     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 6.22 Command Interpreter) - RETRO DOS v4.2 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update:  15/08/2024 (v6.22 - 2024 optimization & bugfix)
     5                                  ;		19/06/2023 (v6.22) ((Previous: 05/05/2023 COMMAND.COM v5.0))
     6                                  ; ----------------------------------------------------------------------------
     7                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     8                                  ; ----------------------------------------------------------------------------
     9                                  ; Assembler: NASM version 2.15 (2.11)
    10                                  ; ----------------------------------------------------------------------------
    11                                  ;	    ((nasm command6.s -l command6.lst -o COMMAND.COM)) 	
    12                                  ; ----------------------------------------------------------------------------
    13                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    14                                  ; by Microsoft, 18/08/1983
    15                                  ; ****************************************************************************
    16                                  ; Modified from 'COMMAND5.S' (MSDOS 5.0 COMMAND.COM) source code
    17                                  ; in NASM syntax (by Erdogan Tan), 05/05/2023
    18                                  ; ----------------------------------------------------------------------------
    19                                  ; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
    20                                  ; in NASM syntax (by Erdogan Tan), 20/10/2018
    21                                  ; ----------------------------------------------------------------------------
    22                                  ;; 11/09/2018 - Erdogan Tan
    23                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    24                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    25                                  ; ----------------------------------------------------------------------------
    26                                  ; MSDOS 6.0 source files:
    27                                  ;;============================================================================
    28                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    29                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    30                                  ;;============================================================================
    31                                  ;
    32                                  ; COMMAND.COM v6.0 source files:
    33                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    34                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    35                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    36                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    37                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    38                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    39                                  ;
    40                                  ; COMMAND.COM v2.11 source files:
    41                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    42                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    43                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    44                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    45                                  ;
    46                                  ; ----------------------------------------------------------------------------
    47                                  ; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)
    48                                  
    49                                  ;============================================================================
    50                                  ; MSDOS 6.22 COMMAND.COM, DISASSEMBLED by Erdogan Tan, 17/05/2023-05/06/2023
    51                                  ;============================================================================
    52                                  
    53                                  ; -=========================================================================¬
    54                                  ; ¦     This file is generated by The Interactive Disassembler (IDA)        ¦
    55                                  ; ¦     Copyright (c) 2010 by Hex-Rays SA, <support@hex-rays.com>           ¦
    56                                  ; ¦                      Licensed to: Freeware version                      ¦
    57                                  ; L=========================================================================-
    58                                  ;
    59                                  ; Input MD5   : FAF051453F215165981F10BD73071D88
    60                                  ;
    61                                  ; File Name   : C:\Users\Erdo­an\Desktop\COMMAND.COM
    62                                  ; Format      : MS-DOS COM-file
    63                                  ; Base Address: 0h Range: 100h-D675h Loaded length: D575h
    64                                  
    65                                  ;============================================================================
    66                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    67                                  ;============================================================================
    68                                  ; 21/09/2018 - Retro DOS v3.0
    69                                  
    70                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    71                                  ;BREAK <system call definitions>
    72                                  
    73                                  ;
    74                                  ;	Microsoft Confidential
    75                                  ;	Copyright (C) Microsoft Corporation 1991
    76                                  ;	All Rights Reserved.
    77                                  ;
    78                                  
    79                                  ;SUBTTL	system call definitions
    80                                  ;PAGE
    81                                  
    82                                  Abort				EQU 0	;  0	  0
    83                                  STD_CON_INPUT			EQU 1	;  1	  1
    84                                  Std_Con_Output			EQU 2	;  2	  2
    85                                  Std_Aux_Input			EQU 3	;  3	  3
    86                                  Std_Aux_Output			EQU 4	;  4	  4
    87                                  Std_Printer_Output		EQU 5	;  5	  5
    88                                  Raw_Con_IO			EQU 6	;  6	  6
    89                                  RAW_CON_INPUT			EQU 7	;  7	  7
    90                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    91                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    92                                  Std_Con_String_Input		EQU 10	; 10	  A
    93                                  Std_Con_Input_Status		EQU 11	; 11	  B
    94                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    95                                  DISK_RESET			EQU 13	; 13	  D
    96                                  Set_Default_Drive		EQU 14	; 14	  E
    97                                  FCB_Open			EQU 15	; 15	  F
    98                                  FCB_Close			EQU 16	; 16	 10
    99                                  Dir_Search_First		EQU 17	; 17	 11
   100                                  Dir_Search_Next 		EQU 18	; 18	 12
   101                                  FCB_Delete			EQU 19	; 19	 13
   102                                  FCB_Seq_Read			EQU 20	; 20	 14
   103                                  FCB_Seq_Write			EQU 21	; 21	 15
   104                                  FCB_Create			EQU 22	; 22	 16
   105                                  FCB_Rename			EQU 23	; 23	 17
   106                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
   107                                  Set_DMA 			EQU 26	; 26	 1A
   108                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   109                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   110                                  ;									   ;
   111                                  Get_Default_DPB 		EQU 31	; 31	 1F
   112                                  ;									   ;
   113                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   114                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   115                                  FCB_Random_Read 		EQU 33	; 33	 21
   116                                  FCB_Random_Write		EQU 34	; 34	 22
   117                                  Get_FCB_File_Length		EQU 35	; 35	 23
   118                                  Get_FCB_Position		EQU 36	; 36	 24
   119                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   120                                  Create_Process_Data_Block	EQU 38	; 38	 26
   121                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   122                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   123                                  Parse_File_Descriptor		EQU 41	; 41	 29
   124                                  Get_Date			EQU 42	; 42	 2A
   125                                  Set_Date			EQU 43	; 43	 2B
   126                                  Get_Time			EQU 44	; 44	 2C
   127                                  Set_Time			EQU 45	; 45	 2D
   128                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   129                                  ; Extended functionality group
   130                                  Get_DMA 			EQU 47	; 47	 2F
   131                                  GET_VERSION			EQU 48	; 48	 30
   132                                  Keep_Process			EQU 49	; 49	 31
   133                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   134                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   135                                  ;									   ;
   136                                  Get_DPB 			EQU 50	; 50	 32
   137                                  ;									   ;
   138                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   139                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   140                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   141                                  Get_InDOS_Flag			EQU 52	; 52	 34
   142                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   143                                  Get_Drive_Freespace		EQU 54	; 54	 36
   144                                  CHAR_OPER			EQU 55	; 55	 37
   145                                  International			EQU 56	; 56	 38
   146                                  ;   Directory Group
   147                                  MKDir				EQU 57	; 57	 39
   148                                  RMDir				EQU 58	; 58	 3A
   149                                  CHDir				EQU 59	; 59	 3B
   150                                  ;   File Group
   151                                  Creat				EQU 60	; 60	 3C
   152                                  OPEN				EQU 61	; 61	 3D
   153                                  CLOSE				EQU 62	; 62	 3E
   154                                  READ				EQU 63	; 63	 3F
   155                                  Write				EQU 64	; 64	 40
   156                                  Unlink				EQU 65	; 65	 41
   157                                  LSEEK				EQU 66	; 66	 42
   158                                  CHMod				EQU 67	; 67	 43
   159                                  IOCTL				EQU 68	; 68	 44
   160                                  XDUP				EQU 69	; 69	 45
   161                                  XDup2				EQU 70	; 70	 46
   162                                  Current_Dir			EQU 71	; 71	 47
   163                                  ;    Memory Group
   164                                  ALLOC				EQU 72	; 72	 48
   165                                  DEALLOC				EQU 73	; 73	 49
   166                                  SETBLOCK			EQU 74	; 74	 4A
   167                                  ;    Process Group
   168                                  Exec				EQU 75	; 75	 4B
   169                                  EXIT				EQU 76	; 76	 4C
   170                                  WAITPROCESS			EQU 77	; 77	 4D
   171                                  Find_First			EQU 78	; 78	 4E
   172                                  ;   Special Group
   173                                  Find_Next			EQU 79	; 79	 4F
   174                                  ; SPECIAL SYSTEM GROUP
   175                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   176                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   177                                  ;									   ;
   178                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   179                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   180                                  Get_In_Vars			EQU 82	; 82	 52
   181                                  SetDPB				EQU 83	; 83	 53
   182                                  ;									   ;
   183                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   184                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   185                                  Get_Verify_On_Write		EQU 84	; 84	 54
   186                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   187                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   188                                  ;									   ;
   189                                  Dup_PDB 			EQU 85	; 85	 55
   190                                  ;									   ;
   191                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   192                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   193                                  Rename				EQU 86	; 86	 56
   194                                  File_Times			EQU 87	; 87	 57
   195                                  AllocOper			EQU 88	; 88	 58
   196                                  ; Network extention system calls
   197                                  GetExtendedError		EQU 89	; 89	 59
   198                                  CreateTempFile			EQU 90	; 90	 5A
   199                                  CreateNewFile			EQU 91	; 91	 5B
   200                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   201                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   202                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   203                                  ;									   ;
   204                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   205                                  					;	    CloseByName, CloseUser,
   206                                  					;	    CloseUserProcess,
   207                                  					;	    GetOpenFileList
   208                                  ;									   ;
   209                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   210                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   211                                  UserOper			EQU 94	; 94	 5E Get and Set
   212                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   213                                  xNameTrans			EQU 96	; 96	 60
   214                                  PathParse			EQU 97	; 97	 61
   215                                  GetCurrentPSP			EQU 98	; 98	 62
   216                                  Hongeul 			EQU 99	; 99	 63
   217                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   218                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   219                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   220                                  ;									   ;
   221                                  Set_Printer_Flag		EQU 100 ; 100	 64
   222                                  ;									   ;
   223                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   224                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   225                                  GetExtCntry			EQU 101 ; 101	 65
   226                                  GetSetCdPg			EQU 102 ; 102	 66
   227                                  ExtHandle			EQU 103 ; 103	 67
   228                                  Commit				EQU 104 ; 104	 68
   229                                  GetSetMediaID			EQU 105 ; 105	 69
   230                                  IFS_IOCTL			EQU 107 ; 107	 6B
   231                                  ExtOpen 			EQU 108 ; 108	 6C
   232                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   233                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   234                                  ;                                                                          ;
   235                                  ;ifdef ROMEXEC
   236                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   237                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   238                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
   239                                  ;endif
   240                                  ;                                                                          ;
   241                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   242                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   243                                  ;
   244                                  ;
   245                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   246                                  OEM_C1				EQU 249 ; 249	 F9
   247                                  OEM_C2				EQU 250 ; 250	 FA
   248                                  OEM_C3				EQU 251 ; 251	 FB
   249                                  OEM_C4				EQU 252 ; 252	 FC
   250                                  OEM_C5				EQU 253 ; 253	 FD
   251                                  OEM_C6				EQU 254 ; 254	 FE
   252                                  OEM_C7				EQU 255 ; 255	 FF
   253                                  
   254                                  ;============================================================================
   255                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   256                                  ;============================================================================
   257                                  ; 21/09/2018 - Retro DOS v3.0
   258                                  
   259                                  ;BREAK <Control character definitions>
   260                                  
   261                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   262                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   263                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   264                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   265                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   266                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   267                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   268                                  c_HT	    EQU     09h 	; ^I ASCII tab
   269                                  
   270                                  ;============================================================================
   271                                  ; DIRENT.INC, MSDOS 6.0, 1991
   272                                  ;============================================================================
   273                                  ; 21/09/2018 - Retro DOS v3.0
   274                                  
   275                                  ;Break <Directory entry>
   276                                  
   277                                  ;	NOTE:  These offsets are also used in the DTA for
   278                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   279                                  ;	with the FCB filename field, and the rest of the
   280                                  ;	DIR_ENTRY fields follow. -DavidOls
   281                                  
   282                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   283                                  ;
   284                                  ;	+---------------------------+
   285                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   286                                  ;	+---------------------------+
   287                                  ;	|     (BYTE) attributes     |	    11	    B
   288                                  ;	+---------------------------+
   289                                  ;	|    (10 BYTE) reserved     |	    12	    C
   290                                  ;	+---------------------------+
   291                                  ;	| (WORD) time of last write |	    22	    16
   292                                  ;	+---------------------------+
   293                                  ;	| (WORD) date of last write |	    24	    18
   294                                  ;	+---------------------------+
   295                                  ;	|   (WORD) First cluster    |	    26	    1A
   296                                  ;	+---------------------------+
   297                                  ;	|     (DWORD) file size     |	    28	    1C
   298                                  ;	+---------------------------+
   299                                  ;
   300                                  ;   First byte of filename  = E5 -> free directory entry
   301                                  ;			    = 00 -> end of allocated directory
   302                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   303                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   304                                  ;
   305                                  
   306                                  STRUC DIR_ENTRY
   307 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   308 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   309 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   310 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   311 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   312 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   313 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   314 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   315 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   316 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   317 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   318                                  .size:
   319                                  
   320                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   321                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   322                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   323                                  ;	    this field is zero for subdirectory files.
   324                                  
   325                                  ENDSTRUC
   326                                  
   327                                  ATTR_READ_ONLY	equ	 1h
   328                                  ATTR_HIDDEN	equ	 2h
   329                                  ATTR_SYSTEM	equ	 4h
   330                                  ATTR_VOLUME_ID	equ	 8h
   331                                  ATTR_DIRECTORY	equ	10h
   332                                  ATTR_ARCHIVE	equ	20h
   333                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   334                                  				;   NO directory entry on a disk EVER
   335                                  				;   has this bit set. It is set non-zero
   336                                  				;   when a device is found by GETPATH
   337                                  
   338                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   339                                  				; OR of hard attributes for FINDENTRY
   340                                  
   341                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   342                                  				; ignore this(ese) attribute(s) during
   343                                  				; search first/next
   344                                  
   345                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   346                                  				; changeable via CHMOD
   347                                  
   348                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   349                                  
   350                                  ;============================================================================
   351                                  ; ERROR.INC, MSDOS 6.0, 1991
   352                                  ;============================================================================
   353                                  ; 21/09/2018 - Retro DOS v3.0
   354                                  
   355                                  ;**	ERROR.INC - DOS Error Codes
   356                                  ;
   357                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   358                                  ;    return error codes through AX.	If an error occurred then
   359                                  ;    the carry bit will be set and the error code is in AX.	If no error
   360                                  ;    occurred then the carry bit is reset and AX contains returned info.
   361                                  ;
   362                                  ;    Since the set of error codes is being extended as we extend the operating
   363                                  ;    system, we have provided a means for applications to ask the system for a
   364                                  ;    recommended course of action when they receive an error.
   365                                  ;
   366                                  ;    The GetExtendedError system call returns a universal error, an error
   367                                  ;    location and a recommended course of action.	The universal error code is
   368                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   369                                  ;    is issued.
   370                                  
   371                                  
   372                                  ;	2.0 error codes
   373                                  
   374                                  error_invalid_function		EQU	1
   375                                  ERROR_FILE_NOT_FOUND		EQU	2
   376                                  ERROR_PATH_NOT_FOUND		EQU	3
   377                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   378                                  ERROR_ACCESS_DENIED		EQU	5
   379                                  error_invalid_handle		EQU	6
   380                                  error_arena_trashed		EQU	7
   381                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   382                                  error_invalid_block		EQU	9
   383                                  error_bad_environment		EQU	10
   384                                  ERROR_BAD_FORMAT		EQU	11
   385                                  error_invalid_access		EQU	12
   386                                  ERROR_INVALID_DATA		EQU	13
   387                                  ;**** reserved			EQU	14	; *****
   388                                  error_invalid_drive		EQU	15
   389                                  error_current_directory 	EQU	16
   390                                  error_not_same_device		EQU	17
   391                                  ERROR_NO_MORE_FILES		EQU	18
   392                                  
   393                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   394                                  
   395                                  ERROR_WRITE_PROTECT		EQU	19
   396                                  error_bad_unit			EQU	20
   397                                  error_not_ready 		EQU	21
   398                                  error_bad_command		EQU	22
   399                                  error_CRC			EQU	23
   400                                  error_bad_length		EQU	24
   401                                  error_Seek			EQU	25
   402                                  error_not_DOS_disk		EQU	26
   403                                  error_sector_not_found		EQU	27
   404                                  error_out_of_paper		EQU	28
   405                                  error_write_fault		EQU	29
   406                                  error_read_fault		EQU	30
   407                                  ERROR_GEN_FAILURE		EQU	31
   408                                  
   409                                  ;	the new 3.0 error codes reported through INT 24
   410                                  
   411                                  error_sharing_violation 	EQU	32
   412                                  error_lock_violation		EQU	33
   413                                  error_wrong_disk		EQU	34
   414                                  ERROR_FCB_UNAVAILABLE		EQU	35
   415                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   416                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   417                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   418                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   419                                  
   420                                  ;	New OEM network-related errors are 50-79
   421                                  
   422                                  error_not_supported		EQU	50
   423                                  
   424                                  error_net_access_denied		EQU	65	;M028
   425                                  
   426                                  ;	End of INT 24 reportable errors
   427                                  
   428                                  error_file_exists		EQU	80
   429                                  error_DUP_FCB			EQU	81	; *****
   430                                  error_cannot_make		EQU	82
   431                                  error_FAIL_I24			EQU	83
   432                                  
   433                                  ;	New 3.0 network related error codes
   434                                  
   435                                  error_out_of_structures 	EQU	84
   436                                  error_Already_assigned		EQU	85
   437                                  error_invalid_password		EQU	86
   438                                  error_invalid_parameter 	EQU	87
   439                                  error_NET_write_fault		EQU	88
   440                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   441                                  
   442                                  ;============================================================================
   443                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   444                                  ;============================================================================
   445                                  ; 22/09/2018 - Retro DOS v3.0
   446                                  
   447                                  ;**	DevSym.inc - Device Symbols
   448                                  
   449                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   450                                  
   451                                  STRUC SYSDEV
   452 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   453 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   454 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   455 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   456 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   457                                  .size:
   458                                  ENDSTRUC
   459                                  
   460                                  ; 24/09/2018
   461                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   462                                  
   463                                  ;============================================================================
   464                                  ; CURDIR.INC, MSDOS 6.0, 1991
   465                                  ;============================================================================
   466                                  ; 21/09/2018 - Retro DOS v3.0
   467                                  
   468                                  DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings
   469                                  
   470                                  ;============================================================================
   471                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   472                                  ;============================================================================
   473                                  ; 21/09/2018 - Retro DOS v3.0
   474                                  
   475                                  ;/*
   476                                  ; *                      Microsoft Confidential
   477                                  ; *                      Copyright (C) Microsoft Corporation 1991
   478                                  ; *                      All Rights Reserved.
   479                                  ; */
   480                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   481                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   482                                  ;*************************************
   483                                  ; COMMAND EQUs which are not switch dependant
   484                                  
   485                                  ;		include	curdir.inc	; to get DIRSTRLEN
   486                                  ;		Note dossym.inc must already have been included!
   487                                  
   488                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   489                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   490                                  
   491                                  SYM		EQU	">"
   492                                  
   493                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   494                                  
   495                                  NORMPERLIN	EQU	1
   496                                  WIDEPERLIN	EQU	5
   497                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   498                                  BatLen		EQU	32		; buffer for batch files
   499                                  YES_ECHO	EQU	1		; echo line
   500                                  NO_ECHO 	EQU	0		; don't echo line
   501                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   502                                  call_in_progress EQU	1		; indicate we're in the CALL command
   503                                  length_call	EQU	4		; length of CALL
   504                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   505                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   506                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   507                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   508                                  nullcommand	EQU     1		; no command on command line
   509                                  END_OF_LINE	EQU    -1		;AN000; end of line return from parser
   510                                  END_OF_LINE_OUT EQU	0		;AN000; end of line for output
   511                                  END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
   512                                  result_number	EQU	1		;AN000; number returned from parser
   513                                  result_string	EQU	3		;AN000; string returned from parser
   514                                  RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
   515                                  result_drive	EQU	6		;AN000; drive returned from parser
   516                                  result_date	EQU	7		;AN000; date returned from parser
   517                                  result_time	EQU	8		;AN000; time returned from parser
   518                                  RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
   519                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   520                                  util_msg_class	EQU	-1		;AN000; message class for utility
   521                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   522                                  parse_msg_class EQU	2		;AN000; message class for parse error
   523                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   524                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   525                                  colon_char	EQU	":"             ;AN000; colon character
   526                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   527                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   528                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   529                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   530                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   531                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   532                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   533                                  shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
   534                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   535                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   536                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   537                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   538                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   539                                  parm_block_size equ	11		;AN000; size of message subst block
   540                                  blank		equ	" "             ;AN000; blank character
   541                                  no_subst	equ	0		;AN000; no substitutions for messages
   542                                  one_subst	equ	1		;AN000; one substitution for messages
   543                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   544                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   545                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   546                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   547                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   548                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   549                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   550                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   551                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   552                                  capital_A	equ	'A'             ;AC000;
   553                                  vbar		equ	'|'             ;AC000;
   554                                  labracket	equ	'<'             ;AC000;
   555                                  rabracket	equ	'>'             ;AC000;
   556                                  dollar		equ	'$'             ;AC000;
   557                                  lparen		equ	'('             ;AC000;
   558                                  rparen		equ	')'             ;AC000;
   559                                  nullrparen	equ	29h		;AC000;
   560                                  in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
   561                                  do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
   562                                  star		equ	'*'             ;AC000;
   563                                  plus_chr	equ	'+'             ;AC000;
   564                                  small_a 	equ	'a'             ;AC000;
   565                                  small_z 	equ	'z'             ;AC000;
   566                                  dot_chr 	equ	'.'             ;AC000;
   567                                  tab_chr 	equ	9		;AN032;
   568                                  equal_chr	equ	'='             ;AN032;
   569                                  semicolon	equ	';'             ;AN049;
   570                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   571                                  dot_colon	equ	2e3ah		;AC000; '.:'
   572                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   573                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   574                                  AppendInstall	equ	0B700H		;AN020; append install check
   575                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   576                                  AppendGetState	equ	0B706H		;AN020; append get current state
   577                                  AppendSetState	equ	0B707H		;AN020; append set current state
   578                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   579                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   580                                  
   581                                  ;*************************************
   582                                  ;* PARSE ERROR MESSAGES
   583                                  ;*************************************
   584                                  
   585                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   586                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   587                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   588                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   589                                  
   590                                  ;*************************************
   591                                  ;* EQUATES FOR MESSAGE RETRIEVER
   592                                  ;*************************************
   593                                  
   594                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   595                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   596                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   597                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   598                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   599                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   600                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   601                                  
   602                                  ;*********************************
   603                                  ;* EQUATES FOR INT 10H
   604                                  ;*********************************
   605                                  
   606                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   607                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   608                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   609                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   610                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   611                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   612                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   613                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   614                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   615                                  
   616                                  AltPipeChr	equ	"|"             ; alternate pipe character
   617                                  
   618                                  FCB		equ	5Ch
   619                                  
   620                                  STRUC VARSTRUC
   621 00000000 ??                      .ISDIR:		RESB	1
   622 00000001 ??                      .SIZ:		RESB	1
   623 00000002 ????                    .TTAIL:		RESW	1
   624 00000004 ??                      .INFO:		RESB	1
   625 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   626                                  .size:
   627                                  ENDSTRUC
   628                                  ;
   629                                  ; Flags for internal command parsing
   630                                  ;
   631                                  fCheckDrive	equ	00000001b	; validate drive letter
   632                                  fSwitchAllowed	equ	00000010b	; switches allowed
   633                                  fLimitHelp	equ	00000100b	; /? must appear alone
   634                                  
   635                                  ;
   636                                  ; Test switches
   637                                  ;
   638                                  fParse		EQU	0001h		; display results of parseline
   639                                  
   640                                  ;
   641                                  ; Batch segment structure
   642                                  ;
   643                                  ;   BYTE    type of segment
   644                                  ;   BYTE    echo state of parent on entry to batch file
   645                                  ;   WORD    segment of last batch file
   646                                  ;   WORD    segment for FOR command
   647                                  ;   BYTE    FOR flag state on entry to batch file
   648                                  ;   DWORD   offset for next line
   649                                  ;   10 WORD pointers to parameters. -1 is empty parameter
   650                                  ;   ASCIZ   file name (with . and ..)
   651                                  ;   BYTES   CR-terminated parameters
   652                                  ;   BYTE    0 flag to indicate end of parameters
   653                                  ;
   654                                  
   655                                  BATCHTYPE   equ 0
   656                                  
   657                                  STRUC BATCHSEGMENT
   658 00000000 ??                      .BatType:	RESB	1		; signature
   659 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   660                                  ; MSDOS 5.0 (& 6.0) - 11/01/2023
   661 00000002 ??                      .BatchEOF:	RESB	1		; records if EOF reached on file
   662 00000003 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   663 00000005 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   664 00000007 ??                      .BatForFlag:	RESB	1		; G state of FOR
   665 00000008 ????????                .BatSeek:	RESD	1		; lseek position of next char
   666 0000000C <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   667 00000020 ??                      .BatFile:	RESB	1		; beginning of batch file name
   668                                  .SIZE:
   669                                  ENDSTRUC
   670                                  
   671                                  ANULL		equ	0		; terminates an argv string
   672                                  ARGMAX		equ	64		; max args on a command line
   673                                  ;ARGBLEN 	equ	2*128		; 1char each plus term NUL
   674                                  ; 27/07/2024 - PCDOS 7.1 COMMAND.COM ;*
   675                                  ARGBLEN 	equ	2*64
   676                                  tplen		equ	64		; max size of one argument
   677                                  arg_cnt_error	equ	1		; number of args > MAXARG
   678                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   679                                  
   680                                  STRUC ARGV_ELE				; elements in the argv array
   681 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   682 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   683 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   684 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   685 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   686 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   687                                  .SIZE:	; 11 ; 27/07/2024
   688                                  ENDSTRUC
   689                                  
   690                                  STRUC ARG_UNIT
   691 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   692 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   693 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   694 000002C4 <res 100h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   695 000003C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   696                                  .SIZE:	; 1092 ; 27/07/2024 ; (it was 1348 in MSDOS 5.0-6.22 COMMAND.COM) ;*
   697                                  ENDSTRUC
   698                                  
   699                                  ; Equates for initialization
   700                                  ;
   701                                  INITINIT	equ	01h		; initialization in progress
   702                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   703                                  INITCTRLC	equ	04h		; already in ^C handler
   704                                  
   705                                  ;============================================================================
   706                                  ;  INTNAT.INC, MSDOS 6.0, 1991
   707                                  ;============================================================================
   708                                  ; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   709                                  
   710                                  ; Current structure of the data returned by the international call
   711                                  
   712                                  struc INTERNAT_BLOCK
   713 00000000 ????                    .date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
   714 00000002 ??????????              .currency_sym:	resb 5			; Currency Symbol 5 bytes
   715 00000007 ????                    .thous_sep:	resb 2			; Thousands separator 2 bytes
   716 00000009 ????                    .decimal_sep:	resb 2			; Decimal separator 2 bytes
   717 0000000B ????                    .date_sep:	resb 2			; Date separator 2 bytes
   718 0000000D ????                    .time_sep:	resb 2			; Decimal separator 2 bytes
   719 0000000F ??                      .bit_field:	resb 1			; Bit values
   720                                  					;   Bit 0 = 0 if currency symbol first
   721                                  					;	  = 1 if currency symbol last
   722                                  					;   Bit 1 = 0 if No space after currency symbol
   723                                  					;	  = 1 if space after currency symbol
   724                                  .currency_cents:
   725 00000010 ??                      		resb 1			; Number of places after currency dec point
   726 00000011 ??                      .time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
   727 00000012 ????????                .map_call:	resw 2			; Address of case mapping call (DWORD)
   728                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   729                                  					;  in pieces.
   730 00000016 ??                      .data_sep:	resb 1			; Data list separator character
   731 00000017 ??                      		resb 1
   732                                  endstruc
   733                                  
   734                                  ; Max size of the block returned by the INTERNATIONAL call
   735                                  
   736                                  internat_block_max equ 32
   737                                  
   738                                  ;============================================================================
   739                                  ; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
   740                                  ;============================================================================
   741                                  ; 13/10/2018 - Retro DOS v3.0
   742                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
   743                                  
   744                                  ;Break	<find first/next buffer>
   745                                  
   746                                  	; MSDOS 3.3 & MSDOS 6.0
   747                                  
   748                                  struc FIND_BUF
   749 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   750 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   751 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   752 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   753 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   754 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   755 00000015 ??                      .ATTR:	    resb 1	; attribute found
   756 00000016 ????                    .TIMR:	    resw 1	; time
   757 00000018 ????                    .DATE:	    resw 1	; date
   758 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   759 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   760 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   761                                  .size:
   762                                  endstruc
   763                                  
   764                                  ;=============================================================================
   765                                  ; PDB.INC, MSDOS 6.0, 1991
   766                                  ;=============================================================================
   767                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   768                                  
   769                                  ;**	Process data block (otherwise known as program header)
   770                                  
   771                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   772                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   773                                  ;	for use.
   774                                  
   775                                  FILPERPROC	EQU     20
   776                                  
   777                                  struc PDB	; Process_data_block
   778 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   779 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   780 00000004 ??                                      resb 1
   781 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   782 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   783 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   784 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   785 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   786 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   787 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   788 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   789 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   790 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   791 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   792 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   793 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   794 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   795 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   796 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   797 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   798 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   799                                  				;  an extended FCB
   800                                  ;endstruc 	; MSDOS 3.3
   801                                  	  	; MSDOS 6.0
   802 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   803 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   804 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   805 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   806                                  endstruc
   807                                  
   808                                  ;=============================================================================
   809                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   810                                  ;=============================================================================
   811                                  ; 24/09/2018 - Retro DOS v3.0
   812                                  
   813                                  ;major_version	equ 6		; Major DOS version
   814                                  ;minor_version	equ 0		; Minor DOS Version
   815                                  
   816                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   817                                  
   818                                  ; MSDOS 3.3 COMMAND.COM
   819                                  ;MAJOR_VERSION	EQU 3
   820                                  ;MINOR_VERSION	EQU 30
   821                                  
   822                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
   823                                  ;MAJOR_VERSION	EQU 5		; Major DOS version
   824                                  ;MINOR_VERSION	EQU 0		; Minor DOS version
   825                                  
   826                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
   827                                  MAJOR_VERSION	EQU 6		; Major DOS version
   828                                  MINOR_VERSION	EQU 22		; Minor DOS version
   829                                  
   830                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   831                                  
   832                                  ;-----------------------------------------------------------------------------
   833                                  ; 21/09/2018
   834                                  ;-----------------------------------------------------------------------------
   835                                  ; Retro DOS v3.0 NOTE:  
   836                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   837                                  ;	with minor modifications which are done by me (Erdogan Tan).
   838                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   839                                  ;	source code files (written by using MASM syntax).
   840                                  ;-----------------------------------------------------------------------------
   841                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   842                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   843                                  ;----------------------------------------------------------------------------- 	
   844                                  
   845                                  ;=============================================================================
   846                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   847                                  ;=============================================================================
   848                                  ; 21/09/2018 - Retro DOS v3.0
   849                                  
   850                                  ;	page ,132
   851                                  ;	title	COMMAND - resident code for COMMAND.COM
   852                                  ;	name	COMMAND
   853                                  
   854                                  ;/*
   855                                  ; *                      Microsoft Confidential
   856                                  ; *                      Copyright (C) Microsoft Corporation 1991
   857                                  ; *                      All Rights Reserved.
   858                                  ; */
   859                                  
   860                                  ;*****************************************************************************
   861                                  ;
   862                                  ; MODULE:	       COMMAND.COM
   863                                  ;
   864                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   865                                  ;
   866                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   867                                  ;		       parts.  First is the resident portion, which includes
   868                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   869                                  ;		       error), and 2EH (command line execute); it also has
   870                                  ;		       code to test and, if necessary, reload the transient
   871                                  ;		       portion. Following the resident is the init code, which
   872                                  ;		       is overwritten after use.  Then comes the transient
   873                                  ;		       portion, which includes all command processing (whether
   874                                  ;		       internal or external).  The transient portion loads at
   875                                  ;		       the end of physical memory, and it may be overlayed by
   876                                  ;		       programs that need as much memory as possible. When the
   877                                  ;		       resident portion of command regains control from a user
   878                                  ;		       program, a check sum is performed on the transient
   879                                  ;		       portion to see if it must be reloaded.  Thus programs
   880                                  ;		       which do not need maximum memory will save the time
   881                                  ;		       required to reload COMMAND when they terminate.
   882                                  ;
   883                                  ; ENTRY POINT:	       PROGSTART
   884                                  ;
   885                                  ; INPUT:	       command line at offset 81H
   886                                  ;
   887                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   888                                  ;		       from a secondary command processor via the EXIT
   889                                  ;		       internal command.
   890                                  ;
   891                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   892                                  ;		       hang the system.
   893                                  ;
   894                                  ; INTERNAL REFERENCES:
   895                                  ;
   896                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   897                                  ;		       (COMMAND.DOC)
   898                                  ;
   899                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   900                                  ;		       (COMMAND.DOC)
   901                                  ;
   902                                  ; EXTERNAL REFERENCES:
   903                                  ;
   904                                  ;      ROUTINES:       none
   905                                  ;
   906                                  ;      DATA AREAS:     none
   907                                  ;
   908                                  ;*****************************************************************************
   909                                  ;
   910                                  ;			      REVISION HISTORY
   911                                  ;			      ----------------
   912                                  ;
   913                                  ; DOS 1.00 to DOS 3.30
   914                                  ; --------------------------
   915                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   916                                  ;
   917                                  ; REV 1.17
   918                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   919                                  ;	       resident since the EXELOAD may have overwritten the transient.
   920                                  ;
   921                                  ; REV 1.18
   922                                  ;    05/21/82  IBM version always looks on drive A
   923                                  ;	       MSVER always looks on default drive
   924                                  ;
   925                                  ; REV 1.19
   926                                  ;    06/03/82  Drive spec now entered in command line
   927                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   928                                  ;	       (print volume label)
   929                                  ;
   930                                  ; REV 1.20
   931                                  ;    06/09/82  Prints "directory" after directories
   932                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   933                                  ;
   934                                  ; REV 1.50
   935                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   936                                  ;	       do it right.
   937                                  ;
   938                                  ; REV 1.70
   939                                  ;	       EXEC used to fork off new processes
   940                                  ;
   941                                  ; REV 1.80
   942                                  ;	       C switch for single command execution
   943                                  ;
   944                                  ; REV 1.90
   945                                  ;	       Batch uses XENIX
   946                                  ;
   947                                  ; Rev 2.00
   948                                  ;	       Lots of neato stuff
   949                                  ;	       IBM 2.00 level
   950                                  ;
   951                                  ; Rev 2.01
   952                                  ;	       'D' switch for date time suppression
   953                                  ;
   954                                  ; Rev 2.02
   955                                  ;	       Default userpath is NUL rather than BIN
   956                                  ;		       same as IBM
   957                                  ;	       COMMAND split into pieces
   958                                  ;
   959                                  ; Rev 2.10
   960                                  ;	       INTERNATIONAL SUPPORT
   961                                  ;
   962                                  ; Rev 2.50
   963                                  ;	       all the 2.x new stuff -MU
   964                                  ;
   965                                  ; Rev 3.30     (Ellen G)
   966                                  ;	       CALL internal command (TBATCH2.ASM)
   967                                  ;	       CHCP internal command (TCMD2B.ASM)
   968                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   969                                  ;	       @ sign suppression of batch file line
   970                                  ;	       Replaceable environment value support in batch files
   971                                  ;	       INT 2FH calls for APPEND
   972                                  ;	       Lots of PTR fixes!
   973                                  ;
   974                                  ; Beyond 3.30 to forever  (Ellen G)
   975                                  ; ----------------------
   976                                  ;
   977                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   978                                  ;			Use Message Retriever services
   979                                  ;			/MSG switch for resident extended error msg
   980                                  ;			Convert to new capitalization support
   981                                  ;			Better error recovery on CHCP command
   982                                  ;			Code page file tag support
   983                                  ;			TRUENAME internal command
   984                                  ;			Extended screen line support
   985                                  ;			/P switch on DEL/ERASE command
   986                                  ;			Improved file redirection error recovery
   987                                  ;	(removed)	Improved batch file performance
   988                                  ;			Unconditional DBCS support
   989                                  ;			Volume serial number support
   990                                  ;	(removed)	COMMENT=?? support
   991                                  ;
   992                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   993                                  ;
   994                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   995                                  ;			require delimiters.
   996                                  ;
   997                                  ; A003	PTM P5,P9,P111	Included in A000 development
   998                                  ;
   999                                  ; A004	PTM P86 	Fix IF command to turn off piping before
  1000                                  ;			executing
  1001                                  ;
  1002                                  ; A005	DCR D17 	If user specifies an extension on the command
  1003                                  ;			line search for that extension only.
  1004                                  ;
  1005                                  ; A006	DCR D15 	New message for MkDir - "Directory already
  1006                                  ;			exists"
  1007                                  ;
  1008                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
  1009                                  ;
  1010                                  ; A008	PTM P182	Change COPY to set default if invalid function
  1011                                  ;			returned from code page call.
  1012                                  ;
  1013                                  ; A009	PTM P179	Add CRLF to invalid disk change message
  1014                                  ;
  1015                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
  1016                                  ;			transient COMMAND.
  1017                                  ;
  1018                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
  1019                                  ;			before appending to a file.
  1020                                  ;
  1021                                  ; A012	PTM P189	Fix redirection error recovery.
  1022                                  ;
  1023                                  ; A013	PTM P330	Change date format
  1024                                  ;
  1025                                  ; A014	PTM P455	Fix echo parsing
  1026                                  ;
  1027                                  ; A015	PTM P517	Fix DIR problem with * vs *.
  1028                                  ;
  1029                                  ; A016	PTM P354	Fix extended error message addressing
  1030                                  ;
  1031                                  ; A017	PTM P448	Fix appending to 0 length files
  1032                                  ;
  1033                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
  1034                                  ;			the parser fails on. Fail on duplicate switches.
  1035                                  ;
  1036                                  ; A019	PTM P542	Fix device name to be printed correctly during
  1037                                  ;			critical error
  1038                                  ;
  1039                                  ; A020	DCR D43 	Set append state off while in DIR
  1040                                  ;
  1041                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
  1042                                  ;
  1043                                  ; A022	DCR D209	Enhanced error recovery
  1044                                  ;
  1045                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
  1046                                  ;
  1047                                  ; A024	PTM P899	Fix EXTOPEN open modes.
  1048                                  ;
  1049                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
  1050                                  ;
  1051                                  ; A026	DCR D191	Change redirection error recovery support.
  1052                                  ;
  1053                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
  1054                                  ;			with a carriage return.
  1055                                  ;
  1056                                  ; A028	PTM P1076	Print a blank line before printing invalid
  1057                                  ;			date and invalid time messages.
  1058                                  ;
  1059                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
  1060                                  ;			and TIME.
  1061                                  ;
  1062                                  ; A030	DCR D201	New extended attribute format.
  1063                                  ;
  1064                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
  1065                                  ;
  1066                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
  1067                                  ;
  1068                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
  1069                                  ;
  1070                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
  1071                                  ;
  1072                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
  1073                                  ;			do a read to determine eof.
  1074                                  ;
  1075                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
  1076                                  ;			so that ASSIGN works correctly.
  1077                                  ;
  1078                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
  1079                                  ;
  1080                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
  1081                                  ;
  1082                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
  1083                                  ;
  1084                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
  1085                                  ;			specified.
  1086                                  ;
  1087                                  ; A041	PTM P1705	Close redirected files after internal APPEND
  1088                                  ;			executes.
  1089                                  ;
  1090                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
  1091                                  ;			files causing loss of batch file.
  1092                                  ;
  1093                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1094                                  ;			CALL'ed batch files.
  1095                                  ;
  1096                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1097                                  ;			as an end of line character
  1098                                  ;
  1099                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1100                                  ;			and extended message pointers when we EXIT if
  1101                                  ;			COMMAND /P is the top level process.
  1102                                  ;
  1103                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1104                                  ;			"File not found - fn"
  1105                                  ;
  1106                                  ; A047	PTM P2819	Fix transient reload prompt message
  1107                                  ;
  1108                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1109                                  ;			when DBCS code was added.
  1110                                  ;
  1111                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1112                                  ;			on line.
  1113                                  ;
  1114                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1115                                  ;
  1116                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1117                                  ;
  1118                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1119                                  ;
  1120                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1121                                  ;
  1122                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1123                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1124                                  ;
  1125                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1126                                  ;			problems with breaking out of INT 24h
  1127                                  ;
  1128                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1129                                  ;
  1130                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1131                                  ;			before the "string".  EX: COMMAND /CDIR
  1132                                  ;
  1133                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1134                                  ;			DBCS switch.
  1135                                  ;
  1136                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1137                                  ;			the time.
  1138                                  ;
  1139                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1140                                  ;			messages to be disk based.  Only keep them if /MSG
  1141                                  ;			is used.
  1142                                  ;
  1143                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1144                                  ;			out of internal commands, due to substitution blocks
  1145                                  ;			not being reset.
  1146                                  ;
  1147                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1148                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1149                                  ;			secondary copy of environment.	Change default slash in
  1150                                  ;			default comspec string to backslash.
  1151                                  ;
  1152                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1153                                  ;			text for critical error messages.
  1154                                  ;
  1155                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1156                                  ;	5/20/88 	with Microsoft product already shipped.
  1157                                  ;
  1158                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1159                                  ;	 5/20/88	with Microsoft product already shipped.
  1160                                  ;
  1161                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1162                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1163                                  ;			header and space remaining.
  1164                                  ;
  1165                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1166                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1167                                  ;			environment was putting a "Z block" marker in the old
  1168                                  ;			environment.  The fix is to move to the old environment
  1169                                  ;			to the new environment before doing the SETBLOCK.
  1170                                  ;
  1171                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1172                                  ;        09/19/88       because the check for APPEND needed to be performed
  1173                                  ;                       before the DIR's findfirst.
  1174                                  ;
  1175                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1176                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1177                                  ;                       loading trans w/new comspec with no user change comspec.
  1178                                  ;
  1179                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1180                                  ;        11/05/88       Expansion of environment variables into batch line of
  1181                                  ;                       128 chars was not being counted and "%" which should be
  1182                                  ;                       ignored were being counted.
  1183                                  ;
  1184                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1185                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1186                                  ;                       ing included in checksum and was being overwritten by
  1187                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1188                                  ;                       Also removed fix A069 (because flag now protected).
  1189                                  ;
  1190                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1191                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1192                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1193                                  ;
  1194                                  ;***********************************************************************************
  1195                                  
  1196                                  ;
  1197                                  ;	Revision History
  1198                                  ;	================
  1199                                  ;
  1200                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1201                                  ;					at init time (date/time prompt)
  1202                                  ;
  1203                                  
  1204                                  ;
  1205                                  ;.xcref
  1206                                  ;.xlist
  1207                                  ;	include dossym.inc		; basic DOS symbol set
  1208                                  ;	include syscall.inc		; DOS function names
  1209                                  ;	include comsw.asm		; build version info
  1210                                  ;	include comequ.asm		; common command.com symbols
  1211                                  ;	include resmsg.equ		; resident message names
  1212                                  ;
  1213                                  ;	include comseg.asm		;segment ordering
  1214                                  ;.list
  1215                                  ;.cref
  1216                                  
  1217                                  ;CODERES segment public byte
  1218                                  ;CODERES ends
  1219                                  ;
  1220                                  ;DATARES 	segment public byte
  1221                                  ;		extrn	AccDen:byte
  1222                                  ;		extrn	Batch:word
  1223                                  ;		extrn	EchoFlag:byte
  1224                                  ;		extrn	ExeBad:byte
  1225                                  ;		extrn	ExecEMes:byte
  1226                                  ;		extrn	ExecErrSubst:byte
  1227                                  ;		extrn	ExtCom:byte
  1228                                  ;		extrn	ForFlag:byte
  1229                                  ;		extrn	IfFlag:byte
  1230                                  ;		extrn	InitFlag:BYTE
  1231                                  ;		extrn	Nest:word
  1232                                  ;		extrn	PipeFlag:byte
  1233                                  ;		extrn	RBadNam:byte
  1234                                  ;		extrn	RetCode:word
  1235                                  ;		extrn	SingleCom:word
  1236                                  ;		extrn	TooBig:byte
  1237                                  ;
  1238                                  ;		extrn	OldDS:word
  1239                                  ;
  1240                                  ;DATARES 	ends
  1241                                  ;
  1242                                  ;
  1243                                  ;INIT		segment public para
  1244                                  ;		extrn	ConProc:near
  1245                                  ;		extrn	Init_Contc_SpecialCase:near
  1246                                  ;INIT		ends
  1247                                  
  1248                                  ; 09/01/2023 - Erdogan Tan - Istanbul
  1249                                  ; --------------------------------------
  1250                                  ; 'command5.s' source code reference(s):
  1251                                  
  1252                                  ;	1) MSDOS 6.0 COMMAND.COM source files
  1253                                  ;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
  1254                                  ;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
  1255                                  ; ----------------------------------------------------------------------				 	 	
  1256                                  
  1257                                  ; -----------------------------------------------------------------------------
  1258                                  ; START OF RESIDENT PORTION
  1259                                  ; -----------------------------------------------------------------------------
  1260                                  ; SEGMENT - DATARES
  1261                                  ; -----------------------------------------------------------------------------
  1262                                  
  1263                                  section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 
  1264                                  
  1265                                  ; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)
  1266                                  
  1267                                  ;==============================================================================
  1268                                  ; STUB.ASM - MSDOS 6.0 - 1991
  1269                                  ;==============================================================================
  1270                                  
  1271                                  ;This file contains the low memory stub for command.com which hooks all the
  1272                                  ;entry points into the resident command.com and directs the calls to the
  1273                                  ;appropriate routines in the resident code which may be located in HIMEM. 
  1274                                  ;
  1275                                  ;The stub has been made part of the resident data and will always
  1276                                  ;be duplicated on every invocation of command.com. However, the only stubs
  1277                                  ;that actually hook the interrupt vectors belong to either the first 
  1278                                  ;command.com or to any other command.com executed with the /p switch. 
  1279                                  ;
  1280                                  ;The stub also keeps track of the current active data segment. The 
  1281                                  ;INIT code of each command.com updates this variable via an int 2fh mechanism
  1282                                  ;with its own data segment. The INIT code also updates a pointer in its data
  1283                                  ;segment to the previous resident data segment. Whenever a command.com exits,
  1284                                  ;the exit code picks up the previous data segment pointer from the current
  1285                                  ;data segment and patches it into the CurResDataSeg variable in the stub.
  1286                                  ;
  1287                                  ;Right now the stub does not bother about A20 switching. We assume
  1288                                  ;A20 is always on. It just does a far jump to the resident code with the 
  1289                                  ;value of the current data segment in one of the registers. A20 toggle 
  1290                                  ;support maybe added as a future enhancement, if the need is felt.
  1291                                  
  1292                                  	; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1293                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  1294                                  
  1295                                  	[ORG 100H]
  1296                                  
  1297                                  	; 21/09/2018 - Retro DOS v3.0
  1298                                  StartCode:
  1299 00000000 E9BD14                  	jmp	ConProc	; 10/01/2023 
  1300                                  
  1301                                  	; 09/01/2023
  1302                                  
  1303                                  ; Make following table word-aligned, and at the same time, provide a
  1304                                  ; signature that sysinit can use to (attempt to) validate the interpreter
  1305                                  
  1306                                  	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
  1307 00000003 66                      	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  1308                                  
  1309                                  ;All the entry points declared below are patched in at INIT time with the
  1310                                  ;proper segment and offset values after the resident code segment has been
  1311                                  ;moved to its final location
  1312                                  
  1313                                  ;!!!WARNING!!!
  1314                                  ; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
  1315                                  ;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
  1316                                  ;in the correct segments and offsets
  1317                                  
  1318                                  Int2f_Entry:
  1319 00000004 [D813]                  	dw	MsgInt2fHandler		; Address of int 2fh handler
  1320 00000006 0000                    	dw	0
  1321                                  Int2e_Entry:
  1322 00000008 [340E]                  	dw	Int_2e			; Address of int 2eh handler
  1323 0000000A 0000                    	dw	0
  1324                                  Ctrlc_Entry:
  1325 0000000C [F30C]                  	dw	ContC			; Address of Ctrl-C handler
  1326 0000000E 0000                    	dw	0
  1327                                  CritErr_Entry:
  1328 00000010 [F510]                  	dw	DSKERR			; Address of critical error handler
  1329 00000012 0000                    	dw	0
  1330                                  
  1331                                  Exec_Entry:
  1332 00000014 00000000                	dd	0			; Entry from transient to Ext_Exec
  1333                                  RemCheck_Entry:
  1334 00000018 00000000                	dd	0			; Entry from transient to TRemCheck
  1335                                  TrnLodCom1_Entry:
  1336 0000001C 00000000                	dd	0			; Entry from transient to LodCom1
  1337                                  LodCom_Entry:
  1338 00000020 00000000                	dd	0			; Entry after exit from command.com
  1339                                  MsgRetrv_Entry:
  1340 00000024 00000000                	dd	0			; Entry from external to MsgRetriever
  1341                                  HeadFix_Entry:
  1342 00000028 00000000                	dd	0			; Entry from trans to HeadFix
  1343                                  UMBOff_Entry:
  1344 0000002C 00000000                	dd	0			; Entry from here to UMBOff routine; M003
  1345                                  XMMCallAddr:
  1346 00000030 00000000                	dd	0			; Call address for XMM functions
  1347                                  ComInHMA:
  1348 00000034 00                      	db	0			; Flags if command.com in HMA
  1349                                  
  1350                                  Int2f_Trap:
  1351                                  	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
  1352 00000035 E86400                  	call	CheckA20
  1353 00000038 1E                      	push	ds			; push current ds value
  1354 00000039 0E                      	push	cs			; push resident data segment value
  1355                                  	;jmp	cs:Int2f_Entry
  1356 0000003A 2EFF2E[0400]            	jmp	far [cs:Int2f_Entry]
  1357                                  
  1358                                  Int2e_Trap:
  1359 0000003F FB                      	sti
  1360 00000040 E85900                  	call	CheckA20
  1361 00000043 1E                      	push	ds			; push current ds value
  1362 00000044 0E                      	push	cs			; push resident data segment value
  1363                                  	;jmp	cs:Int2e_Entry
  1364 00000045 2EFF2E[0800]            	jmp	far [cs:Int2e_Entry]
  1365                                  
  1366                                  Ctrlc_Trap:
  1367 0000004A FB                      	sti
  1368 0000004B E84E00                  	call	CheckA20
  1369 0000004E 1E                      	push	ds			; push current ds value
  1370 0000004F 0E                      	push	cs			; push resident data segment value
  1371                                  	;jmp	cs:Ctrlc_Entry
  1372 00000050 2EFF2E[0C00]            	jmp	far [cs:Ctrlc_Entry]
  1373                                  
  1374                                  CritErr_Trap:
  1375 00000055 FB                      	sti
  1376 00000056 E84300                  	call	CheckA20
  1377 00000059 1E                      	push	ds			; push current ds value
  1378 0000005A 0E                      	push	cs			; push resident data segment value
  1379                                  	;jmp	cs:CritErr_Entry
  1380 0000005B 2EFF2E[1000]            	jmp	far [cs:CritErr_Entry]
  1381                                  
  1382                                  Exec_Trap:
  1383 00000060 E83900                  	call	CheckA20
  1384 00000063 1E                      	push	ds			; push current ds value
  1385 00000064 0E                      	push	cs			; push resident data segment value
  1386                                  	;jmp	cs:Exec_Entry
  1387 00000065 2EFF2E[1400]            	jmp	far [cs:Exec_Entry]
  1388                                  
  1389                                  RemCheck_Trap:
  1390 0000006A E82F00                  	call	CheckA20
  1391 0000006D 1E                      	push	ds			; push current ds value
  1392 0000006E 0E                      	push	cs			; push resident data segment value
  1393                                  	;jmp	cs:RemCheck_Entry
  1394 0000006F 2EFF2E[1800]            	jmp	far [cs:RemCheck_Entry]
  1395                                  
  1396                                  TrnLodCom1_Trap:
  1397 00000074 E82500                  	call	CheckA20
  1398 00000077 1E                      	push	ds			; push current ds value
  1399 00000078 0E                      	push	cs			; push resident data segment value
  1400                                  	;jmp	cs:TrnLodCom1_Entry
  1401 00000079 2EFF2E[1C00]            	jmp	far [cs:TrnLodCom1_Entry]
  1402                                  
  1403                                  LodCom_Trap:
  1404 0000007E E81B00                  	call	CheckA20
  1405 00000081 1E                      	push	ds			; push current ds value
  1406 00000082 0E                      	push	cs			; push resident data segment value
  1407                                  	;jmp	cs:LodCom_Entry
  1408 00000083 2EFF2E[2000]            	jmp	far [cs:LodCom_Entry]
  1409                                  
  1410                                  MsgRetrv_Trap:
  1411 00000088 E81100                  	call	CheckA20
  1412 0000008B 1E                      	push	ds			; push current ds value
  1413 0000008C 0E                      	push	cs			; push resident data segment value
  1414                                  	;jmp	cs:MsgRetrv_Entry
  1415 0000008D 2EFF2E[2400]            	jmp	far [cs:MsgRetrv_Entry]
  1416                                  
  1417                                  HeadFix_Trap:
  1418 00000092 E80700                  	call	CheckA20
  1419 00000095 1E                      	push	ds			; push current ds value
  1420 00000096 0E                      	push	cs			; push resident data segment value
  1421                                  	;jmp	cs:HeadFix_Entry
  1422 00000097 2EFF2E[2800]            	jmp	far [cs:HeadFix_Entry]
  1423                                  
  1424                                  ; ----------------------------------------------------------------------------
  1425                                  
  1426                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1427                                  %if 0
  1428                                  	; 09/01/2023
  1429                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh
  1430                                  
  1431                                  	; 05/06/2023
  1432                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:019Ch
  1433                                  CheckA20:
  1434                                  	pushf				; save current flags
  1435                                  	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1436                                  	jz	short A20_on		; no, jump to resident
  1437                                  
  1438                                  	call	QueryA20
  1439                                  	jnc	short A20_on		; A20 is on, jump to resident
  1440                                  
  1441                                  	call	EnableA20		; turn A20 on
  1442                                  A20_on:
  1443                                  	popf				; flags have to be unchanged
  1444                                  	retn
  1445                                  %else
  1446                                  	; 18/07/2024
  1447                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1448                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1449                                  	; PCDOS 7.1 COMMAND.COM - RESGROUP:01FFh
  1450                                  CheckA20:
  1451 0000009C 9C                      	pushf				; save current flags
  1452 0000009D 2E803E[3400]00          	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1453 000000A3 741A                    	jz	short A20_on		; no, jump to resident
  1454                                  	; 18/07/2024
  1455 000000A5 50                      	push	ax
  1456 000000A6 53                      	push	bx
  1457                                  QueryA20:
  1458                                  	;mov	ah,7
  1459 000000A7 B407                    	mov	ah,XMM_QUERY_A20
  1460                                  	;call	cs:XMMCallAddr
  1461 000000A9 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1462 000000AE 09C0                    	or	ax,ax
  1463                                  	; 16/04/2023
  1464 000000B0 750B                    	jnz	short QA20_ON		; A20 is on, jump to resident
  1465                                  	; 18/07/2024
  1466                                  EnableA20:
  1467                                  	;mov	ah,5
  1468 000000B2 B405                    	mov	ah,XMM_LOCAL_ENABLE_A20	; turn A20 on
  1469                                  	;call	cs:XMMCallAddr
  1470 000000B4 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1471 000000B9 09C0                    	or	ax,ax
  1472 000000BB 7404                    	jz	short XMMerror		; AX = 0 fatal error
  1473                                  QA20_ON:
  1474 000000BD 5B                      	pop	bx
  1475 000000BE 58                      	pop	ax
  1476                                  A20_on:
  1477 000000BF 9D                      	popf				; flags have to be unchanged
  1478 000000C0 C3                      	retn
  1479                                  ;If we get an error, we just loop forever
  1480                                  XMMerror:
  1481 000000C1 EBFE                    	jmp	short XMMerror
  1482                                  %endif
  1483                                  
  1484                                  ; ----------------------------------------------------------------------------
  1485                                  
  1486                                  ; M005; This is a far jump to the actual int 2fh entry point. The renormalized
  1487                                  ; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
  1488                                  ; M005; handler. Note that we have to hardcode a jump and we cannot use any
  1489                                  ; M005; pointers because our cs is going to be different. The segment to
  1490                                  ; M005; jump to is patched in at init time. (in init.asm)
  1491                                  
  1492                                  Carousel_i2f_Hook:			; M005
  1493 000000C3 EA                      	db	0EAh			; far jump opcode; M005
  1494 000000C4 [3500]                  	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
  1495 000000C6 0000                    	dw	0			; int 2fh segment; M005
  1496                                  
  1497                                  ; ----------------------------------------------------------------------------
  1498                                  
  1499                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1500                                  %if 0
  1501                                  	XMM_QUERY_A20 equ 7 ; 09/01/2023
  1502                                  QueryA20:
  1503                                  	push	bx
  1504                                  	push	ax
  1505                                  	;mov	ah,7
  1506                                  	mov	ah,XMM_QUERY_A20
  1507                                  	;call	cs:XMMCallAddr
  1508                                  	call	far [cs:XMMCallAddr]
  1509                                  	or	ax,ax
  1510                                  	pop	ax
  1511                                  	pop	bx
  1512                                  	; 16/04/2023
  1513                                  	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON
  1514                                  	stc					; OFF
  1515                                  	;retn
  1516                                  QA20_ON:
  1517                                  	;clc					; ON
  1518                                  	retn
  1519                                  %endif
  1520                                  
  1521                                  ; ----------------------------------------------------------------------------
  1522                                  
  1523                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM
  1524                                  %if 0
  1525                                  	XMM_LOCAL_ENABLE_A20 equ 5
  1526                                  EnableA20:
  1527                                  	push	bx
  1528                                  	push	ax
  1529                                  	;mov	ah,5
  1530                                  	mov	ah,XMM_LOCAL_ENABLE_A20
  1531                                  	;call	cs:XMMCallAddr
  1532                                  	call	far [cs:XMMCallAddr]
  1533                                  	or	ax,ax
  1534                                  	jz	short XMMerror			; AX = 0 fatal error
  1535                                  	pop	ax
  1536                                  	pop	bx
  1537                                  	retn
  1538                                  ;If we get an error, we just loop forever
  1539                                  XMMerror:
  1540                                  	jmp	short XMMerror
  1541                                  %endif
  1542                                  
  1543                                  ; -----------------------------------------------------------------------------
  1544                                  
  1545                                  ; 05/06/2023
  1546                                  ;HV_Extern	equ	1
  1547                                  ;HV_LoadHigh	equ	1
  1548                                  ;HV_Stub	equ	1
  1549                                  ;	include	highvar.inc	; Make high-memory variables external here
  1550                                  ;	include	highexit.inc	; And add code for UnHideUMBs
  1551                                  
  1552                                  ;==============================================================================
  1553                                  ; HIGHEXIT.INC, MSDOS 6.0, 1992
  1554                                  ;==============================================================================
  1555                                  ; 05/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
  1556                                  
  1557                                  DOS_STRATEGY_GET equ  5800h	; Int 21h, Func 58h, Svc 0 = get alloc strategy
  1558                                  DOS_STRATEGY_SET equ  5801h	; Int 21h, Func 58h, Svc 1 = set alloc strategy
  1559                                  DOS_UMBLINK_GET	equ   5802h	; Int 21h, Func 58h, Svc 2 = get link state
  1560                                  DOS_UMBLINK_SET	equ   5803h	; Int 21h, Func 58h, Svc 3 = set link state
  1561                                  DOS_GET_LISTS	equ     52h	; Int 21h, Func 52h = get list of lists
  1562                                  
  1563                                  UMB_HeadIdx	equ     8Ch	; Offset from ES (after func52h) to get UMBHead
  1564                                  
  1565                                  	; 05/06/2023
  1566                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:01D9h
  1567                                  
  1568                                  ; -----------------------------------------------------------------------------
  1569                                  ;*** UnHideUMBs - Marks HIDDEN elements as FREE
  1570                                  ; -----------------------------------------------------------------------------
  1571                                  ; ENTRY:  None; perhaps, earlier, HideUMBs was called... if not, we have
  1572                                  ;               very little to do, as no elelments will be marked as HIDDEN.
  1573                                  ; EXIT:   Sets InHigh to zero; carry clear if HideUMBs was called earlier.
  1574                                  ; ERROR:  None
  1575                                  ; USES:   fInHigh (from highvar.inc), carry flag
  1576                                  ; -----------------------------------------------------------------------------
  1577                                  
  1578                                  UnHideUMBs:
  1579 000000C8 50                      	push	ax		; Save ax for what we're about to do
  1580                                  
  1581                                  ; -----------------------------------------------------------------------------
  1582                                  ; BUGBUG t-richj 11-8-92: The following six lines were commented out for a good
  1583                                  ;    length of time. Those six constitute a check of whether or not we should
  1584                                  ;    indeed clean up the upper-memory chain; without such a check, COMMAND.COM
  1585                                  ;    will destroy the current link-state and memory-allocation strategy after
  1586                                  ;    every command execution.
  1587                                  ; -----------------------------------------------------------------------------
  1588                                  
  1589                                  	; 05/06/2023
  1590                                  	;getdata al,fInHigh	; Get InHigh from data segment
  1591                                  	;
  1592                                  	;push	ds
  1593 000000C9 A0[D604]                	mov	al,[fInHigh]
  1594                                  	;pop	ds
  1595                                  
  1596                                  	;or	al, al
  1597                                  	;jnz	short uhu10	; If didn't call loadhigh/devicehigh earlier,
  1598                                  
  1599                                  	;pop	ax		; then there's nothing to do here... so
  1600                                  	;stc			; restore everything and return.  Just like
  1601                                  	;retn			; that.
  1602                                  
  1603                                  	; 05/06/2023
  1604 000000CC 3C01                    	cmp	al,1
  1605 000000CE 720F                    	jb	short uhu20	; cf=1
  1606                                  uhu10:	
  1607 000000D0 E8A000                  	call	linkumb		; Make sure UMBs are linked in.
  1608 000000D3 E82000                  	call	FreeUMBs
  1609                                  
  1610                                  	;putdata fInHigh, 0	; We're leaving, so update fInHigh.
  1611                                  	;
  1612                                  	;push	es
  1613                                  	;mov	byte [es:fInHigh],0
  1614                                  	;pop	es
  1615                                  	; 05/06/2023
  1616 000000D6 C606[D604]00            	mov	byte [fInHigh],0
  1617                                  
  1618 000000DB E80300                  	call	he_unlink	; Unlink UMBs
  1619                                  
  1620                                  	;pop	ax
  1621                                  	;clc
  1622                                  	;retn
  1623                                  
  1624 000000DE F8                      	clc
  1625                                  uhu20:
  1626 000000DF 58                      	pop	ax
  1627 000000E0 C3                      	retn
  1628                                  
  1629                                  ; -----------------------------------------------------------------------------
  1630                                  ;*** he_unlink - unlinks UMBs if fm_umb is set to 0
  1631                                  ; -----------------------------------------------------------------------------
  1632                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
  1633                                  ; EXIT:     None
  1634                                  ; ERROR:    None
  1635                                  ; USES:     AX, BX
  1636                                  ; -----------------------------------------------------------------------------
  1637                                  
  1638                                  	; 05/06/2023
  1639                                  he_unlink:
  1640 000000E1 30FF                    	xor	bh, bh
  1641                                  	
  1642                                  	;getdata bl,fm_umb		; Restore original link-state
  1643                                  	;
  1644                                  	;push	ds
  1645 000000E3 8A1E[DB04]              	mov     bl,[fm_umb]
  1646                                  	;pop	ds
  1647                                  
  1648 000000E7 B80358                  	mov	ax,DOS_UMBLINK_SET ; 5803h
  1649 000000EA CD21                    	int	21h
  1650                                  
  1651                                  	;xor	bh, bh
  1652                                  	
  1653                                  	;getdata bl,fm_strat		; Restore original mem-alloc strategy
  1654                                  	;push	ds
  1655 000000EC 8A1E[DC04]              	mov     bl,[fm_strat]
  1656                                  	;pop	ds
  1657                                  
  1658 000000F0 B80158                  	mov	ax,DOS_STRATEGY_SET ; 5801h
  1659 000000F3 CD21                    	int	21h
  1660                                  
  1661 000000F5 C3                      	retn
  1662                                  
  1663                                  ; -----------------------------------------------------------------------------
  1664                                  ;*** freeUMBs - frees all HIDDEN memory elements in upper-memory.
  1665                                  ; -----------------------------------------------------------------------------
  1666                                  ; ENTRY:    None
  1667                                  ; EXIT:     None; HIDDEN memory elements returned to FREE
  1668                                  ; ERROR:    None (ignore CF)
  1669                                  ; USES:     Flags
  1670                                  ; -----------------------------------------------------------------------------
  1671                                  
  1672                                  	; 05/06/2023
  1673                                  arena_signature_end equ 5Ah ; 'Z'
  1674                                  arena_signature equ 0
  1675                                  arena_size equ 3
  1676                                  
  1677                                  FreeUMBs:
  1678 000000F6 50                      	push	ax
  1679 000000F7 06                      	push	es
  1680                                  
  1681 000000F8 E86900                  	call	HeadUmb		; Returns with carry if err, else ES == MCB
  1682 000000FB 721C                    	jc	short fusX
  1683                                  fus10:
  1684 000000FD 8EC0                    	mov	es,ax		; Prepare for the loop; ES = current MCB addr.
  1685 000000FF E81A00                  	call	isHideMCB	; Returns with ZF set if owner is 0
  1686 00000102 7503                    	jnz	short fus20
  1687 00000104 E84200                  	call	freeMCB
  1688                                  fus20:	
  1689 00000107 26A00000                	mov	al,[es:arena_signature] ; mov al,[es:0]
  1690 0000010B 3C5A                    	cmp	al,arena_signature_end ; 'Z' ; 5Ah
  1691 0000010D 740A                    	jz	short fusX	; That means this was the last MCB--that's it.
  1692                                  
  1693 0000010F 8CC0                    	mov	ax,es
  1694 00000111 2603060300              	add	ax,[es:arena_size] ; add ax,[es:3]
  1695 00000116 40                      	inc	ax
  1696                                  	;mov	es,ax		; Go on forward.
  1697                                  	;jmp	short fus10
  1698                                  	; 18/07/2024
  1699 00000117 EBE4                    	jmp	short fus10
  1700                                  fusX:
  1701 00000119 07                      	pop	es
  1702 0000011A 58                      	pop	ax
  1703 0000011B C3                      	retn
  1704                                  
  1705                                  ; -----------------------------------------------------------------------------
  1706                                  ;*** isHideMCB - returns with ZF set if current MCB (ES:0) is HIDDEN
  1707                                  ; -----------------------------------------------------------------------------
  1708                                  ; ENTRY:    ES:0 should point to an MCB
  1709                                  ; EXIT:     ZF set if MCB is hidden, else !ZF
  1710                                  ; ERROR:    None
  1711                                  ; USES:     Flags
  1712                                  ; -----------------------------------------------------------------------------
  1713                                  
  1714                                  	; 05/06/2023
  1715                                  SystemPSPOwner	equ 8
  1716                                  arena_owner	equ 1
  1717                                  arena_name	equ 8
  1718                                  
  1719                                  isHideMCB:
  1720 0000011C 50                      	push	ax
  1721                                  
  1722 0000011D 26833E010008            	cmp	word [es:arena_owner],SystemPSPOwner ; If the owner's SYSTEM
  1723 00000123 7522                    	jne	short ihm_x			     ; then check for HIDDEN
  1724                                  
  1725 00000125 26A10800                	mov	ax,[es:arena_name]   ; [es:8]
  1726 00000129 3D4849                  	cmp	ax,'HI' ; 4948h
  1727 0000012C 7519                    	jne	short ihm_x
  1728 0000012E 26A10A00                	mov	ax,[es:arena_name+2] ; [es:10]
  1729 00000132 3D4444                  	cmp	ax,'DD' ; 4444h
  1730 00000135 7510                    	jne	short ihm_x
  1731 00000137 26A10C00                	mov	ax,[es:arena_name+4] ; [es:12]
  1732 0000013B 3D454E                  	cmp	ax,'EN' ; 4E45h
  1733 0000013E 7507                    	jne	short ihm_x
  1734 00000140 26A10E00                	mov	ax,[es:arena_name+6] ; [es:14]
  1735 00000144 3D2020                  	cmp	ax,'  ' ; 2020h
  1736                                  ihm_x:
  1737 00000147 58                      	pop	ax
  1738 00000148 C3                      	retn
  1739                                  
  1740                                  ; -----------------------------------------------------------------------------
  1741                                  ;*** freeMCB - marks as free the MCB at ES:0
  1742                                  ; -----------------------------------------------------------------------------
  1743                                  ; ENTRY:    ES:0 should point to an MCB
  1744                                  ; EXIT:     None; MCB free'd
  1745                                  ; ERROR:    None
  1746                                  ; USES:     AX
  1747                                  ; -----------------------------------------------------------------------------
  1748                                  
  1749                                  	; 05/06/2023
  1750                                  freeMCB:
  1751 00000149 26C70601000000          	mov	word [es:arena_owner],0	; [es:1]
  1752 00000150 B82020                  	mov	ax,'  '
  1753 00000153 26A30800                	mov	[es:arena_name+0],ax	; [es:8]
  1754 00000157 26A30A00                	mov	[es:arena_name+2],ax
  1755 0000015B 26A30C00                	mov	[es:arena_name+4],ax
  1756 0000015F 26A30E00                	mov	[es:arena_name+6],ax	; [es:14]
  1757 00000163 C3                      	retn
  1758                                  
  1759                                  ; -----------------------------------------------------------------------------
  1760                                  ;*** HeadUmb - returns in AX the address of the first UMB block (0x9FFF)
  1761                                  ; -----------------------------------------------------------------------------
  1762                                  ; ENTRY:  Nothing
  1763                                  ; EXIT:   AX contains 0x9FFF for most systems
  1764                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
  1765                                  ; USES:   Flags, AX
  1766                                  ; -----------------------------------------------------------------------------
  1767                                  
  1768                                  	; 05/06/2023
  1769                                  HeadUmb:
  1770                                  	; 18/07/2024 - PCDOS 7.1 - RESGROUP:02CDh
  1771                                  	;push	si
  1772                                  	;push	ds
  1773 00000164 06                      	push	es
  1774                                  
  1775 00000165 B452                    	mov	ah,DOS_GET_LISTS	; Call int 21h, function 52h...
  1776 00000167 CD21                    	int	21h	; DOS - 2+ internal - GET LIST OF LISTS
  1777                                  			; Return: ES:BX -> DOS list of lists
  1778                                  
  1779 00000169 26A18C00                	mov	ax,[es:UMB_HeadIdx]	; And read what's in ES:008Ch
  1780 0000016D 83F8FF                  	cmp	ax,0FFFFh
  1781                                  	;je	short xhu_e		; If it's 0xFFFF, it's an error...
  1782                                  	;clc				; Else, it isn't.
  1783                                  	;jmp	short xhu_x
  1784                                  ;xhu_e:
  1785                                  	;stc
  1786                                  	; 05/06/2023
  1787 00000170 F5                      	cmc	; cf=0 -> cf=1
  1788                                  ;xhu_x:
  1789 00000171 07                      	pop	es
  1790                                  	; 18/07/2024
  1791                                  	;pop	ds
  1792                                  	;pop	si
  1793 00000172 C3                      	retn
  1794                                  
  1795                                  ; -----------------------------------------------------------------------------
  1796                                  ;*** linkumb - links UMBs not already linked in; updates fm_umb as needed
  1797                                  ; -----------------------------------------------------------------------------
  1798                                  ; ENTRY:    None
  1799                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
  1800                                  ; ERROR:    None
  1801                                  ; USES:     AX, BX, fm_umb
  1802                                  ; -----------------------------------------------------------------------------
  1803                                  
  1804                                  	; 05/06/2023
  1805                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:029Dh
  1806                                  linkumb:
  1807 00000173 B80258                  	mov	ax,DOS_UMBLINK_GET ; 5802h
  1808 00000176 CD21                    	int	21h			; Current link-state is now in al
  1809                                  
  1810 00000178 08C0                    	or	al,al			; BUGBUG: proper check?
  1811 0000017A 7508                    	jnz	short lumbX		; Jumps if UMBs already linked in
  1812                                  
  1813 0000017C B80358                  	mov	ax,DOS_UMBLINK_SET ; 5803h
  1814 0000017F BB0100                  	mov	bx,1
  1815 00000182 CD21                    	int	21h
  1816                                  lumbX:
  1817 00000184 C3                      	retn
  1818                                  
  1819                                  ;==============================================================================
  1820                                  ; STUB.ASM, MSDOS 6.0, 1991
  1821                                  ;==============================================================================
  1822                                  ; 05/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
  1823                                  
  1824                                  	; 09/01/2023 - Retro DOS v4.0 (& 4.1)
  1825                                  	; 05/06/2023 - Retro DOS 4.2
  1826                                  
  1827                                  ;The Exec call has to be issued from the data segment. The reason for this 
  1828                                  ;is TSRs. When a TSR does a call to terminate and stay resident, the call
  1829                                  ;returns with all registers preserved and so all our segment registers are
  1830                                  ;still set up. However, if the TSR unloads itself later on, it still 
  1831                                  ;comes back here. In this case the segment registers and the stack are
  1832                                  ;not set up and random things can happen. The only way to setup all the 
  1833                                  ;registers is to use the cs value and this can only be done when we are in
  1834                                  ;the data segment ourselves. So, this piece of code had to be moved from
  1835                                  ;the code segment to the data segment.
  1836                                  
  1837                                  	; MSDOS 6.22 COMMAND.COM RESGROUP:02AFh
  1838                                  Issue_Exec_Call:
  1839 00000185 CD21                    	int 	21h
  1840                                  
  1841                                  ;We disable interrupts while changing the stack because there is a bug in 
  1842                                  ;some old 8088 processors where interrupts are let through while ss & sp
  1843                                  ;are being changed.
  1844                                  
  1845 00000187 FA                      	cli
  1846 00000188 0E                      	push	cs
  1847 00000189 17                      	pop	ss
  1848                                  
  1849                                  	;;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
  1850                                  	;mov	sp,60Ah	; MSDOS 6.22 COMMAND.COM RESGROUP:02B4h
  1851                                  	;mov	sp,offset DATARES:RStack ; stack is set up
  1852 0000018A BC[D404]                	mov	sp,RStack		; stack is set up
  1853                                  
  1854                                  ; 05/06/2023	
  1855                                  %if 0	
  1856                                  	; 20/04/2023
  1857                                  	;sti
  1858                                  	;push	cs
  1859                                  	;pop	ds			; ds = DATARES
  1860                                  
  1861                                  ; M009; Restore UMB state to that before Exec
  1862                                  
  1863                                  	;pushf				;    This call frees HIDDEN umb's,
  1864                                  	;call	UnHideUMBs		; <- restores the memory-allocation
  1865                                  	;popf				;    strategy and link state, as app.
  1866                                  
  1867                                  	; 09/01/2023 - Retro DOS v4.0
  1868                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
  1869                                  	; ----------------------
  1870                                  	sti
  1871                                  	push    cs
  1872                                  	pop     ds
  1873                                  	pushf
  1874                                  	;mov	al,[cs:fInHigh]
  1875                                  	; 18/04/2023
  1876                                  	mov	al,[fInHigh]
  1877                                  	test	al,80h
  1878                                  	jz      short uhu10
  1879                                  	and     al,7Fh
  1880                                  	;;call	cs:UMBOff_Entry
  1881                                  	;call	far [cs:UMBOff_Entry]
  1882                                  	call	far [UMBOff_Entry]
  1883                                  uhu10:
  1884                                  	;and	byte [cs:fInHigh],7Fh
  1885                                  	; 18/04/2023
  1886                                  	and	byte [fInHigh],7Fh
  1887                                  	popf
  1888                                  	; ----------------------
  1889                                  
  1890                                  %endif
  1891                                  	; 05/06/2023 - Retro DOS 4.2
  1892                                  	; MSDOS 6.22 COMMAND.COM RESGROUP:02B7h
  1893 0000018D FB                      	sti
  1894 0000018E 0E                      	push	cs
  1895 0000018F 1F                      	pop	ds			; ds = DATARES
  1896                                  
  1897                                  ; M009; Restore UMB state to that before Exec
  1898                                  
  1899 00000190 9C                      	pushf				;    This call frees HIDDEN umb's,
  1900 00000191 E834FF                  	call	UnHideUMBs		; <- restores the memory-allocation
  1901 00000194 9D                      	popf				;    strategy and link state, as app
  1902                                  
  1903                                  ;We now jump to the stub trap which returns us to the resident code. All
  1904                                  ;flags are preserved by the stub code.
  1905                                  
  1906 00000195 E9C8FE                  	jmp	Exec_Trap
  1907                                  
  1908                                  ;==============================================================================
  1909                                  ; RDATA.ASM, MSDOS 6.0, 1992
  1910                                  ;==============================================================================
  1911                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1912                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  1913                                  
  1914                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:02C2h (DATARES:02C2h) (*)
  1915                                  ; -----------------------------------------------------------------------------
  1916 00000198 636F78                  cox_location:	db 'cox' ; (*)	
  1917 0000019B 0000                    cox_Y_option:	dw 0     ; (*)
  1918                                  ; -----------------------------------------------------------------------------
  1919                                  
  1920                                  ;***	Message substitution blocks
  1921                                  
  1922                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)
  1923                                  
  1924                                  ;BlkDevErrSubst	label	byte
  1925                                  ;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
  1926                                  ;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter
  1927                                  
  1928 0000019D 02                      BlkDevErrSubst: db	2
  1929 0000019E 0000                    BlkDevErrRw:	dw	0
  1930 000001A0 01                      		db	1
  1931 000001A1 [A301]                  		dw	DrvLet
  1932                                  
  1933 000001A3 41                      DrvLet:		db	'A'			; drive letter
  1934                                  
  1935                                  
  1936                                  ;CharDevErrSubst label	byte
  1937                                  ;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
  1938                                  ;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name
  1939                                  
  1940 000001A4 02                      CharDevErrSubst: db	2
  1941 000001A5 0000                    CharDevErrRw:	dw	0
  1942 000001A7 02                      		db	2
  1943 000001A8 [B601]                  		dw	DevName
  1944                                  
  1945                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0318h
  1946                                  ;DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
  1947                                  ;		db	0
  1948                                  
  1949                                  ;NeedVolSubst	label	byte
  1950                                  ;		subst	<STRING,DATARES:VolName> ; volume name
  1951                                  ;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
  1952                                  ;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #
  1953                                  
  1954 000001AA 02                      NeedVolSubst:	db	2
  1955 000001AB [B301]                  		dw	VolName
  1956 000001AD 03                      		db	3
  1957 000001AE [C101]                  		dw	VolSer+2
  1958 000001B0 03                      		db	3
  1959 000001B1 [BF01]                  		dw	VolSer
  1960                                  
  1961                                  ; 18/07/2024 - PCDOS 7.1 COMMAND.COM - RESGROUP:0321h
  1962                                  	; NOTE:	VolName and VolSer must be adjacent
  1963                                  ;VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
  1964                                  		; 18/07/2024
  1965 000001B3 000000                  VolName:	db	3 dup(0)
  1966 000001B6 0000000000000000        DevName:	db	8 dup(0)
  1967                                  	
  1968 000001BE 00                      		db	0
  1969 000001BF 00000000                VolSer:		dd	0			; volume serial #
  1970                                  
  1971 000001C3 00                      CDevAt:		db	0
  1972                                  
  1973                                  ;BadFatSubst	label	byte
  1974                                  ;		subst	<CHAR,DATARES:DrvLet>	; drive letter
  1975                                  
  1976 000001C4 01                      BadFatSubst:	db	1
  1977 000001C5 [A301]                  		dw	DrvLet
  1978                                  
  1979                                  ;PutBackSubst	label	byte
  1980                                  ;PutBackComSpec	subst	<STRING,>		  ; comspec string
  1981                                  ;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in
  1982                                  
  1983 000001C7 02                      PutBackSubst:	db	2
  1984 000001C8 0000                    PutBackComSpec:	dw	0
  1985 000001CA 01                      		db	1
  1986 000001CB [CD01]                  		dw	PutBackDrv
  1987                                  
  1988 000001CD 20                      PutBackDrv:	db	' '	; db 20h	; drive letter
  1989                                  
  1990                                  ;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>
  1991                                  
  1992 000001CE 02                      ExecErrSubst:	db	2
  1993 000001CF [0004]                  		dw	SafePathBuffer
  1994                                  
  1995 000001D1 00000000                NeedVol:	dd	0	; ptr to volume name from get ext err
  1996 000001D5 00                      ErrType: 	db	0	; critical error message style, 0=old, 1=new
  1997                                  
  1998 000001D6 00000000                Int_2e_Ret:	dd	0	; magic command executer return address
  1999 000001DA 0000                    Save_Pdb:	dw	0
  2000 000001DC 0000                    Parent:		dw	0
  2001 000001DE 00000000                OldTerm:	dd	0
  2002 000001E2 0000                    ErrCd_24:	dw	0
  2003 000001E4 0000                    Handle01:	dw	0
  2004 000001E6 00                      Loading:	db	0
  2005 000001E7 0000                    Batch:		dw	0	; assume no batch mode initially
  2006                                  
  2007                                  ;;;;SR;
  2008                                  ;;;; This flag has been added for a gross hack introduced in batch processing. 
  2009                                  ;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
  2010                                  ;;;;we need to fake the CR-LF for the line to be properly processed
  2011                                  ;;;;
  2012                                  ;;;BatchEOF:	db	0
  2013                                  
  2014                                  	; Bugbug: ComSpec should be 64+3+12+1?
  2015                                  	; What's this comspec_end about?
  2016 000001E9 00<rep 40h>             ComSpec:	times 64 db 0 ; db 64 dup (0)
  2017 00000229 0000                    ComSpec_End:	dw	0
  2018                                  
  2019                                  ;Trans		label	dword
  2020                                  ;		dw	TRANGROUP:Command
  2021                                  
  2022                                  Trans:		;dw	12Ch
  2023                                  		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
  2024 0000022B [2C01]                  		dw	COMMAND ; 16/04/2023
  2025 0000022D 0000                    TrnSeg:		dw	0
  2026                                  
  2027 0000022F 00                      TrnMvFlg:	db	0	; set if transient portion has been moved
  2028                                  
  2029 00000230 00                      In_Batch:	db	0	; set if we are in batch processing mode
  2030 00000231 00                      Batch_Abort:	db	0	; set if user wants to abort from batch mode
  2031                                  
  2032 00000232 00                      ComDrv:		db	0	; drive spec to load autoexec and command
  2033 00000233 0000                    MemSiz:		dw	0
  2034 00000235 0000                    Sum:		dw	0
  2035 00000237 01                      ExtCom:		db	1	; for init, pretend just did an external
  2036 00000238 0000                    RetCode: 	dw	0
  2037 0000023A 00                      Crit_Err_Info:	db	0	; hold critical error flags for r,i,f
  2038                                  
  2039                                  
  2040                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  2041                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  2042                                  
  2043 0000023B 01                      EchoFlag:	db	00000001b ; low bit true => echo commands
  2044 0000023C 01                      Suppress:	db	1	; used for echo, 1=echo line
  2045 0000023D 0000                    Io_Save: 	dw	0
  2046 0000023F 00                      RestDir: 	db	0
  2047 00000240 00                      PermCom: 	db	0	; true => permanent command
  2048                                  ; 05/06/2023
  2049 00000241 FFFF                    SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
  2050                                  				; true => semi-permanent command (/K)
  2051 00000243 0000                    SingleCom:	dw	0	; true => single command version
  2052 00000245 FFFF                    VerVal:		dw	-1
  2053 00000247 00                      fFail:		db	0	; true => fail all int 24s
  2054 00000248 00                      IfFlag:		db	0	; true => IF statement in progress
  2055                                  
  2056 00000249 00                      ForFlag: 	db	0	; true => FOR statement in progress
  2057 0000024A 0000                    ForPtr:		dw	0
  2058                                  
  2059 0000024C 0000                    Nest:		dw	0	; nested batch file counter
  2060 0000024E 00                      Call_Flag:	db	0	; no CALL (batch command) in progress
  2061 0000024F 00                      Call_Batch_Flag: db	0
  2062 00000250 0000                    Next_Batch:	dw	0	; address of next batch segment
  2063 00000252 00                      NullFlag:	db	0	; flag if no command on command line
  2064 00000253 00<rep 5h>              FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
  2065                                  				; buffer for file ucase address
  2066                                  ; Bugbug: don't need crit_msg_ anymore?
  2067                                  
  2068 00000258 0000                    Crit_Msg_Off:	dw	0	; saved critical error message offset
  2069 0000025A 0000                    Crit_Msg_Seg:	dw	0	; saved critical error message segment
  2070 0000025C 0000                    Dbcs_Vector_Addr: dw	0	; DBCS vector offset
  2071 0000025E 0000                    		 dw	0	; DBCS vector segment
  2072 00000260 0000                    Append_State:	dw	0	; current state of append
  2073                                  				;  (if Append_Flag is set)
  2074 00000262 00                      Append_Flag:	db	0	; set if append state is valid
  2075 00000263 00                      Re_Out_App:	db	0
  2076 00000264 00<rep 50h>             Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)
  2077                                  
  2078                                  ; We flag the state of COMMAND in order to correctly handle the ^Cs at
  2079                                  ; various times. Here is the breakdown:
  2080                                  ;
  2081                                  ;   INITINIT	We are in the init code.
  2082                                  ;   INITSPECIAL We are in the date/time prompt
  2083                                  ;   INITCTRLC	We are handling a ^C already.
  2084                                  ;
  2085                                  ; If we get a ^C in the initialization but not in the date/time prompt, we
  2086                                  ; ignore the ^C. This is so the system calls work on nested commands.
  2087                                  ;
  2088                                  ; If we are in the date/time prompt at initialization, we stuff the user's
  2089                                  ; input buffer with a CR to pretend an empty response.
  2090                                  ;
  2091                                  ; If we are already handling a ^C, we set the carry bit and return to the user
  2092                                  ; (ourselves). We can then detect the carry set and properly retry the
  2093                                  ; operation.
  2094                                  
  2095                                  InitFlag:	;db	1
  2096 000002B4 01                      		db	INITINIT
  2097                                  
  2098                                  ; Note: these two bytes are referenced as a word
  2099 000002B5 00                      PipeFlag:	db	0
  2100 000002B6 00                      PipeFiles:	db	0
  2101                                  
  2102                                  ; (rdata.asm, msdos 6.0, 1992)
  2103                                  ; ----------------------------------------------------------------------------
  2104                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)
  2105                                  
  2106                                  ;;SR
  2107                                  ;; Pipe1 & Pipe2 now need to store full-fledged pathnames
  2108                                  ;;
  2109                                  ;
  2110                                  ;; Bugbug: can we find any way around maintaining these
  2111                                  ;; large buffers?
  2112                                  ;
  2113                                  ;Pipe1		db	67+12 dup (?)
  2114                                  ;Pipe2		db	67+12 dup (?)
  2115                                  ;
  2116                                  ;PipePtr 	dw	?
  2117                                  ;
  2118                                  ;PipeStr 	db	129 dup (?)
  2119                                  ;
  2120                                  ;EndPipe	label	byte	; marks end of buffers; M004
  2121                                  ;
  2122                                  ;;SR;
  2123                                  ;; We can move our EndInit code into above buffers. This way, the code will
  2124                                  ;;automatically be discarded after init.
  2125                                  ;;
  2126                                  ;; M004; We overlap our code with the Pipe buffers located above by changing
  2127                                  ;; M004; the origin.
  2128                                  ;;
  2129                                  ;	ORG	Pipe1	; M004
  2130                                  ;
  2131                                  ;; Bugbug: really need a procedure header for EndInit, describing
  2132                                  ;; what it expects, what it does.
  2133                                  ;
  2134                                  
  2135                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2136                                  
  2137                                  Pipe1	equ	EndInit
  2138                                  Pipe2	equ	Pipe1+67+12
  2139                                  PipePtr	equ	Pipe2+67+12
  2140                                  PipeStr	equ	PipePtr+2
  2141                                  EndPipe	equ	PipeStr+129	; EndInit+289
  2142                                  
  2143                                  ; Bugbug: really need a procedure header for EndInit, describing
  2144                                  ; what it expects, what it does.
  2145                                  
  2146                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h
  2147                                  
  2148                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM (compatible with MSDOS 6.22)
  2149                                  ; MSDOS 6.22 COMMAND.COM - RESGROUP:03EAh 
  2150                                  
  2151                                  EndInit:
  2152 000002B7 1E                      	push	ds
  2153 000002B8 06                      	push	es		; save segments
  2154 000002B9 0E                      	push	cs
  2155 000002BA 1F                      	pop	ds		
  2156                                  	;assume	ds:RESGROUP
  2157                                  
  2158                                  ; M004; Save size of transient here before INIT segment is deallocated
  2159                                  
  2160 000002BB 8B16[D21E]              	mov	dx,[TrnSize]		; M004
  2161                                  ;M027
  2162                                  ; These variables are also defined in the INIT segment and need to be saved
  2163                                  ;before we resize
  2164                                  ;
  2165 000002BF A1[C61E]                	mov	ax,[OldEnv]	; Old Environment seg ;M027
  2166 000002C2 8B1E[C21E]              	mov	bx,[EnvSiz]	; Size of new environment ;M027
  2167 000002C6 8B0E[C81E]              	mov	cx,[UsedEnv]	; Size of old environment ;M027
  2168 000002CA 50                      	push	ax		; Save all these values ;M027
  2169 000002CB 53                      	push	bx		; M027
  2170 000002CC 51                      	push	cx		; M027
  2171                                  
  2172                                  
  2173                                  ; Bugbug: push ds, pop es here.
  2174                                  	;mov	bx,ds
  2175                                  	;mov	es,bx		; es = RESGROUP
  2176                                  	; 09/01/2023
  2177 000002CD 1E                      	push	ds
  2178 000002CE 07                      	pop	es
  2179                                  
  2180                                  ;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  2181                                  ; code + data for low COMMAND
  2182                                  
  2183 000002CF 8B1E[5604]              	mov	bx,[ResSize]	; Total size of resident
  2184 000002D3 B44A                    	mov	ah,4Ah
  2185                                  	;mov	ah,SETBLOCK
  2186 000002D5 CD21                    	int	21h		; Set block to resident size
  2187                                  
  2188                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  2189                                  		; ES = segment address of block to change
  2190                                  		; BX = new size in paragraphs
  2191                                  
  2192                                  ;We check if this is for autoexec.bat (PermCom = 1). If so, we then
  2193                                  ;allocate a new batch segment, copy the old one into new batchseg and free
  2194                                  ;the old batchseg. Remember that the old batchseg was allocated on top of the
  2195                                  ;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
  2196                                  ;
  2197                                  ; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
  2198                                  	
  2199 000002D7 803E[4002]01            	cmp	byte [PermCom],1 ; permanent command.com?
  2200 000002DC 7530                    	jne	short adjust_env ; no, do not free batchseg
  2201                                  
  2202 000002DE 833E[E701]00            	cmp	word [Batch],0	 ; was there a valid batchseg?
  2203 000002E3 7429                    	je	short adjust_env ; no, dont juggle
  2204                                  
  2205                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0Fh)/16 ; batchseg size
  2206                                  	; 21/01/2023
  2207 000002E5 BB0400                  	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  2208                                  	;mov	bx,4	; 09/01/2023
  2209                                  			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
  2210 000002E8 B448                    	mov	ah,48h
  2211                                  	;mov	ah,ALLOC
  2212 000002EA CD21                    	int	21h
  2213                                  
  2214                                  		; DOS - 2+ - ALLOCATE MEMORY
  2215                                  		; BX = number of 16-byte paragraphs desired
  2216                                  
  2217                                  ; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
  2218                                  ; a hole, the batch segment COULD already be in the ideal place. We
  2219                                  ; could be making it worse! We're second-guessing where memory
  2220                                  ; allocations go, which might not be such a great idea. Is there
  2221                                  ; a strategy, short of doing something even worse like diddling
  2222                                  ; arena headers, where we can minimize the possibility of fragmentation
  2223                                  ; under all cases? Hmm..
  2224                                  	
  2225 000002EC 7220                    	jc	short adjust_env ; no memory, use old batchseg
  2226                                  
  2227 000002EE 8EC0                    	mov	es,ax		 ; es = New batch segment
  2228 000002F0 31FF                    	xor	di,di
  2229 000002F2 31F6                    	xor	si,si
  2230                                  
  2231 000002F4 1E                      	push	ds
  2232 000002F5 8E1E[E701]              	mov	ds,[Batch]	 ; ds = Old Batch Segment
  2233                                  	;assume	ds:nothing
  2234                                  	;mov	cx,SIZE BatchSegment
  2235                                  	; 23/01/2023
  2236                                  	;mov	cx,BATCHSEGMENT.SIZE
  2237                                  	;;mov	cx,33	; 09/01/2023
  2238                                  	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
  2239                                  	;
  2240                                  	;add	cx,16		 ; for the filename
  2241                                  	; 20/04/2023
  2242 000002F9 B93100                  	mov	cx,BATCHSEGMENT.SIZE+16
  2243                                  
  2244                                  	; Bugbug: 16? Shouldn't this be a common equate or something?
  2245                                  	; It's sure be bad if we copied more bytes than the batch segment
  2246                                  	; holds!
  2247                                  	
  2248 000002FC FC                      	cld
  2249 000002FD F3A4                    	rep	movsb
  2250 000002FF 1F                      	pop	ds
  2251                                  	;assume	ds:RESGROUP
  2252                                  
  2253 00000300 8CC1                    	mov	cx,es		; save new batch segment 
  2254 00000302 8E06[E701]              	mov	es,[Batch]
  2255 00000306 B449                    	mov	ah,49h
  2256                                  	;mov	ah,DEALLOC
  2257 00000308 CD21                    	int	21h		; free the old batch segment
  2258                                  
  2259                                  	; Bugbug: should we check for error?
  2260                                  
  2261 0000030A 890E[E701]              	mov	[Batch],cx	; store new batch segment address
  2262                                  
  2263                                  adjust_env:
  2264 0000030E 59                      	pop	cx		; cx = size of old env ;M027
  2265 0000030F 5B                      	pop	bx		; bx = size of new env needed ;M027
  2266 00000310 5D                      	pop	bp		; bp = old env seg ;M027
  2267                                  
  2268                                  ;Allocate the correct size for the environment
  2269                                  
  2270 00000311 B448                    	mov	ah,48h
  2271                                  	;mov	ah,ALLOC
  2272 00000313 CD21                    	int	21h		; get memory
  2273 00000315 7264                    	jc	short nomem_err	; out of memory,signal error
  2274                                  	
  2275                                  	; Bugbug: why not continue, leaving environment where it is?
  2276                                  
  2277 00000317 A3[DC03]                	mov	[EnvirSeg],ax	; Store new environment segment
  2278                                  	;;mov	[ds:2Ch],ax
  2279                                  	;mov	[2Ch],ax
  2280                                  	;mov	[PDB_Environ],ax ; Put new env seg in PSP
  2281 0000031A A32C00                  	mov	[PDB.ENVIRON],ax
  2282 0000031D 8EC0                    	mov	es,ax		; es = address of allocated memory
  2283                                  	;assume	es:nothing
  2284                                  
  2285                                  ;Copy the environment to the newly allocated segment
  2286                                  
  2287 0000031F 1E                      	push	ds
  2288 00000320 8EDD                    	mov	ds,bp		; ds = Old environment segment
  2289                                  	;assume	ds:nothing
  2290                                  
  2291 00000322 31F6                    	xor	si,si
  2292 00000324 89F7                    	mov	di,si		; Start transfer from 0
  2293                                  
  2294 00000326 FC                      	cld
  2295 00000327 F3A4                    	rep	movsb		; Do the copy
  2296                                  
  2297 00000329 1F                      	pop	ds		; ds = RESGROUP
  2298                                  	;assume	ds:RESGROUP
  2299                                  
  2300                                  ; We have to free the old environment block if it was allocated by INIT
  2301                                  
  2302                                  ; Bugbug: is this only for the case when we were NOT passed an environment,
  2303                                  ; or does it also apply to passed environments?
  2304                                  
  2305                                  ;M036
  2306                                  ; Free up old env segment always because this is a copy passed by Exec and
  2307                                  ; takes up memory that is never used
  2308                                  
  2309                                  ;M044
  2310                                  ; Go back to the old strategy of not freeing the environment. Freeing it leaves
  2311                                  ; a hole behind that Ventura does not like. Basically, Ventura gives strange
  2312                                  ; errors if it gets a memory alloc that it is below its load segment. The
  2313                                  ; freed environment creates a large enough hole for some of its allocs to fit
  2314                                  ; in
  2315                                  
  2316                                  	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
  2317                                          ;je	short no_free	    ; no, do not free it
  2318                                  	; 21/01/2023
  2319                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
  2320 0000032A 803E[881E]00            	cmp	byte [AllocedEnv],0 ; flag - old environment segment
  2321                                  	; !!!! ; 15/08/2024 (!BugFix!)
  2322                                  	;jne	short no_free	; MSDOS 5.0 COMMAND.COM - RESGROUP:039Dh
  2323                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:0467h
  2324 0000032F 7406                    	je	short no_free	; PCDOS 7.1 COMMAND.COM - RESGROUP:04C0h
  2325                                  
  2326 00000331 8EC5                    	mov	es,bp
  2327 00000333 B449                    	mov	ah,49h
  2328                                  	;mov	ah,DEALLOC
  2329 00000335 CD21                    	int	21h		    ; Free it
  2330                                  no_free:
  2331                                  
  2332                                  ; M004; Start of changes
  2333                                  
  2334                                  ; Move the transient now. We will allocate the biggest block available
  2335                                  ; now and move the transient to the top of the block. We will then
  2336                                  ; deallocate this block. When the resident starts executing, it will
  2337                                  ; hopefully allocate this block again and find the transient intact.
  2338                                  
  2339 00000337 C606[2F02]01            	mov	byte [TrnMvFlg],1 ; Indicate that transient has been moved
  2340 0000033C 06                      	push	es
  2341                                  	;;mov	si,offset ResGroup:TranStart
  2342                                  	; 09/01/2023
  2343                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
  2344                                  	; 05/06/2023
  2345                                  	;mov	si,26E0h	; MSDOS 6.22 COMMAND.COM RESGROUP:0475h
  2346 0000033D BE5025                  	mov	si,TRANSTART	; (End of the resident portion)
  2347                                  	;mov	di,0
  2348 00000340 31FF                    	xor	di,di ; 0
  2349                                  	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
  2350                                  	;mov	cx,98C5h
  2351                                  	; 05/06/2023 - MSDOS 6.22 COMMAND.COM RESGROUP:047Bh
  2352                                  	;mov	cx,0AF95h	; TRANSIENT portion size
  2353 00000342 B901AA                  	mov	cx,TRANSPACEEND
  2354                                  	
  2355                                  ; Find the largest block available
  2356                                  
  2357 00000345 BBFFFF                  	mov	bx,0FFFFh
  2358 00000348 B448                    	mov	ah,48h
  2359                                  	;mov	ah,ALLOC
  2360 0000034A CD21                    	int	21h
  2361                                  
  2362                                  ; dx = size of transient saved previously 
  2363                                  
  2364 0000034C 39D3                    	cmp	bx,dx		; enough memory?
  2365 0000034E 722B                    	jb	short nomem_err	; not enough memory for transient
  2366                                  
  2367 00000350 B448                    	mov	ah,48h
  2368                                  	;mov	ah,ALLOC
  2369 00000352 CD21                    	int	21h		; get the largest block
  2370 00000354 7225                    	jc	short nomem_err	; something is really screwed up
  2371                                  
  2372 00000356 50                      	push	ax		; save memory address
  2373 00000357 01D8                    	add	ax,bx		; ax = top of my memory block
  2374 00000359 29D0                    	sub	ax,dx		; less size of transient
  2375 0000035B A3[2D02]                	mov	[TrnSeg],ax	; save transient segment
  2376 0000035E 8EC0                    	mov	es,ax		;
  2377 00000360 58                      	pop	ax		; restore our seg addr
  2378                                  
  2379                                  ; Everything is set for a move. We need to move in the reverse direction to
  2380                                  ; make sure we dont overwrite ourselves while copying
  2381                                  
  2382 00000361 01CE                    	add	si,cx
  2383 00000363 4E                      	dec	si
  2384 00000364 01CF                    	add	di,cx
  2385 00000366 4F                      	dec	di
  2386 00000367 FD                      	std
  2387 00000368 F3A4                    	rep	movsb
  2388 0000036A FC                      	cld
  2389                                  
  2390                                  ; Now we have to free up this block so that resident can get hold of it
  2391                                  
  2392 0000036B 8EC0                    	mov	es,ax
  2393 0000036D B449                    	mov	ah,49h
  2394                                  	;mov	ah,DEALLOC
  2395 0000036F CD21                    	int	21h		; release the memory block
  2396                                  
  2397                                  ; M004; End of changes
  2398                                  
  2399                                  	;mov	InitFlag,FALSE	; indicate INIT is done
  2400                                  	; 09/01/2023
  2401 00000371 C606[B402]00            	mov	byte [InitFlag],0	
  2402                                  
  2403 00000376 07                      	pop	es
  2404 00000377 1F                      	pop	ds
  2405                                  	;assume	ds:nothing
  2406                                  	
  2407                                  	; Bugbug: did we need to save & restore seg reg's during EndInit?
  2408                                  	
  2409 00000378 E903FD                  	jmp	LodCom_Trap	; allocate transient
  2410                                  
  2411                                  nomem_err:
  2412                                  
  2413                                  ;We call the error routine which will never return. It will either exit
  2414                                  ;with an error ( if not the first COMMAND ) or just hang after an error 
  2415                                  ;message ( if first COMMAND )
  2416                                  
  2417 0000037B E9761A                  	jmp	Alloc_error
  2418                                  
  2419                                  ;EndCodeInit:	; label	byte		; M004
  2420                                  
  2421                                  	; 16/04/2023
  2422                                  	EndCodeInit equ $
  2423                                  
  2424                                  ;; M004; Check if the EndInit code will fit into the Pipe buffers above.
  2425                                  ;; M004; If not, we signal an assembly error
  2426                                  ;
  2427                                  ;IF2
  2428                                  ;	IF ($ GT EndPipe)
  2429                                  ;		.err
  2430                                  ;		%out	"ENDINIT CODE TOO BIG"
  2431                                  ;	ENDIF
  2432                                  ;ENDIF
  2433                                  
  2434                                  ;; M004; Set the origin back to what it was at the end of the buffers
  2435                                  ;;
  2436                                  ;		ORG	EndPipe		; M004
  2437                                  
  2438                                  ; 09/01/2023
  2439                                  ; MSDOS 5.0 COMMAND.COM - CODERES:03EDh
  2440                                  ; 05/06/2023
  2441                                  ; MSDOS 6.22 COMMAND.COM - CODERES:04B7h
  2442                                  ;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)
  2443                                  
  2444                                  ; 16/04/2023
  2445                                  	FillBytes equ EndPipe - EndCodeInit
  2446                                  
  2447                                  ;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
  2448                                  ; 16/04/2023
  2449                                  %if FillBytes>0
  2450                                  	;times EndPipe - EndCodeInit db 0
  2451 0000037E 00<rep 5Ah>             	times FillBytes db 0
  2452                                  %endif
  2453                                  
  2454                                  ; 09/01/2023 - Retrodos v4.0 (& v4.1)
  2455                                  ; MSDOS 5.0 COMMAND.COM - CODERES:0441h ; EndInit+289
  2456                                  
  2457                                  ; 05/06/2023 - Retrodos v4.2
  2458                                  ; MSDOS 6.22 COMMAND.COM - CODERES:050Bh ; EndInit+289
  2459                                  
  2460                                  ;InPipePtr	dw	offset DATARES:Pipe1	; 320h
  2461                                  ;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh
  2462                                  
  2463 000003D8 [B702]                  InPipePtr:	dw	Pipe1 ;; 320h for MSDOS 5.0 COMMAND.COM
  2464                                  			      ; 3EAh for MSDOS 6.22 COMMAND.COM
  2465 000003DA [0603]                  OutPipePtr:	dw	Pipe2 ;; 36Fh for MSDOS 5.0 COMMAND.COM
  2466                                  			      ; 439h for MSDOS 6.22 COMMAND.COM
  2467                                  
  2468                                  Exec_Block:	; label	byte	; the data block for exec calls
  2469 000003DC 0000                    EnvirSeg:	dw	0
  2470                                  Com_Ptr:	; label	dword
  2471 000003DE 8000                    		dw	80h	; point at unformatted parameters
  2472 000003E0 0000                    		dw	0
  2473                                  Com_Fcb1:	; label	dword
  2474 000003E2 5C00                    		dw	5Ch
  2475 000003E4 0000                    		dw	0
  2476                                  Com_Fcb2:	; label	dword
  2477 000003E6 6C00                    		dw	6Ch
  2478 000003E8 0000                    		dw	0
  2479                                  
  2480                                  ; variables passed to transient
  2481                                  TranVars:	; label	byte
  2482                                  		;dw	offset DATARES:HeadFix_Trap
  2483 000003EA [9200]                  		dw	HeadFix_Trap
  2484 000003EC 0000                    MySeg:		dw	0	; put our own segment here
  2485 000003EE 0000                    LTpa:		dw	0	; will store tpa segment here
  2486 000003F0 2F                      RSwitChar:	db	"/"
  2487 000003F1 5C                      RDirChar:	db	"\"
  2488                                  		;dw	offset DATARES:Issue_Exec_Call
  2489 000003F2 [8501]                  		dw	Issue_Exec_Call
  2490 000003F4 0000                    MySeg1:		dw	0
  2491                                  		;dw	offset DATARES:RemCheck_Trap
  2492 000003F6 [6A00]                  		dw	RemCheck_Trap
  2493 000003F8 0000                    MySeg2:		dw	0
  2494                                  
  2495                                  ; 14/08/2024 - PCDOS 7.1 COMMAND.COM
  2496                                  %if 0
  2497                                  ResTest: 	dw	0
  2498                                  %endif
  2499                                  
  2500 000003FA 0000                    Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
  2501                                  
  2502                                  ; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
  2503 000003FC 0000                    Y_Flag:		dw	0
  2504                                  
  2505                                  TranVarEnd:	; label	byte
  2506                                  
  2507 000003FE 0000                    OldErrNo:	dw	0
  2508                                  
  2509                                  ;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
  2510                                  ;  MsgBuffer is only used while a command is being executed.
  2511                                  ;  SafePathBuffer is no longer needed, since it is used for
  2512                                  ;  unsuccessful program launches.
  2513                                  
  2514                                  MsgBuffer:	; label	byte	; buffer for messages from disk
  2515                                  SafePathBuffer: ; label	byte	; resident pathname for EXEC
  2516                                  	;Bugbug: Why so big a buffer?
  2517                                  		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
  2518 00000400 00<rep 50h>             		times	64+3+13 db 0		
  2519                                  
  2520                                  LENMSGORPATHBUF	equ $ - MsgBuffer
  2521                                  
  2522 00000450 00000000                Int2fHandler:	dd	0	; address of next int 2f handler
  2523 00000454 0000                    ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)
  2524                                  
  2525                                  ;SR;
  2526                                  ; The three vars below have been added for a pure COMMAND.COM
  2527                                  
  2528 00000456 0000                    ResSize:	dw	0
  2529                                  
  2530                                  ;SR;
  2531                                  ; Moved the stack here from the code segment
  2532                                  ;
  2533                                  ; bugbug: Why this odd stack size? And what should stack size be?
  2534                                  	
  2535                                  		;db	(80h - 3) dup (?)
  2536                                  align 2
  2537 00000458 00<rep 7Ch>             		times	124 db 0		
  2538                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
  2539                                  ; 05/06/2023
  2540                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:060Ah (offset RStack)
  2541                                  RStack:		; label	word
  2542 000004D4 0000                    OldDS:		dw	0	; keeps old ds value when jumping to
  2543                                  				; resident code segments
  2544                                  ;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003
  2545                                  
  2546                                  ; include highvar.inc		; Add variables for 6.0 loadhigh functionality
  2547                                  ; -------------------------------
  2548                                  
  2549                                  ; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
  2550                                  ; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
  2551                                  ; SegLoad  - Segment address for first UMB specified; set automatically.
  2552                                  ; UmbLoad  - The load UMB number; for example, this is 3 if the user has
  2553                                  ;            given a command-line like "/L:3,500;4"
  2554                                  ; UmbUsed  - An array of characters, each of which is 1 if the UMB
  2555                                  ;            matching its index number was specified on the command-line;
  2556                                  ;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  2557                                  ;            will be set to 1. All others will be set to 0.
  2558                                  ; UmbSize  - An array of words, each of which is interpreted as a size
  2559                                  ;            specified by the user for a UMB (in the above example, all
  2560                                  ;            elements would be zero save UmbSize[3], which would be 500.
  2561                                  ; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
  2562                                  ; fm_strat - Set to the old memory-allocation strategy (0$00000???)
  2563                                  ; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  2564                                  ;            for details).
  2565                                  
  2566                                  ; - MSDOS 6.0 COMMAND.COM -
  2567                                  ;; To keep track of which UMBs were specified on the DH/LH command lines, and
  2568                                  ;; to keep track of the minimum sizes given for each, there're two arrays kept
  2569                                  ;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  2570                                  ;; big. 16 should be around 14 too many for most users, so there's no expected
  2571                                  ;; space problem (it's just such a nice round number, eh?).
  2572                                  
  2573                                  ; 05/06/2023
  2574                                  MAXUMB	equ	16
  2575                                  
  2576                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2577                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)
  2578                                  
  2579 000004D6 00                      fInHigh:	db	0
  2580                                  
  2581                                  ; MSDOS 6.0 COMMAND.COM
  2582                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  2583                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:060Dh (DATARES:060Dh)
  2584 000004D7 00                      fUmbTiny:	db	0
  2585 000004D8 0000                    SegLoad:	dw	0
  2586 000004DA 00                      UmbLoad:	db	0
  2587                                  
  2588                                  ; 19/07/2024
  2589                                  ; PCDOS 7.1 COMMAND.COM
  2590                                  %if 0
  2591                                  UmbUsed:	times MAXUMB db 0 ; db MAXUMB dup (?)
  2592                                  UmbSize:	times MAXUMB dw 0 ; dw MAXUMB dup (?)
  2593                                  %else
  2594                                  	; 19/07/2024 - Retro DOS v5.0 (& v4.2) COMMAND.COM
  2595                                  	UmbUsed equ MsgBuffer	; 16 bytes
  2596                                  	UmbSize equ UmbUsed+MAXUMB ; UmbUsed+16; 16 words
  2597                                  %endif
  2598                                  
  2599 000004DB 00                      fm_umb:		db	0
  2600 000004DC 00                      fm_strat:	db	0
  2601 000004DD 00                      fm_argc:	db	0
  2602                                  
  2603                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  2604                                  ; UmbLoad is set to the UMB number given.
  2605                                  
  2606                                  ;*** MESSAGES
  2607                                  ;    and other translatable text
  2608                                  
  2609                                  ; include comrmsg.inc	; M00
  2610                                  ; ------------------------------
  2611                                  
  2612                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2613                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)
  2614                                  
  2615                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  2616                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0644h (DATARES:0644h)
  2617                                  
  2618 000004DE 41                      ABORT_CHAR:	db 'A'
  2619 000004DF 52                      RETRY_CHAR:	db 'R'
  2620 000004E0 49                      IGNORE_CHAR:	db 'I'
  2621 000004E1 46                      FAIL_CHAR:	db 'F'
  2622 000004E2 59                      YES_CHAR:	db 'Y'
  2623 000004E3 4E                      NO_CHAR:	db 'N'
  2624 000004E4 05                      REQ_ABORT:	db 5
  2625 000004E5 41626F7274              		db 'Abort'
  2626 000004EA 07                      REQ_RETRY:	db 7
  2627 000004EB 2C205265747279          		db ', Retry'
  2628 000004F2 08                      REQ_IGNORE:	db 8
  2629 000004F3 2C2049676E6F7265        		db ', Ignore'
  2630 000004FB 06                      REQ_FAIL:	db 6
  2631 000004FC 2C204661696C            		db ', Fail'
  2632 00000502 01                      REQ_END:	db 1
  2633 00000503 3F                      		db '?'
  2634 00000504 08                      MREAD:		db 8
  2635 00000505 72656164696E6700        		db 'reading', 0
  2636 0000050D 08                      MWRITE:		db 8
  2637 0000050E 77726974696E6700        		db 'writing', 0
  2638 00000516 0E                      MDRIVE:		db 14
  2639 00000517 202531206472697665-     		db ' %1 drive %2',0Dh,0Ah
  2639 00000520 2025320D0A         
  2640 00000525 0F                      MDEVICE:	db 15
  2641 00000526 202531206465766963-     		db ' %1 device %2',0Dh,0Ah
  2641 0000052F 652025320D0A       
  2642 00000535 26                      MVOLSERIAL:	db 38
  2643 00000536 506C6561736520696E-     		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
  2643 0000053F 7365727420766F6C75-
  2643 00000548 6D6520253120736572-
  2643 00000551 69616C2025322D2533-
  2643 0000055A 0D0A               
  2644 0000055C 25                      BADFATMSG:	db 37
  2645 0000055D 46696C6520616C6C6F-     		db 'File allocation table bad, drive %1',0Dh,0Ah
  2645 00000566 636174696F6E207461-
  2645 0000056F 626C65206261642C20-
  2645 00000578 64726976652025310D-
  2645 00000581 0A                 
  2646 00000582 15                      COMBAD:		db 21
  2647 00000583 496E76616C69642043-     		db 'Invalid COMMAND.COM',0Dh,0Ah
  2647 0000058C 4F4D4D414E442E434F-
  2647 00000595 4D0D0A             
  2648 00000598 21                      PUTBACKMSG:	db 33
  2649 00000599 496E73657274206469-     		db 'Insert disk with %1 in drive %2',0Dh,0Ah
  2649 000005A2 736B20776974682025-
  2649 000005AB 3120696E2064726976-
  2649 000005B4 652025320D0A       
  2650 000005BA 21                      PROMPT:		db 33
  2651 000005BB 507265737320616E79-     		db 'Press any key to continue . . .',0Dh,0Ah
  2651 000005C4 206B657920746F2063-
  2651 000005CD 6F6E74696E7565202E-
  2651 000005D6 202E202E0D0A       
  2652 000005DC 1C                      ENDBATMES:	db 28
  2653 000005DD 0D0A                    		db 0Dh,0Ah
  2654 000005DF 5465726D696E617465-     		db 'Terminate batch job (Y/N)?'
  2654 000005E8 206261746368206A6F-
  2654 000005F1 622028592F4E293F   
  2655 000005F9 13                      EXECEMES:	db 19
  2656 000005FA 43616E6E6F74206578-     		db 'Cannot execute %1',0Dh,0Ah
  2656 00000603 65637574652025310D-
  2656 0000060C 0A                 
  2657 0000060D 13                      EXEBAD:		db 19
  2658 0000060E 4572726F7220696E20-     		db 'Error in EXE file',0Dh,0Ah
  2658 00000617 4558452066696C650D-
  2658 00000620 0A                 
  2659 00000621 22                      TOOBIG:		db 34
  2660 00000622 50726F6772616D2074-     		db 'Program too big to fit in memory',0Dh,0Ah
  2660 0000062B 6F6F2062696720746F-
  2660 00000634 2066697420696E206D-
  2660 0000063D 656D6F72790D0A     
  2661 00000644 16                      NOHANDMES:	db 22
  2662 00000645 0D0A                    		db 0Dh,0Ah
  2663 00000647 4E6F20667265652066-     		db 'No free file handles'
  2663 00000650 696C652068616E646C-
  2663 00000659 6573               
  2664 0000065B 1A                      RBADNAM:	db 26
  2665 0000065C 42616420436F6D6D61-     		db 'Bad Command or file name',0Dh,0Ah
  2665 00000665 6E64206F722066696C-
  2665 0000066E 65206E616D650D0A   
  2666                                  ACCDENIED:	; 14/01/2023
  2667                                  		; 10/01/2023
  2668                                  ACCDEN:		;db 14
  2669                                  		;db 'Access denied '
  2670                                  		; 19/07/2024 - PCDOS 7.1
  2671 00000676 0D                      		db 13
  2672 00000677 416363657373206465-     		db 'Access denied'
  2672 00000680 6E696564           
  2673 00000684 19                      BMEMMES:	db 25
  2674 00000685 0D0A4D656D6F727920-     		db 0Dh,0Ah,'Memory allocation error'
  2674 0000068E 616C6C6F636174696F-
  2674 00000697 6E206572726F72     
  2675 0000069E 26                      HALTMES:	db 38
  2676 0000069F 0D0A                    		db 0Dh,0Ah
  2677 000006A1 43616E6E6F74206C6F-     		db 'Cannot load COMMAND, system halted',0Dh,0Ah
  2677 000006AA 616420434F4D4D414E-
  2677 000006B3 442C2073797374656D-
  2677 000006BC 2068616C7465640D0A 
  2678 000006C5 21                      FRETMES:	db 33
  2679 000006C6 0D0A                    		db 0Dh,0Ah,
  2680 000006C8 43616E6E6F74207374-     		db 'Cannot start COMMAND, exiting',0Dh,0Ah
  2680 000006D1 61727420434F4D4D41-
  2680 000006DA 4E442C206578697469-
  2680 000006E3 6E670D0A           
  2681 000006E7 2E                      PATRICIDE:	db 46
  2682 000006E8 0D0A                    		db 0Dh,0Ah
  2683 000006EA 546F70206C6576656C-     		db 'Top level process aborted, cannot continue'
  2683 000006F3 2070726F6365737320-
  2683 000006FC 61626F727465642C20-
  2683 00000705 63616E6E6F7420636F-
  2683 0000070E 6E74696E7565       
  2684 00000714 0D0A                    		db 0Dh,0Ah
  2685 00000716 02                      NEWLINE:	db 2
  2686 00000717 0D0A                    		db 0Dh, 0Ah
  2687                                  
  2688                                  ; 10/01/2023
  2689                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh
  2690                                  ; 05/06/2023
  2691                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0880h
  2692                                  
  2693 00000719 [FD0B]                  MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
  2694 0000071B 0100                    		dw 1
  2695 0000071D [B809]                  		dw PARSMSGPTRS		; parse	error messages
  2696 0000071F 0100                    		dw 1
  2697 00000721 [FD0B]                  		dw EXTMSGPTRS		; critical error messages
  2698 00000723 0100                    		dw 1
  2699 00000725 0000                    		dw 0			; File system error messages
  2700 00000727 0000                    		dw 0			; are not supported.
  2701 00000729 [8800]                  		dw MsgRetrv_Trap	; disk retriever routine
  2702 0000072B 0000                    MySeg3:		dw 0			; segment of retriever routine
  2703                                  
  2704                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0791h
  2705                                  ; 05/06/2023
  2706                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0894h
  2707                                  
  2708 0000072D 13                      CRMSG0:		db 19
  2709 0000072E 57726974652070726F-     		db 'Write protect error'
  2709 00000737 74656374206572726F-
  2709 00000740 72                 
  2710 00000741 0C                      CRMSG1:		db 12
  2711 00000742 496E76616C69642075-     		db 'Invalid unit'
  2711 0000074B 6E6974             
  2712 0000074E 09                      CRMSG2:		db 9
  2713 0000074F 4E6F74207265616479      		db 'Not ready'
  2714 00000758 16                      CRMSG3:		db 22
  2715 00000759 496E76616C69642064-     		db 'Invalid device request'
  2715 00000762 657669636520726571-
  2715 0000076B 75657374           
  2716 0000076F 0A                      CRMSG4:		db 10
  2717 00000770 44617461206572726F-     		db 'Data error'
  2717 00000779 72                 
  2718 0000077A 21                      CRMSG5:		db 33
  2719 0000077B 496E76616C69642064-     		db 'Invalid device request parameters'
  2719 00000784 657669636520726571-
  2719 0000078D 756573742070617261-
  2719 00000796 6D6574657273       
  2720 0000079C 0A                      CRMSG6:		db 10
  2721 0000079D 5365656B206572726F-     		db 'Seek error'
  2721 000007A6 72                 
  2722 000007A7 12                      CRMSG7:		db 18
  2723 000007A8 496E76616C6964206D-     		db 'Invalid media type'
  2723 000007B1 656469612074797065 
  2724 000007BA 10                      CRMSG8:		db 16
  2725 000007BB 536563746F72206E6F-     		db 'Sector not found'
  2725 000007C4 7420666F756E64     
  2726 000007CB 1A                      CRMSG9:		db 26
  2727 000007CC 5072696E746572206F-     		db 'Printer out of paper error'
  2727 000007D5 7574206F6620706170-
  2727 000007DE 6572206572726F72   
  2728 000007E6 11                      CRMSG10:	db 17
  2729 000007E7 577269746520666175-     		db 'Write fault error'
  2729 000007F0 6C74206572726F72   
  2730 000007F8 10                      CRMSG11:	db 16
  2731 000007F9 52656164206661756C-     		db 'Read fault error'
  2731 00000802 74206572726F72     
  2732 00000809 0F                      CRMSG12:	db 15
  2733 0000080A 47656E6572616C2066-     		db 'General failure'
  2733 00000813 61696C757265       
  2734 00000819 11                      CRMSG13:	db 17
  2735 0000081A 53686172696E672076-     		db 'Sharing violation'
  2735 00000823 696F6C6174696F6E   
  2736 0000082B 0E                      CRMSG14:	db 14
  2737 0000082C 4C6F636B2076696F6C-     		db 'Lock violation'
  2737 00000835 6174696F6E         
  2738 0000083A 13                      CRMSG15:	db 19
  2739 0000083B 496E76616C69642064-     		db 'Invalid disk change'
  2739 00000844 69736B206368616E67-
  2739 0000084D 65                 
  2740 0000084E 0F                      CRMSG16:	db 15
  2741 0000084F 46434220756E617661-     		db 'FCB unavailable'
  2741 00000858 696C61626C65       
  2742 0000085E 19                      CRMSG17:	db 25
  2743 0000085F 53797374656D207265-     		db 'System resource exhausted'
  2743 00000868 736F75726365206578-
  2743 00000871 68617573746564     
  2744 00000878 12                      CRMSG18:	db 18
  2745 00000879 436F64652070616765-     		db 'Code page mismatch'
  2745 00000882 206D69736D61746368 
  2746 0000088B 0C                      CRMSG19:	db 12
  2747 0000088C 4F7574206F6620696E-     		db 'Out of input'
  2747 00000895 707574             
  2748 00000898 17                      CRMSG20:	db 23
  2749 00000899 496E73756666696369-     		db 'Insufficient disk space'
  2749 000008A2 656E74206469736B20-
  2749 000008AB 7370616365         
  2750                                  
  2751                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0914h
  2752                                  ; 05/06/2023
  2753                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0A17h
  2754                                  
  2755 000008B0 [2D07]                  CRITMSGPTRS:	dw CRMSG0
  2756 000008B2 [4107]                  		dw CRMSG1
  2757 000008B4 [4E07]                  		dw CRMSG2
  2758 000008B6 [5807]                  		dw CRMSG3
  2759 000008B8 [6F07]                  		dw CRMSG4
  2760 000008BA [7A07]                  		dw CRMSG5
  2761 000008BC [9C07]                  		dw CRMSG6
  2762 000008BE [A707]                  		dw CRMSG7
  2763 000008C0 [BA07]                  		dw CRMSG8
  2764 000008C2 [CB07]                  		dw CRMSG9
  2765 000008C4 [E607]                  		dw CRMSG10
  2766 000008C6 [F807]                  		dw CRMSG11
  2767 000008C8 [0908]                  		dw CRMSG12
  2768 000008CA [1908]                  		dw CRMSG13
  2769 000008CC [2B08]                  		dw CRMSG14
  2770 000008CE [3A08]                  		dw CRMSG15
  2771 000008D0 [4E08]                  		dw CRMSG16
  2772 000008D2 [5E08]                  		dw CRMSG17
  2773 000008D4 [7808]                  		dw CRMSG18
  2774 000008D6 [8B08]                  		dw CRMSG19
  2775 000008D8 [9808]                  		dw CRMSG20
  2776                                  
  2777                                  		; 14/01/2023
  2778                                  ;DataresEnd:	;; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)
  2779                                  		; 05/06/2023
  2780                                  DataresEnd:	; MSDOS 6.22 COMMAND.COM - DATARES:0A41h (RESGROUP:0A41h)
  2781                                  
  2782 000008DA 13                      PAERRMSG0:	db 19
  2783 000008DB 546F6F206D616E7920-     		db 'Too many parameters'
  2783 000008E4 706172616D65746572-
  2783 000008ED 73                 
  2784 000008EE 1A                      PAERRMSG1:	db 26
  2785 000008EF 526571756972656420-     		db 'Required parameter missing'
  2785 000008F8 706172616D65746572-
  2785 00000901 206D697373696E67   
  2786 00000909 0E                      PAERRMSG2:	db 14
  2787 0000090A 496E76616C69642073-     		db 'Invalid switch'
  2787 00000913 7769746368         
  2788 00000918 0F                      PAERRMSG3:	db 15
  2789 00000919 496E76616C6964206B-     		db 'Invalid keyword'
  2789 00000922 6579776F7264       
  2790 00000928 01                      PAERRMSG4:	db 1
  2791 00000929 20                      		db 20h
  2792 0000092A 24                      PAERRMSG5:	db 36
  2793 0000092B 506172616D65746572-     		db 'Parameter value not in allowed range'
  2793 00000934 2076616C7565206E6F-
  2793 0000093D 7420696E20616C6C6F-
  2793 00000946 7765642072616E6765 
  2794                                  PAERRMSG6:	; 10/01/2023
  2795 0000094F 1B                      PAERRMSG7:	db 27
  2796 00000950 506172616D65746572-     		db 'Parameter value not allowed'
  2796 00000959 2076616C7565206E6F-
  2796 00000962 7420616C6C6F776564 
  2797                                  ;PAERRMSG7:	db 27
  2798                                  ;		db 'Parameter value not allowed'
  2799 0000096B 1C                      PAERRMSG8:	db 28
  2800 0000096C 506172616D65746572-     		db 'Parameter format not correct'
  2800 00000975 20666F726D6174206E-
  2800 0000097E 6F7420636F72726563-
  2800 00000987 74                 
  2801 00000988 11                      PAERRMSG9:	db 17
  2802 00000989 496E76616C69642070-     		db 'Invalid parameter'
  2802 00000992 6172616D65746572   
  2803 0000099A 1D                      PAERRMSG10:	db 29
  2804 0000099B 496E76616C69642070-     		db 'Invalid parameter combination'
  2804 000009A4 6172616D6574657220-
  2804 000009AD 636F6D62696E617469-
  2804 000009B6 6F6E               
  2805                                  
  2806                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h
  2807                                  ; 05/06/2023
  2808                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0B3Bh
  2809                                  
  2810 000009B8 [DA08]                  PARSMSGPTRS:	dw PAERRMSG0
  2811 000009BA [EE08]                  		dw PAERRMSG1
  2812 000009BC [0909]                  		dw PAERRMSG2
  2813 000009BE [1809]                  		dw PAERRMSG3
  2814 000009C0 [2809]                  		dw PAERRMSG4
  2815 000009C2 [2A09]                  		dw PAERRMSG5
  2816 000009C4 [4F09]                  		dw PAERRMSG6
  2817 000009C6 [4F09]                  		dw PAERRMSG7
  2818 000009C8 [6B09]                  		dw PAERRMSG8
  2819 000009CA [8809]                  		dw PAERRMSG9
  2820 000009CC [9A09]                  		dw PAERRMSG10
  2821                                  ; 21/04/2023
  2822                                  NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023
  2823                                  
  2824 000009CE 10                      INVLFUNCT:	db 16
  2825 000009CF 496E76616C69642066-     		db 'Invalid function'
  2825 000009D8 756E6374696F6E     
  2826 000009DF 0E                      FNOTFOUND:	db 14
  2827 000009E0 46696C65206E6F7420-     		db 'File not found'
  2827 000009E9 666F756E64         
  2828 000009EE 0E                      PNOTFOUND:	db 14
  2829 000009EF 50617468206E6F7420-     		db 'Path not found'
  2829 000009F8 666F756E64         
  2830 000009FD 13                      TOOMANYOF:	db 19
  2831 000009FE 546F6F206D616E7920-     		db 'Too many open files'
  2831 00000A07 6F70656E2066696C65-
  2831 00000A10 73                 
  2832                                  ; 14/01/2023
  2833                                  ;ACCDEN:	; 10/01/2023
  2834                                  ;ACCDENIED:	db 14
  2835                                  ;		db 'Access denied '
  2836 00000A11 0E                      INVHANDLE:	db 14
  2837 00000A12 496E76616C69642068-     		db 'Invalid handle'
  2837 00000A1B 616E646C65         
  2838 00000A20 1F                      MEMCBDEST:	db 31
  2839 00000A21 4D656D6F727920636F-     		db 'Memory control blocks destroyed'
  2839 00000A2A 6E74726F6C20626C6F-
  2839 00000A33 636B73206465737472-
  2839 00000A3C 6F796564           
  2840 00000A40 13                      INSUFFMEM:	db 19
  2841 00000A41 496E73756666696369-     		db 'Insufficient memory'
  2841 00000A4A 656E74206D656D6F72-
  2841 00000A53 79                 
  2842 00000A54 1C                      INVMEMBLA:	db 28
  2843 00000A55 496E76616C6964206D-     		db 'Invalid memory block address'
  2843 00000A5E 656D6F727920626C6F-
  2843 00000A67 636B20616464726573-
  2843 00000A70 73                 
  2844 00000A71 13                      INVENVIRO:	db 19
  2845 00000A72 496E76616C69642045-     		db 'Invalid Environment'
  2845 00000A7B 6E7669726F6E6D656E-
  2845 00000A84 74                 
  2846 00000A85 0E                      INVFORMAT:	db 14
  2847 00000A86 496E76616C69642066-     		db 'Invalid format'
  2847 00000A8F 6F726D6174         
  2848 00000A94 1A                      INVFNPARM:	db 26
  2849 00000A95 496E76616C69642066-     		db 'Invalid function parameter'
  2849 00000A9E 756E6374696F6E2070-
  2849 00000AA7 6172616D65746572   
  2850 00000AAF 0C                      INVLDDATA:	db 12
  2851 00000AB0 496E76616C69642064-     		db 'Invalid data'
  2851 00000AB9 617461             
  2852 00000ABC 1B                      INVDRVSPC:	db 27
  2853 00000ABD 496E76616C69642064-     		db 'Invalid drive specification'
  2853 00000AC6 726976652073706563-
  2853 00000ACF 696669636174696F6E 
  2854 00000AD8 23                      ATRCURDIR:	db 35
  2855 00000AD9 417474656D70742074-     		db 'Attempt to remove current directory'
  2855 00000AE2 6F2072656D6F766520-
  2855 00000AEB 63757272656E742064-
  2855 00000AF4 69726563746F7279   
  2856 00000AFC 0F                      NOTSAMDEV:	db 15
  2857 00000AFD 4E6F742073616D6520-     		db 'Not same device'
  2857 00000B06 646576696365       
  2858 00000B0C 0D                      NOMOREFIL:	db 13
  2859 00000B0D 4E6F206D6F72652066-     		db 'No more files'
  2859 00000B16 696C6573           
  2860 00000B1A 0B                      FILEXISTS:	db 11
  2861 00000B1B 46696C652065786973-     		db 'File exists'
  2861 00000B24 7473               
  2862 00000B26 1B                      CANTMKDIR:	db 27
  2863 00000B27 43616E6E6F74206D61-     		db 'Cannot make directory entry'
  2863 00000B30 6B6520646972656374-
  2863 00000B39 6F727920656E747279 
  2864 00000B42 0E                      FAILINT24:	db 14
  2865 00000B43 4661696C206F6E2049-     		db 'Fail on INT 24'
  2865 00000B4C 4E54203234         
  2866 00000B51 15                      TOOMANYRD:	db 21
  2867 00000B52 546F6F206D616E7920-     		db 'Too many redirections'
  2867 00000B5B 726564697265637469-
  2867 00000B64 6F6E73             
  2868 00000B67 15                      DUPLREDIR:	db 21
  2869 00000B68 4475706C6963617465-     		db 'Duplicate redirection'
  2869 00000B71 207265646972656374-
  2869 00000B7A 696F6E             
  2870 00000B7D 10                      INVPASSWD:	db 16
  2871 00000B7E 496E76616C69642070-     		db 'Invalid password'
  2871 00000B87 617373776F7264     
  2872 00000B8E 11                      INVLDPARM:	db 17
  2873 00000B8F 496E76616C69642070-     		db 'Invalid parameter'
  2873 00000B98 6172616D65746572   
  2874 00000BA0 12                      NETDATFAU:	db 18
  2875 00000BA1 4E6574776F726B2064-     		db 'Network data fault'
  2875 00000BAA 617461206661756C74 
  2876 00000BB3 21                      FNOSUPNET:	db 33
  2877 00000BB4 46756E6374696F6E20-     		db 'Function not supported by network'
  2877 00000BBD 6E6F7420737570706F-
  2877 00000BC6 72746564206279206E-
  2877 00000BCF 6574776F726B       
  2878 00000BD5 27                      RSCNOTINS:	db 39
  2879 00000BD6 526571756972656420-     		db 'Required system component not installed'
  2879 00000BDF 73797374656D20636F-
  2879 00000BE8 6D706F6E656E74206E-
  2879 00000BF1 6F7420696E7374616C-
  2879 00000BFA 6C6564             
  2880                                  
  2881                                  ;; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch
  2882                                  ; 05/06/2023
  2883                                  ; MSDOS 6.22 COMMAND.COM RESGROUP:0D8Fh
  2884                                  
  2885 00000BFD [CE09]                  EXTMSGPTRS:	dw INVLFUNCT
  2886 00000BFF [DF09]                  		dw FNOTFOUND
  2887 00000C01 [EE09]                  		dw PNOTFOUND
  2888 00000C03 [FD09]                  		dw TOOMANYOF
  2889 00000C05 [7606]                  		dw ACCDENIED
  2890 00000C07 [110A]                  		dw INVHANDLE
  2891 00000C09 [200A]                  		dw MEMCBDEST
  2892 00000C0B [400A]                  		dw INSUFFMEM
  2893 00000C0D [540A]                  		dw INVMEMBLA
  2894 00000C0F [710A]                  		dw INVENVIRO
  2895 00000C11 [850A]                  		dw INVFORMAT
  2896 00000C13 [940A]                  		dw INVFNPARM
  2897 00000C15 [AF0A]                  		dw INVLDDATA
  2898 00000C17 0000                    		dw 0
  2899 00000C19 [BC0A]                  		dw INVDRVSPC
  2900 00000C1B [D80A]                  		dw ATRCURDIR
  2901 00000C1D [FC0A]                  		dw NOTSAMDEV
  2902 00000C1F [0C0B]                  		dw NOMOREFIL
  2903 00000C21 [2D07]                  		dw CRMSG0
  2904 00000C23 [4107]                  		dw CRMSG1
  2905 00000C25 [4E07]                  		dw CRMSG2
  2906 00000C27 [5807]                  		dw CRMSG3
  2907 00000C29 [6F07]                  		dw CRMSG4
  2908 00000C2B [7A07]                  		dw CRMSG5
  2909 00000C2D [9C07]                  		dw CRMSG6
  2910 00000C2F [A707]                  		dw CRMSG7
  2911 00000C31 [BA07]                  		dw CRMSG8
  2912 00000C33 [CB07]                  		dw CRMSG9
  2913 00000C35 [E607]                  		dw CRMSG10
  2914 00000C37 [F807]                  		dw CRMSG11
  2915 00000C39 [0908]                  		dw CRMSG12
  2916 00000C3B [1908]                  		dw CRMSG13
  2917 00000C3D [2B08]                  		dw CRMSG14
  2918 00000C3F [3A08]                  		dw CRMSG15
  2919 00000C41 [4E08]                  		dw CRMSG16
  2920 00000C43 [5E08]                  		dw CRMSG17
  2921 00000C45 [7808]                  		dw CRMSG18
  2922 00000C47 [8B08]                  		dw CRMSG19
  2923 00000C49 [9808]                  		dw CRMSG20
  2924 00000C4B 0000<rep 28h>           		times 40 dw 0	; db 80 dup(0)
  2925 00000C9B [1A0B]                  		dw FILEXISTS
  2926 00000C9D 0000                    		dw 0
  2927 00000C9F [260B]                  		dw CANTMKDIR
  2928 00000CA1 [420B]                  		dw FAILINT24
  2929 00000CA3 [510B]                  		dw TOOMANYRD
  2930 00000CA5 [670B]                  		dw DUPLREDIR
  2931 00000CA7 [7D0B]                  		dw INVPASSWD
  2932 00000CA9 [8E0B]                  		dw INVLDPARM
  2933 00000CAB [A00B]                  		dw NETDATFAU
  2934 00000CAD [B30B]                  		dw FNOSUPNET
  2935 00000CAF [D50B]                  		dw RSCNOTINS
  2936                                  ; ----------------------------------------------------------------------------
  2937                                  	; 17/04/2023
  2938                                  ExtMsgEnd:
  2939                                  
  2940                                  ; 21/04/2023
  2941                                  NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023
  2942                                  
  2943                                  ; ----------------------------------------------------------------------------
  2944                                  
  2945                                  ; 20/04/2023
  2946                                  
  2947 00000CB1 90<rep Fh>              align 16
  2948                                  
  2949                                  ; ----------------------------------------------------------------------------
  2950                                  
  2951                                  ; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2952                                  ;; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)
  2953                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  2954                                  ; MSDOS 6.22 COMMAND.COM - RESGROUP:0E50h (CODERES:0000h)
  2955                                  
  2956                                  ; ----------------------------------------------------------------------------
  2957                                  ; SEGMENT - CODERES
  2958                                  ; ----------------------------------------------------------------------------
  2959                                  
  2960                                  ; 11/01/2023
  2961                                  RCODE_START:	
  2962                                  
  2963                                  ; ----------------------------------------------------------------------------
  2964                                  ;***	EXEC error handling
  2965                                  ;
  2966                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  2967                                  ;	We examine the error code and select an appropriate message.
  2968                                  ; --------------------------
  2969                                  ;	Bugbug:	optimize reg usage in following code? Careful of DX!
  2970                                  ;	Condense the error scan?
  2971                                  ;	RBADNAM is checked by transient, no need here?
  2972                                  ;	Move below Ext_Exec.
  2973                                  ; ----------------------------------------------------------------------------
  2974                                  
  2975                                  Exec_Err:
  2976                                  ;SR;
  2977                                  ; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
  2978                                  ; in order here
  2979                                  
  2980                                  ;	Bugbug:	can we use byte compares here?
  2981                                  ;	Might be able to use byte msg#s, too.
  2982                                  
  2983                                  ;	Store errors in a 3 or 4 byte table. Msg #s in another.
  2984                                  ;	Speed not high priority here.
  2985                                  
  2986                                  ;	Move this to transient.
  2987                                  
  2988                                  	; 10/01/2023
  2989                                  
  2990                                  	;mov	bx,RBADNAM	; offset DATARES:RBadNam
  2991 00000CC0 BA[5B06]                	mov	dx,RBADNAM
  2992 00000CC3 3C02                    	cmp	al,ERROR_FILE_NOT_FOUND ; 2
  2993 00000CC5 741B                    	je	short GotExecEMes		; bad command
  2994                                  	;mov	bx,TOOBIG	; offset DATARES:TooBig
  2995 00000CC7 BA[2106]                	mov	dx,TOOBIG
  2996 00000CCA 3C08                    	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
  2997 00000CCC 7414                    	je	short GotExecEMes		; file not found
  2998                                  	;mov	bx,EXEBAD	; offset DATARES:ExeBad
  2999 00000CCE BA[0D06]                	mov	dx,EXEBAD
  3000 00000CD1 3C0B                    	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
  3001 00000CD3 740D                    	je	short GotExecEMes		; bad exe file
  3002                                  	;mov	bx,ACCDEN	; offset DATARES:AccDen
  3003 00000CD5 BA[7606]                	mov	dx,ACCDEN
  3004 00000CD8 3C05                    	cmp	al,ERROR_ACCESS_DENIED ; 5
  3005 00000CDA 7406                    	je	short GotExecEMes		; access denied
  3006                                  
  3007                                  Default_Message:
  3008                                  	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
  3009 00000CDC BA[F905]                	mov	dx,EXECEMES
  3010                                  						; default message
  3011 00000CDF BE[CE01]                	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
  3012                                  						; get address of subst block
  3013                                  GotExecEMes:
  3014                                  	;mov	dx,bx				; DX = ptr to msg
  3015 00000CE2 E85106                  	call	RPrint ; invoke	RPrint
  3016 00000CE5 EB09                    	jmp	short NoExec
  3017                                  
  3018                                  ; ----------------------------------------------------------------------------
  3019                                  ;***	EXEC call
  3020                                  ;
  3021                                  ;	The transient has set up everything for an EXEC system call.
  3022                                  ;	For cleanliness, we issue the EXEC here in the resident 
  3023                                  ;	so that we may be able to recover cleanly upon success.
  3024                                  ;
  3025                                  ;	CS,DS,ES,SS = DATARES seg addr
  3026                                  ; ----------------------------------------------------------------------------
  3027                                  
  3028                                  Ext_Exec:
  3029                                  ;SR;
  3030                                  ; The words put on the stack by the stub will be popped off when we finally
  3031                                  ;jump to LodCom (by LodCom).
  3032                                  
  3033                                  	; 10/01/2023
  3034                                  	;int	21h			; do the exec
  3035                                  	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
  3036                                  Exec_Ret:
  3037 00000CE7 72D7                    	jc	short Exec_Err		; exec failed
  3038                                  
  3039                                  ;	The exec has completed. Retrieve the exit code.
  3040                                  
  3041                                  Exec_Wait:
  3042 00000CE9 B44D                    	mov	ah,4Dh
  3043                                  	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  3044 00000CEB CD21                    	int	21h			; get the return code
  3045                                  	;mov	[cs:RetCode],ax
  3046                                  	; 11/01/2023
  3047 00000CED A3[3802]                	mov	[RetCode],ax
  3048                                  
  3049                                  ;	See if we can reload the transient. The external command
  3050                                  ;	may have overwritten part of the transient.
  3051                                  
  3052                                  NoExec:
  3053                                  ;SR;
  3054                                  ; ds = es = ss = DATARES when we jump to LodCom
  3055                                  ;
  3056 00000CF0 E97801                  	jmp	LodCom
  3057                                  
  3058                                  ; ----------------------------------------------------------------------------
  3059                                  ;***	Int 23 (ctrl-c) handler
  3060                                  ;
  3061                                  ;	This is the default system INT 23 handler. All processes
  3062                                  ;	(including COMMAND) get it by default. There are some
  3063                                  ;	games that are played: We ignore ^C during most of the
  3064                                  ;	INIT code. This is because we may perform an ALLOC and
  3065                                  ;	diddle the header! Also, if we are prompting for date/time
  3066                                  ;	in the init code, we are to treat ^C as empty responses.
  3067                                  ; ---------------------------
  3068                                  ;	Bugbug:	put init ctrl-c handling in init module.
  3069                                  ; ----------------------------------------------------------------------------
  3070                                  
  3071                                  ;SR;
  3072                                  ;The stub has pushed the previous ds and DATARES onto the stack. We get
  3073                                  ;both these values off the stack now
  3074                                  ;
  3075                                  ;ContC	proc	far
  3076                                  
  3077                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  3078                                  
  3079                                  	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
  3080                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
  3081                                  ContC:
  3082 00000CF3 1F                      	pop	ds			; ds = DATARES
  3083                                  ;	assume	ds:DATARES
  3084                                  ;;	pop	word [OldDS]		; OldDS = old ds
  3085                                  
  3086 00000CF4 F606[B402]01            	test	byte [InitFlag],INITINIT ; 1
  3087                                  	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  3088 00000CF9 740D                    	jz	short NotAtInit		; no
  3089 00000CFB F606[B402]02            	test	byte [InitFlag],INITSPECIAL ; 2 
  3090                                  	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  3091 00000D00 7404                    	jz	short CmdIret		; no, ignore ^C
  3092 00000D02 1F                      	pop	ds			; restore before jumping; M021
  3093                                  	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
  3094 00000D03 E92F0E                  	jmp	init_contc_specialcase
  3095                                  CmdIret:
  3096                                  ;SR;
  3097                                  ; Restore ds to its previous value
  3098                                  ;
  3099                                  
  3100                                  ;;	mov	ds,[OLdDS]		;
  3101 00000D06 1F                      	pop	ds
  3102 00000D07 CF                      	iret				; yes, ignore the ^C
  3103                                  
  3104                                  NotAtInit:
  3105 00000D08 F606[B402]04            	test	byte [InitFlag],INITCTRLC ; 4
  3106                                  	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  3107 00000D0D 7411                    	jz	short NotInit 		; nope too.
  3108                                  
  3109                                  ;*	We are interrupting ourselves in this ^C handler. We need
  3110                                  ;	to set carry and return to the user sans flags only if the
  3111                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  3112                                  
  3113                                  	;cmp	ah,1
  3114                                  	;jb	short CmdIret
  3115                                  	; 19/07/2024
  3116 00000D0F 84E4                    	test	ah,ah
  3117 00000D11 74F3                    	jz	short CmdIret
  3118                                  
  3119 00000D13 80FC0C                  	cmp	ah,12
  3120 00000D16 77EE                    	ja	short CmdIret
  3121                                  
  3122 00000D18 1F                      	pop	ds			;restore ds to old value
  3123 00000D19 83C406                  	add	sp,6			; remove int frame
  3124 00000D1C F9                      	stc
  3125                                  
  3126                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  3127 00000D1D CA0200                  	retf	2			; remove those flags...
  3128                                  
  3129                                  NotInit:
  3130                                  
  3131                                  ;*	We have now received a ^C for some process (maybe ourselves
  3132                                  ;	but not at INIT).
  3133                                  ;	
  3134                                  ;	Note that we are running on the user's stack!!! Bad news if
  3135                                  ;	any of the system calls below go and issue another INT
  3136                                  ;	24... Massive stack overflow! Another bad point is that
  3137                                  ;	SavHand will save an already saved handle, thus losing a
  3138                                  ;	possible redirection...
  3139                                  ;	
  3140                                  ;	All we need to do is set the flag to indicate nested ^C. 
  3141                                  ;	The above code will correctly flag the ^C diring the
  3142                                  ;	message output and prompting while ignoring the ^C the rest
  3143                                  ;	of the time.
  3144                                  ;	
  3145                                  ;	Clean up: flush disk. If we are in the middle of a batch
  3146                                  ;	file, we ask if he wants to terminate it. If he does, then
  3147                                  ;	we turn off all internal flags and let the DOS abort.
  3148                                  
  3149 00000D20 800E[B402]04            	or	byte [InitFlag],INITCTRLC ; 4
  3150                                  	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  3151 00000D25 FB                      	sti
  3152                                  
  3153                                  ;	push	cs			; el yucko! change the user's ds!!
  3154                                  ;	pop	ds
  3155                                  
  3156                                  ;	assume	ds:RESGROUP
  3157                                  
  3158 00000D26 58                      	pop	ax			; discard the old ds value
  3159                                  
  3160 00000D27 A1[4302]                	mov	ax,[SingleCom]
  3161 00000D2A 09C0                    	or	ax,ax
  3162 00000D2C 7506                    	jnz	short NoReset
  3163 00000D2E 50                      	push	ax
  3164 00000D2F B40D                    	mov	ah,DISK_RESET ; 0Dh
  3165 00000D31 CD21                    	int	21h			; reset disks in case files were open
  3166 00000D33 58                      	pop	ax
  3167                                  
  3168                                  NoReset:
  3169                                  
  3170                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  3171                                  ;	walk the entire active list and free each segment. Here,
  3172                                  ;	we just free the single batch segment.
  3173                                  
  3174 00000D34 F706[E701]FFFF          	test	word [Batch],-1 ; 0FFFFh
  3175 00000D3A 7452                    	jz	short ContCTerm
  3176 00000D3C 09C0                    	or	ax,ax
  3177 00000D3E 754E                    	jnz	short ContCTerm
  3178 00000D40 E88502                  	call	SavHand
  3179 00000D43 E89303                  	call	AskEnd			; ask if user wants to end batch
  3180                                  
  3181                                  ;	If the carry flag is clear, we do NOT free up the batch file
  3182                                  
  3183 00000D46 7340                    	jnc	short ContBatch
  3184 00000D48 8A0E[3B02]              	mov	cl,[EchoFlag]		; get current echo flag
  3185 00000D4C 53                      	push	bx
  3186                                  
  3187                                  ClearBatch:
  3188 00000D4D 8E06[E701]              	mov	es,[Batch]		; get batch segment
  3189                                  	;mov	di,20h
  3190 00000D51 8B3E2000                	mov	di,[BATCHSEGMENT.BatFile] ; get offset of batch file name
  3191                                  	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
  3192                                  	;mov	bx,es:BatForPtr		; get old FOR segment
  3193 00000D55 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
  3194                                  	; MSDOS 3.3 ([ES:4])
  3195                                  	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  3196                                  	;
  3197                                  	; 19/07/2024
  3198                                  	;cmp	bx,0			; is a FOR in progress
  3199                                  	;je	short No_Bat_For	; no - don't deallocate
  3200 00000D5A 85DB                    	test	bx,bx
  3201 00000D5C 7408                    	jz	short No_Bat_For
  3202                                  
  3203 00000D5E 06                      	push	es			;
  3204 00000D5F 8EC3                    	mov	es,bx			; yes - free it up...
  3205 00000D61 B449                    	mov	ah,49h
  3206                                  	;mov	ah,DEALLOC ; 49h	;
  3207 00000D63 CD21                    	int	21h			;
  3208 00000D65 07                      	pop	es			; restore to batch segment
  3209                                  
  3210                                  No_Bat_For:
  3211                                  	;mov	cl,[es:1]
  3212 00000D66 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  3213                                  	;mov	bx,[es:3]
  3214 00000D6B 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  3215 00000D70 B449                    	mov	ah,49h
  3216                                  	;mov	ah,DEALLOC ; 49h	; free it up...
  3217 00000D72 CD21                    	int	21h
  3218 00000D74 891E[E701]              	mov	[Batch],bx		; get ready to deallocate next batch
  3219 00000D78 FF0E[4C02]              	dec	word [Nest]		; is there another batch file?
  3220 00000D7C 75CF                    	jnz	short ClearBatch	; keep going until no batch file
  3221                                  
  3222                                  ;	We are terminating a batch file; restore the echo status
  3223                                  
  3224                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  3225 00000D7E 5B                      	pop	bx
  3226 00000D7F 880E[3B02]              	mov	[EchoFlag],cl		; reset echo status
  3227                                  	; 29/05/2018
  3228 00000D83 C606[B502]00            	mov	byte [PipeFlag],0	; turn off pipeflag
  3229                                  
  3230                                  ContBatch:
  3231 00000D88 E8A805                  	call	crlf			; print out crlf before returning
  3232 00000D8B E86302                  	call	RestHand
  3233                                  
  3234                                  ;	Yes, we are terminating. Turn off flags and allow the DOS to abort.
  3235                                  
  3236                                  ContCTerm:
  3237 00000D8E 31C0                    	xor	ax,ax			; indicate no read
  3238 00000D90 89C5                    	mov	bp,ax
  3239                                  
  3240                                  ;	The following resetting of the state flags is good for the
  3241                                  ;	generalized batch processing.
  3242                                  
  3243 00000D92 A2[4802]                	mov	[IfFlag],al		; turn off iffing
  3244 00000D95 A2[4902]                	mov	[ForFlag],al		; turn off for processing
  3245 00000D98 E81C00                  	call	ResPipeOff
  3246 00000D9B 3906[4302]              	cmp	[SingleCom],ax		; see if we need to set SingleCom
  3247 00000D9F 7406                    	jz	short NoSetSing
  3248 00000DA1 C706[4302]FFFF          	mov	word [SingleCom],-1	; cause termination on 
  3249                                  					;  pipe, batch, for
  3250                                  NoSetSing:
  3251                                  
  3252                                  ;	If we are doing an internal command, go through the reload process.
  3253                                  ;	If we are doing an external, let DOS abort the process.
  3254                                  ;	In both cases, we are now done with the ^C processing.
  3255                                  
  3256 00000DA7 8026[B402]FB            	and	byte [InitFlag],~INITCTRLC ; 0FBh
  3257 00000DAC 3806[3702]              	cmp	[ExtCom],al
  3258 00000DB0 7503                    	jnz	short DoDAb		; internal ^c
  3259 00000DB2 E94501                  	jmp	LodCom1
  3260                                  DoDAb:
  3261 00000DB5 F9                      	stc				; tell dos to abort
  3262                                  
  3263                                  ;SR;
  3264                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  3265                                  ;by setting carry and leaving flags on the stack
  3266                                  
  3267 00000DB6 CB                      	retf				; Leave flags on stack
  3268                                  
  3269                                  ;ContC	endp
  3270                                  
  3271                                  ;SR;
  3272                                  ;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  3273                                  ;both have ds = DATARES
  3274                                  
  3275                                  	; 11/01/2023
  3276                                  ResPipeOff:
  3277 00000DB7 50                      	push	ax
  3278 00000DB8 31C0                    	xor	ax,ax
  3279                                  	;xchg	al,[cs:PIPEFLAG]
  3280 00000DBA 8606[B502]              	xchg	al,[PipeFlag]
  3281 00000DBE 08C0                    	or	al,al
  3282 00000DC0 7404                    	jz	short NoPipePop
  3283                                  	;shr	byte [cs:ECHOFLAG],1
  3284 00000DC2 D02E[3B02]              	shr	byte [EchoFlag],1
  3285                                  NoPipePop:
  3286 00000DC6 58                      	pop	ax
  3287 00000DC7 C3                      	retn
  3288                                  
  3289                                  ;CODERES ends
  3290                                  
  3291                                  ;=============================================================================
  3292                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  3293                                  ;=============================================================================
  3294                                  ; 21/09/2018 - Retro DOS v3.0
  3295                                  
  3296                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  3297                                  ;	name	COMMAND2
  3298                                  
  3299                                  ;/*
  3300                                  ; *                      Microsoft Confidential
  3301                                  ; *                      Copyright (C) Microsoft Corporation 1991
  3302                                  ; *                      All Rights Reserved.
  3303                                  ; */
  3304                                  
  3305                                  ;
  3306                                  ;	Revision History
  3307                                  ;	================
  3308                                  ;
  3309                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  3310                                  ;			reserve memory by changing int 12h and then give it
  3311                                  ;			back to DOS by changing arenas in autoexec.bat.
  3312                                  ;			This makes command.com reload transient and this
  3313                                  ;			cannot be done at this stage.
  3314                                  ;
  3315                                  
  3316                                  ;CODERES segment public byte
  3317                                  
  3318                                  ;*	If we cannot allocate enough memory for the transient or there
  3319                                  ;	was some other allocation error, we display a message and
  3320                                  ;	then die.
  3321                                  
  3322                                  ;SR;
  3323                                  ; We will have to make sure that at this entry point and at FatalC, 
  3324                                  ;ds = DATARES. All jumps to these points are made from only within this file
  3325                                  ;and so we should be able to do this
  3326                                  
  3327                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3328                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)
  3329                                  
  3330                                  	;assume	ds:DATARES
  3331                                  BadMemErr:
  3332 00000DC8 BA[8406]                	mov	dx,BMEMMES			; DX = ptr to msg
  3333                                  FatalC:
  3334                                  	; 12/01/2023
  3335                                  ;;	push	cs
  3336                                  ;;	pop	ds
  3337                                  ;;	assume	ds:ResGroup
  3338                                  ;	invoke	RPrint
  3339                                  
  3340                                  	; 12/01/2023
  3341                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3342 00000DCB E86805                  	call	RPrint
  3343                                  
  3344                                  	; MSDOS 3.3
  3345                                  	;call	RDISPMSG
  3346                                  
  3347                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  3348                                  ;	we can't do anything else!
  3349                                  
  3350 00000DCE 803E[4002]00            	cmp	byte [PermCom],0
  3351 00000DD3 7410                    	je	short FatalRet
  3352                                  
  3353                                  ;	We are a permanent command. If we are in the process of the
  3354                                  ;	magic interrupt (Singlecom) then exit too.
  3355                                  
  3356 00000DD5 833E[4302]00            	cmp	word [SingleCom],0		; if PermCom and SingleCom
  3357 00000DDA 7509                    	jne	short FatalRet			; must take int_2e exit
  3358                                  
  3359                                  ;	Permanent command. We can't do ANYthing except halt.
  3360                                  
  3361 00000DDC BA[9E06]                	mov	dx,HALTMES			; DX = ptr to msg
  3362                                  	;invoke	RPrint
  3363                                  	; 12/01/2023	
  3364                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3365 00000DDF E85405                  	call	RPrint	
  3366                                  	; MSDOS 3.3
  3367                                  	;call	RDISPMSG
  3368 00000DE2 FB                      	sti
  3369                                  Stall:
  3370 00000DE3 EBFE                    	jmp	short Stall			; crash the system nicely
  3371                                  
  3372                                  FatalRet:
  3373 00000DE5 BA[C506]                	mov	dx,FRETMES			; DX = ptr to msg
  3374                                  	;call	RDISPMSG
  3375                                  	; 12/01/2023	
  3376 00000DE8 E84B05                  	call	RPrint	
  3377                                  FatalRet2:
  3378 00000DEB 803E[4002]00            	cmp	byte [PermCom],0		; if we get here and PermCom,
  3379 00000DF0 7517                    	jne	short Ret_2e			; must be int_2e
  3380                                  
  3381                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  3382                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  3383                                  ;	case we decide to do that.)
  3384                                  
  3385 00000DF2 A1[DC01]                	mov	ax,[Parent]
  3386                                  	;mov	[16h],ax
  3387 00000DF5 A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  3388 00000DF8 A1[DE01]                	mov	ax,[OldTerm]
  3389                                  	;mov	[0Ah],ax
  3390 00000DFB A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  3391 00000DFE A1[E001]                	mov	ax,[OldTerm+2]
  3392                                  	;mov	[0Ch],ax
  3393 00000E01 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  3394 00000E04 B8004C                  	mov	ax,4C00h
  3395                                  	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  3396 00000E07 CD21                    	int	21h
  3397                                  Ret_2e:
  3398                                  ;SR;
  3399                                  ; We will ensure that ds = DATARES for all entries to this place
  3400                                  ;
  3401                                  
  3402                                  ;;	push	cs
  3403                                  ;;	pop	ds
  3404                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  3405                                    	
  3406                                  ;	assume	ds:DATARES
  3407                                  
  3408                                  	;PUSH	CS
  3409                                  	;POP	DS
  3410                                  
  3411 00000E09 C706[4302]0000          	mov	word [SingleCom],0	; turn off SingleCom
  3412 00000E0F 8E06[FA03]              	mov	es,[Res_Tpa]
  3413                                  	;mov	ah,49h	; 12/01/2023
  3414 00000E13 B449                    	mov	ah,DEALLOC
  3415 00000E15 CD21                    	int	21h			; free up space used by transient
  3416 00000E17 8B1E[DA01]              	mov	bx,[Save_Pdb]
  3417 00000E1B B450                    	mov	ah,50h
  3418                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3419 00000E1D CD21                    	int	21h			; current process is user
  3420 00000E1F A1[3802]                	mov	ax,[RetCode]
  3421 00000E22 803E[3702]00            	cmp	byte [ExtCom],0
  3422 00000E27 7502                    	jne	short GotECode
  3423 00000E29 31C0                    	xor	ax,ax			; internals always return 0
  3424                                  GotECode:
  3425 00000E2B C606[3702]01            	mov	byte [ExtCom],1		; force external
  3426                                  
  3427                                  ;SR; This is actually returning to the caller. However, the old code had
  3428                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  3429                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  3430                                  
  3431                                  	; 12/01/2023
  3432 00000E30 FF2E[D601]              	jmp	far [Int_2e_Ret]	; "iret"
  3433                                  
  3434                                  ;***	Int_2e, magic command executer
  3435                                  
  3436                                  Int_2e:
  3437                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  3438                                  ;SR;
  3439                                  ;We are going to come here from the stub with the old ds and DATARES value
  3440                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  3441                                  
  3442                                  	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
  3443                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)
  3444                                  
  3445 00000E34 1F                      	pop	ds			; ds = DATARES
  3446                                  	;assume	ds:DATARES
  3447 00000E35 58                      	pop	ax
  3448                                  ;	;pop	ds:OldDS 		; Save old value of ds
  3449                                  
  3450                                  	;pop	word [cs:Int_2e_Ret]
  3451                                  	;pop	word [cs:Int_2e_Ret+2]	; store return address
  3452                                  	;pop	ax			; chuck flags
  3453 00000E36 8F06[D601]              	pop	word [Int_2e_Ret]
  3454 00000E3A 8F06[D801]              	pop	word [Int_2e_Ret+2]
  3455                                  	
  3456 00000E3E 83C402                  	add	sp,2
  3457                                  
  3458                                  ;;	push	cs
  3459                                  ;;	pop	es
  3460                                  
  3461 00000E41 1E                      	push	ds
  3462 00000E42 07                      	pop	es			; es = DATARES
  3463                                  ;	;mov	ds,OldDS
  3464 00000E43 8ED8                    	mov	ds,ax
  3465                                  	;assume	ds:nothing		; ds = old value
  3466                                  
  3467 00000E45 BF8000                  	mov	di,80h
  3468 00000E48 B94000                  	mov	cx,64
  3469                                  ;	Bugbug:	cld
  3470 00000E4B F3A5                    	rep	movsw
  3471 00000E4D B451                    	mov	ah,51h
  3472                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3473 00000E4F CD21                    	int	21h			; get user's header
  3474                                  	; 12/01/2023
  3475 00000E51 26891E[DA01]            	mov	[es:Save_Pdb],bx
  3476                                  	;mov	[cs:Save_Pdb],bx
  3477 00000E56 B450                    	mov	ah,50h
  3478                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3479                                  
  3480                                  ;;	mov	bx,cs
  3481                                  ;SR;
  3482                                  ;Set ds = DATARES because BadMemErr expects this
  3483                                  
  3484                                  	; 12/01/2023
  3485 00000E58 06                      	push	es
  3486 00000E59 1F                      	pop	ds
  3487                                  	;assume	ds:DATARES
  3488                                  
  3489 00000E5A 8CDB                    	mov	bx,ds			; es = our PSP now
  3490                                  	;mov	bx,cs
  3491                                  
  3492 00000E5C CD21                    	int	21h			; current process is me
  3493                                  	;mov	word [cs:SingleCom],81h
  3494                                  	;mov	byte [cs:ExtCom],1	; make sure this case forced
  3495                                  	; 12/01/2023
  3496 00000E5E C706[4302]8100          	mov	word [SingleCom],81h
  3497 00000E64 C606[3702]01            	mov	byte [ExtCom],1		; make sure this case forced
  3498                                  
  3499                                  ;SR;
  3500                                  ;We can enter LodCom directly after a command shell is terminated or we
  3501                                  ;can fall thru from above. When we enter directly from the stub, the stack
  3502                                  ;has the old ds value and the data seg value on the stack, so that ds can
  3503                                  ;be properly set. To fake this, we push dummy values here.
  3504                                  
  3505                                  	; 12/01/2023
  3506 00000E69 1E                      	push	ds			; old value of ds
  3507 00000E6A 1E                      	push	ds			; data seg value, ds = DATARES
  3508                                  LodCom: 				; termination handler
  3509 00000E6B 1F                      	pop	ds			; ds = DATARES
  3510                                  	;assume	ds:DATARES
  3511 00000E6C 83C402                  	add	sp,2
  3512                                  ;	;pop	OldDS			; store old ds
  3513                                  	;cmp	ExtCom,0
  3514 00000E6F 803E[3702]00            	cmp	byte [ExtCom],0
  3515                                  	;cmp	byte [cs:ExtCom],0
  3516                                  	;jne	short @f	 	; internal cmd - memory allocated
  3517                                  	; 16/04/2023
  3518 00000E74 7503                    	jne	short LodCom0 ; 24/09/2018
  3519 00000E76 E98100                  	jmp	LodCom1
  3520                                  	;je	short LodCom1 ; 25/09/2018	
  3521                                  ;@@:
  3522                                  LodCom0: ; 24/09/2018
  3523 00000E79 BBFFFF                  	mov	bx,0FFFFh
  3524 00000E7C B448                    	mov	ah,48h	; 12/01/2023
  3525                                  	;mov	ah,ALLOC ; 48h	
  3526 00000E7E CD21                    	int	21h		; DOS - 2+ - ALLOCATE MEMORY
  3527                                  				; BX = number of 16-byte paragraphs desired
  3528 00000E80 E80A00                  	call	SetSize
  3529 00000E83 83C020                  	add	ax,20h
  3530 00000E86 39C3                    	cmp	bx,ax
  3531 00000E88 730B                    	jnb	short MemOk		; > 512 byte buffer - good enough
  3532                                  BadMemErrJ:
  3533 00000E8A E93BFF                  	jmp	BadMemErr		; not enough memory
  3534                                  
  3535                                  ;***	SetSize - get transient size in paragraphs
  3536                                  
  3537                                  SetSize:
  3538                                  	; 12/01/2023
  3539                                  	;;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
  3540                                  	;;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
  3541                                  	; 05/06/2023
  3542                                  	;mov	ax,0AFA4h		; MSDOS 6.22 COMMAND.COM
  3543 00000E8D B810AA                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
  3544 00000E90 B104                    	mov	cl,4
  3545 00000E92 D3E8                    	shr	ax,cl
  3546 00000E94 C3                      	retn
  3547                                  
  3548                                  MemOk:
  3549                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  3550                                  
  3551 00000E95 B448                    	mov	ah,48h
  3552                                  	;mov	ah,ALLOC  ; 48h
  3553 00000E97 CD21                    	int	21h
  3554 00000E99 72EF                    	jc	short BadMemErrJ	; memory arenas probably trashed
  3555                                  	;mov	byte [cs:ExtCom],0
  3556                                  	;mov	[cs:Res_Tpa],ax
  3557                                  	; 12/01/2023
  3558 00000E9B C606[3702]00            	mov	byte [ExtCom],0		; flag not to alloc again
  3559 00000EA0 A3[FA03]                	mov	[Res_Tpa],ax		; save current tpa segment
  3560                                  
  3561 00000EA3 2500F0                  	and	ax,0F000h
  3562 00000EA6 050010                  	add	ax,1000h		; round up to next 64k boundary
  3563 00000EA9 7212                    	jc	short Bad_Tpa		; memory wrap if carry set
  3564                                  
  3565                                  ;	Make sure that new boundary is within allocated range
  3566                                  
  3567                                  	;mov	dx,[cs:Res_Tpa]
  3568                                  	; 12/01/2023
  3569 00000EAB 8B16[FA03]              	mov	dx,[Res_Tpa]
  3570 00000EAF 01DA                    	add	dx,bx			; compute maximum address
  3571 00000EB1 39C2                    	cmp	dx,ax			; is 64k address out of range?
  3572 00000EB3 7608                    	jbe	short Bad_Tpa
  3573                                  
  3574                                  ;	Must have 64K of usable space.
  3575                                  
  3576 00000EB5 29C2                    	sub	dx,ax			; compute the usable space
  3577 00000EB7 81FA0010                	cmp	dx,1000h		; is space >= 64k ?
  3578 00000EBB 7303                    	jae	short LTpaSet
  3579                                  Bad_Tpa:
  3580                                  	;mov	ax,[cs:Res_Tpa]
  3581                                  	; 12/01/2023
  3582 00000EBD A1[FA03]                	mov	ax,[Res_Tpa]
  3583                                  LTpaSet:
  3584                                  	;mov	[cs:LTPA],ax
  3585                                  	;mov	ax,[cs:Res_Tpa]
  3586                                  	; 12/01/2023
  3587 00000EC0 A3[EE03]                	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
  3588 00000EC3 A1[FA03]                	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
  3589 00000EC6 01C3                    	add	bx,ax
  3590                                  	;mov	[cs:MemSiz],bx
  3591 00000EC8 891E[3302]              	mov	[MemSiz],bx
  3592 00000ECC E8BEFF                  	call	SetSize
  3593 00000ECF 29C3                    	sub	bx,ax
  3594                                  
  3595                                  	; MSDOS 6.0
  3596                                  
  3597                                  ;M038; Start of changes
  3598                                  ;Changes for Novell RPL. These guys reserve memory for themselves by
  3599                                  ;reducing int 12h size and add this memory to the system at autoexec time by
  3600                                  ;running a program that changes arenas. This changes the largest block that
  3601                                  ;command.com gets and so changes the transient segment. So, command.com does
  3602                                  ;a checksum at the wrong address and thinks that the transient is destroyed
  3603                                  ;and tries to reload it. At this point, no Comspec is defined and so the
  3604                                  ;reload fails, hanging the system. To get around this we just copy the
  3605                                  ;transient from the previous address to the new address(if changed) and
  3606                                  ;then let command.com do the checksum. So, if the transient area is not
  3607                                  ;corrupted, there will not be any reload. In Novell's case, the transient
  3608                                  ;is not really corrupted and so this should work.
  3609                                  
  3610                                  	; 12/01/2023
  3611                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)
  3612                                  
  3613 00000ED1 3B1E[2D02]              	cmp	bx,[TrnSeg]		; Segment still the same?
  3614 00000ED5 7423                    	je	short LodCom1		; yes, dont copy
  3615                                  
  3616                                  ;Check if the new segment is above or below the current move. If the new
  3617                                  ;segment is above (i.e new block is larger than previous block), then we
  3618                                  ;have to move in the reverse direction
  3619                                  
  3620                                  	;;mov	cx,98C5h
  3621                                  	; 05/06/2023
  3622                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:106Ah (CODERES:021Ah)
  3623                                  	;mov	cx,0AF95h
  3624 00000ED7 B901AA                  	mov	cx,TRANSPACEEND		; cx = length to move
  3625 00000EDA 7707                    	ja	short mov_down		; new seg > old seg, reverse move
  3626 00000EDC 31F6                    	xor	si,si			; normal move
  3627 00000EDE 89F7                    	mov	di,si
  3628 00000EE0 FC                      	cld
  3629 00000EE1 EB06                    	jmp	short copy_trans
  3630                                  mov_down:
  3631 00000EE3 89CE                    	mov	si,cx			; reverse move, start from end
  3632 00000EE5 4E                      	dec	si
  3633 00000EE6 89F7                    	mov	di,si
  3634 00000EE8 FD                      	std
  3635                                  copy_trans:
  3636 00000EE9 1E                      	push	ds
  3637 00000EEA 06                      	push	es
  3638 00000EEB 8EC3                    	mov	es,bx			; dest segment
  3639 00000EED 8E1E[2D02]              	mov	ds,[TrnSeg]		; source segment
  3640                                  	;assume	ds:nothing
  3641                                  
  3642 00000EF1 F3A4                    	rep	movsb			; copy transient
  3643 00000EF3 FC                      	cld
  3644 00000EF4 07                      	pop	es
  3645 00000EF5 1F                      	pop	ds
  3646                                  	;assume	ds:DATARES
  3647                                  
  3648                                  ;M038; End of changes
  3649                                  
  3650                                  	;mov	[cs:TrnSeg],bx		; new location of transient
  3651                                  	; 12/01/2023
  3652 00000EF6 891E[2D02]              	mov	[TrnSeg],bx
  3653                                  
  3654                                  LodCom1:
  3655                                  ;;	mov	ax,cs
  3656                                  ;;	mov	ss,ax
  3657                                  ;SR; At this point ds = DATARES which is where the stack is located
  3658                                  
  3659                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3660                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3661 00000EFA 8CD8                    	mov	ax,ds
  3662 00000EFC 8ED0                    	mov	ss,ax
  3663                                  	;assume	ss:DATARES
  3664                                  	;;;mov	sp,offset DATARES:RStack
  3665                                  	;;mov	sp,53Eh
  3666                                  	; 05/06/2023
  3667                                  	;mov	sp,60Ah ; MSDOS 6.22 COMMAND.COM
  3668 00000EFE BC[D404]                	mov	sp,RStack
  3669                                  
  3670                                  ;;	mov	ds,ax
  3671                                  
  3672                                  	;assume	ds:DATARES
  3673                                  	
  3674                                  	; MSDOS 3.3
  3675                                  	;mov	ax,cs
  3676                                  	;mov	ss,ax
  3677                                  	;mov	sp,RSTACK
  3678                                  	;mov	ds,ax
  3679                                  
  3680 00000F01 E87B00                  	call	HeadFix			; close files, restore stdin, stdout
  3681 00000F04 31ED                    	xor	bp,bp			; flag command ok
  3682 00000F06 B8FFFF                  	mov	ax,-1
  3683 00000F09 8706[4502]              	xchg	ax,[VerVal]
  3684 00000F0D 83F8FF                  	cmp	ax,-1
  3685 00000F10 7404                    	je	short NoSetVer
  3686 00000F12 B42E                    	mov	ah,2Eh
  3687                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  3688 00000F14 CD21                    	int	21h 		; DOS - SET VERIFY FLAG
  3689                                  				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  3690                                  NoSetVer:
  3691 00000F16 833E[4302]FF            	cmp	word [SingleCom],-1
  3692 00000F1B 7503                    	jne	short NoSng
  3693 00000F1D E9CBFE                  	jmp	FatalRet2		; we have finished the single command
  3694                                  NoSng:
  3695 00000F20 E87201                  	call	ChkSum			; check the transient
  3696                                  	;cmp	dx,[Sum]
  3697                                  	;je	short HavCom		; transient ok
  3698                                  	; 12/01/2023
  3699 00000F23 7412                    	jz	short HavCom
  3700                                  Bogus_Com:
  3701 00000F25 C606[E601]01            	mov	byte [Loading],1	; flag DskErr routine
  3702 00000F2A E81E01                  	call	LoadCom
  3703                                  ChkSame:
  3704 00000F2D E86501                  	call	ChkSum
  3705                                  	;cmp	dx,[Sum]
  3706                                  	;je	short HavCom		; same command
  3707                                  	; 12/01/2023
  3708 00000F30 7405                    	jz	short HavCom
  3709                                  Also_Bogus:
  3710 00000F32 E85801                  	call	WrongCom
  3711 00000F35 EBF6                    	jmp	short ChkSame
  3712                                  
  3713                                  	; 12/01/2023
  3714                                  ;HavCom:
  3715                                  ;	; 25/09/2018
  3716                                  ;	mov     ax,(CHAR_OPER*256) ; 3700h
  3717                                  ;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3718                                  ;			; Return: AL = FFh unsupported subfunction
  3719                                  ;			; DL = current switch character
  3720                                  ;	mov     [RSWITCHAR],dl
  3721                                  ;	cmp     dl,'/'
  3722                                  ;	jnz     short USESLASH
  3723                                  ;	;mov	cl,'\'
  3724                                  ;	;mov	[RDIRCHAR],cl
  3725                                  ;	mov	byte [RDIRCHAR],'\'
  3726                                  ;USESLASH:
  3727                                  
  3728                                  HavCom:
  3729                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3730 00000F37 C606[E601]00            	mov	byte [Loading],0		; flag to DskErr
  3731                                  	;;;mov	si,offset DATARES:TranVars
  3732                                  	;;mov	si,453h		; MSDOS 5.0 COMMAND.COM
  3733                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  3734                                  	;mov	si,51Dh		; MSDOS 6.22 COMMAND.COM
  3735 00000F3C BE[EA03]                	mov	si,TranVars
  3736                                  	;;;mov	di,offset TRANGROUP:HeadCall
  3737                                  	;;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
  3738                                  	; 05/06/2023
  3739                                  	;mov	di,0A303h	; MSDOS 6.22 COMMAND.COM
  3740 00000F3F BF[F19D]                	mov	di,HEADCALL
  3741 00000F42 8E06[2D02]              	mov	es,[TrnSeg]
  3742 00000F46 FC                      	cld
  3743                                  	;;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
  3744                                  	;mov	cx,533h		; MSDOS 6.22 COMMAND.COM	
  3745 00000F47 B9[FE03]                	mov	cx,TranVarEnd
  3746 00000F4A 29F1                    	sub	cx,si
  3747 00000F4C F3A4                    	rep	movsb			; transfer info to transient
  3748 00000F4E A1[3302]                	mov	ax,[MemSiz]
  3749 00000F51 A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  3750                                  
  3751                                  ;***	TJmp - jump-off to transient
  3752                                  ;
  3753                                  ;	Public label so debugger can find this spot.
  3754                                  
  3755                                  TJmp:	; 12/01/2023
  3756 00000F54 FF2E[2B02]              	jmp	far [Trans]		; jmp dword ptr Trans
  3757                                  
  3758                                  ;***	TRemCheck - far version of RemCheck for transient
  3759                                  
  3760                                  TRemCheck:
  3761                                  	; 12/01/2023
  3762 00000F58 1F                      	pop	ds			; ds = DATARES
  3763 00000F59 83C402                  	add	sp,2			; discard old value of ds
  3764                                  
  3765 00000F5C E80100                  	call	RemCheck
  3766 00000F5F CB                      	retf
  3767                                  
  3768                                  ;***	RemCheck
  3769                                  ;
  3770                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  3771                                  ;
  3772                                  ;	EXIT	ZR set if removeable media
  3773                                  ;		ZR clear if fixed media
  3774                                  ;
  3775                                  ;	USED	none
  3776                                  
  3777                                  	; 12/01/2023
  3778                                  RemCheck:
  3779 00000F60 50                      	push	ax
  3780 00000F61 53                      	push	bx
  3781 00000F62 89C3                    	mov	bx,ax
  3782 00000F64 B80844                  	mov	ax,4408h
  3783                                  	;mov	ax,(IOCTL<<8)+8 ; 4408h
  3784 00000F67 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  3785 00000F69 7304                    	jnc	short rcCont		
  3786                                  
  3787                                  ;	If an error occurred, assume the media is non-removable.
  3788                                  ;	AX contains the non-zero error code from the int 21, so
  3789                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  3790                                  ;	appear to be non-removable.				
  3791                                  					
  3792 00000F6B 09C0                    	or	ax,ax			
  3793 00000F6D EB05                    	jmp	short ResRegs
  3794                                  rcCont:
  3795 00000F6F 83E001                  	and	ax,1
  3796 00000F72 F7D0                    	not	ax
  3797                                  ResRegs:
  3798 00000F74 5B                      	pop	bx
  3799 00000F75 58                      	pop	ax
  3800 00000F76 C3                      	retn
  3801                                  
  3802                                  ;***	THeadFix
  3803                                  ;
  3804                                  ;	Far version of HeadFix, called from transient.
  3805                                  
  3806                                  THeadFix:
  3807                                  	; 12/01/2023
  3808 00000F77 1F                      	pop	ds			; ds = DATARES
  3809 00000F78 83C402                  	add	sp,2			; discard old ds value on stack
  3810                                  
  3811 00000F7B E80100                  	call	HeadFix
  3812 00000F7E CB                      	retf
  3813                                  
  3814                                  ;***	HeadFix
  3815                                  
  3816                                  	; 12/01/2023
  3817                                  HeadFix:
  3818 00000F7F E83101                  	call	SetVect			; set vectors to our values
  3819                                  
  3820                                  ;	Clean up header
  3821                                  
  3822                                  ;	Bugbug:	optimize:
  3823                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  3824                                  
  3825 00000F82 31DB                    	xor	bx,bx			; BX = handle = 0
  3826 00000F84 8B0E[3D02]              	mov	cx,[Io_Save]		; CX = original stdin, stdout
  3827                                  	;mov	dx,[18h] 
  3828 00000F88 8B161800                	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
  3829 00000F8C 38D1                    	cmp	cl,dl
  3830 00000F8E 7408                    	je	short Chk1		; stdin matches
  3831 00000F90 B43E                    	mov	ah,3Eh
  3832                                  	;mov	ah,CLOSE  ; 3Eh
  3833 00000F92 CD21                    	int	21h			; close stdin
  3834                                  	;mov	[18h],cl
  3835 00000F94 880E1800                	mov	[PDB.JFN_TABLE],cl	; restore stdin
  3836                                  Chk1:
  3837 00000F98 43                      	inc	bx			; BX = handle = 1
  3838 00000F99 38F5                    	cmp	ch,dh			
  3839 00000F9B 7408                    	je	short ChkOtherHand	; stdout matches
  3840 00000F9D B43E                    	mov	ah,3Eh
  3841                                  	;mov	ah,CLOSE
  3842 00000F9F CD21                    	int	21h			; close stdout
  3843                                  	;mov	[19h],ch
  3844 00000FA1 882E1900                	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
  3845                                  ChkOtherHand:
  3846 00000FA5 83C304                  	add	bx,4			; skip handles 2,3,4
  3847 00000FA8 B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  3848                                  					; (handles 0-4 already done)
  3849                                  CloseLoop:
  3850 00000FAB B43E                    	mov	ah,3Eh
  3851                                  	;mov	ah,CLOSE ; 3Eh
  3852 00000FAD CD21                    	int	21h			; close each handle
  3853 00000FAF 43                      	inc	bx			; BX = next handle
  3854 00000FB0 E2F9                    	loop	CloseLoop
  3855                                  
  3856                                  	; MSDOS 6.0
  3857                                  ;	Bugbug:	since this is for transient code, move it there
  3858                                  	
  3859                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3860                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)
  3861                                  
  3862                                  ;	M012: remove this CS -> DS. Must've been missed during
  3863                                  ;	purification.
  3864                                  ;;	push	ds			; save data segment
  3865                                  ;;	push	cs			; get local segment into DS
  3866                                  ;;	pop	ds			;
  3867 00000FB2 803E[6202]FF            	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
  3868 00000FB7 750E                    	jne	short Append_Fix_End	; no - just exit
  3869 00000FB9 B807B7                  	mov	ax,0B707h
  3870                                  	;mov	ax,AppendSetState	; set the state of Append
  3871 00000FBC 8B1E[6002]              	mov	bx,[Append_State] 	; back to the original state
  3872 00000FC0 CD2F                    	int	2Fh			;
  3873 00000FC2 C606[6202]00            	mov	byte [Append_Flag],0	; set append flag to invalid
  3874                                  Append_Fix_End: 			;
  3875                                  ;;	pop	ds			; get data segment back
  3876 00000FC7 C3                      	retn
  3877                                  
  3878                                  	; MSDOS 3.3
  3879                                  	;retn
  3880                                  
  3881                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  3882                                  ;
  3883                                  ;	ENTRY	nothing
  3884                                  ;
  3885                                  ;	EXIT	nothing
  3886                                  ;
  3887                                  ;	USED	flags
  3888                                  ;
  3889                                  ;	EFFECTS
  3890                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  3891                                  ;	  current program's stdin,stdout set to our stderr
  3892                                  ;
  3893                                  
  3894                                  ;SR;
  3895                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  3896                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  3897                                  
  3898                                  SavHand:
  3899                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  3900                                  
  3901                                  	; 12/01/2023
  3902                                  	;push	ds ; MSDOS 3.3
  3903                                  
  3904 00000FC8 53                      	push	bx			;preserve registers
  3905 00000FC9 50                      	push	ax
  3906                                  	; 12/01/2023
  3907 00000FCA 06                      	push	es
  3908 00000FCB 1E                      	push	ds			; save DATARES value
  3909                                  
  3910 00000FCC B451                    	mov	ah,51h
  3911                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3912 00000FCE CD21                    	int	21h			; BX = user's header seg addr
  3913 00000FD0 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  3914                                  	;lds	bx,[34h]	
  3915 00000FD2 C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
  3916 00000FD6 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  3917                                  	; 12/01/2023
  3918 00000FD8 07                      	pop	es			; es = DATARES
  3919 00000FD9 06                      	push	es			; save it back on stack
  3920 00000FDA 26A3[E401]              	mov	[es:Handle01],ax	; save user's stdin, stdout
  3921                                  	;mov	[cs:HANDLE01],ax
  3922                                  
  3923                                  ;SR;
  3924                                  ; Use es to address Handle01 & our JFN_Table
  3925                                  
  3926                                  	; 12/01/2023
  3927                                  	;mov	al,[es:1Ah]
  3928 00000FDE 26A01A00                	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
  3929                                  	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  3930 00000FE2 88C4                    	mov	ah,al			; AH = COMMAND stderr
  3931 00000FE4 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  3932                                  	; 12/01/2023
  3933 00000FE6 1F                      	pop	ds			; restore registers
  3934 00000FE7 07                      	pop	es
  3935 00000FE8 58                      	pop	ax
  3936 00000FE9 5B                      	pop	bx
  3937                                  	;pop	ds ; MSDOS 3.3
  3938 00000FEA C3                      	retn
  3939                                  
  3940                                  	;assume	ds:DATARES
  3941                                  GetComDsk2:
  3942 00000FEB E81F00                  	call	GetComDsk
  3943 00000FEE E909FF                  	jmp	LodCom1			; memory already allocated
  3944                                  
  3945                                  RestHand:
  3946 00000FF1 1E                      	push	ds
  3947 00000FF2 53                      	push	bx			; restore stdin, stdout to user
  3948 00000FF3 50                      	push	ax
  3949                                  	; 12/01/2023
  3950 00000FF4 B451                    	mov	ah,51h
  3951                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3952 00000FF6 CD21                    	int	21h			; point to user's header
  3953 00000FF8 A1[E401]                	mov	ax,[Handle01]
  3954 00000FFB 8EDB                    	mov	ds,bx
  3955                                  	;assume ds:NOTHING
  3956                                  	;lds	bx,[34h] 
  3957 00000FFD C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
  3958 00001001 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  3959 00001003 58                      	pop	ax
  3960 00001004 5B                      	pop	bx
  3961 00001005 1F                      	pop	ds
  3962 00001006 C3                      	retn
  3963                                  
  3964                                  	;assume ds:DATARES,ss:DATARES
  3965                                  Hopeless:
  3966 00001007 BA[8205]                	mov	dx,COMBAD
  3967 0000100A E9BEFD                  	jmp	FatalC
  3968                                  
  3969                                  GetComDsk:
  3970 0000100D A0[3202]                	mov	al,[ComDrv]
  3971 00001010 E84DFF                  	call	RemCheck
  3972 00001013 75F2                    	jnz	short Hopeless		; non-removable media
  3973                                  GetComDsk3:
  3974 00001015 81FA[8205]              	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
  3975 00001019 7503                    	jne	short GetComDsk4
  3976                                  	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
  3977                                  	; 12/01/2023
  3978                                  	;;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
  3979                                  	; 05/06/2023
  3980                                  	;mov	dx,COMBAD ; (MSDOS 6.22 COMMAND.COM - RESGROUP:11B6h)
  3981                                  	;invoke	RPrint			; say COMMAND is invalid
  3982 0000101B E81803                  	call	RPrint
  3983                                  	;call	RDISPMSG
  3984                                  
  3985                                  GetComDsk4:
  3986                                  
  3987                                  ;	Bugbug:	there's always a drive here? No need to check?
  3988                                  
  3989 0000101E 803E[CD01]00            	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
  3990 00001023 7509                    	jne	short Users_Drive	; yes - use it
  3991 00001025 B419                    	mov	ah,19h
  3992                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  3993 00001027 CD21                    	int	21h
  3994 00001029 0441                    	add	al,"A"                  ; convert to ascii
  3995 0000102B A2[CD01]                	mov	[PutBackDrv],al		; put in message to print out
  3996                                  
  3997                                  Users_Drive:
  3998                                  	; 12/01/2023
  3999                                  	; MSDOS 6.0
  4000 0000102E BA[9805]                	mov	dx,PUTBACKMSG		; prompt for diskette
  4001                                  	;mov	si,offset DATARES:PutBackSubst
  4002                                  	;invoke	RPrint
  4003 00001031 BE[C701]                	mov	si,PutBackSubst		; containing COMMAND
  4004 00001034 E8FF02                  	call	RPrint
  4005                                  	;mov	dx,offset DATARES:Prompt
  4006                                  	;invoke	RPrint
  4007 00001037 BA[BA05]                	mov	dx,PROMPT		; "Press any key"
  4008 0000103A E8F902                  	call	RPrint
  4009                                  
  4010                                  	; MSDOS 3.3
  4011                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  4012                                  	;call	RDISPMSG
  4013                                  	;mov	dx,[PUTBACKSUBSTPTR]
  4014                                  	;mov	si,[COMSPEC_END]
  4015                                  	;mov	byte [si+1],'$'
  4016                                  	;call	RDISPMSG
  4017                                  	;mov	byte [si+1],0
  4018                                  	;mov	dx,PROMPT
  4019                                  	;call	RDISPMSG
  4020                                  
  4021                                  	;call	GetRawFlushedByte
  4022                                  	;retn
  4023                                  	; 12/01/2023
  4024                                  	;jmp	short GetRawFlushedByte
  4025                                  
  4026                                  ;***	GetRawFlushedByte - flush world and get raw input
  4027                                  
  4028                                  GetRawFlushedByte:
  4029                                  	; 12/01/2023
  4030 0000103D B8070C                  	mov	ax,0C07h
  4031                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  4032 00001040 CD21                    	int	21h			; get char without testing or echo
  4033 00001042 B8000C                  	mov	ax,0C00h
  4034                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  4035 00001045 CD21                    	int	21h
  4036                                  
  4037                                  ;	Bugbug:	get rid of this return and the following retz.
  4038                                  
  4039                                  LoadCom_retn:
  4040 00001047 C3                      	retn
  4041                                  
  4042                                  	; 21/04/2023
  4043                                  TryDoOpen:
  4044 00001048 E8C2FF                  	call	GetComDsk
  4045                                  	;jmp	short LoadCom
  4046                                  
  4047                                  ;***	LoadCom - load in transient
  4048                                  
  4049                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4050                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)
  4051                                  
  4052                                  LoadCom:
  4053                                  	;assume	ds:DATARES
  4054                                  	
  4055 0000104B 45                      	inc	bp				; flag command read
  4056                                  
  4057 0000104C BA[E901]                	mov	dx,ComSpec
  4058 0000104F B8003D                  	mov	ax,3D00h
  4059                                  	;mov	ax,OPEN<<8	; 3D00h
  4060 00001052 CD21                    	int	21h				; open command.com
  4061 00001054 730B                    	jnc	short ReadCom
  4062                                  	;cmp	ax,4
  4063 00001056 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  4064 00001059 75ED                    	jnz	short TryDoOpen
  4065 0000105B BA[4406]                	mov	dx,NOHANDMES
  4066 0000105E E96AFD                  	jmp	FatalC				; will never find a handle
  4067                                  
  4068                                  	; 21/04/2023
  4069                                  ;TryDoOpen:
  4070                                  	;call	GetComDsk
  4071                                  	;jmp	short LoadCom
  4072                                  
  4073                                  ReadCom:
  4074 00001061 89C3                    	mov	bx,ax				; BX = handle
  4075                                  	;mov	dx,offset RESGROUP:TranStart
  4076                                  	; 05/06/2023
  4077                                  	;mov	dx,26E0h ; MSDOS 6.22 COMMAND.COM
  4078 00001063 BA5025                  	mov	dx,TRANSTART
  4079 00001066 31C9                    	xor	cx,cx				; CX:DX = seek loc
  4080 00001068 B80042                  	mov	ax,4200h
  4081                                  	;mov	ax,LSEEK<<8	; 4200h
  4082 0000106B CD21                    	int	21h
  4083 0000106D 7210                    	jc	short WrongCom1
  4084                                  	; 12/01/2023
  4085                                  	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
  4086                                  	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
  4087                                  	; 05/06/2023
  4088                                  	;mov	cx,0AE95h		 ; MSDOS 6.22 COMMAND.COM
  4089 0000106F B901A9                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  4090 00001072 1E                      	push	ds
  4091 00001073 8E1E[2D02]              	mov	ds,[TrnSeg]
  4092                                  	;assume	ds:NOTHING
  4093 00001077 BA0001                  	mov	dx,100h
  4094 0000107A B43F                    	mov	ah,3Fh
  4095                                  	;mov	ah,READ	; 3Fh	
  4096 0000107C CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  4097                                  			; BX = file handle, CX = number of bytes to read
  4098                                  			; DS:DX -> buffer
  4099 0000107E 1F                      	pop	ds
  4100                                  	;assume	ds:DATARES
  4101                                  WrongCom1:
  4102 0000107F 9C                      	pushf
  4103 00001080 50                      	push	ax
  4104 00001081 B43E                    	mov	ah,3Eh
  4105                                  	;mov	ah,CLOSE ; 3Eh
  4106 00001083 CD21                    	int	21h			; close command.com
  4107 00001085 58                      	pop	ax
  4108 00001086 9D                      	popf
  4109 00001087 7204                    	jc	short WrongCom		; error on read
  4110 00001089 39C8                    	cmp	ax,cx
  4111                                  	;retz				; size matched
  4112 0000108B 74BA                    	jz	short LoadCom_retn
  4113                                  WrongCom:
  4114 0000108D BA[8205]                	mov	dx,COMBAD
  4115 00001090 E87AFF                  	call	GetComDsk
  4116 00001093 EBB6                    	jmp	short LoadCom		; try again
  4117                                  
  4118                                  ;***	ChkSum - compute transient checksum
  4119                                  
  4120                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4121                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
  4122                                  	
  4123                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  4124                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1239h
  4125                                  ChkSum:
  4126 00001095 1E                      	push	ds
  4127 00001096 8E1E[2D02]              	mov	ds,[TrnSeg]
  4128 0000109A BE0001                  	mov	si,100h
  4129                                  	;;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
  4130                                  	;;mov	cx,87C2h ; MSDOS 5.0
  4131                                  	; 05/06/2023
  4132                                  	;mov	cx,9D53h ; MSDOS 6.22
  4133 0000109D B9[4198]                	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
  4134                                  Check_Sum:
  4135 000010A0 FC                      	cld
  4136 000010A1 D1E9                    	shr	cx,1
  4137 000010A3 31D2                    	xor	dx,dx
  4138                                  Chk:
  4139 000010A5 AD                      	lodsw
  4140 000010A6 01C2                    	add	dx,ax
  4141 000010A8 83D200                  	adc	dx,0
  4142 000010AB E2F8                    	loop	Chk
  4143                                  
  4144                                  	; 04/05/2023
  4145 000010AD 1F                      	pop	ds
  4146                                  
  4147                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4148 000010AE 3B16[3502]              	cmp	dx,[Sum]
  4149                                  
  4150                                  	;pop	ds ; 04/05/2023
  4151 000010B2 C3                      	retn
  4152                                  
  4153                                  ;***	SetVect - set interrupt vectors
  4154                                  
  4155                                  SetVect:
  4156                                  	;mov	dx,offset DATARES:LodCom_Trap 
  4157                                  	; 12/01/2023
  4158 000010B3 BA[7E00]                	mov	dx,LodCom_Trap
  4159                                  	;mov	dx,LODCOM ; MSDOS 3.3
  4160 000010B6 B82225                  	mov	ax,2522h
  4161                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  4162 000010B9 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  4163 000010BD 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  4164 000010C1 CD21                    	int	21h
  4165                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  4166 000010C3 BA[4A00]                	mov	dx,Ctrlc_Trap
  4167                                  	;mov	dx,CONTC ; MSDOS 3.3
  4168 000010C6 FEC0                    	inc	al	; 23h
  4169 000010C8 CD21                    	int	21h
  4170                                  	;mov	dx,offset DATARES:CritErr_Trap
  4171 000010CA BA[5500]                	mov	dx,CritErr_Trap
  4172                                  	;mov	dx,CRITERR ; MSDOS 3.3
  4173 000010CD FEC0                    	inc	al	; 24h
  4174 000010CF CD21                    	int	21h
  4175 000010D1 C3                      	retn
  4176                                  
  4177                                  ; ---------------------------
  4178                                  
  4179                                  	; MSDOS 6.0
  4180                                  ;;SR;
  4181                                  ;We have this to take care of the extra values pushed on the stack by
  4182                                  ;the stub before jumping to LodCom1. We set up ds here and then jump to
  4183                                  ;Lodcom1
  4184                                  
  4185                                  ;public	TrnLodCom1
  4186                                  	; 12/01/2023
  4187                                  TrnLodCom1:
  4188 000010D2 1F                      	pop	ds			; ds = DATARES
  4189 000010D3 83C402                  	add	sp,2
  4190                                  ;	pop	ds:OldDS
  4191 000010D6 E921FE                  	jmp	LodCom1
  4192                                  
  4193                                  ;=============================================================================
  4194                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  4195                                  ;=============================================================================
  4196                                  ; 22/09/2018 - Retro DOS v3.0
  4197                                  
  4198                                  ;	title	Localizable code for resident COMMAND
  4199                                  
  4200                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4201                                  
  4202                                  ; ----------------------------------------------------------------------------
  4203                                  ;***	AskEnd - ask user to confirm batch file termination
  4204                                  ;
  4205                                  ;	Confirm with user before freeing batch ...
  4206                                  ;
  4207                                  ;	ENTRY	nothing
  4208                                  ;
  4209                                  ;	EXIT	CY = set if batch termination is confirmed
  4210                                  ;
  4211                                  ;		CY = clear if batch should continue
  4212                                  ;
  4213                                  ;	USED	AX,DX,...
  4214                                  ;
  4215                                  ;	Bugbug:	move this to transient, copy to batch segment.
  4216                                  ;	Bugbug:	or move it to command1 1st.
  4217                                  ;
  4218                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  4219                                  ; ----------------------------------------------------------------------------
  4220                                  
  4221                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4222                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)
  4223                                  
  4224                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  4225                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1279h (CODERES:0429h)
  4226                                  AskEnd:
  4227                                  	;assume	ds:DATARES
  4228                                  
  4229 000010D9 BA[DC05]                	mov	dx,ENDBATMES			; DX = message #
  4230 000010DC E85702                  	call	RPrint
  4231                                  	;call	RDISPMSG  ; MSDOS 3.3
  4232 000010DF B8010C                  	mov	ax,0C01h
  4233                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  4234 000010E2 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  4235                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  4236 000010E4 E8E802                  	call	CharToUpper			; change to upper case
  4237 000010E7 3A06[E304]              	cmp	al,[NO_CHAR]
  4238 000010EB 7407                    	je	short aeRet			; answer is no (CY is clear)
  4239 000010ED 3A06[E204]              	cmp	al,[YES_CHAR]
  4240 000010F1 75E6                    	jne	short AskEnd			; invalid response, try again
  4241 000010F3 F9                      	stc					; answer is yes
  4242                                  aeRet:	
  4243 000010F4 C3                      	retn
  4244                                  
  4245                                  ; ----------------------------------------------------------------------------
  4246                                  ;***	DskErr - critical error handler
  4247                                  ;
  4248                                  ;	Default critical error handler unless user intercepts int 24h.
  4249                                  ;
  4250                                  ;	ENTRY	int 24h
  4251                                  ;
  4252                                  ;	EXIT
  4253                                  ;
  4254                                  ;	USED
  4255                                  ;
  4256                                  ;	EFFECTS
  4257                                  ; ----------------------------------------------------------------------------
  4258                                  
  4259                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4260                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)
  4261                                  
  4262                                  ;SR; 
  4263                                  ;The stub is going to push the old ds value and the resident data segment
  4264                                  ;onto the stack in that order. Get it off the stack
  4265                                  
  4266                                  ;DskErr	proc	far
  4267                                  DSKERR:
  4268                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  4269                                  	; 12/01/2023
  4270 000010F5 1F                      	pop	ds			; ds = DATARES
  4271                                  	;assume ds:DATARES
  4272 000010F6 8F06[D404]              	pop	word [OldDS]		; save old ds value
  4273                                  
  4274                                  ;CRITERR: ; MSDOS 3.3
  4275 000010FA FB                      	sti
  4276                                  	; 12/01/2023
  4277                                  	;push	ds ; 25/09/2018
  4278 000010FB 06                      	push	es
  4279 000010FC 56                      	push	si
  4280 000010FD 51                      	push	cx
  4281 000010FE 57                      	push	di
  4282 000010FF 51                      	push	cx
  4283 00001100 50                      	push	ax
  4284                                  
  4285 00001101 1E                      	push	ds			;save our data segment
  4286                                  	;push	cs ; 25/09/2018
  4287 00001102 07                      	pop	es			;es = DATARES
  4288                                  
  4289 00001103 8EDD                    	mov	ds,bp
  4290                                  	;assume	ds:nothing
  4291                                  
  4292                                  	;mov	ax,[si].SDEVATT
  4293 00001105 8B4404                  	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
  4294 00001108 268826[C301]            	mov	[es:CDevAt],ah
  4295                                  
  4296                                  	;push	cs
  4297                                  	;pop	es
  4298                                  
  4299 0000110D BF[B601]                	mov	di,DevName
  4300 00001110 B90800                  	mov	cx,8
  4301                                  	;add	si,SDEVNAME  ; add si,10
  4302 00001113 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  4303                                  				
  4304 00001116 FC                      	cld
  4305 00001117 F3A4                    	rep	movsb
  4306 00001119 58                      	pop	ax
  4307 0000111A 59                      	pop	cx
  4308 0000111B 5F                      	pop	di
  4309                                  
  4310                                  ;	Stack still contains DS and ES.
  4311                                  
  4312                                  ;SR;
  4313                                  ;We need ds = DATARES for SavHand
  4314                                  
  4315                                  	 ;12/01/2023
  4316 0000111C 06                      	push	es
  4317 0000111D 1F                      	pop	ds
  4318                                  	;assume	ds:DATARES
  4319                                  
  4320                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  4321 0000111E E8A7FE                  	call	SavHand
  4322                                  
  4323                                  	; 12/01/2023
  4324                                  	; 25/09/2018
  4325                                  	;;push	cs
  4326                                  	;push	es
  4327                                  	;pop	ds		; set up local data segment
  4328                                  	;assume	ds:resgroup
  4329                                  
  4330 00001121 52                      	push	dx
  4331 00001122 E80E02                  	call	crlf
  4332 00001125 5A                      	pop	dx
  4333                                  
  4334                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  4335                                  
  4336 00001126 8826[3A02]              	mov	[Crit_Err_Info],ah	; save critical error flags
  4337                                  
  4338                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  4339                                  
  4340 0000112A 0441                    	add	al,'A'
  4341 0000112C A2[A301]                	mov	[DrvLet],al
  4342                                  
  4343                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  4344                                  
  4345 0000112F F6C480                  	test	ah,80h
  4346 00001132 740A                    	jz	short NoHardE		; it's a disk-device error
  4347 00001134 F606[C301]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4348 00001139 7503                    	jnz	short NoHardE		; it's a character device
  4349 0000113B E9E801                  	jmp	FatErr			; it's a FAT error
  4350                                  
  4351                                  NoHardE:
  4352 0000113E BE[0405]                	mov	si,MREAD		; SI = "read" msg #
  4353 00001141 F6C401                  	test	ah,1
  4354 00001144 7403                    	jz	short SavMes		; it's a read error
  4355 00001146 BE[0D05]                	mov	si,MWRITE		; SI = "write" msg #
  4356                                  SavMes:
  4357 00001149 893E[FE03]              	mov	[OldErrNo],di		; save critical error code
  4358                                  
  4359                                  ;	Bugbug:	don't need to save/restore all here?
  4360                                  
  4361 0000114D 06                      	push	es
  4362                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4363                                  	;push	ds			; GetExtendedError likes to STOMP
  4364                                  	; 12/01/2023
  4365                                  	; (all registers are changed -in dos service- except bp) *
  4366                                  	;push	bp
  4367                                  	; 19/07/2024
  4368                                  	;push	si
  4369                                  	;push	dx
  4370 0000114E 51                      	push	cx
  4371 0000114F 53                      	push	bx
  4372                                  	; 05/06/2023
  4373 00001150 B459                    	mov	ah,59h ; *
  4374                                  	;mov	ah,GetExtendedError ; 59h ; get extended error info
  4375 00001152 CD21                    	int	21h
  4376 00001154 5B                      	pop	bx
  4377 00001155 59                      	pop	cx
  4378                                  	; 19/07/2024
  4379                                  	;pop	dx
  4380                                  	;pop	si
  4381                                  	; 12/01/2023
  4382                                  	;pop	bp
  4383                                  	; 19/07/2024
  4384                                  	;pop	ds
  4385 00001156 893E[D101]              	mov	[NeedVol],di		; save possible ptr to volume label
  4386 0000115A 8C06[D301]              	mov	[NeedVol+2],es
  4387 0000115E 07                      	pop	es
  4388                                  
  4389                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  4390                                  
  4391                                  	; 19/07/2024 - PCDOS 7.1 COMMAND.COM
  4392                                  	;xor	ah,ah
  4393 0000115F 89C7                    	mov	di,ax			; DI = error code
  4394                                  
  4395                                  ; Bugbug: somewhat obsolete documentation?
  4396                                  ;
  4397                                  ; DI is now the correct error code. Classify things to see what we are
  4398                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  4399                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  4400                                  ; the like) are contiguous.
  4401                                  
  4402                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  4403                                  ;	Check use of ErrCd_24, though.
  4404                                  
  4405 00001161 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  4406 00001164 7303                    	jae	short HavCod
  4407                                  
  4408                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  4409                                  ;	even though it's not a critical error?
  4410                                  
  4411 00001166 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  4412                                  
  4413                                  ; DI now has the mapped error code. Old style errors are:
  4414                                  ;   FOOBAR <read|writ>ing drive ZZ.
  4415                                  ; New style errors are:
  4416                                  ;   FOOBAR
  4417                                  ; We need to figure out which the particular error belongs to.
  4418                                  
  4419                                  HavCod:
  4420 00001169 C606[D501]00            	mov	byte [ErrType],0	; assume old style
  4421 0000116E 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  4422 00001171 7405                    	je	short SetStyle
  4423 00001173 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4424 00001176 7504                    	jne	short GotStyle
  4425                                  
  4426                                  SetStyle:
  4427                                  ;	Bugbug:	use INC
  4428                                  	;mov	byte [ErrType],1		; must be new type
  4429 00001178 FE06[D501]              	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  4430                                  
  4431                                  GotStyle:
  4432 0000117C 893E[E201]              	mov	[ErrCd_24],di
  4433                                  	; 12/01/2023
  4434                                  	; 25/09/2018
  4435                                  	; MSDOS 6.0
  4436 00001180 83FF14                  	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  4437                                  	; MSDOS 3.3
  4438                                  	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4439                                  
  4440                                  						; If the error message is unknown
  4441 00001183 7641                    	jbe	short NormalError		;  redirector, continue. Otherwise,
  4442                                  
  4443                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  4444                                  ; how to handle things
  4445                                  
  4446                                  ;input to IFSFUNC:    AL=1
  4447                                  ;		      BX=extended error number
  4448                                  ;
  4449                                  ;output from IFSFUNC: AL=error type (0 or 1)
  4450                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  4451                                  ;			   Abort, Retry, Ignore
  4452                                  ;			 1=<message>
  4453                                  ;			   Abort, Retry, Ignore
  4454                                  ;		      ES:DI=pointer to message text
  4455                                  ;		      carry set=>no message
  4456                                  
  4457 00001185 89C7                    	mov	di,ax			; retrieve correct extended error...
  4458 00001187 B80005                  	mov	ax,0500h		; is the redir there?
  4459 0000118A CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  4460                                  			; Return: AL = 00h not installed, OK to install
  4461                                  			; 01h not installed, can't install
  4462                                  			; FFh installed
  4463 0000118C 3CFF                    	cmp	al,0FFh
  4464 0000118E 7529                    	jne	short NoHandler		; no, go to NoHandler
  4465                                  
  4466                                  	; 12/01/2023
  4467                                  	; MSDOS 6.0
  4468 00001190 53                      	push	bx
  4469 00001191 89FB                    	mov	bx,di			; get ErrType and ptr to error msg
  4470 00001193 B80105                  	mov	ax,0501h
  4471 00001196 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4472 00001198 5B                      	pop	bx 
  4473 00001199 721E                    	jc	short NoHandler
  4474                                  	
  4475                                  	; MSDOS 3.3
  4476                                  	;mov     ax,di
  4477                                  	;mov     ah,5
  4478                                  	;int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4479                                  	;jc      short NOHANDLER
  4480                                  
  4481                                  ;	Bugbug:	need to record error type?
  4482                                  
  4483 0000119B A2[D501]                	mov	[ErrType],al
  4484                                  
  4485 0000119E 1E                      	push	ds
  4486 0000119F 06                      	push	es
  4487 000011A0 1F                      	pop	ds
  4488 000011A1 89FA                    	mov	dx,di
  4489 000011A3 B9FFFF                  	mov	cx,-1			; find end of msg
  4490 000011A6 30C0                    	xor	al,al
  4491                                  
  4492 000011A8 FC                      	cld
  4493 000011A9 F2AE                    	repnz	scasb
  4494                                  
  4495                                  ;	Bugbug:	we can do better than this.
  4496                                  
  4497                                  	;mov	byte [di-1],'$'
  4498                                  	; 19/07/2024
  4499 000011AB 4F                      	dec	di
  4500 000011AC C60524                  	mov	byte [di],'$'
  4501                                  	
  4502                                  	;CALL	RDISPMSG ; MSDOS 3.3
  4503                                  	
  4504 000011AF B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  4505 000011B1 CD21                    	int	21h
  4506                                  
  4507                                  	;mov	byte [di-1],0			; restore terminal byte
  4508                                  	; 19/07/2024
  4509 000011B3 C60500                  	mov	byte [di],0
  4510                                  
  4511 000011B6 1F                      	pop	ds				; clean up and continue
  4512 000011B7 EB15                    	jmp	short CheckErrType
  4513                                  
  4514                                  ;*	Redir isn't available or doesn't recognize the error.
  4515                                  ;	Restore regs to unextended error.
  4516                                  
  4517                                  NoHandler:
  4518 000011B9 C606[D501]00            	mov	byte [ErrType],0
  4519                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  4520 000011BE 8B3E[FE03]              	mov	di,[OldErrNo]
  4521 000011C2 893E[E201]              	mov	[ErrCd_24],di
  4522                                  
  4523                                  NormalError:
  4524                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4525                                  	; MSDOS 6.0
  4526 000011C6 83C713                  	add	di,ERROR_WRITE_PROTECT
  4527 000011C9 87FA                    	xchg	di,dx			; may need dx later
  4528 000011CB E88101                  	call	RPrintCrit		; print error type
  4529                                  
  4530                                  	; MSDOS 3.3
  4531                                  	;shl     di,1
  4532                                  	;mov     di,[CRMSGTBL+di]
  4533                                  	;xchg    di,dx
  4534                                  	;call    RDISPMSG
  4535                                  
  4536                                  CheckErrType:
  4537 000011CE 803E[D501]00            	cmp	byte [ErrType],0	; Check error style...
  4538 000011D3 7405                    	je	short ContOld
  4539 000011D5 E85B01                  	call	crlf			; if new style then done printing
  4540 000011D8 EB31                    	jmp	short Ask
  4541                                  
  4542                                  ContOld:
  4543                                  	; 12/01/2023
  4544                                  	; MSDOS 6.0
  4545 000011DA 46                      	inc	si			; DS:SI = ptr to asciiz string
  4546                                  
  4547                                  ;	Bugbug:	combine some of the following two sections?
  4548                                  
  4549                                  	; 12/01/2023
  4550 000011DB F606[C301]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4551                                  	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
  4552 000011E0 740F                    	jz	short BlkErr
  4553                                  	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
  4554                                  	;mov	dx,ChardevErr
  4555 000011E2 BA[2505]                	mov	dx,MDEVICE
  4556                                  	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
  4557 000011E5 8936[A501]              	mov	[CharDevErrRw],si
  4558                                  	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  4559 000011E9 BE[A401]                	mov	si,CharDevErrSubst
  4560                                  
  4561 000011EC E84701                  	call	RPrint				; print the message
  4562 000011EF EB1A                    	jmp	short Ask			; don't ralph on command
  4563                                  
  4564                                  	; 12/01/2023
  4565                                  	; MSDOS 3.3
  4566                                  	;mov	dx,ERRMES
  4567                                  	;call	RDISPMSG
  4568                                  	;mov	dx,si
  4569                                  	;call	RDISPMSG
  4570                                  	;
  4571                                  	;test	byte [CDevAt],80h
  4572                                  	;jz	short BLKERR
  4573                                  	;mov	dx,CHARDEVERR	; " device "
  4574                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4575                                  	;int	21h		; DOS - PRINT STRING
  4576                                  	;			; DS:DX -> string terminated by "$"
  4577                                  	;jmp	short ASK
  4578                                  
  4579                                  BlkErr:
  4580                                  	; 12/01/2023
  4581                                  	; MSDOS 6.0
  4582                                  	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
  4583                                  	;mov	dx,BlkDevErr
  4584 000011F1 BA[1605]                	mov	dx,MDRIVE
  4585                                  	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
  4586 000011F4 8936[9E01]              	mov	[BlkDevErrRw],si
  4587                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  4588 000011F8 BE[9D01]                	mov	si,BlkDevErrSubst
  4589 000011FB E83801                  	call	RPrint
  4590                                  
  4591                                  	; MSDOS 3.3
  4592                                  	;mov	dx,BLKDEVERR
  4593                                  	;call	RDISPMSG
  4594                                  
  4595 000011FE 803E[E601]00            	cmp	byte [Loading],0
  4596 00001203 7406                    	jz	short Ask
  4597 00001205 E8E9FD                  	call	RestHand
  4598 00001208 E9E0FD                  	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
  4599                                  Ask:
  4600 0000120B 833E[E201]0F            	cmp	word [ErrCd_24],15	; error 15 has an extra message
  4601 00001210 751E                    	jne	short Not15		; not error 15
  4602                                  
  4603                                  ;*	For error 15, tell the user which volume/serial # are needed.
  4604                                  
  4605 00001212 51                      	push	cx
  4606                                  
  4607                                  ;	Bugbug:	does this push/pop need to be done?
  4608                                  
  4609 00001213 1E                      	push	ds
  4610 00001214 07                      	pop	es
  4611 00001215 C536[D101]              	lds	si,[NeedVol]
  4612                                  	;assume	ds:NOTHING
  4613 00001219 57                      	push	di
  4614 0000121A BF[B301]                	mov	di,VolName
  4615                                  	; 12/01/2023
  4616                                  	; MSDOS 6.0
  4617 0000121D B91000                  	mov	cx,16			; copy volume name & serial #
  4618                                  	; MSDOS 3.3
  4619                                  	;mov	cx,11			; copy volume name
  4620 00001220 FC                      	cld
  4621 00001221 F3A4                    	rep	movsb
  4622 00001223 5F                      	pop	di
  4623 00001224 06                      	push	es
  4624 00001225 1F                      	pop	ds
  4625 00001226 59                      	pop	cx
  4626                                  	;assume	ds:DATARES
  4627                                  	; 12/01/2023
  4628                                  	; MSDOS 6.0
  4629                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  4630                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  4631                                  	;mov	dx,NeedVolMsg
  4632 00001227 BA[3505]                	mov	dx,MVOLSERIAL
  4633 0000122A BE[AA01]                	mov	si,NeedVolSubst
  4634 0000122D E80601                  	call	RPrint
  4635                                  
  4636                                  	; MSDOS 3.3
  4637                                  	;mov	dx,NEEDVOLMSG
  4638                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4639                                  	;int	21h		; DOS - PRINT STRING
  4640                                  	;			; DS:DX -> string terminated by "$"
  4641                                  Not15:
  4642                                  ;*	Print abort, retry, ignore, fail message.
  4643                                  ;	Print only options that are valid.
  4644                                  
  4645                                  ;	Bugbug:	sizzle this.
  4646                                  
  4647                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4648 00001230 BA[E404]                	mov	dx,REQ_ABORT
  4649 00001233 E80001                  	call	RPrint
  4650                                  	;call	RDISPMSG
  4651 00001236 F606[3A02]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
  4652 0000123B 7406                    	jz	short Try_Ignore
  4653 0000123D BA[EA04]                	mov	dx,REQ_RETRY
  4654 00001240 E8F300                  	call	RPrint
  4655                                  	;call	RDISPMSG
  4656                                  Try_Ignore:
  4657 00001243 F606[3A02]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
  4658 00001248 7406                    	jz	short Try_Fail
  4659 0000124A BA[F204]                	mov	dx,REQ_IGNORE
  4660 0000124D E8E600                  	call	RPrint
  4661                                  	;call	RDISPMSG
  4662                                  Try_Fail:
  4663 00001250 F606[3A02]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
  4664 00001255 7406                    	jz	short Term_Question
  4665 00001257 BA[FB04]                	mov	dx,REQ_FAIL
  4666 0000125A E8D900                  	call	RPrint
  4667                                  	;call	RDISPMSG
  4668                                  Term_Question:
  4669 0000125D BA[0205]                	mov	dx,REQ_END
  4670 00001260 E8D300                  	call	RPrint
  4671                                  	;call	RDISPMSG
  4672                                  
  4673                                  ;	If the /f switch was given, we fail all requests.
  4674                                  
  4675 00001263 F606[4702]FF            	test	byte [fFail],-1
  4676 00001268 741B                    	jz	short DoPrompt
  4677 0000126A B403                    	mov	ah,3				; signal fail
  4678 0000126C E9A800                  	jmp	EExit
  4679                                  
  4680                                  	; 16/04/2023
  4681                                  Abort_Process:
  4682 0000126F F606[B402]01            	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
  4683 00001274 745D                    	jz	short AbortCont			; no, handle it normally
  4684 00001276 803E[4002]00            	cmp	byte [PermCom],0		; are we top level process?
  4685 0000127B 744B                    	jz	short JustExit			; yes, just exit
  4686                                  
  4687 0000127D BA[E706]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  4688                                  	; 12/01/2023
  4689 00001280 E8B300                  	call	RPrint				; print it
  4690                                  	;call	RDISPMSG
  4691                                  DeadInTheWater:
  4692 00001283 EBFE                    	jmp	short DeadInTheWater		; loop until the user reboots
  4693                                  
  4694                                  DoPrompt:
  4695                                  	; 12/01/2023
  4696 00001285 B8010C                  	mov	ax,0C01h
  4697                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  4698 00001288 CD21                    	int	21h				; get response
  4699                                  
  4700 0000128A E8A600                  	call	crlf
  4701 0000128D E83F01                  	call	CharToUpper			; convert to upper case
  4702 00001290 B400                    	mov	ah,0				; return code for ignore
  4703 00001292 F606[3A02]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  4704 00001297 7406                    	jz	short User_Retry
  4705 00001299 3A06[E004]              	cmp	al,[IGNORE_CHAR]		; ignore?
  4706                                  	;jz	short EExitJ
  4707                                  	; 16/04/2023
  4708 0000129D 7478                    	jz	short EExit
  4709                                  
  4710                                  ;	Bugbug:	optimize following code.
  4711                                  
  4712                                  User_Retry:
  4713 0000129F FEC4                    	inc	ah				; return code for retry
  4714 000012A1 F606[3A02]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
  4715 000012A6 7406                    	jz	short User_Abort
  4716 000012A8 3A06[DF04]              	cmp	al,[RETRY_CHAR]			; retry?
  4717                                  	;jz	short EExitJ
  4718                                  	; 16/04/2023
  4719 000012AC 7469                    	jz	short EExit
  4720                                  User_Abort:
  4721 000012AE FEC4                    	inc	ah				; return code for abort
  4722                                  						;  (abort always allowed)
  4723 000012B0 3A06[DE04]              	cmp	al,[ABORT_CHAR]			; abort?
  4724 000012B4 74B9                    	jz	short Abort_Process		; exit user program
  4725 000012B6 FEC4                    	inc	ah				; return code for fail
  4726 000012B8 F606[3A02]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
  4727 000012BD 7406                    	jz	short AskJ
  4728 000012BF 3A06[E104]              	cmp	al,[FAIL_CHAR]			; fail?
  4729                                  	;jz	short EExitJ
  4730                                  	; 16/04/2023
  4731 000012C3 7452                    	jz	short EExit
  4732                                  AskJ:
  4733 000012C5 E943FF                  	jmp	Ask
  4734                                  
  4735                                  	; 12/01/2023
  4736                                  ;EExitJ:
  4737                                  	;jmp	short EExit
  4738                                  
  4739                                  JustExit:
  4740                                  	;assume	ds:DATARES
  4741                                  	; 12/01/2023
  4742 000012C8 A1[DC01]                	mov	ax,[Parent]			; load real parent pid
  4743                                  	;mov	[16h],ax
  4744 000012CB A31600                  	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
  4745 000012CE B8FF4C                  	mov	ax,4CFFh
  4746                                  	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
  4747 000012D1 CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  4748                                  				; AL = exit code
  4749                                  AbortCont:
  4750 000012D3 F606[3002]FF            	test	byte [In_Batch],-1		; Are we accessing a batch file?
  4751 000012D8 7405                    	jz	short Not_Batch_Abort
  4752 000012DA C606[3102]01            	mov	byte [Batch_Abort],1		; set flag for abort
  4753                                  
  4754                                  Not_Batch_Abort:
  4755 000012DF 8A16[B502]              	mov	dl,[PipeFlag]
  4756 000012E3 E8D1FA                  	call	ResPipeOff
  4757 000012E6 08D2                    	or	dl,dl
  4758 000012E8 740D                    	je	short CheckForA
  4759 000012EA 833E[4302]00            	cmp	word [SingleCom],0
  4760 000012EF 7406                    	je	short CheckForA
  4761 000012F1 C706[4302]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4762                                  
  4763                                  CheckForA:
  4764 000012F7 833E[E201]00            	cmp	word [ErrCd_24],0		; write protect?
  4765 000012FC 7407                    	je	short abortfor
  4766 000012FE 833E[E201]02            	cmp	word [ErrCd_24],2		; drive not ready?
  4767 00001303 7512                    	jne	short EExit			; don't abort the FOR
  4768                                  
  4769                                  abortfor:
  4770 00001305 C606[4902]00            	mov	byte [ForFlag],0		; abort a FOR in progress
  4771 0000130A 833E[4302]00            	cmp	word [SingleCom],0
  4772 0000130F 7406                    	je	short EExit
  4773 00001311 C706[4302]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4774                                  
  4775                                  EExit:
  4776 00001317 88E0                    	mov	al,ah
  4777 00001319 89FA                    	mov	dx,di
  4778                                  RestHd:
  4779 0000131B E8D3FC                  	call    RestHand
  4780 0000131E 59                      	pop	cx
  4781 0000131F 5E                      	pop	si				; restore registers
  4782 00001320 07                      	pop	es
  4783                                  
  4784                                  	; 12/01/2023	
  4785                                  	; MSDOS 6.0
  4786                                  ;;	pop	ds
  4787                                  ;SR;
  4788                                  ;ds has to be got from the variable we saved it in
  4789                                  
  4790 00001321 8E1E[D404]               	mov	ds,[OldDS]			; restore old value of ds
  4791                                  
  4792                                  ;	pop	ds
  4793                                  ;	assume	ds:nothing
  4794                                  
  4795                                  	; MSDOS 3.3
  4796                                  	;pop	ds
  4797                                  
  4798 00001325 CF                      	iret
  4799                                  
  4800                                  FatErr:
  4801                                  	; 12/01/2023
  4802                                  	; MSDOS 6.0
  4803                                  	;mov	dx,offset DATARES:BadFatMsg
  4804                                  	;mov	si,offset DATARES:BadFatSubst
  4805 00001326 BA[5C05]                	mov	dx,BADFATMSG
  4806 00001329 BE[C401]                	mov	si,BadFatSubst
  4807 0000132C E80700                  	call	RPrint
  4808                                  
  4809                                  	; MSDOS 3.3
  4810                                  	;mov	dx,BADFATMSG
  4811                                  	;call	RDISPMSG
  4812                                  	;mov	dx,BLKDEVERR
  4813                                  	;call	RDISPMSG
  4814                                  
  4815 0000132F B002                    	mov	al,2				; abort
  4816 00001331 EBE8                    	jmp	short RestHd
  4817                                  
  4818                                  ;DskErr	endp
  4819                                  
  4820                                  	; MSDOS 6.0
  4821                                  ; ----------------------------------------------------------------------------
  4822                                  ;***	RPrint - print message
  4823                                  ;***	Crlf - display cr/lf
  4824                                  ;
  4825                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  4826                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  4827                                  ;		variable fields related to substitution blocks are set
  4828                                  ;
  4829                                  ;	EXIT	nothing
  4830                                  ;
  4831                                  ;	USED	flags
  4832                                  ;
  4833                                  ;	EFFECTS
  4834                                  ;	  Message is displayed on stdout.
  4835                                  ;
  4836                                  ;	NOTE
  4837                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  4838                                  ;	  be greater than number of substition blocks present.
  4839                                  ; ----------------------------------------------------------------------------
  4840                                  
  4841                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4842                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)
  4843                                  
  4844                                  crlf: 
  4845                                  	;mov	dx,offset DATARES:Newlin ; cheap newline
  4846                                  	; 14/01/2023
  4847 00001333 BA[1607]                	mov	dx,NEWLINE
  4848                                  
  4849                                  ;RPrint	proc
  4850                                  ;
  4851                                  ;	assume	ds:DATARES,ss:DATARES
  4852                                  ;
  4853                                  	; 14/01/2023
  4854                                  RPrint:
  4855                                  
  4856                                  ;	Bugbug:	do we need to save all reg's?
  4857                                  
  4858 00001336 56                      	push	si			; preserve registers
  4859 00001337 50                      	push	ax
  4860 00001338 53                      	push	bx
  4861 00001339 51                      	push	cx
  4862 0000133A 52                      	push	dx
  4863                                  
  4864 0000133B 89F3                    	mov	bx,si			; DS:BX = ptr to subst block
  4865 0000133D 89D6                    	mov	si,dx			; DS:SI = ptr to count byte
  4866 0000133F AC                      	lodsb				; AL = message length
  4867                                  					; DS:SI = ptr to message text
  4868 00001340 31C9                    	xor	cx,cx
  4869 00001342 88C1                    	mov	cl,al			; CX = message length
  4870 00001344 E303                    	jcxz	rpRet
  4871                                  
  4872 00001346 E81900                  	call	RDispMsg
  4873                                  
  4874 00001349 5A                      rpRet:	pop	dx
  4875 0000134A 59                      	pop	cx
  4876 0000134B 5B                      	pop	bx
  4877 0000134C 58                      	pop	ax
  4878 0000134D 5E                      	pop	si
  4879 0000134E C3                      	retn
  4880                                  
  4881                                  ;RPrint	endp
  4882                                  
  4883                                  	; 14/01/2023
  4884                                  ;	; MSDOS 3.3
  4885                                  ;CRLF:
  4886                                  ;	mov     dx,NEWLIN
  4887                                  ;
  4888                                  ;RDISPMSG: ; Display message/text
  4889                                  ;	; DS:DX = ($ terminated) Message/Text address 
  4890                                  ;	push    ax
  4891                                  ;	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4892                                  ;	clc
  4893                                  ;	int     21h             ; DOS - PRINT STRING
  4894                                  ;				; DS:DX -> string terminated by "$"
  4895                                  ;	pop     ax
  4896                                  ;	retn
  4897                                  
  4898                                  
  4899                                  	; MSDOS 6.0
  4900                                  ; ----------------------------------------------------------------------------
  4901                                  ;***	RPrintCrit - print critical error message
  4902                                  ;
  4903                                  ;	ENTRY	DX = extended error # (19-39)
  4904                                  ;
  4905                                  ;	EXIT	nothing
  4906                                  ;
  4907                                  ;	USED	flags
  4908                                  ;
  4909                                  ;	EFFECTS
  4910                                  ;	  Message is displayed on stdout
  4911                                  ; ----------------------------------------------------------------------------
  4912                                  
  4913                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4914                                  
  4915                                  ;RPrintCrit	proc
  4916                                  ;	assume	ds:DATARES,ss:DATARES
  4917                                  
  4918                                  	; 14/01/2023
  4919                                  RPrintCrit:
  4920 0000134F 52                      	push	dx			; preserve DX
  4921 00001350 87DA                    	xchg	bx,dx			; BX = extended error #
  4922                                  					; DX = saved BX
  4923 00001352 83EB13                  	sub	bx,19			; BX = critical error index, from 0
  4924 00001355 D1E3                    	shl	bx,1			; BX = offset in word table
  4925 00001357 8B9F[B008]              	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
  4926 0000135B 87DA                    	xchg	bx,dx			; DX = ptr to error msg
  4927                                  					; BX = restored
  4928 0000135D E8D6FF                  	call	RPrint			; print the message
  4929 00001360 5A                      	pop	dx			; restore DX
  4930 00001361 C3                      	retn
  4931                                  
  4932                                  ;RPrintCrit	endp
  4933                                  
  4934                                  ; ----------------------------------------------------------------------------
  4935                                  ;***	RDispMsg - display message
  4936                                  ;
  4937                                  ;	Display message, with substitutions, for RPrint.
  4938                                  ;
  4939                                  ;	ENTRY	DS:SI = ptr to message text
  4940                                  ;		CX = message length
  4941                                  ;		DS:BX = ptr to substitution block, if any
  4942                                  ;
  4943                                  ;	EXIT	nothing
  4944                                  ;
  4945                                  ;	USED	AX,CX,DX,SI
  4946                                  ; ----------------------------------------------------------------------------
  4947                                  
  4948                                  ;RDispMsg	proc
  4949                                  ;	assume	ds:DATARES,ss:DATARES
  4950                                  
  4951                                  RDispMsg:
  4952                                  	; 14/01/2023
  4953                                  rdNextChar:
  4954 00001362 AC                      	lodsb				; AL = next char
  4955 00001363 3C25                    	cmp	al,'%'
  4956 00001365 7511                    	jne	short rdOutChar		; not a substitution
  4957 00001367 8A14                    	mov	dl,[si]			; DL = possible '1' - '9'
  4958 00001369 80EA31                  	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  4959 0000136C 80FA09                  	cmp	dl,9
  4960 0000136F 7307                    	jae	short rdOutChar		; not a substitution
  4961                                  
  4962                                  ;*	A substitution code %1 - %9 has been encountered.
  4963                                  ;	DL = 0-8, indicating %1-%9
  4964                                  ;	DS:BX = ptr to substitution block
  4965                                  
  4966 00001371 E80D00                  	call	SubstMsg		; display the substitution
  4967 00001374 46                      	inc	si			; SI = ptr past %n
  4968 00001375 49                      	dec	cx			; count extra character in %n
  4969 00001376 EB06                    	jmp	short rdCharDone
  4970                                  
  4971                                  ;*	Normal character output.
  4972                                  
  4973                                  rdOutChar:
  4974 00001378 88C2                    	mov	dl,al			; DL = char
  4975 0000137A B402                    	mov	ah,2			; AH = DOS Character Output code
  4976 0000137C CD21                    	int	21h			; call DOS
  4977                                  rdCharDone:
  4978 0000137E E2E2                    	loop	rdNextChar
  4979 00001380 C3                      	retn
  4980                                  
  4981                                  ;RDispMsg	endp
  4982                                  
  4983                                  ; ----------------------------------------------------------------------------
  4984                                  ;***	SubstMsg - display message substitution
  4985                                  ;
  4986                                  ;	Display a substitution string within a message.
  4987                                  ;	Substitution can be a char, an ASCIIZ string, or
  4988                                  ;	a word to be displayed as hex digits.
  4989                                  ;
  4990                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  4991                                  ;		DS:BX = ptr to substitution block
  4992                                  ;
  4993                                  ;	EXIT	nothing
  4994                                  ;
  4995                                  ;	USED	AX,DX
  4996                                  ; ----------------------------------------------------------------------------
  4997                                  
  4998                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4999                                  
  5000                                  ;SubstMsg	proc
  5001                                  ;	assume	ds:DATARES,ss:DATARES
  5002                                  	
  5003                                  	; 14/01/2023
  5004                                  SubstMsg:
  5005 00001381 53                      	push	bx			; preserve BX
  5006 00001382 51                      	push	cx			; preserve CX
  5007                                  
  5008                                  	;mov	al,size SUBST		; AL = size of substitution block
  5009 00001383 B003                    	mov	al,3
  5010 00001385 F6E2                    	mul	dl			; AX = offset of desired subst block
  5011 00001387 01C3                    	add	bx,ax			; DS:BX = ptr to desired subst block
  5012                                  
  5013                                  	;mov	al,[bx].SubstType	; AX = substitution type flag
  5014 00001389 8A07                    	mov	al,[bx]
  5015                                  	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  5016 0000138B 8B5F01                  	mov	bx,[bx+1]
  5017                                  
  5018                                  ;	AL = 1, 2, or 3 for char, string, or hex type
  5019                                  
  5020 0000138E FEC8                    	dec	al
  5021 00001390 7428                    	jz	short smChar
  5022 00001392 FEC8                    	dec	al
  5023 00001394 742C                    	jz	short smStr
  5024                                  
  5025                                  ;*	Hex number substitution.
  5026                                  
  5027                                  	;mov	ax,ds:[bx]		; AX = word value
  5028 00001396 8B07                    	mov	ax,[bx]
  5029 00001398 B90400                  	mov	cx,4			; CX = # digits to display
  5030                                  smDigit:
  5031 0000139B D1C0                    	rol	ax,1
  5032 0000139D D1C0                    	rol	ax,1
  5033 0000139F D1C0                    	rol	ax,1
  5034 000013A1 D1C0                    	rol	ax,1			; AL<3:0> = next digit
  5035                                  
  5036 000013A3 50                      	push	ax			; save other digits
  5037 000013A4 240F                    	and	al,0Fh			; AL = binary digit
  5038 000013A6 0430                    	add	al,'0'			; AL = ascii digit if 0-9
  5039 000013A8 3C39                    	cmp	al,'9'
  5040 000013AA 7602                    	jbe	short smDigit09		; it's 0-9
  5041                                  	;add	al,7
  5042 000013AC 0407                    	add	al,('A' - '0') - 10	; AL = ascii digit A-F
  5043                                  smDigit09:
  5044 000013AE 88C2                    	mov	dl,al			; DL = ascii digit
  5045 000013B0 B402                    	mov	ah,2
  5046 000013B2 CD21                    	int	21h			; output the ascii digit
  5047 000013B4 58                      	pop	ax			; restore all digits
  5048                                  
  5049 000013B5 E2E4                    	loop	smDigit
  5050                                  	;jmp	short smRet
  5051                                  	; 14/01/2023
  5052                                  smRet:	
  5053 000013B7 59                      	pop	cx
  5054 000013B8 5B                      	pop	bx
  5055 000013B9 C3                      	retn
  5056                                  
  5057                                  ;*	Char substitution.
  5058                                  
  5059                                  smChar:
  5060                                  	;mov	dl,ds:[bx]		; DL = char to output
  5061 000013BA 8A17                    	mov	dl,[bx]
  5062 000013BC B402                    	mov	ah,2
  5063 000013BE CD21                    	int	21h
  5064 000013C0 EBF5                    	jmp	short smRet
  5065                                  
  5066                                  ;*	String substitution.
  5067                                  
  5068                                  smStr:
  5069                                  	;mov	dl,ds:[bx]		; DL = next char
  5070 000013C2 8A17                    	mov	dl,[bx]
  5071 000013C4 08D2                    	or	dl,dl
  5072 000013C6 74EF                    	jz	short smRet		; null char - we're done
  5073 000013C8 B402                    	mov	ah,2
  5074 000013CA CD21                    	int	21h			; display char
  5075 000013CC 43                      	inc	bx			; DS:BX = ptr to next char
  5076 000013CD EBF3                    	jmp	short smStr
  5077                                  
  5078                                  ;smRet:	pop	cx
  5079                                  ;	pop	bx
  5080                                  ;	retn
  5081                                  
  5082                                  ;SubstMsg	endp
  5083                                  
  5084                                  	; MSDOS 6.0
  5085                                  ; ----------------------------------------------------------------------------
  5086                                  ;***	CharToUpper - convert character to uppercase
  5087                                  ;
  5088                                  ;	ENTRY	AL = char
  5089                                  ;
  5090                                  ;	EXIT	AL = uppercase char
  5091                                  ;
  5092                                  ;	USED	AX
  5093                                  ; ----------------------------------------------------------------------------
  5094                                  
  5095                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5096                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
  5097                                  
  5098                                  ;CharToUpper	proc
  5099                                  ;	assume	ds:DATARES
  5100                                  CharToUpper:
  5101 000013CF 50                      	push	ax		; put char on stack as arg to int 2F
  5102 000013D0 B81312                  	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  5103 000013D3 CD2F                    	int	2Fh
  5104 000013D5 44                      	inc	sp		; throw away old char on stack
  5105 000013D6 44                      	inc	sp
  5106 000013D7 C3                      	retn
  5107                                  
  5108                                  ;CharToUpper	endp
  5109                                  
  5110                                  	; 14/01/2023
  5111                                  ;	; MSDOS 3.3
  5112                                  ;CHARTOUPPER:
  5113                                  ;	cmp	al,80h
  5114                                  ;	jb	short CHARTOUPPER1
  5115                                  ;	sub	al,80h
  5116                                  ;	push	ds
  5117                                  ;	push	bx
  5118                                  ;	lds	bx,[UPPERCASETBL]
  5119                                  ;	add	bx,2
  5120                                  ;	xlat
  5121                                  ;	pop	bx
  5122                                  ;	pop	ds
  5123                                  ;	jmp	short CHARTOUPPER_RETN
  5124                                  ;CHARTOUPPER1:
  5125                                  ;	cmp	al,'a'
  5126                                  ;	jb	short CHARTOUPPER_RETN
  5127                                  ;	cmp	al,'z'
  5128                                  ;	ja	short CHARTOUPPER_RETN
  5129                                  ;	sub	al,20h
  5130                                  ;CHARTOUPPER_RETN:
  5131                                  ;	retn
  5132                                  
  5133                                  ;public	EndCode
  5134                                  ;EndCode label byte
  5135                                  
  5136                                  	; MSDOS 6.0
  5137                                  ; ----------------------------------------------------------------------------
  5138                                  ;***	MsgInt2fHandler - int 2f handler for message retrieval
  5139                                  ;
  5140                                  ;	ENTRY	If we handle it -
  5141                                  ;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
  5142                                  ;		  DL = operation =
  5143                                  ;		     0 = get extended error messages
  5144                                  ;		     1 = set extended error messages
  5145                                  ;		     2 = get parse error messages
  5146                                  ;		     3 = set parse error messages
  5147                                  ;		     4 = get critical error messages
  5148                                  ;		     5 = set critical error messages
  5149                                  ;		     6 = get file system error messages
  5150                                  ;		     7 = set file system error messages
  5151                                  ;		     8 = get disk retriever routine
  5152                                  ;		     9 = set disk retriever routine
  5153                                  ;		  ES:DI = address for 'set' operations
  5154                                  ;
  5155                                  ;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
  5156                                  ;
  5157                                  ;	NOTE
  5158                                  ;	  This handler replaces the one that used to reside in DOS.
  5159                                  ;	  'Set' operations are ignored.
  5160                                  ;	  'File system error messages' are not supported.
  5161                                  ; ----------------------------------------------------------------------------
  5162                                  
  5163                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5164                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
  5165                                  
  5166                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  5167                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1588h (CODERES:0738h)
  5168                                  
  5169                                  ;SR;
  5170                                  ;At the int 2fh entry point we push the old ds value and the resident data
  5171                                  ;segment address. Get them off the stack
  5172                                  
  5173                                  ;MsgInt2fHandler proc	far
  5174                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  5175                                  
  5176                                  	; 14/01/2023
  5177                                  MsgInt2fHandler:
  5178 000013D8 1F                      	pop	ds			; ds = DATARES
  5179                                  	;assume	ds:DATARES
  5180                                  ;	pop	word [OldDS]		; save old value of ds
  5181                                  
  5182 000013D9 3D2E12                  	cmp	ax,122Eh
  5183                                  	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
  5184                                  	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
  5185 000013DC 742A                    	je	short miOurs		; it's ours
  5186                                  
  5187                                  ;ifndef ROMDOS
  5188                                  	;cmp	ax,5500h
  5189 000013DE 3D0055                  	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
  5190                                  ;else
  5191                                  ;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
  5192                                  ;endif	;ROMDOS
  5193 000013E1 741C                    	je	short fcOurs
  5194                                  
  5195                                  ;SR;
  5196                                  ;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
  5197                                  ;onto the stack and do a far return to jump to the next 2fh handler. 
  5198                                  ;Our old ds is on the stack. We need to restore it but we cannot lose the
  5199                                  ;current value of ds as it points at the data segment. So we do some kinky
  5200                                  ;stack manipulations.
  5201                                  
  5202 000013E3 50                      	push	ax
  5203 000013E4 50                      	push	ax			; create 2 words on stack for retf
  5204                                  
  5205 000013E5 55                      	push	bp
  5206 000013E6 50                      	push	ax
  5207                                  
  5208 000013E7 89E5                    	mov	bp,sp			; bp can be used to address stack
  5209                                  
  5210                                  ;Swap the old ds value with the second dummy word on the stack. Now, we can
  5211                                  ;do a 'pop ds' at the end to restore our ds
  5212                                  
  5213 000013E9 8B4608                  	mov	ax,[bp+8]		; ax = old ds value
  5214 000013EC 894604                  	mov	[bp+4],ax
  5215                                  	
  5216                                  	;mov	ax,word ptr ds:Int2fHandler+2
  5217 000013EF A1[5204]                	mov	ax,[Int2fHandler+2]
  5218 000013F2 894608                  	mov	[bp+8],ax		; put segment address
  5219                                  	;mov	ax,word ptr ds:Int2fHandler
  5220 000013F5 A1[5004]                	mov	ax,[Int2fHandler]
  5221 000013F8 894606                  	mov	[bp+6],ax		; put offset address
  5222                                  
  5223 000013FB 58                      	pop	ax
  5224 000013FC 5D                      	pop	bp
  5225 000013FD 1F                      	pop	ds
  5226                                  
  5227 000013FE CB                      	retf				; chain on to next handler
  5228                                  
  5229                                  ;;	jmp	Int2fHandler		; hand off to next 2f handler
  5230                                  
  5231                                  fcOurs:
  5232                                  
  5233                                  ;We have to clear ax, and return in ds:si a pointer to the stub jump table
  5234                                  
  5235 000013FF 58                      	pop	ax			; discard ds currently on stack
  5236 00001400 1E                      	push	ds			; store our data segment
  5237                                  
  5238                                  	;mov	si,offset DATARES:Int2f_Entry ; start of table
  5239 00001401 BE[0400]                	mov	si,Int2f_Entry
  5240                                  
  5241 00001404 31C0                    	xor	ax,ax			; indicate COMMAND present
  5242 00001406 EB11                    	jmp	short miRet		; return to caller
  5243                                  
  5244                                  miOurs:
  5245 00001408 F6C201                  	test	dl,1
  5246 0000140B 750C                    	jnz	short miRet		; ignore 'set' operations
  5247                                  
  5248 0000140D 53                      	push	bx			; preserve BX
  5249 0000140E 89D3                    	mov	bx,dx
  5250 00001410 30FF                    	xor	bh,bh			; BX = index in word table
  5251 00001412 D1E3                    	shl	bx,1			; BX = index in dword table
  5252                                  	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
  5253 00001414 C4BF[1907]              	les	di,[bx+MsgPtrLists]
  5254 00001418 5B                      	pop	bx			; restore BX
  5255                                  miRet:
  5256                                  ;	mov	ds,[OldDS]		; restore ds
  5257 00001419 1F                      	pop	ds
  5258                                  	;assume	ds:nothing
  5259                                  
  5260 0000141A CF                      	iret
  5261                                  
  5262                                  ;MsgInt2fHandler endp
  5263                                  
  5264                                  	; MSDOS 6.0
  5265                                  ; ----------------------------------------------------------------------------
  5266                                  ;***	MsgRetriever - message retrieval routine for utilities
  5267                                  ;
  5268                                  ;	Address of this routine is passed to utility programs via 
  5269                                  ;	message services int 2f. We try to find the desired message
  5270                                  ;	in memory or in our disk image.
  5271                                  ;
  5272                                  ;	ENTRY	AX = message #
  5273                                  ;		DI = offset in RESGROUP of msg ptr list
  5274                                  ;		ComSpec = asciiz pathname to our disk image
  5275                                  ;
  5276                                  ;	EXIT	CY clear for success
  5277                                  ;		ES:DI = ptr to count byte, followed by message text
  5278                                  ;
  5279                                  ;		CY set for failure
  5280                                  ;		ES,DI undefined
  5281                                  ;
  5282                                  ;	USED	flags
  5283                                  ;
  5284                                  ;	NOTE
  5285                                  ;	  The message # in AX is used to compute an offset into
  5286                                  ;	  the message ptr list pointed to by DI. The lists must
  5287                                  ;	  start with message # 1 and proceed through consecutive
  5288                                  ;	  message #'s.  
  5289                                  ;
  5290                                  ;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
  5291                                  ;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
  5292                                  ;	  valid message #.  ;M033
  5293                                  ;
  5294                                  ;	  List positions with no corresponding message text are
  5295                                  ;	  indicated by null pointers, which this routine detects.
  5296                                  ; ----------------------------------------------------------------------------
  5297                                  
  5298                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5299                                  
  5300                                  ;SR; This routine will be called directly by the utilities. So, we have
  5301                                  ; trap for it in the stub. The stub pushes the old value of ds and the 
  5302                                  ; DATARES value on the stack. We get them off the stack to setup ds here
  5303                                  
  5304                                  ;MsgRetriever	proc	far
  5305                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  5306                                  
  5307                                  	; 14/01/2023
  5308                                  MsgRetriever:
  5309 0000141B 1F                      	pop	ds			; ds = DATARES
  5310                                  	;assume	ds:DATARES
  5311                                  ;	pop	word [OldDS]		; save old ds
  5312                                  
  5313 0000141C 50                      	push	ax			; preserve registers
  5314 0000141D 53                      	push	bx
  5315 0000141E 51                      	push	cx
  5316 0000141F 52                      	push	dx
  5317 00001420 56                      	push	si
  5318                                  
  5319                                  ;;	push	ds
  5320                                  ;;	push	cs
  5321                                  ;;	pop	ds			; DS = DATARES seg addr
  5322                                  ;;	assume	ds:RESGROUP
  5323                                  ;;	push	cs
  5324                                  
  5325 00001421 1E                      	push	ds			; get es from ds
  5326 00001422 07                      	pop	es			; ES = DATARES seg addr
  5327                                  
  5328                                  ;	Begin modification M033.
  5329                                  
  5330                                  ;	Make sure msg # is valid.
  5331                                  ;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.
  5332                                  
  5333                                  	;mov	bx,11
  5334 00001423 BB0B00                  	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
  5335                                  	;cmp	di,offset DATARES:ParsMsgPtrs
  5336 00001426 81FF[B809]              	cmp	di,PARSMSGPTRS
  5337 0000142A 7403                    	je	short chkmsgnum		; it's ParsMsgPtrs
  5338                                  	;mov	bx,90
  5339 0000142C BB5A00                  	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
  5340                                  chkmsgnum:
  5341 0000142F 39C3                    	cmp	bx,ax
  5342 00001431 725A                    	jc	short mrRet		; msg # too high, return carry
  5343                                  
  5344                                  ;	Msg # is valid.
  5345                                  
  5346                                  ;	End modification M033.
  5347                                  
  5348 00001433 48                      	dec	ax
  5349 00001434 D1E0                    	shl	ax,1			; AX = offset into msg ptr list
  5350 00001436 01C7                    	add	di,ax			; DI = ptr to msg ptr
  5351                                  
  5352 00001438 81FF[5404]              	cmp	di,ResMsgEnd
  5353 0000143C 7247                    	jb	short mrInMem		; ptr (and message) in memory
  5354                                  
  5355                                  ;*	Retrieve message from disk (or ROM) image.
  5356                                  ;	Read once to get the ptr to the message, then again for the message.
  5357                                  
  5358                                  ;ifndef	ROMDOS
  5359                                  	; 14/01/2023
  5360                                  	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
  5361 0000143E BE[E901]                	mov	si,ComSpec
  5362 00001441 BA0100                  	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
  5363 00001444 BB0020                  	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
  5364 00001447 B8006C                  	mov	ax,6C00h
  5365                                  	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
  5366 0000144A CD21                    	int	21h				; call DOS
  5367 0000144C 723F                    	jc	short mrRet			; return failure
  5368                                  
  5369 0000144E 89C3                    	mov	bx,ax				; BX = file handle
  5370 00001450 89FA                    	mov	dx,di				; DX = ptr to msg ptr
  5371 00001452 31F6                    	xor	si,si				; SI = read count
  5372                                  mrRead:
  5373 00001454 81EA0001                	sub	dx,100h				; DX = LSW of file offset
  5374 00001458 31C9                    	xor	cx,cx				; CX = MSW of file offset
  5375 0000145A B80042                  	mov	ax,4200h
  5376                                  	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
  5377 0000145D CD21                    	int	21h				; call DOS
  5378 0000145F 721A                    	jc	short mrCloseFile		; handle error
  5379                                  
  5380                                  	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
  5381 00001461 BA[0004]                	mov	dx,MsgBuffer
  5382 00001464 B94000                  	mov	cx,64				; CX = # bytes to read
  5383 00001467 B43F                    	mov	ah,3Fh
  5384                                  	;mov	ah,READ				; AH = 'Read File'
  5385 00001469 CD21                    	int	21h				; call DOS
  5386 0000146B 720E                    	jc	short mrCloseFile		; handle error
  5387                                  
  5388 0000146D 09F6                    	or	si,si				; (CY cleared)
  5389 0000146F 750A                    	jnz	short mrCloseFile		; 2nd time thru - we're done
  5390 00001471 46                      	inc	si				; mark one read done
  5391 00001472 8B16[0004]              	mov	dx,[MsgBuffer]			; DX = ptr to message
  5392 00001476 09D2                    	or	dx,dx
  5393 00001478 75DA                    	jnz	short mrRead			; go read the message
  5394 0000147A F9                      	stc					; null ptr found- no msg
  5395                                  
  5396                                  mrCloseFile:
  5397 0000147B 9C                      	pushf				; save success/failure (CY)
  5398 0000147C B43E                    	mov	ah,3Eh
  5399                                  	;mov	ah,CLOSE		; AH = 'Close File'
  5400 0000147E CD21                    	int	21h			; call DOS
  5401                                  ;	Bugbug: should we avoid this popf?
  5402 00001480 9D                      	popf				; CY = success/failure
  5403 00001481 89D7                    	mov	di,dx			; ES:DI = ptr to msg, if successful
  5404 00001483 EB08                    	jmp	short mrRet		; we're done
  5405                                  
  5406                                  ;else	;ROMDOS
  5407                                  ;
  5408                                  ;;	DI = ptr to msg ptr
  5409                                  ;
  5410                                  ;	mov	si,di			; SI = ptr to msg ptr
  5411                                  ;	sub	si,100h			; SI = offset into image of msg ptr
  5412                                  ;	mov	cx,2			; CX = # bytes to copy from image
  5413                                  ;
  5414                                  ;;	ASSUME ES:NOTHING is still in effect.
  5415                                  ;
  5416                                  ;	push	ds
  5417                                  ;	pop	es				; ES = DATARES seg addr
  5418                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
  5419                                  ;	invoke	LoadFromROM			; copy msg ptr from ROM
  5420                                  ;	mov	si,word ptr MsgBuffer		; SI = ptr to message
  5421                                  ;	or	si,si
  5422                                  ;	jz	mrNoMsg			; null ptr- no message text
  5423                                  ;
  5424                                  ;	sub	si,100h			; SI = offset into image of msg
  5425                                  ;	mov	cx,64			; CX = # bytes to copy from image
  5426                                  ;	mov	di,offset DATARES:MsgBuffer
  5427                                  ;	invoke	LoadFromROM
  5428                                  ;	clc					; success
  5429                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
  5430                                  ;	jmp	short mrRet
  5431                                  ;
  5432                                  ;mrNoMsg:
  5433                                  ;	stc
  5434                                  ;	jmp	short mrRet
  5435                                  ;
  5436                                  ;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
  5437                                  ;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
  5438                                  ;	assume	es:NOTHING
  5439                                  ;
  5440                                  ;endif	;ROMDOS
  5441                                  
  5442                                  ;*	Message ptr is in memory.
  5443                                  ;	If ptr is in memory, assume message is in memory (/msg).
  5444                                  
  5445                                  mrInMem:
  5446                                  	; 14/01/2023
  5447 00001485 268B3D                  	mov	di,[es:di]		; ES:DI = ptr to msg
  5448 00001488 09FF                    	or	di,di			; (CY cleared)
  5449 0000148A 7501                    	jnz	short mrRet		; found message
  5450 0000148C F9                      	stc				; null ptr found - no message
  5451                                  mrRet:	
  5452 0000148D 5E                      	pop	si			; restore all registers
  5453 0000148E 5A                      	pop	dx
  5454 0000148F 59                      	pop	cx
  5455 00001490 5B                      	pop	bx
  5456 00001491 58                      	pop	ax
  5457                                  
  5458                                  ;	mov	ds,[OldDS]		; restore ds
  5459 00001492 1F                      	pop	ds
  5460                                  	;assume	ds:nothing
  5461                                  
  5462 00001493 CB                      	retf	; 21/04/2023
  5463                                  
  5464                                  ;MsgRetriever endp
  5465                                  
  5466                                  ; M003; Start of changes for UMB support
  5467                                  
  5468                                  ; ----------------------------------------------------------------------------
  5469                                  ;***	Lh_OffUnlink -- Restore allocation strat and link state
  5470                                  ;
  5471                                  ;	ENTRY	al = Saved alloc strat and link state
  5472                                  ;			b0 = 1 if alloc strat to restore is HighFirst
  5473                                  ;			b1 = 1 if link state to restore is Linked
  5474                                  ;
  5475                                  ;	EXIT	None
  5476                                  ;
  5477                                  ;	USED	ax, bx, cx
  5478                                  ; ----------------------------------------------------------------------------
  5479                                  
  5480                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5481                                  
  5482                                  ;public	Lh_OffUnlink
  5483                                  Lh_OffUnlink:	; proc	far
  5484                                  	; 14/01/2023
  5485 00001494 88C5                    	mov	ch,al
  5486 00001496 88C1                    	mov	cl,al
  5487                                  	;;mov	ax,(ALLOCOPER shl 8) OR 0
  5488                                  	;mov	ax,(ALLOCOPER<<8)
  5489 00001498 B80058                  	mov	ax,5800h
  5490 0000149B CD21                    	int	21h
  5491 0000149D 89C3                    	mov	bx,ax
  5492 0000149F D0C9                    	ror	cl,1				; b7 = HighFirst bit
  5493 000014A1 80E180                  	and	cl,80h				; mask off b6-b0
  5494 000014A4 80E37F                  	and	bl,7fh				; mask off HighFirst bit
  5495 000014A7 08CB                    	or	bl,cl				; set HighFirst bit state
  5496                                  	;;mov	ax,(ALLOCOPER shl 8) OR 1
  5497                                  	;mov	ax,(ALLOCOPER<<8)|1
  5498 000014A9 B80158                  	mov	ax,5801h
  5499 000014AC CD21                    	int	21h				; set alloc strat
  5500                                  
  5501 000014AE 88EB                    	mov	bl,ch
  5502 000014B0 D0EB                    	shr	bl,1
  5503 000014B2 30FF                    	xor	bh,bh				; bx = linkstate
  5504                                  	;mov	ax,(ALLOCOPER shl 8) OR 3
  5505                                  	;mov	ax,(ALLOCOPER<<8)|3
  5506 000014B4 B80358                  	mov	ax,5803h
  5507 000014B7 CD21                    	int	21h				; set linkstate
  5508                                  
  5509 000014B9 CB                      	retf
  5510                                  
  5511                                  ;Lh_OffUnlink endp
  5512                                  
  5513                                  ; M003; End of changes for UMB support
  5514                                  
  5515                                  ;public	EndCode
  5516                                  ; 14/01/2023
  5517                                  ;EndCode: ; label byte
  5518                                  ; 06/06/2023
  5519                                  ; 16/04/2023
  5520                                  ; 14/08/2024
  5521                                  ;EndCode equ ($-StartCode)+100h
  5522                                  
  5523                                  ; 06/06/2023
  5524                                  ;EndCode equ $-StartCode
  5525                                  
  5526                                  ; 14/08/2024
  5527                                  EndCode:
  5528                                  ENDCODE equ ($-StartCode)+100h	
  5529                                  
  5530                                  ;CODERES ends
  5531                                  ;	end
  5532                                  
  5533                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5534                                  
  5535                                  	;times	(((EndCode+15)>>4)<<4)-EndCode db 0
  5536                                  	; 14/08/2024
  5537 000014BA 00<rep 6h>              	times	(((ENDCODE+15)>>4)<<4)-ENDCODE db 0
  5538                                  
  5539                                  ;align 16
  5540                                  
  5541                                  ;=============================================================================
  5542                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  5543                                  ;=============================================================================
  5544                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  5545                                  
  5546                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  5547                                  
  5548                                  ;TITLE   COMMAND Initialization
  5549                                  
  5550                                  ;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
  5551                                  ;ENVIRONSIZ2 EQU 092H
  5552                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  5553                                  
  5554                                  ; UINIT.ASM, MSDOS 6.0, 1991
  5555                                  ; 23/09/2018
  5556                                  ENVBIG	EQU 32768		;AN000; maximum environment size
  5557                                  ; 14/01/2023
  5558                                  ;ENVSML	EQU 160			;AN000; minimum environment size
  5559                                  
  5560                                  ; ----------------------------------------------------------------------------
  5561                                  
  5562                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5563                                  
  5564                                  ; 06/06/2023
  5565                                  ; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
  5566                                  ;ENVIRONSIZ equ 160
  5567                                  
  5568                                  ENVSML	equ 256	; minimum environment size
  5569                                  ;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
  5570                                  MAX_COMSPEC equ 146
  5571                                  ECOMSPEC equ 14
  5572                                  
  5573                                  ; 14/01/2023
  5574                                  TAB_CHAR equ 09h
  5575                                  SPACE_CHAR equ 20h	
  5576                                  
  5577                                  ; 06/06/2023
  5578                                  ; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
  5579                                  ENVIRONSIZ equ 180	; SIZE Environment 
  5580                                  
  5581                                  ;----------------------------------------------------
  5582                                  ; MSDOS 6.0 - ENVDATA.ASM - 1991
  5583                                  ;----------------------------------------------------
  5584                                  ;Environment Struc	; Default COMMAND environment
  5585                                  ;
  5586                                  ;Env_PathString  db	"path="
  5587                                  ;Env_PathSpec	 db	"c:\msdos"
  5588                                  ;                db	0
  5589                                  ;Env_PrmptString db	"prompt="
  5590                                  ;Env_PrmptSpec   db	"$p$g"
  5591                                  ;                db	0
  5592                                  ;Env_ComString   db	"comspec="
  5593                                  ;Env_ComSpec     db	"\command.com"
  5594                                  ;		 db	134 dup (0)
  5595                                  ;
  5596                                  ;Environment ends
  5597                                  ;----------------------------------------------------
  5598                                  
  5599                                  ;-----------------------------------------------------------------------------
  5600                                  
  5601                                  ;-----------------------------------------------------------------------------
  5602                                  ; START OF INIT PORTION
  5603                                  ; This code is deallocated after initialization.
  5604                                  ;-----------------------------------------------------------------------------
  5605                                  
  5606                                  ;INIT	SEGMENT PUBLIC PARA
  5607                                  
  5608                                  ; 	EXTRN   HEADER:BYTE
  5609                                  ;	EXTRN   BADCOMLKMES:BYTE
  5610                                  
  5611                                  ;	PUBLIC  CONPROC
  5612                                  
  5613                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  5614                                  
  5615                                          ;ORG 0
  5616                                  ;ZERO = $
  5617                                  	; 23/09/2018
  5618                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  5619                                  
  5620                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5621                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
  5622                                  
  5623                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  5624                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1670h (CODERES:0820h)
  5625                                  ConProc:
  5626                                  	;mov	sp,offset ResGroup:RStack	; must be first instruction
  5627 000014C0 BC[D404]                	mov	sp,RStack
  5628                                  
  5629                                  ; We need to set the PSP to us right at start because Carousel needs
  5630                                  ; to be lied to and it does not set PSP when it transfers control to
  5631                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  5632                                  ; command.com is also not lied to.
  5633                                  
  5634                                  	; 14/01/2023
  5635                                  	; MSDOS 6.0
  5636 000014C3 B450                            mov	ah,50h
  5637                                  	;mov	ah,SET_CURRENT_PDB
  5638 000014C5 8CC3                            mov	bx,es
  5639 000014C7 CD21                            int	21h
  5640                                  
  5641                                  	; 14/01/2023
  5642                                  	;mov	ah,30h 
  5643                                  	;;mov	ax,GET_VERSION<<8 ; 3000h
  5644                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5645 000014C9 B80030                  	mov	ax,3000h
  5646 000014CC CD21                    	int	21h
  5647                                  	;;;cmp	ax,EXPECTED_VERSION ; 1E03h
  5648                                  	;;cmp	ax,5
  5649                                  	;cmp	ax,EXPECTED_VERSION ; 0005h
  5650                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5651 000014CE 3D0616                  	cmp	ax,EXPECTED_VERSION ; 1606h
  5652 000014D1 7411                    	je	short okdos			; DOS version is ok
  5653                                  
  5654 000014D3 BA[881F]                	mov	dx,BADVERMSG			; DX = ptr to msg
  5655 000014D6 E85DFE                  	call	RPrint
  5656                                  
  5657                                  	; MSDOS 3.3
  5658                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  5659                                  	;int	21h             ; DOS - PRINT STRING
  5660                                  				; DS:DX -> string terminated by "$"
  5661 000014D9 8CC0                    	mov	ax,es
  5662 000014DB 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  5663                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  5664                                  Here:	
  5665 000014E0 74FE                    	jz	short Here			;  loop forever
  5666                                  	
  5667 000014E2 CD20                    	int	20h				; otherwise, exit
  5668                                  okdos:
  5669                                  	; 23/09/2018
  5670                                  
  5671                                  ;  Calculate and save the end of the INIT segment (which is also
  5672                                  ;  the beginning of TRANGROUP).
  5673                                  
  5674                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5675                                  	; MSDOS 3.3
  5676                                  	;mov	ah,65h
  5677                                  	;mov	al,2
  5678                                  	;mov	dx,-1
  5679                                  	;mov	bx,-1
  5680                                  	;mov	cx,5
  5681                                  	;mov	di,UCASE_ADDR
  5682                                  	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  5683                                  	;		; AL = 02h : Get pointer to character translation table
  5684                                  	;		; BX = code page (-1 = current global code page)
  5685                                  	;		; DX = country ID (-1 = current country)
  5686                                  	;		; CX = amount of data to return
  5687                                  	;; ES:DI = pointer to output buffer
  5688                                  	;; Buffer offset :
  5689                                  	;;	00h -  byte,  country Id
  5690                                  	;;  	01h -  dword, pointer to uppercase table	
  5691                                  
  5692                                  	; 14/01/2023
  5693                                  	; MSDOS 6.0 (& MSDOS 3.3)
  5694                                    	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
  5695                                  	; 06/06/2023
  5696                                  	;mov	dx,26EFh     ; MSDOS 6.22 COMMAND.COM       	
  5697 000014E4 BA5F25                  	mov	dx,TRANSTART+15			; get end of init code
  5698                                  	; 27/09/2018
  5699                                  	;mov	dx,TRANSTART ; (paragraph aligned address)
  5700 000014E7 B104                    	mov	cl,4				; change to paragraphs
  5701 000014E9 D3EA                            shr	dx,cl				;
  5702 000014EB 8CC8                            mov     ax,cs                           ; get current segment
  5703 000014ED 01D0                            add     ax,dx                           ; calculate segment of end of init
  5704 000014EF A3[D01E]                        mov     [initend],ax			; save this
  5705                                  
  5706                                  	; 14/01/2023
  5707                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 
  5708                                  
  5709                                  ;  Check for /? on the command line. If found, display help text and exit.
  5710                                  ;  NOTE: this routine may terminate the program, never returning.
  5711                                  
  5712 000014F2 E8B006                  	call	CheckHelp
  5713                                  
  5714                                  ; We have to patch the segment values for the various interrupt entry points.
  5715                                  ; This is because we need to have the default addresses of the handlers in our
  5716                                  ; stub before the relocation is done. These values will then be changed once
  5717                                  ; the resident is relocated
  5718                                  
  5719 000014F5 E81A09                  	call	patch_segs
  5720                                  
  5721                                  ;  Turn APPEND off during initialization processing
  5722                                  
  5723                                  	; 14/01/2023
  5724 000014F8 B800B7                  	mov     ax,0B700h
  5725                                  	;mov	ax,APPENDINSTALL                ; see if append installed
  5726 000014FB CD2F                    	int	2Fh				;
  5727                                  	;cmp	al,0				; append installed?
  5728 000014FD 08C0                    	or	al,al
  5729 000014FF 7418                    	jz	short set_msg_addr		; no - continue
  5730                                  	
  5731 00001501 B802B7                  	mov	ax,0B702h
  5732                                  	;mov	ax,APPENDDOS			; see if append DOS version right
  5733 00001504 CD2F                    	int	2Fh				;
  5734                                  	;cmp	ax,-1				; append version correct?
  5735                                  	;jne	short set_msg_addr		; no - continue
  5736 00001506 40                      	inc	ax ; -1 -> 0
  5737 00001507 7510                    	jnz	short set_msg_addr        
  5738                                  	
  5739 00001509 B806B7                  	mov     ax,0B706h
  5740                                  	;mov	ax,APPENDGETSTATE               ; Get the state of Append
  5741 0000150C CD2F                    	int	2Fh				;
  5742 0000150E 891E[6002]                      mov     [Append_State],bx		; save append state
  5743                                         
  5744 00001512 31DB                    	xor	bx,bx                           ; clear out state
  5745 00001514 B807B7                  	mov	ax,0B707h
  5746                                  	;mov	ax,APPENDSETSTATE               ; Set the state of Append
  5747 00001517 CD2F                    	int	2Fh				; set everything off
  5748                                  
  5749                                  set_msg_addr:
  5750                                  	; 14/01/2023
  5751                                  	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
  5752                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
  5753                                  	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
  5754                                  	; 06/06/2023
  5755                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:16CBh) 
  5756                                  	;mov	di,0A41h  ; mov di,PAERRMSG0 ; MSDOS 6.22 COMMAND.COM
  5757 00001519 BF[DA08]                	mov	di,DataresEnd
  5758 0000151C 893E[5404]              	mov	[ResMsgEnd],di			; save it
  5759                                  
  5760 00001520 E80109                          call    get_XMMAddr                     ; get XMM call address
  5761                                  
  5762                                  ; Check if this is the first instance of command.com. If not, we just exit
  5763                                  ; this routine without moving any code.
  5764                                  ; After the int 2fh, ds:si points at the resident jump table in the previous
  5765                                  ; stub. We just have to copy this over
  5766                                  	
  5767                                  ;ifndef ROMDOS
  5768 00001523 B80055                  	mov	ax,5500h
  5769                                  	;mov	ax,GET_COMMAND_STATE	
  5770                                  ;else
  5771                                  ;	mov	ax,GET_ROMCOMMAND_STATE	
  5772                                  ;endif ; ROMDOS
  5773                                  
  5774 00001526 CD2F                    	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
  5775                                  	;assume	ds:nothing
  5776                                  
  5777                                  	; 03/05/2023
  5778                                  	; Return:
  5779                                  	;   AX = 0000h if an instance of COMMAND.COM is already running
  5780                                  	;   DS:SI -> entry point table
  5781                                  
  5782                                  	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))
  5783                                  
  5784 00001528 09C0                    	or	ax,ax
  5785 0000152A 750C                    	jnz	short first_com			; this is the first instance
  5786                                  
  5787                                  	; 14/01/2023
  5788 0000152C 268936[0C24]            	mov	[es:ResJmpTable],si		; save old stub jump table
  5789 00001531 268C1E[0E24]            	mov	[es:ResJmpTable+2],ds
  5790 00001536 EB06                    	jmp	short init_cntry
  5791                                  
  5792                                  first_com:
  5793 00001538 26C606[1024]01          	mov	byte [es:FirstCom],1		; indicate first command.com
  5794                                  
  5795                                  init_cntry:
  5796                                  	; 14/01/2023
  5797 0000153E 06                      	push	es
  5798 0000153F 1F                      	pop	ds
  5799                                  	;assume	ds:RESGROUP
  5800                                  
  5801 00001540 B465                    	mov	ah,65h
  5802                                  	;mov	ah,GETEXTCNTRY			; get extended country info
  5803 00001542 B004                    	mov	al,4				; get file ucase table
  5804 00001544 BAFFFF                  	mov	dx,-1				;
  5805                                  	;mov	bx,-1				;
  5806 00001547 89D3                    	mov	bx,dx
  5807 00001549 B90500                  	mov	cx,5				; number of bytes we want
  5808                                  	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
  5809 0000154C BF[5302]                	mov	di,FUCase_Addr
  5810 0000154F CD21                    	int	21h
  5811                                  		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  5812                                  		; AL = function -
  5813                                  
  5814                                  ;	Bugbug:	conditionalize dbcs_vector stuff?
  5815                                  
  5816 00001551 1E                      	push	ds				;
  5817 00001552 B80063                  	mov	ax,6300h
  5818                                  	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
  5819 00001555 CD21                    	int	21h				;
  5820                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  5821                                  			
  5822 00001557 8CDB                    	mov	bx,ds				; get segment to bx
  5823 00001559 1F                      	pop	ds				;
  5824 0000155A 8936[5C02]              	mov	[Dbcs_Vector_Addr],si		; save address of
  5825 0000155E 891E[5E02]              	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector
  5826                                  
  5827                                  	;mov	ax,[16h]
  5828 00001562 A11600                  	mov	ax,[PDB.PARENT_PID]
  5829                                  				; mov ax,ds:16h	; Init PARENT so we can exit
  5830 00001565 A3[DC01]                	mov	[Parent],ax			;  correctly.
  5831 00001568 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  5832 0000156B A3[DE01]                	mov	[OldTerm],ax
  5833 0000156E A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  5834 00001571 A3[E001]                	mov	[OldTerm+2],ax
  5835                                  
  5836                                  	; 14/01/2023
  5837                                  	;;;mov	ax,offset ResGroup:EndCode + 15
  5838                                  	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
  5839                                  	; 06/06/2023
  5840                                  	;mov	ax,1679h	; MSDOS 6.22 COMMAND.COM
  5841                                  	;mov	ax,EndCode+15
  5842                                  	;;mov	ax,INITSTART+15 ; 24/09/2018
  5843                                  	; 14/01/2023
  5844                                  	;mov	cl,4				; ax = size of resident part of
  5845                                  	;shr	ax,cl				;  command in paragraphs. Add
  5846                                  	;mov	cx,cs				;  this to CS and you get the
  5847                                  	;add	ax,cx				;  segment of the TPA.
  5848                                  
  5849 00001574 8CC8                    	mov	ax,cs
  5850                                  	; 14/08/2024
  5851                                  	EndCodeParag equ (ENDCODE+15)>>4
  5852                                  	;add	ax,(EndCode+15)>>4
  5853 00001576 055C01                  	add	ax,EndCodeParag
  5854                                  	
  5855 00001579 A3[FA03]                	mov	[Res_Tpa],ax			; Temporarily save the TPA segment
  5856 0000157C 2500F0                  	and	ax,0F000h
  5857 0000157F 050010                  	add	ax,1000h			; Round up to next 64K boundary
  5858 00001582 7303                    	jnc	short TpaSet			; Memory wrap if carry set
  5859 00001584 A1[FA03]                	mov	ax,[Res_Tpa]
  5860                                  TpaSet:
  5861 00001587 A3[EE03]                	mov	[LTpa],ax			; Good enough for the moment
  5862                                  	;mov	ax,[2]
  5863 0000158A A10200                  	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command
  5864                                  
  5865 0000158D 8C1E[F403]              	mov	[MySeg1],ds			; These 3 variables are used as part of
  5866 00001591 8C1E[F803]              	mov	[MySeg2],ds			;  3 long ptrs that the transient will
  5867 00001595 8C1E[EC03]              	mov	[MySeg],ds			;  use to call resident routines.
  5868                                  	; 19/04/2023
  5869                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
  5870 00001599 8C1E[2B07]              	mov	[MySeg3],ds			; segment of msg retriever routine 
  5871                                  
  5872 0000159D A3[3302]                	mov	[MemSiz],ax			; Needed for execing other programs
  5873                                  
  5874                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5875                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h
  5876                                  
  5877                                  ; First reallocate the COMMAND size to its memory image
  5878                                  	
  5879 000015A0 50                      	push	ax    
  5880                                    	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
  5881                                  	;;mov	bx,offset RESGROUP:TranStart    ;
  5882                                  	;mov	bx,TRANSTART
  5883                                  	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
  5884                                          ;add	bx,offset TRANGROUP:TranSpaceEnd;
  5885                                  	;add	bx,15 ; *			; round up the size
  5886                                  	; 06/06/2023
  5887                                  	;mov	bx,26E0h  ; MSDOS 6.22 COMMAND.COM ; mov bx,offset RESGROUP:TranStart
  5888                                  	;add	bx,0AF95h ; MSDOS 6.22 COMMAND.COM ; add bx,offset TRANGROUP:TranSpaceEnd
  5889                                  	;add	bx,15 ; *			; round up the size
  5890                                  
  5891                                  	; 03/05/2023
  5892                                  	;mov	bx,TRANSTART+15 ; * ; 14/01/2023
  5893                                  	;add	bx,TRANSPACEEND
  5894                                  	; 06/06/2023
  5895                                  	;mov	bx,TRANSTART+TRANSPACEEND+15 
  5896                                          ;mov	cl,4				;
  5897                                          ;shr	bx,cl				; size of command.com
  5898 000015A1 BBF60C                  	mov	bx,(TRANSTART+TRANSPACEEND+15)>>4	
  5899                                  
  5900 000015A4 B44A                    	mov	ah,4Ah
  5901                                  	;mov	ah,SETBLOCK			; free all memory above pgm
  5902 000015A6 CD21                            int     21h				;
  5903 000015A8 58                              pop     ax				;
  5904                                  	
  5905                                  ; Compute maximum size of environment
  5906                                  
  5907                                  	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  5908                                          ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  5909                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5910                                  	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
  5911                                  	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
  5912 000015A9 C706[C41E]5300          	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
  5913                                  					; 12+(((1B53h-1670h)+15)/16)-1 = 90	
  5914                                  ;
  5915                                  ; Compute minimum size of environment
  5916                                  ;
  5917                                  	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
  5918                                  	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
  5919 000015AF C706[C21E]1000          	mov	word [EnvSiz],ENVSML/16 ; 256/16
  5920                                  
  5921                                  	;;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  5922                                  	;;mov	dx,98D4h	; MSDOS 5.0 COMMAND.COM
  5923                                  	; 06/06/2023
  5924                                  	;;mov	dx,0AFA4h	; MSDOS 6.22 COMMAND.COM
  5925                                  	;mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  5926                                  	;mov	cl,4				;  in paragraphs.
  5927                                  	;shr	dx,cl
  5928 000015B5 BAA10A                  	mov	dx,(TRANSPACEEND+15)>>4
  5929                                  
  5930 000015B8 8916[D21E]                      mov     [TrnSize],dx			; save size of transient in paragraphs
  5931                                  
  5932 000015BC 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  5933 000015BE A3[2D02]                	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
  5934                                  	;mov	ax,[2Ch]
  5935 000015C1 A12C00                  	mov	ax,[PDB.ENVIRON]		; ax = environment segment
  5936                                  
  5937                                  	; 14/01/2023
  5938                                          ; MSDOS 6.0
  5939                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5940 000015C4 A3[DC03]                	mov	[EnvirSeg],ax
  5941                                          
  5942                                  	; 21/01/2023
  5943 000015C7 09C0                    	or	ax,ax				; if there is no environment segment,
  5944 000015C9 7407                    	jz	short buildenv			; make one
  5945                                    
  5946                                  	; 21/01/2023
  5947                                  	; MSDOS 3.3 & MSDOS 5.0
  5948                                  	;;inc	byte [CHUCKENV]
  5949                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5950                                  	;inc	byte [AllocedEnv]		; Flag - old environment segment
  5951                                  	
  5952                                  	; MSDOS 3.3 & MSDOS 5.0
  5953                                  	; 06/06/2023
  5954                                  	;jmp	short environpassed
  5955                                  	
  5956                                  	; MSDOS 6.0
  5957                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM	
  5958 000015CB 803E[1024]00            	cmp	byte [FirstCom],0		; if this is the first command.com,
  5959 000015D0 7403                    	je	short environpassed		; do a merge job (make sure COMSPEC exists)
  5960                                  
  5961                                  	; MSDOS 6.0
  5962                                  
  5963                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  5964                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  5965                                  ; size and free this buffer. We need this buffer because we no longer have an
  5966                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  5967                                  ; given on the command line before we know the environment size. This routine
  5968                                  ; will not return in case of an allocation error. It will either exit or hang
  5969                                  ; depending on whether or not this is the first COMMAND.COM or not.
  5970                                  
  5971                                  	; 14/01/2023
  5972                                  buildenv:
  5973 000015D2 E8BC06                  	call	alloc_env                       ; try to allocate buffer
  5974                                  environpassed:
  5975                                  	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
  5976                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5977                                  	;mov	[EnvirSeg],ax
  5978                                  	;
  5979 000015D5 8EC0                    	mov	es,ax                           ; and it load into es.
  5980                                  	;assume	es:nothing
  5981                                  
  5982                                  gottheenvir:
  5983                                  
  5984                                  ; Initialize the command drive
  5985                                  
  5986                                  	; 14/01/2023
  5987                                  	; MSDOS 3.3 & MSDOS 6.0
  5988 000015D7 B419                    	mov	ah,19h
  5989                                  	;mov	ah,GET_DEFAULT_DRIVE	; 19h
  5990 000015D9 CD21                    	int	21h
  5991 000015DB FEC0                    	inc	al
  5992 000015DD A2[3202]                	mov	[ComDrv],al
  5993                                  
  5994                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  5995 000015E0 A05C00                          mov	al,[FCB]
  5996 000015E3 08C0                    	or	al,al
  5997 000015E5 7433                    	jz	short nocomdrv		; no drive specified
  5998                                  
  5999 000015E7 B43A                    	mov	ah,':'
  6000 000015E9 A2[3202]                	mov	[ComDrv],al
  6001 000015EC 0440                    	add	al,40h			; convert number to uppercase character
  6002                                  
  6003 000015EE FD                      	std
  6004                                  
  6005                                  	; MSDOS 6.0
  6006                                  	; 06/06/2023
  6007                                  	; MSDOS 6.22 - COMMAND.COM - RESGROUP:17B7h
  6008 000015EF 803E[881E]00            	cmp	byte [AllocedEnv],0	; if a new environment is being built,
  6009 000015F4 7420                    	je	short notwidenv		;  move the default comspec string in it
  6010                                  	; 14/01/2023
  6011                                  	; MSDOS 5.0 COMMAND.COM
  6012 000015F6 8B3E[AB1E]              	mov	di,[ComspOffset]
  6013 000015FA 26807D013A                      cmp	byte [es:di+1],':'	; drive specifier already exist?
  6014 000015FF 7415                            je	short notwidenv		; yes, must have been inherited that way
  6015                                  
  6016                                  	; 06/06/2023
  6017                                  	; MSDOS 3.3
  6018                                  	;;cmp	byte [CHUCKENV],0
  6019                                  	;;jne	short NOTWIDENV
  6020                                  	; 21/01/2021
  6021                                  	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
  6022                                   	;cmp	byte [AllocedEnv],0
  6023                                  	;ja	short notwidenv
  6024                                  
  6025 00001601 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  6026 00001602 06                      	push	es			;  the drivespec is in ax and is copied
  6027 00001603 1F                      	pop	ds			;  on to the front of the string.
  6028                                  
  6029                                  ; 06/06/2023
  6030                                  %if 0
  6031                                  	; 21/01/2023
  6032                                  	; 14/01/2023
  6033                                  	; MSDOS 5.0 COMMAND.COM
  6034                                  	; MSDOS 3.3
  6035                                  	; 23/09/2018
  6036                                  	; 30/04/2018
  6037                                  	;mov	di,159
  6038                                  	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  6039                                  	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  6040                                  	mov	di,ENVIRONSIZ-1 ; 21/01/2023
  6041                                  	;mov	si,157
  6042                                  	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  6043                                          ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  6044                                  	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
  6045                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  6046                                  	mov	cx,MAX_COMSPEC-2 ; 144
  6047                                  %endif
  6048                                  
  6049                                  	; MSDOS 6.0
  6050                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM - RESGROUP:17CCh
  6051 00001604 8DB58F00                        lea	si,[di+MAX_COMSPEC-3]	; lea si,[di+143]
  6052 00001608 8DBD9100                        lea	di,[di+MAX_COMSPEC-1]	; lea di,[di+145]
  6053                                  
  6054 0000160C B99000                          mov	cx,MAX_COMSPEC-2 ; 144
  6055                                  
  6056 0000160F F3A4                    	rep	movsb
  6057 00001611 1F                      	pop	ds
  6058                                  
  6059                                  	; MSDOS 6.0
  6060                                  	; 06/06/2023
  6061 00001612 268945FF                	mov	[es:di-1],ax
  6062                                  
  6063                                  	; MSDOS 3.3
  6064                                  	;mov	[es:0Eh],ax
  6065                                  	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  6066                                  	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  6067                                  	; 14/01/2023
  6068                                  	; 06/06/2023
  6069                                  	;mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax
  6070                                  
  6071                                  	; MSDOS 3.3 & MSDOS 6.0
  6072                                  notwidenv:
  6073 00001616 FC                      	cld
  6074 00001617 A3[6A1E]                	mov	[AUTOBAT],ax ; db 0,":\AUTOEXEC.BAT"
  6075                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6076                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
  6077                                  	
  6078                                  	; 22/07/2024
  6079                                  	; 06/06/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6080                                  	;mov	[KAUTOBAT],ax ; db 0,":\AUTOEXEC.BAT"
  6081                                  
  6082                                  nocomdrv:
  6083 0000161A E896FA                  	call	SetVect        ; Set the vectors
  6084                                  
  6085                                  ; parsing starts here
  6086                                  
  6087                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6088                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16C9h - CODERES:0989h)
  6089                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6090                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:17E8h - CODERES:0998h)
  6091                                  	; MSDOS 6.0
  6092 0000161D 0E                      	push	cs
  6093 0000161E 0E                      	push	cs
  6094 0000161F 1F                      	pop	ds
  6095 00001620 07                      	pop	es
  6096                                  	;assume ds:ResGroup,es:ResGroup
  6097                                  
  6098 00001621 BE8000                  	mov	si,80h				; get command line
  6099 00001624 AC                      	lodsb					; get length of line
  6100 00001625 89F7                    	mov	di,si				; get line position in di
  6101 00001627 30E4                    	xor	ah,ah				; ax = length of command line
  6102                                  
  6103                                  ; insure that the command line correctly ends with a cr
  6104                                  
  6105 00001629 01C7                    	add	di,ax				; go to end of command line
  6106 0000162B C6050D                          mov	byte [di],0Dh			; insert a carriage return
  6107 0000162E 31C9                    	xor	cx,cx				; clear cx
  6108 00001630 890E[841F]                      mov	[num_positionals],cx		; initialize positionals
  6109                                  
  6110                                  ; Scan the command line looking for the parameters
  6111                                  
  6112                                  Parse_command_line:
  6113                                  	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
  6114 00001634 BF[DA1E]                	mov	di,PARSE_COMMAND
  6115 00001637 8B0E[841F]              	mov	cx,[num_positionals]		; Get number of positionals
  6116 0000163B 31D2                    	xor	dx,dx				; clear dx
  6117 0000163D 8936[861F]                      mov	[old_parse_ptr],si		; save position before calling parser
  6118                                  	;call	dword ptr Init_Parse
  6119 00001641 FF1E[CE1E]              	call	far [Init_Parse]		; call parser
  6120 00001645 890E[841F]                      mov     [num_positionals],cx		; Save number of positionals
  6121                                  	; 29/01/2023
  6122                                  	;;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
  6123                                          ;cmp	ax,-1
  6124                                  	;jne	short t1
  6125                                  	; 10/06/2023
  6126 00001649 40                      	inc	ax	 ; cmp ax,-1
  6127 0000164A 7503                    	jnz	short t1 ; 0FFFFh -> 0
  6128                                  	; ax = 0
  6129 0000164C E93202                  	jmp     ArgsDone                        ; yes - exit
  6130                                  t1:	
  6131                                  	;;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
  6132                                  	;;cmp	ax,0
  6133                                  	;and	ax,ax
  6134                                  	; 10/06/2023
  6135 0000164F 48                      	dec	ax  ; cmp ax,0
  6136 00001650 7450                    	jz	short parse_cont  ; 1 -> 0	; no - continue
  6137                                  
  6138                                  ; Before issuing error message - make sure switch is not /C
  6139                                  
  6140                                  parse_line_error:
  6141                                  	; 14/01/2023
  6142                                  	;push	si				; save line position
  6143                                  	;push	ax				; save error number
  6144                                  	;cmp	ax,3
  6145 00001652 83F803                  	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
  6146                                          ;jnz	short parse_line_error_disp	; No - just issue message
  6147 00001655 7533                    	jne	short parse_line_error_disp2
  6148 00001657 56                      	push	si ; **				; save line position
  6149 00001658 50                      	push	ax ; *				; save error number
  6150 00001659 89F7                    	mov	di,si				; Get terminating pointer in DI
  6151 0000165B 8B36[861F]                      mov     si,[old_parse_ptr]		; Get starting pointer in SI
  6152                                  
  6153                                  init_chk_delim:
  6154 0000165F 39FE                    	cmp	si,di				; at end of parsed parameter?
  6155 00001661 7425                            je	short parse_line_error_disp	; Yes - just display message
  6156 00001663 AC                      	lodsb					;
  6157 00001664 3C20                    	cmp	al,20h ; ' ' ; 16/04/2023
  6158                                  	;cmp	al,space_chr ; 14/01/2023
  6159                                  	;;cmp	al,[space]			; Skip blank spaces
  6160 00001666 74F7                    	je	short init_chk_delim		;
  6161                                  	;cmp	al,9
  6162 00001668 3C09                    	cmp	al,tab_chr ; 9			; Skip tab characters
  6163 0000166A 74F3                    	je	short init_chk_delim		;
  6164                                  
  6165 0000166C 3A06[F003]              	cmp	al,[RSwitChar]	; '/'		; Switch?
  6166 00001670 7516                            jne	short parse_line_error_disp	; No - just issue message
  6167 00001672 AC                      	lodsb					; Get the char after the switch
  6168                                  
  6169 00001673 E8A004                  	call	iupconv 			; upper case it
  6170                                  
  6171                                  	;cmp	al,[scswitch]	; 'C'		; it is /C?
  6172                                          ;jne	short check_k_too ; MSDOS 6.0	;
  6173                                  	; 16/04/2023
  6174 00001676 3C43                    	cmp	al,'C' ; scswitch
  6175                                  	;jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
  6176                                  	; 06/06/2023
  6177                                  	; MSDOS 6.22 COMMAND.COM
  6178 00001678 7505                    	jne	short check_k_too
  6179 0000167A 5A                      	pop	dx ; *				; even up stack
  6180 0000167B 5A                      	pop	dx ; **				; even up stack
  6181 0000167C E9B100                  	jmp	SetSSwitch			; Yes - go set COMMAND /C
  6182                                  
  6183                                  	; MSDOS 6.0
  6184                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  6185                                  check_k_too:
  6186                                  	;cmp	al,[skswitch]	; 'K'		; it is /K?
  6187                                          ;jne	short parse_line_error_disp	;
  6188                                  	; 06/06/2023
  6189 0000167F 3C4B                    	cmp	al,'K'
  6190 00001681 7505                    	jne	short parse_line_error_disp
  6191 00001683 5A                      	pop	dx ; *				; even up stack
  6192 00001684 5A                      	pop	dx ; **				; even up stack
  6193 00001685 E9A100                          jmp	SetKSwitch			; Yes - go set COMMAND /K
  6194                                  
  6195                                  parse_line_error_disp:
  6196                                  	; 14/01/2023
  6197 00001688 58                      	pop	ax ; *				; restore error number
  6198 00001689 5E                      	pop	si ; **				; restore line position
  6199                                  parse_line_error_disp2:
  6200 0000168A 89C2                    	mov	dx,ax				; get message number
  6201 0000168C E82B04                  	call	RPrintParse
  6202 0000168F E8A1FC                  	call	crlf
  6203 00001692 EBA0                            jmp     short Parse_command_line        ; continue parsing
  6204                                  
  6205                                  ; 16/04/2023
  6206                                  %if 1
  6207                                  SetMSwitch:
  6208                                          ;cmp	byte [ext_msg],1
  6209 00001694 803E[D51E]01            	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6210                                  	; 16/04/2023
  6211                                  	;jnz	short setMswitchok		; no - set it
  6212                                  	;;mov	ax,1
  6213                                  	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6214                                  	;jmp	parse_line_error                ; go issue error message
  6215                                  	; 16/04/2023
  6216 00001699 7458                    	je	short parse_line_error_j
  6217                                  setMswitchok:
  6218                                          ;mov	byte [ext_msg],1
  6219 0000169B C606[D51E]01            	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6220                                  	; 06/06/2023
  6221 000016A0 EB92                    	jmp	short Parse_command_line	; keep parsing
  6222                                  %endif
  6223                                  
  6224                                  parse_cont:
  6225                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6226                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
  6227                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6228                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:1869h - CODERES:0A19h)
  6229                                  
  6230                                  	; MSDOS 6.0
  6231                                  
  6232                                  ; See if a switch was entered
  6233                                  ;
  6234                                  ; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare
  6235                                  
  6236 000016A2 813E[7D1F][151F]        	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
  6237 000016A8 7433                    	je	short SetFSwitch		; yes go set fail switch
  6238 000016AA 813E[7D1F][091F]        	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
  6239 000016B0 743A                    	je	short SetPSwitch		; yes go set up PERMCOM
  6240 000016B2 813E[7D1F][211F]        	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
  6241 000016B8 745C                    	je	short SetDSwitch		; yes go set date switch
  6242 000016BA 813E[7D1F][461F]        	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
  6243 000016C0 746E                    	je	short SetSSwitch		; yes go set up SINGLECOM
  6244                                  	; 06/06/2023
  6245                                  	; MSDOS 6.0 only!
  6246 000016C2 813E[7D1F][6C1F]        	cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
  6247 000016C8 745F                            je	short SetKSwitch		; yes go set up SINGLECOM
  6248                                  	;
  6249 000016CA 813E[7D1F][2D1F]        	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
  6250 000016D0 746F                    	je	short SetESwitch		; yes go set up environment
  6251 000016D2 813E[7D1F][521F]        	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
  6252                                  	;je	short SetMSwitchjmp		; yes go set up message flag
  6253                                  	; 15/01/2023
  6254 000016D8 74BA                    	je	short SetMSwitch 
  6255 000016DA E98200                  	jmp	ChkOtherArgs		; Must be something else
  6256                                  
  6257                                  	; MSDOS 6.0
  6258                                  ;SetMSwitchjmp:
  6259                                  	;jmp	SetMSwitch
  6260                                  	
  6261                                  	; MSDOS 6.0
  6262                                  SetFSwitch:
  6263 000016DD 803E[4702]FF            	cmp	byte [fFail],-1		; has fail switch been set?
  6264                                  	; 16/04/2023
  6265                                  	;jne	short failok		; no - set it
  6266                                  	;;mov	ax,1
  6267                                  	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
  6268                                          ;jmp	parse_line_error        ; go issue error 
  6269                                  	; 16/04/2023
  6270 000016E2 740F                    	je	short parse_line_error_j
  6271                                  
  6272                                  	; MSDOS 3.3 & MSDOS 6.0
  6273                                  failok:
  6274 000016E4 C606[4702]FF            	mov	byte [fFail],-1		; fail all INT 24s.
  6275                                  	; MSDOS 3.3
  6276                                  	;jmp	short CHKARG
  6277                                  	; MSDOS 6.0
  6278 000016E9 E948FF                  	jmp	Parse_command_line
  6279                                  
  6280                                  ;CHECKPSWITCH:
  6281                                  	;;cmp	al,'p'			; Permanent COMMAND switch
  6282                                  	;cmp	al,[letter_p]
  6283                                          ;jnz	short CHECKDSWITCH
  6284                                  
  6285                                  SetPSwitch:
  6286                                  
  6287                                  ; We have a permanent COMMAND switch /P. Flag this and stash the
  6288                                  ; termination address.
  6289                                  
  6290                                  	; MSDOS 6.0
  6291 000016EC 803E[4002]00            	cmp	byte [PermCom],0	; has /p switch been set?
  6292 000016F1 7406                    	jz	short permcomok		; no - set it
  6293                                  	; 16/04/2023
  6294                                  parse_line_error_j:
  6295                                          ;mov	ax,1
  6296 000016F3 B80100                  	mov	ax,MoreArgs_Ptr		; set up too many arguments
  6297 000016F6 E959FF                          jmp	parse_line_error	; go issue error 
  6298                                  
  6299                                  permcomok:
  6300                                  	; MSDOS 3.3 & MSDOS 6.0
  6301 000016F9 FE06[4002]              	inc	byte [PermCom]
  6302                                  	;mov	word [OLDTERM],LODCOM
  6303 000016FD C706[DE01][7E00]        	mov	word [OldTerm],LodCom_Trap
  6304                                  	;mov	[OLDTERM+2],ds
  6305 00001703 8C1E[E001]              	mov	[OldTerm+2],ds
  6306                                  
  6307                                  ; make sure that we display the date and time. if the flag was not
  6308                                  ; initialized, set it to indicate yes, do prompt.
  6309                                  
  6310                                  	; MSDOS 3.3
  6311                                  	;cmp	byte [PRDATTM],-1
  6312                                  	;jnz	short CHKARG
  6313                                  	;mov	byte [PRDATTM],0
  6314                                  	;jmp	short CHKARG
  6315                                  
  6316                                  	; MSDOS 6.0
  6317 00001707 803E[7B1E]FF            	cmp	byte [PRDATTM],-1
  6318 0000170C 7505                    	jne	short Parse_command_line_jmp
  6319 0000170E C606[7B1E]00            	mov	byte [PRDATTM],0
  6320                                  Parse_command_line_jmp:
  6321 00001713 E91EFF                  	jmp     Parse_command_line	; keep parsing
  6322                                  
  6323                                  ;COMRETURNSJ:
  6324                                  ;	; MSDOS 3.3
  6325                                  ;	JMP	ARGSDONE
  6326                                  
  6327                                  ;CHECKDSWITCH:
  6328                                  	;;cmp	al,'d'
  6329                                          ;cmp	al,[letter_d]
  6330                                  	;jnz	short CHECKCSWITCH
  6331                                  
  6332                                  SetDSwitch:
  6333                                  
  6334                                  ; Flag no date/time prompting.
  6335                                  
  6336                                  	; MSDOS 6.0
  6337 00001716 803E[D71E]00            	cmp	byte [dswitch],0	; has /D switch been set?
  6338                                  	; 16/04/2023
  6339                                  	;jz	short setdateok		; no - set it
  6340                                          ;;mov	ax,1
  6341                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6342                                          ;jmp	parse_line_error	; go issue error message
  6343                                  	; 16/04/2023
  6344 0000171B 75D6                    	jnz	short parse_line_error_j
  6345                                  setdateok:
  6346 0000171D FE06[D71E]              	inc	byte  [dswitch]		; indicate /D entered
  6347                                  
  6348                                  	; MSDOS 3.3 & MSDOS 6.0
  6349 00001721 C606[7B1E]01                    mov	byte [PRDATTM],1	; User explicitly says no date time
  6350                                  	; MSDOS 3.3
  6351                                  	;jmp	short CHKARG
  6352                                  	; MSDOS 6.0
  6353 00001726 E90BFF                  	jmp     Parse_command_line	; continue parsing
  6354                                  
  6355                                  	; 15/01/2023
  6356                                  	; MSDOS 6.0 
  6357                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  6358                                  SetKSwitch:
  6359 00001729 C606[4102]00            	mov	byte [SemiPermCom],0
  6360 0000172E EB05                    	jmp	short SetSorKSwitch
  6361                                  
  6362                                  ;CHECKCSWITCH:
  6363                                  	;;cmp	al,'c'
  6364                                  	;cmp	al,[letter_c]
  6365                                          ;jnz	short CHECKESWITCH
  6366                                  
  6367                                  SetSSwitch:
  6368                                  ;SETCSWITCH:
  6369                                  
  6370                                  ; Set up pointer to command line, flag no date/time and turn off SingleCom.
  6371                                  
  6372 00001730 C606[4002]00            	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
  6373                                  SetSorKSwitch:	; 06/06/2023
  6374 00001735 8936[4302]              	mov	[SingleCom],si		; Point to the rest of the command line
  6375 00001739 C606[7B1E]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  6376                                  ;COMRETURNSJ: ; 24/09/2018
  6377 0000173E E94001                  	jmp     ArgsDone
  6378                                  
  6379                                  ;CHECKESWITCH:
  6380                                  	;cmp	al,'e'
  6381                                  	;jnz	short CHKARG
  6382                                  
  6383                                  ; Look for environment-size setting switch
  6384                                  
  6385                                  ; The environment size is represented in decimal bytes and is
  6386                                  ; converted into paragraphs (rounded up to the next paragraph).
  6387                                  
  6388                                  SetESwitch:
  6389                                  	; MSDOS 6.0
  6390 00001741 803E[D61E]00            	cmp	byte [eswitch],0	; has environment size switch been set?
  6391                                  	; 16/04/2023
  6392                                  	;jz	short eswitchok		; no - set it
  6393                                  	;;mov	ax,1
  6394                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6395                                          ;jmp	parse_line_error	; go issue error message
  6396                                  	; 16/04/2023
  6397 00001746 75AB                    	jnz	short parse_line_error_j
  6398                                  eswitchok:
  6399 00001748 FE06[D61E]              	inc	byte [eswitch]		; indicate /E entered 	
  6400                                  
  6401                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  6402                                  	; 15/01/2023 - Retro DOS v4.1 (& v4.1) - MSDOS 5.0 COMMAND.COM
  6403                                  	; MSDOS 6.0
  6404                                  	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
  6405 0000174C BF[7F1F]                        mov	di,COMND1_ADDR
  6406 0000174F 8B1D                    	mov     bx,[di]				; into bx
  6407                                  
  6408 00001751 83C30F                  	add	bx,0Fh				; Round up to next paragraph
  6409 00001754 B104                    	mov	cl,4				; convert to pargraphs
  6410 00001756 D3EB                    	shr	bx,cl				; by right 4
  6411                                  
  6412 00001758 891E[C21E]              	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
  6413 0000175C E9D5FE                  	jmp	Parse_command_line		; continue parsing command line
  6414                                  
  6415                                  ; 16/04/2023
  6416                                  %if 0
  6417                                  SetMSwitch:
  6418                                          ;cmp	byte [ext_msg],1
  6419                                  	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6420                                  	jnz	short setMswitchok		; no - set it
  6421                                  	;mov	ax,1
  6422                                  	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6423                                  	jmp	parse_line_error                ; go issue error message
  6424                                  setMswitchok:
  6425                                          ;mov	byte [ext_msg],1
  6426                                  	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6427                                  	jmp	Parse_command_line              ; keep parsing
  6428                                  %endif
  6429                                  
  6430                                  ;ArgsDoneJ:
  6431                                  	;jmp	ArgsDone
  6432                                  
  6433                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6434                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
  6435                                  
  6436                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6437                                  	; (MSDOS 6.22 COMMAND.COM - RESGROUP:196Dh - CODERES:0B1Dh)
  6438                                  ChkOtherArgs:
  6439                                  
  6440                                  ; We have a non-switch character here.
  6441                                  
  6442                                  	; MSDOS 6.0
  6443 0000175F 1E                      	push	ds ; ****			;
  6444 00001760 56                      	push	si ; *** 			; save place in command line
  6445 00001761 C536[7F1F]              	lds	si,[COMND1_ADDR]		; get address of filespec
  6446                                  	;assume	ds:nothing			;
  6447                                  
  6448 00001765 89F2                    	mov	dx,si				; put in dx also
  6449 00001767 B8023D                  	mov	ax,3D02h
  6450                                  	;mov	ax,(OPEN shl 8) or 2            ; Read and write
  6451 0000176A CD21                    	int	21h
  6452 0000176C 7260                    	jc	short ChkSrchSpec		; Wasn't a file
  6453 0000176E 89C3                    	mov	bx,ax
  6454 00001770 B80044                  	mov	ax,4400h
  6455                                  	;mov	ax,IOCTL shl 8
  6456 00001773 CD21                    	int	21h
  6457 00001775 F6C280                  	test	dl,80h
  6458 00001778 7506                    	jnz	short IsaDevice
  6459                                  BadSetCon:
  6460 0000177A B43E                    	mov	ah,3Eh
  6461                                  	;mov	ah,CLOSE		; Close initial handle, wasn't a device
  6462 0000177C CD21                    	int	21h
  6463 0000177E EB4E                    	jmp	short ChkSrchSpec
  6464                                  
  6465                                  	; 15/01/2023
  6466                                  IsaDevice:
  6467                                  	; MSDOS 3.3 & MSDOS 6.0
  6468 00001780 30F6                    	xor	dh,dh
  6469 00001782 80CA03                  	or	dl,3				; Make sure has CON attributes
  6470                                  	;mov	ax,(IOCTL shl 8) or 1
  6471 00001785 B80144                  	mov	ax,(IOCTL*256)|1 ; 4401h
  6472 00001788 CD21                    	int	21h
  6473                                  	;
  6474                                  	; 15/01/2023
  6475 0000178A 72EE                    	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
  6476                                  	; 25/09/2018
  6477                                  	;pop	dx ; *
  6478                                  	;pop	dx ; **
  6479                                  	;
  6480                                  	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  6481                                  	
  6482 0000178C 89DA                    	mov	dx,bx				; Save new handle
  6483                                  
  6484                                  	; MSDOS 6.0
  6485 0000178E 26803E[1124]01          	cmp	byte [es:DevFlag],1
  6486 00001794 742A                    	jz	short DevErr
  6487                                  
  6488                                  	; MSDOS 3.3
  6489                                          ;pop	bx ; *				; Throw away saved SI
  6490                                          ;pop	bx ; **				; Throw away saved CX
  6491                                  
  6492                                  	; MSDOS 3.3 & MSDOS 6.0
  6493 00001796 51                      	push	cx ; **
  6494 00001797 B90300                  	mov	cx,3
  6495 0000179A 31DB                    	xor	bx,bx
  6496                                  
  6497                                  	; 15/01/2023
  6498                                  rcclloop:
  6499 0000179C B43E                    	mov	ah,3Eh
  6500                                  	;mov	ah,CLOSE ; 3Eh
  6501 0000179E CD21                    	int	21h
  6502 000017A0 43                      	inc	bx
  6503 000017A1 E2F9                    	loop	rcclloop
  6504                                  
  6505 000017A3 89D3                    	mov	bx,dx				; New device handle
  6506 000017A5 B445                    	mov	ah,45h
  6507                                  	;mov	ah,XDUP ; 45h
  6508 000017A7 CD21                    	int	21h				; Dup to 0
  6509 000017A9 B445                    	mov	ah,45h
  6510                                  	;mov	ah,XDUP
  6511 000017AB CD21                    	int	21h				; Dup to 1
  6512 000017AD B445                    	mov	ah,45h
  6513                                  	;mov	ah,XDUP
  6514 000017AF CD21                    	int	21h				; Dup to 2
  6515 000017B1 B43E                    	mov	ah,3Eh
  6516                                  	;mov	ah,CLOSE
  6517 000017B3 CD21                    	int	21h				; Close initial handle
  6518                                  	
  6519 000017B5 59                      	pop	cx ; **
  6520                                  	
  6521                                  	; MSDOS 6.0
  6522 000017B6 5E                      	pop	si ; ***			; restore position of command line
  6523 000017B7 1F                      	pop	ds ; ****			;
  6524                                  
  6525                                  ; Register the fact that we already have redirected the output
  6526                                  ; and can not do it again
  6527                                  
  6528 000017B8 26FE06[1124]            	inc	byte [es:DevFlag]		
  6529 000017BD E974FE                  	jmp	Parse_command_line		; continue parsing
  6530                                  
  6531                                  	; MSDOS 3.3
  6532                                  	;jcxz	ARGSDONEJ2
  6533                                  	;jmp	CHKARG
  6534                                  
  6535                                  	; MSDOS 6.0
  6536                                  DevErr:
  6537 000017C0 5E                      	pop	si ; ***
  6538 000017C1 1F                      	pop	ds ; ****
  6539 000017C2 BA0100                  	mov	dx,1
  6540 000017C5 E8F202                          call	RPrintParse                     ; "Too many parameters"
  6541 000017C8 E868FB                          call	crlf
  6542 000017CB E966FE                  	jmp	Parse_command_line
  6543                                  
  6544                                  ChkSrchSpec:				; Not a device, so must be directory spec
  6545                                  	; MSDOS 6.0
  6546 000017CE 26803E[1224]01                  cmp	byte [es:PathFlag],1		; already set COMSPEC?
  6547 000017D4 74EA                            jz	short DevErr			; yes, error
  6548                                  	
  6549 000017D6 26FE06[1224]                    inc	byte [es:PathFlag]		; mark that we have a path
  6550                                  
  6551                                  ; We have to override the passed environment. Allocate a buffer for use now.
  6552                                  ; This buffer will later be replaced by a proper environment
  6553                                  
  6554                                  	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
  6555                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
  6556                                  	; 06/06/2023
  6557                                  	;mov	ax,[ss:EnvirSeg]
  6558                                  	
  6559                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6560                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:19E9h
  6561                                  	;
  6562                                  	; MSDOS 6.0
  6563 000017DB E8B304                  	call	alloc_env                       ; environment buffer
  6564                                  
  6565                                  ; 06/06/2023
  6566                                  %if 0
  6567                                  	; 15/01/2023
  6568                                  	; MSDOS 5.0
  6569                                  	cmp	byte [ss:AllocedEnv],1
  6570                                  	mov	byte [ss:AllocedEnv],0
  6571                                  	jne     short env_alloced
  6572                                  	call	alloc_env
  6573                                  	mov	[ss:EnvirSeg],ax
  6574                                  %endif
  6575                                  
  6576                                  env_alloced:
  6577                                  	; MSDOS 5.0 & MSDOS 6.0
  6578 000017DE 8EC0                    	mov	es,ax
  6579                                  	;assume	es:nothing
  6580 000017E0 56                      	push	si ; **				; remember location of file
  6581 000017E1 31C9                    	xor	cx,cx				; clear cx for counting
  6582                                  	
  6583                                  	; 15/01/2023
  6584                                  countloop:
  6585 000017E3 AC                      	lodsb					; get a character
  6586 000017E4 41                      	inc	cx				; increment counter
  6587                                          ;;cmp	al,0
  6588                                  	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  6589                                  	;jne	short countloop			; no - keep counting
  6590 000017E5 08C0                    	or	al,al	
  6591 000017E7 75FA                    	jnz	short countloop
  6592                                  	; 06/03/2023
  6593                                  	; al = 0 ; (*) 
  6594                                  
  6595                                  	;;;;mov	al,[Space]
  6596                                  	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
  6597                                  	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6598                                  	; 16/04/2023
  6599                                  	;mov	al,20h ; ' ' 
  6600 000017E9 4E                      	dec	si				; move back one
  6601                                          ;mov	[si],al				; put a space at end of line
  6602 000017EA C60420                  	mov	byte [si],20h ; ' ' ; space_chr
  6603                                  
  6604                                  ; We now know how long the new pathspec for command.com is. Time to
  6605                                  ; figure out how long the current COMSPEC setting is, and then to move
  6606                                  ; all the environment data up, throwing that COMSPEC setting away, and
  6607                                  ; preparing to append the new COMSPEC. ComspOffset (the offset of
  6608                                  ; where the filespec exists in the environment) is updated as well.
  6609                                  
  6610                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6611                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:19FEh
  6612                                  
  6613                                  	; MSDOS 6.0
  6614 000017ED 51                      	push	cx ; * 				;
  6615 000017EE B90080                          mov	cx,ENVBIG ; 32768		;
  6616 000017F1 368B3E[AB1E]                    mov	di,[ss:ComspOffset]		; get location of COMSPEC
  6617                                          ;mov	al,0                            ;
  6618                                  	; 06/06/2023
  6619                                  	; al = 0 ; (*)
  6620 000017F6 F2AE                    	repne	scasb                           ; find the end of COMSPEC
  6621 000017F8 89FE                            mov	si,di                           ;
  6622                                  comp_endenv:					;
  6623 000017FA AE                      	scasb					; end of env?
  6624 000017FB 7404                    	je	short got_endenv		; yes
  6625 000017FD F2AE                    	repne	scasb				;
  6626 000017FF EBF9                    	jmp	short comp_endenv		;
  6627                                  got_endenv:					;
  6628 00001801 89F9                    	mov	cx,di				;
  6629 00001803 29F1                    	sub	cx,si				;
  6630 00001805 368B3E[AB1E]            	mov	di,[ss:ComspOffset]		;
  6631 0000180A 83EF08                  	sub	di,ComspStrLen	; sub di,8	;
  6632 0000180D 1E                      	push	ds ; +				;
  6633 0000180E 06                      	push	es				;
  6634 0000180F 1F                      	pop	ds				;
  6635 00001810 F3A4                    	rep	movsb				;
  6636 00001812 4F                      	dec	di				; copy in new COMSPEC=
  6637 00001813 0E                      	push	cs				;
  6638 00001814 1F                      	pop	ds				;
  6639                                          ;assume ds:RESGROUP			;
  6640                                  	;mov    si,offset RESGROUP:ComspString	;
  6641 00001815 BE[AD1E]                	mov	si,ComspString			; "COMSPEC=\COMMAND.COM"
  6642                                  	;mov	cx,ComspStrLen	; mov cx,8	;
  6643 00001818 B108                            mov	cl,ComspStrLen	; mov cl,8
  6644 0000181A F3A4                    	rep	movsb				;
  6645 0000181C 893E[AB1E]              	mov	[ComspOffset],di		;
  6646 00001820 1F                      	pop	ds ; + 				;
  6647                                          ;assume ds:nothing			;
  6648 00001821 59                      	pop	cx ; *				;
  6649                                  	;
  6650 00001822 5E                      	pop	si ; **				; get new comspec location back
  6651                                  
  6652                                  	;; MSDOS 3.3 COMMAND.COM
  6653                                  	;;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
  6654                                  	;;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
  6655                                  	;;mov	cl,4
  6656                                  	;;shr	ax,cl
  6657                                  	;;mov	dx,ds
  6658                                  	;;add	ax,dx
  6659                                  	;;mov	[ENVIRSEG],ax
  6660                                  	;;mov	es,ax
  6661                                  	;;;mov	al,' '
  6662                                  	;;mov	al,[SPACE_CHR]
  6663                                  	;;mov	[si-1],al
  6664                                  	;;pop	si ; **				; Remember location
  6665                                  	;;pop	cx ; *				; and count
  6666                                  	;;;mov	di,[ECOMLOC]
  6667                                  	;;mov	di,[COMSPOFFSET]
  6668                                  
  6669                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6670                                  	;; 15/01/2023
  6671                                  	;; MSDOS 5.0 COMMAND.COM
  6672                                  	;pop	si ; **
  6673                                  	;;mov	di,14
  6674                                  	;mov	di,ECOMSPEC ; mov di,0Eh
  6675                                  
  6676                                  ComtrLoop:
  6677                                  	; MSDOS 3.3 & MSDOS 6.0
  6678 00001823 AC                      	lodsb
  6679 00001824 49                      	dec	cx
  6680                                  	;;;;cmp	al,' '
  6681                                  	;;;cmp	al,[space_chr]
  6682                                  	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
  6683                                  	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6684                                  	; 16/04/2023
  6685 00001825 3C20                    	cmp	al,20h ; ' ' ; space_chr
  6686 00001827 7405                    	je	short SetComsr
  6687                                  	; MSDOS 3.3
  6688                                  	;cmp	al,9
  6689                                  	;je	short SetComsr
  6690                                  	; MSDOS 3.3 & MSDOS 6.0
  6691 00001829 AA                      	stosb
  6692 0000182A E302                    	jcxz	SetComsr
  6693 0000182C EBF5                    	jmp	short ComtrLoop
  6694                                  
  6695                                  SetComsr:
  6696                                  	; 15/01/2023
  6697                                  	; MSDOS 6.0
  6698 0000182E 51                      	push	cx ; **
  6699 0000182F 0E                      	push	cs				; Get local segment
  6700 00001830 1F                      	pop	ds				;
  6701                                  	;assume	ds:ResGroup			;
  6702 00001831 1E                      	push	ds ; *
  6703                                  	;mov	si,offset ResGroup:ComSpect
  6704 00001832 BE[5C1E]                	mov	si,COMSPECT ; "\COMMAND.COM"
  6705 00001835 B90E00                  	mov	cx,14
  6706 00001838 268A45FF                	mov	al,[es:di-1]
  6707 0000183C 3A06[F103]              	cmp	al,[RDirChar]
  6708 00001840 7502                    	jne	short iNotRoot
  6709 00001842 46                      	inc	si				; Don't make a double /
  6710 00001843 49                      	dec	cx
  6711                                  	
  6712                                  	; MSDOS 3.3
  6713                                  	;push	si
  6714                                  	;push	cx
  6715                                  	;push	ds
  6716                                  	;mov	si,COMSPECT ; "/COMMAND.COM"
  6717                                  	;mov	cx,14
  6718                                  	;mov	al,[es:di-1]
  6719                                  	;call	PATHCHRCMPR
  6720                                  	;jnz	short INOTROOT			
  6721                                  	;inc	si				; Don't make a double /
  6722                                  	;dec	cx
  6723                                  
  6724                                  iNotRoot:
  6725                                  	; MSDOS 3.3 & MSDOS 6.0
  6726 00001844 F3A4                    	rep	movsb
  6727                                  
  6728                                  	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  6729                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6730                                  	; MSDOS 6.0 
  6731 00001846 8B16[AB1E]              	mov	dx,[ComspOffset] ; [COMSPOFFSET]
  6732                                  	; 15/01/2023
  6733                                  	;;mov	dx,14
  6734                                  	;mov	dx,ECOMSPEC ; mov dx,0Eh ; MSDOS 5.0 COMMAND.COM
  6735                                  
  6736 0000184A 06                      	push	es
  6737 0000184B 1F                      	pop	ds
  6738                                  	;;mov	ax,OPEN shl 8
  6739                                  	;mov	ax,OPEN*256 ; 3D00h
  6740 0000184C B8003D                  	mov	ax,3D00h ; 15/01/2023
  6741 0000184F CD21                    	int	21h				; Open COMMAND.COM
  6742 00001851 1F                      	pop	ds ; *
  6743 00001852 720E                    	jc	short SetComsrBad		; No COMMAND.COM here
  6744 00001854 89C3                    	mov	bx,ax				; Handle
  6745 00001856 B43E                    	mov	ah,3Eh ; 15/01/2023
  6746                                  	;mov	ah,CLOSE ; 3Eh
  6747 00001858 CD21                    	int	21h				; Close COMMAND.COM
  6748                                  SetComsrRet:
  6749                                  	; 15/01/2023
  6750 0000185A 59                      	pop	cx ; **
  6751 0000185B 5E                      	pop	si ; ***
  6752                                  
  6753                                  	; MSDOS 6.0
  6754 0000185C 1F                      	pop	ds ; ****			;
  6755                                  	;assume	ds:ResGroup			;
  6756                                  	;
  6757 0000185D 0E                      	push	cs				; Make sure local ES is
  6758 0000185E 07                      	pop	es				;  restored
  6759 0000185F E9D2FD                  	jmp	Parse_command_line		; continue parsing command line
  6760                                  
  6761                                  	; MSDOS 3.3
  6762                                  ;ARGSDONEJ2:
  6763                                  	;jcxz	ARGSDONE
  6764                                  	;jmp	CHKARG
  6765                                  
  6766                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6767                                  SetComsrBad:
  6768                                  	; MSDOS 3.3 & MSDOS 6.0
  6769                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  6770 00001862 BA[1A20]                	mov	dx,BADCOMLKMES
  6771                                  
  6772                                  ;	Note: we're about to make a near call to TriageError, which
  6773                                  ;	lives in a different segment and group. Some linkers will
  6774                                  ;	generate a warning like "Possible fix-up overflow". We're
  6775                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  6776                                  ;	we're still all together.
  6777                                  
  6778                                  	; 16/01/2023
  6779                                  	;TRIAGEERROR equ TRANSTART+TriageError
  6780                                  	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)
  6781                                  
  6782                                  	; 06/06/2023
  6783                                  	TRIAGEERROR equ TRANSTART+TriageError
  6784                                  	;(MSDOS 6.22 COMMAND.COM, 26E0h+333Ch)
  6785                                  
  6786                                  	;;call	50B2h ; MSDOS 5.0 COMMAND.COM
  6787                                  	;call	5A1Ch ; MSDOS 6.22 COMMAND.COM
  6788 00001865 E8(1A57)                	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  6789                                  				; in original MSDOS 3.3 COMMAND.COM
  6790                                  
  6791                                  			; TriageError procedure is at offset 50B2h
  6792                                  			; in original MSDOS 5.0 COMMAND.COM	
  6793 00001868 83F841                  	cmp	ax,65
  6794 0000186B 7503                    	jne	short doprt
  6795                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  6796 0000186D BA[4320]                	mov	dx,BADCOMACCMSG
  6797                                  doprt:
  6798 00001870 E8C3FA                  	call	RPrint
  6799                                  	;mov	si,offset ResGroup:ComSpect
  6800 00001873 BE[5C1E]                	mov     si,COMSPECT ; "\COMMAND.COM"
  6801                                  	;;mov	di,[ECOMLOC]
  6802                                  	; 06/06/2023
  6803 00001876 8B3E[AB1E]              	mov	di,[ComspOffset] ; MSDOS 6.22 COMMAND.COM
  6804                                  	; 16/01/2023
  6805                                  	;mov	di,ECOMSPEC ; mov di,0Eh ; MSDOS 5.0 COMMAND.COM
  6806 0000187A B90E00                  	mov	cx,14
  6807 0000187D F3A4                    	rep	movsb				; get my default back
  6808                                  
  6809 0000187F EBD9                    	jmp	short SetComsrRet
  6810                                  
  6811                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6812                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
  6813                                  
  6814                                  	; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6815                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1A99h (CODERES:0C49h)
  6816                                  ArgsDone:
  6817                                  	; MSDOS 6.0
  6818 00001881 8E06[DC03]              	mov	es,[EnvirSeg]			; get environment back
  6819                                  	;assume	es:nothing			;
  6820                                  
  6821                                  	; MSDOS 3.3 & MSDOS 6.0
  6822 00001885 803E[4002]00                    cmp	byte [PermCom],0
  6823 0000188A 742E                            jz	short ComReturns
  6824                                  
  6825 0000188C 06                      	push	es				; Save environment pointer
  6826 0000188D B450                    	mov	ah,50h
  6827                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  6828 0000188F 8CDB                    	mov	bx,ds
  6829 00001891 8EC3                    	mov	es,bx
  6830 00001893 CD21                    	int	21h				; current process is me
  6831 00001895 BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  6832                                  	;;mov	ax,offset RESGROUP:LODCOM
  6833                                  	;mov	ax,LODCOM
  6834                                  	; 16/01/2023
  6835 00001898 B8[7E00]                	mov	ax,LodCom_Trap
  6836 0000189B AB                              stosw
  6837 0000189C 8CD8                            mov	ax,ds
  6838 0000189E AB                              stosw
  6839                                  	;;mov	ax,offset RESGROUP:CONTC
  6840                                  	;mov	ax,CONTC
  6841                                  	; 16/01/2023
  6842 0000189F B8[4A00]                	mov	ax,Ctrlc_Trap
  6843 000018A2 AB                              stosw
  6844 000018A3 8CD8                            mov	ax,ds
  6845 000018A5 AB                              stosw
  6846                                  	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  6847                                  	;mov	ax,CRITERR
  6848                                  	; 16/01/2023
  6849 000018A6 B8[5500]                	mov	ax,CritErr_Trap
  6850 000018A9 AB                      	stosw
  6851 000018AA 8CD8                    	mov     ax,ds
  6852 000018AC AB                      	stosw
  6853                                  	;;mov	word ptr ds:16h,ds
  6854                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  6855 000018AD 8C1E1600                	mov	[PDB.PARENT_PID],ds
  6856                                          ;;mov	dx,offset RESGROUP:Int_2e
  6857                                  	;mov	dx,Int_2e
  6858                                          ; 16/01/2023
  6859 000018B1 BA[3F00]                	mov	dx,Int2e_Trap
  6860 000018B4 B82E25                  	mov	ax,252Eh
  6861                                  	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  6862                                  	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  6863 000018B7 CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  6864                                  			; AL = interrupt number
  6865                                  			; DS:DX = new vector to be used for specified interrupt
  6866 000018B9 07                              pop	es				; Remember environment
  6867                                  	
  6868                                  ComReturns:
  6869                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  6870 000018BA A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  6871                                  	; 16/01/2023
  6872 000018BD A3[DC01]                	mov	[Parent],ax			; Save parent
  6873                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  6874 000018C0 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  6875                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  6876 000018C4 A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
  6877 000018C7 A3[3D02]                        mov	[Io_Save],ax		; Get the default stdin and out
  6878 000018CA 8C1E[E003]                      mov	[Com_Ptr+2],ds		; Set all these to resident
  6879 000018CE 8C1E[E403]                      mov	[Com_Fcb1+2],ds
  6880 000018D2 8C1E[E803]              	mov	[Com_Fcb2+2],ds
  6881                                          ;mov	di,offset ResGroup:ComSpec
  6882 000018D6 BF[E901]                        mov	di,ComSpec
  6883                                  
  6884                                  	;;mov	si,[ECOMLOC]
  6885                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  6886 000018D9 8B36[AB1E]              	mov	si,[ComspOffset]
  6887                                  	; 16/01/2023 - MSDOS 5.0 COMMAND.COM
  6888                                  	;mov	si,ECOMSPEC ; mov si,0Eh
  6889                                  
  6890 000018DD 803E[881E]00            	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
  6891                                          ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  6892                                  	
  6893 000018E2 8CD8                    	mov	ax,ds				; Xchg es,ds
  6894 000018E4 06                      	push	es
  6895 000018E5 1F                      	pop	ds
  6896 000018E6 8EC0                    	mov	es,ax
  6897                                  
  6898                                  	; 06/06/2023
  6899 000018E8 7517                    	jne	short CopyComsp ; MSDOS 6.0
  6900                                  	; 16/01/2023	
  6901                                  	;je	short CopyComsp ; MSDOS 5.0
  6902                                  	;;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  6903                                  
  6904 000018EA 0E                              push	cs
  6905 000018EB 1F                              pop	ds
  6906                                  
  6907                                          ;mov	si,offset ResGroup:ComspString
  6908 000018EC BE[AD1E]                	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6909 000018EF 06                      	push	es
  6910 000018F0 57                      	push	di
  6911 000018F1 E8D701                  	call	IfindE
  6912 000018F4 89FE                    	mov	si,di
  6913 000018F6 06                      	push	es
  6914 000018F7 1F                      	pop	ds
  6915 000018F8 5F                      	pop	di
  6916 000018F9 07                      	pop	es
  6917 000018FA 7305                            jnc	short CopyComsp
  6918                                  
  6919                                  	; 06/06/2023
  6920                                  	; MSDOS 6.0
  6921                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1B04h
  6922                                  ComSpecNofnd:
  6923                                  	;;mov	si,offset ResGroup:ComspString
  6924                                  	;mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6925                                  	;add	si,ComspStrLen ; add si,8
  6926 000018FC BE[B51E]                	mov	si,ComspString+ComspStrLen
  6927                                  	
  6928                                  	;; 21/01/2023
  6929                                  	;; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
  6930                                  	;;mov	si,0Eh
  6931                                  	;mov	si,ECOMSPEC
  6932                                  	
  6933 000018FF 0E                      	push	cs
  6934 00001900 1F                      	pop	ds	
  6935                                  
  6936                                  	; 21/01/2023
  6937                                  ;COMSPECNOFND:
  6938                                  	; MSDOS 3.3
  6939                                          ;;mov	si,[es:ECOMLOC]
  6940                                          ;mov	si,[es:COMSPOFFSET]
  6941                                  	;;add	si,offset RESGROUP:PATHSTRING
  6942                                          ;add	si,PATHSTRING ; "PATH="
  6943                                  	;push	cs
  6944                                  	;pop	ds
  6945                                  
  6946                                  CopyComsp:
  6947                                  	; 21/01/2023
  6948                                  ;COPYCOMSP:
  6949                                  	; MSDOS 3.3 & MSDOS 6.0
  6950                                  	;;mov	es:PutBackComSpec.SubstPtr,di
  6951                                  	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  6952 00001901 26893E[C801]            	mov	[es:PutBackComSpec],di
  6953 00001906 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  6954 0000190A 7506                    	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
  6955                                  	;;add	es:PutBackComSpec.SubstPtr,2
  6956                                  	;add	word [es:PUTBACKSUBSTPTR],2
  6957 0000190C 268306[C801]02          	add	word [es:PutBackComSpec],2
  6958                                  CopyComspLoop:
  6959 00001912 AC                      	lodsb
  6960 00001913 AA                      	stosb
  6961 00001914 08C0                    	or	al,al
  6962 00001916 75FA                    	jnz	short CopyComspLoop
  6963                                  
  6964 00001918 26893E[2902]            	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
  6965 0000191D 26FF0E[2902]            	dec	word [es:ComSpec_End]
  6966 00001922 268A26[3202]            	mov	ah,[es:ComDrv]
  6967 00001927 80C440                  	add	ah,'A'-1 ; 40h
  6968 0000192A 268826[CD01]            	mov	[es:PutBackDrv],ah		; save drive letter
  6969                                  
  6970                                  	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
  6971                                  	
  6972                                  	; MSDOS 6.0
  6973 0000192F E81002                  	call	setup_for_messages		; set up parse and extended error messages
  6974                                  
  6975                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  6976                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  6977                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  6978                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  6979                                  ; the data otherwise it is just the data.
  6980                                   
  6981 00001932 E8AF02                  	call	Setup_res_end			; put resident size in ResSize
  6982                                  
  6983 00001935 0E                      	push	cs
  6984 00001936 1F                      	pop	ds
  6985                                  	;assume	ds:RESGROUP
  6986                                  
  6987                                  ;Public EnvMaximum
  6988                                          ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6989                                  EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh
  6990                                          ; 06/06/2023 - Retro DOS v4.2 COMMAND.COM
  6991                                  		; MSDOS 6.22 COMMAND.COM - RESGROUP:1B53h
  6992                                  
  6993                                  	; 21/01/2023
  6994                                  	; MSDOS 6.0
  6995                                  	;;mov	si,offset RESGROUP:TranStart
  6996                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
  6997                                  	; 06/06/2023
  6998                                  	;;mov	si,26E0h	; MSDOS 6.22 COMMAND.COM
  6999                                  	;mov	si,TRANSTART
  7000                                  	;add	si,100h
  7001                                  	; 23/04/2023
  7002 00001937 BE5026                  	mov	si,TRANSTART+100h
  7003                                  
  7004                                  	;;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  7005                                  	;;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
  7006                                  	; 06/06/2023
  7007                                  	;;mov	cx,9D53h	; MSDOS 6.22 COMMAND.COM	
  7008 0000193A B9[4198]                	mov	cx,TRANDATAEND-100h
  7009                                  
  7010 0000193D FC                      	cld
  7011 0000193E D1E9                    	shr	cx,1
  7012 00001940 31D2                    	xor	dx,dx
  7013                                  Ichksum:
  7014 00001942 AD                      	lodsw
  7015 00001943 01C2                    	add	dx,ax
  7016 00001945 83D200                  	adc	dx,0
  7017 00001948 E2F8                    	loop	Ichksum
  7018                                  
  7019 0000194A 8916[3502]                      mov	[Sum],dx			; store checksum
  7020                                  
  7021 0000194E 803E[7B1E]00                    cmp     byte [PRDATTM],0
  7022 00001953 750C                            jne	short NoBatchSeg		; don't do autoexec or date time
  7023                                  	
  7024                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  7025                                  
  7026                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
  7027                                  	; 21/01/2023
  7028                                  	;mov	bx,4
  7029 00001955 BB0400                          mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  7030 00001958 B448                    	mov	ah,48h
  7031                                  	;mov	ah,ALLOC                        ;
  7032 0000195A CD21                            int	21h                             ;
  7033 0000195C 7203                    	jc	short NoBatchSeg		; didn't allocate - pretend no batch
  7034 0000195E A3[E701]                        mov	[Batch],ax			; save batch segment
  7035                                  
  7036                                  NoBatchSeg:
  7037                                  	; 21/01/2023
  7038                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7039 00001961 8B1E[DC03]              	mov	bx,[EnvirSeg]			; get old environment segment
  7040 00001965 891E[C61E]              	mov	[OldEnv],bx			; save it
  7041 00001969 C706[C81E]0000          	mov	word [UsedEnv],0		; initialize env size counter
  7042 0000196F 8EDB                    	mov	ds,bx
  7043                                  	;assume	ds:nothing
  7044                                  	
  7045 00001971 31F6                    	xor	si,si
  7046 00001973 89F7                    	mov	di,si
  7047                                  
  7048                                  ; This is the maximum allowed size for the environment
  7049                                  
  7050                                  	; 21/01/2023
  7051                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
  7052                                  	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
  7053                                  	;;mov	[ss:EnvMax],bx
  7054                                  	;shl	bx,1
  7055                                  	;shl	bx,1
  7056                                  	;shl	bx,1
  7057                                  	;shl	bx,1
  7058 00001975 BBF0FF                  	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
  7059 00001978 36891E[C41E]            	mov	[ss:EnvMax], bx			; convert envmax to bytes
  7060 0000197D 4B                      	dec	bx				; dec by one to leave room for double 0
  7061 0000197E 31D2                    	xor	dx,dx				; use dx to indicate that there was
  7062                                  						; no environment size error.
  7063                                  ;public NxtStr
  7064                                  NxtStr:
  7065 00001980 E81E01                  	call	GetStrLen			; get the size of the current env string
  7066                                  
  7067                                  ;Bugbug: Can use ss here to address UsedEnv
  7068                                  
  7069 00001983 1E                      	push	ds                              ; get addressability to environment
  7070 00001984 0E                              push	cs                              ;                       counter
  7071 00001985 1F                              pop	ds                              ;
  7072                                  	;assume	ds:ResGroup
  7073 00001986 010E[C81E]                      add	[UsedEnv],cx			; add the string length to env size
  7074 0000198A 1F                      	pop	ds                              ;
  7075                                  	;assume	ds:nothing
  7076                                  	
  7077 0000198B 83F901                  	cmp	cx,1				; end of environment was encountered.
  7078 0000198E 7405                    	je	short EnvExit
  7079 00001990 29CB                    	sub	bx,cx
  7080                                  	;jae	short OkCpyStr			; can't fit in all of enviroment.
  7081                                  	; 21/01/2023
  7082 00001992 73EC                    	jae	short NxtStr
  7083 00001994 42                      	inc	dx				; out of env space msg must be displayed
  7084                                  	;jmp	short EnvExit
  7085                                  
  7086                                  ;OkCpyStr:
  7087                                  	;jmp	short NxtStr
  7088                                  
  7089                                  EnvExit:
  7090 00001995 0E                      	push	cs
  7091 00001996 1F                      	pop	ds
  7092                                  	;assume	ds:ResGroup
  7093 00001997 09D2                    	or	dx,dx				; dx will be non-zero if error
  7094 00001999 7406                    	jz	short EnvNoErr
  7095                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  7096 0000199B BA[A01F]                	mov	dx,OUTENVMSG
  7097 0000199E E895F9                  	call 	RPrint
  7098                                  EnvNoErr:
  7099 000019A1 A1[C21E]                	mov	ax,[EnvSiz]			; env size previously set
  7100 000019A4 B104                    	mov	cl,4
  7101 000019A6 D3E0                    	shl	ax,cl				; get size in bytes
  7102 000019A8 3B06[C81E]              	cmp	ax,[UsedEnv]			; is it a new env?
  7103 000019AC 7706                    	ja	short st_envsize		; yes, store the size
  7104 000019AE A1[C81E]                	mov	ax,[UsedEnv]
  7105 000019B1 83C00F                  	add	ax,15				; round up
  7106                                  st_envsize:	
  7107 000019B4 D3E8                    	shr	ax,cl
  7108 000019B6 A3[C21E]                	mov	[EnvSiz],ax			; store env size needed(paras)
  7109                                  
  7110                                  ;if MSVER
  7111                                  	;cmp	SingleCom,0
  7112                                  	;jnz	nophead 			; don't print header if SingleCom
  7113                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7114                                  	;call	RPrint
  7115                                  ;nophead:
  7116                                  ;endif
  7117                                  	; 21/01/2023
  7118                                  
  7119                                  	; MSDOS 3.3 & 6.0
  7120 000019B9 833E[E701]00            	cmp     word [Batch],0		; did we set up a batch segment?
  7121 000019BE 7503                    	jnz     short DoDate		; yes - go initialize it
  7122 000019C0 E99300                  	jmp     NoDttm			; don't do autoexec or date time
  7123                                  
  7124                                  DoDate:
  7125                                  
  7126                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  7127                                  
  7128 000019C3 A1[E701]                	mov	ax,[Batch]		; get batch segment
  7129 000019C6 C606[3B02]03            	mov	byte [EchoFlag],3	; set batch echo
  7130 000019CB C706[4C02]0100          	mov	word [Nest],1		; set nest flag to 1 batch
  7131 000019D1 8EC0                    	mov	es,ax
  7132                                  
  7133                                  ; initialize the segment
  7134                                  
  7135 000019D3 31FF                    	xor	di,di
  7136                                  	;;mov	al,0
  7137                                  	;mov	al,BATCHTYPE ; 0
  7138                                  	; 06/06/2023
  7139 000019D5 31C0                    	xor	ax,ax
  7140 000019D7 AA                      	stosb
  7141                                  	;mov	al,1			; initialize echo for batch exit
  7142                                  	;inc	al
  7143                                  	; 22/07/2024
  7144 000019D8 40                      	inc	ax
  7145 000019D9 AA                      	stosb
  7146                                  
  7147                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  7148                                  
  7149                                  	;xor	ax,ax			; initialize to zero
  7150                                  	; 06/06/2023
  7151                                  	;dec	al ; ax = 0
  7152                                  	; 22/07/2024
  7153 000019DA 48                      	dec	ax
  7154                                  
  7155                                  	; 21/01/2023
  7156 000019DB AA                      	stosb	; MSDOS 6.0 		; clear out BatchEOF
  7157                                  
  7158 000019DC AB                      	stosw				; batch segment of last job - batlast
  7159 000019DD AB                      	stosw				; segment for FOR
  7160 000019DE AA                      	stosb				; FOR flag
  7161 000019DF AB                      	stosw				; position in file - batseek
  7162 000019E0 AB                      	stosw
  7163                                  
  7164                                  ; clean out the parameters
  7165                                  
  7166                                  	;mov	ax,-1			; initialize to no parameters
  7167                                  	; 06/06/2023
  7168 000019E1 48                      	dec	ax ; ax = -1
  7169                                  
  7170 000019E2 B90A00                  	mov	cx,10
  7171 000019E5 F3AB                    	rep	stosw
  7172                                  
  7173                                  ; decide whether we should grab the default drive
  7174                                  
  7175 000019E7 803E[6A1E]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  7176 000019EC 7509                    	jne	short NoAutSet
  7177 000019EE B419                    	mov	ah,19h	; 21/01/2023
  7178                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  7179 000019F0 CD21                    	int	21h
  7180                                  	;;add	al,'A'
  7181                                  	;add	al,[letter_A] ; Ucasea
  7182                                  	;add	al,[ucasea] ; 21/01/2023
  7183                                  	; 21/01/2023
  7184 000019F2 0441                    	add	al,'A'
  7185 000019F4 A2[6A1E]                	mov	[AUTOBAT],al
  7186                                  	; 22/07/2024
  7187                                  	; 21/01/2023
  7188                                  	; 06/06/2023
  7189                                  	;mov	[KAUTOBAT],al
  7190                                  NoAutSet:
  7191                                  
  7192                                  ; copy in the batch file name (including nul)
  7193                                  
  7194                                  	;mov	si,offset ResGroup:AutoBat
  7195 000019F7 BE[6A1E]                	mov	si,AUTOBAT
  7196 000019FA B90800                  	mov	cx,8
  7197 000019FD F3A5                    	rep	movsw
  7198                                  	; 23/04/2023
  7199 000019FF A4                      	movsb	; MSDOS 6.0		; move in carriage return to terminate string
  7200                                  
  7201                                  	;mov	dx,offset ResGroup:AutoBat
  7202 00001A00 BA[6A1E]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  7203                                  
  7204                                  	;;mov	ax,OPEN shl 8
  7205 00001A03 B8003D                  	mov	ax,3D00h ; 21/01/2023
  7206                                  	;mov	ax,OPEN*256 ; 3D00h	; open for read
  7207 00001A06 CD21                    	int	21h			; see if autoexec.bat exists
  7208 00001A08 7208                    	jc	short noabat
  7209 00001A0A 89C3                    	mov	bx,ax
  7210 00001A0C B43E                    	mov	ah,3Eh ; 21/01/2023
  7211                                  	;mov	ah,CLOSE  ; 3Eh
  7212 00001A0E CD21                    	int	21h
  7213                                  	;jmp	Drv0			; go process autoexec
  7214                                  	; 22/07/2024
  7215 00001A10 EB51                    	jmp	short Drv0
  7216                                  
  7217                                  noabat:
  7218 00001A12 50                      	push	ax
  7219 00001A13 E89400                  	call	Setup_Seg
  7220 00001A16 A3[861E]                	mov	[triage_add+2],ax
  7221 00001A19 58                      	pop	ax
  7222 00001A1A FF1E[841E]              	call	far [triage_add]	; get extended error
  7223 00001A1E 83F841                  	cmp	ax,65			; network access denied?
  7224                                  	;jne	short OPENERR		; no - go deallocate batch
  7225                                  	; 21/01/2023
  7226                                  	;;je	short AccDenErr
  7227                                  	; 22/07/2024
  7228 00001A21 7506                    	jne	short OpenErr 
  7229                                  	; 06/06/2023
  7230                                  	;je	short AccDenErr
  7231                                  
  7232                                  	; 21/01/2023
  7233                                  ;_ACCDENERROR:					; yes - put out message
  7234                                  ;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7235                                  ;	mov	dx,ACCDENERR
  7236                                  ;	call	RPRINT
  7237                                  
  7238                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7239                                  
  7240                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7241                                  
  7242                                  ; 22/07/2024
  7243                                  ; 06/06/2023
  7244                                  ; 21/01/2023
  7245                                  %if 0
  7246                                  
  7247                                  ; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
  7248                                  ; by Ellen to check only when in Korea. The country information
  7249                                  ; returned will overlay the old parse data area, but we don't care
  7250                                  ; since we won't need the parse information or country information.
  7251                                  ; We only care about the country code returned in BX.
  7252                                  
  7253                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h
  7254                                  	; 06/06/2023
  7255                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1C5Eh
  7256                                  
  7257                                  	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
  7258                                  	mov	dx,INTERNAT_INFO
  7259                                  	mov	ax,3800h
  7260                                  	;mov	ax,INTERNATIONAL<<8
  7261                                  	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
  7262                                  	int	21h				;
  7263                                  	jc	short NoKabat 			; error - don't bother with it
  7264                                  	cmp	bx,52h
  7265                                  	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
  7266                                  	jne	short OpenErr 			; no, don't check for kautoexe
  7267                                  
  7268                                  	;mov	di,BatFile			; 3/3/kk
  7269                                  	mov	di,20h
  7270                                  	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
  7271                                  	mov	si,KAUTOBAT
  7272                                  	mov	cx,8				; auto execution for the 3/3/kk
  7273                                  	rep	movsw				; non-english country	3/3/kk
  7274                                  	movsb					; move in carraige return to terminate string
  7275                                  	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
  7276                                  	mov	dx,KAUTOBAT
  7277                                  	mov	ax,3D00h
  7278                                  	;mov	ax,OPEN<<8
  7279                                  	;;mov	ax,OPEN shl 8			; 3/3/kk
  7280                                  	int	21h				; see if kautoexe.bat exists  3/3/kk
  7281                                  	jc	short NoKabat 			; 3/3/kk
  7282                                  	mov	bx,ax				; 3/3/kk
  7283                                  	mov	ah,3Eh
  7284                                  	;mov	ah,CLOSE			; 3/3/kk
  7285                                  	int	21h				; 3/3/kk
  7286                                  	jmp	short Drv0			; 3/3/kk
  7287                                  
  7288                                  NoKabat:					; 3/3/kk
  7289                                  	call	far [triage_add]		; get extended error
  7290                                  	cmp	ax,65				; network access denied?
  7291                                  	jnz	short OpenErr 			; no - go deallocate batch
  7292                                  
  7293                                  	; 22/07/2024
  7294                                  %endif	; 06/06/2023 - Retro DOS 4.2 COMMAND.COM
  7295                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7296                                  
  7297                                  AccDenErr:					; yes - put out message
  7298                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7299 00001A23 BA[7606]                	mov	dx,ACCDEN
  7300 00001A26 E80DF9                  	call	RPrint
  7301                                  OpenErr:
  7302                                  ;OPENERR:
  7303 00001A29 8E06[E701]              	mov	es,[Batch]		; not found--turn off batch job
  7304 00001A2D B449                    	mov	ah,49h
  7305                                  	;mov	ah,DEALLOC ; 49h
  7306 00001A2F CD21                    	int	21h
  7307 00001A31 C706[E701]0000          	mov	word [Batch],0		; after dealloc in case of ^c
  7308 00001A37 C606[3B02]01            	mov	byte [EchoFlag],1
  7309 00001A3C C706[4C02]0000          	mov	word [Nest],0		; indicate no batch in progress
  7310                                  ;DoDttm:
  7311                                  	;mov	ax,offset TranGroup:Datinit
  7312 00001A42 B8[B133]                	mov	ax,DATINIT
  7313 00001A45 A3[7C1E]                	mov	[INITADD],ax
  7314                                  
  7315                                  	; MSDOS 6.0
  7316                                  ;;M004;;mov	ax,TrnSeg	
  7317                                  ;
  7318                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  7319                                  ; M004; the transient starts on a para boundary at the label TranStart.
  7320                                  ; M004; We use TranStart to get the start of the transient segment.
  7321                                  
  7322                                  	; 21/01/2023
  7323                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  7324                                  	;;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7325                                  	; 06/06/2023
  7326                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7327                                  	;
  7328                                  	;mov	ax,TRANSTART
  7329                                  	;mov	cl,4				; M004
  7330                                  	;shr	ax,cl				; get relative seg ; M004
  7331                                  	; 06/06/2023
  7332 00001A48 B85502                  	mov	ax,TRANSTART>>4	
  7333                                  
  7334 00001A4B 8CC9                    	mov	cx,cs
  7335 00001A4D 01C8                    	add	ax,cx				; ax = transient seg ; M004
  7336                                  
  7337                                  	; 21/01/2023
  7338                                  	; MSDOS 3.3
  7339                                  	; 25/09/2018
  7340                                  	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  7341                                  
  7342                                  	; MSDOS 3.3 & MSDOS 6.0
  7343 00001A4F A3[7E1E]                	mov	[INITADD+2],ax
  7344                                  	;call	dword ptr InitAdd
  7345 00001A52 FF1E[7C1E]              	call	far [INITADD]
  7346                                  
  7347                                  NoDttm:
  7348                                  	; MSDOS 6.0
  7349                                  	; 21/01/2023
  7350                                  ;Copyright:
  7351                                  	;public	Copyright
  7352                                  ;	Bugbug:	remove Copyright label.
  7353                                  
  7354                                  ;if IBMVER
  7355 00001A56 833E[4302]00            	cmp	word [SingleCom],0
  7356 00001A5B 7506                    	jnz	short Drv0			; don't print header if SingleCom
  7357                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7358 00001A5D BA[BB1F]                	mov	dx,COPYRIGHTMSG
  7359 00001A60 E8D3F8                  	call	RPrint
  7360                                  ;endif
  7361                                  	; 21/01/2023
  7362                                  	; MSDOS 3.3
  7363                                  	;cmp	word [SingleCom],0	; don't print header if SingleCom
  7364                                  	;jnz	short DRV0
  7365                                  	;mov	dx,HEADERPTR	; dx = ptr to msg
  7366                                  	;call	RPRINT
  7367                                  ;DRV0:
  7368                                  	; MSDOS 3.3
  7369                                  	;mov	byte [INITFLAG],0
  7370                                  	;jmp	ENDINIT
  7371                                  
  7372                                  	; 21/01/2023
  7373                                  	; MSDOS 6.0
  7374                                  Drv0:						; Reset APPEND state
  7375 00001A63 1E                      	push	ds				; save data segment
  7376 00001A64 0E                      	push	cs				; Get local segment into DS
  7377 00001A65 1F                      	pop	ds				;
  7378 00001A66 B807B7                  	mov	ax,0B707h ; 21/01/2023
  7379                                  	;mov	ax,APPENDSETSTATE		; Set the state of Append
  7380 00001A69 8B1E[6002]              	mov	bx,[Append_State] 		;  back to the original state
  7381 00001A6D CD2F                    	int	2Fh				;
  7382 00001A6F 1F                      	pop	ds				; get data segment back
  7383                                  
  7384                                  ;Check FirstCom set previously to see if this is the first instance of
  7385                                  ;command.com. If not, we do not move command.com. Instead, we copy over the
  7386                                  ;jump table from the previous stub to the current stub.
  7387                                  
  7388 00001A70 803E[1024]01            	cmp	byte [FirstCom],1		; first command.com?
  7389 00001A75 7424                    	jz	short move_code			; yes, move it
  7390                                  
  7391 00001A77 06                      	push	es
  7392 00001A78 1E                      	push	ds
  7393                                  
  7394 00001A79 1E                      	push	ds
  7395 00001A7A 07                      	pop	es
  7396                                  	;mov	di,offset DATARES:Int2f_Entry
  7397 00001A7B BF[0400]                	mov	di,Int2f_Entry	
  7398                                  
  7399                                  	;mov	ds,[es:ResJmpTable+2]		; get segment address
  7400                                  	;mov	si,[es:ResJmpTable]		; get offset address
  7401                                  	; 22/07/2024 - PCDOS 7.1 COMMAND.COM
  7402 00001A7E 26C536[0C24]            	lds	si,[es:ResJmpTable]
  7403                                  
  7404                                  	;mov	cx,11
  7405                                  	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
  7406                                  	;shl	cx,1
  7407                                  	;shl	cx,1				; size of table in bytes
  7408                                  	; 21/01/2023
  7409 00001A83 B92C00                  	mov	cx,44				; size of table in bytes
  7410                                  
  7411 00001A86 FC                      	cld
  7412 00001A87 F3A4                    	rep	movsb				; copy the jump table
  7413                                  
  7414                                  ;Check if the resident code is in HMA. We assume that it is in HMA if its 
  7415                                  ;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  7416                                  
  7417 00001A89 26817DFE00F0            	cmp	word [es:di-2],0F000h		; is resident code in HMA?
  7418 00001A8F 7206                    	jb	short res_low			; no, dont set flag
  7419                                  
  7420 00001A91 26C606[3400]01          	mov	byte [es:ComInHMA],1		; indicate code in HMA
  7421                                  res_low:
  7422 00001A97 1F                      	pop	ds
  7423 00001A98 07                      	pop	es
  7424 00001A99 EB03                    	jmp	short finish_init
  7425                                  
  7426                                  ;Now, we can move the resident code to its final location, either to HIMEM
  7427                                  ;or to overlay the messages in the data segment if the user has not used the
  7428                                  ;/msg switch.
  7429                                  
  7430                                  move_code:
  7431 00001A9B E88D01                  	call	Move_res_code			; move the code
  7432                                  
  7433                                  finish_init:
  7434                                  	;jmp	RESGROUP:EndInit 		; finish initializing
  7435 00001A9E E916E8                  	jmp	EndInit
  7436                                  
  7437                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7438                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)
  7439                                  
  7440                                  GetStrLen:
  7441                                  ;	Get length of string pointed to by DS:SI. Length includes NULL.
  7442                                  ;	Length is returned in CX
  7443                                  
  7444                                  	; MSDOS 3.3 & MSDOS 6.0
  7445 00001AA1 31C9                    	xor	cx,cx
  7446                                  NxtChar:
  7447 00001AA3 AC                      	lodsb
  7448 00001AA4 41                      	inc	cx
  7449 00001AA5 08C0                    	or	al,al
  7450 00001AA7 75FA                    	jnz	short NxtChar
  7451 00001AA9 C3                      	retn
  7452                                  
  7453                                  	; 29/01/2023
  7454                                  Setup_Seg:
  7455                                  
  7456                                  ; If the transient has been loaded in TranSeg, then we need to use that
  7457                                  ; segment for calls to routines in the transient area. Otherwise, the current
  7458                                  ; code segment is used
  7459                                  ; Segment returned in AX.
  7460                                  
  7461                                  	; MSDOS 3.3 & MSDOS 6.0
  7462 00001AAA A1[2D02]                	mov	ax,[TrnSeg]
  7463 00001AAD 803E[2F02]01            	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
  7464 00001AB2 7405                    	je	short setup_end
  7465                                  
  7466                                  ;06/06/2023
  7467                                  %if 0
  7468                                  	push	bx
  7469                                  	mov	bx,cs
  7470                                  	;mov	ax,offset ResGroup:TranStart
  7471                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7472                                  	; 06/06/2023
  7473                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7474                                  	;mov	ax,TRANSTART
  7475                                  	;shr	ax,1
  7476                                  	;shr	ax,1
  7477                                  	;shr	ax,1
  7478                                  	;shr	ax,1
  7479                                  	; 29/01/2023
  7480                                  	mov	ax,TRANSTART>>4
  7481                                  	add	ax,bx
  7482                                  	pop	bx
  7483                                  %endif
  7484                                  	; 06/06/2023
  7485 00001AB4 8CC8                    	mov	ax,cs
  7486 00001AB6 055502                  	add	ax,TRANSTART>>4
  7487                                  
  7488                                  setup_end:
  7489 00001AB9 C3                      	retn
  7490                                  
  7491                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7492                                  ;RPRINT:
  7493                                  	; MSDOS 3.3
  7494                                  	;push	ax
  7495                                  	;call	SETUP_SEG
  7496                                  	;mov	[PRINTADD+2], ax
  7497                                  	;;call	dword ptr PRINTADD
  7498                                  	;call	far [PRINTADD]
  7499                                  	;pop	ax
  7500                                  	;retn
  7501                                  
  7502                                  	; 29/01/2023
  7503                                  	; MSDOS 6.0
  7504                                  ;***	RPrintParse - display parse error message
  7505                                  ;
  7506                                  ;	ENTRY	DX = parse error #
  7507                                  ;
  7508                                  ;	EXIT	nothing
  7509                                  ;
  7510                                  ;	USED	flags
  7511                                  ;
  7512                                  ;	EFFECTS
  7513                                  ;	  Message is displayed on stdout.
  7514                                  
  7515                                  RPrintParse:	;proc
  7516                                  	;assume	ds:ResGroup,ss:ResGroup
  7517                                  
  7518 00001ABA 52                      	push	dx				; preserve DX
  7519 00001ABB 87DA                    	xchg	bx,dx				; bx = parse error #
  7520                                  						; dx = saved BX
  7521 00001ABD 4B                      	dec	bx				; bx = parse error index, from 0
  7522 00001ABE D1E3                    	shl	bx,1				; bx = offset in word table
  7523                                  	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  7524 00001AC0 8B9F[B809]              	mov	bx,[bx+PARSMSGPTRS]
  7525 00001AC4 87DA                    	xchg	bx,dx				; dx = ptr to error msg
  7526                                  						; bx = restored
  7527 00001AC6 E86DF8                  	call	RPrint				; print the message
  7528 00001AC9 5A                      	pop	dx				; restore DX
  7529 00001ACA C3                      	retn
  7530                                  
  7531                                  ;RPrintParse	endp
  7532                                  
  7533                                  	; 29/01/2023
  7534                                  ;PATHCHRCMPR:
  7535                                  	; MSDOS 3.3
  7536                                  	;push	dx
  7537                                  	;mov	dl,[slash_chr]
  7538                                  	;;cmp	byte [RSWITCHAR],'/'
  7539                                          ;cmp	[RSWITCHAR],dl
  7540                                  	;je	short RNOSLASHT
  7541                                  	;;cmp	al,'/'
  7542                                  	;cmp	al,dl
  7543                                  	;je	short RET41 ; zf = 1 
  7544                                  ;RNOSLASHT:
  7545                                          ;;cmp	al,'\'
  7546                                  	;cmp	al,[bslash_chr]
  7547                                  ;RET41:
  7548                                  	;pop	dx
  7549                                  	;retn
  7550                                  
  7551                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7552                                  IfindE:
  7553                                  	; MSDOS 3.3 & MSDOS 6.0
  7554 00001ACB E80300                  	call	ifind				; find the name
  7555                                  	;jc	short ifind2			; carry means not found
  7556                                  	;jmp	short Iscasb1 			; scan for = sign
  7557                                  	; 29/01/2023
  7558 00001ACE 733A                    	jnc	short Iscasb1
  7559                                  ifind2:
  7560 00001AD0 C3                      	retn
  7561                                  
  7562                                  	; 29/01/2023
  7563                                  
  7564                                  ; on return of find1, es:di points to beginning of name
  7565                                  
  7566                                  ifind:
  7567 00001AD1 FC                      	cld
  7568 00001AD2 E82700                  	call	Icount0				; cx = length of name
  7569 00001AD5 8E06[DC03]              	mov	es,[EnvirSeg]
  7570 00001AD9 31FF                    	xor	di,di
  7571                                  ifind1:
  7572 00001ADB 51                      	push	cx
  7573 00001ADC 56                      	push	si
  7574 00001ADD 57                      	push	di
  7575                                  ifind11:
  7576 00001ADE AC                      	lodsb
  7577 00001ADF E83400                  	call	iupconv
  7578 00001AE2 47                      	inc	di
  7579 00001AE3 263A45FF                	cmp	al,[es:di-1]
  7580 00001AE7 7502                    	jnz	short ifind12
  7581 00001AE9 E2F3                    	loop	ifind11
  7582                                  ifind12:
  7583 00001AEB 5F                      	pop	di
  7584 00001AEC 5E                      	pop	si
  7585 00001AED 59                      	pop	cx
  7586 00001AEE 74E0                    	jz	short ifind2
  7587 00001AF0 51                      	push	cx
  7588 00001AF1 E81A00                  	call	Iscasb2 			; scan for a nul
  7589 00001AF4 59                      	pop	cx
  7590                                  	;cmp	byte [es:di],0
  7591                                  	;jnz	short ifind1
  7592                                  	;stc					; indicate not found
  7593 00001AF5 26803D01                	cmp	byte [es:di],1
  7594 00001AF9 73E0                    	jnb	short ifind1
  7595                                  	; cf=1					; indicate not found
  7596                                  ;ifind2:
  7597 00001AFB C3                      	retn
  7598                                  
  7599                                  	; 29/01/2023
  7600                                  Icount0:
  7601 00001AFC 1E                      	push	ds
  7602 00001AFD 07                      	pop	es
  7603 00001AFE 89F7                    	mov	di,si
  7604                                  
  7605 00001B00 57                      	push	di				; count number of chars until "="
  7606 00001B01 E80600                  	call	Iscasb1
  7607                                  	; 25/09/2018
  7608                                  	;jmp	short Icountx
  7609                                  	;push	di				; count number of chars until nul
  7610                                  	;call	Iscasb2
  7611                                  ;Icountx:
  7612 00001B04 59                      	pop	cx
  7613 00001B05 29CF                    	sub	di,cx
  7614 00001B07 87F9                    	xchg	di,cx
  7615 00001B09 C3                      	retn
  7616                                  
  7617                                  Iscasb1:
  7618                                  	; 29/01/2023
  7619 00001B0A B03D                    	mov	al,"="
  7620                                  	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
  7621 00001B0C EB02                    	jmp	short Iscasbx
  7622                                  Iscasb2:
  7623 00001B0E 30C0                    	xor	al,al				; scan for a nul
  7624                                  Iscasbx:
  7625 00001B10 B90001                  	mov	cx,256 ; 100h
  7626 00001B13 F2AE                    	repnz	scasb
  7627 00001B15 C3                      	retn
  7628                                  
  7629                                  	; 29/01/2023
  7630                                  ;IUPCONV:
  7631                                  	; MSDOS 3.3
  7632                                          ;;cmp	al,"a"
  7633                                  	;cmp	al,[letter_a]
  7634                                          ;jb	short IRET22
  7635                                          ;;cmp	al,"z"
  7636                                          ;cmp	al,[letter_z]
  7637                                  	;ja	short IRET22
  7638                                          ;sub	al,20h			; Lower-case changed to upper-case
  7639                                  ;IRET22:
  7640                                  	;retn
  7641                                  
  7642                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7643                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h
  7644                                  
  7645                                  	; MSDOS 6.0
  7646                                  ; *****************************************************************
  7647                                  ; *
  7648                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  7649                                  ; *
  7650                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7651                                  ; *		 the character in AL from the file upper case table
  7652                                  ; *		 in DOS if character if above ascii 128, else
  7653                                  ; *		 subtracts 20H if between "a" and "z".
  7654                                  ; *
  7655                                  ; * INPUT:	 DS	      set to resident
  7656                                  ; *		 AL	      char to be upper cased
  7657                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7658                                  ; *
  7659                                  ; * OUTPUT:	 AL	      upper cased character
  7660                                  ; *
  7661                                  ; *****************************************************************
  7662                                  
  7663                                  iupconv:	;proc	near				
  7664                                  	;assume	ds:ResGroup			;
  7665                                  
  7666 00001B16 3C80                    	cmp	al,80h				; see if char is > ascii 128
  7667 00001B18 7210                    	jb	short other_fucase		; no - upper case math
  7668 00001B1A 2C80                    	sub	al,80h				; only upper 128 chars in table
  7669 00001B1C 1E                      	push	ds				;
  7670 00001B1D 53                      	push	bx				;
  7671                                  	;lds	bx,dword ptr FUCase_Addr+1	; get table address
  7672 00001B1E C51E[5402]              	lds     bx,[FUCase_Addr+1]
  7673 00001B22 83C302                  	add	bx,2				; skip over first word
  7674                                  	;xlat	ds:byte ptr [bx]		; convert to upper case
  7675 00001B25 D7                      	xlat
  7676 00001B26 5B                      	pop	bx				;
  7677 00001B27 1F                      	pop	ds				;
  7678 00001B28 EB0A                    	jmp	short iupconv_end		; we finished - exit
  7679                                  
  7680                                  other_fucase:					;
  7681                                  	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
  7682 00001B2A 3C61                    	cmp	al,'a'
  7683 00001B2C 7206                    	jb	short iupconv_end		;     subtract 20h to get
  7684                                  	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
  7685 00001B2E 3C7A                    	cmp	al,'z'
  7686 00001B30 7702                    	ja	short iupconv_end		;
  7687 00001B32 2C20                    	sub	al,20h				; Change lower-case to upper
  7688                                  iupconv_end:					;
  7689 00001B34 C3                      	retn
  7690                                  
  7691                                  ;iupConv endp
  7692                                  
  7693                                  	; 29/01/2023
  7694                                  init_contc_specialcase:
  7695                                  	; MSDOS 3.3 & MSDOS 6.0
  7696                                  						; This routine is called if control-C
  7697 00001B35 83C406                  	add	sp,6				;  is type during the date/time prompt
  7698 00001B38 56                      	push	si				;  at initialization time.  The desired
  7699 00001B39 89D6                    	mov	si,dx				;  response is to make it look like the
  7700 00001B3B C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  7701 00001B40 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  7702 00001B41 CF                      	iret					;  a <CR> in the user's buffer, and
  7703                                  						;  returning directly to the user.
  7704                                  						; In this case the user is TCODE.
  7705                                  
  7706                                  ; ----------------------------------------------------------------------------
  7707                                  
  7708                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7709                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)
  7710                                  
  7711                                  	; MSDOS 6.0
  7712                                  ; ****************************************************************
  7713                                  ; *
  7714                                  ; * ROUTINE:	 Setup_for_messages
  7715                                  ; *
  7716                                  ; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
  7717                                  ; *		 messages as follows:
  7718                                  ; *
  7719                                  ; *		 IF /P and /MSG are entered
  7720                                  ; *		    keep PARSE and EXTENDED ERRORS in memory
  7721                                  ; *		 ELSE IF /P is entered
  7722                                  ; *		    use PARSE and EXTENDED ERRORS on disk
  7723                                  ; *		    remove PARSE ERRORS from memory
  7724                                  ; *		 ELSE
  7725                                  ; *		    remove PARSE ERRORS from memory
  7726                                  ; *		 ENDIF
  7727                                  ; *
  7728                                  ; * INPUT:	 PERMCOM	Set up with user input
  7729                                  ; *		 EXT_MSG	Set up with user input
  7730                                  ; *		 System set up to retain PARSE ERRORS
  7731                                  ; *
  7732                                  ; * OUTPUT:	 registers unchanged
  7733                                  ; *
  7734                                  ; ****************************************************************
  7735                                  
  7736                                  setup_for_messages: ;proc near		
  7737                                  
  7738 00001B42 53                      	push	bx
  7739 00001B43 1E                      	push	ds				; save data segment
  7740 00001B44 06                      	push	es				; save environment segment
  7741 00001B45 50                      	push	ax				;
  7742 00001B46 52                      	push	dx				;
  7743 00001B47 57                      	push	di				;
  7744 00001B48 8CC8                    	mov	ax,cs				; get local segment to ES and DS
  7745 00001B4A 8ED8                    	mov	ds,ax				;
  7746 00001B4C 8EC0                    	mov	es,ax				;
  7747                                  
  7748 00001B4E 803E[4002]00            	cmp	byte [PermCom],0		; was permcom set?
  7749 00001B53 743C                    	jz	short no_permcom		; No - don't worry about messages
  7750                                  
  7751                                  ;*	We're permanent. Install our message services int 2f handler.
  7752                                  
  7753 00001B55 06                      	push	es
  7754                                  	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
  7755 00001B56 B82F35                  	mov	ax,352Fh
  7756 00001B59 CD21                    	int	21h
  7757                                  			; DOS - 2+ - GET INTERRUPT VECTOR
  7758                                  			; AL = interrupt number
  7759                                  			; Return: ES:BX = value of interrupt vector
  7760 00001B5B 891E[5004]              	mov	[Int2fHandler],bx
  7761 00001B5F 8C06[5204]              	mov	[Int2fHandler+2],es
  7762 00001B63 07                      	pop	es
  7763                                  
  7764                                  ;	DS = RESGROUP seg addr
  7765                                  
  7766                                  ; M005; We will not hook int 2fh on any command.com other than the first.
  7767                                  ; M005; Carousel loads as a permanent command.com and when we exit Carousel,
  7768                                  ; M005; it just wipes our arena out. So, int 2fh is still hooked and the
  7769                                  ; M005; first int 2fh call after exit from Carousel (from the DOS terminate
  7770                                  ; M005; call) goes off into space.
  7771                                  
  7772 00001B64 803E[1024]00            	cmp	byte [FirstCom],0		; M005
  7773 00001B69 7416                    	je	short no_msg_hook		; M005
  7774                                  ;
  7775                                  ; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
  7776                                  ; M005; Carousel plays around with the interrupt vector tables. He saves it
  7777                                  ; M005; before loading a new command.com. Then, it takes hold of the current
  7778                                  ; M005; command.com's PSP and then looks at all interrupt vectors whose
  7779                                  ; M005; segment matches the command.com PSP and then updates these segments
  7780                                  ; M005; to the new command.com's PSP in his saved vector table. Whenever we
  7781                                  ; M005; we pop into his menu, he puts this saved table into the vector table.
  7782                                  ; M005; If we now quit, Carousel just wipes out command.com's arena and then
  7783                                  ; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
  7784                                  ; M005; the command.com that was wiped out and so the next int 2fh call will
  7785                                  ; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
  7786                                  ; M005; renormalize our int 2fh pointer so that its cs is not the same as the
  7787                                  ; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
  7788                                  ; M005; remains nice and happy. The renormalized pointer points at a far 
  7789                                  ; M005; jump to the actual int 2fh entry point.
  7790                                  ;
  7791 00001B6B 1E                      	push	ds				; M005
  7792                                  	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
  7793 00001B6C BA[C300]                	mov     dx,Carousel_i2f_Hook
  7794 00001B6F 83EA10                  	sub	dx,10h				; renormalize offset; M005
  7795 00001B72 8CD8                    	mov	ax,ds				; M005
  7796 00001B74 40                      	inc	ax				; Relocated cs ; M005
  7797 00001B75 8ED8                    	mov	ds,ax				; M005
  7798                                  	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
  7799 00001B77 B82F25                  	mov	ax,252Fh
  7800 00001B7A CD21                    	int	21h
  7801                                  			; DOS - SET INTERRUPT VECTOR
  7802                                  			; AL = interrupt number
  7803                                  			; DS:DX = new vector to be used for specified interrupt
  7804 00001B7C 1F                      	pop	ds				; M005
  7805                                  	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
  7806 00001B7D 8C1E[C600]              	mov	[Carousel_i2f_Hook+3],ds
  7807                                  						; patch in the cs for jump
  7808                                  no_msg_hook:					; M005
  7809 00001B81 803E[D51E]01            	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
  7810 00001B86 7516                    	jne	short permcom_end		; no /msg - exit
  7811                                  
  7812                                  permcom_slash_msg:				; Keep messages in memory
  7813                                  	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
  7814 00001B88 BF[B10C]                	mov     di,ExtMsgEnd
  7815 00001B8B 893E[5404]              	mov	[ResMsgEnd],di			; save it
  7816 00001B8F EB0D                    	jmp	short permcom_end		; exit
  7817                                  
  7818                                  no_permcom:					
  7819                                  	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
  7820 00001B91 803E[D51E]01            	cmp	byte [ext_msg],1
  7821 00001B96 7506                    	jne	short permcom_end		; no - no error
  7822                                  	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
  7823 00001B98 BA0200                  	mov	dx,2
  7824 00001B9B E81CFF                  	call	RPrintParse
  7825                                  
  7826                                  permcom_end:
  7827 00001B9E 5F                      	pop	di				;
  7828 00001B9F 5A                      	pop	dx				;
  7829 00001BA0 58                      	pop	ax				;
  7830 00001BA1 07                      	pop	es				; get environment back
  7831 00001BA2 1F                      	pop	ds				;
  7832 00001BA3 5B                      	pop	bx
  7833                                  
  7834 00001BA4 C3                      	retn					;
  7835                                  
  7836                                  ;setup_for_messages	endp
  7837                                  
  7838                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7839                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h
  7840                                  
  7841                                  	; MSDOS 6.0
  7842                                  
  7843                                  ;***	CheckHelp - print help text and exit if /? is on command line
  7844                                  ;
  7845                                  ;	ENTRY	command-line tail at 81h
  7846                                  ;
  7847                                  ;	EXIT	return if /? not found
  7848                                  ;		terminate if /? found
  7849                                  ;
  7850                                  ;	USED	AX,BX,CX,DX,SI,DI
  7851                                  ;
  7852                                  ;	EFFECTS	Help text displayed if /? found on command line
  7853                                  
  7854                                  CheckHelp:	; proc
  7855                                  	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP
  7856                                  
  7857 00001BA5 BE8100                  	mov	si,81h			; DS:SI = ptr to command-line tail
  7858                                  	;mov	di,offset RESGROUP:Parse_Command
  7859 00001BA8 BF[DA1E]                	mov	di,PARSE_COMMAND
  7860                                  					; ES:DI = ptr to primary parse block
  7861 00001BAB 31C9                    	xor	cx,cx			; CX = # positional param's found
  7862 00001BAD 31D2                    	xor	dx,dx			; DX will be ptr to result buffer
  7863                                  chParse:
  7864                                  	;call	dword ptr Init_Parse
  7865 00001BAF FF1E[CE1E]              	call	far [Init_Parse]	; call system parser
  7866                                  
  7867                                  	;;cmp	ax,END_OF_LINE
  7868                                  	;cmp	ax,-1 ; 0FFFFh	
  7869                                  	;je	short chRet		; end of command line, no /? found
  7870                                  	;;cmp	ax,RESULT_NO_ERROR
  7871                                  	;;cmp	ax,0
  7872                                  	;;je	short chWhich		; valid syntax element found
  7873                                  	;;jmp	short chParse		; go parse more
  7874                                  	;and	ax,ax ; cmp ax,0
  7875                                  	;jnz	short chParse ; jne
  7876                                  	; 10/06/2023
  7877 00001BB3 40                      	inc	ax	; cmp ax,-1
  7878 00001BB4 741B                    	jz	short chRet   ; 0FFFFh -> 0
  7879 00001BB6 48                      	dec	ax	; cmp ax,0
  7880 00001BB7 75F6                    	jnz	short chParse ; 1 -> 0
  7881                                  	; ax = 0
  7882                                  chWhich:
  7883                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
  7884 00001BB9 813E[7D1F][601F]        	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
  7885 00001BBF 7411                    	je	short chHelp		; /? found - display help & exit
  7886                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
  7887 00001BC1 813E[7D1F][461F]        	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
  7888                                  	; 06/06/2023
  7889 00001BC7 7408                    	je	short chRet		; /c found - ignore rest of line
  7890                                  	; 29/01/2023
  7891                                  	;jne	short chParse
  7892                                  	; 06/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  7893                                  	; MSDOS 6.0
  7894                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
  7895 00001BC9 813E[7D1F][6C1F]        	cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
  7896                                  	;je	short chRet		; /k found - ignore rest of line
  7897                                  	;jmp	short chParse		; anything else - ignore, keep looking
  7898                                  	; 06/06/2023
  7899 00001BCF 75DE                    	jne	short chParse
  7900                                  chRet:
  7901 00001BD1 C3                      	retn
  7902                                  chHelp:
  7903                                  	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
  7904 00001BD2 BE[DA23]                	mov	si,HelpMsgs
  7905                                  chHelpNext:
  7906 00001BD5 AD                      	lodsw					; AX = ptr to msg
  7907 00001BD6 09C0                    	or	ax,ax
  7908 00001BD8 7407                    	jz	short chHelpDone		; end of list - all done
  7909 00001BDA 89C2                    	mov	dx,ax				; DX = ptr to msg
  7910 00001BDC E857F7                  	call	RPrint				; display msg
  7911 00001BDF EBF4                    	jmp	short chHelpNext		; go do next msg
  7912                                  
  7913                                  chHelpDone:
  7914 00001BE1 CD20                    	int	20h				; terminate program
  7915                                  ;chRet:
  7916 00001BE3 C3                      	retn
  7917                                  
  7918                                  ;CheckHelp	endp
  7919                                  
  7920                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7921                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h
  7922                                  
  7923                                  	; MSDOS 6.0
  7924                                  
  7925                                  ;***** Setup_res_end -- This routine determines the resident size of COMMAND.
  7926                                  ;
  7927                                  ; It determines based on 2 factors:
  7928                                  ;	1. Is this is the first COMMAND?
  7929                                  ;	2. Is COMMAND to be loaded into HIMEM?
  7930                                  ;   The strategy works as follows:
  7931                                  ;
  7932                                  ;	if (First COMMAND)
  7933                                  ;	then if (COMMAND in HIMEM)
  7934                                  ;		ResSize = resident_data;
  7935                                  ;	     else
  7936                                  ;		ResSize = resident_data + resident_code;
  7937                                  ;	else
  7938                                  ;	   ResSize = resident_data;
  7939                                  ;
  7940                                  ; Int 2fh calls have been added to determine whether or not we are the first
  7941                                  ; COMMAND and whether DOS is in HIMEM.
  7942                                  ;
  7943                                  ;	ENTRY: ResMsgEnd = resident size of data in paras
  7944                                  ;
  7945                                  ;	EXIT:  ResSize = resident size in low memory
  7946                                  ;
  7947                                  ;	REGISTERS AFFECTED: ax,cx,dx
  7948                                  ;
  7949                                  
  7950                                  GET_HMA_ADDR	equ	4A02h
  7951                                  
  7952                                  Setup_res_end:	;proc near
  7953                                  	
  7954 00001BE4 1E                      	push	ds
  7955 00001BE5 8CC8                    	mov	ax,cs
  7956 00001BE7 8ED8                    	mov	ds,ax				;ds = RESGROUP
  7957                                  	;assume	ds:RESGROUP
  7958                                  
  7959 00001BE9 8B0E[5404]              	mov	cx,[ResMsgEnd]			;set resident size = data
  7960                                  
  7961                                  ;ifndef	ROMDOS
  7962                                  
  7963                                  ;M042 -- Begin changes
  7964                                  ;If messages are to be kept behind, we need to round up the messages to
  7965                                  ;the next para boundary. This is because we have a dummy segment between the
  7966                                  ;data and the resident code segment so that the code segment starts on a
  7967                                  ;para boundary
  7968                                  
  7969                                  	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
  7970 00001BED 81F9[B10C]              	cmp	cx,ExtMsgEnd
  7971 00001BF1 7506                    	jne	short calc_res			;no, continue
  7972 00001BF3 83C10F                  	add	cx,15				;round up
  7973 00001BF6 83E1F0                  	and	cx,0FFF0h
  7974                                  calc_res:
  7975                                  
  7976                                  ;M042 -- End changes
  7977                                  
  7978                                  	; 18/07/2024
  7979                                  	;xor	ax,ax
  7980                                         	
  7981 00001BF9 803E[1024]01            	cmp	byte [FirstCom],1		;is it first command.com?
  7982                                  	;jne	short not_first			;no, do not keep code
  7983                                  	; 06/06/2023
  7984 00001BFE 751A                    	jne	short not_first2
  7985                                  
  7986                                  ;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
  7987                                  ;bit 4 of dh is set
  7988                                  
  7989 00001C00 53                      	push	bx
  7990 00001C01 51                      	push	cx
  7991                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
  7992 00001C02 B80633                  	mov	ax,3306h
  7993 00001C05 CD21                    	int	21h
  7994                                  		; DOS - 5+ Get TRUE Version Number
  7995                                  		; (BL major, BH minor, DL revision, DH flags)
  7996 00001C07 59                      	pop	cx
  7997                                  
  7998                                  ;bugbug: remove version check after testing
  7999                                  
  8000 00001C08 80FB05                  	cmp	bl,5				;bl has true version ; M013
  8001 00001C0B 7207                    	jb	short oldver
  8002                                  
  8003 00001C0D 31C0                    	xor	ax,ax
  8004 00001C0F 80E610                  	and	dh,10h				;is DOS in HMA ; M013
  8005                                  	;pop	bx
  8006                                  	;jnz	short not_first			;DOS in HIMEM, code not
  8007                                  						;	resident
  8008                                  	; 29/01/2023
  8009 00001C12 7503                    	jnz	short not_first_pop
  8010                                  oldver:
  8011                                  	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8012                                  	; 06/06/2023
  8013                                  	;;mov	ax,81Ah ; MSDOS 5.0 and MSDOS 6.22 COMMAND.COM
  8014                                  	; 06/06/2023
  8015                                  	; 29/01/2023
  8016                                  	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
  8017                                  	; 03/05/2023
  8018 00001C14 B8FA07                  	mov	ax,EndCode-RCODE_START	; 06/06/2023
  8019                                  
  8020                                  not_first_pop:
  8021                                  	; 29/01/2023
  8022 00001C17 5B                      	pop	bx
  8023                                  
  8024                                  not_first:
  8025                                  
  8026                                  ;Note that ax = 0 (side effect of int 2fh), if the code is not to be retained
  8027                                  
  8028 00001C18 01C1                    	add	cx,ax
  8029                                  
  8030                                  not_first2:	; 06/06/2023
  8031                                  
  8032                                  ;endif	;not ROMDOS
  8033                                  
  8034 00001C1A 83C10F                  	add	cx,15				;round up to next para
  8035 00001C1D D1E9                    	shr	cx,1
  8036 00001C1F D1E9                    	shr	cx,1
  8037 00001C21 D1E9                    	shr	cx,1
  8038 00001C23 D1E9                    	shr	cx,1				;ax = para size of res code
  8039 00001C25 890E[5604]              	mov	[ResSize],cx			;store resident size
  8040                                  
  8041 00001C29 1F                      	pop	ds
  8042                                  	;assume	ds:nothing
  8043 00001C2A C3                      	retn
  8044                                  
  8045                                  ;ifndef	ROMDOS
  8046                                  
  8047                                  ;bugbug: remove this code (for version independent COMMAND) after testing
  8048                                  
  8049                                  	; 29/01/2023
  8050                                  ;oldver:
  8051                                  ;	pop	bx
  8052                                  ;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8053                                  ;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8054                                  ;	; 29/01/2023
  8055                                  ;	mov	ax,EndCode-RCODE_START
  8056                                  ;	jmp	short not_first
  8057                                  
  8058                                  ;endif	;not ROMDOS
  8059                                  
  8060                                  ;setup_res_end	endp
  8061                                  
  8062                                  ;ifndef	ROMDOS
  8063                                  
  8064                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8065                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8066                                  
  8067                                  	; MSDOS 6.0
  8068                                  ;*** Move_res_code -- This routine moves the resident code to its final 
  8069                                  ; location. We check if DOS is in HIMEM. If so, we try to load ourselves
  8070                                  ; in HIMEM. If we fail, then we remain low and update ResSize to reflect
  8071                                  ; the correct resident size. When remaining low, we have to check if we 
  8072                                  ; need to overlay the messages part of the data segment which is determined
  8073                                  ; by the /msg switch.
  8074                                  ;
  8075                                  ;	ENTRY: ResMsgEnd = end of resident data
  8076                                  ;
  8077                                  ;	EXIT:  The resident code is either up high or in its final location
  8078                                  ;		down low.
  8079                                  ;
  8080                                  ;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
  8081                                  	
  8082                                  Move_res_code:	;proc near
  8083                                  
  8084 00001C2B 1E                      	push	ds
  8085 00001C2C 06                      	push	es
  8086                                  
  8087 00001C2D 8CC8                    	mov	ax,cs
  8088 00001C2F 8ED8                    	mov	ds,ax
  8089                                  	;assume	ds:RESGROUP
  8090                                  
  8091                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
  8092 00001C31 B80633                  	mov	ax,3306h
  8093 00001C34 CD21                    	int	21h				;DOS in HIMEM?
  8094                                  		; DOS - 5+ Get TRUE Version Number
  8095                                  		; (BL major, BH minor, DL revision, DH flags)
  8096                                  
  8097 00001C36 80E610                  	and	dh,10h				; M013
  8098 00001C39 750E                    	jnz	short move_high			;yes, move code high
  8099                                  
  8100                                  ;Check if messages have been discarded or not
  8101                                  
  8102                                  load_low:
  8103 00001C3B 1E                      	push	ds
  8104 00001C3C 07                      	pop	es				;es = RESGROUP
  8105 00001C3D 8B3E[5404]              	mov	di,[ResMsgEnd]			;end offset in DATARES
  8106                                  	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
  8107                                  	;mov	bx,ExtMsgEnd
  8108                                  	; 29/01/2023
  8109 00001C41 81FF[B10C]              	cmp	di,ExtMsgEnd
  8110                                  	;cmp	di,bx				;are messages to be kept?
  8111 00001C45 7431                    	je	short no_move			;yes, dont move code
  8112                                  
  8113 00001C47 EB37                    	jmp	short setup_move		;es:di points at dest.
  8114                                  
  8115                                  move_high:
  8116                                  
  8117                                  ;We have to call DOS to get the load address in HIMEM for COMMAND
  8118                                  ;We pass in bx the number of bytes we need
  8119                                  
  8120                                  	;mov	bx,offset CODERES:EndCode
  8121                                  	; 29/01/2023
  8122                                  	;;mov	bx,81Ah ; MSDOS 5.0 & MSDOS 6.22 COMMAND.COM
  8123                                  	; 06/06/2023
  8124                                  	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023 ; 06/06/2023
  8125                                  	; 03/05/2023
  8126 00001C49 BBFA07                  	mov	bx,EndCode-RCODE_START ; 06/06/2023
  8127                                  
  8128                                  ;M030;
  8129                                  ; Set di=0ffffh so that we load low in case no one answers this int 2fh
  8130                                  
  8131 00001C4C BFFFFF                  	mov	di,0FFFFh			;DT - in case no-one handles
  8132                                  						;this ; M030
  8133 00001C4F B8024A                  	mov	ax,GET_HMA_ADDR ; 4A02h
  8134 00001C52 CD2F                    	int	2Fh
  8135                                  
  8136                                  ;If the offset = 0xffff, then no HMA available
  8137                                  
  8138 00001C54 83FFFF                  	cmp	di,0FFFFh			;HMA available?
  8139 00001C57 C606[3400]01            	mov	byte [ComInHMA],1		;assume command.com in HMA
  8140 00001C5C 7522                    	jne	short setup_move		;no error, es:di = memory
  8141                                  
  8142                                  	;mov	byte [ComInHMA],0		;could not load in HMA
  8143                                  	; 29/01/2023	
  8144 00001C5E FE0E[3400]              	dec	byte [ComInHMA] ; 1 -> 0
  8145                                  
  8146                                  ;Zero means that we do not have enough HIMEM. Remain low and update
  8147                                  ;ResSize to reflect this
  8148                                  
  8149 00001C62 8B0E[5404]              	mov	cx,[ResMsgEnd]			;size of data in bytes
  8150                                  	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8151                                  	;;mov	ax,81Ah ; MSDOS 5.0 & MSDOS 6.22 COMMAND.COM
  8152                                  	;mov	ax,EndCode-RCODE_START
  8153                                  	;add	cx,ax
  8154                                  	; 06/06/2023
  8155                                  	; 29/01/2023
  8156                                  	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 ; 06/06/2023
  8157                                  	;add	cx,15				;round up to next para
  8158                                  	; 03/05/2023
  8159 00001C66 81C10908                	add	cx,(EndCode-RCODE_START)+15 ; 06/06/2023
  8160 00001C6A D1E9                    	shr	cx,1
  8161 00001C6C D1E9                    	shr	cx,1
  8162 00001C6E D1E9                    	shr	cx,1
  8163 00001C70 D1E9                    	shr	cx,1				;ax = para size of res code
  8164 00001C72 890E[5604]              	mov	[ResSize],cx			;store resident size
  8165 00001C76 EBC3                    	jmp	short load_low			;let code remain low
  8166                                  
  8167                                  no_move:
  8168                                  	; 05/05/2023
  8169                                  	;mov	cl,4
  8170 00001C78 83C70F                  	add	di,0Fh
  8171 00001C7B 83E7F0                  	and	di,0FFF0h			;round it to a para offset
  8172 00001C7E EB0B                    	jmp	short patch_up
  8173                                  
  8174                                  setup_move:
  8175                                  	;mov	si,offset RESGROUP:StartCode
  8176                                  	; 03/05/2023
  8177 00001C80 BE[C00C]                	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
  8178                                  				; 0D40h for MSDOS 5.0 COMMAND.COM
  8179                                  	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
  8180                                  	;mov	cx,81Ah ; MSDOS 5.0 & MSDOS 6.22 COMMAND.COM
  8181                                  	; 06/06/2023
  8182                                  	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8183                                  	; 03/05/2023
  8184 00001C83 B9FA07                  	mov	cx,EndCode-RCODE_START	; 06/06/2023
  8185                                  
  8186 00001C86 FC                      	cld
  8187 00001C87 57                      	push	di				;need di for patching offset
  8188 00001C88 F3A4                    	rep	movsb
  8189 00001C8A 5F                      	pop	di
  8190                                  
  8191                                  patch_up:
  8192 00001C8B E86901                  	call	patch_stub
  8193 00001C8E 07                      	pop	es
  8194 00001C8F 1F                      	pop	ds
  8195                                  	;assume	ds:nothing
  8196 00001C90 C3                      	retn
  8197                                  
  8198                                  ;Move_res_code endp
  8199                                  
  8200                                  ;else	;ROMDOS
  8201                                  ;
  8202                                  ;;***	Move_res_code - ROMDOS version - locate ROM resident
  8203                                  ;
  8204                                  ;Move_res_code	proc
  8205                                  ;
  8206                                  ;	push	es
  8207                                  ;
  8208                                  ;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
  8209                                  ;	call	patch_stub
  8210                                  ;
  8211                                  ;	pop	es
  8212                                  ;	ret
  8213                                  ;
  8214                                  ;Move_res_code	endp
  8215                                  ;
  8216                                  ;	assume	ds:NOTHING		; to match ending assume above
  8217                                  ;
  8218                                  ;endif	;ROMDOS
  8219                                  
  8220                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8221                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8222                                  
  8223                                  	; MSDOS 6.0
  8224                                  ;*** Alloc_env -- This routine allocates the temporary environment for the
  8225                                  ; Init code to initialize the COMSPEC. This is not a complete environment. 
  8226                                  ; Later on, at EndInit time, a proper sized environment is allocated and
  8227                                  ; the contents of this temporary environment are copied to it. This routine
  8228                                  ; will not be called in case a valid environment is passed to command.com
  8229                                  ;
  8230                                  ;       ENTRY:  FirstCom and initial EnvirSeg set
  8231                                  ;
  8232                                  ;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
  8233                                  ;
  8234                                  ;       REGISTERS AFFECTED: ax,bx,cx,dx
  8235                                  
  8236                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8237                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:1F3Fh
  8238                                  
  8239                                  alloc_env:	;proc near
  8240                                  	;assume ds:nothing
  8241                                  	
  8242 00001C91 1E                              push    ds
  8243 00001C92 06                      	push	es
  8244 00001C93 56                      	push	si
  8245 00001C94 57                      	push	di
  8246                                  
  8247                                  ; 07/06/2023
  8248                                  ; 29/01/2023 - MSDOS 6.0 COMMAND.COM
  8249                                  ;%if 0
  8250                                  %if 1 
  8251 00001C95 16                              push    ss
  8252 00001C96 1F                              pop     ds
  8253                                  	;assume ds:RESGROUP
  8254                                  
  8255 00001C97 A1[DC03]                        mov     ax,[EnvirSeg]
  8256                                  
  8257 00001C9A 803E[881E]00                    cmp	byte [AllocedEnv],0
  8258 00001C9F 7403                            je	short alloc_cont
  8259 00001CA1 E94801                          jmp     alloc_done
  8260                                  
  8261                                  alloc_cont:
  8262 00001CA4 29FF                            sub     di,di                           ; default start
  8263                                          ;mov	bx,SIZE Environment             ; default size needed
  8264                                  	; 29/01/2023
  8265 00001CA6 BBB400                  	mov	bx,ENVIRONSIZ	; mov bx,180 ; 07/06/2023
  8266                                  
  8267 00001CA9 803E[1024]00                    cmp	byte [FirstCom],0		; first COMMAND.COM?
  8268 00001CAE 747E                            je	short alloc_seg			; no
  8269                                  
  8270                                  ;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
  8271                                  ;   Record their respective locations and do not add the default vars.
  8272                                  
  8273 00001CB0 09C0                    	or      ax,ax
  8274 00001CB2 7476                    	jz	short alloc_new			; no previous environment
  8275                                  
  8276 00001CB4 8EC0                            mov     es,ax
  8277                                  	;assume es:nothing
  8278                                  
  8279                                  _find_path:
  8280 00001CB6 B000                            mov     al,0
  8281 00001CB8 29FF                            sub     di,di
  8282                                  comp_path:
  8283 00001CBA AE                              scasb                                   ; end of env?
  8284 00001CBB 7417                    	je	short _find_prompt		; yes
  8285 00001CBD 4F                              dec     di
  8286 00001CBE B90500                          mov     cx,PathStrLen ; mov cx,5 ; "PATH="
  8287                                          ;mov	si,offset RESGROUP:PathString
  8288 00001CC1 BE[891E]                	mov	si,PathString	; "PATH="
  8289 00001CC4 F3A6                            repe    cmpsb
  8290 00001CC6 7407                            je	short got_path
  8291 00001CC8 B90001                          mov	cx,256
  8292 00001CCB F2AE                            repne   scasb                           ; find next NULL
  8293 00001CCD EBEB                            jmp     short comp_path
  8294                                  
  8295                                  got_path:
  8296 00001CCF C606[891E]00                    mov	byte [PathString],0		; don't add it
  8297                                  
  8298                                  _find_prompt:
  8299 00001CD4 29FF                            sub     di,di
  8300                                  comp_prompt:
  8301 00001CD6 AE                      	scasb                                   ; end of env?
  8302 00001CD7 7417                    	je	short find_comspec		; yes
  8303 00001CD9 4F                      	dec     di
  8304 00001CDA B90700                  	mov     cx,PrmptStrLen2	; mov cx,7
  8305                                  	;mov	si,offset RESGROUP:PrmptString
  8306 00001CDD BE[9F1E]                	mov	si,PrmptString	; "PROMPT=$P$G"   
  8307 00001CE0 F3A6                            repe    cmpsb
  8308 00001CE2 7407                            je	short got_prompt
  8309 00001CE4 B90001                          mov     cx,256
  8310 00001CE7 F2AE                            repne   scasb                           ; find next NULL
  8311 00001CE9 EBEB                            jmp	short comp_prompt
  8312                                  
  8313                                  got_prompt:
  8314 00001CEB C606[9F1E]00            	mov	byte [PrmptString],0		; don't add it
  8315                                  
  8316                                  find_comspec:
  8317 00001CF0 29FF                            sub     di,di
  8318                                  comp_comspec:
  8319 00001CF2 AE                              scasb                                   ; end of env?
  8320 00001CF3 7423                            je	short got_envend		; yes
  8321 00001CF5 4F                              dec     di
  8322 00001CF6 B90800                          mov	cx,ComspStrLen	; mov cx,8
  8323                                  	;mov	si,offset RESGROUP:ComspString
  8324 00001CF9 BE[AD1E]                	mov	si,ComspString	; "COMSPEC=\COMMAND.COM"
  8325 00001CFC F3A6                            repe    cmpsb
  8326 00001CFE 7407                            je	short got_comspec
  8327 00001D00 B90001                          mov     cx,256
  8328 00001D03 F2AE                            repne   scasb                           ; find next NULL
  8329 00001D05 EBEB                            jmp	short comp_comspec
  8330                                  
  8331                                  got_comspec:
  8332 00001D07 893E[AB1E]                      mov     [ComspOffset],di
  8333                                  
  8334                                  find_envend:
  8335 00001D0B 29FF                            sub     di,di
  8336 00001D0D B90080                          mov     cx,ENVBIG	; 32768		; max env size
  8337                                  comp_envend:
  8338 00001D10 49                              dec     cx                              ;
  8339 00001D11 AE                              scasb                                   ; end of env?
  8340 00001D12 7404                            je	short got_envend		; yes
  8341 00001D14 F2AE                            repne   scasb
  8342 00001D16 EBF8                            jmp	short comp_envend
  8343                                  
  8344                                  got_envend:
  8345 00001D18 4F                              dec     di
  8346                                  	; 07/06/2023
  8347 00001D19 8D9DB400                	lea     bx,[di+ENVIRONSIZ]		; add room for the basics
  8348                                  
  8349                                  ;   We want to fall through to alloc_new and set up default
  8350                                  ;   path and prompt ONLY IF this is the first process;  in all other
  8351                                  ;   cases, we assume it is a bad idea to try editing the user's environment
  8352                                  
  8353 00001D1D 1E                              push    ds
  8354                                          ;mov	ds,ds:[PDB_Parent_Pid]
  8355 00001D1E 8E1E1600                        mov	ds,[PDB.PARENT_PID]
  8356                                  	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
  8357 00001D22 833E160000              	cmp	word [PDB.PARENT_PID],0
  8358 00001D27 1F                      	pop     ds
  8359 00001D28 7504                            jne	short alloc_seg			; no, we're not the first process
  8360                                                                                  ; so don't muck with the env.
  8361                                  alloc_new:
  8362 00001D2A FE06[881E]              	inc	byte [AllocedEnv]		; note we have virgin env.
  8363                                  
  8364                                  alloc_seg:
  8365                                  
  8366                                  ; Allocate default environment size
  8367                                  
  8368 00001D2E 89D9                            mov     cx,bx                           ; save byte-granular size in CX
  8369 00001D30 83C30F                          add     bx,15
  8370 00001D33 D1EB                            shr     bx,1
  8371 00001D35 D1EB                            shr     bx,1
  8372 00001D37 D1EB                            shr     bx,1
  8373 00001D39 D1EB                            shr     bx,1                            ; BX = # paras
  8374 00001D3B B448                    	mov	ah,ALLOC ; 48h
  8375 00001D3D CD21                    	int	21h
  8376 00001D3F 7303                            jnc	short init_ok
  8377 00001D41 E9AD00                          jmp     init_nomem                      ; insufficient memory, error
  8378                                  
  8379                                  ; If a previous environment existed (ie, DI != 0), then copy it into
  8380                                  ; the new buffer
  8381                                  
  8382                                  init_ok:
  8383 00001D44 8EC0                    	mov	es,ax
  8384                                  	;assume	es:nothing                      ; es = temp env segment
  8385                                  
  8386 00001D46 09FF                    	or      di,di
  8387 00001D48 7412                            jz	short copy_path
  8388                                  
  8389 00001D4A 51                              push    cx
  8390 00001D4B 1E                              push    ds
  8391 00001D4C 8E1E[DC03]                      mov     ds,[EnvirSeg]
  8392                                          ;assume ds:nothing
  8393 00001D50 29F6                            sub     si,si
  8394 00001D52 89F9                            mov     cx,di
  8395 00001D54 29FF                            sub     di,di
  8396 00001D56 F3A4                            rep     movsb
  8397 00001D58 1F                              pop     ds
  8398                                          ;assume ds:RESGROUP
  8399 00001D59 59                              pop     cx
  8400 00001D5A 29F9                            sub     cx,di
  8401                                  
  8402                                  copy_path:
  8403                                  
  8404                                  ; First clear out (the rest of) the buffer
  8405                                  
  8406 00001D5C 57                              push    di
  8407 00001D5D 29C0                            sub     ax,ax
  8408 00001D5F F3AA                            rep     stosb
  8409 00001D61 5F                              pop     di
  8410                                  
  8411                                  ; Initialize the path string (PATH=) first
  8412                                  
  8413                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8414 00001D62 BE[891E]                	mov	si,PathString
  8415 00001D65 3804                            cmp     byte [si],al			; add it?
  8416 00001D67 744D                            je	short init_prompt		; no
  8417                                  	;;mov	cx,PathStrLen+1                 ;
  8418                                  	;mov	cx,6 ; db "PATH=",0
  8419                                          ; 14/08/2024
  8420 00001D69 B106                    	mov	cl,6
  8421 00001D6B F3A4                            rep     movsb                           ;
  8422 00001D6D 3806[881E]                      cmp     [AllocedEnv],al			; virgin env?
  8423 00001D71 7443                            je	short init_prompt		; no
  8424                                  
  8425                                  ; Establish a more reasonable default for the PATH
  8426                                  
  8427                                  	;mov	ah,GET_DEFAULT_DRIVE
  8428 00001D73 B419                    	mov	ah,19h
  8429 00001D75 CD21                    	int	21h
  8430 00001D77 0441                            add     al,'A'                          ; convert to letter
  8431 00001D79 A2[8F1E]                        mov     [DefPathString],al              ;
  8432 00001D7C A2[981E]                        mov     [DefPath2String],al             ; now our default paths are complete
  8433                                  
  8434 00001D7F B200                            mov     dl,0                            ; get dir for default drive
  8435 00001D81 1E                              push    ds                              ;
  8436 00001D82 06                              push    es                              ;
  8437 00001D83 1F                              pop     ds                              ;
  8438 00001D84 C6055C                          mov     byte [di],'\'			;
  8439 00001D87 8D7501                          lea     si,[di+1]                       ; set DS:SI -> available space
  8440                                  	;mov	ah,Current_Dir                  ;
  8441 00001D8A B447                            mov	ah,47h
  8442 00001D8C CD21                    	int     21h                             ;
  8443 00001D8E 1F                              pop     ds                              ;
  8444                                  
  8445                                  	;;mov	cx,DefPathStrLen+1              ;
  8446                                  	;mov	cx,9 ; db "C:\MSDOS",0
  8447                                  	; 14/08/2024 ; ch = 0
  8448 00001D8F B109                    	mov	cl,9
  8449                                  
  8450                                  	;mov	dx,offset RESGROUP:DefPathString
  8451 00001D91 BA[8F1E]                	mov	dx,DefPathString	; "C:\MSDOS"
  8452 00001D94 89D6                    	mov	si,dx                           ;
  8453                                          ;mov	ah,CHDir                        ;
  8454 00001D96 B43B                            mov	ah,3Bh
  8455 00001D98 CD21                    	int     21h                             ;
  8456 00001D9A 730D                            jnc	short init_setpath		; DefPathString exists!
  8457                                  
  8458                                  	;;mov	cx,DefPath2StrLen+1		;
  8459                                  	;mov	cx,7 ; db "C:\DOS",0
  8460                                  	; 14/08/2024 ; ch = 0
  8461 00001D9C B107                    	mov	cl,7
  8462                                  
  8463 00001D9E BA[981E]                	mov	dx,DefPath2String	; "C:\DOS"
  8464 00001DA1 89D6                            mov     si,dx                           ;
  8465                                          ;mov	ah,CHDir                        ;
  8466 00001DA3 B43B                            mov	ah,3Bh
  8467 00001DA5 CD21                            int     21h                             ;
  8468 00001DA7 720D                            jc	short init_prompt		; DefPath2String doesn't exist
  8469                                  
  8470                                  init_setpath:
  8471 00001DA9 89FA                            mov     dx,di                           ; success
  8472 00001DAB 1E                              push    ds                              ; so restore prev dir
  8473 00001DAC 06                              push    es                              ;
  8474 00001DAD 1F                              pop     ds                              ; DS:DX -> prev dir
  8475                                          ;mov	ah,CHDir                        ;
  8476 00001DAE B43B                            mov	ah,3Bh			
  8477 00001DB0 CD21                            int     21h                             ;
  8478 00001DB2 1F                              pop     ds                              ;
  8479                                  
  8480 00001DB3 4F                              dec     di                              ; then copy in DefPathString
  8481 00001DB4 F3A4                            rep     movsb                           ; DS:SI -> "C:\\DOS\0"
  8482                                  
  8483                                  ; Initialize the default prompt
  8484                                  
  8485                                  init_prompt:
  8486 00001DB6 57                              push    di                              ;
  8487 00001DB7 29C0                            sub     ax,ax                           ;
  8488                                  	;mov	cx,64				; insure any data read in
  8489                                  	; 14/08/2024
  8490 00001DB9 B140                    	mov	cl,64  ; ch = 0
  8491 00001DBB F3AA                            rep     stosb                           ; from Current_Dir is zapped
  8492 00001DBD 5F                              pop     di                              ;
  8493                                  
  8494 00001DBE 3806[881E]              	cmp	[AllocedEnv],al			; virgin env?
  8495 00001DC2 740B                            je	short init_comspec		; no
  8496                                          ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
  8497 00001DC4 BE[9F1E]                        mov	si,PrmptString
  8498 00001DC7 3804                    	cmp     [si],al				; add it?
  8499 00001DC9 7404                            je      short init_comspec		; no
  8500                                  	;mov	cx,PrmptStrLen+1                ;
  8501 00001DCB B10C                            mov	cl,12  ; db "PROMPT=$P$G",0
  8502 00001DCD F3A4                    	rep     movsb                           ;
  8503                                  
  8504                                  ; Initialize the Comspec string
  8505                                  
  8506                                  init_comspec:
  8507 00001DCF 3906[AB1E]                      cmp	[ComspOffset],ax		; add it?
  8508 00001DD3 750E                            jne	short init_done			; no
  8509                                          ;lea	ax,[di+8]
  8510 00001DD5 8D4508                  	lea     ax,[di+ComspStrLen]             ;
  8511 00001DD8 A3[AB1E]                        mov	[ComspOffset],ax		;
  8512                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8513 00001DDB BE[AD1E]                        mov	si,ComspString
  8514                                  	;mov	cx,ComspStrLen2+1               ;
  8515 00001DDE B91500                          mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
  8516 00001DE1 F3A4                    	rep     movsb                           ;
  8517                                  
  8518                                  init_done:
  8519 00001DE3 8CC0                            mov     ax,es                           ; return env seg in ax
  8520 00001DE5 A3[DC03]                        mov     [EnvirSeg],ax			; save env seg
  8521 00001DE8 FE06[881E]                      inc	byte [AllocedEnv]		; remember that *we* alloced it
  8522                                  %endif
  8523                                  
  8524                                  ; 07/06/2023
  8525                                  ; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
  8526                                  ;%if 1
  8527                                  %if 0
  8528                                  	;mov	bx,10
  8529                                  	mov	bx,ENVIRONSIZ>>4 ; 160/16
  8530                                  	mov	ah,48h
  8531                                  	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
  8532                                  			; BX = number of 16-byte paragraphs desired
  8533                                  	jc	short init_nomem
  8534                                  
  8535                                  init_ok:
  8536                                  	mov	es,ax
  8537                                  	;assume	es:nothing                      ; es = temp env segment
  8538                                  
  8539                                  	xor	di,di
  8540                                  	mov	ax,di
  8541                                  	;mov	cx,160
  8542                                  	mov	cx,ENVIRONSIZ
  8543                                          rep	stosb
  8544                                  
  8545                                  init_pathstr:
  8546                                  
  8547                                  ; Initialize the path string (PATH=) first
  8548                                  
  8549                                  	push	ss
  8550                                  	pop	ds
  8551                                  
  8552                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8553                                  	mov	si,PathString
  8554                                  	mov	di,0
  8555                                  init_cp_pathstr:
  8556                                  	lodsb
  8557                                  	stosb
  8558                                  	or	al,al
  8559                                  	jnz	short init_cp_pathstr
  8560                                  
  8561                                  ; Initialize the Comspec string
  8562                                  
  8563                                  init_comspec:
  8564                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8565                                          mov	si,ComspString
  8566                                  	; 05/05/2023
  8567                                  	mov	di,6
  8568                                  init_cp_compstr:
  8569                                  	lodsb
  8570                                  	stosb
  8571                                  	or	al,al
  8572                                  	jnz	short init_cp_compstr
  8573                                  
  8574                                  init_done:
  8575                                          mov     ax,es                           ; return env seg in ax
  8576                                          ;mov	[EnvirSeg],ax			; save env seg
  8577                                          ;inc	byte [AllocedEnv]		; remember that *we* alloced it
  8578                                  %endif	
  8579                                  
  8580                                  	; 29/01/2023
  8581                                  alloc_done:
  8582 00001DEC 5F                      	pop	di
  8583 00001DED 5E                      	pop	si
  8584 00001DEE 07                      	pop	es
  8585 00001DEF 1F                              pop     ds
  8586                                  	;assume	ds:nothing
  8587 00001DF0 C3                      	retn
  8588                                  
  8589                                  	; 29/01/2023
  8590                                  init_nomem:
  8591                                  
  8592                                  ;We call the error routine from here. This routine never returns. It either
  8593                                  ;terminates COMMAND with error( if it is not the first invocation ) or hangs
  8594                                  ;the system ( if it is the first COMMAND.COM ).
  8595                                  
  8596 00001DF1 E80000                  	call	Alloc_error
  8597                                  
  8598                                  ;Alloc_env	endp
  8599                                  
  8600                                  ;*** Alloc_error: This routine just jumps to the actual label where we 
  8601                                  ; check if this is a permanent or secondary command.com and take the 
  8602                                  ; appropriate action.
  8603                                  ;
  8604                                  ;	ENTRY:	ds = RESGROUP = DATARES
  8605                                  ;
  8606                                  ;	EXIT:	None - does not return
  8607                                  ;
  8608                                  ;	REGISTERS AFFECTED: Does not matter
  8609                                  ;
  8610                                  
  8611                                  ;public Alloc_error
  8612                                  Alloc_error:	;proc	near
  8613                                  
  8614                                  	;jmp	RESGROUP:BadMemErr
  8615                                  	; 29/01/2023
  8616 00001DF4 E9D1EF                  	jmp	BadMemErr	
  8617                                  	
  8618                                  ;Alloc_error	endp
  8619                                  
  8620                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8621                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh
  8622                                  
  8623                                  	; MSDOS 6.0
  8624                                  ;*** Patch_stub -- This routine patches in the segment and offset values in
  8625                                  ; the stub table of the various entry points in the resident code segment.
  8626                                  ; Some of them are interrupt entry points and some of them are entries from
  8627                                  ; the transient to the resident code segment.
  8628                                  ;
  8629                                  ;	ENTRY:	ds = RESGROUP
  8630                                  ;		es:di = segment:offset of final location of resident code
  8631                                  ;
  8632                                  ;	EXIT:	All segments and offsets patched into the stub table
  8633                                  ;
  8634                                  ;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
  8635                                  
  8636                                  patch_stub:	;proc near
  8637                                  	;assume	ds:RESGROUP
  8638                                  	
  8639 00001DF7 06                      	push	es
  8640                                  
  8641 00001DF8 8CC3                    	mov	bx,es			;bx = resident code segment
  8642 00001DFA 89FA                    	mov	dx,di
  8643                                  	;mov	di,offset DATARES:Int2f_Entry
  8644 00001DFC BF[0400]                	mov	di,Int2f_Entry
  8645                                  	;mov	si,offset RESGROUP:Reloc_Table
  8646 00001DFF BE[F623]                	mov	si,Reloc_Table
  8647 00001E02 1E                      	push	ds
  8648 00001E03 07                      	pop	es			;es = RESGROUP = DATARES
  8649                                  
  8650                                  ;bx:dx = segment:offset of resident code segment
  8651                                  ;es:di = entry point table in stub
  8652                                  ;ds:si = offset table in INIT segment -- offsets of code entry points now
  8653                                  
  8654                                  	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
  8655 00001E04 B90B00                  	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
  8656                                  patchlp:
  8657 00001E07 AD                      	lodsw				;get current offset
  8658 00001E08 01D0                    	add	ax,dx			;offset it by code seg location 
  8659 00001E0A AB                      	stosw				;store offset
  8660 00001E0B 89D8                    	mov	ax,bx			
  8661 00001E0D AB                      	stosw				;store segment 
  8662 00001E0E E2F7                    	loop	patchlp
  8663                                  
  8664 00001E10 07                      	pop	es
  8665 00001E11 C3                      	retn
  8666                                  
  8667                                  ;Patch_stub	endp
  8668                                  
  8669                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8670                                  
  8671                                  	; MSDOS 6.0
  8672                                  ;*** Patch_segs -- This routine patches the segment values in the dword 
  8673                                  ; pointers that the stub uses to jump to the actual handler. These values 
  8674                                  ; are temporarily needed to handle these interrupts if they occur before
  8675                                  ; the resident is relocated to its final position and all the addresses of
  8676                                  ; the handlers have been updated.
  8677                                  ;
  8678                                  ;	ENTRY:	es = PSP segment = code segment
  8679                                  ;
  8680                                  ;	EXIT:	Current segment values patched into the jump table in the
  8681                                  ;		stub.
  8682                                  ;
  8683                                  ;	REGISTERS AFFECTED: ax, cx, di
  8684                                  
  8685                                  patch_segs:	;proc near
  8686                                  
  8687                                  	;mov	di,offset RESGROUP:Int2f_Entry
  8688 00001E12 BF[0400]                	mov	di,Int2f_Entry 
  8689 00001E15 B90400                  	mov	cx,4			;we have to patch 4 handlers
  8690 00001E18 83C702                  	add	di,2
  8691 00001E1B 8CC0                    	mov	ax,es
  8692                                  pseglp:
  8693 00001E1D AB                      	stosw				;store the segment value
  8694 00001E1E 83C702                  	add	di,2			;skip the next offset value
  8695 00001E21 E2FA                    	loop	pseglp
  8696                                  
  8697 00001E23 C3                      	retn
  8698                                  
  8699                                  ;Patch_segs	endp
  8700                                  
  8701                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8702                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch
  8703                                  
  8704                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8705                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:20D8h
  8706                                  
  8707                                  	; MSDOS 6.0
  8708                                  ;*** get_XMMAddr -- This routine gets the call address for the XMM driver
  8709                                  ; by issuing the appropriate int 2fh. This is stored in a stub variable 
  8710                                  ; and is used by the stub when we have to jump to the resident in HMA
  8711                                  ;
  8712                                  ;	ENTRY:	ds = RESGROUP
  8713                                  ;
  8714                                  ;	EXIT:	XMMCallAddr = XMM driver far call address
  8715                                  ;
  8716                                  ;	REGISTERS AFFECTED:
  8717                                  ;
  8718                                  
  8719                                  get_XMMAddr:	;proc near
  8720                                  	;assume	ds:RESGROUP
  8721                                  
  8722 00001E24 06                      	push	es
  8723                                  
  8724                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
  8725 00001E25 B80043                  	mov	ax,4300h
  8726 00001E28 CD2F                    	int	2Fh
  8727                                  		; - Multiplex - XMS - INSTALLATION CHECK
  8728                                  		; Return: AL = 80h XMS driver installed
  8729                                  		; AL <> 80h no driver
  8730 00001E2A 3C80                    	cmp	al,80h			; Q: installed
  8731 00001E2C 750D                    	jne	short cXMMexit		; N: set error, quit
  8732                                  ;
  8733                                  ; get the XMM control functions entry point, save it, we
  8734                                  ; need to call it later.
  8735                                  ;
  8736                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
  8737 00001E2E B81043                  	mov	ax,4310h
  8738 00001E31 CD2F                    	int	2Fh
  8739                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  8740                                  		; Return: ES:BX -> driver entry point
  8741                                  
  8742 00001E33 891E[3000]              	mov	[XMMCallAddr], bx
  8743 00001E37 8C06[3200]              	mov	[XMMCallAddr+2],es
  8744                                  cXMMexit:
  8745 00001E3B 07                      	pop	es
  8746 00001E3C C3                      	retn				; done
  8747                                  
  8748                                  ;get_XMMAddr	endp
  8749                                  
  8750                                  ;=============================================================================
  8751                                  ; UNINIT.ASM, MSDOS 6.0, 1991
  8752                                  ;=============================================================================
  8753                                  ; 24/09/2018 - Retro DOS v3.0
  8754                                  
  8755                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  8756                                  
  8757                                  ; TITLE	COMMAND Initialization messages
  8758                                  
  8759                                  ;INIT	SEGMENT PUBLIC PARA
  8760                                  
  8761                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8762                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8763                                  
  8764                                  	; 25/09/2018
  8765                                  	; (15 bytes filler)
  8766 00001E3D 00                      	db 0
  8767                                  	;db "25/9/2018 ETAN"
  8768                                  	; 30/01/2023
  8769                                  	;db "30/1/2023 ETAN"
  8770                                  	; 19/06/2023
  8771                                  	;db "19/6/2023 ETAN"
  8772                                  	; 31/07/2024
  8773 00001E3E 31352F382F32303234-     	db "15/8/2024 ETAN" ; 15/08/2024
  8773 00001E47 204554414E         
  8774 00001E4C 00                      	db 0
  8775                                  
  8776                                  ; 30/01/2023
  8777                                  %if 0
  8778                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  8779                                  	;dw 0
  8780                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  8781                                  	db 0Dh,0Ah
  8782                                  	db 0Dh,0Ah
  8783                                  	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  8784                                  	db 0Dh,0Ah
  8785                                  	db '             (C)Copyright Microsoft Corp 1981-1987               '
  8786                                  	db ' ',0Dh,0Ah
  8787                                  	db '                                                   ',
  8788                                  	db 0Dh,0Ah,0
  8789                                  
  8790                                  	times	43 db 20h
  8791                                  
  8792                                  _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  8793                                  BADCOMLKMES:
  8794                                  	dw _152Fh
  8795                                  
  8796                                  _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  8797                                  BADCOMACCMSG:
  8798                                  	dw _155Ah
  8799                                  
  8800                                  _1593h:	db 'Access denied',0Dh,0Ah,0
  8801                                  ACCDENERR:
  8802                                  	dw _1593h
  8803                                  
  8804                                  _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  8805                                  OUTENVMSG:
  8806                                  	dw _15A5h
  8807                                  
  8808                                  BADVERMSG:
  8809                                  	db 'Incorrect DOS version',0Dh,0Ah,'$'
  8810                                  
  8811                                  BADENVSIZMSG:
  8812                                  	db 'Invalid environment size specified',0Dh,0Ah,'$'
  8813                                  
  8814                                  HEADERPTR:
  8815                                  	dw COPYRIGHTMSG
  8816                                  %endif
  8817                                  
  8818                                  ; 30/01/2023
  8819                                  ;align 16
  8820                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8821                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
  8822                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8823                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:2100h 
  8824                                  ICONDEV:
  8825 00001E4D 2F4445562F                      db '/DEV/'
  8826 00001E52 434F4E000000000000      	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
  8827                                  BADCSPFL:
  8828 00001E5B 00                      	db 0
  8829                                  COMSPECT:
  8830 00001E5C 5C434F4D4D414E442E-     	db '\COMMAND.COM',0
  8830 00001E65 434F4D00           
  8831 00001E69 00                      	db 0
  8832                                  AUTOBAT:
  8833 00001E6A 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0,0Dh
  8833 00001E73 45432E424154000D   
  8834                                  
  8835                                  ; 22/07/2024
  8836                                  ; 07/06/2023
  8837                                  ;KAUTOBAT:
  8838                                  ;	db 0,':\KAUTOEXEC.BAT',0,0Dh
  8839                                   
  8840                                  PRDATTM:
  8841 00001E7B FF                      	db -1 ; 0FFh		; Init not to prompt for date time
  8842                                  INITADD:
  8843 00001E7C 00000000                	dd 0
  8844                                  print_add:
  8845 00001E80 [FD54]                  	dw Printf_Init
  8846 00001E82 0000                    	dw 0
  8847                                  triage_add:
  8848 00001E84 [F131]                  	dw Triage_Init
  8849 00001E86 0000                    	dw 0
  8850                                  ;CHUCKENV:
  8851                                  AllocedEnv:
  8852 00001E88 00                      	db 0
  8853                                  
  8854                                  ; 30/01/2023 - MSDOS 3.3
  8855                                  ;COMSPOFFSET:
  8856                                  ;ECOMLOC:
  8857                                  ;	;dw 0Eh
  8858                                  ;	;dw offset ENVIRONMENT:ECOMSPEC-10h
  8859                                  ;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  8860                                  ;COMSPSTRING:
  8861                                  ;	db 'COMSPEC='
  8862                                  
  8863                                  ; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
  8864                                  PathString:
  8865 00001E89 504154483D00            	db 'PATH=',0
  8866                                  PathStrLen equ $-PathString-1
  8867                                  ;;;
  8868                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8869                                  ; MSDOS 6.0
  8870                                  DefPathString:
  8871 00001E8F 433A5C4D53444F5300      	db 'C:\MSDOS',0
  8872                                  DefPathStrLen equ $-DefPathString-1
  8873                                  DefPath2String:
  8874 00001E98 433A5C444F5300          	db 'C:\DOS',0
  8875                                  DefPath2StrLen equ $-DefPath2String-1
  8876                                  
  8877                                  PrmptString:
  8878 00001E9F 50524F4D50543D2450-     	db 'PROMPT=$P$G',0
  8878 00001EA8 244700             
  8879                                  PrmptStrLen equ $-PrmptString-1
  8880                                  PrmptStrLen2 equ 7		; length of PROMPT=
  8881                                  ComspOffset:
  8882 00001EAB 0000                    	dw 0
  8883                                  ;;;
  8884                                  ComspString:
  8885 00001EAD 434F4D535045433D5C-     	db 'COMSPEC=\COMMAND.COM',0
  8885 00001EB6 434F4D4D414E442E43-
  8885 00001EBF 4F4D00             
  8886                                  ComspStrLen equ 8		; length of COMSPEC=
  8887                                  ComspStrLen2 equ $-ComspString-1
  8888                                  				; length of full COMSPEC
  8889                                  	; 29/01/2023
  8890                                  ;equal_sign:
  8891                                  ;equalsign:
  8892                                  ;	db '='
  8893                                  ;letter_a:
  8894                                  ;lcasea:
  8895                                  ;	db 'a'
  8896                                  ;letter_z:
  8897                                  ;lcasez:
  8898                                  ;	db 'z'
  8899                                  	; 30/01/2023
  8900                                  ;;slash_chr:
  8901                                  ;;	db '/'
  8902                                  ;;bslash_chr:
  8903                                  ;;	db '\'
  8904                                  ;space_chr:
  8905                                  ;;space:
  8906                                  ;	db 20h
  8907                                  ;;letter_p:
  8908                                  ;;	db 'p'
  8909                                  ;;letter_d:
  8910                                  ;;	db 'd'
  8911                                  ;;letter_c:
  8912                                  ;;	db 'c'
  8913                                  	; 16/04/2023
  8914                                  ; MSDOS 5.0 & MSDOS 6.0
  8915                                  ;scswitch:
  8916                                  ;	db 'C'		; Single command
  8917                                  ;;skswitch:
  8918                                  ;	db 'K' ; MSDOS 6.0
  8919                                  ;;letter_A:
  8920                                  ;ucasea: ; 21/01/2023 
  8921                                  ;	db 'A'
  8922                                  
  8923                                  	; 30/01/2023
  8924                                  EnvSiz:
  8925 00001EC2 0000                    	dw 0		; size user wants to allocate
  8926                                  EnvMax:
  8927 00001EC4 0000                    	dw 0		; maximum size allowed
  8928                                  OldEnv:
  8929 00001EC6 0000                    	dw 0		; envirseg at initialization
  8930                                  UsedEnv:
  8931 00001EC8 0000                    	dw 0		; amount of envirseg used
  8932                                  	; MSDOS 5.0 & MSDOS 6.0
  8933                                  PARS_MSG_OFF:
  8934 00001ECA 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
  8935                                  PARS_MSG_SEG:
  8936 00001ECC 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT
  8937                                  
  8938                                  ;Do not separate the following two words. Used to call transient PARSE routine
  8939                                  
  8940                                  Init_Parse:
  8941                                  	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
  8942                                  init_p:
  8943 00001ECE [F954]                  	dw append_parse
  8944                                  initend:
  8945 00001ED0 0000                    	dw 0		; segment address of end of init
  8946                                  TrnSize:
  8947 00001ED2 0000                    	dw 0		; size of transient in paragraphs
  8948                                  
  8949                                  ; 23/07/2024 - Retro DOS v4.2 COMMAND.COM
  8950                                  ;%if 0
  8951                                  resetenv:
  8952                                  	;dw 0		; set if we need to setblck env at endinit
  8953                                  	; 23/07/2024
  8954 00001ED4 00                      	db 0
  8955                                  ;%endif
  8956                                  
  8957                                  ext_msg:
  8958 00001ED5 00                      	db 0		; set if /MSG switch entered
  8959                                  eswitch:
  8960 00001ED6 00                      	db 0		; set if /e was entered
  8961                                  dswitch:
  8962 00001ED7 00                      	db 0		; set if /d was entered
  8963                                  parsemes_ptr:
  8964 00001ED8 0000                    	dw 0		; word to store parse error number
  8965                                  
  8966                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8967                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h
  8968                                  
  8969                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  8970                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:21A5h 
  8971                                  
  8972                                  	; MSDOS 6.0 (UINIT.ASM, 1991)
  8973                                  ;  The following parse control block is used for COMMAND. This block is
  8974                                  ;  used for parsing during initialization. The syntax for COMMAND is:
  8975                                  ;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
  8976                                  ;
  8977                                  ;  Anything on the command line after the /C switch will be passed to the
  8978                                  ;  executable command, so if /C is used, it must be specified last. The
  8979                                  ;  /MSG switch can only be specified if the /P switch is specified.
  8980                                  ;
  8981                                  ;  The /? switch causes help text to be displayed. Any other options
  8982                                  ;  on the command line are ignored. Command.com will not load if /?
  8983                                  ;  is specified.
  8984                                  
  8985                                  INTERNAT_INFO:		; used for country info after parsing is completed
  8986                                  PARSE_COMMAND:
  8987 00001EDA [DD1E]                  	dw COMMAND_PARMS
  8988 00001EDC 00                      	db 0			; no extra delimiter
  8989                                  COMMAND_PARMS:
  8990 00001EDD 0002                    	db 0,2			; 1 positional parm
  8991 00001EDF [F71E]                  	dw COMMAND_FILE
  8992 00001EE1 [F71E]                  	dw COMMAND_FILE
  8993                                          ; MSDOS 5.0
  8994                                  	;db 7			; 7 switches
  8995                                  	; MSDOS 6.0
  8996                                  	;db 8 			; 8 switches
  8997                                  	; 07/06/2023
  8998                                  	; MSDOS 6.22
  8999 00001EE3 09                      	db 9			; 9 switches
  9000 00001EE4 [001F]                  	dw COMMAND_SWITCH1
  9001 00001EE6 [0C1F]                  	dw COMMAND_SWITCH2
  9002 00001EE8 [181F]                  	dw COMMAND_SWITCH3
  9003 00001EEA [241F]                  	dw COMMAND_SWITCH4
  9004 00001EEC [3D1F]                  	dw COMMAND_SWITCH5
  9005 00001EEE [491F]                  	dw COMMAND_SWITCH6
  9006 00001EF0 [571F]                  	dw COMMAND_SWITCH7
  9007                                  	; 07/06/2023
  9008 00001EF2 [631F]                  	dw COMMAND_SWITCH8 ; MSDOS 6.0
  9009 00001EF4 [6F1F]                  	dw COMMAND_SWITCH9 ; MSDOS 6.22
  9010 00001EF6 00                      	db 0			; no keywords
  9011                                  
  9012                                  COMMAND_FILE:
  9013 00001EF7 0102                    	dw 0201h		; filespec - optional
  9014 00001EF9 0100                    	dw 1			; capitalize - file table
  9015 00001EFB [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9016 00001EFD [831F]                  	dw NO_VAL 		;
  9017 00001EFF 00                      	db 0			; no keywords
  9018                                  
  9019                                  COMMAND_SWITCH1:
  9020 00001F00 0000                    	dw 0			; no match flags
  9021 00001F02 0200                    	dw 2			; capitalize by char table
  9022 00001F04 [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9023 00001F06 [831F]                  	dw NO_VAL 		;
  9024 00001F08 01                      	db 1			; 1 keyword
  9025                                  COMMAND_P_SYN:
  9026 00001F09 2F5000                  	db '/P',0		; /P switch
  9027                                  
  9028                                  COMMAND_SWITCH2:
  9029 00001F0C 0000                    	dw 0			; no match flags
  9030 00001F0E 0200                    	dw 2			; capitalize by char table
  9031 00001F10 [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9032 00001F12 [831F]                  	dw NO_VAL 		;
  9033 00001F14 01                      	db 1			; 1 keyword
  9034                                  COMMAND_F_SYN:
  9035 00001F15 2F4600                  	db '/F',0		; /F switch
  9036                                  
  9037                                  COMMAND_SWITCH3:
  9038 00001F18 0000                    	dw 0			; no match flags
  9039 00001F1A 0200                    	dw 2			; capitalize by char table
  9040 00001F1C [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9041 00001F1E [831F]                  	dw NO_VAL 		;
  9042 00001F20 01                      	db 1			; 1 keyword
  9043                                  COMMAND_D_SYN:
  9044 00001F21 2F4400                  	db '/D',0		; /D switch
  9045                                  
  9046                                  COMMAND_SWITCH4:
  9047 00001F24 0080                    	dw 8000h		; numeric value - required
  9048 00001F26 0000                    	dw 0			; no function flags
  9049 00001F28 [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9050 00001F2A [301F]                  	dw COMMAND_E_VAL	; pointer to value list
  9051 00001F2C 01                      	db 1			; 1 keyword
  9052                                  COMMAND_E_SYN:
  9053 00001F2D 2F4500                  	db '/E',0		; /E switch
  9054                                  
  9055                                  COMMAND_E_VAL:
  9056 00001F30 01                      	db 1			;
  9057 00001F31 01                      	db 1			; 1 range
  9058 00001F32 01                      	db 1			; returned if result
  9059                                  	;dd ENVSML,ENVBIG	; minimum & maximum value
  9060                                  	; MSDOS 5.0 COMMAND.COM
  9061                                  	; (RESGROUP:1F2Bh)
  9062 00001F33 A0000000                	dd 160	 ; ENVSML
  9063 00001F37 00800000                	dd 32768 ; ENVBIG
  9064 00001F3B 00                      	db 0			; no numeric values
  9065 00001F3C 00                      	db 0			; no string values
  9066                                  
  9067                                  COMMAND_SWITCH5:
  9068 00001F3D 0000                    	dw 0			; no match flags
  9069 00001F3F 0200                    	dw 2			; capitalize by char table
  9070 00001F41 [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9071 00001F43 [831F]                  	dw NO_VAL 		;
  9072 00001F45 01                      	db 1			; 1 keyword
  9073                                  COMMAND_C_SYN:
  9074 00001F46 2F4300                  	db '/C',0		; /C switch
  9075                                  
  9076                                  COMMAND_SWITCH6:
  9077 00001F49 0000                    	dw 0			; no match flags
  9078 00001F4B 0200                    	dw 2			; capitalize by char table
  9079 00001F4D [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9080 00001F4F [831F]                  	dw NO_VAL 		;
  9081 00001F51 01                      	db 1			; 1 keyword
  9082                                  COMMAND_M_SYN:
  9083 00001F52 2F4D534700              	db '/MSG',0		; /MSG switch
  9084                                  
  9085                                  COMMAND_SWITCH7:
  9086 00001F57 0000                    	dw 0			; no match flags
  9087 00001F59 0200                    	dw 2			; capitalize by char table
  9088 00001F5B [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9089 00001F5D [831F]                  	dw NO_VAL 		;
  9090 00001F5F 01                      	db 1			; 1 keyword
  9091                                  COMMAND_?_SYN:
  9092 00001F60 2F3F00                  	db '/?',0 		; /? switch
  9093                                  
  9094                                  	; 07/06/2023
  9095                                  	; MSDOS 6.0
  9096                                  COMMAND_SWITCH8:
  9097 00001F63 0000                    	dw 0			; no match flags
  9098 00001F65 0200                    	dw 2			; capitalize by char table
  9099 00001F67 [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9100 00001F69 [831F]                  	dw NO_VAL 		;
  9101 00001F6B 01                      	db 1			; 1 keyword
  9102                                  COMMAND_K_SYN:
  9103 00001F6C 2F4B00                  	db '/K',0		; /K switch
  9104                                  
  9105                                  	; 07/06/2023
  9106                                  	; MSDOS 6.22
  9107                                  COMMAND_SWITCH9:
  9108 00001F6F 0000                    	dw 0			; no match flags
  9109 00001F71 0200                    	dw 2			; capitalize by char table
  9110 00001F73 [7B1F]                  	dw COMND1_OUTPUT	; result buffer
  9111 00001F75 [831F]                  	dw NO_VAL 		;
  9112 00001F77 01                      	db 1			; 1 keyword
  9113                                  COMMAND_Y_SYN:
  9114 00001F78 2F5900                  	db '/Y',0		; /Y switch
  9115                                  
  9116                                  COMND1_OUTPUT:
  9117                                  COMND1_TYPE:
  9118 00001F7B 00                      	db 0			; type
  9119                                  COMND1_CODE:
  9120 00001F7C 00                      	db 0			; return value
  9121                                  COMND1_SYN:
  9122 00001F7D 0000                    	dw 0			; synonym pointer
  9123                                  COMND1_ADDR:
  9124 00001F7F 00000000                	dd 0			; numeric value / address
  9125                                  				; of string value
  9126                                  NO_VAL:
  9127 00001F83 00                      	db 0			; no values
  9128                                  num_positionals:
  9129 00001F84 0000                    	dw 0			; counter for positionals
  9130                                  old_parse_ptr:
  9131 00001F86 0000                    	dw 0			; SI position before calling parser
  9132                                  
  9133                                  	; 30/01/2023
  9134                                  ;***	INITIALIZATION MESSAGES
  9135                                  ;	-------------------------
  9136                                  ;	include	comimsg.inc	;M00
  9137                                  ;-----------------------------------------------------------------------------	
  9138                                  
  9139                                  BADVERMSG:
  9140 00001F88 17                      	db 23
  9141 00001F89 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah
  9141 00001F92 20444F532076657273-
  9141 00001F9B 696F6E0D0A         
  9142                                  OUTENVMSG:
  9143 00001FA0 1A                      	db 26
  9144 00001FA1 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
  9144 00001FAA 7669726F6E6D656E74-
  9144 00001FB3 2073706163650D0A   
  9145                                  
  9146                                  ; 07/06/2023
  9147                                  ;COPYRIGHTMSG:
  9148                                  ;	db 94
  9149                                  ;	db 0Dh,0Ah
  9150                                  ;	db 0Dh,0Ah
  9151                                  ;	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
  9152                                  ;	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
  9153                                  
  9154                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9155                                  ; MSDOS 6.22 COMMAND.COM - RESGROUP:2286h
  9156                                  COPYRIGHTMSG:
  9157 00001FBB 5E                      	db 94
  9158 00001FBC 0D0A                    	db 0Dh,0Ah
  9159 00001FBE 0D0A                    	db 0Dh,0Ah
  9160 00001FC0 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R) Version 6.22',0Dh,0Ah
  9160 00001FC9 285229204D532D444F-
  9160 00001FD2 532852292056657273-
  9160 00001FDB 696F6E20362E32320D-
  9160 00001FE4 0A                 
  9161 00001FE5 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1994.',0Dh,0Ah
  9161 00001FEE 20202020284329436F-
  9161 00001FF7 70797269676874204D-
  9161 00002000 6963726F736F667420-
  9161 00002009 436F72702031393831-
  9161 00002012 2D313939342E0D0A   
  9162                                  
  9163                                  BADCOMLKMES:
  9164 0000201A 28                      	db 40
  9165 0000201B 537065636966696564-     	db 'Specified COMMAND search directory bad',0Dh,0Ah
  9165 00002024 20434F4D4D414E4420-
  9165 0000202D 736561726368206469-
  9165 00002036 726563746F72792062-
  9165 0000203F 61640D0A           
  9166                                  	; 07/06/2023
  9167                                  BADCOMACCMSG:
  9168 00002043 37                      	db 55
  9169 00002044 537065636966696564-     	db 'Specified COMMAND search directory bad, access denied',0Dh,0Ah
  9169 0000204D 20434F4D4D414E4420-
  9169 00002056 736561726368206469-
  9169 0000205F 726563746F72792062-
  9169 00002068 61642C206163636573-
  9169 00002071 732064656E6965640D-
  9169 0000207A 0A                 
  9170                                  HELPMSG1:
  9171 0000207B 38                      	db 56
  9172 0000207C 537461727473206120-     	db 'Starts a new copy of the MS-DOS command interpreter.',0Dh,0Ah
  9172 00002085 6E657720636F707920-
  9172 0000208E 6F6620746865204D53-
  9172 00002097 2D444F5320636F6D6D-
  9172 000020A0 616E6420696E746572-
  9172 000020A9 7072657465722E0D0A 
  9173 000020B2 0D0A                    	db 0Dh,0Ah
  9174                                  
  9175                                  ;HELPMSG2:
  9176                                  ;	db 70
  9177                                  ;	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
  9178                                  ;	db 0Dh,0Ah
  9179                                  ;	db 0Dh,0Ah
  9180                                  	; 07/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  9181                                  HELPMSG2:
  9182 000020B4 38                      	db 56
  9183 000020B5 434F4D4D414E44205B-     	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P [/MSG]]',0Dh,0Ah
  9183 000020BE 5B64726976653A5D70-
  9183 000020C7 6174685D205B646576-
  9183 000020D0 6963655D205B2F453A-
  9183 000020D9 6E6E6E6E6E5D205B2F-
  9183 000020E2 50205B2F4D53475D5D-
  9183 000020EB 0D0A               
  9184                                  HELPMSG3:
  9185 000020ED 2A                      	db 42
  9186 000020EE 20202020202020205B-     	db '        [/Y [/C command | /K command]]',0Dh,0Ah
  9186 000020F7 2F59205B2F4320636F-
  9186 00002100 6D6D616E64207C202F-
  9186 00002109 4B20636F6D6D616E64-
  9186 00002112 5D5D0D0A           
  9187 00002116 0D0A                    	db 0Dh,0Ah
  9188                                  
  9189                                  ;HELPMSG3:
  9190                                  HELPMSG4:
  9191 00002118 48                              db 72
  9192 00002119 20205B64726976653A-     	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
  9192 00002122 5D7061746820202020-
  9192 0000212B 537065636966696573-
  9192 00002134 207468652064697265-
  9192 0000213D 63746F727920636F6E-
  9192 00002146 7461696E696E672043-
  9192 0000214F 4F4D4D414E442E434F-
  9192 00002158 4D20               
  9193 0000215A 66696C652E0D0A          	db 'file.',0Dh,0Ah
  9194                                  ;HELPMSG4:
  9195                                  HELPMSG5:
  9196 00002161 4D                      	db 77
  9197 00002162 202064657669636520-     	db '  device          Specifies the device to use for command input and '
  9197 0000216B 202020202020202020-
  9197 00002174 537065636966696573-
  9197 0000217D 207468652064657669-
  9197 00002186 636520746F20757365-
  9197 0000218F 20666F7220636F6D6D-
  9197 00002198 616E6420696E707574-
  9197 000021A1 20616E6420         
  9198 000021A6 6F75747075742E0D0A      	db 'output.',0Dh,0Ah
  9199                                  ;HELPMSG5:
  9200                                  HELPMSG6:
  9201 000021AF 45                      	db 69
  9202 000021B0 20202F453A6E6E6E6E-     	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
  9202 000021B9 6E2020202020202020-
  9202 000021C2 536574732074686520-
  9202 000021CB 696E697469616C2065-
  9202 000021D4 6E7669726F6E6D656E-
  9202 000021DD 742073697A6520746F-
  9202 000021E6 206E6E6E6E6E206279-
  9202 000021EF 7465732E           
  9203 000021F3 0D0A                    	db 0Dh,0Ah
  9204                                  ;HELPMSG6:
  9205                                  HELPMSG7:
  9206 000021F5 4D                      	db 77
  9207 000021F6 20202F502020202020-     	db '  /P              Makes the new Command Interpreter permanent '
  9207 000021FF 202020202020202020-
  9207 00002208 4D616B657320746865-
  9207 00002211 206E657720436F6D6D-
  9207 0000221A 616E6420496E746572-
  9207 00002223 707265746572207065-
  9207 0000222C 726D616E656E7420   
  9208 00002234 2863616E2774206578-     	db '(can',27h,'t exit).',0Dh,0Ah
  9208 0000223D 6974292E0D0A       
  9209                                  ;HELPMSG7:
  9210                                  HELPMSG8:
  9211                                  	;db 80
  9212                                  	;db '  /C string       Carries out the command specified by string, and '
  9213                                  	;db 'then stops.',0Dh,0Ah
  9214                                  	; 07/06/2023
  9215 00002243 46                      	db 70
  9216 00002244 20202F4D5347202020-     	db '  /MSG            Stores all error messages in memory (requires /P).'
  9216 0000224D 202020202020202020-
  9216 00002256 53746F72657320616C-
  9216 0000225F 6C206572726F72206D-
  9216 00002268 657373616765732069-
  9216 00002271 6E206D656D6F727920-
  9216 0000227A 287265717569726573-
  9216 00002283 202F50292E         
  9217 00002288 0D0A                    	db 0Dh,0Ah
  9218                                  ;HELPMSG8:
  9219                                  HELPMSG9:
  9220                                  	;db 78
  9221                                  	;db '  /MSG            Specifies that all error messages be stored in '
  9222                                  	;db 'memory. You',0Dh,0Ah
  9223                                  ;HELPMSG9:
  9224                                  	;db 56
  9225                                  	;db '                  need to specify /P with this switch.',0Dh,0Ah
  9226 0000228A 4A                      	db 74
  9227 0000228B 20202F592020202020-     	db '  /Y              Steps through the batch program specified by /C'
  9227 00002294 202020202020202020-
  9227 0000229D 537465707320746872-
  9227 000022A6 6F7567682074686520-
  9227 000022AF 62617463682070726F-
  9227 000022B8 6772616D2073706563-
  9227 000022C1 696669656420627920-
  9227 000022CA 2F43               
  9228 000022CC 206F72202F4B2E0D0A      	db ' or /K.',0Dh,0Ah
  9229                                  
  9230                                  	; 07/06/2023
  9231                                  HELPMSG10:
  9232 000022D5 3F                      	db 63
  9233 000022D6 20202F4320636F6D6D-     	db '  /C command      Executes the specified command and returns.',0Dh,0Ah
  9233 000022DF 616E64202020202020-
  9233 000022E8 457865637574657320-
  9233 000022F1 746865207370656369-
  9233 000022FA 6669656420636F6D6D-
  9233 00002303 616E6420616E642072-
  9233 0000230C 657475726E732E0D0A 
  9234                                  HELPMSG11:
  9235 00002315 4B                      	db 75
  9236 00002316 20202F4B20636F6D6D-     	db '  /K command      Executes the specified command and continues running.'
  9236 0000231F 616E64202020202020-
  9236 00002328 457865637574657320-
  9236 00002331 746865207370656369-
  9236 0000233A 6669656420636F6D6D-
  9236 00002343 616E6420616E642063-
  9236 0000234C 6F6E74696E75657320-
  9236 00002355 72756E6E696E672E   
  9237 0000235D 0D0A                    	db 0Dh,0Ah
  9238 0000235F 0D0A                    	db 0Dh,0Ah
  9239                                  HELPMSG12:
  9240 00002361 4C                      	db 76
  9241 00002362 546865202F5020616E-     	db 'The /P and /MSG switches may be used only when COMMAND is started'
  9241 0000236B 64202F4D5347207377-
  9241 00002374 697463686573206D61-
  9241 0000237D 792062652075736564-
  9241 00002386 206F6E6C7920776865-
  9241 0000238F 6E20434F4D4D414E44-
  9241 00002398 206973207374617274-
  9241 000023A1 6564               
  9242 000023A3 206279207573696E67-     	db ' by using',0Dh,0Ah
  9242 000023AC 0D0A               
  9243                                  HELPMSG13:
  9244 000023AE 2B                      	db 43
  9245 000023AF 746865205348454C4C-     	db 'the SHELL command in the CONFIG.SYS file.',0Dh,0Ah
  9245 000023B8 20636F6D6D616E6420-
  9245 000023C1 696E2074686520434F-
  9245 000023CA 4E4649472E53595320-
  9245 000023D3 66696C652E0D0A     
  9246                                  
  9247                                  HelpMsgs:
  9248 000023DA [7B20]                          dw HELPMSG1
  9249 000023DC [B420]                  	dw HELPMSG2
  9250 000023DE [ED20]                  	dw HELPMSG3
  9251 000023E0 [1821]                  	dw HELPMSG4
  9252 000023E2 [6121]                  	dw HELPMSG5
  9253 000023E4 [AF21]                  	dw HELPMSG6
  9254 000023E6 [F521]                  	dw HELPMSG7
  9255 000023E8 [4322]                  	dw HELPMSG8
  9256 000023EA [8A22]                  	dw HELPMSG9
  9257                                  
  9258                                  	; 07/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  9259 000023EC [D522]                  	dw HELPMSG10
  9260 000023EE [1523]                  	dw HELPMSG11
  9261 000023F0 [6123]                  	dw HELPMSG12
  9262 000023F2 [AE23]                  	dw HELPMSG13
  9263                                  
  9264                                  	; 23/04/2023
  9265 000023F4 0000                    	dw 0
  9266                                  
  9267                                  ;-----------------------------------------------------------------------------
  9268                                  
  9269                                  ;SR;
  9270                                  ; This table of offsets is used by the init code to calculate the new offsets
  9271                                  ;for these labels after the resident code has been relocated
  9272                                  
  9273                                  ;Reloc_Table:
  9274                                  	;dw offset CODERES:MsgInt2fHandler
  9275                                  	;dw offset CODERES:Int_2e
  9276                                  	;dw offset CODERES:ContC
  9277                                  	;dw offset CODERES:DskErr
  9278                                  	;dw offset CODERES:Exec_Ret
  9279                                  	;dw offset CODERES:TRemCheck
  9280                                  	;dw offset CODERES:TrnLodCom1
  9281                                  	;dw offset CODERES:LodCom
  9282                                  	;dw offset CODERES:MsgRetriever
  9283                                  	;dw offset CODERES:THeadFix
  9284                                  	;dw offset CODERES:Lh_OffUnlink	; M003
  9285                                  
  9286                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9287                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h
  9288                                  
  9289                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9290                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:26C1h
  9291                                  
  9292                                  Reloc_Table:			          ; MSDOS 5.0 - 6.22 CODERES address
  9293 000023F6 1807                    	dw MsgInt2fHandler - RCODE_START  ; 738h (RESGROUP:738h+X) *
  9294 000023F8 7401                    	dw Int_2e - RCODE_START		  ; 177h (RESGROUP:177h+X) *	
  9295 000023FA 3300                    	dw ContC - RCODE_START		  ; 035h (RESGROUP:035h+X) *
  9296 000023FC 3504                    	dw DSKERR - RCODE_START		  ; 445h (RESGROUP:445h+X) *
  9297 000023FE 2700                    	dw Exec_Ret - RCODE_START	  ; 029h (RESGROUP:029h+X) *
  9298 00002400 9802                    	dw TRemCheck - RCODE_START	  ; 2A3h (RESGROUP:2A3h+X) *
  9299 00002402 1204                    	dw TrnLodCom1 - RCODE_START	  ; 422h (RESGROUP:422h+X) *
  9300 00002404 AB01                    	dw LodCom - RCODE_START		  ; 1AEh (RESGROUP:1AEh+X) *
  9301 00002406 5B07                    	dw MsgRetriever - RCODE_START	  ; 77Bh (RESGROUP:77Bh+X) *
  9302 00002408 B702                    	dw THeadFix - RCODE_START	  ; 2C2h (RESGROUP:2C2h+X) *
  9303 0000240A D407                    	dw Lh_OffUnlink - RCODE_START	  ; 7F4h (RESGROUP:7F4h+X) *
  9304                                  
  9305                                  	; 07/06/2023
  9306                                  	; X = 0D40h for MSDOS 5.0 COMMAND.COM
  9307                                  	; X = 0E50h for MSDOS 6.22 COMMAND.COM
  9308                                  	;; example:
  9309                                  	;;	MsgIn2FHandler is at RESGROUP:1588h or at CODERES:0738h
  9310                                  	;;				(in MSDOS 6.22 COMMAND.COM)
  9311                                  
  9312                                  NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2
  9313                                  
  9314                                  ResJmpTable:
  9315 0000240C 00000000                	dd 0			; stores prev stub jump table addr
  9316                                  FirstCom:
  9317 00002410 00                      	db 0			; flag set if first command.com
  9318                                  DevFlag:
  9319 00002411 00                      	db 0
  9320                                  PathFlag:
  9321 00002412 00                      	db 0
  9322                                  
  9323                                  	;; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
  9324                                  	;;times 13 db 0
  9325                                  
  9326                                  	; 07/06/2023
  9327                                  	; MSDOS 6.22 COMMAND.COM - RESGROUP:26DEh
  9328                                  	;times 2 db 0
  9329                                  
  9330                                  ; 30/01/2023
  9331                                  coderes_end equ $
  9332                                  
  9333                                  ;INIT	ENDS
  9334                                  
  9335                                  ;	END
  9336                                  
  9337                                  ;-----------------------------------------------------------------------------
  9338                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  9339                                  ;-----------------------------------------------------------------------------
  9340                                  
  9341                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  9342                                  	; 30/01/2023
  9343 00002413 00                      db	0
  9344                                  ;db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"		
  9345                                  	; 07/06/2023
  9346                                  ;db	"Retro DOS v4.2 COMMAND.COM by Erdogan Tan [2023]"
  9347 00002414 526574726F20444F53-     db	"Retro DOS v4.2 COMMAND.COM by Erdogan Tan [2024]" ; 21/07/2024
  9347 0000241D 2076342E3220434F4D-
  9347 00002426 4D414E442E434F4D20-
  9347 0000242F 6279204572646F6761-
  9347 00002438 6E2054616E205B3230-
  9347 00002441 32345D             
  9348 00002444 00                      db	0
  9349                                  
  9350                                  ;-----------------------------------------------------------------------------
  9351                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  9352                                  ;-----------------------------------------------------------------------------
  9353                                  
  9354                                  ;TAIL    SEGMENT PUBLIC PARA
  9355                                  ;        ORG     0
  9356                                  ;TRANSTART LABEL WORD
  9357                                  ;TAIL    ENDS
  9358                                  
  9359                                  ;ALIGN 16  ; 25/09/2018
  9360                                  
  9361                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9362                                  
  9363                                  numbertodiv equ ($-StartCode)+100h ; 16/04/2023
  9364                                  numbertomod equ (numbertodiv % 16)
  9365                                  
  9366                                  %if numbertomod>0 & numbertomod<16
  9367 00002445 00<rep Bh>              	times (16-numbertomod) db 0
  9368                                  %endif
  9369                                  
  9370                                  ; 30/01/2023
  9371                                  ;TRANSTART:
  9372                                  
  9373                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  9374                                  ;	times	128 db 0	
  9375                                  
  9376                                  ;-----------------------------------------------------------------------------
  9377                                  ; SEGMENT - TRANSCODE
  9378                                  ;-----------------------------------------------------------------------------
  9379                                  
  9380                                  ;TRANGROUP: ; 21/04/2018
  9381                                  
  9382                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9383                                  ;-----------------------------------------------------------------------------
  9384                                  
  9385                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  9386                                  
  9387                                  ; 21/04/2018 - Retro DOS v2.0
  9388                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  9389                                  ; (these values must be changed when transcom.s source code is changed
  9390                                  ; and data offsets are changed)
  9391                                  ;
  9392                                  ; 30/04/2018
  9393                                  ; 29/04/2018
  9394                                  
  9395                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9396                                  ;COMMAND      EQU  012CH
  9397                                  ;DATINIT      EQU  2091H
  9398                                  ;HEADCALL     EQU  428FH
  9399                                  ;TRANSPACEEND EQU  4D5CH
  9400                                  ;TRANDATAEND  EQU  3F44H
  9401                                  
  9402                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9403                                  ;TRIAGE_INIT  EQU  1F15H
  9404                                  ;PRINTF_INIT  EQU  34E0H 
  9405                                  
  9406                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  9407                                  
  9408                                  ;TPA	EQU  4293H
  9409                                  ;TRNLEN	EQU  04D6H
  9410                                  
  9411                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  9412                                  ;COMMAND      EQU  012CH
  9413                                  ;DATINIT      EQU  206FH
  9414                                  ;HEADCALL     EQU  426FH
  9415                                  ; 09/01/2023
  9416                                  ;TRANSPACEEND EQU  4D3CH
  9417                                  ;TRANDATAEND  EQU  3F24H
  9418                                  ;TRIAGE_INIT  EQU  1EF3H
  9419                                  ;PRINTF_INIT  EQU  34BFH 
  9420                                  ;
  9421                                  ;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  9422                                  
  9423                                  ;-----------------------------------------------------------------------------
  9424                                  ; ARENA.INC, MSDOS 6.0, 1991
  9425                                  ;-----------------------------------------------------------------------------
  9426                                  ; 13/10/2018 - Retro DOS 3.0
  9427                                  ; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9428                                  
  9429                                  ;BREAK <Memory arena structure>
  9430                                  
  9431                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  9432                                  
  9433                                  ; arena item
  9434                                  
  9435                                  struc ARENA
  9436 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
  9437 00000001 ????                      .owner:	resw 1		; owner of arena item
  9438 00000003 ????                      .size:	resw 1		; size in paragraphs of item
  9439                                  endstruc
  9440                                  
  9441                                  ;-----------------------------------------------------------------------------
  9442                                  ;START OF TRANSIENT PORTION
  9443                                  ;This code is loaded at the end of memory and may be overwritten by
  9444                                  ;memory-intensive user programs.
  9445                                  ;-----------------------------------------------------------------------------
  9446                                  
  9447                                  ; 16/04/2023
  9448                                  TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
  9449                                  ; 29/09/2018
  9450                                  ; 31/01/2023 
  9451                                  ;TRANSTART:	; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  9452                                  			
  9453                                  		; 09/01/2023
  9454                                  		; Offset 2320h in original MSDOS 5.0 COMMAND.COM
  9455                                  			
  9456                                  		; 07/06/2023
  9457                                  		; Offset 26E0h in original MSDOS 6.22 COMMAND.COM
  9458                                  
  9459                                  ; 25/09/2018
  9460                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  9461                                  ;
  9462                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  9463                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  9464                                  ;
  9465                                  ;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  9466                                  ;
  9467                                  ;
  9468                                  ;COMTRANS:
  9469                                  ;
  9470                                  ; 20/10/2018 - Retro DOS v3.0	
  9471                                  ;INCBIN	"TRANCOM3.BIN"
  9472                                  ;
  9473                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  9474                                  ;
  9475                                  ; 29/04/2018
  9476                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  9477                                  ;
  9478                                  ;TIMES BSS_SIZE db 0
  9479                                  ;
  9480                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  9481                                  
  9482                                  ;COMMANDCOMSIZE equ $ - 100h
  9483                                  
  9484                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9485                                  ; ============================================================================
  9486                                  ; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
  9487                                  ; ============================================================================
  9488                                  
  9489                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM (MSDOS 6.22 COMMAND.COM)
  9490                                  
  9491                                  ; ----------------------------------------------------------------------------
  9492                                  ; START OF TRANSIENT PORTION
  9493                                  ; ----------------------------------------------------------------------------
  9494                                  ; SEGMENT - TRANSCODE
  9495                                  ; ----------------------------------------------------------------------------
  9496                                  
  9497                                  ; 18/04/2023
  9498                                  section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 
  9499                                  
  9500                                  ; 18/04/2023
  9501                                  ;-----------------------------------------------------------------------------
  9502                                  ; TRANSCODE segment offset 0
  9503                                  TRANSIENTSTART:
  9504                                  
  9505                                  	; 31/01/2023
  9506 00000000 00<rep 100h>            	times 256 db 0		; Allow for 100H parameter area
  9507                                  
  9508                                  ;============================================================================
  9509                                  ; TCODE.ASM, MSDOS 6.0, 1991
  9510                                  ;============================================================================
  9511                                  ; 12/10/2018 - Retro DOS v3.0
  9512                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1)
  9513                                  
  9514                                  ;[ORG 100h]
  9515                                  
  9516                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  9517                                  
  9518                                  ; ---------------------------------------------------------------------------
  9519                                  		
  9520                                  	; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9521                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:0100h)
  9522                                  
  9523                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9524                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:0100h)
  9525                                  SETDRV:
  9526 00000100 B40E                    	mov	ah,0Eh
  9527                                  	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  9528 00000102 CD21                    	int	21h	; DOS -	SELECT DISK
  9529                                  			; DL = new default drive number
  9530                                  			;		(0 = A, 1 = B, ..)
  9531                                  			; Return: AL = number of logical drives
  9532                                  
  9533                                  ; ---------------------------------------------------------------------------
  9534                                  
  9535                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  9536                                  ; No registers (CS:IP) no flags, nothing.
  9537                                  
  9538                                  TCOMMAND:
  9539 00000104 2E8E1E[F39D]            	mov	ds,[cs:RESSEG]
  9540 00000109 B8FFFF                  	mov	ax,-1
  9541 0000010C 8706[4502]              	xchg	ax,[VerVal]
  9542 00000110 83F8FF                  	cmp	ax,-1
  9543 00000113 7404                    	je	short NOSETVER2
  9544 00000115 B42E                    	mov	ah,2Eh
  9545                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  9546 00000117 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
  9547                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  9548                                  NOSETVER2:
  9549 00000119 2EFF1E[F19D]            	call	far [cs:HEADCALL]   ; Make sure header fixed
  9550 0000011E 31ED                    	xor	bp,bp		    ; Flag transient not read
  9551 00000120 833E[4302]FF            	cmp	word [SingleCom],-1
  9552 00000125 7505                    	jne	short COMMAND
  9553                                  _$EXITPREP:
  9554 00000127 0E                      	push	cs
  9555 00000128 1F                      	pop	ds
  9556 00000129 E97025                  	jmp	_$EXIT		; Have finished the single command
  9557                                  
  9558                                  ; ---------------------------------------------------------------------------
  9559                                  ;
  9560                                  ; Main entry point from resident portion.
  9561                                  ;
  9562                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  9563                                  ;   just beginning the processing of another command.
  9564                                  ;
  9565                                  ; ---------------------------------------------------------------------------
  9566                                  
  9567                                  ; We are not always sure of the state of the world at this time. We presume
  9568                                  ; worst case and initialize the relevant registers: segments and stack.
  9569                                  
  9570                                  COMMAND:
  9571 0000012C FC                      	cld
  9572 0000012D 8CC8                    	mov	ax,cs
  9573 0000012F FA                      	cli
  9574 00000130 8ED0                    	mov	ss,ax
  9575                                  	;mov	sp,offset TRANGROUP:STACK
  9576                                  				; 07/06/2023
  9577 00000132 BC[90A9]                	mov	sp,STACK	; 0AF24h for MSDOS 6.22 COMMAND.COM
  9578                                  				; 09854h for MSDOS 5.0 COMMAND.COM
  9579 00000135 FB                      	sti
  9580                                  		
  9581 00000136 8EC0                    	mov	es,ax
  9582                                  		
  9583                                  	; MSDOS 6.0
  9584 00000138 8ED8                    	mov	ds,ax		;AN000; set DS to transient
  9585                                  	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  9586                                  	;invoke	TSYSLOADMSG	;AN000; preload messages
  9587                                  	; 31/01/2023
  9588 0000013A E8AF54                  	call	TSYSLOADMSG
  9589 0000013D C606[27A2]00            	mov	byte [append_exec],0 ;AN041; set internal append state off
  9590                                  
  9591                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9592                                  	;mov	ds,[ss:RESSEG]
  9593                                  	; 31/01/2023
  9594 00000142 8E1E[F39D]              	mov	ds,[RESSEG]
  9595 00000146 36C606[CF9B]80          	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  9596 0000014C 36C606[529C]80          	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  9597                                  
  9598                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  9599                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  9600                                  ; I guess not: the only circumstances in which we reload the command processor
  9601                                  ; is after a transient program execution. In this case, we let the current
  9602                                  ; directory lie where it may.
  9603                                  
  9604 00000152 09ED                    	or	bp,bp		; See if just read
  9605 00000154 7409                    	jz	short TESTRDIR	; Not read, check user directory
  9606 00000156 36C706[D09B]010D        	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  9607 0000015D EB17                    	jmp	short NOSETBUF
  9608                                  TESTRDIR:
  9609 0000015F 803E[3F02]00            	cmp	byte [RestDir],0
  9610 00000164 7410                    	jz	short NOSETBUF	; User directory OK
  9611 00000166 1E                      	push	ds
  9612                                  
  9613                                  ; We have an unusual situation to handle. The user *may* have changed his
  9614                                  ; directory as a result of an internal command that got aborted. Restoring it
  9615                                  ; twice may not help us: the problem may never go away. We just attempt it
  9616                                  ; once and give up.
  9617                                  
  9618 00000167 C606[3F02]00            	mov	byte [RestDir],0 ; Flag users dirs OK
  9619                                  
  9620                                  	; Restore users directory
  9621 0000016C 0E                      	push	cs
  9622 0000016D 1F                      	pop	ds
  9623 0000016E BA[D59C]                	mov	dx,USERDIR1
  9624 00000171 B43B                    	mov	ah,3Bh
  9625                                  	;mov	ah,CHDir ; 3Bh
  9626 00000173 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  9627                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
  9628 00000175 1F                      	pop	ds
  9629                                  NOSETBUF:
  9630 00000176 803E[B602]00            	cmp	byte [PipeFiles],0
  9631 0000017B 740A                    	jz	short NOPCLOSE	; Don't bother if they don't exist
  9632 0000017D 803E[B502]00            	cmp	byte [PipeFlag],0
  9633 00000182 7503                    	jnz	short NOPCLOSE	; Don't del if still piping
  9634 00000184 E8B630                  	call	PIPEDEL
  9635                                  NOPCLOSE:
  9636                                  	;mov	byte [0BE9h],0	; MSDOS 3.3
  9637                                  	; 31/01/2023
  9638 00000187 C606[3702]00            	mov	byte [ExtCom],0 ; Flag internal command
  9639 0000018C 8CC8                    	mov	ax,cs		; Get segment we're in
  9640 0000018E 8ED8                    	mov	ds,ax
  9641 00000190 50                      	push	ax
  9642                                  			; 07/06/2023 (INTERNATVARS addr = STACK addr)
  9643 00000191 BA[90A9]                	mov	dx,INTERNATVARS ; 0AF24h for MSDOS 6.22 COMMAND.COM
  9644                                  				; 09854h for MSDOS 5.0 COMMAND.COM
  9645 00000194 B80038                  	mov	ax,3800h
  9646                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
  9647 00000197 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9648                                  			; get current-country info
  9649                                  			; DS:DX	-> buffer for returned info
  9650 00000199 58                      	pop	ax
  9651 0000019A 2B06[F59D]              	sub	ax,[TPA]	; AX=size of TPA in paragraphs
  9652 0000019E 53                      	push	bx
  9653 0000019F BB1000                  	mov	bx,16
  9654 000001A2 F7E3                    	mul	bx		; DX:AX=size of TPA in bytes
  9655 000001A4 5B                      	pop	bx
  9656 000001A5 09D2                    	or	dx,dx		; See if over 64K
  9657 000001A7 7403                    	jz	short SAVSIZ	; OK if not
  9658 000001A9 B8FFFF                  	mov	ax,-1		; If so, limit to 65535 bytes
  9659                                  SAVSIZ:
  9660                                  
  9661                                  ; AX is the number of bytes free in the buffer between the resident and the
  9662                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  9663                                  
  9664 000001AC 3D0002                  	cmp	ax,512
  9665 000001AF 7603                    	jbe	short GOTSIZE
  9666                                  	;and	ax,~1FFh
  9667 000001B1 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FF
  9668                                  GOTSIZE:
  9669 000001B4 A3[129E]                	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  9670 000001B7 8E1E[F39D]              	mov	ds,[RESSEG]	; All batch work must use resident seg.
  9671                                  
  9672 000001BB F606[3B02]01            	test	byte [EchoFlag],1 
  9673 000001C0 741E                    	jz	short GETCOM	; Don't do the CRLF
  9674 000001C2 E85730                  	call	SINGLETEST
  9675 000001C5 7219                    	jb	short GETCOM
  9676 000001C7 F606[B502]FF            	test	byte [PipeFlag],0FFh ; -1
  9677 000001CC 7512                    	jnz	short GETCOM
  9678                                  				; G  Don't print prompt in FOR
  9679 000001CE F606[4902]FF            	test	byte [ForFlag],0FFh ; -1
  9680 000001D3 750B                    	jnz	short GETCOM
  9681                                  				; G  Don't print prompt if in batch
  9682 000001D5 F706[E701]FFFF          	test	word [Batch],0FFFFh ; -1
  9683 000001DB 7503                    	jnz	short GETCOM
  9684 000001DD E84129                  	call	CRLF2
  9685                                  
  9686                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9687                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:01E0h
  9688                                  GETCOM:
  9689 000001E0 833E[4302]00            	cmp     word [SingleCom],0
  9690 000001E5 750D                    	jnz     short GETCOM2
  9691 000001E7 F706[E701]FFFF          	test    word [Batch],0FFFFh
  9692 000001ED 7505                    	jnz     short GETCOM2
  9693 000001EF 8026[FC03]EF            	and     byte [Y_Flag],0EFh ; Y/N question overwrite flag ; ~10h
  9694                                  
  9695                                  ;GETCOM:	; MSDOS 5.0 COMMAND.COM
  9696                                  GETCOM2:
  9697 000001F4 C606[4E02]00            	mov	byte [Call_Flag],0 ; G Reset call flags
  9698 000001F9 C606[4F02]00            	mov	byte [Call_Batch_Flag],0
  9699 000001FE B419                    	mov	ah,19h
  9700                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  9701 00000200 CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
  9702 00000202 36A2[059E]              	mov	[ss:CURDRV],al
  9703 00000206 F606[B502]FF            	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
  9704 0000020B 7403                    	jz	short NOPIPE
  9705 0000020D E9F830                  	jmp	PIPEPROC	; Continue the pipeline
  9706                                  NOPIPE:
  9707 00000210 F606[3B02]01            	test	byte [EchoFlag],1
  9708 00000215 7417                    	jz	short NOPDRV	; No prompt if echo off
  9709 00000217 E80230                  	call	SINGLETEST
  9710 0000021A 7212                    	jb	short NOPDRV
  9711 0000021C F606[4902]FF            	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
  9712 00000221 750B                    	jnz	short NOPDRV
  9713 00000223 F706[E701]FFFF          	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
  9714 00000229 750D                    	jnz	short TESTFORBAT
  9715 0000022B E8B520                  	call	PRINT_PROMPT	; Prompt the user
  9716                                  NOPDRV:
  9717 0000022E F606[4902]FF            	test	byte [ForFlag],0FFh ; FOR has next highest precedence
  9718 00000233 7403                    	jz	short TESTFORBAT
  9719 00000235 E9760C                  	jmp	FORPROC		; Continue the FOR
  9720                                  
  9721                                  TESTFORBAT:
  9722 00000238 36C606[9E9D]00          	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  9723 0000023E C606[6402]00            	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
  9724 00000243 C606[6302]00            	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
  9725 00000248 C606[4802]00            	mov	byte [IfFlag],0	; no more ifs...
  9726 0000024D F706[E701]FFFF          	test	word [Batch],0FFFFh ; Batch has lowest precedence
  9727 00000253 7441                    	jz	short ISNOBAT
  9728                                  
  9729                                  	; 31/01/2023
  9730                                  
  9731                                  	; MSDOS 6.0
  9732                                  
  9733                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  9734                                  
  9735 00000255 06                      	push	es			;AN000; save ES
  9736 00000256 1E                      	push	ds			;AN000; save DS
  9737                                  	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  9738                                  	; 05/02/2023
  9739 00000257 B80219                  	mov	ax,1902h
  9740 0000025A 8E06[E701]              	mov	es,[Batch]		;AN000; get batch segment
  9741                                  	;mov	di,20h
  9742 0000025E BF2000                  	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
  9743 00000261 0E                      	push	cs			;AN000; get local segment to DS
  9744 00000262 1F                      	pop	ds			;AN000;
  9745                                  	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  9746 00000263 BA[529C]                	mov	dx,COMBUF
  9747 00000266 CD2F                    	int	2Fh			;AN000; call the shell
  9748                                  		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
  9749                                  		; ES:DI -> ASCIZ full filename of current batch file, with at least the
  9750                                  		; final filename element uppercased
  9751                                  		; DS:DX -> buffer for results
  9752                                  	;cmp	al,0FFh
  9753 00000268 3CFF                    	cmp	al,shell_action		;AN000; does shell have a commmand?
  9754 0000026A 1F                      	pop	ds			;AN000; restore DS
  9755 0000026B 07                      	pop	es			;AN000; restore ES
  9756 0000026C 7424                    	jz	short JDOCOM1		;AN000; yes - go process command
  9757                                  
  9758                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9759 0000026E 1E                      	push	ds
  9760 0000026F E8D503                  	call	READBAT			; Continue BATCH
  9761 00000272 1F                      	pop	ds
  9762 00000273 C606[5202]00            	mov	byte [NullFlag],0	;G reset no command flag
  9763 00000278 F706[E701]FFFF          	test	word [Batch],0FFFFh
  9764 0000027E 7512                    	jnz	short JDOCOM1		;G if batch still in progress continue
  9765 00000280 8B1E[5002]              	mov	bx,[Next_Batch]
  9766                                  	; 31/01/2023
  9767 00000284 09DB                    	or	bx,bx
  9768                                  	;cmp	bx,0			;G see if there is a new batch file
  9769 00000286 740A                    	jz	short JDOCOM1		;G no - go do command
  9770 00000288 891E[E701]              	mov	[Batch],bx		;G get segment of next batch file
  9771 0000028C C706[5002]0000          	mov	word [Next_Batch],0	;G reset next batch
  9772                                  JDOCOM1:
  9773 00000292 0E                      	push	cs
  9774 00000293 1F                      	pop	ds
  9775                                  	;jmp	short DOCOM1
  9776                                  	; 07/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
  9777 00000294 EB5D                    	jmp	short DOCOM0
  9778                                  ISNOBAT:
  9779 00000296 833E[4302]00            	cmp	word [SingleCom],0
  9780 0000029B 741D                    	jz	short REGCOM
  9781                                  	; 07/06/2023 - MSDOS 6.22 COMMAND.COM
  9782 0000029D 8B36[4102]              	mov	si,[SemiPermCom] ;  MSDOS 6.0
  9783                                  	;mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
  9784 000002A1 8736[4302]              	xchg	si,[SingleCom]
  9785 000002A5 BF[549C]                	mov	di,COMBUF+2
  9786 000002A8 31C9                    	xor	cx,cx
  9787                                  SINGLELOOP:
  9788 000002AA AC                      	lodsb
  9789 000002AB AA                      	stosb
  9790 000002AC 41                      	inc	cx
  9791 000002AD 3C0D                    	cmp	al,0Dh
  9792 000002AF 75F9                    	jnz	short SINGLELOOP
  9793 000002B1 49                      	dec	cx
  9794 000002B2 0E                      	push	cs
  9795 000002B3 1F                      	pop	ds
  9796 000002B4 880E[539C]              	mov	[COMBUF+1],cl
  9797                                  
  9798                                  ; do NOT issue a trailing CRLF...
  9799                                  
  9800                                  	;jmp	short DOCOM1
  9801                                  	; 07/06/2023
  9802                                  	; MSDOS 6.22 COMMAND.COM
  9803 000002B8 EB39                    	jmp	short DOCOM0
  9804                                  
  9805                                  	;nop
  9806                                  
  9807                                  	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
  9808                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h
  9809                                  
  9810                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9811                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:02BBh
  9812                                  
  9813                                  ; We have a normal command.  
  9814                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  9815                                  ; sometimes they aren't. At this point, we automatically close all spool
  9816                                  ; files and turn on truncation mode.
  9817                                  
  9818                                  REGCOM:
  9819                                  	;mov	ax,(ServerCall shl 8) + 9
  9820                                  	; 31/01/2023
  9821 000002BA B8095D                  	mov	ax,5D09h
  9822                                  	;mov	ax,(SERVERCALL<<8)+9
  9823 000002BD CD21                    	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  9824                                  	;mov	ax,(ServerCall shl 8) + 8
  9825 000002BF B8085D                  	mov	ax,5D08h
  9826                                  	;mov	ax,(SERVERCALL<<8)+8
  9827 000002C2 B201                    	mov	dl,1
  9828 000002C4 CD21                    	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  9829                                  			; DL = 00h redirected output is	combined
  9830                                  			;      01h redirected output placed in separate	jobs
  9831                                  			; start	new print job now
  9832 000002C6 0E                      	push	cs
  9833 000002C7 1F                      	pop	ds	; Need local segment to point to buffer
  9834 000002C8 BA[CF9B]                	mov	dx,UCOMBUF
  9835                                  
  9836                                  	; MSDOS 6.0
  9837                                  ;	Try to read interactive command line via DOSKey.
  9838                                  ;	If that fails, use DOS Buffered Keyboard Input.
  9839                                  
  9840                                  	; 31/01/2023
  9841 000002CB B81048                  	mov	ax,4810h	; AX = DOSKey Read Line function
  9842 000002CE CD2F                    	int	2Fh
  9843 000002D0 09C0                    	or	ax,ax
  9844 000002D2 7404                    	jz	short GOTCOM	; DOSKey gave us a command line
  9845                                  
  9846 000002D4 B40A                    	mov	ah,0Ah
  9847                                  	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
  9848 000002D6 CD21                    	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  9849                                  			; DS:DX	-> buffer
  9850                                  GOTCOM:
  9851 000002D8 8A0E[CF9B]              	mov	cl,[UCOMBUF]
  9852 000002DC 30ED                    	xor	ch,ch
  9853 000002DE 83C103                  	add	cx,3
  9854 000002E1 BE[CF9B]                	mov	si,UCOMBUF
  9855 000002E4 BF[529C]                	mov	di,COMBUF
  9856 000002E7 F3A4                    	rep	movsb		; Transfer it to the cooked buffer
  9857                                  
  9858                                  	; -------------
  9859                                  
  9860                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9861                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:02EDh
  9862                                  
  9863 000002E9 E83528                  	call	CRLF2
  9864 000002EC 31C0                    	xor	ax,ax
  9865 000002EE EB06                    	jmp	short DOCOM2
  9866                                  	; -------------
  9867                                  
  9868                                  DOCOM:
  9869 000002F0 E82E28                  	call	CRLF2
  9870                                  
  9871                                  	; -------------
  9872                                  
  9873                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9874                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:02F4h
  9875                                  DOCOM0:
  9876 000002F3 B80100                  	mov	ax,1
  9877                                  DOCOM2:
  9878 000002F6 1E                      	push	ds
  9879 000002F7 8E1E[F39D]              	mov     ds,[RESSEG]
  9880 000002FB A3[9B01]                	mov	[cox_Y_option],ax
  9881 000002FE 1F                      	pop	ds
  9882 000002FF BE[529C]                	mov	si,COMBUF
  9883 00000302 8A4C01                  	mov	cl,[si+1]
  9884 00000305 30ED                    	xor	ch,ch
  9885 00000307 83C602                  	add	si,2
  9886 0000030A E82501                  	call	get_cox_y_n_opt
  9887 0000030D 7303                    	jnc	short DOCOM1    ; YES answer
  9888                                  	; 07/06/2023
  9889                                  NULLCOMJ:
  9890 0000030F E90201                  	jmp	NULLCOM         ; NO answer
  9891                                  	; -------------
  9892                                  
  9893                                  	; MSDOS 5.0 & MSDOS 6.0 COMMAND.COM
  9894                                  DOCOM1:
  9895 00000312 E8932B                  	call	PRESCAN		; Cook the input buffer
  9896 00000315 7403                    	jz	short NOPIPEPROC
  9897 00000317 E96D2F                  	jmp	PIPEPROCSTRT	; Fire up the pipe
  9898                                  
  9899                                  	; 07/06/2023
  9900                                  ;NULLCOMJ:
  9901                                  	;jmp	NULLCOM
  9902                                  
  9903                                  NOPIPEPROC:
  9904 0000031A E86832                  	call	PARSELINE
  9905 0000031D 730B                    	jnb	short OKPARSE	; user error? or maybe we goofed?
  9906                                  BADPARSE:
  9907 0000031F 0E                      	push	cs
  9908 00000320 1F                      	pop	ds
  9909 00000321 BA[F391]                	mov	dx,BADNAM_PTR	; 31/01/2023
  9910 00000324 E8E051                  	call	std_eprintf
  9911 00000327 E9DAFD                  	jmp	TCOMMAND
  9912                                  
  9913                                  OKPARSE:
  9914                                  	;test	byte [ARGV0_ARG_FLAGS],2
  9915                                  	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
  9916                                  	; 01/02/2023
  9917 0000032A F606[43A2]02            	test	byte [ARG+ARGV_ELE.argflags],2
  9918 0000032F 75EE                    	jnz	short BADPARSE	; ambiguous commands not allowed
  9919                                  	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  9920 00000331 833E[01A5]00            	cmp	word [ARG+ARG_UNIT.argvcnt],0
  9921 00000336 74D7                    	jz	short NULLCOMJ
  9922                                  	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  9923 00000338 833E[46A2]00            	cmp	word [ARG+ARGV_ELE.arglen],0
  9924 0000033D 74D0                    	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  9925                                  
  9926 0000033F BE[549C]                	mov	si,COMBUF+2
  9927 00000342 BF[AB9F]                	mov	di,IDLEN
  9928                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9929                                  				; Make FCB with blank scan-off
  9930                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9931 00000345 B80129                  	mov	ax,2901h
  9932 00000348 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9933                                  			; DS:SI	-> string to parse
  9934                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9935                                  			; AL = bit mask	to control parsing
  9936                                  	;mov	bx,[ARG_ARGV]
  9937 0000034A 8B1E[41A2]              	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  9938 0000034E 807F013A                	cmp	byte [bx+1],':'	; was a drive specified?
  9939 00000352 751B                    	jne	short DRVGD	; no, use default of zero...
  9940 00000354 8A17                    	mov	dl,[bx]		; pick-up drive letter
  9941                                  	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  9942                                  	;and	dl,~20h
  9943 00000356 80E2DF                  	and	dl,0DFh		; uppercase the sucker
  9944                                  	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  9945                                  	; 31/01/2023
  9946 00000359 80EA41                  	sub	dl,'A'
  9947 0000035C 3CFF                    	cmp	al,-1		; See what PARSE said about our drive letter.
  9948 0000035E 740C                    	je	short DRVBADJ	; It was invalid.
  9949                                  	;mov	di,[ARGV0_ARGSTARTEL]
  9950 00000360 8B3E[44A2]              	mov	di,[ARG+ARGV_ELE.argstartel]
  9951 00000364 803D00                  	cmp	byte [di],0	; is there actually a command there?
  9952 00000367 7506                    	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  9953 00000369 E994FD                  	jmp	SETDRV		; and set drive to new drive spec
  9954                                  DRVBADJ:
  9955 0000036C E93B2A                  	jmp	DRVBAD
  9956                                  DRVGD:
  9957 0000036F 8A05                    	mov	al,[di]
  9958 00000371 A2[119E]                	mov	[SPECDRV],al
  9959 00000374 B020                    	mov	al,' '
  9960 00000376 B90900                  	mov	cx,9
  9961 00000379 47                      	inc	di
  9962 0000037A F2AE                    	repne	scasb		; Count number of letters in command name
  9963 0000037C B008                    	mov	al,8
  9964 0000037E 28C8                    	sub	al,cl
  9965 00000380 A2[AB9F]                	mov	[IDLEN],al	; IDLEN is truly the length
  9966 00000383 BF8100                  	mov	di,81h
  9967 00000386 56                      	push	si
  9968 00000387 BE[549C]                	mov	si,COMBUF+2	; Skip over all leading delims
  9969 0000038A E8A127                  	call	scanoff
  9970                                  
  9971                                  	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9972                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h
  9973                                  
  9974                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
  9975                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0391h
  9976                                  
  9977                                  	; MSDOS 6.0
  9978                                  ;SR;
  9979                                  ; We are going to skip over the first char always. The logic is that the
  9980                                  ;command tail can never start from the first character. The code below is 
  9981                                  ;trying to figure out the command tail and copy it to the command line 
  9982                                  ;buffer in the PSP. However, if the first character happens to be a switch
  9983                                  ;character and the user given command line is a full 128 bytes, we try to
  9984                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  9985                                  ;char overwrites the code and leads to a crash on future commands.
  9986                                  
  9987 0000038D 46                      	inc	si ;  MSDOS 6.0
  9988                                  
  9989                                  DO_SKIPCOM:
  9990 0000038E AC                      	lodsb			; move command line pointer over
  9991 0000038F E8A427                  	call	DELIM		; pathname -- have to do it ourselves
  9992 00000392 740A                    	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  9993 00000394 3C0D                    	cmp	al,0Dh		; can't always depend on argv[0].arglen
  9994 00000396 7406                    	jz	short DO_SKIPPED ; to be the same length as the user-
  9995 00000398 3A06[F79D]              	cmp	al,[SWITCHAR]	; specified command string
  9996 0000039C 75F0                    	jnz	short DO_SKIPCOM 
  9997                                  DO_SKIPPED:
  9998 0000039E 4E                      	dec	si
  9999 0000039F 31C9                    	xor	cx,cx
 10000                                  COMTAIL:
 10001 000003A1 AC                      	lodsb
 10002 000003A2 AA                      	stosb			; Move command tail to 80h
 10003 000003A3 3C0D                    	cmp	al,0Dh
 10004 000003A5 E0FA                    	loopne	COMTAIL
 10005 000003A7 4F                      	dec	di
 10006 000003A8 89FD                    	mov	bp,di
 10007 000003AA F6D1                    	not	cl
 10008 000003AC 880E8000                	mov	[80h],cl
 10009 000003B0 5E                      	pop	si
 10010                                  ;-----
 10011                                  ; Some of these comments are sadly at odds with this brave new code.
 10012                                  ;-----
 10013                                  ; If the command has 0 parameters must check here for
 10014                                  ; any switches that might be present.
 10015                                  ; SI -> first character after the command.
 10016                                  
 10017                                  	;mov	di,arg.argv[0].argsw_word
 10018                                  	;mov	di,[ARGV0_ARGSW_WORD]
 10019 000003B1 8B3E[48A2]              	mov	di,[ARG+ARGV_ELE.argsw_word]
 10020 000003B5 893E[089E]              	mov	[COMSW],di	; ah yes, the old addressing mode problem...
 10021                                  	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
 10022                                  				; s = argv[1];
 10023                                  	;mov	si,[ARGV1_ARGPOINTER]
 10024 000003B9 8B36[4CA2]              	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
 10025 000003BD 09F6                    	or	si,si		;   if (s == NULL)
 10026 000003BF 7502                    	jnz	short DOPARSE	;	s = bp; (buffer end)
 10027 000003C1 89EE                    	mov	si,bp
 10028                                  DOPARSE:
 10029 000003C3 BF5C00                  	mov	di,FCB ; 5Ch
 10030                                  	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
 10031                                  	; 01/02/2023
 10032 000003C6 B80129                  	mov	ax,2901h
 10033                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
 10034 000003C9 CD21                    	int	21h	; DOS -	PARSE FILENAME
 10035                                  			; DS:SI	-> string to parse
 10036                                  			; ES:DI	-> buffer to fill with unopened	FCB
 10037                                  			; AL = bit mask	to control parsing
 10038 000003CB A2[069E]                	mov	[PARM1],al	; Save result of parse
 10039                                  	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
 10040                                  	;mov	di,[ARGV1_ARGSW_WORD]
 10041 000003CE 8B3E[53A2]              	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
 10042 000003D2 893E[0A9E]              	mov	[ARG1S],di
 10043                                  	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
 10044                                  				; s = argv[2];
 10045                                  	;mov	si,[ARGV2_ARGPOINTER]
 10046 000003D6 8B36[57A2]              	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
 10047 000003DA 09F6                    	or	si,si		; if (s == NULL)
 10048 000003DC 7502                    	jnz	short DOPARSE2
 10049 000003DE 89EE                    	mov	si,bp		;     s = bp; (buffer end)
 10050                                  DOPARSE2:			
 10051 000003E0 BF6C00                  	mov	di,FCB+10h ; 6Ch
 10052                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
 10053 000003E3 B80129                  	mov	ax,2901h
 10054                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
 10055 000003E6 CD21                    	int	21h	; DOS -	PARSE FILENAME
 10056                                  			; DS:SI	-> string to parse
 10057                                  			; ES:DI	-> buffer to fill with unopened	FCB
 10058                                  			; AL = bit mask	to control parsing
 10059 000003E8 A2[079E]                	mov	[PARM2],al	; Save result
 10060                                  	;mov	di,[ARGV2_ARGSW_WORD]
 10061                                  	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
 10062 000003EB 8B3E[5EA2]              	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
 10063 000003EF 893E[0C9E]              	mov	[ARG2S],di
 10064                                  	;mov	di,[ARGV0_ARGSW_WORD]
 10065                                  	;mov	di,arg.argv[0].argsw_word
 10066 000003F3 8B3E[48A2]              	mov	di,[ARG+ARGV_ELE.argsw_word]
 10067 000003F7 F7D7                    	not	di		; ARGTS doesn't include the flags
 10068                                  	;and	di,[ARG_ARGSWINFO] ; from COMSW...
 10069                                  	;and	di,arg.argswinfo	
 10070 000003F9 233E[03A5]              	and	di,[ARG+ARG_UNIT.argswinfo]
 10071 000003FD 893E[0E9E]              	mov	[ARGTS],di
 10072                                  
 10073 00000401 A0[AB9F]                	mov	al,[IDLEN]
 10074 00000404 8A16[119E]              	mov	dl,[SPECDRV]
 10075 00000408 08D2                    	or	dl,dl		; if a drive was specified...
 10076 0000040A 7505                    	jnz	short EXTERNALJ1 ; it MUST be external, by this time
 10077 0000040C FEC8                    	dec	al		; (I don't know why -- old code did it)
 10078 0000040E E9EC28                  	jmp	FNDCOM		; otherwise, check internal com table
 10079                                  EXTERNALJ1:
 10080 00000411 E9EE29                  	jmp	EXTERNAL
 10081                                  NULLCOM:
 10082 00000414 8E1E[F39D]              	mov	ds,[RESSEG]
 10083 00000418 F706[E701]FFFF          	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
 10084 0000041E 7405                    	jz	short NOSETFLAG	  ;G only set flag if in batch
 10085 00000420 C606[5202]01            	mov	byte [NullFlag],1 ;G set flag to indicate no command
 10086                                  	;mov	byte [NullFlag],nullcommand ; 1
 10087                                  NOSETFLAG:
 10088 00000425 833E[4302]FF            	cmp	word [SingleCom],0FFFFh ; -1
 10089 0000042A 7403                    	je	short EXITJ
 10090 0000042C E9B1FD                  	jmp	GETCOM
 10091                                  EXITJ:
 10092 0000042F E9F5FC                  	jmp	_$EXITPREP
 10093                                  
 10094                                  ; 07/06/2023
 10095                                  ; ---------------------------------------------------------------------------
 10096                                  ; MSDOS 6.2(2) COMMAND.COM procedure only !
 10097                                  ; -----------------------------------------
 10098                                  ; Hex-Rays IDA / disassembled source code ! modified for NASM by Erdogan Tan
 10099                                  ; ---------------------------------------------------------------------------
 10100                                  
 10101                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 10102                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0436h
 10103                                  
 10104                                  get_cox_y_n_opt:
 10105 00000432 E339                    	jcxz	ccydp4		; empty	input buffer
 10106                                  ccydp0:
 10107 00000434 803C0D                  	cmp	byte [si],0Dh
 10108 00000437 7434                    	je	short ccydp4
 10109 00000439 803C0A                  	cmp	byte [si],0Ah
 10110 0000043C 742F                    	je	short ccydp4
 10111 0000043E 06                      	push	es
 10112 0000043F 8E06[F39D]              	mov	es,[RESSEG]
 10113 00000443 26A0[FC03]              	mov	al,[es:Y_Flag]
 10114 00000447 A810                    	test	al,10h		; bit 1	= 1 -> Y/N answer is needed
 10115 00000449 7421                    	jz	short ccydp3 ; cf=0 ; 07/06/2023
 10116 0000044B 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],1 ; (in) Batch file ?
 10117 00000451 7419                    	je	short ccydp3	; yes, don't check for ESCAPE
 10118 00000453 A840                    	test	al,40h		; ESCAPE status
 10119                                  				; (bit 4 is zero if Y/N	is escaped)
 10120 00000455 7417                    	jz	short ccydp5
 10121                                  ccydp1:
 10122 00000457 26F706[E701]FFFF        	test	word [es:Batch],0FFFFh
 10123 0000045E 740B                    	jz	short ccydp2
 10124 00000460 268E06[E701]            	mov	es,[es:Batch]
 10125                                  	;mov	byte [es:2],1 ; [es:BATCHSEGMENT.BatchEOF]
 10126 00000465 26C606020001            	mov	byte [es:BATCHSEGMENT.BatchEOF],1
 10127                                  ccydp2:
 10128 0000046B F9                      	stc
 10129                                  ccydp3:		; 07/06/2023 ; cf = 0
 10130 0000046C 07                      	pop	es
 10131                                  ccydp4:		; 07/06/2023 ; cf = 0
 10132 0000046D C3                      	retn
 10133                                  
 10134                                  ;ccydp3:
 10135                                  ;	pop	es
 10136                                  ;ccydp4:
 10137                                  ;	clc
 10138                                  ;	retn
 10139                                  
 10140                                  ccydp5:
 10141 0000046E 89F2                    	mov	dx,si
 10142 00000470 BB0200                  	mov	bx,2
 10143 00000473 B440                    	mov	ah,40h
 10144 00000475 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 10145                                  			; BX = file handle, CX = number	of bytes to write
 10146                                  			; DS:DX -> buffer
 10147 00000477 BA[1594]                	mov	dx,cox_Y_quest_ptr ; msg number	pointer	of ' [Y/N]?'
 10148                                  				   ; (is 1082)
 10149 0000047A E88A50                  	call	std_eprintf
 10150 0000047D 1E                      	push	ds
 10151 0000047E B83B04                  	mov	ax,1083	; cox_Y_answer number (overwrite Y/N answer letter)
 10152 00000481 B6FF                    	mov	dh,0FFh		; utility_msg_class
 10153 00000483 E86C51                  	call	TSYSGETMSG
 10154                                  	;mov	cx,'NY' ; MASM word format
 10155                                  	; NASM word format
 10156 00000486 B9594E                  	mov	cx,'YN'        ; 'YN' Yes/No (CL=Y)
 10157 00000489 7202                    	jc	short ccydp6
 10158 0000048B 8B0C                    	mov	cx,[si]
 10159                                  ccydp6:
 10160 0000048D 1F                      	pop	ds
 10161                                  ccydp7:
 10162 0000048E B408                    	mov	ah,8
 10163 00000490 CD21                    	int	21h	; DOS -	KEYBOARD INPUT,	NO ECHO
 10164                                  			; Return: AL = character
 10165 00000492 84C0                    	test	al,al
 10166 00000494 7510                    	jnz	short ccydp8
 10167 00000496 B408                    	mov	ah,8
 10168 00000498 CD21                    	int	21h	; DOS -	KEYBOARD INPUT,	NO ECHO
 10169                                  			; Return: AL = character
 10170 0000049A 3C3F                    	cmp	al,'?'
 10171 0000049C 75F0                    	jne	short ccydp7
 10172 0000049E 26800E[FC03]40          	or	byte [es:Y_Flag],40h ; bit 4, question flag
 10173 000004A4 EBB1                    	jmp	short ccydp1
 10174                                  ccydp8:
 10175 000004A6 3C1B                    	cmp	al,1Bh		; ESCAPE ?
 10176 000004A8 7509                    	jne	short ccydp9
 10177 000004AA 268026[FC03]EF          	and	byte [es:Y_Flag],0EFh ; (ESCAPE) Clear bit 4 ; ~10h
 10178                                  	;jmp	short ccydp12
 10179                                  	; 07/06/2023
 10180 000004B0 9C                      	pushf
 10181 000004B1 EB14                    	jmp	short ccydp12
 10182                                  ccydp9:
 10183 000004B3 24DF                    	and	al,0DFh		; uppercase
 10184 000004B5 38E8                    	cmp	al,ch		; NO character (N)
 10185 000004B7 7503                    	jne	short ccydp10
 10186 000004B9 F9                      	stc
 10187 000004BA EB04                    	jmp	short ccydp11	; cf = 1 -> overwrite NO answer
 10188                                  ccydp10:
 10189 000004BC 38C8                    	cmp	al,cl		; YES character	(Y)
 10190 000004BE 75CE                    	jne	short ccydp7
 10191                                  ccydp11:
 10192 000004C0 9C                      	pushf			; cf = 0 -> overwrite YES answer
 10193 000004C1 88C2                    	mov	dl,al
 10194 000004C3 B402                    	mov	ah,2
 10195 000004C5 CD21                    	int	21h	; DOS -	DISPLAY	OUTPUT
 10196                                  			; DL = character to send to standard output
 10197                                  	; 07/06/2023
 10198                                  	;popf
 10199                                  ccydp12:
 10200                                  	;pushf
 10201 000004C7 E85726                  	call	CRLF2
 10202 000004CA 9D                      	popf
 10203 000004CB 07                      	pop	es
 10204 000004CC C3                      	retn
 10205                                  
 10206                                  ;============================================================================
 10207                                  ; MSHALO.ASM, MSDOS 6.0, 1991
 10208                                  ;============================================================================
 10209                                  ; 12/10/2018 - Retro DOS v3.0
 10210                                  
 10211                                  ; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM
 10212                                  
 10213                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
 10214                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
 10215                                  ;   there is a header that describes a block of rom program.  This header
 10216                                  ;   contains information needed to initialize a module and to provide PCDOS
 10217                                  ;   with a set of reserved names for execution.
 10218                                  ;
 10219                                  ;   This header has the following format:
 10220                                  ;
 10221                                  ;   rom_header	STRUC
 10222                                  ;	Signature1  DB	55h
 10223                                  ;	Signature2  DB	AAh
 10224                                  ;	rom_length  DB	?		; number of 512 byte pieces
 10225                                  ;	init_jmp    DB	3 dup (?)
 10226                                  ;	name_list   name_struc <>
 10227                                  ;   rom_header	ENDS
 10228                                  ;
 10229                                  ;   name_struc	STRUC
 10230                                  ;	name_len    DB	?
 10231                                  ;	name_text   DB	? DUP (?)
 10232                                  ;	name_jmp    DB	3 DUP (?)
 10233                                  ;   name_struc	ENDS
 10234                                  ;
 10235                                  ;   The name list is a list of names that are reserved by a particular section
 10236                                  ;   of a module.  This list of names is terminated by a null name (length
 10237                                  ;   is zero).
 10238                                  ;
 10239                                  ;   Consider now, the PCDOS action when a user enters a command:
 10240                                  ;
 10241                                  ;	COMMAND.COM has control.
 10242                                  ;	o   If location FFFFEh has FDh then
 10243                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
 10244                                  ;		    by AAh, stop scan if we get above or = F0000H
 10245                                  ;	o	When we've found one, compare the name entered by the user
 10246                                  ;		    with the one found in the rom.  If we have a match, then
 10247                                  ;		    set up the environment for execution and do a long jump
 10248                                  ;		    to the near jump after the found name.
 10249                                  ;	o	If no more names in the list, then continue scanning the module
 10250                                  ;		    for more 55h followed by AAh.
 10251                                  ;	o   We get to this point only if there is no matching name in the
 10252                                  ;		rom.  We now look on disk for the command.
 10253                                  ;
 10254                                  ;   This gives us the flexibility to execute any rom cartridge without having
 10255                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
 10256                                  ;   want to be invisible to the DOS should not have any names in their lists
 10257                                  ;   (i.e. they have a single null name).
 10258                                  ;
 10259                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
 10260                                  ;   Clearly this version will be available on disk.  How does a user actually
 10261                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
 10262                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
 10263                                  ;   solution:
 10264                                  ;
 10265                                  ;   o	Keep things consistent and force the user to have his software named
 10266                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
 10267                                  
 10268                                  struc ROM_HEADER
 10269 00000000 ??                          .signature1: resb 1
 10270 00000001 ??                          .signature2: resb 1
 10271 00000002 ??                          .rom_length: resb 1
 10272 00000003 ??????                      .init_jmp:	 resb 3
 10273 00000006 ??                          .name_list:	 resb 1
 10274                                      .size:
 10275                                  endstruc
 10276                                  
 10277                                  struc NAME_STRUC
 10278 00000000 ??                          .name_len:	resb 1
 10279 00000001 ??                          .name_text:	resb 1
 10280 00000002 ??????                      .name_jmp:	resb 3
 10281                                      .size:	
 10282                                  endstruc
 10283                                  
 10284                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
 10285                                  
 10286                                  ; =============== S U B	R O U T	I N E =======================================
 10287                                  
 10288                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
 10289                                  
 10290                                  ; 05/02/2023
 10291                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh
 10292                                  
 10293                                  ; 07/06/2023
 10294                                  ; MSDOS 6.22 COMMAND.COM - TRANGROUP:04D5h
 10295                                  
 10296                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
 10297                                  
 10298                                  ROM_SCAN:
 10299 000004CD 06                      	push	es
 10300 000004CE 56                      	push	si
 10301 000004CF 57                      	push	di
 10302 000004D0 51                      	push	cx
 10303 000004D1 50                      	push	ax
 10304 000004D2 53                      	push	bx
 10305                                  
 10306                                  	; check for PC Jr signature in rom
 10307                                  
 10308 000004D3 B800F0                  	mov	ax,0F000h
 10309 000004D6 8EC0                    	mov	es,ax
 10310 000004D8 26803EFEFFFD            	cmp	byte [es:0FFFEh],0FDh
 10311 000004DE 7408                    	je	short SCAN_IT
 10312                                  NO_ROM:
 10313 000004E0 F8                      	clc
 10314                                  ROM_RET:
 10315 000004E1 5B                      	pop	bx
 10316 000004E2 58                      	pop	ax
 10317 000004E3 59                      	pop	cx
 10318 000004E4 5F                      	pop	di
 10319 000004E5 5E                      	pop	si
 10320 000004E6 07                      	pop	es
 10321 000004E7 C3                      	retn
 10322                                  
 10323                                  	; start scanning at C000h
 10324                                  SCAN_IT:
 10325 000004E8 B800C0                  	mov	ax,0C000h
 10326                                  SCAN_ONE:
 10327 000004EB 8EC0                    	mov	es,ax
 10328 000004ED 31FF                    	xor	di,di
 10329                                  
 10330                                  	; check for a valid header
 10331                                  SCAN_MODULE:
 10332 000004EF 26813D55AA              	cmp	word [es:di],0AA55h
 10333 000004F4 740A                    	je	short SCAN_LIST
 10334 000004F6 058000                  	add	ax,80h
 10335                                  SCAN_END:
 10336 000004F9 3D00F0                  	cmp	ax,0F000h
 10337 000004FC 72ED                    	jb	short SCAN_ONE
 10338 000004FE EBE0                    	jmp	short NO_ROM
 10339                                  
 10340                                  	; trundle down list of names
 10341                                  SCAN_LIST:
 10342                                  	;mov	bl,[es:di+2]	; number of 512-byte jobbers
 10343 00000500 268A5D02                	mov	bl,[es:di+ROM_HEADER.rom_length]
 10344 00000504 30FF                    	xor	bh,bh		; nothing in the high byte
 10345 00000506 D1E3                    	shl	bx,1
 10346 00000508 D1E3                    	shl	bx,1		; number of paragraphs
 10347 0000050A 83C37F                  	add	bx,7Fh
 10348 0000050D 83E380                  	and	bx,0FF80h	; round to 2k
 10349                                  	;mov	di,6
 10350                                  	; 05/05/2023
 10351 00000510 BF0600                  	mov	di,ROM_HEADER.name_list
 10352                                  	;nop
 10353                                  SCAN_NAME:
 10354 00000513 268A0D                  	mov	cl,[es:di]	; length of name
 10355 00000516 47                      	inc	di		; point to name
 10356 00000517 30ED                    	xor	ch,ch
 10357 00000519 09C9                    	or	cx,cx		; zero length name
 10358 0000051B 7504                    	jnz	short SCAN_TEST	; nope... compare
 10359 0000051D 01D8                    	add	ax,bx		; yep, skip to next block
 10360 0000051F EBD8                    	jmp	short SCAN_END
 10361                                  
 10362                                  	; compare a single name
 10363                                  SCAN_TEST:
 10364 00000521 89D6                    	mov	si,dx
 10365 00000523 46                      	inc	si
 10366 00000524 F3A6                    	repe	cmpsb		 ; compare name
 10367 00000526 7407                    	jz	short SCAN_FOUND ; success!
 10368                                  SCAN_NEXT:
 10369 00000528 01CF                    	add	di,cx		; failure, next name piece
 10370 0000052A 83C703                  	add	di,3
 10371 0000052D EBE4                    	jmp	short SCAN_NAME
 10372                                  
 10373                                  	; found a name. save entry location
 10374                                  SCAN_FOUND:	
 10375 0000052F 803C3F                  	cmp	byte [si],'?'
 10376 00000532 7405                    	je	short SCAN_SAVE
 10377 00000534 803C20                  	cmp	byte [si],' '
 10378 00000537 75EF                    	jne	short SCAN_NEXT
 10379                                  SCAN_SAVE:
 10380 00000539 2E8C06[A8A0]            	mov	[cs:ROM_CS],es
 10381 0000053E 2E893E[A6A0]            	mov	[cs:ROM_IP],di
 10382 00000543 F9                      	stc
 10383 00000544 EB9B                    	jmp	short ROM_RET
 10384                                  
 10385                                  ; ---------------------------------------------------------------------------
 10386                                  
 10387                                  ; execute a rom-placed body of code. allocate largest block
 10388                                  
 10389                                  ROM_EXEC:
 10390 00000546 BBFFFF                  	mov	bx,0FFFFh
 10391                                  	; 05/02/2023
 10392 00000549 B448                    	mov	ah,48h
 10393                                  	;mov	ah,ALLOC ; 48h
 10394 0000054B CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10395                                  			; BX = number of 16-byte paragraphs desired
 10396 0000054D B448                    	mov	ah,48h
 10397                                  	;mov	ah,ALLOC ; 48h
 10398 0000054F CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10399                                  			; BX = number of 16-byte paragraphs desired
 10400 00000551 53                      	push	bx
 10401 00000552 50                      	push	ax
 10402                                  
 10403                                  	; set terminate addresses
 10404                                  
 10405 00000553 B82225                  	mov	ax,2522h
 10406                                  	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
 10407                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
 10408 00000556 1E                      	push	ds
 10409 00000557 2E8E1E[F39D]            	mov	ds,[cs:RESSEG]
 10410                                  	;mov	dx,offset RESGROUP:EXEC_WAIT
 10411                                  	;mov	dx,131h ; MSDOS 3.3
 10412                                  	; 05/02/2023
 10413                                  	;mov	dx,0D6Bh ; MSDOS 5.0
 10414 0000055C BA[E90C]                	mov	dx,Exec_Wait
 10415 0000055F CD21                    	int	21h	; DOS -	SET INTERRUPT VECTOR
 10416                                  			; AL = interrupt number
 10417                                  			; DS:DX	= new vector to	be used	for specified interrupt
 10418 00000561 8CDA                    	mov	dx,ds
 10419 00000563 8EC2                    	mov	es,dx
 10420 00000565 1F                      	pop	ds
 10421                                  		
 10422                                  	; and create program header and dup all jfn's
 10423                                  
 10424 00000566 5A                      	pop	dx
 10425 00000567 B455                    	mov	ah,55h
 10426                                  	;mov	ah,DUP_PDB ; 55h
 10427 00000569 CD21                    	int	21h	; DOS -	2+ internal - CREATE PSP
 10428                                  			; DX = segment number at which to set up PSP
 10429                                  			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
 10430                                  		
 10431                                  	; set up dma address
 10432                                  
 10433 0000056B 8EDA                    	mov	ds,dx
 10434 0000056D BA8000                  	mov	dx,80h
 10435 00000570 B41A                    	mov	ah,1Ah
 10436                                  	;mov	ah,Set_DMA ; 1Ah
 10437 00000572 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 10438                                  			; DS:DX	-> disk	transfer buffer
 10439                                  
 10440                                  	; copy in environment info
 10441                                  
 10442 00000574 26A1[DC03]              	mov	ax,[es:EnvirSeg]
 10443                                  	;mov	[2Ch],ax
 10444 00000578 A32C00                  	mov	[PDB.ENVIRON],ax
 10445                                  
 10446                                  	; set up correct size of block
 10447                                  
 10448 0000057B 5B                      	pop	bx		; BX has size, DS has segment
 10449 0000057C 8CDA                    	mov	dx,ds
 10450 0000057E 01DA                    	add	dx,bx
 10451                                  	;mov	[2],dx
 10452 00000580 89160200                	mov	[PDB.BLOCK_LEN],dx
 10453                                  
 10454                                  	; change ownership of block
 10455                                  
 10456 00000584 8CDA                    	mov	dx,ds
 10457 00000586 4A                      	dec	dx
 10458 00000587 8EDA                    	mov	ds,dx
 10459 00000589 42                      	inc	dx	
 10460                                  	;mov	[1],dx
 10461 0000058A 89160100                	mov	[ARENA.owner],dx
 10462 0000058E 8EDA                    	mov	ds,dx
 10463                                  
 10464                                  	; set up correct stack
 10465                                  
 10466 00000590 81FB0010                	cmp	bx,1000h
 10467 00000594 7202                    	jb	short GOT_STACK
 10468 00000596 31DB                    	xor	bx,bx
 10469                                  GOT_STACK:
 10470 00000598 B104                    	mov	cl,4
 10471 0000059A D3E3                    	shl	bx,cl
 10472 0000059C 8CDA                    	mov	dx,ds
 10473 0000059E 8ED2                    	mov	ss,dx
 10474 000005A0 89DC                    	mov	sp,bx
 10475 000005A2 31C0                    	xor	ax,ax
 10476 000005A4 50                      	push	ax
 10477                                  
 10478                                  	; set up initial registers and go to the guy
 10479                                  
 10480 000005A5 F7D0                    	not	ax
 10481 000005A7 2EFF36[A8A0]            	push	word [cs:ROM_CS]
 10482 000005AC 2EFF36[A6A0]            	push	word [cs:ROM_IP]
 10483 000005B1 8EC2                    	mov	es,dx
 10484 000005B3 CB                      	retf	; far return
 10485                                  
 10486                                  ;============================================================================
 10487                                  ; TBATCH.ASM, MSDOS 6.0, 1991
 10488                                  ;============================================================================
 10489                                  ; 12/10/2018 - Retro DOS v3.0
 10490                                  
 10491                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
 10492                                  
 10493                                  ; =============== S U B	R O U T	I N E =======================================
 10494                                  
 10495                                  ;Break	<PromptBat - Open or wait for batch file>
 10496                                  
 10497                                  ; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10498                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h
 10499                                  
 10500                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 10501                                  ; MSDOS 6.22 COMMAND.COM - TRANGROUP:05BCh
 10502                                  
 10503                                  ; Open the batch file. If we cannot find the batch file. If the media is
 10504                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
 10505                                  ; file. Leave segment registers alone.
 10506                                  
 10507                                  PROMPTBAT:
 10508 000005B4 E84808                  	call	BATOPEN
 10509 000005B7 7201                    	jc	short PROMPTBAT1
 10510 000005B9 C3                      	retn
 10511                                  PROMPTBAT1:
 10512                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10513                                  	; MSDOS 6.0 COMMAND.COM
 10514 000005BA 83FA02                  	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
 10515 000005BD 740A                    	je	short BAT_REMCHECK	;AN022;
 10516 000005BF 83FA03                  	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
 10517 000005C2 7405                    	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
 10518                                  	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
 10519 000005C4 E83500                  	call	output_batch_name
 10520 000005C7 EB13                    	jmp	short BATDIE		;AN022;
 10521                                  
 10522                                  	; 05/02/2023
 10523                                  	; MSDOS 3.3 COMMAND.COM
 10524                                  	;cmp	dx,ACCDENPTR
 10525                                  	;jz	short BATDIE
 10526                                  
 10527                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10528                                  BAT_REMCHECK:				;AN022; Go see if media is removable
 10529 000005C9 2EFF1E[FD9D]            	call	far [cs:RCH_ADDR]	; DX has error number
 10530 000005CE 7417                    	jz	short ASKFORBAT		; Media is removable
 10531                                  
 10532                                  ; The media is not changeable. Turn everything off.
 10533                                  
 10534 000005D0 E83D0B                  	call	FOROFF
 10535 000005D3 E8E22E                  	call	PipeOff
 10536 000005D6 A2[4802]                	mov	[IfFlag],al	; No If in progress.	
 10537 000005D9 BA[ED91]                	mov	dx,BADBAT_PTR
 10538                                  BATDIE:
 10539 000005DC E8F003                  	call	BATCHOFF
 10540 000005DF 0E                      	push	cs
 10541 000005E0 1F                      	pop	ds
 10542                                  	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
 10543                                  	; 05/02/2023
 10544 000005E1 E8234F                  	call	std_eprintf	; MSDOS 6.0
 10545                                  	;call	STD_PRINTF	; MSDOS 3.3
 10546                                  
 10547                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
 10548                                  
 10549 000005E4 E91DFB                  	jmp	TCOMMAND
 10550                                  
 10551                                  ; Ask the user to reinsert the batch file
 10552                                  
 10553                                  ASKFORBAT:
 10554 000005E7 1E                      	push	ds
 10555 000005E8 0E                      	push	cs
 10556 000005E9 1F                      	pop	ds
 10557                                  
 10558                                  	; MSDOS 6.0
 10559                                  	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
 10560 000005EA BA[F091]                	mov	dx,NEEDBAT_PTR
 10561                                  	;invoke	std_eprintf	 	;Prompt for batch file on stderr
 10562                                  	; 05/02/2023
 10563 000005ED E8174F                  	call	std_eprintf
 10564                                  	;mov	dx,offset trangroup:pausemes_ptr
 10565 000005F0 BA[6292]                	mov	dx,PAUSEMES_PTR
 10566                                  	;invoke std_eprintf		;AN000; get second part of message
 10567 000005F3 E8114F                  	call	std_eprintf
 10568                                  					;AN000; print it to stderr
 10569                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10570                                  	;call	STD_EPRINTF
 10571 000005F6 E82E00                  	call	GETKEYSTROKE
 10572 000005F9 1F                      	pop	ds
 10573 000005FA EBB8                    	jmp	short PROMPTBAT
 10574                                  
 10575                                  
 10576                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10577                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah
 10578                                  
 10579                                  	; MSDOS 6.0
 10580                                  ;****************************************************************
 10581                                  ;*
 10582                                  ;* ROUTINE:	Output_batch_name
 10583                                  ;*
 10584                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
 10585                                  ;*
 10586                                  ;* INPUT:	DX - extended error number
 10587                                  ;*
 10588                                  ;* OUTPUT:	Ready to call print routine
 10589                                  ;*
 10590                                  ;****************************************************************
 10591                                  ;
 10592                                  ;public	output_batch_name		;AN022;
 10593                                  
 10594                                  output_batch_name:	;proc near	;AN022;
 10595                                  
 10596 000005FC 1E                      	push	ds			;AN022; save resident segment
 10597 000005FD 8E1E[E701]              	mov	ds,[Batch]		;AN022; get batch file segment
 10598                                  	;assume	DS:nothing		;AN022;
 10599                                  	;;mov	SI,BatFile		;AN022; get offset of batch file
 10600                                  	; 05/02/2023
 10601                                  	;mov	si,20h
 10602                                  	; 24/04/2023
 10603 00000601 BE2000                  	mov	si,BATCHSEGMENT.BatFile
 10604                                  	;invoke	dstrlen 		;AN022; get length of string
 10605 00000604 E8B52B                  	call	dstrlen
 10606                                  	;mov	di,offset Trangroup:bwdbuf
 10607                                  					;AN022; target for batch name
 10608 00000607 BF[2AA0]                	mov	di,BWDBUF
 10609 0000060A F3A4                    	rep	movsb			;AN022; move the name
 10610                                  
 10611 0000060C 0E                      	push	cs			;AN022; get local segment
 10612 0000060D 1F                      	pop	ds			;AN022;
 10613                                  	;assume	DS:trangroup		;AN022;
 10614                                  	; 05/02/2023
 10615 0000060E 8916[D091]              	mov	[extend_buf_ptr],dx	;AN022; put message number in block
 10616                                  	;mov	byte [msg_disp_class],1
 10617 00000612 C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class
 10618                                  					;AN022; set up extended error msg class
 10619                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 10620 00000617 BA[D091]                	mov	dx,extend_buf_ptr	
 10621                                  					;AN022; get extended message pointer
 10622                                  	;mov	string_ptr_2,offset trangroup:bwdbuf 
 10623 0000061A C706[91A0][2AA0]        	mov	word [string_ptr_2],BWDBUF	
 10624                                  					;AN022; point to substitution
 10625                                  	;mov	byte [extend_buf_sub],1
 10626 00000620 C606[D291]01            	mov	byte [extend_buf_sub],one_subst
 10627                                  					;AN022; set up for one subst
 10628 00000625 1F                      	pop	ds			;AN022; restore data segment
 10629 00000626 C3                      	retn				;AN022; return
 10630                                  
 10631                                  ;output_batch_name    endp		;AN022;
 10632                                  
 10633                                  
 10634                                  ; =============== S U B	R O U T	I N E =======================================
 10635                                  
 10636                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
 10637                                  
 10638                                  ; Read the next keystroke. Since there may be several characters in the queue
 10639                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
 10640                                  ; AFTER waiting.
 10641                                  
 10642                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10643                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h
 10644                                  
 10645                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 10646                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:062Fh
 10647                                  
 10648                                  GETKEYSTROKE:
 10649                                  	; 05/02/2023
 10650                                  	; MSDOS 3.3
 10651                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
 10652                                  	;;mov	ax,0C08h
 10653                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
 10654                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10655                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10656                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10657                                  	;;mov	ax,0C00h
 10658                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
 10659                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10660                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10661                                  	;retn
 10662                                  
 10663                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10664                                  	; MSDOS 6.0
 10665 00000627 52                      	push	dx			;AN000;  3/3/KK
 10666                                  	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
 10667                                  					;AN000;  3/3/KK
 10668 00000628 B80263                  	mov	ax,6302h
 10669 0000062B CD21                    	int	21h			;AN000;  3/3/KK
 10670                                  		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
 10671                                  	
 10672 0000062D 52                      	push	dx			;AN000;  save interim state 3/3/KK
 10673                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10674                                  					;AN000;  3/3/KK
 10675 0000062E B80163                  	mov	ax,6301h
 10676 00000631 B201                    	mov	dl,1
 10677                                  	;mov	dl,InterimMode		;AN000;  3/3/KK
 10678 00000633 CD21                    	int	21h			;AN000;  3/3/KK
 10679                                  		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
 10680                                  		; DL = new mode
 10681                                  		; 00h return only full characters on DOS keyboard input functions
 10682                                  		; 01h return partially-formed characters also
 10683                                  	
 10684                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
 10685 00000635 B8080C                  	mov	ax,0C08h
 10686 00000638 CD21                    	int	21h			; Get character with KB buffer flush
 10687                                  		; DOS - CLEAR KEYBOARD BUFFER
 10688                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10689                                  
 10690                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10691 0000063A B8000C                  	mov	ax,0C00h
 10692 0000063D CD21                    	int	21h
 10693                                  		; DOS - CLEAR KEYBOARD BUFFER
 10694                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10695                                  
 10696                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10697                                  					;AN000;  3/3/KK
 10698 0000063F B80163                  	mov	ax,6301h
 10699 00000642 5A                      	pop	dx			;AN000;  restore interim state 3/3/KK
 10700 00000643 CD21                    	int	21h			;AN000;  3/3/KK
 10701 00000645 5A                      	pop	dx			;AN000;  3/3/KK
 10702                                  	
 10703 00000646 C3                      	retn
 10704                                  
 10705                                  ; =============== S U B	R O U T	I N E =======================================
 10706                                  
 10707                                  ; Break	<ReadBat - read 1 line from batch file>
 10708                                  
 10709                                  ; ReadBat - read a single line from the batch file. 
 10710                                  ; Perform all substitutions as appropriate.
 10711                                  
 10712                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10713                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h
 10714                                  
 10715                                  READBAT:
 10716                                  	;ASSUME	DS:ResGroup,ES:TranGroup
 10717                                  		
 10718                                  	;mov	byte [Suppress],1
 10719                                  				; initialize line suppress status
 10720 00000647 C606[3C02]01            	mov	byte [Suppress],YES_ECHO
 10721 0000064C F606[3102]FF            	test	byte [Batch_Abort],-1 ; 0FFh
 10722 00000651 751F                    	jnz	short TRYING_TO_ABORT
 10723 00000653 C606[3002]01            	mov	byte [In_Batch],1 ; set flag to indicate batch job
 10724                                  
 10725                                  	; MSDOS 6.0
 10726                                  
 10727                                  ;M037; Start of changes
 10728                                  ; We check here if we have set the flag indicating that the batchfile is at
 10729                                  ;EOF. In this case, we do not want to continue with the normal processing.
 10730                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
 10731                                  ;batch file gets closed etc. and then return as if everything is done.
 10732                                  
 10733                                  	; 05/02/2023
 10734 00000658 1E                      	push	ds
 10735 00000659 8E1E[E701]              	mov	ds,[Batch]
 10736                                  	;cmp	byte [2],0
 10737 0000065D 803E020000              	cmp	byte [BATCHSEGMENT.BatchEOF],0
 10738                                  				; are we at EOF in batchfile
 10739 00000662 1F                      	pop	ds
 10740 00000663 740A                    	jz	short CONTBAT	; no, continue normal processing
 10741                                  	;invoke	GetBatByt	; frees up batchseg
 10742 00000665 E8D303                  	call	GETBATBYT
 10743 00000668 26A2[549C]              	mov	[es:COMBUF+2],al
 10744                                  				; stuff CR into command buffer
 10745                                  				; as a dummy command
 10746                                  	;;invoke CrLf2		; print a CR-LF
 10747                                  	;call	CRLF2
 10748                                  	;;return		; done batch processing
 10749                                  	;retn
 10750                                  	; 24/04/2023
 10751 0000066C E9B224                  	jmp	CRLF2
 10752                                  
 10753                                  ;M037; End of changes
 10754                                  		
 10755                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10756                                  CONTBAT:
 10757 0000066F E842FF                  	call	PROMPTBAT
 10758                                  
 10759                                  TRYING_TO_ABORT:
 10760 00000672 BF[549C]                	mov	di,COMBUF+2
 10761                                  
 10762                                  ; Save position and try to scan for first non delimiter.
 10763                                  
 10764                                  TESTNOP:
 10765 00000675 8CD8                    	mov	ax,ds
 10766 00000677 8E1E[E701]              	mov	ds,[Batch]
 10767 0000067B FF360800                	push	word [BATCHSEGMENT.BatSeek]
 10768 0000067F FF360A00                	push	word [BATCHSEGMENT.BatSeek+2]
 10769                                  				; save current location.
 10770 00000683 8ED8                    	mov	ds,ax
 10771 00000685 E84B06                  	call	SKIPDELIM	; skip to first non-delim
 10772                                  
 10773                                  ; If the first non-delimiter is not a : (label), we reseek back to the
 10774                                  ; beginning and read the line.
 10775                                  
 10776 00000688 3C3A                    	cmp	al,':'		; is it a label?
 10777 0000068A 59                      	pop	cx
 10778 0000068B 5A                      	pop	dx		; restore position in bat file
 10779 0000068C 7431                    	jz	short NOPLINE	; yes, resync everything.
 10780 0000068E F706[E701]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10781 00000694 7438                    	jz	short RDBAT	; no, go read batch file
 10782                                  
 10783                                  	;cmp	al,'@'
 10784 00000696 3C40                    	cmp	al,No_Echo_Char	; see if user wants to suppress line
 10785 00000698 7507                    	jne	short SET_BAT_POS ; no - go and set batch file position
 10786                                  	;mov	byte [Suppress],0
 10787 0000069A C606[3C02]00            	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
 10788 0000069F EB2D                    	jmp	short RDBAT	; go read batch file
 10789                                  	;nop
 10790                                  SET_BAT_POS:
 10791 000006A1 1E                      	push	ds
 10792 000006A2 8E1E[E701]              	mov	ds,[Batch]
 10793                                  	;mov	[8],dx
 10794 000006A6 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
 10795                                  	;mov	[10],cx
 10796 000006AA 890E0A00                	mov	[BATCHSEGMENT.BatSeek+2],cx
 10797 000006AE 1F                      	pop	ds
 10798                                  	;;mov	ax,(LSEEK SHL 8) + 0
 10799                                  	; 05/02/2023
 10800 000006AF B80042                  	mov	ax,4200h
 10801                                  	;mov	ax,(LSEEK*256) ; 4200h ; seek back
 10802 000006B2 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 10803                                  			; AL = method: offset from beginning of	file
 10804                                  	;mov	word [cs:BATBUFPOS],0FFFFh
 10805                                  	; 24/04/2023
 10806                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
 10807 000006B4 26C706[B9A9]FFFF        	mov	word [es:BATBUFPOS],-1; 0FFFFh
 10808                                  	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
 10809 000006BB 31C9                    	xor	cx,cx		; Initialize line length to zero
 10810 000006BD EB0F                    	jmp	short RDBAT
 10811                                  
 10812                                  	;nop
 10813                                  
 10814                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
 10815                                  ; We eat characters until a CR is seen.
 10816                                  
 10817                                  NOPLINE:
 10818 000006BF E80501                  	call	SKIPTOEOL
 10819 000006C2 E87603                  	call	GETBATBYT	; eat trailing LF
 10820                                  	;test	word [Batch],0FFFFh
 10821 000006C5 F706[E701]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10822 000006CB 75A8                    	jnz	short TESTNOP	; no, go get another line
 10823                                  READBAT_RETN:			; Hit EOF
 10824 000006CD C3                      	retn
 10825                                  
 10826                                  ; ---------------------------------------------------------------------------
 10827                                  
 10828                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
 10829                                  ; input, we are to consider two special cases:
 10830                                  ;
 10831                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
 10832                                  ;   %sym%	This is a symbol from the environment
 10833                                  
 10834                                  RDBAT:
 10835 000006CE E86A03                  	call	GETBATBYT
 10836 000006D1 41                      	inc	cx		; Inc the line length
 10837                                  
 10838                                  	; 05/02/2023
 10839                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
 10840 000006D2 E83A22                  	call	testkanj
 10841 000006D5 740C                    	jz	short RDBAT1
 10842                                  	;cmp	cx,127
 10843 000006D7 83F97F                  	cmp	cx,COMBUFLEN-1
 10844 000006DA 7350                    	jnb	short TOOLONG
 10845 000006DC AA                      	stosb
 10846 000006DD E85B03                  	call    GETBATBYT
 10847 000006E0 41                      	inc	cx
 10848 000006E1 EB0A                    	jmp	short SAVBATBYT
 10849                                  RDBAT1:
 10850 000006E3 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10851 000006E7 7343                    	jnb	short TOOLONG	   ; Yes - handle it, handle it
 10852                                  
 10853                                  ; See if we have a parameter character.
 10854                                  
 10855 000006E9 3C25                    	cmp	al,'%'		; Check for parameter
 10856 000006EB 7449                    	je	short NEEDPARM
 10857                                  
 10858                                  ; no parameter character. Store it as usual and see if we are done.
 10859                                  
 10860                                  SAVBATBYT:
 10861 000006ED AA                      	stosb			; End of line found?
 10862 000006EE 3C0D                    	cmp	al,0Dh
 10863 000006F0 75DC                    	jne	short RDBAT	; no, go for more
 10864                                  
 10865                                  ; We have read in an entire line. 
 10866                                  ; Decide whether we should echo the command line or not.
 10867                                  
 10868                                  FOUND_EOL:
 10869 000006F2 81EF[559C]              	sub	di,COMBUF+3
 10870 000006F6 89F8                    	mov	ax,di		; remember that we've not counted the CR
 10871 000006F8 26A2[539C]              	mov	[es:COMBUF+1],al
 10872                                  				; Set length of line
 10873 000006FC E83C03                  	call	GETBATBYT	; Eat linefeed
 10874 000006FF E8E906                  	call	BATCLOSE
 10875 00000702 803E[3C02]00            	cmp	byte [Suppress],NO_ECHO ; 0
 10876 00000707 7407                    	jz	short RESET
 10877 00000709 F606[3B02]01            	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
 10878 0000070E 7504                    	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
 10879                                  RESET:
 10880 00000710 0E                      	push	cs
 10881 00000711 1F                      	pop	ds		; Go back to local segment
 10882 00000712 74B9                    	jz	short READBAT_RETN ; no echoing here...
 10883                                  TRY_NEXTFLAG:
 10884 00000714 803E[5202]01            	cmp	byte [NullFlag],nullcommand ; 1
 10885                                  				;G was there a command last time?
 10886 00000719 7403                    	jz	short NO_CRLF_PRINT
 10887                                  				;G no - don't print crlf
 10888 0000071B E80324                  	call	CRLF2		;G Print out prompt
 10889                                  NO_CRLF_PRINT:
 10890 0000071E E8C21B                  	call	PRINT_PROMPT
 10891 00000721 0E                      	push	cs		;G change data segment
 10892 00000722 1F                      	pop	ds
 10893 00000723 BA[549C]                	mov	dx,COMBUF+2	; get command line for echoing
 10894 00000726 E85124                  	call	CRPRINT
 10895                                  	;call	CRLF2
 10896                                  	;retn
 10897                                  	; 06/02/2023
 10898 00000729 E9F523                  	jmp	CRLF2
 10899                                  
 10900                                  ; The line was too long. Eat remainder of input text up until the CR
 10901                                  
 10902                                  TOOLONG:
 10903 0000072C 3C0D                    	cmp	al,0Dh		; Has the end of the line been reached?
 10904 0000072E 7403                    	jz	short LTLCONT	; Yes, continue
 10905 00000730 E89400                  	call	SKIPTOEOL	; Eat remainder of line	
 10906                                  LTLCONT:
 10907 00000733 AA                      	stosb			; Terminate the command
 10908 00000734 EBBC                    	jmp	short FOUND_EOL	; Go process the valid part of the line
 10909                                  
 10910                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
 10911                                  
 10912                                  NEEDPARM:
 10913 00000736 E80203                  	call	GETBATBYT	; get next character
 10914 00000739 3C25                    	cmp	al,'%'		; Check for two consecutive %
 10915 0000073B 74B0                    	je	short SAVBATBYT	; if so, replace with a single %
 10916 0000073D 3C0D                    	cmp	al,0Dh		; Check for end-of-line
 10917 0000073F 74AC                    	je	short SAVBATBYT	; yes, treat it normally
 10918                                  
 10919                                  ; We have found %<something>. If the <something> is in the range 0-9, we
 10920                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
 10921                                  ; see if the <something> has a terminating % and then look up the contents
 10922                                  ; in the environment.
 10923                                  
 10924                                  PAROK:
 10925 00000741 2C30                    	sub	al,'0'
 10926 00000743 7239                    	jb	short NEEDENV	; look for parameter in the environment
 10927 00000745 3C09                    	cmp	al,9
 10928 00000747 7735                    	ja	short NEEDENV
 10929                                  
 10930                                  ; We have found %<number>. This is taken from the parameters in the
 10931                                  ; allocated batch area.
 10932                                  
 10933 00000749 98                      	cbw
 10934 0000074A 89C3                    	mov	bx,ax		; move index into AX
 10935 0000074C D1E3                    	shl	bx,1		; convert word index into byte ptr
 10936 0000074E 06                      	push	es
 10937 0000074F 8E06[E701]              	mov	es,[Batch]
 10938                                  
 10939                                  ; The structure of the batch area is:
 10940                                  ;
 10941                                  ;   BYTE    type of segment
 10942                                  ;   DWORD   offset for next line
 10943                                  ;   10 WORD pointers to parameters. -1 is empty parameter
 10944                                  ;   ASCIZ   file name (with . and ..)
 10945                                  ;   BYTES   CR-terminated parameters
 10946                                  ;   BYTE    0 flag to indicate end of parameters
 10947                                  ;
 10948                                  ; Get pointer to BX'th argument
 10949                                  
 10950                                  	;;mov	si,[es:bx+0Bh]
 10951                                  	; 05/02/2023
 10952                                  	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
 10953 00000753 268B770C                	mov	si,[es:bx+BATCHSEGMENT.BatParm]
 10954 00000757 07                      	pop	es
 10955                                  
 10956                                  ; Is there a parameter here?
 10957                                  
 10958 00000758 83FEFF                  	cmp	si,-1		; Check if parameter exists
 10959 0000075B 7503                    	jnz	short YES_THERE_IS ; Yes go get it
 10960 0000075D E96EFF                  	jmp	RDBAT		; Ignore if it doesn't
 10961                                  
 10962                                  ; Copy in the found parameter from batch segment
 10963                                  
 10964                                  YES_THERE_IS:
 10965 00000760 1E                      	push	ds
 10966 00000761 8E1E[E701]              	mov	ds,[Batch]
 10967 00000765 49                      	dec	cx		; Don't count '%' in line length
 10968                                  COPYPARM:
 10969 00000766 AC                      	lodsb			; From resident segment
 10970 00000767 3C0D                    	cmp	al,0Dh		; Check for end of parameter
 10971 00000769 740F                    	je	short ENDPARAM
 10972 0000076B 41                      	inc	cx		; Inc the line length
 10973 0000076C 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10974 00000770 7303                    	jnb	short LINETOOL	; Yes - handle it, handle it
 10975 00000772 AA                      	stosb
 10976 00000773 EBF1                    	jmp	short COPYPARM
 10977                                  
 10978                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
 10979                                  ; line. We need to make sure that the tooLong code isn't fooled into
 10980                                  ; believing that we are at EOL. Clobber AL too.
 10981                                  
 10982                                  LINETOOL:
 10983 00000775 30C0                    	xor	al,al
 10984 00000777 1F                      	pop	ds
 10985 00000778 EBB2                    	jmp	short TOOLONG
 10986                                  
 10987                                  ; We have copied in an entire parameter. Go back for more
 10988                                  
 10989                                  ENDPARAM:
 10990 0000077A 1F                      	pop	ds
 10991 0000077B E950FF                  	jmp	RDBAT
 10992                                  
 10993                                  ; We have found % followed by something other than 0-9. We presume that there
 10994                                  ; will be a following % character. In between is an environment variable that
 10995                                  ; we will fetch and replace in the batch line with its value.
 10996                                  
 10997                                  NEEDENV:
 10998                                  	; MSDOS 6.0 COMMAND.COM
 10999                                  	; 05/02/2023 
 11000 0000077E 49                      	dec     cx 		;AN070; Don't count "%"
 11001                                  
 11002                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11003 0000077F 1E                      	push	ds
 11004 00000780 57                      	push	di
 11005                                  				; temp spot for name
 11006 00000781 BF[AC9F]                	mov	di,ID
 11007 00000784 0430                    	add	al,'0'		; reconvert character
 11008 00000786 AA                      	stosb			; store it in appropriate place
 11009                                  
 11010                                  ; loop getting characters until the next % is found or until EOL
 11011                                  
 11012                                  GETENV1:
 11013 00000787 E8B102                  	call	GETBATBYT	; get the byte
 11014 0000078A AA                      	stosb			; store it
 11015 0000078B 3C0D                    	cmp	al,0Dh		; EOL?
 11016 0000078D 7514                    	jne	short GETENV15	; no, see if it the term char
 11017                                  
 11018                                  ; The user entered a string with a % but no trailing %. We copy the string.
 11019                                  
 11020 0000078F 26C645FF00              	mov	byte [es:di-1],0 ; nul terminate the string
 11021 00000794 BE[AC9F]                	mov	si,ID 		; point to buffer
 11022 00000797 5F                      	pop	di		; point to line buffer
 11023 00000798 0E                      	push	cs
 11024 00000799 1F                      	pop	ds
 11025 0000079A E88B02                  	call	STRCPY
 11026                                  	; 05/02/2023
 11027 0000079D 72D6                    	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
 11028                                  	; 24/04/2023
 11029                                  	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
 11030 0000079F 1F                      	pop	ds
 11031 000007A0 E94AFF                  	jmp	SAVBATBYT
 11032                                  GETENV15:
 11033 000007A3 3C25                    	cmp	al,'%'		; terminating %?
 11034 000007A5 75E0                    	jne	short GETENV1	; no, go suck out more characters
 11035                                  
 11036                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
 11037                                  ; This was the source of bug #1.
 11038                                  ;	dec	cx		;AN070; Don't count "%"
 11039                                  
 11040 000007A7 B03D                    	mov	al,'='		; terminate  with =
 11041 000007A9 268845FF                	mov	[es:di-1],al
 11042                                  
 11043                                  ; ID now either has a =-terminated string which we are to find in the
 11044                                  ; environment or a non =-terminated string which will not be found in the
 11045                                  ; environment.
 11046                                  
 11047                                  GETENV2:
 11048 000007AD BE[AC9F]                	mov	si,ID
 11049 000007B0 0E                      	push	cs
 11050 000007B1 1F                      	pop	ds		; DS:SI points to name
 11051 000007B2 51                      	push	cx
 11052 000007B3 E8AF20                  	call	find_name_in_environment
 11053 000007B6 59                      	pop	cx
 11054 000007B7 06                      	push	es
 11055 000007B8 1F                      	pop	ds
 11056 000007B9 0E                      	push	cs
 11057 000007BA 07                      	pop	es
 11058 000007BB 89FE                    	mov	si,di
 11059 000007BD 5F                      	pop	di		; get back pointer to command line
 11060                                  
 11061                                  ; If the parameter was not found, there is no need to perform any replacement.
 11062                                  ; We merely pretend that we've copied the parameter.
 11063                                  
 11064 000007BE 7203                    	jc	short GETENV6
 11065                                  
 11066                                  ; ES:DI points to command line being built
 11067                                  ; DS:SI points either to nul-terminated environment object AFTER =
 11068                                  
 11069 000007C0 E86502                  	call	STRCPY		; (let RdBat handle overflow)
 11070                                  	; 24/04/2022
 11071                                  	;dec	di 		; MSDOS 3.3 COMMAND.COM
 11072                                  GETENV6:
 11073 000007C3 1F                      	pop	ds
 11074 000007C4 E907FF                  	jmp	RDBAT		; go back to batch file
 11075                                  
 11076                                  ; =============== S U B	R O U T	I N E =======================================
 11077                                  
 11078                                  ;   SkipToEOL - read from batch file until end of line
 11079                                  
 11080                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11081                                  SKIPTOEOL:
 11082 000007C7 F706[E701]FFFF          	test	word [Batch],-1 ; 0FFFFh
 11083                                  	;jnz	short SKIPTOEOL1  	
 11084                                  	;retn			; no batch file in effect
 11085                                  	
 11086 000007CD 7407                    	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
 11087                                  SKIPTOEOL1:
 11088 000007CF E86902                  	call	GETBATBYT
 11089 000007D2 3C0D                    	cmp	al,0Dh		; eol character?
 11090 000007D4 75F1                    	jnz	short SKIPTOEOL	; no, go eat another
 11091                                  SKIPTOEOL2:
 11092 000007D6 C3                      	retn
 11093                                  
 11094                                  ; =============== S U B	R O U T	I N E =======================================
 11095                                  
 11096                                  ;Break	<Allocate and deallocate the transient portion>
 11097                                  
 11098                                  ; Free Transient. Modify ES,AX,flags
 11099                                  
 11100                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11101                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
 11102                                  FREE_TPA:
 11103 000007D7 06                      	push	es
 11104 000007D8 8E06[F39D]              	mov	es,[RESSEG]
 11105 000007DC 268E06[FA03]            	mov	es,[es:Res_Tpa]
 11106 000007E1 B449                    	mov	ah,49h
 11107                                  	;mov	ah,DEALLOC ; 49h
 11108 000007E3 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11109                                  			; ES = segment address of area to be freed
 11110 000007E5 07                      	pop	es
 11111 000007E6 C3                      	retn
 11112                                  
 11113                                  ; =============== S U B	R O U T	I N E =======================================
 11114                                  
 11115                                  ; Allocate transient. Modify AX,BX,DX,flags
 11116                                  
 11117                                  	; 06/02/2023
 11118                                  ALLOC_TPA:
 11119 000007E7 06                      	push	es
 11120 000007E8 8E06[F39D]              	mov	es,[RESSEG]
 11121 000007EC BBFFFF                  	mov	bx,0FFFFh 	; Re-allocate the transient	
 11122 000007EF B448                    	mov	ah,48h
 11123                                  	;mov	ah,ALLOC ; 48h
 11124 000007F1 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11125                                  			; BX = number of 16-byte paragraphs desired
 11126 000007F3 53                      	push	bx	  	; Save size of block
 11127 000007F4 B448                    	mov	ah,48h
 11128                                  	;mov	ah,ALLOC ; 48h
 11129 000007F6 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11130                                  			; BX = number of 16-byte paragraphs desired
 11131                                  
 11132                                  ; Attempt to align TPA on 64K boundary
 11133                                  
 11134 000007F8 5B                      	pop	bx		; Restore size of block
 11135 000007F9 26A3[FA03]              	mov	[es:Res_Tpa],ax
 11136                                  				; Save segment to beginning of block
 11137 000007FD A3[019E]                	mov	[TRAN_TPA],ax
 11138                                  
 11139                                  ; Is the segment already aligned on a 64K boundary
 11140                                  
 11141 00000800 89C2                    	mov	dx,ax		; Save segment
 11142 00000802 25FF0F                  	and	ax,0FFFh	; Test if above boundary
 11143 00000805 7507                    	jnz	short CALC_TPA
 11144 00000807 89D0                    	mov	ax,dx
 11145 00000809 2500F0                  	and	ax,0F000h	; Test if multiple of 64K
 11146 0000080C 7523                    	jnz	short NOROUND
 11147                                  CALC_TPA:
 11148 0000080E 89D0                    	mov	ax,dx
 11149 00000810 2500F0                  	and	ax,0F000h
 11150 00000813 050010                  	add	ax,1000h	; Round up to next 64K boundary
 11151 00000816 7219                    	jc	short NOROUND	; Memory wrap if carry set
 11152                                  
 11153                                  ; Make sure that new boundary is within allocated range
 11154                                  
 11155 00000818 268B16[FA03]            	mov	dx,[es:Res_Tpa]
 11156 0000081D 01DA                    	add	dx,bx		; Compute maximum address
 11157 0000081F 39C2                    	cmp	dx,ax		; Is 64K address out of range?
 11158 00000821 720E                    	jb	short NOROUND
 11159                                  
 11160                                  ; Make sure that we won't overwrite the transient
 11161                                  
 11162 00000823 8CCB                    	mov	bx,cs		; CS is beginning of transient
 11163 00000825 39C3                    	cmp	bx,ax
 11164 00000827 7208                    	jb	short NOROUND
 11165                                  
 11166                                  ; The area from the 64K boundary to the beginning of the transient must
 11167                                  ; be at least 64K.
 11168                                  
 11169 00000829 29C3                    	sub	bx,ax
 11170                                  	;cmp	bx,4096
 11171 0000082B 81FB0010                	cmp	bx,1000h	; Size greater than 64K?	
 11172 0000082F 7304                    	jnb	short ROUNDDONE
 11173                                  NOROUND:
 11174 00000831 26A1[FA03]              	mov	ax,[es:Res_Tpa]
 11175                                  ROUNDDONE:
 11176 00000835 26A3[EE03]              	mov	[es:LTpa],ax	; Re-compute everything
 11177 00000839 A3[F59D]                	mov	[TPA],ax
 11178 0000083C 89C3                    	mov	bx,ax
 11179 0000083E 8CC8                    	mov	ax,cs
 11180 00000840 29D8                    	sub	ax,bx
 11181 00000842 53                      	push	bx
 11182 00000843 BB1000                  	mov	bx,16
 11183 00000846 F7E3                    	mul	bx
 11184 00000848 5B                      	pop	bx
 11185 00000849 09D2                    	or	dx,dx
 11186 0000084B 7403                    	jz	short SAVSIZ2
 11187 0000084D B8FFFF                  	mov	ax,-1
 11188                                  SAVSIZ2:
 11189                                  
 11190                                  ; AX is the number of bytes free in the buffer between the resident and the
 11191                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
 11192                                  
 11193 00000850 3D0002                  	cmp	ax,512
 11194 00000853 7603                    	jbe	short GOTSIZE2
 11195                                  	;and	ax,~1FFh
 11196 00000855 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FFh
 11197                                  GOTSIZE2:
 11198 00000858 A3[129E]                	mov	[BYTCNT],ax
 11199 0000085B 07                      	pop	es
 11200 0000085C C3                      	retn
 11201                                  
 11202                                  ; =============== S U B	R O U T	I N E =======================================
 11203                                  
 11204                                  ;Break	<BatCom - enter a batch file>
 11205                                  
 11206                                  ; The exec search has determined that the user has requested a batch file for
 11207                                  ; execution. We parse the arguments, create the batch segment, and signal
 11208                                  ; batch processing.
 11209                                  
 11210                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11211                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
 11212                                  
 11213                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 11214                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0868h
 11215                                  BATCOM:	
 11216                                  
 11217                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
 11218                                  
 11219                                  ; Batch parameters are read with ES set to segment of resident part
 11220                                  
 11221                                  	; MSDOS 6.0
 11222 0000085D 8E06[F39D]              	mov	es,[RESSEG]
 11223                                  	;ASSUME	ES:RESGROUP
 11224                                  	;cmp	byte [es:Call_Batch_Flag],1
 11225 00000861 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11226                                  					;AN043; If in CALL,
 11227 00000867 7403                    	jz	short skip_ioset	;AN043; redirection was already set up
 11228                                  	;invoke	IOSET			; Set up any redirection
 11229 00000869 E86128                  	call	IOSET
 11230                                  skip_ioset:				;AN043;
 11231 0000086C E868FF                  	call	FREE_TPA		; G
 11232                                  	;cmp	byte [es:Call_Batch_Flag],1
 11233 0000086F 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11234 00000875 7403                    	jz	short GETECHO 		; G if we're in a call, don't execute
 11235                                  
 11236                                  	; 12/02/2023
 11237                                  	; MSDOS 3.3
 11238                                  	;call	IOSET
 11239                                  	;mov	es,[RESSEG]
 11240                                  	;call	FREE_TPA
 11241                                  	;;cmp	byte [es:CALL_BATCH_FLAG],1
 11242                                  	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
 11243                                  	;jz	short GETECHO		; G if we're in a call, don't execute
 11244                                  
 11245                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11246                                  
 11247                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
 11248                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
 11249                                  ; Don't execute if in call
 11250                                  
 11251 00000877 E89608                  	call	FOROFF
 11252                                  GETECHO:
 11253 0000087A E83B2C                  	call	PipeOff
 11254 0000087D 26A0[3B02]              	mov	al,[es:EchoFlag]	; preserve echo state for chaining
 11255 00000881 2401                    	and	al,1			; Save current echo state
 11256                                  
 11257 00000883 50                      	push	ax
 11258 00000884 31C0                    	xor	ax,ax
 11259 00000886 26F706[E701]FFFF        	test	word [es:Batch],-1 	; Are we in a batch file?
 11260 0000088D 7414                    	jz	short LEAVEBAT	   	; No, nothing to save
 11261 0000088F 26A1[E701]              	mov	ax,[es:Batch] 		; Get current batch segment
 11262                                  	;cmp	byte [es:Call_Batch_Flag],1
 11263 00000893 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11264 00000899 7408                    	jz	short LEAVEBAT
 11265                                  
 11266                                  ;  We are in a chained batch file, save batlast from previous batch segment
 11267                                  ;  so that if we're in a CALL, we will return to the correct batch file.
 11268                                  
 11269 0000089B 06                      	push	es
 11270 0000089C 8EC0                    	mov	es,ax		; Get current batch segment
 11271                                  	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
 11272                                  				; Get previous batch segment
 11273                                  	; 12/02/2023
 11274                                  	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
 11275 0000089E 26A10300                	mov	ax,[es:BATCHSEGMENT.BatLast]
 11276 000008A2 07                      	pop	es
 11277                                  LEAVEBAT:
 11278 000008A3 50                      	push	ax		; Keep segment until new one created
 11279                                  	;cmp	byte [es:Call_Batch_Flag],1
 11280 000008A4 26803E[4F02]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 11281 000008AA 7403                    	jz	short STARTBAT
 11282 000008AC E82001                  	call	BATCHOFF
 11283                                  
 11284                                  ; Find length of batch file
 11285                                  
 11286                                  STARTBAT:
 11287 000008AF 26C606[4F02]00          	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
 11288 000008B5 BE[1B9D]                	mov	si,EXECPATH
 11289                                  
 11290                                  	; 12/02/2023
 11291                                  	; MSDOS 6.0
 11292 000008B8 B811B7                  	mov	ax,0B711h
 11293                                  	;mov	ax,AppendTruename
 11294                                  				;AN042; Get the real path where the batch file
 11295 000008BB CD2F                    	int	2Fh		;AN042;    was found with APPEND
 11296 000008BD B44E                    	mov	ah,4Eh
 11297                                  	;mov	ah,Find_First	;AN042; The find_first will return it
 11298 000008BF 89F2                    	mov	dx,si		;AN042; Get the string
 11299 000008C1 B91300                  	mov	cx,13h
 11300                                  	;mov	cx,search_attr	;AN042; filetypes to search for
 11301 000008C4 CD21                    	int	21h		;AN042;
 11302                                  
 11303                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11304 000008C6 E8F328                  	call	dstrlen
 11305                                  ;
 11306                                  ; Allocate batch area:
 11307                                  ;   BYTE    type of segment
 11308                                  ;   WORD    segment of last batch file
 11309                                  ;   WORD    segment for FOR command
 11310                                  ;   BYTE    FOR flag state on entry to batch file
 11311                                  ;   DWORD   offset for next line
 11312                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
 11313                                  ;   ASCIZ   file name (with . and ..)
 11314                                  ;   BYTES   CR-terminated parameters
 11315                                  ;   BYTE    0 flag to indicate end of parameters
 11316                                  ;
 11317                                  ; We allocate the maximum size for the command line and use setblock to shrink
 11318                                  ; later when we've squeezed out the extra
 11319                                  ;
 11320 000008C9 89CB                    	mov	bx,cx		; length of file name.
 11321                                  	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
 11322                                  	; 12/02/2023
 11323                                  	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
 11324                                  	; 25/04/2023
 11325 000008CB 81C3BF00                	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
 11326                                  					; structure + max len + round up
 11327 000008CF 51                      	push	cx
 11328 000008D0 B104                    	mov	cl,4
 11329 000008D2 D3EB                    	shr	bx,cl		; convert to paragraphs
 11330 000008D4 53                      	push	bx		; Save size of batch segment
 11331 000008D5 B448                    	mov	ah,48h
 11332                                  	;mov	ah,ALLOC ; 48h ; Allocate batch segment
 11333 000008D7 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 11334                                  				; BX = number of 16-byte paragraphs desired
 11335 000008D9 5B                      	pop	bx		; Get size of batch segment
 11336                                  
 11337                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
 11338                                  ; the batch segment. This may not be true, however, in a multitasking system.
 11339                                  ; G This error will occur with nesting of batch files. We also need to
 11340                                  ; G make sure that we don't overlay the transient.
 11341                                  
 11342 000008DA 7221                    	jc	short MEM_ERROR	;G not enough memory - exit
 11343                                  
 11344 000008DC 50                      	push	ax		;G save batch segment
 11345 000008DD 01D8                    	add	ax,bx		;G get end of batch segment
 11346 000008DF 83C020                  	add	ax,20h		;G add some tpa work area
 11347 000008E2 8CCB                    	mov	bx,cs		;G get the transient segment
 11348                                  
 11349                                  	; MSDOS 6.0
 11350                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
 11351                                  ; M006; batchseg is always above the transient. We need to change this code
 11352                                  ; M006; to only check for an overlap
 11353                                  
 11354                                  	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
 11355                                  	; 12/02/2023
 11356                                  	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
 11357                                  	;mov	dx,TRANSPACEEND		
 11358                                  	;add	dx,15		;round up para; M006
 11359 000008E4 BA10AA                  	mov	dx,TRANSPACEEND+15
 11360                                  
 11361 000008E7 D3EA                    	shr	dx,cl		;para size of transient; M006
 11362 000008E9 01DA                    	add	dx,bx		;dx = top of transient; M006
 11363                                  
 11364 000008EB 39D8                    	cmp	ax,bx		; M006
 11365 000008ED 7211                    	jb	short ENOUGH_MEM
 11366                                  				; Batchseg below transient
 11367                                  				; enough memory ; M006
 11368 000008EF 39D0                    	cmp	ax,dx		; M006
 11369 000008F1 770D                    	ja	short ENOUGH_MEM	
 11370                                  				; Batchseg above transient
 11371                                  				; enough memory ; M006
 11372                                  
 11373                                  ; M006; Batchseg overlaps transient -- insufficient memory
 11374                                  
 11375 000008F3 58                      	pop	ax		; restore ax; M006
 11376                                  
 11377                                  	; 12/02/2023
 11378                                  	; MSDOS 3.3
 11379                                  ; M006;	cmp	ax,bx		;G do we end before the transient
 11380                                  ; M006;	pop	ax		;G get batch segment back
 11381                                  ; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue
 11382                                  
 11383                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11384 000008F4 06                      	push	es		;G no we're hitting the transient
 11385 000008F5 8EC0                    	mov	es,ax
 11386 000008F7 B80049                  	mov	ax,4900h
 11387                                  	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
 11388 000008FA CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11389                                  			; ES = segment address of area to be freed
 11390 000008FC 07                      	pop	es
 11391                                  MEM_ERROR:
 11392 000008FD E9B800                  	jmp	NO_MEMORY	;G Set up for message and exit
 11393                                  
 11394                                  ENOUGH_MEM:
 11395                                  	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
 11396                                  	; MSDOS 6.0
 11397 00000900 58                      	pop	ax		; restore ax; M006
 11398                                  
 11399                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11400 00000901 26A3[E701]              	mov	[es:Batch],ax
 11401 00000905 E8DFFE                  	call	ALLOC_TPA
 11402                                  
 11403                                  ; Initialize batch segment
 11404                                  
 11405 00000908 5A                      	pop	dx		; length of name
 11406 00000909 58                      	pop	ax		;G get saved batch segment back
 11407 0000090A 26FF06[4C02]            	inc	word [es:Nest]	;G increment # batch files in progress
 11408 0000090F 06                      	push	es
 11409 00000910 268E06[E701]            	mov	es,[es:Batch]
 11410                                  	;mov	byte [ES:0],0
 11411                                  				; signal batch file type
 11412 00000915 26C606000000            	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
 11413                                  	;;mov	[es:2],ax	; MSDOS 3.3
 11414                                  				;G save segment of last batch file
 11415                                  	;mov	[es:3],ax	; MSDOS 6.0
 11416 0000091B 26A30300                	mov	[es:BATCHSEGMENT.BatLast],ax
 11417 0000091F 1E                      	push	ds
 11418 00000920 8E1E[F39D]              	mov	ds,[RESSEG]	;G set to resident data
 11419                                  
 11420 00000924 31C0                    	xor	ax,ax
 11421 00000926 8A1E[4902]              	mov	bl,[ForFlag]	;G get the current FOR state
 11422                                  	;;mov	[es:6],bl	; MSDOS 3.3
 11423                                  				;G save it in the batch segment
 11424                                  	;mov	[es:7],bl	; MSDOS 6.0 	
 11425 0000092A 26881E0700              	mov	[es:BATCHSEGMENT.BatForFlag],bl
 11426 0000092F F6C3FF                  	test	bl,-1 ; 0FFh	;G are we in a FOR?
 11427 00000932 7406                    	jz	short FOR_NOT_ON ;G no, for segment set to 0	
 11428                                  	;mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11429                                  	;mov	byte [ForFlag],0 ;G reset forflag
 11430                                  	; 26/07/2024
 11431 00000934 A2[4902]                	mov	[ForFlag],al ; 0
 11432 00000937 A1[4A02]                	mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11433                                  FOR_NOT_ON:
 11434                                  	;;mov	[es:4],ax	; MSDOS 3.3
 11435                                  				;G save FOR segment in batch segment
 11436                                  	;mov	[es:5],ax	; MSDOS 6.0		
 11437 0000093A 26A30500                	mov	[es:BATCHSEGMENT.BatForPtr],ax	
 11438 0000093E 31C0                    	xor	ax,ax
 11439 00000940 A3[4A02]                	mov	[ForPtr],ax	;G make sure for segment is not active
 11440 00000943 8A1E[3B02]              	mov	bl,[EchoFlag]
 11441 00000947 1F                      	pop	ds
 11442                                  	;mov	[es:1],bl 
 11443                                  				 ;G save echo state of parent
 11444 00000948 26881E0100              	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
 11445                                  ;SR;
 11446                                  ; Initialize the new BatchEOF flag we have added to 0
 11447                                  
 11448                                  	; MSDOS 6.0
 11449                                  	;mov	byte [es:2],0
 11450 0000094D 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 11451                                  
 11452                                  	;mov	[es:08h],ax  ; MSDOS 6.0
 11453 00000953 26A30800                	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
 11454                                  	;mov	[es:0Ah],ax  ; MSDOS 6.0	
 11455 00000957 26A30A00                	mov	[es:BATCHSEGMENT.BatSeek+2],ax
 11456                                  
 11457                                  ; Initialize pointers
 11458                                  
 11459 0000095B 48                      	dec	ax		; put -1 into AX
 11460                                  	;;mov	di,0Bh  ; MSDOS 3.3
 11461                                  				; point to parm area
 11462                                  	;mov	di,0Ch	; MSDOS 6.0
 11463 0000095C BF0C00                  	mov	di,BATCHSEGMENT.BatParm
 11464 0000095F 89FB                    	mov	bx,di
 11465 00000961 B90A00                  	mov	cx,10
 11466 00000964 F3AB                    	rep stosw		; Init to no parms
 11467                                  
 11468                                  ; Move in batch file name
 11469                                  
 11470 00000966 89D1                    	mov	cx,dx
 11471 00000968 F3A4                    	rep	movsb
 11472                                  
 11473                                  ; Now copy the command line into batch segment, parsing the arguments along
 11474                                  ; the way. Segment will look like this:
 11475                                  ;
 11476                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
 11477                                  ;
 11478                                  ; or, in the case of fewer arguments:
 11479                                  ;
 11480                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
 11481                                  
 11482 0000096A BE[549C]                	mov	si,COMBUF+2
 11483                                  	;mov	cx,10		; at most 10 arguments
 11484                                  	; 07/06/2023
 11485 0000096D B10A                    	mov	cl,10
 11486                                  EACHPARM:
 11487 0000096F E8BC21                  	call	scanoff		; skip to argument
 11488                                  
 11489                                  ; AL is first non-delimiter. DS:SI points to char = AL
 11490                                  
 11491 00000972 3C0D                    	cmp	al,0Dh		; end of road?
 11492 00000974 741D                    	jz	short HAVPARM	; yes, no more arguments
 11493                                  
 11494                                  ; If CX = 0 then we have stored the most parm we can. Skip store
 11495                                  
 11496 00000976 E306                    	jcxz	MOVPARM		; Only first 10 parms get pointers
 11497                                  
 11498                                  ; Go into allocated piece and stick in new argument pointer.
 11499                                  
 11500 00000978 26893F                  	mov	[es:bx],di	; store batch pointer
 11501 0000097B 83C302                  	add	bx,2		; advance arg counter
 11502                                  
 11503                                  ; Move the parameter into batch segment
 11504                                  
 11505                                  MOVPARM:
 11506 0000097E AC                      	lodsb			; get byte
 11507 0000097F E8B421                  	call	DELIM		; if delimiter
 11508 00000982 7407                    	jz	short ENDPARM	; then done with parm
 11509 00000984 AA                      	stosb			; store byte
 11510 00000985 3C0D                    	cmp	al,0Dh		; if CR then not delimiter
 11511 00000987 740A                    	jz	short HAVPARM	; but end of parm list, finish
 11512 00000989 EBF3                    	jmp	short MOVPARM
 11513                                  
 11514                                  ; We have copied a parameter up until the first separator.
 11515                                  ; Terminate it with CR.
 11516                                  
 11517                                  ENDPARM:
 11518 0000098B B00D                    	mov	al,0Dh
 11519 0000098D AA                      	stosb
 11520 0000098E E3DF                    	jcxz	EACHPARM	; if no parameters, don't dec
 11521 00000990 49                      	dec	cx		; remember that we've seen one.	
 11522 00000991 EBDC                    	jmp	short EACHPARM
 11523                                  
 11524                                  ; We have parsed the entire line. Terminate the arg list
 11525                                  
 11526                                  HAVPARM:
 11527 00000993 30C0                    	xor	al,al		; Nul terminate the parms
 11528 00000995 AA                      	stosb
 11529                                  
 11530                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
 11531                                  ; into paragraphs and setblock to the appropriate size
 11532                                  
 11533 00000996 8D5D0F                  	lea	bx,[di+15]
 11534 00000999 B104                    	mov	cl,4
 11535 0000099B D3EB                    	shr	bx,cl
 11536 0000099D B44A                    	mov	ah,4Ah
 11537                                  	;mov	ah,SETBLOCK ; 4Ah
 11538 0000099F CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 11539                                  			; ES = segment address of block	to change
 11540                                  			; BX = new size	in paragraphs
 11541 000009A1 07                      	pop	es
 11542 000009A2 06                      	push	es
 11543 000009A3 1F                      	pop	ds		; Simply batch FCB setup
 11544 000009A4 833E[4302]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 11545 000009A9 7506                    	jne	short NOBATSING
 11546 000009AB C706[4302]F0FF          	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job
 11547                                  
 11548                                  NOBATSING:
 11549                                  
 11550                                  ; Enter the batch file with the current echo state
 11551                                  
 11552 000009B1 58                      	pop	ax		; Get original echo state
 11553 000009B2 A2[3B02]                	mov	[EchoFlag],al	; restore it
 11554 000009B5 E94CF7                  	jmp	TCOMMAND
 11555                                  
 11556                                  ; The following is executed if there isn't enough memory for batch segment
 11557                                  
 11558                                  NO_MEMORY:
 11559 000009B8 5A                      	pop	dx		; even up our stack 
 11560 000009B9 58                      	pop	ax
 11561 000009BA 58                      	pop	ax
 11562 000009BB E829FE                  	call	ALLOC_TPA	; reallocate memory
 11563                                  
 11564                                  	; 12/02/2023
 11565                                  	; MSDOS 3.3
 11566                                  	;mov	dx,INSFMEMMESPTR
 11567                                  	;jmp	CERROR
 11568                                  
 11569                                  	; MSDOS 6.0
 11570                                  	;mov	byte [msg_disp_class],1
 11571 000009BE C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class
 11572                                  				;AN000; set up extended error msg class
 11573                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 11574 000009C3 BA[D091]                	mov	dx,extend_buf_ptr
 11575                                  	;			;AC000; get extended message pointer
 11576                                  	;mov	word [extend_buf_ptr],8
 11577 000009C6 C706[D091]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 11578                                  				;AN000; get message number in control block
 11579 000009CC E9D324                  	jmp	cerror		;g print error message and go...
 11580                                  
 11581                                  ; =============== S U B	R O U T	I N E =======================================
 11582                                  
 11583                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11584                                  BATCHOFF:
 11585 000009CF 50                      	push	ax
 11586 000009D0 06                      	push	es
 11587 000009D1 1E                      	push	ds
 11588 000009D2 53                      	push	bx
 11589                                  
 11590 000009D3 2E8E06[F39D]            	mov	es,[cs:RESSEG]
 11591                                  	;mov	ds,[cs:RESSEG]
 11592                                  	; 26/07/2024
 11593 000009D8 06                      	push	es
 11594 000009D9 1F                      	pop	ds
 11595                                  
 11596 000009DA A1[E701]                	mov	ax,[Batch]	; Free the batch segment
 11597 000009DD 09C0                    	or	ax,ax
 11598 000009DF 7442                    	jz	short NOTFREE
 11599                                  
 11600 000009E1 06                      	push	es
 11601 000009E2 8EC0                    	mov	es,ax
 11602 000009E4 F606[3B02]01            	test	byte [EchoFlag],1
 11603                                  				;G Is echo on?
 11604 000009E9 7505                    	jnz	short ECHO_LAST_LINE
 11605                                  				;G Yes - echo last line in file
 11606                                  	;mov	byte [SUPPRESS],0
 11607 000009EB C606[3C02]00            	mov	byte [Suppress],NO_ECHO
 11608                                  				;G no - don't echo last line in file	
 11609                                  ECHO_LAST_LINE:
 11610                                  	;mov	bl,[es:1]
 11611 000009F0 268A1E0100              	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
 11612                                  				; G get echo state
 11613 000009F5 881E[3B02]              	mov	[EchoFlag],bl
 11614                                  				; G  and restore it
 11615                                  	;;mov	bx,[es:4]  ; MSDOS 3.3
 11616                                  	;mov	bx,[es:5]  ; MSDOS 6.0
 11617 000009F9 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr]
 11618                                  				;G Get FOR segment
 11619 000009FE 891E[4A02]              	mov	[ForPtr],bx	;G  and restore it
 11620                                  	;;mov	bl,[es:6]  ; MSDOS 3.3
 11621                                  	;mov	bl,[es:7]  ; MSDOS 6.0	
 11622 00000A02 268A1E0700              	mov	bl,[es:BATCHSEGMENT.BatForFlag]
 11623                                  				;G Get FOR flag
 11624 00000A07 881E[4902]              	mov	[ForFlag],bl
 11625                                  				;G  and restore it
 11626                                  	;;mov	bx,[es:2] ; MSDOS 3.3
 11627                                  	;mov	bx,[es:3] ; MSDOS 6.0	
 11628 00000A0B 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 11629                                  				;G  Get old batch segment
 11630                                  
 11631 00000A10 B449                    	mov	ah,49h
 11632                                  	;mov	ah,DEALLOC ; 49h
 11633 00000A12 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11634                                  			; ES = segment address of area to be freed
 11635 00000A14 07                      	pop	es
 11636 00000A15 891E[5002]              	mov	[Next_Batch],bx	;G reset batch segment	
 11637 00000A19 26FF0E[4C02]            	dec	word [es:Nest]
 11638 00000A1E 31C0                    	xor	ax,ax
 11639 00000A20 A3[E701]                	mov	[Batch],ax	; No batch in progress
 11640                                  NOTFREE:
 11641 00000A23 5B                      	pop	bx
 11642 00000A24 1F                      	pop	ds
 11643 00000A25 07                      	pop	es
 11644 00000A26 58                      	pop	ax
 11645 00000A27 C3                      	retn
 11646                                  
 11647                                  ; =============== S U B	R O U T	I N E =======================================
 11648                                  
 11649                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11650                                  
 11651                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
 11652                                  ;	Entry : DS:SI ==> source string
 11653                                  ;		ES:DI ==> destination string
 11654                                  ;		CX = current length of destination string
 11655                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
 11656                                  
 11657                                  	; 12/02/2023	
 11658                                  	; MSDOS 3.3
 11659                                  ;STRCPY:
 11660                                  	;push	ax
 11661                                  ;CCYCLE:
 11662                                  	;lodsb
 11663                                  	;stosb
 11664                                  	;or	al,al
 11665                                  	;jnz	short CCYCLE
 11666                                  	;pop	ax
 11667                                  	;retn
 11668                                  
 11669                                  ;Procedure StrCpy,NEAR
 11670                                  
 11671                                  	; 12/02/2023
 11672                                  	; MSDOS 6.0
 11673                                  STRCPY:
 11674 00000A28 50                      	push	ax
 11675                                  ccycle:
 11676 00000A29 AC                      	lodsb
 11677 00000A2A 41                      	inc	cx
 11678                                  	;cmp	cx,128
 11679 00000A2B 81F98000                	cmp	cx,COMBUFLEN
 11680                                  	;jb	short ccopy
 11681                                  	;stc			; set carry to signal error
 11682                                  	;jmp	short ccend
 11683                                  	; 12/02/2023
 11684 00000A2F F5                      	cmc
 11685 00000A30 7205                    	jc	short ccend
 11686                                  ccopy:
 11687 00000A32 AA                      	stosb
 11688 00000A33 08C0                    	or	al,al
 11689 00000A35 75F2                    	jnz	short ccycle
 11690                                  ccend:
 11691 00000A37 49                      	dec	cx		; discount extra byte
 11692 00000A38 4F                      	dec	di		; back up pointer
 11693 00000A39 58                      	pop	ax
 11694 00000A3A C3                      	retn			; return carry clear
 11695                                  
 11696                                  ;EndProc StrCpy
 11697                                  
 11698                                  ;============================================================================
 11699                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
 11700                                  ;============================================================================
 11701                                  ; 12/10/2018 - Retro DOS v3.0
 11702                                  
 11703                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
 11704                                  
 11705                                  ; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11706                                  
 11707                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h
 11708                                  
 11709                                  ; =============== S U B	R O U T	I N E =======================================
 11710                                  
 11711                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
 11712                                  
 11713                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
 11714                                  ; <CR> and ends batch mode. DS must be set to resident segment.
 11715                                  ; AH, DX destroyed.
 11716                                  
 11717                                  GETBATBYT:
 11718 00000A3B 53                      	push	bx
 11719 00000A3C 51                      	push	cx
 11720 00000A3D 1E                      	push	ds
 11721 00000A3E F606[3102]FF            	test	byte [Batch_Abort],-1
 11722                                  	;jnz	short BATEOF
 11723                                  	; 14/02/2023
 11724 00000A43 7403                    	jz	short getbatbyt1
 11725 00000A45 E9D100                  	jmp	BATEOF
 11726                                  getbatbyt1:
 11727 00000A48 F706[E701]FFFF          	test	word [Batch],-1
 11728                                  	;jz	short BATEOF
 11729                                  	; 14/02/2023
 11730 00000A4E 7503                    	jnz	short getbatbyt2
 11731 00000A50 E9C600                  	jmp	BATEOF
 11732                                  getbatbyt2:
 11733 00000A53 06                      	push	es
 11734 00000A54 8E06[E701]              	mov	es,[Batch]
 11735                                  
 11736                                  	; MSDOS 6.0
 11737                                  ;M020;
 11738                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
 11739                                  ;try to read from the batchfile again.
 11740                                  
 11741                                  	;cmp	byte [es:2],0
 11742 00000A58 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11743                                  				;already reached EOF?	;M020
 11744 00000A5E 7403                    	jz	short not_eof	;no, read batch file	;M020
 11745 00000A60 E99C00                  	jmp	At_EOF		;yes, no more reads	;M020
 11746                                  not_eof:						;M020
 11747                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11748                                  	;add	word [es:8],1	; MSDOS 6.0
 11749 00000A63 268306080001            	add	word [es:BATCHSEGMENT.BatSeek],1
 11750                                  	;adc	word [es:10],0	; MSDOS 6.0
 11751 00000A69 2683160A0000            	adc	word [es:BATCHSEGMENT.BatSeek+2],0
 11752 00000A6F 07                      	pop	es
 11753                                  
 11754                                  ; See if we have bytes buffered...
 11755                                  
 11756 00000A70 8CC8                    	mov	ax,cs
 11757 00000A72 8ED8                    	mov	ds,ax
 11758 00000A74 8B1E[B9A9]              	mov	bx,[BATBUFPOS]
 11759 00000A78 83FBFF                  	cmp	bx,-1
 11760 00000A7B 7540                    	jnz	short UNBUF
 11761                                  
 11762                                  ; There are no bytes in the buffer. Let's try to fill it up.
 11763                                  
 11764 00000A7D BA[BBA9]                	mov	dx,BATBUF
 11765 00000A80 8B0E[7597]              	mov	cx,[BATBUFLEN] ; max to read.
 11766 00000A84 8B1E[E5A1]              	mov	bx,[BATHAND]
 11767                                  	; 14/02/2023
 11768 00000A88 B43F                    	mov	ah,3Fh
 11769                                  	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
 11770 00000A8A CD21                    	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 11771                                  			; BX = file handle,CX = number	of bytes to read
 11772                                  			; DS:DX	-> buffer
 11773                                  	; MSDOS 6.0
 11774 00000A8C 7321                    	jnc	short bat_read_ok	;AN022; if no error - continue
 11775                                  	;invoke	get_ext_error_number	;AN022; get the error
 11776 00000A8E E8B117                  	call	get_ext_error_number
 11777 00000A91 1E                      	push	ds			;AN022; save local segment
 11778 00000A92 8E1E[F39D]              	mov	ds,[RESSEG]		;AN022; get resident segment
 11779                                  	;assume ds:resgroup		;AN022;
 11780 00000A96 89C2                    	mov	dx,ax			;AN022; put error in DX
 11781                                  	;invoke	output_batch_name	;AN022; set up to print the error
 11782 00000A98 E861FB                  	call	output_batch_name
 11783 00000A9B 1F                      	pop	ds			;AN022;
 11784                                  	;assume	ds:trangroup		;AN022;
 11785                                  	;invoke	std_eprintf		;AN022; print out the error
 11786 00000A9C E8684A                  	call	std_eprintf
 11787                                  	;mov	byte ptr combuf+2,end_of_line_in
 11788 00000A9F C606[549C]0D            	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
 11789                                  	;				;AN022; terminate the batch line for parsing
 11790                                  	;mov	byte ptr combuf+3,end_of_line_out 
 11791 00000AA4 C606[559C]00            	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
 11792                                  	;				;AN022; terminate the batch line for output
 11793                                  ;M020;
 11794                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
 11795                                  ;error is never hit (and it shouldn't be)
 11796                                  
 11797 00000AA9 8E1E[F39D]              	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
 11798 00000AAD EB6A                    	jmp	short BATEOF		;AN022; terminate the batch file
 11799                                  bat_read_ok:				;AN022;
 11800                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11801 00000AAF 89C1                    	mov	cx,ax
 11802                                  	;jcxz	TURN_OFF ; MSDOS 3.3
 11803                                  	; 14/02/2023
 11804 00000AB1 E320                    	jcxz	BATEOFDS ; MSDOS 6.0
 11805 00000AB3 890E[DBA9]              	mov	[BATBUFEND],cx
 11806 00000AB7 31DB                    	xor	bx,bx
 11807 00000AB9 891E[B9A9]              	mov	[BATBUFPOS],bx
 11808                                  
 11809                                  	; Buffered bytes!
 11810                                  UNBUF:
 11811 00000ABD 8A87[BBA9]              	mov	al,[BATBUF+bx]		; get next byte
 11812 00000AC1 43                      	inc	bx
 11813 00000AC2 3B1E[DBA9]              	cmp	bx,[BATBUFEND]		; beyond end of buffer?
 11814 00000AC6 7203                    	jb	short SETBUFPOS
 11815 00000AC8 BBFFFF                  	mov	bx,-1
 11816                                  SETBUFPOS:
 11817 00000ACB 891E[B9A9]              	mov	[BATBUFPOS],bx
 11818 00000ACF 3C1A                    	cmp	al,1Ah			; ^Z for termination?
 11819 00000AD1 7575                    	jne	short GETBYTEDONE
 11820                                  
 11821                                  ;We get here only when we hit an EOF
 11822                                  	
 11823                                  	; MSDOS 6.0
 11824                                  BATEOFDS:
 11825                                  ;SR;
 11826                                  ; HACK!!! A massive hack being put in here to get batch processing to work
 11827                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
 11828                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
 11829                                  ;batch processing is turned off before the last line is processed and so 
 11830                                  ;this line would never be executed. 
 11831                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
 11832                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
 11833                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
 11834                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
 11835                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
 11836                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
 11837                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
 11838                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
 11839                                  ;during this call, and there was a CR-LF previously, we are going to fake
 11840                                  ;another redundant CR-LF. There is no work-around I can think of.
 11841                                  ; 	I would love to restructure this entire routine and its caller to
 11842                                  ;make the flow really easy to understand but I guess this will have to wait.
 11843                                  ;
 11844 00000AD3 06                      	push	es
 11845 00000AD4 8E06[F39D]              	mov	es,[RESSEG]
 11846                                  ;SR;
 11847                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
 11848                                  ;or BatchEOF == 1 now), then do not do the LF check.
 11849                                  ;
 11850 00000AD8 268E06[E701]            	mov	es,[es:Batch]
 11851                                  	;cmp	byte [es:2],0
 11852 00000ADD 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11853 00000AE3 7516                    	jnz	short crpresent
 11854                                  
 11855                                  	;inc	byte [es:2]
 11856 00000AE5 26FE060200              	inc	byte [es:BATCHSEGMENT.BatchEOF]
 11857                                  					;match the dec following
 11858 00000AEA 8B1E[DBA9]              	mov	bx,[BATBUFEND]
 11859 00000AEE 80BF[BAA9]0A            	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
 11860 00000AF3 7406                    	je	short crpresent		;yes, no need to fake it
 11861                                  
 11862                                  	;add	byte [es:2],3
 11863 00000AF5 268006020003            	add	byte [es:BATCHSEGMENT.BatchEOF],3
 11864                                  					;BatchEOF == 4 to fake CR-LF
 11865                                  crpresent:
 11866                                  ;;	;pop	es
 11867                                  
 11868                                  	;ASSUME	DS:TranGroup
 11869                                  	; 14/02/2023
 11870 00000AFB 8E1E[F39D]              	mov	ds,[RESSEG]
 11871                                  	;ASSUME	DS:ResGroup
 11872                                  ;SR;
 11873                                  ; The shift operation is done here to replace the decrement. This is because
 11874                                  ;we can jump to this label directly from above when bogus calls are made to
 11875                                  ;this routine even after batch processing is turned off. The shift ensures
 11876                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
 11877                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
 11878                                  ;calls.
 11879                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
 11880                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
 11881                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
 11882                                  ;turning batch processing off.
 11883                                  
 11884                                  At_EOF:					;new label added ;M020
 11885                                  	;shr	byte [es:2],1
 11886 00000AFF 26D02E0200              	shr	byte [es:BATCHSEGMENT.BatchEOF],1
 11887                                  					;decrement the flag
 11888 00000B04 7412                    	jz	short turn_off		;zero,turn batch off
 11889                                  	;cmp	byte [es:2],1
 11890 00000B06 26803E020001            	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
 11891 00000B0C 7405                    	jz	short ret_lf		;BatchEOF was 2, return LF
 11892                                  ;
 11893                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
 11894                                  ;
 11895 00000B0E B00D                    	mov	al,0Dh			;return fake CR.
 11896 00000B10 07                      	pop	es
 11897 00000B11 EB35                    	jmp	short GETBYTEDONE
 11898                                  ret_lf:
 11899 00000B13 B00A                    	mov	al,0Ah			;return fake LF
 11900 00000B15 07                      	pop	es
 11901 00000B16 EB30                    	jmp	short GETBYTEDONE		
 11902                                  turn_off:
 11903 00000B18 07                      	pop	es
 11904                                  ;BATEOF:
 11905                                  	; MSDOS 3.3
 11906                                  ;TURN_OFF:
 11907                                  	;mov	ds,[RESSEG]
 11908                                  
 11909                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11910                                  BATEOF:
 11911 00000B19 E8B3FE                  	call	BATCHOFF
 11912 00000B1C E8CC02                  	call	BATCLOSE
 11913                                  
 11914                                  ;;;	mov	BatchEOF,0	;make sure BatchEOF = 0
 11915                                  
 11916                                  ;SR; BugBug
 11917                                  ; There is a good reason why this carriage return is being returned here. 
 11918                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
 11919                                  ;of the way the caller is structured, a fake CR has to be returned again on
 11920                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
 11921                                  ;results in an extra linefeed after the batchfile is run if the last line of
 11922                                  ;the batchfile already had a CR-LF. 
 11923                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
 11924                                  ;the end-of-line. This CR is to mark the end-of-file.
 11925                                  
 11926 00000B1F B00D                    	mov	al,0Dh			; If end-of-file, then end of line
 11927 00000B21 F606[3102]FF            	test	byte [Batch_Abort],-1
 11928 00000B26 C606[3102]00            	mov	byte [Batch_Abort],0
 11929 00000B2B 7407                    	jz	short CONT_GET_BYT
 11930 00000B2D BF[549C]                	mov	di,COMBUF+2		; reset pointer to beginning of buffer
 11931 00000B30 31C9                    	xor	cx,cx			; zero line length
 11932 00000B32 EB14                    	jmp	short GETBYTEDONE
 11933                                  CONT_GET_BYT:
 11934 00000B34 833E[4302]F0            	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
 11935 00000B39 750D                    	jne	short GETBYTEDONE
 11936 00000B3B 833E[4C02]00            	cmp	word [Nest],0		;G See if we have nested batch files
 11937 00000B40 7506                    	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
 11938 00000B42 C706[4302]FFFF          	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
 11939                                  GETBYTEDONE:
 11940 00000B48 1F                      	pop	ds
 11941 00000B49 59                      	pop	cx
 11942 00000B4A 5B                      	pop	bx
 11943 00000B4B C3                      	retn
 11944                                  
 11945                                  ; ---------------------------------------------------------------------------
 11946                                  
 11947                                  ;break	<$If - conditional execution>
 11948                                  
 11949                                  	; 17/04/2023
 11950                                  ;IFERRORP:
 11951                                  ;	pop	ax
 11952                                  ;IFERROR:
 11953                                  ;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11954                                  ;FORERROR:
 11955                                  ;	mov	dx,SYNTMES_PTR
 11956                                  ;	jmp	cerror
 11957                                  
 11958                                  ; ---------------------------------------------------------------------------
 11959                                  
 11960                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11961                                  	;
 11962                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 11963                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0B69h
 11964                                  _$IF:
 11965                                  	; MSDOS 6.0
 11966                                  ; Turn off any pipes in progress.
 11967 00000B4C 1E                      	push	ds			;AN004; save local DS
 11968 00000B4D 8E1E[F39D]              	mov	ds,[RESSEG]		;AN004; get resident segment
 11969                                  	;assume	ds:resgroup		;AN004;
 11970 00000B51 803E[B602]00            	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
 11971 00000B56 7403                    	jz	short IFNoPipe		;AN004; no pipe - continue
 11972                                  	;invoke	PipeDel 		;AN004; turn off piping
 11973 00000B58 E8E226                  	call	PIPEDEL	
 11974                                  IFNoPipe:				;AN004;
 11975 00000B5B 1F                      	pop	ds			;AN004; get local DS back
 11976                                  	;assume	ds:trangroup		;AN004;
 11977                                  
 11978                                  	; MSDOS 3.3 (&MSDOS 6.0)
 11979 00000B5C C606[049E]00            	mov	byte [IFNOTFLAG],0
 11980 00000B61 C706[8DA8]0000          	mov	word [IF_NOT_COUNT],0
 11981 00000B67 BE8100                  	mov	si,81h
 11982                                  IFREENT:
 11983 00000B6A E8C11F                  	call	scanoff
 11984 00000B6D 3C0D                    	cmp	al,0Dh
 11985 00000B6F 743C                    	je	short IFERROR
 11986 00000B71 89F5                    	mov	bp,si
 11987 00000B73 BF[C395]                	mov	di,IFTAB		; Prepare to search if table	
 11988                                  	;mov	ch,0
 11989                                  	; 17/04/2023
 11990 00000B76 30ED                    	xor	ch,ch
 11991                                  IFINDCOM:
 11992 00000B78 89EE                    	mov	si,bp
 11993 00000B7A 8A0D                    	mov	cl,[di]
 11994 00000B7C 47                      	inc	di
 11995 00000B7D E33E                    	jcxz	IFSTRING
 11996 00000B7F EB02                    	jmp	short FIRSTCOMP
 11997                                  IFCOMP:
 11998 00000B81 7510                    	jnz	short IF_DIF
 11999                                  FIRSTCOMP:
 12000 00000B83 AC                      	lodsb
 12001 00000B84 268A25                  	mov	ah,[es:di]
 12002 00000B87 47                      	inc	di
 12003 00000B88 38E0                    	cmp	al,ah
 12004 00000B8A 7405                    	je	short IFLP
 12005 00000B8C 80CC20                  	or	ah,20h			; Try lower case
 12006 00000B8F 38E0                    	cmp	al,ah
 12007                                  IFLP:
 12008 00000B91 E2EE                    	loop	IFCOMP
 12009                                  IF_DIF:
 12010 00000B93 9F                      	lahf
 12011 00000B94 01CF                    	add	di,cx			; Bump to next position without affecting flags
 12012 00000B96 8B1D                    	mov	bx,[di]			; Get handler address
 12013 00000B98 47                      	inc	di
 12014 00000B99 47                      	inc	di
 12015 00000B9A 9E                      	sahf
 12016 00000B9B 75DB                    	jnz	short IFINDCOM
 12017 00000B9D AC                      	lodsb
 12018 00000B9E 3C0D                    	cmp	al,0Dh
 12019                                  IFERRJ:
 12020 00000BA0 740B                    	jz	short IFERROR
 12021 00000BA2 E8911F                  	call	DELIM
 12022 00000BA5 75D1                    	jnz	short IFINDCOM
 12023 00000BA7 E8841F                  	call	scanoff
 12024 00000BAA FFE3                    	jmp	bx
 12025                                  
 12026                                  	; 17/04/2023
 12027                                  IFERRORP:
 12028 00000BAC 58                      	pop	ax
 12029                                  IFERROR:
 12030                                  	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 12031                                  FORERROR:
 12032 00000BAD BA[6892]                	mov	dx,SYNTMES_PTR
 12033 00000BB0 E9EF22                  	jmp	cerror
 12034                                  
 12035                                  IFNOT:
 12036 00000BB3 F616[049E]              	not	byte [IFNOTFLAG]
 12037 00000BB7 FF06[8DA8]              	inc	word [IF_NOT_COUNT]
 12038 00000BBB EBAD                    	jmp	short IFREENT
 12039                                  
 12040                                  ; We are comparing two strings for equality. First, find the end of the
 12041                                  ; first string.
 12042                                  
 12043                                  IFSTRING:
 12044 00000BBD 56                      	push	si			; save away pointer for later compare
 12045 00000BBE 31C9                    	xor	cx,cx			; count of chars in first string
 12046                                  FIRST_STRING:
 12047 00000BC0 AC                      	lodsb				; get character
 12048 00000BC1 3C0D                    	cmp	al,0Dh			; end of line?
 12049 00000BC3 74E7                    	jz	short IFERRORP		; yes => error
 12050 00000BC5 E86E1F                  	call	DELIM			; is it a delimiter?
 12051 00000BC8 7403                    	jz	short EQUAL_CHECK 	; yes, go find equal sign
 12052 00000BCA 41                      	inc	cx			; remember 1 byte for the length
 12053 00000BCB EBF3                    	jmp	short FIRST_STRING 	; go back for more
 12054                                  EQUAL_CHECK:
 12055 00000BCD 3C3D                    	cmp	al,'='			; is char we have an = sign?
 12056 00000BCF 7407                    	je	short EQUAL_CHECK2 	; yes, go find second one.
 12057 00000BD1 3C0D                    	cmp	al,0Dh			; end of line?
 12058 00000BD3 74D7                    	je	short IFERRORP		; yes, syntax error
 12059 00000BD5 AC                      	lodsb				; get next char
 12060 00000BD6 EBF5                    	jmp	short EQUAL_CHECK
 12061                                  
 12062                                  ; The first = has been found. The next char had better be an = too.
 12063                                  
 12064                                  EQUAL_CHECK2:
 12065 00000BD8 AC                      	lodsb				; get potential = char
 12066 00000BD9 3C3D                    	cmp	al,'='			; is it good?	
 12067                                  	;jnz	short IFERRPJ		; no, error
 12068                                  	; 17/04/2023
 12069 00000BDB 75CF                    	jne	short IFERRORP
 12070                                  
 12071                                  ; Find beginning of second string.
 12072                                  
 12073 00000BDD E84E1F                  	call	scanoff
 12074 00000BE0 3C0D                    	cmp	al,0Dh
 12075                                  	;jz	short IFERRPJ
 12076                                  	; 17/04/2023
 12077 00000BE2 74C8                    	je	short IFERRORP
 12078 00000BE4 5F                      	pop	di
 12079                                  
 12080                                  ; DS:SI points to second string
 12081                                  ; CX has number of chars in first string
 12082                                  ; ES:DI points to first string
 12083                                  
 12084 00000BE5 F3A6                    	repe	cmpsb
 12085 00000BE7 7414                    	jz	short MATCH		; match found!
 12086                                  
 12087                                  ; No match. Let's find out what was wrong. The character that did not match
 12088                                  ; has been advanced over. Let's back up to it.
 12089                                  
 12090 00000BE9 4E                      	dec	si
 12091                                  
 12092                                  ; If it is EOL, then syntax error
 12093                                  
 12094 00000BEA 803C0D                  	cmp	byte [si],0Dh
 12095                                  	;jz	short IFERRJ
 12096                                  	; 17/04/2023
 12097 00000BED 74BE                    	je	short IFERROR
 12098                                  
 12099                                  ; Advance pointer over remainder of unmatched text to next delimiter
 12100                                  
 12101                                  SKIPSTRINGEND:
 12102 00000BEF AC                      	lodsb
 12103                                  NOTMATCH:
 12104 00000BF0 3C0D                    	cmp	al,0Dh
 12105                                  IFERRORJ2:
 12106                                  	;jz	short IFERRJ
 12107                                  	; 17/04/2023
 12108 00000BF2 74B9                    	jz	short IFERROR
 12109 00000BF4 E83F1F                  	call	DELIM
 12110 00000BF7 75F6                    	jnz	short SKIPSTRINGEND
 12111                                  
 12112                                  ; Signal that we did NOT have a match
 12113                                  
 12114 00000BF9 B0FF                    	mov	al,-1	 ; 0FFh
 12115 00000BFB EB37                    	jmp	short IFRET
 12116                                  
 12117                                  	; 17/04/2023
 12118                                  ;IFERRPJ:
 12119                                  	;jmp	IFERRORP
 12120                                  
 12121                                  ; The compare succeeded. Was the second string longer than the first?
 12122                                  ; We do this by seeing if the next char is a delimiter.
 12123                                  
 12124                                  MATCH:
 12125 00000BFD AC                      	lodsb
 12126 00000BFE E8351F                  	call	DELIM
 12127 00000C01 75ED                    	jnz	short NOTMATCH ; not same.
 12128 00000C03 30C0                    	xor	al,al
 12129 00000C05 EB2D                    	jmp	short IFRET
 12130                                  
 12131                                  ; ---------------------------------------------------------------------------
 12132                                  
 12133                                  IFEXISTS:
 12134                                  
 12135                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
 12136                                  
 12137                                  ;MOREDELIM:
 12138 00000C07 AC                      	lodsb
 12139 00000C08 E82B1F                  	call	DELIM
 12140 00000C0B 75FA                    	jnz	short IFEXISTS
 12141                                  	;jnz	short MOREDELIM
 12142                                  
 12143 00000C0D BA[2AA0]                	mov	dx,DIRBUF
 12144 00000C10 B8001A                  	mov	ax,1A00h
 12145                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12146 00000C13 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12147                                  			; DS:DX	-> disk	transfer buffer
 12148 00000C15 BB0200                  	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
 12149 00000C18 031E[8DA8]              	add	bx,[IF_NOT_COUNT]
 12150                                  	;mov	ax,ARG_ARGV
 12151                                  	;mov	ax,ARG+ARG_UNIT.argv
 12152 00000C1C B8[41A2]                	mov	ax,ARG
 12153 00000C1F E87C2A                  	call	argv_calc		; convert arg index to pointer
 12154 00000C22 8B17                    	mov	dx,[bx]
 12155                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12156                                  	;mov	cx,6
 12157 00000C24 B90600                  	mov	cx,IFEXIST_ATTR ; filetypes to search for
 12158 00000C27 B8004E                  	mov	ax,4E00h
 12159                                  	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 12160 00000C2A CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12161                                  			; CX = search attributes
 12162                                  			; DS:DX	-> ASCIZ filespec
 12163                                  			; (drive,path, and wildcards allowed)
 12164 00000C2C 7204                    	jc	short IF_EX_C ; carry is how to determine error
 12165 00000C2E 30C0                    	xor	al,al
 12166 00000C30 EB02                    	jmp	short IFRET
 12167                                  
 12168                                  	;nop
 12169                                  IF_EX_C:
 12170 00000C32 B0FF                    	mov	al,-1	; 0FFh	; false 'n' fall through...
 12171                                  IFRET:
 12172 00000C34 F606[049E]FF            	test	byte [IFNOTFLAG],-1 ; 0FFh
 12173 00000C39 7402                    	jz	short REALTEST
 12174 00000C3B F6D0                    	not	al
 12175                                  REALTEST:
 12176 00000C3D 08C0                    	or	al,al
 12177 00000C3F 7403                    	jz	short IFTRUE
 12178 00000C41 E9C0F4                  	jmp	TCOMMAND
 12179                                  
 12180                                  IFTRUE:
 12181 00000C44 E8E71E                  	call	scanoff
 12182 00000C47 89F1                    	mov	cx,si
 12183 00000C49 81E98100                	sub	cx,81h
 12184 00000C4D 280E8000                	sub	[80h],cl
 12185 00000C51 8A0E8000                	mov	cl,[80h]
 12186 00000C55 880E[539C]              	mov	[COMBUF+1],cl
 12187 00000C59 BF[549C]                	mov	di,COMBUF+2
 12188 00000C5C FC                      	cld
 12189 00000C5D F3A4                    	rep	movsb
 12190 00000C5F B00D                    	mov	al,0Dh
 12191 00000C61 AA                      	stosb
 12192                                  
 12193                                  ; Signal that an IF was done. 
 12194                                  ; This prevents the redirections from getting lost.
 12195                                  
 12196 00000C62 1E                      	push	ds
 12197 00000C63 8E1E[F39D]              	mov	ds,[RESSEG]
 12198 00000C67 C606[4802]FF            	mov	byte [IfFlag],-1
 12199 00000C6C 1F                      	pop	ds
 12200                                  
 12201                                  ; Go do the command
 12202                                  
 12203                                  	;jmp	DOCOM1 ; MSDOS 5.0 COMMAND.COM
 12204                                  	; 07/06/2023
 12205                                  	; Retro DOS v4.2 COMMAND.COM
 12206 00000C6D E983F6                  	jmp	DOCOM0 ; MSDOS 6.22 COMMAND.COM
 12207                                  
 12208                                  ; ---------------------------------------------------------------------------
 12209                                  
 12210                                  IFERRORJ3:
 12211 00000C70 EB80                    	jmp	IFERRORJ2
 12212                                  
 12213                                  IFERLEV:
 12214 00000C72 B70A                    	mov	bh,10
 12215 00000C74 30DB                    	xor	bl,bl
 12216                                  GETNUMLP:
 12217 00000C76 AC                      	lodsb
 12218 00000C77 3C0D                    	cmp	al,0Dh
 12219 00000C79 74F5                    	je	short IFERRORJ3
 12220 00000C7B E8B81E                  	call	DELIM
 12221 00000C7E 740C                    	jz	short GOTNUM
 12222 00000C80 2C30                    	sub	al,'0'
 12223 00000C82 86C3                    	xchg	al,bl
 12224 00000C84 F6E7                    	mul	bh
 12225 00000C86 00D8                    	add	al,bl
 12226 00000C88 86C3                    	xchg	al,bl
 12227 00000C8A EBEA                    	jmp	short GETNUMLP
 12228                                  GOTNUM:
 12229 00000C8C 1E                      	push	ds
 12230 00000C8D 8E1E[F39D]              	mov	ds,[RESSEG]
 12231 00000C91 8A26[3802]              	mov	ah,[RetCode]
 12232 00000C95 1F                      	pop	ds
 12233 00000C96 30C0                    	xor	al,al
 12234 00000C98 38DC                    	cmp	ah,bl
 12235 00000C9A 7398                    	jnb	short IFRET
 12236 00000C9C FEC8                    	dec	al
 12237 00000C9E EB94                    	jmp	short IFRET
 12238                                  
 12239                                  ; ---------------------------------------------------------------------------
 12240                                  
 12241                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
 12242                                  ; This is a NOP if no batch in progress.
 12243                                  
 12244                                  _SHIFT:
 12245 00000CA0 8E1E[F39D]              	mov	ds,[RESSEG]
 12246 00000CA4 A1[E701]                	mov	ax,[Batch]		; get batch pointer
 12247 00000CA7 09C0                    	or	ax,ax			; in batch mode?
 12248 00000CA9 7501                    	jnz	short SHIFT1		; yes, operate in batch segment	
 12249                                  SHIFT_RETN:				; no, done.
 12250 00000CAB C3                      	retn
 12251                                  SHIFT1:
 12252 00000CAC 8EC0                    	mov	es,ax
 12253 00000CAE 8ED8                    	mov	ds,ax
 12254                                  
 12255                                  ; Now move the batch args down by 1 word
 12256                                  
 12257                                  	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
 12258                                  	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
 12259 00000CB0 BF0C00                  	mov	di,BATCHSEGMENT.BatParm ; point to parm table
 12260 00000CB3 8D7502                  	lea	si,[di+2]		; make source = dest + 2
 12261 00000CB6 B90900                  	mov	cx,9			; move 9 parameters
 12262 00000CB9 F3A5                    	rep	movsw			; SHIFT down
 12263                                  
 12264                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
 12265                                  ; We have copied it into the previous position.
 12266                                  
 12267 00000CBB 833DFF                  	cmp	word [di],-1	; if last one was not in use then
 12268 00000CBE 74EB                    	je	short SHIFT_RETN ; No new parm
 12269                                  
 12270                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
 12271                                  ; Assume, first, that there is no next argument.
 12272                                   
 12273 00000CC0 8B35                    	mov	si,[di]
 12274 00000CC2 C705FFFF                	mov	word [di],-1		; Assume no parm
 12275                                  
 12276                                  ; The parameters are CR separated. Scan for end of this parm.
 12277                                  
 12278                                  SKIPCRLP:
 12279 00000CC6 AC                      	lodsb
 12280 00000CC7 3C0D                    	cmp	al,0Dh
 12281 00000CC9 75FB                    	jne	short SKIPCRLP
 12282                                  
 12283                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
 12284                                  ; are finished. There are no more parms and the pointer has been previously
 12285                                  ; initialized to indicate it.
 12286                                  
 12287 00000CCB 803C00                  	cmp	byte [si],0
 12288 00000CCE 74DB                    	jz	short SHIFT_RETN 	; End of parms
 12289 00000CD0 8935                    	mov	[di],si			; Pointer to next parm as %9
 12290 00000CD2 C3                      	retn
 12291                                  
 12292                                  ; =============== S U B	R O U T	I N E =======================================
 12293                                  
 12294                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
 12295                                  ; returns char in AL, carry set -> eof
 12296                                  
 12297                                  SKIPDELIM:
 12298 00000CD3 F706[E701]FFFF          	test	word [Batch],-1		; batch file empty. OOPS!
 12299 00000CD9 740A                    	jz	short SKIPERR
 12300 00000CDB E85DFD                  	call	GETBATBYT		; get a char
 12301 00000CDE E8551E                  	call	DELIM			; check for ignoreable chars
 12302 00000CE1 74F0                    	jz	short SKIPDELIM		; ignore this char.
 12303 00000CE3 F8                      	clc
 12304 00000CE4 C3                      	retn
 12305                                  SKIPERR:
 12306 00000CE5 F9                      	stc
 12307                                  GOTO_RETN:
 12308 00000CE6 C3                      	retn
 12309                                  
 12310                                  ; ---------------------------------------------------------------------------
 12311                                  
 12312                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
 12313                                  ;  .com file. This routine strips the CALL off the command line, sets
 12314                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
 12315                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
 12316                                  ;  being CALLed.
 12317                                  
 12318                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12319                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
 12320                                  
 12321                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 12322                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0D01h
 12323                                  _$CALL:
 12324                                  
 12325                                  ;  strip off CALL from command line
 12326                                  
 12327                                  	;ASSUME DS:trangroup,ES:trangroup
 12328                                  
 12329 00000CE7 56                      	push	si
 12330 00000CE8 57                      	push	di
 12331 00000CE9 50                      	push	ax
 12332 00000CEA 51                      	push	cx
 12333 00000CEB BE[549C]                	mov	si,COMBUF+2
 12334 00000CEE E83D1E                  	call	scanoff			;get to first non-delimeter
 12335                                  	;add	si,4
 12336 00000CF1 83C604                  	add	si,length_call		;point to char past CALL
 12337 00000CF4 BF[549C]                	mov	di,COMBUF+2
 12338                                  	;mov	cx,124		
 12339 00000CF7 B97C00                  	mov	cx,COMBUFLEN-length_call 
 12340                                  					;get length of buffer
 12341 00000CFA F3A4                    	rep	movsb			;move it
 12342 00000CFC 59                      	pop	cx
 12343 00000CFD 58                      	pop	ax
 12344 00000CFE 5F                      	pop	di
 12345 00000CFF 5E                      	pop	si
 12346                                  
 12347                                  ;  set call flag to indicate call in progress
 12348                                  
 12349 00000D00 1E                      	push	ds
 12350 00000D01 8E1E[F39D]              	mov	ds,[RESSEG]
 12351 00000D05 C606[4E02]01            	mov	byte [Call_Flag],call_in_progress ; 1
 12352 00000D0A C606[4F02]01            	mov	byte [Call_Batch_Flag],call_in_progress ; 1
 12353                                  
 12354                                  ; Turn off any pipes in progress.
 12355                                  
 12356 00000D0F 803E[B602]00            	cmp	byte [PipeFiles],0 	; Only turn off if present.
 12357 00000D14 7403                    	jz	short _NOPIPE
 12358 00000D16 E82425                  	call	PIPEDEL
 12359                                  _NOPIPE:
 12360 00000D19 1F                      	pop	ds
 12361 00000D1A C3                      	retn
 12362                                  
 12363                                  ; ---------------------------------------------------------------------------
 12364                                  
 12365                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12366                                  _GOTO:
 12367 00000D1B 8E1E[F39D]              	mov	ds,[RESSEG]
 12368 00000D1F F706[E701]FFFF          	test	word [Batch],-1	; If not in batch mode, a nop
 12369 00000D25 74BF                    	jz	short GOTO_RETN
 12370 00000D27 31D2                    	xor	dx,dx
 12371 00000D29 1E                      	push	ds
 12372 00000D2A 8E1E[E701]              	mov	ds,[Batch]
 12373                                  	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
 12374 00000D2E 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
 12375                                  	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
 12376 00000D32 89160A00                	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
 12377                                  
 12378                                  	; MSDOS 6.0
 12379                                  ;M037
 12380                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
 12381                                  ;
 12382 00000D36 C606020000              	mov	byte [BATCHSEGMENT.BatchEOF],0
 12383                                  					; clear eof indicator ;M037
 12384                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12385 00000D3B 1F                      	pop	ds
 12386                                  GOTOOPEN:
 12387 00000D3C E875F8                  	call	PROMPTBAT
 12388                                  	;mov	di,5Dh
 12389 00000D3F BF5D00                  	mov	di,FCB+1		; Get the label
 12390 00000D42 B90B00                  	mov	cx,11
 12391 00000D45 B020                    	mov	al,' '
 12392 00000D47 F2AE                    	repne	scasb
 12393 00000D49 7501                    	jnz	short NOINC
 12394 00000D4B 41                      	inc	cx
 12395                                  NOINC:
 12396 00000D4C 83E90B                  	sub	cx,11
 12397 00000D4F F7D9                    	neg	cx
 12398                                  	;mov	[cs:GOTOLEN],cx
 12399                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12400 00000D51 26890E[2AA0]            	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)
 12401                                  
 12402                                  ; At beginning of file. Skip to first non-delimiter char
 12403                                  
 12404 00000D56 E87AFF                  	call	SKIPDELIM
 12405 00000D59 721C                    	jb	short BADGOTO
 12406 00000D5B 3C3A                    	cmp	al,':'
 12407 00000D5D 7426                    	jz	short CHKLABEL
 12408                                  LABLKLP:				; Look for the label
 12409 00000D5F E8D9FC                  	call	GETBATBYT
 12410 00000D62 3C0A                    	cmp	al,0Ah
 12411 00000D64 7509                    	jne	short LABLKTST
 12412                                  
 12413                                  ; At beginning of line. Skip to first non-delimiter char
 12414                                  
 12415 00000D66 E86AFF                  	call	SKIPDELIM
 12416 00000D69 720C                    	jb	short BADGOTO
 12417 00000D6B 3C3A                    	cmp	al,':'
 12418 00000D6D 7416                    	je	short CHKLABEL
 12419                                  LABLKTST:
 12420 00000D6F F706[E701]FFFF          	test	word [Batch],0FFFFh ; -1
 12421 00000D75 75E8                    	jnz	short LABLKLP
 12422                                  BADGOTO:
 12423 00000D77 E87100                  	call	BATCLOSE
 12424                                  
 12425                                  	; MSDOS 6.0
 12426                                  ;SR;
 12427                                  ; At this point we are terminating without freeing up any nested batch 
 12428                                  ;segments i.e if the error occurred within a called batch file. This routine
 12429                                  ;will traverse the linked list of batch segments and free all of them.
 12430                                  ;
 12431 00000D7A E8BB00                  	call	free_batch		; free up nested batch segments
 12432                                  
 12433                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12434 00000D7D 0E                      	push	cs
 12435 00000D7E 1F                      	pop	ds
 12436 00000D7F BA[6592]                	mov	dx,BADLAB_PTR
 12437 00000D82 E91D21                  	jmp	cerror
 12438                                  
 12439                                  ; Found the :.	Skip to first non-delimiter char
 12440                                  
 12441                                  CHKLABEL:
 12442 00000D85 E84BFF                  	call	SKIPDELIM
 12443 00000D88 72ED                    	jb	short BADGOTO
 12444 00000D8A BF5D00                  	mov	di,FCB+1 ; 5Dh
 12445                                  	;mov	cx,[cs:GOTOLEN]
 12446                                  	; 14/02/2023
 12447 00000D8D 268B0E[2AA0]            	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12448 00000D92 EB05                    	jmp	short GOTBYTE
 12449                                  
 12450                                  NEXTCHRLP:
 12451 00000D94 51                      	push	cx
 12452 00000D95 E8A3FC                  	call	GETBATBYT
 12453 00000D98 59                      	pop	cx
 12454                                  GOTBYTE:
 12455                                  	; 18/03/2023
 12456                                  	; 14/02/2023
 12457                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
 12458 00000D99 E8731B                  	call	testkanj
 12459 00000D9C 7413                    	jz	short NOTKANJ1
 12460 00000D9E 263A05                  	cmp	al,[es:di]
 12461 00000DA1 75CC                    	jne	short LABLKTST
 12462 00000DA3 47                      	inc	di
 12463 00000DA4 49                      	dec	cx
 12464 00000DA5 E3C8                    	jcxz	LABLKTST
 12465 00000DA7 51                      	push	cx
 12466 00000DA8 E890FC                  	call	GETBATBYT
 12467 00000DAB 59                      	pop	cx
 12468 00000DAC 263A05                  	cmp	al,[es:di]
 12469 00000DAF EB0C                    	jmp	short KNEXTLABCHR
 12470                                  NOTKANJ1:
 12471                                  	; 14/02/2023
 12472                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
 12473 00000DB1 0C20                    	or	al,20h
 12474 00000DB3 263A05                  	cmp	al,[es:di]
 12475                                  	;jne	short TRYUPPER
 12476                                  	;jmp	short NEXTLABCHR
 12477                                  	; 25/04/2023
 12478 00000DB6 7407                    	je	short NEXTLABCHR 
 12479                                  TRYUPPER:
 12480 00000DB8 2C20                    	sub	al,20h
 12481 00000DBA 263A05                  	cmp	al,[es:di]
 12482                                  KNEXTLABCHR:
 12483 00000DBD 75B0                    	jnz	short LABLKTST
 12484                                  NEXTLABCHR:
 12485 00000DBF 47                      	inc	di
 12486 00000DC0 E2D2                    	loop	NEXTCHRLP
 12487 00000DC2 E876FC                  	call	GETBATBYT
 12488                                  	; 14/02/2023
 12489 00000DC5 26833E[2AA0]08          	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
 12490                                  	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
 12491 00000DCB 7D04                    	jge	short GOTOCONT	; Yes, then the next char doesn't matter
 12492 00000DCD 3C20                    	cmp	al,' '
 12493 00000DCF 779E                    	ja	short LABLKTST
 12494                                  GOTOCONT:
 12495 00000DD1 3C0D                    	cmp	al,0Dh
 12496 00000DD3 7407                    	je	short SKIPLFEED
 12497                                  TONEXTBATLIN:
 12498 00000DD5 E863FC                  	call	GETBATBYT
 12499 00000DD8 3C0D                    	cmp	al,0Dh
 12500 00000DDA 75F9                    	jne	short TONEXTBATLIN
 12501                                  SKIPLFEED:
 12502 00000DDC E85CFC                  	call	GETBATBYT
 12503                                  
 12504                                  	; MSDOS 6.0
 12505                                  ;SR;
 12506                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
 12507                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
 12508                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
 12509                                  ;to get the EOF has not been made yet because we encountered the Goto. On
 12510                                  ;all other cases, EOF will be hit while trying to read the next line and
 12511                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
 12512                                  ;
 12513 00000DDF 06                      	push	es
 12514 00000DE0 8E06[E701]              	mov	es,[Batch]
 12515 00000DE4 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 12516                                  					;invalidate fake CR-LF flag
 12517 00000DEA 07                      	pop	es
 12518                                  
 12519                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12520                                  	;call	BATCLOSE
 12521                                  	;retn
 12522                                  	; 14/02/2023
 12523                                  	;jmp	short BATCLOSE
 12524                                  
 12525                                  ; =============== S U B	R O U T	I N E =======================================
 12526                                  
 12527                                  BATCLOSE:
 12528 00000DEB 2E8B1E[E5A1]            	mov	bx,[cs:BATHAND]
 12529 00000DF0 83FB05                  	cmp	bx,5
 12530 00000DF3 7204                    	jb	short CLOSERETURN
 12531                                  	; 14/02/2023
 12532 00000DF5 B43E                    	mov	ah,3Eh
 12533                                  	;mov	ah,CLOSE ; 3Eh
 12534 00000DF7 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 12535                                  			; BX = file handle
 12536                                  CLOSERETURN:
 12537 00000DF9 C606[3002]00            	mov	byte [In_Batch],0 ; reset flag	
 12538 00000DFE C3                      	retn
 12539                                  
 12540                                  ; =============== S U B	R O U T	I N E =======================================
 12541                                  
 12542                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
 12543                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
 12544                                  
 12545                                  	; 14/02/2023
 12546                                  BATOPEN:
 12547 00000DFF 1E                      	push	ds
 12548 00000E00 8E1E[E701]              	mov	ds,[Batch]
 12549                                  	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
 12550                                  	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
 12551 00000E04 BA2000                  	mov	dx,BATCHSEGMENT.BatFile
 12552 00000E07 B8003D                  	mov	ax,3D00h
 12553                                  	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
 12554 00000E0A CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 12555                                  			; DS:DX	-> ASCIZ filename
 12556                                  			; AL = access mode
 12557                                  			; 0 - read
 12558 00000E0C 721C                    	jc	short SETERRDL
 12559                                  	;mov	dx,[8]
 12560 00000E0E 8B160800                	mov	dx,[BATCHSEGMENT.BatSeek]
 12561                                  	;mov	cx,[10]
 12562 00000E12 8B0E0A00                	mov	cx,[BATCHSEGMENT.BatSeek+2]
 12563 00000E16 1F                      	pop	ds
 12564                                  	;mov	[cs:BATHAND],ax
 12565 00000E17 26A3[E5A1]              	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12566 00000E1B 89C3                    	mov	bx,ax
 12567 00000E1D B80042                  	mov	ax,4200h
 12568                                  	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
 12569 00000E20 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 12570                                  			; AL = method: offset from beginning of	file
 12571                                  
 12572                                  	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
 12573                                  					; nuke batch buffer position
 12574 00000E22 26C706[B9A9]FFFF        	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12575                                  BATOPEN_RETN:
 12576 00000E29 C3                      	retn
 12577                                  
 12578                                  SETERRDL:
 12579 00000E2A 89D3                    	mov	bx,dx
 12580                                  	; MSDOS 6.0
 12581                                  	;invoke	get_ext_error_number 	;AN022; get the extended error
 12582                                  	; 14/02/2023
 12583 00000E2C E81314                  	call	get_ext_error_number
 12584 00000E2F 89C2                    	mov	dx,ax		     	;AN022; save extended error in DX
 12585                                  
 12586                                  	; MSDOS 3.3
 12587                                  	;mov	dx,INSERTDSKPTR
 12588                                  	;call	GET_EXT_ERR_NUMBER
 12589                                  
 12590                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12591 00000E31 8A07                    	mov	al,[bx]			; Get drive spec
 12592 00000E33 2C40                    	sub	al,'@'	; sub al,40h	; A = 1
 12593 00000E35 1F                      	pop	ds
 12594 00000E36 F9                      	stc				; SUB mucked over carry
 12595 00000E37 C3                      	retn
 12596                                  
 12597                                  ; =============== S U B	R O U T	I N E =======================================
 12598                                  
 12599                                  ;Free_batch : This routine traverses the linked batch segments freeing all
 12600                                  ;the batch and FOR segments until all of them are freed. It also restores
 12601                                  ;the old state of the EchoFlag.
 12602                                  ;
 12603                                  ;	ENTRY:	ds = RESGROUP
 12604                                  ;
 12605                                  ;	EXIT: 	All batch & FOR segments freed.
 12606                                  ;		EchoFlag restored to old state before batch process.
 12607                                  ;
 12608                                  ;	REGISTERS AFFECTED: bx, cx
 12609                                  
 12610                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12611                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh
 12612                                  
 12613                                  free_batch: ;proc near
 12614                                  	;assume	ds:RESGROUP,es:nothing
 12615                                  
 12616 00000E38 06                      	push	es
 12617 00000E39 8B1E[5002]              	mov	bx,[Next_Batch]
 12618 00000E3D 09DB                    	or	bx,bx
 12619 00000E3F 7431                    	jz	short fb_ret
 12620                                  _ClearBatch:
 12621 00000E41 8EC3                    	mov	es,bx			; get batch segment
 12622                                  	;mov	bx,es:BatForPtr		; get old FOR segment
 12623 00000E43 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
 12624                                  	;cmp	bx,0			; is a FOR in progress
 12625                                  	; 27/07/2024
 12626 00000E48 21DB                    	and	bx,bx
 12627 00000E4A 7408                    	jz	short no_bat_for	; no - don't deallocate
 12628 00000E4C 06                      	push	es			;
 12629 00000E4D 8EC3                    	mov	es,bx			; yes - free it up...
 12630 00000E4F B449                    	mov	ah,49h
 12631                                  	;mov	ah,DEALLOC		;
 12632 00000E51 CD21                    	int	21h			;
 12633 00000E53 07                      	pop	es			; restore to batch segment
 12634                                  no_bat_for:
 12635                                  	;mov	cl,[es:1]
 12636 00000E54 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
 12637                                  					; get old echo flag
 12638                                  	;mov	bx,[es:3]
 12639 00000E59 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 12640                                  					; get old batch segment
 12641 00000E5E B449                    	mov	ah,49h
 12642                                  	;mov	ah,DEALLOC		; free it up...
 12643 00000E60 CD21                    	int	21h
 12644                                  	; 14/02/2023
 12645                                  	;mov	[Batch],bx		; get ready to deallocate next batch
 12646 00000E62 FF0E[4C02]              	dec	word [Nest]		; is there another batch file?
 12647 00000E66 75D9                    	jnz	short _ClearBatch	; keep going until no batch file
 12648                                  	
 12649 00000E68 880E[3B02]              	mov	[EchoFlag],cl		;restore echo status
 12650 00000E6C C706[E701]0000          	mov	word [Batch],0		;no batch process in progress
 12651                                  fb_ret:
 12652 00000E72 07                      	pop	es
 12653 00000E73 C3                      	ret
 12654                                  
 12655                                  ;free_batch endp
 12656                                  
 12657                                  ;============================================================================
 12658                                  ; TFOR.ASM, MSDOS 6.0, 1991
 12659                                  ;============================================================================
 12660                                  ; 10/10/2018 - Retro DOS v3.0
 12661                                  
 12662                                  ; All batch proccessing has DS set to segment of resident portion
 12663                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
 12664                                  
 12665                                  ; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h
 12666                                  
 12667                                  ; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12668                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh
 12669                                  
 12670                                  ; ---------------------------------------------------------------------------
 12671                                  
 12672                                  	; 15/02/2023
 12673                                  FORTERM:
 12674                                  	; MSDOS 6.0
 12675 00000E74 0E                      	push	cs			;AN037; Get local segment into
 12676 00000E75 1F                      	pop	ds			;AN037;  DS, ES
 12677 00000E76 0E                      	push	cs			;AN037;
 12678 00000E77 07                      	pop	es			;AN037;
 12679                                  
 12680                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12681 00000E78 E89502                  	call	FOROFF
 12682                                  	;mov	ds,[cs:RESSEG]
 12683 00000E7B 268E1E[F39D]            	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
 12684 00000E80 813E[4302]00FF          	cmp	word [SingleCom],0FF00h
 12685 00000E86 750F                    	jne	short BAT_CRLF
 12686 00000E88 833E[4C02]00            	cmp	word [Nest],0		;See if we have nested batch files
 12687 00000E8D 7508                    	jne	short BAT_CRLF		;Yes - don't exit just yet
 12688 00000E8F C706[4302]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
 12689 00000E95 EB12                    	jmp	short NOFORP2
 12690                                  BAT_CRLF:
 12691 00000E97 F606[3B02]01            	test	byte [EchoFlag],1 	; Is echo on?
 12692 00000E9C 740B                    	jz	short NOFORP2		; no - exit
 12693 00000E9E F706[E701]FFFF          	test	word [Batch],-1 ; 0FFFFh
 12694                                  					; print CRLF if in batch
 12695 00000EA4 7403                    	jz	short NOFORP2
 12696 00000EA6 E8781C                  	call	CRLF2
 12697                                  NOFORP2:
 12698 00000EA9 E958F2                  	jmp	TCOMMAND
 12699                                  
 12700                                  ; ---------------------------------------------------------------------------
 12701                                  
 12702                                  ;------
 12703                                  ;   For-loop processing. For loops are of the form:
 12704                                  ;	    for %<loop-variable> in (<list>) do <command>
 12705                                  ; where <command> may contain references of the form %<variable>, which are
 12706                                  ; later substituted with the items in <list>. The for-loop structure is
 12707                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
 12708                                  ; <command> once for each item in <list>. All of the information needed for
 12709                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
 12710                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
 12711                                  ; a complete copy of the original command-line structure as parsed by
 12712                                  ; 'parseline', loop control variables, and a dma buffer for the
 12713                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
 12714                                  ; processing has completed, this chunk of memory is returned to the system.
 12715                                  ;
 12716                                  ;   All of the previously defined variables, in 'datares', used for loop
 12717                                  ; processing may be erased. Only one, (DW) ForPtr, need be allocated.
 12718                                  ;
 12719                                  ;   The error message, 'for_alloc_mes', should be moved into the file
 12720                                  ; containing all of the other error messages.
 12721                                  ;
 12722                                  ;   Referencing the allocated for-loop structure is a little tricky.
 12723                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
 12724                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
 12725                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
 12726                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
 12727                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
 12728                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
 12729                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
 12730                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
 12731                                  ; instead of
 12732                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
 12733                                  ; By using 'f', we pretend that we are actually referencing an allocated
 12734                                  ; structure, and the assembler coughs up the code we want. Notice that it
 12735                                  ; doesn't matter whether we put brackets around the location or not -- the
 12736                                  ; assembler is "smart" enough to know that we want an address instead of the
 12737                                  ; contents of that location.
 12738                                  ;
 12739                                  ;   Finally, there now exists the potential to easily implement nested loops.
 12740                                  ; One method would be to have a link field in each for-structure pointing to
 12741                                  ; its parent.  Variable references that couldn't be resolved in the local
 12742                                  ; frame would cause a search of prior frames. For-structures would still be
 12743                                  ; allocated and released in exactly the same fashion. The only limit on the
 12744                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
 12745                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
 12746                                  ; maintained in the resident data area. This structure would be an array of
 12747                                  ; control-variable names and pointers to for-structure blocks. This would
 12748                                  ; greatly speed up the resolution of non-local variable references. However,
 12749                                  ; since space in the resident is precious, we would have to compromise on a
 12750                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
 12751                                  ; allocation and de-allocation would have to be modified slightly to take this
 12752                                  ; new structure into account.
 12753                                  ;
 12754                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
 12755                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
 12756                                  ; it may be easier to allocate it as part of 'for_segment'.
 12757                                  ;------
 12758                                  		; include fordata.asm
 12759                                  
 12760                                  ; Data structure definitions included by tfor.asm
 12761                                  
 12762                                  struc FOR_INFO
 12763 00000000 <res 444h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
 12764 00000444 ??                        .FOR_COM_START: resb  1		; beginning of <command>
 12765 00000445 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
 12766 00000447 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
 12767 00000449 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
 12768 0000044B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
 12769 000004CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
 12770 0000054B ??                        .FOR_VAR:	  resb  1		; loop control variable
 12771                                    .size:
 12772                                  endstruc
 12773                                  					; ARG_UNIT.SIZE = 1348 (544h)
 12774                                  					; ARG_UNIT.SIZE = 1092 ; 27/07/2024
 12775                                  _$FOR_EXIT:
 12776 00000EAC EBC6                    	jmp	short FORTERM		; exceeding maxarg means all done
 12777                                  
 12778                                  ; ---------------------------------------------------------------------------
 12779                                  
 12780                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12781                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 12782                                  	;	     & Retro DOS v4.2 COMMAND.COM (2024 modification)
 12783                                  FORPROC:
 12784 00000EAE A1[4A02]                	mov	ax,[ForPtr]
 12785 00000EB1 8ED8                    	mov	ds,ax
 12786 00000EB3 8EC0                    	mov	es,ax			; operate in for-info area
 12787                                  	;;mov	dx,5CBh	; MSDOS 5.0 & 6.22
 12788                                  	;mov	dx,4CBh ; PCDOS 7.1 ; 27/07/2024
 12789 00000EB5 BACB04                  	mov	dx,FOR_INFO.FORDMA	; 1348+1+2+2+2+128 = 1483 = 5CBh
 12790                                  		; PCDOS 7.1 COMMAND.COM ; 1092+1+2+2+2+128 = 1227 = 4CBh
 12791 00000EB8 B8001A                  	mov	ax,1A00h
 12792                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12793 00000EBB CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12794                                  			; DS:DX	-> disk	transfer buffer
 12795                                  FOR_BEGIN:
 12796                                  	;;cmp	word [545h],0
 12797                                  	;cmp	word [445h] ; 27/07/2024
 12798 00000EBD 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12799 00000EC2 7404                    	jz	short FOR_BEGIN1
 12800                                  					; non-zero for_expand equals FALSE
 12801                                  	;;inc	word [547h]
 12802                                  	;inc	word [447h] ; 27/07/2024
 12803 00000EC4 FF064704                	inc	word [FOR_INFO.FOR_MINARG]
 12804                                  FOR_BEGIN1:
 12805                                  	;mov	bx,[447h] ; 27/07/2024
 12806 00000EC8 8B1E4704                	mov	bx,[FOR_INFO.FOR_MINARG] ; current item in <list> to examine
 12807                                  	;cmp	bx,[449h] ; 27/07/2024
 12808 00000ECC 3B1E4904                	cmp	bx,[FOR_INFO.FOR_MAXARG]
 12809 00000ED0 7FDA                     	jg	short _$FOR_EXIT	; exceeding maxarg means all done
 12810                                  	;mov	ax,0
 12811 00000ED2 B80000                  	mov	ax,FOR_INFO.FOR_ARGS ; 0 
 12812 00000ED5 E8C627                  	call	argv_calc		; compute argv[x] address
 12813                                  	;mov	cx,[bx+3]
 12814 00000ED8 8B4F03                  	mov	cx,[bx+ARGV_ELE.argstartel]
 12815 00000EDB 8B17                    	mov	dx,[bx]
 12816                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12817                                  	;test	byte [bx+2],4		; Is there a path separator in this arg?
 12818 00000EDD F6470204                	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 12819 00000EE1 7512                    	jnz	short FORSUB		; Yes, argstartel should be correct
 12820 00000EE3 8B37                    	mov	si,[bx]
 12821                                  	;mov	si,[bx+ARGV_ELE.argpointer]
 12822                                  
 12823                                  	;mov	al,[cs:LPAREN]
 12824                                  	; 15/02/2023
 12825                                  	; MSDOS 6.0 (& 5.0) COMMAND.com
 12826                                  	;mov	al,'('	; mov al,lparen
 12827                                  	;cmp	[si-1],	al		; If the current token is the first
 12828                                  	; 27/07/2024
 12829 00000EE5 807CFF28                	cmp	byte [si-1],'('
 12830 00000EE9 750A                    	jne	short FORSUB		;  one in the list and originally had
 12831 00000EEB 41                      	inc	cx			;  the opening paren as its first char,
 12832                                  					;  the argstartel ptr needs to be
 12833                                  					;  advanced passed it before the prefix
 12834                                  					;  length is computed.
 12835                                  	;mov	al,':'
 12836                                  	;cmp	[si+1],	al		; If the token begins with "(d:",
 12837                                  	; 27/07/2024
 12838 00000EEC 807C013A                	cmp	byte [si+1],':'
 12839 00000EF0 7503                    	jne	short FORSUB		;  argstartel has to be moved over the
 12840 00000EF2 83C102                  	add	cx,2			;  rest of the prefix as well.
 12841                                  FORSUB:
 12842 00000EF5 29D1                    	sub	cx,dx			; compute length of pathname prefix
 12843                                  	;;cmp	word [545h],0
 12844                                  	;cmp	word [445h],0 ; 27/07/2024
 12845 00000EF7 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12846                                  					; are we still expanding a name?
 12847 00000EFC 7416                    	jz	short FOR_FIND_NEXT
 12848                                  					; if so, get next matching filename
 12849                                  	;test	byte [bx+2],2
 12850 00000EFE F6470202                	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
 12851 00000F02 7505                    	jnz	short FOR_FIND_FIRST
 12852                                  					; should we expand THIS (new) arg?
 12853                                  	;mov	cx,[bx+5]
 12854                                  					; else, just copy all of it directly
 12855 00000F04 8B4F05                  	mov	cx,[bx+ARGV_ELE.arglen]
 12856 00000F07 EB1D                    	jmp	short FOR_SMOOSH
 12857                                  
 12858                                  	;nop
 12859                                  	; 15/02/2023
 12860                                  FOR_FIND_FIRST:
 12861 00000F09 51                      	push	cx
 12862 00000F0A 31C9                    	xor	cx,cx
 12863 00000F0C B8004E                  	mov	ax,4E00h
 12864                                  	;mov	ax,Find_First*256 ; 4E00h
 12865 00000F0F CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12866                                  			; CX = search attributes
 12867                                  			; DS:DX	-> ASCIZ filespec
 12868                                  			; (drive,path, and wildcards allowed)
 12869 00000F11 59                      	pop	cx
 12870 00000F12 EB05                    	jmp	short FOR_RESULT
 12871                                  
 12872                                  	;nop
 12873                                  FOR_FIND_NEXT:
 12874 00000F14 B8004F                  	mov	ax,4F00h
 12875                                  	;mov	ax,Find_Next*256 ;4F00h
 12876 00000F17 CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 12877                                  			; [DTA]	= data block from
 12878                                  			; last AH = 4Eh/4Fh call
 12879                                  FOR_RESULT:
 12880 00000F19 B8FFFF                  	mov	ax,-1 ; 0FFFFh		; assume worst case
 12881 00000F1C 7201                    	jc	short FOR_CHECK
 12882                                  	; 15/02/2023
 12883 00000F1E 40                      	inc	ax ; ax = 0
 12884                                  	;mov	ax,0			; Find* returns 0 for SUCCESS
 12885                                  FOR_CHECK:				; record success of findfirst/next
 12886                                  	;;mov	[545h],ax
 12887                                  	;mov	[445h],ax ; 27/07/2024
 12888 00000F1F A34504                  	mov	[FOR_INFO.FOR_EXPAND],ax
 12889 00000F22 09C0                    	or	ax,ax			; anything out there?
 12890 00000F24 7597                    	jnz	short FOR_BEGIN		; if not, try next arg
 12891                                  FOR_SMOOSH:
 12892                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12893 00000F26 8B37                    	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
 12894                                  	;;mov	di,54Bh	; MSDOS 5.0 & 6.22 COMMAND.COM
 12895                                  	;mov	di,44Bh ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12896 00000F28 BF4B04                  	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
 12897 00000F2B F3A4                    	rep	movsb			; arg, some days just the path prefix
 12898                                  					
 12899 00000F2D 833E450400              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12900                                  					; if we're not expanding, we can
 12901 00000F32 7509                    	jnz	short FOR_MAKE_COM 	; skip the following
 12902                                  	; 15/02/2023
 12903                                  	;;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.22 COMMAND.COM ; 27/07/2024
 12904                                  	; 27/07/2024
 12905                                  	;mov	si,04E9h ; PCDOS 7.1 COMMAND.COM
 12906 00000F34 BEE904                  	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
 12907                                  FOR_MORE:
 12908                                  	;cmp	byte [si],0		; tack on matching filename
 12909                                  	;jz	short FOR_MAKE_COM
 12910                                  	;movsb
 12911                                  	;jnz	short FOR_MORE
 12912                                  	; 25/04/2023
 12913 00000F37 AC                      	lodsb
 12914 00000F38 AA                      	stosb
 12915 00000F39 08C0                    	or	al,al
 12916 00000F3B 75FA                    	jnz	short FOR_MORE
 12917                                  FOR_MAKE_COM:
 12918                                  	; 25/04/2023
 12919                                  	;xor	al,al			; tack a null byte onto the end
 12920                                  	;stosb				; of the substitute string
 12921 00000F3D 31C9                    	xor	cx,cx			; character count for command line
 12922 00000F3F F7D1                    	not	cx			; negate it -- take advantage of loopnz
 12923 00000F41 31DB                    	xor	bx,bx			; argpointer
 12924 00000F43 BF[549C]                	mov	di,COMBUF+2
 12925                                  	; 15/02/2023
 12926                                  	;;mov	bl,[544h] ; MSDOS 5.0-6.22 ; 27/07/2024
 12927                                  	; 27/07/2024
 12928                                  	;mov	bl,[444h] ; PCDOS 7.1 COMMAND.COM 
 12929 00000F46 8A1E4404                	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
 12930                                  	;;mov	dh,[64Bh]
 12931                                  	;mov	dh,[54Bh] ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 12932 00000F4A 8A364B05                	mov	dh,[FOR_INFO.FOR_VAR]
 12933                                  					; %<for-var> is replaced by [forbuf]
 12934 00000F4E 0E                      	push	cs			; time to form the <command> string
 12935 00000F4F 07                      	pop	es
 12936                                  	;assume ES:trangroup
 12937                                  	;mov	ax,FOR_INFO.FOR_ARGS
 12938 00000F50 B80000                  	mov	ax,0			; translate offset to pointer
 12939 00000F53 E84827                  	call	argv_calc
 12940                                  	;mov	si,[bx+9]
 12941 00000F56 8B7709                  	mov	si,[bx+ARGV_ELE.arg_ocomptr]
 12942                                  					; mov ptr passed beginning space
 12943 00000F59 46                      	inc	si
 12944                                  FOR_MAKE_LOOP:
 12945 00000F5A 8A04                    	mov	al,[si]			; the <command> arg, byte by byte
 12946 00000F5C 46                      	inc	si
 12947 00000F5D 3C25                    	cmp	al,'%'			; looking for %<control-variable>
 12948 00000F5F 7514                    	jne	short FOR_STOSB 	; no % ... add byte to string
 12949 00000F61 3834                    	cmp	[si],dh			; got the right <variable>?
 12950 00000F63 7510                    	jnz	short FOR_STOSB		; got a %, but wrong <variable>
 12951 00000F65 46                      	inc	si			; skip over <for-variable>
 12952                                  
 12953 00000F66 56                      	push	si
 12954                                  	; 15/02/2023
 12955                                  	;;mov	si,54Bh	; MSDOS 5.0-6.22 ; 27/07/2024
 12956                                  	; 27/07/2024
 12957                                  	;mov	si,44Bh ; PCDOS 7.1 COMMAND.COM
 12958 00000F67 BE4B04                  	mov	si,FOR_INFO.FORBUF
 12959                                  					; substitute the <item> for <variable>
 12960                                  					; to make a final <command> to execute
 12961                                  SLOOP:					
 12962 00000F6A AC                      	lodsb				; grab all those <item> bytes, and
 12963 00000F6B AA                      	stosb				; add 'em to the <command> string,
 12964 00000F6C 08C0                    	or	al,al			; until we run into a null
 12965 00000F6E E0FA                    	loopne	SLOOP
 12966 00000F70 4F                      	dec	di			; adjust length and <command> pointer
 12967 00000F71 41                      	inc	cx			; so we can overwrite the null
 12968 00000F72 5E                      	pop	si
 12969 00000F73 EBE5                    	jmp	short FOR_MAKE_LOOP
 12970                                  					; got back for more <command> bytes
 12971                                  FOR_STOSB:
 12972 00000F75 AA                      	stosb				; take a byte from the <command> arg
 12973 00000F76 49                      	dec	cx			; and put it into the <command> to be
 12974                                  					; executed (and note length, too)
 12975 00000F77 3C0D                    	cmp	al,0Dh
 12976 00000F79 75DF                    	jne	short FOR_MAKE_LOOP	; If not done, loop.
 12977                                  FOR_MADE_COM:
 12978 00000F7B F6D1                    	not	cl
 12979                                  	;mov	[cs:COMBUF+1],cl
 12980                                  	;mov	ds,[cs:RESSEG]
 12981                                  	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
 12982                                  	; MSDOS 5.0 COMMAND.COM
 12983 00000F7D 26880E[539C]            	mov	[es:COMBUF+1],cl
 12984 00000F82 268E1E[F39D]            	mov	ds,[es:RESSEG]
 12985                                  	;assume DS:resgroup
 12986 00000F87 F606[3B02]01            	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
 12987 00000F8C 742F                    	jz	short NOECHO3
 12988                                  	;cmp	byte [NullFlag],nullcommand
 12989 00000F8E 803E[5202]01            	cmp	byte [NullFlag],1 	;G was there a command last time?
 12990 00000F93 7403                    	jz	short NO_CRLF_PR  	;G no - don't print crlf
 12991                                  
 12992 00000F95 E8891B                  	call	CRLF2		  	;G Print out prompt
 12993                                  NO_CRLF_PR:
 12994 00000F98 C606[5202]00            	mov	byte [NullFlag],0 	;G reset no command flag
 12995 00000F9D 0E                      	push	cs
 12996 00000F9E 1F                      	pop	ds
 12997 00000F9F 57                      	push	di
 12998 00000FA0 E84013                  	call	PRINT_PROMPT	  	;G Prompt the user
 12999 00000FA3 5F                      	pop	di
 13000                                  
 13001 00000FA4 26C645FF00              	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
 13002 00000FA9 C706[91A0][549C]        	mov	word [string_ptr_2],COMBUF+2
 13003                                  	; 17/04/2023
 13004 00000FAF BA[9793]                	mov	dx,string_buf_ptr
 13005 00000FB2 E85A45                  	call	std_printf
 13006 00000FB5 26C645FF0D              	mov	byte [es:di-1],0Dh
 13007 00000FBA E933F3                  	jmp	DOCOM		  	; run silent, run deep...
 13008                                  NOECHO3:
 13009 00000FBD C606[5202]00            	mov	byte [NullFlag],0
 13010 00000FC2 0E                      	push	cs
 13011 00000FC3 1F                      	pop	ds
 13012                                  	;jmp	DOCOM1
 13013                                  	; 07/06/2023
 13014                                  	; Retro DOS v4.2 COMMAND.COM
 13015 00000FC4 E92CF3                  	jmp	DOCOM0 ; MSDOS 6.22 COMMAND.COM
 13016                                  
 13017                                  FORNESTERRJ:				; no multi-loop processing... yet!
 13018 00000FC7 E84601                  	call	FOROFF
 13019 00000FCA E92901                  	jmp	FORNESTERR
 13020                                  
 13021                                  ; ---------------------------------------------------------------------------
 13022                                  
 13023                                  FORERRORJ:
 13024 00000FCD E9DDFB                  	jmp	FORERROR
 13025                                  
 13026                                  ; ---------------------------------------------------------------------------
 13027                                  
 13028                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F24h
 13029                                  
 13030                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 13031                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0FFEh
 13032                                  
 13033                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 13034                                  	; PCDOS 7.1 COMMAND.COM - TRANGROUP:1040h
 13035                                  _$FOR:
 13036 00000FD0 8E06[F39D]              	mov	es,[RESSEG]
 13037 00000FD4 26803E[4902]00          	cmp	byte [es:ForFlag],0 ; is another one already running?
 13038 00000FDA 75EB                    	jnz	short FORNESTERRJ   ; if flag is set.... boom!
 13039                                  
 13040                                  ; Turn off any pipes in progress.
 13041                                  
 13042 00000FDC 26803E[B602]00          	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
 13043 00000FE2 7403                    	jz	short NO_PIPE
 13044 00000FE4 E85622                  	call	PIPEDEL
 13045                                  NO_PIPE:
 13046 00000FE7 31D2                    	xor	dx,dx			; counter (0 <= DX < argvcnt)
 13047 00000FE9 E8F400                  	call	NEXTARG			; move to next argv[n]
 13048 00000FEC 72DF                    	jc	short FORERRORJ		; no more args -- bad forloop
 13049 00000FEE 3C25                    	cmp	al,'%'			; next arg MUST start with '%'...
 13050 00000FF0 75DB                    	jne	short FORERRORJ
 13051 00000FF2 89C5                    	mov	bp,ax			; save forloop variable
 13052 00000FF4 AC                      	lodsb
 13053 00000FF5 08C0                    	or	al,al			; and MUST end immediately...
 13054 00000FF7 75D4                    	jnz	short FORERRORJ
 13055 00000FF9 E8E400                  	call	NEXTARG			; let's make sure the next arg is 'in'
 13056 00000FFC 72CF                    	jb	short FORERRORJ
 13057                                  	;and	ax,0DFDFh
 13058 00000FFE 25DFDF                  	and	ax,~2020h		; uppercase the letters
 13059                                  	; 15/02/2023
 13060                                  	;cmp	ax,4E49h  	; MSDOS 5.0
 13061                                  	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
 13062                                  	;cmp	ax,in_word	; MSDOS 5.0
 13063 00001001 3D494E                  	cmp	ax,'IN'
 13064 00001004 75C7                    	jnz	short FORERRORJ
 13065 00001006 AC                      	lodsb
 13066                                  
 13067                                  	; 15/02/2023
 13068                                  	; MSDOS 3.3
 13069                                  	;or	al,al			; it, too, must end right away
 13070                                  	;jz	short CHECKLPAREN
 13071                                  	;cmp	al,[LPAREN]
 13072                                  	;jnz	short FORERRORJ
 13073                                  	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
 13074                                  	;add	word [bx],2
 13075                                  	;;add	word [bx+9],2
 13076                                  	;add	word [bx+ARGV_ELE.arg_ocomptr],2
 13077                                  	;;sub	word [bx+5],2
 13078                                  	;sub	word [bx+ARGV_ELE.arglen],2
 13079                                  	;mov	ax,[si-1]
 13080                                  	;jmp	short LPCHECK
 13081                                  
 13082                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13083                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh
 13084                                  
 13085                                  	; MSDOS 6.0
 13086                                  ; Compaq bug fix -- exit from this loop on error
 13087                                  
 13088 00001007 08C0                    	or	al,al
 13089 00001009 75C2                    	jne	short FORERRORJ		; jump on error
 13090                                  
 13091                                  ;	je	short CHECKLPAREN
 13092                                  ;
 13093                                  ; Not null. Perhaps there are no spaces between this and the (:
 13094                                  ;   FOR %i in(foo bar...
 13095                                  ; Check for the Lparen here
 13096                                  ;
 13097                                  ;;	cmp	al,lparen
 13098                                  ;;	jnz	short FORERRORJ
 13099                                  ;
 13100                                  ; The token was in(... We strip off the "in" part to simulate a separator
 13101                                  ; being there in the first place.
 13102                                  ;
 13103                                  ;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
 13104                                  ;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
 13105                                  ;;						; advance original string
 13106                                  ;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
 13107                                  ;
 13108                                  ; SI now points past the in(.  Simulate a nextarg call that results in the
 13109                                  ; current value.
 13110                                  ;
 13111                                  ;;	mov	ax,[si-1]		; get lparen and next char
 13112                                  ;;	jmp	short LPCHECK
 13113                                  ;
 13114                                  ; end of Compaq bug fix
 13115                                  
 13116                                  ; ---------------------------------------------------------------------------
 13117                                  
 13118                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13119                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh
 13120                                  
 13121                                  	; MSDOS 3.3 (& MSDOS 6.0)
 13122                                  CHECKLPAREN:
 13123 0000100B E8D200                  	call	NEXTARG			; lparen delimits beginning of <list>
 13124 0000100E 72BD                    	jc	short FORERRORJ
 13125                                  LPCHECK:
 13126                                  	; 15/02/2023
 13127                                  	; MSDOS 5.0 (% MSDOS 6.0)
 13128                                  	;;cmp	al,[LPAREN]
 13129                                  	;cmp	al,lparen
 13130 00001010 3C28                    	cmp	al,'('
 13131 00001012 75B9                    	jne	short FORERRORJ
 13132 00001014 80FC00                  	cmp	ah,0
 13133 00001017 7410                    	je	short FOR_PAREN_TOKEN
 13134                                  	;;cmp	ah,[RPAREN]		; special case:  null list
 13135                                  	;cmp	ah,rparen
 13136 00001019 80FC29                  	cmp	ah,')'
 13137 0000101C 7503                    	jne	short FOR_LIST_NOT_EMPTY
 13138 0000101E E953FE                  	jmp	FORTERM
 13139                                  FOR_LIST_NOT_EMPTY:
 13140                                  	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
 13141 00001021 FF07                    	inc	word [bx]		; Advance ptr past "("
 13142                                  	;dec	word [bx+5]		; Adjust the rest of this argv entry
 13143 00001023 FF4F05                  	dec	word [bx+ARGV_ELE.arglen] ; to agree.
 13144 00001026 46                      	inc	si			; Inc si so check for ")" works
 13145 00001027 EB0D                    	jmp	short FOR_LIST
 13146                                  
 13147                                  	;nop
 13148                                  FOR_PAREN_TOKEN:
 13149 00001029 E8B400                  	call	NEXTARG			; what have we in our <list>?
 13150 0000102C 729F                    	jc	short FORERRORJ
 13151                                  	; 15/02/2023
 13152                                  	;;;cmp	ax,[RPAREN+1]
 13153                                  	;;cmp	ax,[NULLRPAREN]		; special case:  null list
 13154                                  	;cmp	ax,nullrparen
 13155 0000102E 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 13156 00001031 7503                    	jne	short FOR_LIST
 13157 00001033 E93EFE                  	jmp	FORTERM
 13158                                  
 13159                                  ;FORERORJJ:
 13160                                  	;jmp	FORERROR
 13161                                  
 13162                                  FOR_LIST:				; skip over rest of <list>
 13163 00001036 89D1                    	mov	cx,dx			; first arg of <list>
 13164                                  
 13165                                  SKIP_LIST:
 13166                                  	;add	si,[bx+5]
 13167 00001038 037705                  	add	si,[bx+ARGV_ELE.arglen]
 13168 0000103B 83EE03                  	sub	si,3			; si = ptr to last char of token
 13169                                  	; 15/02/2023
 13170                                  	;;mov	al,[RPAREN]
 13171                                  	;mov	al,rparen
 13172 0000103E B029                    	mov	al,')'
 13173 00001040 3804                    	cmp	[si],al			; Is this the last element in <list>
 13174 00001042 7408                    	je	short FOR_END_LIST 	; Yes, exit loop.
 13175 00001044 E89900                  	call	NEXTARG			; No, get next arg <list>
 13176                                  	;jc	short FORERORJJ		; If no more and no rparen, error.
 13177                                  	;jmp	short SKIP_LIST
 13178                                  	; 15/02/2023
 13179 00001047 73EF                    	jnc	short SKIP_LIST
 13180                                  
 13181                                  	; 15/02/2023
 13182                                  FORERORJJ:
 13183 00001049 E961FB                  	jmp	FORERROR
 13184                                  
 13185                                  FOR_END_LIST:
 13186 0000104C 89D7                    	mov	di,dx			; record position of last arg in <list>
 13187 0000104E C60400                  	mov	byte [si],0		; Zap the rparen
 13188                                  	; 15/02/2023
 13189                                  	;;;cmp	ax,[RPAREN+1]
 13190                                  	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
 13191                                  	;cmp	ax,nullparen
 13192 00001051 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 13193 00001054 7401                    	je	short FOR_DO		; Yes, continue
 13194 00001056 47                      	inc	di			; No, inc position of last arg
 13195                                  FOR_DO:
 13196 00001057 E88600                  	call	NEXTARG			; now we had BETTER find a 'do'...
 13197 0000105A 72ED                    	jc	short FORERORJJ
 13198                                  	;and	ax,0DFDFh
 13199 0000105C 25DFDF                  	and	ax,~2020h		; uppercase the letters
 13200                                  	; 15/02/2023
 13201                                  	;;cmp	ax,[DO_WORD]
 13202                                  	;cmp	ax,do_word ; 4F44h
 13203 0000105F 3D444F                  	cmp	ax,'DO'	 ; 4F44h
 13204 00001062 75E5                    	jne	short FORERORJJ
 13205 00001064 AC                      	lodsb
 13206 00001065 08C0                    	or	al,al			; and it had BETTER be ONLY a 'do'...
 13207 00001067 75E0                    	jnz	short FORERORJJ
 13208                                  		
 13209 00001069 E87400                  	call	NEXTARG			; on to the beginning of <command>
 13210 0000106C 72DB                    	jc	short FORERORJJ		; null <command> not legal
 13211                                  
 13212 0000106E 50                      	push	ax
 13213 0000106F 53                      	push	bx
 13214 00001070 51                      	push	cx
 13215 00001071 52                      	push	dx			; preserve registers against disaster
 13216 00001072 57                      	push	di
 13217 00001073 56                      	push	si
 13218 00001074 55                      	push	bp
 13219 00001075 E85FF7                  	call	FREE_TPA		; need to make free memory, first
 13220 00001078 E89500                  	call	FOROFF
 13221                                  	;mov	bx,264
 13222 0000107B BB0801                  	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
 13223 0000107E E84229                  	call	SAVE_ARGS		; extra bytes needed for for-info
 13224 00001081 9C                      	pushf
 13225 00001082 26A3[4A02]              	mov	[es:ForPtr],ax
 13226 00001086 E85EF7                  	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
 13227 00001089 9D                      	popf
 13228 0000108A 5D                      	pop	bp
 13229 0000108B 5E                      	pop	si
 13230 0000108C 5F                      	pop	di
 13231 0000108D 5A                      	pop	dx
 13232 0000108E 59                      	pop	cx
 13233 0000108F 5B                      	pop	bx
 13234 00001090 58                      	pop	ax
 13235 00001091 723C                    	jc	short FOR_ALLOC_ERR
 13236                                  
 13237 00001093 06                      	push	es			; save resgroup seg...
 13238 00001094 26FF36[4A02]            	push	word [es:ForPtr]
 13239 00001099 07                      	pop	es
 13240                                  	;assume es:for_segment
 13241 0000109A 49                      	dec	cx			; forproc wants min pointing before
 13242 0000109B 4F                      	dec	di			; first arg, max right at last one
 13243                                  	; 15/02/2023
 13244                                  	;;mov	[547h],cx
 13245                                  	; 27/07/2024
 13246                                  	;mov	[447h],cx ; PCDOS 7.1 COMMAND.COM
 13247 0000109C 26890E4704              	mov	[es:FOR_INFO.FOR_MINARG],cx
 13248                                  	;;mov	[549h],di
 13249                                  	;mov	[449h],di ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 13250 000010A1 26893E4904              	mov	[es:FOR_INFO.FOR_MAXARG],di
 13251                                  	;;mov	[544h],dl
 13252                                  	;mov	[444h],dl ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 13253 000010A6 2688164404              	mov	[es:FOR_INFO.FOR_COM_START],dl
 13254                                  	;;mov	word [545h],0FFFFh ; -1
 13255                                  	;mov	[445h],0FFFFh ; PCDOS 7.1 COMMAND.COM ; 27/07/2024
 13256 000010AB 26C7064504FFFF          	mov	word [es:FOR_INFO.FOR_EXPAND],-1
 13257                                  					; non-zero means FALSE
 13258 000010B2 89E8                    	mov	ax,bp
 13259                                  	;;mov	[64Bh],ah
 13260                                  	;mov	[54Bh],ah ; 27/07/2024 ; PCDOS 7.1 COMMAND.COM
 13261 000010B4 2688264B05              	mov	[es:FOR_INFO.FOR_VAR],ah
 13262 000010B9 07                      	pop	es
 13263                                  	;assume es:resgroup
 13264 000010BA 26FE06[4902]            	inc	byte [es:ForFlag]
 13265 000010BF 26833E[4302]FF          	cmp	word [es:SingleCom],-1
 13266 000010C5 7507                    	jne	short FOR_RET
 13267 000010C7 26C706[4302]00FF        	mov	word [es:SingleCom],0FF00h
 13268                                  FOR_RET:
 13269 000010CE C3                      	retn
 13270                                  
 13271                                  FOR_ALLOC_ERR:
 13272                                  	; 15/02/2023
 13273                                  	; MSDOS 3.3
 13274                                  	;mov	dx,INSFMEMMESPTR
 13275                                  	;jmp	CERROR
 13276                                  
 13277                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13278                                  	; MSDOS 6.0
 13279                                  	;mov	byte [msg_disp_class],1
 13280 000010CF C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class
 13281                                  					;AN000; set up extended error msg class
 13282                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 13283 000010D4 BA[D091]                	mov	dx,extend_buf_ptr
 13284                                  					;AC000; get extended message pointer
 13285                                  	;mov	word [extend_buf_ptr],8
 13286 000010D7 C706[D091]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 13287                                  					;AN000; get message number in control block
 13288 000010DD E9C21D                  	jmp	cerror
 13289                                  
 13290                                  
 13291                                  ; =============== S U B	R O U T	I N E =======================================
 13292                                  
 13293                                  NEXTARG:
 13294 000010E0 42                      	inc	dx			; next argv[n]
 13295                                  	;cmp	dx,[ARG_ARGVCNT]
 13296 000010E1 3B16[01A5]              	cmp	dx,[ARG+ARG_UNIT.argvcnt]
 13297                                  					; make sure we don't run off end
 13298 000010E5 7D0D                    	jge	short NEXTARG_ERR 	;  of argv[]...	
 13299 000010E7 89D3                    	mov	bx,dx
 13300                                  	;mov	ax,ARG_ARGV
 13301                                  	;mov	ax,ARG+ARG_UNIT.argv
 13302 000010E9 B8[41A2]                	mov	ax,ARG
 13303 000010EC E8AF25                  	call	argv_calc		; convert array index to pointer
 13304 000010EF 8B37                    	mov	si,[bx]			; load pointer to argstring
 13305                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 13306 000010F1 AD                      	lodsw				; and load first two chars
 13307 000010F2 F8                      	clc
 13308 000010F3 C3                      	retn
 13309                                  NEXTARG_ERR:
 13310 000010F4 F9                      	stc
 13311 000010F5 C3                      	retn
 13312                                  
 13313                                  ; ---------------------------------------------------------------------------
 13314                                  
 13315                                  FORNESTERR:
 13316 000010F6 1E                      	push	ds
 13317 000010F7 8E1E[F39D]              	mov	ds,[RESSEG]
 13318                                  	;ASSUME DS:RESGROUP
 13319 000010FB BA[2E93]                	mov	dx,FORNESTMES_PTR
 13320 000010FE 813E[4302]00FF          	cmp	word [SingleCom],0FF00h
 13321 00001104 7506                    	jne	short NOFORP3
 13322 00001106 C706[4302]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
 13323                                  NOFORP3:
 13324 0000110C 1F                      	pop	ds
 13325 0000110D E9921D                  	jmp	cerror
 13326                                  
 13327                                  ; =============== S U B	R O U T	I N E =======================================
 13328                                  
 13329                                  ; General routine called to free the for segment. We also clear the forflag
 13330                                  ; too. Change no registers.
 13331                                  
 13332                                  FOROFF:
 13333 00001110 50                      	push	ax
 13334 00001111 06                      	push	es
 13335 00001112 2E8E06[F39D]            	mov	es,[cs:RESSEG]
 13336 00001117 26A1[4A02]              	mov	ax,[es:ForPtr]
 13337 0000111B 09C0                    	or	ax,ax
 13338 0000111D 7408                    	jz	short FREEDONE
 13339 0000111F 06                      	push	es
 13340 00001120 8EC0                    	mov	es,ax
 13341                                  	; 15/02/2023
 13342 00001122 B449                    	mov	ah,49h
 13343                                  	;mov	ah,DEALLOC ; 49h
 13344 00001124 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 13345                                  			; ES = segment address of area to be freed
 13346 00001126 07                      	pop	es
 13347                                  FREEDONE:
 13348 00001127 26C706[4A02]0000        	mov	word [es:ForPtr],0
 13349 0000112E 26C606[4902]00          	mov	byte [es:ForFlag],0
 13350 00001134 07                      	pop	es
 13351 00001135 58                      	pop	ax
 13352 00001136 C3                      	retn
 13353                                  
 13354                                  ;============================================================================
 13355                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
 13356                                  ;============================================================================
 13357                                  ; 09/10/2018 - Retro DOS v3.0
 13358                                  
 13359                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
 13360                                  
 13361                                  ; ---------------------------------------------------------------------------
 13362                                  
 13363                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13364                                  
 13365                                  %if 0
 13366                                  
 13367                                  ; The DIR command displays the contents of a directory.
 13368                                  ;
 13369                                  ; ****************************************************************
 13370                                  ; *
 13371                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
 13372                                  ; *
 13373                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
 13374                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
 13375                                  ; *		 If an error occurs issue and error message and
 13376                                  ; *		 transfer control to CERROR.
 13377                                  ; *
 13378                                  ; * INPUT:	 command line at offset 81H
 13379                                  ; *
 13380                                  ; * OUTPUT:	 none
 13381                                  ; *
 13382                                  ; ****************************************************************
 13383                                  
 13384                                  CATALOG:
 13385                                  	; MSDOS 3.3
 13386                                  
 13387                                  	;mov	ax,ARG_ARGV
 13388                                  	;mov	ax,ARG+ARG_UNIT.argv
 13389                                  	mov	ax,ARG
 13390                                  	mov	dx,0FFFFh
 13391                                  	xor	cx,cx
 13392                                  	xor	si,si
 13393                                  DIR1:
 13394                                  	;cmp	cx,[ARG_ARGVCNT]
 13395                                  	cmp	cx,[ARG+ARG_UNIT.argvcnt]
 13396                                  	jnb	short DIR6 ; No more arguments
 13397                                  	mov	bx,cx
 13398                                  	call	ARGV_CALC
 13399                                  	;or	si,[bx+7]
 13400                                  	or	si,[bx+ARGV_ELE.argsw_word]
 13401                                  	test	si,7FFCh  ; test si,~8003
 13402                                  	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
 13403                                  	;test	byte [bx+2],1
 13404                                  	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
 13405                                  	jz	short DIR3
 13406                                  	jmp	short DIR5
 13407                                  DIR2:
 13408                                  	mov	dx,BADPARMPTR
 13409                                  	jmp	CERROR
 13410                                  DIR3:
 13411                                  	or	cx,cx
 13412                                  	jnz	short DIR4	
 13413                                  	;cmp	word [bx+5],3
 13414                                  	cmp	word [bx+ARGV_ELE.arglen],3
 13415                                  	jz	short DIR5
 13416                                  	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
 13417                                  	add	word [bx],3
 13418                                  	;add	word [bx+9],3
 13419                                  	add	word [bx+ARGV_ELE.arg_ocomptr],3
 13420                                  	;add	word [bx+3],3
 13421                                  	add	word [bx+ARGV_ELE.argstartel],3
 13422                                  	;sub	word [bx+5],3
 13423                                  	sub	word [bx+ARGV_ELE.arglen],3
 13424                                  DIR4:
 13425                                  	cmp	dx,0FFFFh
 13426                                  	jnz	short DIR2
 13427                                  	mov	dx,bx
 13428                                  DIR5:
 13429                                  	inc	cx
 13430                                  	jmp	short DIR1
 13431                                  DIR6:
 13432                                  	mov	[COMSW],si
 13433                                  	push	dx
 13434                                  	xor	al,al
 13435                                  	cmp	dx,0FFFFh
 13436                                  	jz	short DIR7
 13437                                  	mov	bx,dx
 13438                                  	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
 13439                                  	mov	di,[bx]
 13440                                  	cmp	byte [di+1],':'
 13441                                  	jnz	short DIR7
 13442                                  	mov	al,[di]
 13443                                  	or	al,20h		; Lowercase drive name	
 13444                                  	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
 13445                                  DIR7:
 13446                                  	;mov	[5CH],al
 13447                                  	mov	[FCB],al
 13448                                  	call	OKVOLARG
 13449                                  	mov	al,'?'		; *.* is default file spec.
 13450                                  	;mov	di,5Dh
 13451                                  	mov	di,FCB+1
 13452                                  	mov	cx,11
 13453                                  	rep stosb
 13454                                  
 13455                                  ; Begin by processing any switches that may have been specified.
 13456                                  ; BITS will contain any information about switches that was
 13457                                  ; found when the command line was parsed.
 13458                                  
 13459                                  	mov	ax,[COMSW]	; Get switches from command
 13460                                  	mov	[_BITS],ax	; initialize switches
 13461                                  	mov	word [COMSW],0	; initialize flags
 13462                                  	mov	byte [LINPERPAG],23 ; Set default for lines per page
 13463                                  	;test	al,1
 13464                                  	test	al,SWITCHW	; /W ?
 13465                                  	;mov	al,1
 13466                                  	mov	al,NORMPERLIN
 13467                                  	jz	short DIR8
 13468                                  	;mov	al,5
 13469                                  	mov	al,WIDEPERLIN
 13470                                  DIR8:
 13471                                  	mov	[LINLEN],al	; Set number of entries per line
 13472                                  	mov	[LINCNT],al
 13473                                  	mov	word [FILECNT],0 ; Keep track of how many files found
 13474                                  	mov	dx,DIRBUF
 13475                                  	mov	ah,Set_DMA ; 1Ah
 13476                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13477                                  			; DS:DX	-> disk	transfer buffer
 13478                                  	;mov	dl,[5Ch]
 13479                                  	mov	dl,[FCB]
 13480                                  	call	SAVUDIR
 13481                                  	pop	bx
 13482                                  	cmp	bx,0FFFFh
 13483                                  	jz	short DIR9
 13484                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 13485                                  	mov	dx,[bx]
 13486                                  
 13487                                  ; The user may have specified a device. Search for the path and see if the
 13488                                  ; attributes indicate a device.
 13489                                  
 13490                                  	mov	ah,Find_First ; 4Eh
 13491                                  	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 13492                                  			; CX = search attributes
 13493                                  			; DS:DX	-> ASCIZ filespec
 13494                                  			; (drive,path, and wildcards allowed)
 13495                                  	jc	short DIR10
 13496                                  			; Check device atrribute..
 13497                                  	;test	byte [DIRBUF_ATTRIB2],40h
 13498                                  	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
 13499                                  	; 14/10/2018
 13500                                  	;test	byte [DIRBUF+21],40h
 13501                                  	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 13502                                  	jz	short DIR10	; no, go do normal operation
 13503                                  	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
 13504                                  DIR9:
 13505                                  	jmp	short DOHEADER
 13506                                  DIR10:
 13507                                  	;mov	dx,[bx+ARGV_ELE.argpointer]
 13508                                  	mov	dx,[bx]
 13509                                  	mov	ah,CHDir ; 3Bh
 13510                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13511                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13512                                  	jnc	short DOHEADER
 13513                                  	;mov	si,[bx+3]
 13514                                  	mov	si,[bx+ARGV_ELE.argstartel]
 13515                                  	cmp	dx,si
 13516                                  	jz	short DIR_NO_DRIVE
 13517                                  	xor	cl,cl
 13518                                  	xchg	cl,[si]
 13519                                  	mov	ah,CHDir ; 3Bh
 13520                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13521                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13522                                  	xchg	cl,[si]
 13523                                  	jnc	short DIR_NO_DRIVE
 13524                                  	mov	al,[si-1]
 13525                                  	call	PATHCHRCMP
 13526                                  	jnz	short DIR11
 13527                                  	mov	al,[si-2]
 13528                                  	call	PATHCHRCMP
 13529                                  	jz	short DIR12
 13530                                  	xchg	cl,[si-1]
 13531                                  	mov	ah,CHDir ; 3Bh
 13532                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13533                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13534                                  	xchg	cl,[si-1]
 13535                                  	jnc	short DIR_NO_DRIVE
 13536                                  DIR11:
 13537                                  	mov	ch,':'
 13538                                  	cmp	ch,[si-1]
 13539                                  	jnz	short DIR12
 13540                                  	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
 13541                                  	mov	cx,[bx]
 13542                                  	xchg	cx,si
 13543                                  	sub	cx,si
 13544                                  	cmp	cx,2
 13545                                  	jz	short DIR_NO_DRIVE
 13546                                  DIR12:
 13547                                  	mov	dx,BADCDPTR
 13548                                  	;test	byte [bx+2],4
 13549                                  	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 13550                                  	jnz	short DIRERROR
 13551                                  DIRNF:
 13552                                  	mov	dx,FNOTFOUNDPTR
 13553                                  DIRERROR:
 13554                                  	jmp	CERROR
 13555                                  DIR_NO_DRIVE:
 13556                                  	cmp	word [si],'..'
 13557                                  	jnz	short DOREALPARSE
 13558                                  	cmp	byte [si+2],0
 13559                                  	jnz	short DOREALPARSE
 13560                                  	inc	word [COMSW]
 13561                                  	jmp	short DOHEADER
 13562                                  DOREALPARSE:
 13563                                  	mov	di,FCB ; 5Ch	
 13564                                  	;mov	ax,290Eh
 13565                                  	mov	ax,(Parse_File_Descriptor<<8)|0Eh
 13566                                  	int	21h	; DOS -	PARSE FILENAME
 13567                                  			; DS:SI	-> string to parse
 13568                                  			; ES:DI	-> buffer to fill with unopened	FCB
 13569                                  			; AL = bit mask	to control parsing
 13570                                  	cmp	byte [si],0
 13571                                  	jz	short DOHEADER
 13572                                  	dec	word [COMSW]
 13573                                  DOHEADER:
 13574                                  		
 13575                                  ; Display the header
 13576                                  
 13577                                  	push	bx
 13578                                  	call	BUILD_DIR_STRING
 13579                                  	mov	dx,DIRBUF
 13580                                  	mov	[VOL_DIR],dx
 13581                                  	mov	dx,DIRHEADPTR
 13582                                  	call	PRINTF_CRLF
 13583                                  	pop	bx
 13584                                  	cmp	bx,0FFFFh
 13585                                  	jz	short DOSEARCH
 13586                                  
 13587                                  ; If there were chars left after parse or device, then invalid file name
 13588                                  
 13589                                  	cmp	word [COMSW],0
 13590                                  	jz	short DOSEARCH	; nothing left; good parse
 13591                                  	jl	short DIRNFFIX	; not .. => error file not found
 13592                                  	call	RESTUDIR
 13593                                  	mov	dx,BADCDPTR
 13594                                  	jmp	CERROR		; was .. => error directory not found
 13595                                  DIRNFFIX:
 13596                                  	call	RESTUDIR
 13597                                  	jmp	short DIRNF
 13598                                  
 13599                                  ; We are assured that everything is correct. Let's go and search. Use
 13600                                  ; attributes that will include finding directories. Perform the first search
 13601                                  ; and reset our directory afterward.
 13602                                  
 13603                                  DOSEARCH:
 13604                                  	;mov	byte [55h],0FFh
 13605                                  	mov	byte [FCB-7],0FFh
 13606                                  	;mov	byte [5Bh],10h
 13607                                  	mov	byte [FCB-1],10h
 13608                                  
 13609                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
 13610                                  ; the directory information as an extended FCB. We must bias all fetches into
 13611                                  ; DIRBUF by 8 (Extended FCB part + drive)
 13612                                  
 13613                                  	mov	ah,Dir_Search_First ; 11h
 13614                                  	mov	dx,FCB-7 ; 55h
 13615                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 13616                                  			; DS:DX	-> FCB
 13617                                  
 13618                                  ; Restore the user's directory. We preserve, though, the return from the
 13619                                  ; previous system call for later checking.
 13620                                  
 13621                                  FOUND_FIRST_FILE:
 13622                                  	push	ax		; save return state
 13623                                  	call	RESTUDIR	; restore user's dir	
 13624                                  	pop	ax		; get return state back
 13625                                  
 13626                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
 13627                                  ; no more.
 13628                                  
 13629                                  DIRSTART:
 13630                                  	inc	al		; 0FFh = file not found
 13631                                  	jnz	short DISPLAY	; Either an error or we are finished
 13632                                  	jmp	CHKCNT
 13633                                  DISPLAY:
 13634                                  	inc	word [FILECNT]	; Keep track of how many we find
 13635                                  	mov	si,DIRBUF+8	; SI -> information returned by sys call
 13636                                  	;call	SHONAME
 13637                                  	call	DISPLAYNAME
 13638                                  	;test	byte [_BITS],1
 13639                                  	test	byte [_BITS],SWITCHW ; W switch set?
 13640                                  	jz	short DIRTEST	; If so, no size, date, or time
 13641                                  	jmp	NEXENT
 13642                                  DIRTEST:
 13643                                  	;test	byte [DIRBUF_ATTRIB1],10h
 13644                                  	; 14/10/2018
 13645                                  	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
 13646                                  	;test	byte [DIRBUF+19],10h
 13647                                  	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
 13648                                  	jz	short FILEENT
 13649                                  	mov	dx,DMESPTR
 13650                                  	call	STD_PRINTF
 13651                                  	jmp	short NOFSIZ
 13652                                  FILEENT:
 13653                                  	;mov	dx,[DIRBUF_FSIZ_L]
 13654                                  	;mov	dx,[DIRBUF+36]
 13655                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
 13656                                  	mov	[FILESIZE_L],dx
 13657                                  	;mov	dx,[DIRBUF_FSIZ_H]
 13658                                  	;mov	dx,[DIRBUF+38]
 13659                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
 13660                                  	mov	[FILESIZE_H],dx
 13661                                  	mov	dx,FSIZEMESPTR
 13662                                  	call	STD_PRINTF	; Print size of file
 13663                                  NOFSIZ:
 13664                                  	;mov	ax,[DIRBUF_FDATE]  ; Get date
 13665                                  	;mov	ax,[DIRBUF+32]
 13666                                  	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
 13667                                  	or	ax,ax
 13668                                  	jz	short NEXENT	; Skip if no date
 13669                                  	mov	di,CHARBUF
 13670                                  	push	ax
 13671                                  	mov	ax,'  '
 13672                                  	stosw
 13673                                  	pop	ax
 13674                                  	mov	bx,ax
 13675                                  	and	ax,1Fh		; Get day
 13676                                  	mov	dl,al
 13677                                  	mov	ax,bx
 13678                                  	mov	cl,5
 13679                                  	shr	ax,cl		; Align month
 13680                                  	and	al,0Fh		; Get month
 13681                                  	mov	dh,al
 13682                                  	mov	cl,bh
 13683                                  	shr	cl,1		; Align year
 13684                                  	xor	ch,ch
 13685                                  	add	cx,80		; Relative 1980
 13686                                  	cmp	cl,100
 13687                                  	jb	short MILLENIUM
 13688                                  	sub	cl,100
 13689                                  MILLENIUM:
 13690                                  	call	DATE_CXDX
 13691                                  	;mov	cx,[DIRBUF_FTIME]
 13692                                  	;mov	cx,[DIRBUF+30]
 13693                                  	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
 13694                                  	jcxz	PRBUF		; Time field present?
 13695                                  	mov	ax,2020h
 13696                                  	stosw
 13697                                  	shr	cx,1
 13698                                  	shr	cx,1
 13699                                  	shr	cx,1
 13700                                  	shr	cl,1
 13701                                  	shr	cl,1		; Hours in CH, minutes in CL
 13702                                  	mov	bl,[TIME_24]
 13703                                  	or	bl,80h		; Tell P_TIME called from DIR
 13704                                  	call	P_TIME		; Don't care about DX, never used with DIR
 13705                                  PRBUF:
 13706                                  	xor	ax,ax
 13707                                  	stosb
 13708                                  	mov	dx,CHARBUF
 13709                                  	mov	[STRING_PTR_2],dx
 13710                                  	mov	dx,STRINGBUF2PTR
 13711                                  	call	STD_PRINTF
 13712                                  NEXENT:
 13713                                  	dec	byte [LINCNT]
 13714                                  	jnz	short SAMLIN
 13715                                  NEXLIN:
 13716                                  	mov	al,[LINLEN]
 13717                                  	mov	[LINCNT],al
 13718                                  	call	CRLF2
 13719                                  	dec	byte [LINPERPAG]
 13720                                  	jnz	short SCROLL
 13721                                  	;test	byte [_BITS],2
 13722                                  	test	byte [_BITS],SWITCHP ; P switch present?
 13723                                  	jz	short SCROLL	; If not, just continue
 13724                                  	mov	byte [LINPERPAG],23
 13725                                  	call	PAUSE
 13726                                  	jmp	short SCROLL
 13727                                  SAMLIN:
 13728                                  	mov	dx,TABPTR	; Output a tab
 13729                                  	call	STD_PRINTF
 13730                                  SCROLL:
 13731                                  	mov	ah,Dir_Search_Next ; 12h
 13732                                  	;mov	dx,55h
 13733                                  	mov	dx,FCB-7	; DX -> Unopened FCB
 13734                                  	int	21h	; DOS -	SEARCH NEXT USING FCB
 13735                                  			; DS:DX	-> FCB
 13736                                  			; Return: AL = status
 13737                                  	jmp	DIRSTART
 13738                                  CHKCNT:
 13739                                  	test	word [FILECNT],0FFFFh ; -1
 13740                                  	jnz	short TRAILER
 13741                                  	jmp	DIRNF
 13742                                  TRAILER:
 13743                                  	mov	al,[LINLEN]
 13744                                  	cmp	al,[LINCNT]
 13745                                  	jz	short MMESSAGE
 13746                                  	call	CRLF2
 13747                                  MMESSAGE:
 13748                                  	mov	dx,DIRMESPTR
 13749                                  	mov	si,[FILECNT]
 13750                                  	mov	[DIR_NUM],si
 13751                                  	call	STD_PRINTF
 13752                                  DTFREE:
 13753                                  	mov	ah,GET_DRIVE_FREESPACE ; 36h
 13754                                  	;mov	dl,[5Ch]
 13755                                  	mov	dl,[FCB]
 13756                                  	int	21h	; DOS -	2+ - GET DISK SPACE
 13757                                  			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
 13758                                  	cmp	ax,-1
 13759                                  	jnz	short DTFREE1
 13760                                  DTRET:
 13761                                  	retn
 13762                                  DTFREE1:
 13763                                  	mul	cx
 13764                                  	mul	bx
 13765                                  	mov	[BYTES_FREE],ax
 13766                                  	mov	[BYTES_FREE+2],dx
 13767                                  	mov	dx,BYTEMESPTR
 13768                                  	jmp	STD_PRINTF
 13769                                  
 13770                                  ; =============== S U B	R O U T	I N E =======================================
 13771                                  
 13772                                  SHONAME:
 13773                                  DISPLAYNAME:
 13774                                  	; MSDOS 3.3
 13775                                  	mov	di,CHARBUF
 13776                                  	mov	cx,8
 13777                                  	rep	movsb
 13778                                  	mov	al,' '
 13779                                  	stosb
 13780                                  	mov	cx,3
 13781                                  	rep	movsb
 13782                                  	xor	ax,ax
 13783                                  	stosb
 13784                                  	push	dx
 13785                                  	mov	dx,CHARBUF
 13786                                  	mov	[STRING_PTR_2],dx
 13787                                  	mov	dx,STRINGBUF2PTR
 13788                                  	call	STD_PRINTF
 13789                                  	pop	dx
 13790                                  	retn
 13791                                  
 13792                                  %endif
 13793                                  
 13794                                  ;============================================================================
 13795                                  ; DIR.ASM, MSDOS 6.0, 1991
 13796                                  ;============================================================================
 13797                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13798                                  
 13799                                  	; MSDOS 6.0
 13800                                  %if 0
 13801                                  
 13802                                  ;***	DIR.ASM - DIR internal command
 13803                                  
 13804                                  comment	% =================================================================
 13805                                  
 13806                                  This module replaces TCMD1A.ASM.  The old module was titled 
 13807                                  "PART4 COMMAND Transient routines".
 13808                                  
 13809                                  From residual documentation, I surmise that TCMD.ASM originally
 13810                                  contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
 13811                                  VER.  The file seems to have been successively split:
 13812                                  
 13813                                    TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B
 13814                                  
 13815                                  TCMD1A.ASM contained only the DIR command.
 13816                                  
 13817                                  Usage:
 13818                                  ------
 13819                                  
 13820                                  DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>
 13821                                  
 13822                                  DIR /?
 13823                                  
 13824                                  
 13825                                  <filespec> may include any or none of:  drive; directory path;
 13826                                             wildcarded filename.  If drive or directory path are
 13827                                  	   omitted, the current defaults are used.  If the
 13828                                  	   file name or extension is omitted, wildcards are
 13829                                  	   assumed.
 13830                                  
 13831                                  /w	Wide listing format.  Files are displayed in compressed
 13832                                  	'name.ext' format.  Subdirectory files are enclosed in
 13833                                  	brackets, '[dirname]'.
 13834                                  
 13835                                  /p	Paged, or prompted listing.  A screenful is displayed
 13836                                  	at a time.  The name of the directory being listed appears
 13837                                  	at the top of each page.
 13838                                  
 13839                                  	Bugbug:  pages nead to be uniform length..?
 13840                                  
 13841                                  /b	Bare listing format.  Turns off /w or /p.  Files are 
 13842                                  	listed in compressed 'name.ext' format, one per line,
 13843                                  	without additional information.  Good for making batch
 13844                                  	files or for piping.  When used with /s, complete
 13845                                  	pathnames are listed.
 13846                                  
 13847                                  /s	Descend subdirectory tree.  Performs command on current
 13848                                  	or specified directory, then for each subdirectory below
 13849                                  	that directory.  Directory header and footer is displayed
 13850                                  	for each directory where matching files are found, unless
 13851                                  	used with /b.  /b suppresses headers and footers.
 13852                                  
 13853                                  	Tree is explored depth first, alphabetically within the
 13854                                  	same level.
 13855                                  
 13856                                  	Bugbug:  hidden directories aren't searched.
 13857                                  
 13858                                  /l	Display file names, extensions and paths in lowercase.	;M010
 13859                                  
 13860                                  /c	Display file compression ratio, if the file is on a MagicDrv
 13861                                  	compressed volume.
 13862                                  
 13863                                  /o	Sort order.  /o alone sorts by default order (dirs-first, name,
 13864                                  	extension).  A sort order may be specified after /o.  Any of
 13865                                  	the following characters may be used: nedsgc (name, extension,
 13866                                  	date/time, size, group-dirs-first, compression ratio).	Placing
 13867                                  	a '-' before any letter causes a downward sort on that field.
 13868                                  	E.g., /oe-d means sort first by extension in alphabetical order,
 13869                                  	then within each extension sort by date and time in reverse
 13870                                  	chronological order.
 13871                                  
 13872                                  /a	Attribute selection.  Without /a, hidden and system files
 13873                                  	are suppressed from the listing.  With /a alone, all files
 13874                                  	are listed.  An attribute list may follow /a, consisting of
 13875                                  	any of the following characters:  hsdar (hidden, system,
 13876                                  	directory, archive, read-only).  A '-' before any letter
 13877                                  	means 'not' that attribute.  E.g., /ar-d means files that
 13878                                  	are marked read-only and are not directory files.  Note
 13879                                  	that hidden or system files may be included in the listing.
 13880                                  	They are suppressed without /a but are treated like any other
 13881                                  	attribute with /a.
 13882                                  
 13883                                  /?	Help listing.  Display DIR useage information.	;M008;Handled externally
 13884                                  
 13885                                  /h has been removed.					;M008
 13886                                  
 13887                                  DIRCMD	An environment variable named DIRCMD is parsed before the
 13888                                  	DIR command line.  Any command line options may be specified
 13889                                  	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
 13890                                  	A filespec may be specified in DIRCMD and will be used unless
 13891                                  	a filespec is specified on the command line.  Any switch
 13892                                  	specified in DIRCMD may be overridden on the command line.
 13893                                  	If the original DIR default action is desired for a particular
 13894                                  	switch, the switch letter may be preceded by a '-' on the
 13895                                  	command line.  E.g.,
 13896                                  
 13897                                  	  /-w	use long listing format
 13898                                  	  /-p	don't page the listing
 13899                                  	  /-b	don't use bare format
 13900                                  	  /-s	don't descend subdirectory tree
 13901                                  	  /-o	display files in disk order
 13902                                  	  /-a	suppress hidden and system files
 13903                                  
 13904                                  Notes:
 13905                                  ------
 13906                                  
 13907                                  For sorted listings, file entries are loaded into the TPA buffer, which
 13908                                  is usually about 64K in size.  This allows sorts of up to 3000 files at
 13909                                  a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
 13910                                  The byte after the last entry is 0FFh.  The first byte of each entry is
 13911                                  a flag byte which is made zero when the entry is loaded, and made one
 13912                                  when the entry is used.
 13913                                  
 13914                                  Revision History
 13915                                  ================
 13916                                  M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
 13917                                  				in the absence of ANSI.SYS
 13918                                  
 13919                                  M007	sa	8/1/90		Allow /p/b combination
 13920                                  
 13921                                  M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
 13922                                  				to internally handle /? message.
 13923                                  
 13924                                  M010	sa	8/5/90		Add support for /l (lowercase) option.
 13925                                  
 13926                                  M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
 13927                                  				first FCB with the drive number when the drive
 13928                                  				letter in the command line is preceded by a
 13929                                  				switch.  Now dir manually loads the drive
 13930                                  				number after parsing.
 13931                                  
 13932                                  M018	md	8/12/90 	Increment the screen height by 1 when obtained
 13933                                  				from the ROM BIOS.
 13934                                  
 13935                                  M023	sa	8/31/90		Prevent DIR from failing if it encounters
 13936                                  				a subdirectory having len(pathname)>MAXPATH.
 13937                                  				Just skip over that subdirectory.
 13938                                  
 13939                                  M028	dbo	9/24/90		When country=US, sort by strict character
 13940                                  				byte value, rather than collating table.
 13941                                  				This to match MS-DOS Shell's sort order.
 13942                                  
 13943                                  ========================================================================= %
 13944                                  
 13945                                  %endif
 13946                                  
 13947                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM (MSDOS 6.22)
 13948                                  ;ifdef DBLSPACE_HOOKS
 13949                                  NUM_DIR_SWS	equ	16	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13950                                  ;else
 13951                                  ; 16/02/2023 - Retro DOS v4.0 (v4.1) COMMAND.COM (MSDOS 5.0)
 13952                                  ;NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13953                                  ;endif
 13954                                  
 13955                                  ;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13956                                  ;
 13957                                  ;		on/off bit record for /l, /b, /s, /p, /w, /c options
 13958                                  ;		(order is hard-coded; see OnOffSw)
 13959                                  ;		Inmem is set when entries are loaded in memory.
 13960                                  
 13961                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13962                                  ;mask.wide  equ 1
 13963                                  ;mask.pagd  equ 2
 13964                                  ;mask.subd  equ 4
 13965                                  ;mask.bare  equ 8
 13966                                  ;mask.lcase equ 16
 13967                                  ;mask.inmem equ 32
 13968                                  
 13969                                  ; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 13970                                  ;ifdef DBLSPACE_HOOKS
 13971                                  ;  OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1,cratio:1
 13972                                  ;else
 13973                                  ;  OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13974                                  ;endif
 13975                                  mask.cratio equ 1
 13976                                  mask.wide   equ 2
 13977                                  mask.pagd   equ 4
 13978                                  mask.subd   equ 8
 13979                                  mask.bare   equ 16
 13980                                  mask.lcase  equ 32
 13981                                  mask.inmem  equ 64
 13982                                  ;
 13983                                  mask.dev    equ 1
 13984                                  mask.baddir equ 2	
 13985                                  
 13986                                  NUM_ATTR_LTRS	equ	6	; length of attribute letter list
 13987                                  
 13988                                  ; 05/06/2023
 13989                                  ;ifdef DBLSPACE_HOOKS
 13990                                  NUM_ORDER_LTRS	equ	6	; length of sort order letter list
 13991                                  CRATIO_ORDER	equ	6	; position of 'C' in ORDER_LTRS
 13992                                  ;else
 13993                                  ;NUM_ORDER_LTRS	equ	5	; length of sort order letter list
 13994                                  ;endif
 13995                                  
 13996                                  ;ResultBuffer	struc		; structure of parse result buffer
 13997                                  ;ValueType	db	?
 13998                                  ;ValueTag	db	?
 13999                                  ;SynPtr		dw	?
 14000                                  ;ValuePtr	dd	?
 14001                                  ;ResultBuffer	ends
 14002                                  
 14003                                  ;ErrorRec	record	baddir:1,dev:1
 14004                                  ;
 14005                                  ;		Error bits are:
 14006                                  ;		  Invalid directory format
 14007                                  ;		  File is device
 14008                                  
 14009                                  ;EntryStruc	struc			; our private directory entry structure
 14010                                  ;used		db	?		; =0 until entry used, then =1
 14011                                  ;filename	db	8 dup (?)	; filename
 14012                                  ;fileext	db	3 dup (?)	; extension
 14013                                  ;fileattr	db	?		; file attributes
 14014                                  ;filetime	dw	?		; file time
 14015                                  ;filedate	dw	?		; file date
 14016                                  ;filesize	dd	?		; file size
 14017                                  ; 05/06/2023
 14018                                  ;;ifdef DBLSPACE_HOOKS
 14019                                  ;compratio	db	?		; compression ratio
 14020                                  ;;endif
 14021                                  ;EntryStruc	ends
 14022                                  
 14023                                  ;shove	macro	val		; hose-bag 8086 doesn't push immediate
 14024                                  ;	mov	ax,val		; invisible, dangerous use of AX!
 14025                                  ;	push	ax
 14026                                  ;	endm
 14027                                  
 14028                                  ;	public	Catalog		; our entry point
 14029                                  ;
 14030                                  ;	break	<DIR (Catalog) principal routines>
 14031                                  ;
 14032                                  ;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
 14033                                  ; ---------------------------------------------------------------------------
 14034                                  ;	Bugbug:	Each routine should start with it's own ASSUME.
 14035                                  
 14036                                  ;----------------------------------------------------------------------------
 14037                                  ;----------------------------------------------------------------------------
 14038                                  
 14039                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14040                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh
 14041                                  
 14042                                  ;***	Catalog - DIR command main routine
 14043                                  ;
 14044                                  ;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
 14045                                  ;		Cmd-line tail text is at 81h, terminated by 0Dh
 14046                                  ;		CS, DS, ES, SS = TRANGROUP seg addr
 14047                                  ;		Tpa = TPA buffer seg addr
 14048                                  ;		BytCnt = # bytes in TPA buffer
 14049                                  ;
 14050                                  ;	EXIT	nothing
 14051                                  ;
 14052                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14053                                  ;
 14054                                  ;	ERROR EXITS
 14055                                  ;
 14056                                  ;	  Errors are handled by setting up error message pointers
 14057                                  ;	   for Std_EPrintf and jumping to CError. Syntax errors in
 14058                                  ;	   the environment variable, however, are handled by printing
 14059                                  ;	   an error message and continuing.
 14060                                  ;
 14061                                  ;	EFFECTS
 14062                                  ;
 14063                                  ;	  Directory listing is displayed (on standard output).
 14064                                  ;	  APPEND is disabled. HeadFix routine is expected to
 14065                                  ;	   restore APPEND state.
 14066                                  ;	  Working directory may be changed. The user's default
 14067                                  ;	   directory is saved and flagged for restoration by RestUDir
 14068                                  ;	   during COMMAND cycle.
 14069                                  ;	  Lots of variables may be changed in TRANSPACE segment.
 14070                                  ;
 14071                                  ;	NOTES
 14072                                  ;
 14073                                  ;	  ES = TRANGROUP seg addr except when used to address the
 14074                                  ;	   the TPA buffer, where directory entries are loaded from disk.
 14075                                  
 14076                                  	; 16/02/2023
 14077                                  
 14078                                  ; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 14079                                  ;----------------------------------------------------------------------------
 14080                                  ; MSDOS 6.22 COMMAND.COM - TRANGROUP:1167h
 14081                                  
 14082                                  CATALOG:
 14083                                  	; 07/06/2023
 14084                                  	; MSDOS 6.22 COMMAND COM feature only !
 14085 00001137 E82B0A                  	call    screen_f_set	; set display parameters for video/text mode
 14086                                  	;			; (different depending on scr width/columns)
 14087 0000113A E8C900                  	call	SetDefaults
 14088 0000113D E8ED00                  	call	ParseEnvironment
 14089 00001140 E80501                  	call	ParseCmdLine
 14090 00001143 7303                    	jnc	short catalog1	; no parse error
 14091                                  	;jmp	catErr		; error msg is set up
 14092                                  	; 07/06/2023
 14093                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMANBD.COM
 14094 00001145 E9B100                  	jmp	catExtErr2 
 14095                                  catalog1:
 14096 00001148 E82E01                  	call	SetOptions
 14097 0000114B E80401                  	call	SetCollatingTable
 14098                                  
 14099                                  ;	Drive # to operate on has already been placed in FCB by
 14100                                  ;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.
 14101                                  
 14102                                  	;;;test	Bits,mask bare
 14103                                  	;;test 	word [_Bits],8
 14104                                  	;test	byte [_Bits],8
 14105                                  	; 07/06/2023
 14106 0000114E F606[7CA0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 14107 00001153 750A                    	jnz	short catalog2	; don't display volume info for /b
 14108                                  	;invoke	OkVolArg	; find & display volume info
 14109 00001155 E85C10                  	call	OkVolArg
 14110                                  	;sub	byte [LeftOnpage],2
 14111 00001158 832E[1B9E]02            	sub	word [LeftOnPage],2
 14112                                  				; record display lines used by volume info
 14113 0000115D EB14                    	jmp	short catCrunch
 14114                                  
 14115                                  ;	OkVolArg side effects:
 14116                                  ;	APPEND is disabled;
 14117                                  ;	DTA established at DirBuf;
 14118                                  ;	Filename fields in FCB are wildcarded.
 14119                                  
 14120                                  catalog2:
 14121                                  ;	OkVolArg wasn't executed, so we have to do these ourselves.
 14122                                  
 14123                                  	;invoke	DisAppend	; disable APPEND
 14124 0000115F E81F10                  	call	DisAppend
 14125                                  
 14126                                  	;mov	dx,offset TRANGROUP:DirBuf
 14127 00001162 BA[2AA0]                	mov	dx,DIRBUF
 14128 00001165 B41A                    	mov	ah,1Ah
 14129                                  	;mov	ah,Set_DMA
 14130 00001167 CD21                    	int	21h		; set DTA
 14131                                  
 14132                                  	;mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
 14133                                  	;inc	di		; ES:DI = ptr to filename field of FCB
 14134                                  	; 28/07/2024
 14135 00001169 BF5D00                  	mov	di,FCB+1 ; 5Dh
 14136 0000116C B03F                    	mov	al,'?'		; AL = wildcard character
 14137 0000116E B90B00                  	mov	cx,11
 14138 00001171 F3AA                    	rep	stosb		; wildcard filename field
 14139                                  
 14140                                  catCrunch:
 14141 00001173 E86A01                  	call	CrunchPath	; crunch pathname to get directory and filename
 14142 00001176 724B                    	jc	short catRecErr	; handle recorded or extended error
 14143                                  
 14144                                  ;	User's directory has been saved, we've changed to specified directory.
 14145                                  ;	ComSw = error bits for later use
 14146                                  ;	FCB contains parsed filename
 14147                                  
 14148                                  	;cmp	byte [COMSW],0
 14149 00001178 833E[089E]00            	cmp	word [COMSW],0
 14150 0000117D 7544                    	jne	short catRecErr	; handle recorded error
 14151                                  
 14152 0000117F E8B801                  	call	InstallCtrlC	; install control-C handler
 14153                                  
 14154                                  	; 07/06/2023
 14155                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 14156                                  	; MSDOS 6.0 (DBLSPACE/DRVSPACE)
 14157                                  
 14158                                   	;test	word [_Bits],1	; mask.cratio
 14159 00001182 F606[7CA0]01            	test	byte [_Bits],mask.cratio ; compression ratio wanted?
 14160 00001187 740A                    	jz      short catalog4
 14161 00001189 E8350A                  	call    OpenCVF         ; yes, try to open CVF file
 14162 0000118C 7305                    	jnc     short catalog4
 14163                                  
 14164                                  	;and	word [_Bits],0FFFEh ; not (mask cratio)
 14165 0000118E 8026[7CA0]FE            	and	byte [_Bits],~mask.cratio ; 0FEh
 14166                                  
 14167                                  catalog4:	; 07/06/2023
 14168 00001193 E89309                  	call	ZeroTotals	; zero grand totals
 14169 00001196 E88304                  	call	ListDir		; list main directory
 14170                                  	;jc	short catExtErr
 14171                                  	; 07/06/2023
 14172                                  	; MSDOS 6.22 COMMAND.COM
 14173 00001199 724E                    	jc      short catExtErr1
 14174                                  
 14175                                  	;;;test	Bits,mask subd
 14176                                  	;;test	word [_Bits],4
 14177                                  	;test	byte [_Bits],4
 14178                                  	; 07/06/2023
 14179 0000119B F606[7CA0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0 
 14180 000011A0 7405                    	jz	short catalog3	; subdirectories option not set
 14181 000011A2 E8AD01                  	call	ListSubds	; list subdirectories
 14182                                  	;jc	short catExtErr
 14183                                  	; 07/06/2023
 14184                                  	; MSDOS 6.22 COMMAND.COM
 14185 000011A5 7242                    	jc      short catExtErr1
 14186                                  
 14187                                  catalog3:
 14188                                  ;	Check if any files were found.
 14189                                  
 14190                                  	;;;test	Bits,mask bare
 14191                                  	;;test	word [_Bits],8
 14192                                  	;test	byte [_Bits],8
 14193                                  	; 07/06/2023
 14194 000011A7 F606[7CA0]10            	test	byte [_Bits],mask.bare ; 16 ; MSDOS 6.0
 14195 000011AC 750A                    	jnz	short catRet	; don't bother for bare format
 14196                                  
 14197 000011AE A1[239E]                	mov	ax,[FileCntTotal]
 14198 000011B1 09C0                    	or	ax,ax
 14199 000011B3 7421                    	jz	short catNoFiles ; no files found
 14200                                  
 14201 000011B5 E8D202                  	call	DisplayTotals	; display trailing grand totals
 14202                                  	;jmp	short catRet	; all done
 14203                                  	; 25/04/2023
 14204                                  	; 07/06/2023
 14205                                  catRet:
 14206                                  	;retn	; MSDOS 5.0 COMMAND.COM
 14207                                  	
 14208                                  	; 07/06/2023
 14209                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 14210                                  
 14211                                  	;test	word [_Bits],1	; mask.cratio
 14212 000011B8 F606[7CA0]01            	test	byte [_Bits],mask.cratio
 14213 000011BD 7403                    	jz      short catRetn
 14214 000011BF E81C0B                  	call    CloseCVF
 14215                                  catRetn:
 14216 000011C2 C3                      	retn
 14217                                  
 14218                                  catRecErr:
 14219                                  
 14220                                  ;	ComSw may have error bit set. If not, do extended error.
 14221                                  
 14222                                  	;;;test	ComSw,mask dev
 14223                                  	;;test	word [COMSW],1
 14224                                  	;test	byte [COMSW],1
 14225 000011C3 F606[089E]01            	test	byte [COMSW],mask.dev
 14226 000011C8 750C                    	jnz	short catNoFiles 
 14227                                  				; filename is device, respond 'file not found'
 14228                                  	;;test	ComSw,mask baddir
 14229                                  	;;test	word [COMSW],2
 14230                                  	;test	byte [COMSW],2
 14231 000011CA F606[089E]02            	test	byte [COMSW],mask.baddir
 14232                                  	;jz	short catExtErr	; no ComSw error bits, must be extended error
 14233                                  	; 07/06/2023
 14234                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM 
 14235 000011CF 7418                    	jz	short catExtErr1
 14236                                  
 14237                                  	;mov	dx,offset TRANGROUP:BadCd_Ptr
 14238                                  				; invalid directory
 14239 000011D1 BA[0B93]                	mov	dx,badcd_ptr
 14240                                  	;jmp	short catErr
 14241                                  	; 07/06/2023
 14242                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 14243 000011D4 EB23                    	jmp	short catExtErr2	
 14244                                  
 14245                                  catNoFiles:
 14246                                  
 14247                                  ;	Display header and force 'file not found' message.
 14248                                  
 14249 000011D6 E89A07                  	call	DisplayHeader
 14250 000011D9 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 14251 000011DC C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 14252 000011E1 BA[D091]                	mov	dx,extend_buf_ptr
 14253 000011E4 A3[D091]                	mov	[extend_buf_ptr],ax
 14254                                  	;jmp	short catErr
 14255                                  	; 07/06/2023
 14256                                  	; MSDOS 6.22 COMMAND.COM
 14257 000011E7 EB10                    	jmp	short catExtErr2
 14258                                  
 14259                                  catExtErr:	; Retro DOS v4.0 (MSDOS 5.0) COMMAND.COM
 14260                                  	; 07/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 14261                                  catExtErr1:
 14262                                  
 14263                                  ;	DOS has returned an error status. Get the extended error#, and
 14264                                  ;	set up an error message, changing 'No more files' error 
 14265                                  ;	to 'File not found' error.
 14266                                  
 14267 000011E9 E84610                  	call	Set_Ext_Error_Msg
 14268 000011EC 833E[D091]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 14269                                  	;jne	short catalog4  ; catErr ; MSDOS 5.0 COMMAND.COM
 14270                                  	; 07/06/2023
 14271                                  	; MSDOS 6.22 COMMAND.COM
 14272 000011F1 7506                    	jne	short catExtErr2	
 14273                                  
 14274 000011F3 C706[D091]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 14275                                  
 14276                                  ;catalog4:	; Retro DOS v4.0 (MSDOS 5.0) COMMAND.COM
 14277                                  	; 07/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 14278                                  catExtErr2:
 14279                                  	;test	word [_Bits],1	; mask.cratio
 14280 000011F9 F606[7CA0]01            	test	byte [_Bits],mask.cratio
 14281                                  				; close Compressed Volume File if cratio
 14282 000011FE 7403                    	jz      short catErr
 14283 00001200 E8DB0A                  	call    CloseCVF
 14284                                  
 14285                                  ;	Error exit. Error message information has been set up
 14286                                  ;	for Std_EPrintf.
 14287                                  
 14288                                  catErr:
 14289 00001203 E99C1C                  	jmp	cerror		; go to COMMAND error recycle point
 14290                                  
 14291                                  	; 25/04/2023
 14292                                  ;catRet:
 14293                                  	;retn
 14294                                  
 14295                                  ; ---------------------------------------------------------------------------
 14296                                  
 14297                                  ;***	SetDefaults - set default pathname, options
 14298                                  ;
 14299                                  ;	ENTRY	DS = TRANGROUP seg addr
 14300                                  ;
 14301                                  ;	EXIT	nothing
 14302                                  ;
 14303                                  ;	USED	AX,DI
 14304                                  ;
 14305                                  ;	EFFECTS
 14306                                  ;	  SrcBuf = '*',EOL - default pathname
 14307                                  ;	  PathPos = ptr to pathname
 14308                                  ;	  PathCnt = length of pathname
 14309                                  
 14310                                  	; 16/02/2023
 14311                                  SetDefaults:
 14312 00001206 BF[12A1]                	mov	di,SrcBuf		; DI = ptr to pathname buffer
 14313 00001209 893E[80A0]              	mov	[PathPos],di		; PathPos = ptr to pathname
 14314                                  	;mov	al,STAR
 14315 0000120D B02A                    	mov	al,'*'
 14316 0000120F AA                      	stosb
 14317                                  	;mov	al,END_OF_LINE_IN
 14318 00001210 B00D                    	mov	al,0Dh ; cr
 14319 00001212 AA                      	stosb				; SrcBuf = '*',0Dh
 14320 00001213 C706[7EA0]0100          	mov	word [PathCnt],1	; PathCnt = pathname length
 14321                                  
 14322 00001219 31C0                    	xor	ax,ax			; AX = 0
 14323 0000121B A3[089E]                	mov	[COMSW],ax		; = no error
 14324 0000121E A3[7CA0]                	mov	[_Bits],ax		; = options off
 14325 00001221 A2[AFA0]                	mov	[DestBuf],al		; = no sort
 14326 00001224 C606[84A0]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
 14327 00001229 A2[85A0]                	mov	[AttrSelect],al		; exclude hidden, system files
 14328                                  peRet:	; 25/04/2023
 14329 0000122C C3                      	retn
 14330                                  
 14331                                  ; ---------------------------------------------------------------------------
 14332                                  
 14333                                  ;***	ParseEnvironment - find and parse our environment variable
 14334                                  ;
 14335                                  ;	Find our environment variable and parse it. If a parse
 14336                                  ;	error occurs, issue an error message. The parse results
 14337                                  ;	up to the error will still have effect. Always leave
 14338                                  ;	the option variables in a useable state.
 14339                                  ;
 14340                                  ;	ENTRY	DS = TRANGROUP seg addr
 14341                                  ;
 14342                                  ;	EXIT	nothing
 14343                                  ;
 14344                                  ;	USED	AX,BX,CX,DX,SI,DI
 14345                                  ;
 14346                                  ;	EFFECTS
 14347                                  ;
 14348                                  ;	  Bits may contain new option settings.
 14349                                  ;	  DestBuf may contain new series of sort codes.
 14350                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 14351                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14352                                  ;	  PathPos, PathCnt updated for new pathname.
 14353                                  ;
 14354                                  ;	  If a parse error occurred, an error message will be issued.
 14355                                  
 14356                                  	; 16/02/2023
 14357                                  ParseEnvironment:
 14358 0000122D E8A203                  	call	GetEnvValue		; get environment variable value
 14359 00001230 72FA                    	jc	short peRet		; name not found in environment
 14360                                  
 14361                                  ;	SI = ptr to value of environment variable, in TRANGROUP seg
 14362                                  
 14363 00001232 E80E05                  	call	Parse_Line		; parse environment value
 14364 00001235 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14365                                  	;cmp	ax,END_OF_LINE
 14366 00001238 74F2                    	je	short peRet		; successful completion
 14367                                  
 14368                                  ;	Some kind of parse error occurred.
 14369                                  ;	We're set up for a Std_EPrintf call.
 14370                                  
 14371 0000123A E8CA42                  	call	std_eprintf		; display the parse error
 14372                                  	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
 14373                                  					; restore default msg class
 14374 0000123D C606[CE91]FF            	mov	byte [msg_disp_class],0FFh ; -1
 14375                                  	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
 14376 00001242 BA[1294]                	mov	dx,errparsenv_ptr
 14377                                  	;;invoke Printf_Crlf		; "(Error occurred in environment.."
 14378                                  	;call	Printf_Crlf
 14379                                  	; 25/04/2023
 14380                                  	;retn
 14381 00001245 E9B942                  	jmp	Printf_Crlf
 14382                                  					;M008;Internal handling of /? removed
 14383                                  ;peOk:	and	Bits,not mask help	; disallow /h in environment variable
 14384                                  	; 25/04/2023
 14385                                  ;peRet:
 14386                                  	;retn
 14387                                  
 14388                                  ; ---------------------------------------------------------------------------
 14389                                  
 14390                                  ;***	ParseCmdLine - parse and record command line parameters
 14391                                  ;
 14392                                  ;	ENTRY	PSP offset 81h is beginning of cmd line buffer
 14393                                  ;		DS, ES, CS = TRANGROUP seg addr
 14394                                  ;
 14395                                  ;	EXIT	CY = set if parse error occurred
 14396                                  ;
 14397                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 14398                                  ;		AX = system parser error code
 14399                                  ;		DX = ptr to message block
 14400                                  ;
 14401                                  ;	USED	AX,BX,CX,DX,SI,DI
 14402                                  ;
 14403                                  ;	EFFECTS
 14404                                  ;
 14405                                  ;	  Bits may contain new option settings.
 14406                                  ;	  DestBuf may contain new series of sort codes.
 14407                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 14408                                  ;	  SrcBuf may contain a new default pathname/filespec.
 14409                                  ;	  PathPos, PathCnt updated for new pathname.
 14410                                  ;
 14411                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 14412                                  ;	  Msg_Disp_Class = parse error class
 14413                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 14414                                  ;	  Message block (see DX) is set up for parse error message
 14415                                  
 14416                                  	; 16/02/2023
 14417                                  ParseCmdLine:
 14418 00001248 BE8100                  	mov	si,81h			; SI = ptr to cmd-line tail text
 14419 0000124B E8F504                  	call	Parse_Line		; parse cmd line tail
 14420 0000124E 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 14421                                  	;;cmp	ax,END_OF_LINE
 14422                                  	; 25/04/2023
 14423                                  	;je	short pcOk		; parse completed successfully
 14424                                  
 14425                                  ;	A parse error occurred. We're all set up for message output.
 14426                                  
 14427                                  	; 25/04/2023
 14428                                  	; cf = 1 (ax < 0FFFFh)
 14429                                  	;stc		   		; return failure
 14430                                  	;jmp	short pcRet
 14431                                  	; 25/04/2023
 14432                                  	;retn
 14433                                  pcOk:
 14434                                  	; 25/04/2023
 14435                                  	;cf = 0 (ax = 0FFFFh)
 14436                                  	;clc				; return success
 14437                                  pcRet:
 14438 00001251 C3                      	retn
 14439                                  
 14440                                  ; ---------------------------------------------------------------------------
 14441                                  
 14442                                  ;***	SetCollatingTable - set up character collating table for sorting
 14443                                  ;
 14444                                  ;	If country is other than USA, try to get a collating table
 14445                                  ;	for character sorting. For USA, use straight byte values.
 14446                                  ;	This is so DIR behaves like the MS-DOS Shell, which sorts
 14447                                  ;	by straight byte values in the USA for better performance.
 14448                                  ;
 14449                                  ;	ENTRY	ES = TRANGROUP seg addr
 14450                                  ;
 14451                                  ;	EXIT	nothing
 14452                                  ;
 14453                                  ;	USED	AX,BX,CX,DX,DI
 14454                                  ;
 14455                                  ;	EFFECTS
 14456                                  ;
 14457                                  ;	  If collating table is set -
 14458                                  ;	    CountryPtrId = 6.
 14459                                  ;	    CountryPtr points to collating table.
 14460                                  ;
 14461                                  ;	  Otherwise -
 14462                                  ;	    CountryPtrId = 0.
 14463                                  
 14464                                  SetCollatingTable:
 14465                                  
 14466                                  ;	Begin modification M028
 14467                                  
 14468                                  	;mov	dx,offset TRANGROUP:InternatVars
 14469                                  	;			; DS:DX = ptr to international info buffer
 14470 00001252 BA[90A9]                	mov	dx,INTERNATVARS
 14471 00001255 B80038                  	mov	ax,3800h
 14472                                  	;mov	ax,INTERNATIONAL << 8
 14473                                  	;;mov	ax,INTERNATIONAL shl 8
 14474                                  				; AX = 'Get current country info'
 14475 00001258 CD21                    	int	21h		; call DOS
 14476 0000125A 7217                    	jc	short scNoTable	; error - so don't collate
 14477                                  
 14478                                  ;	BX = country code
 14479                                  
 14480 0000125C 83FB01                  	cmp	bx,1
 14481 0000125F 7412                    	je	short scNoTable	; we're in USA, don't collate
 14482                                  
 14483                                  ;	End modification M028
 14484                                  
 14485                                  ;*	Country code is other than USA. Try to get a collating table.
 14486                                  
 14487 00001261 B80665                  	mov	ax,6506h
 14488                                  	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
 14489                                  	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
 14490                                  				; AH = 'Get Extended Country Info'
 14491                                  				; AL = 'Get Pointer to Collating Table'
 14492 00001264 BBFFFF                  	mov	bx,-1		; BX = code page of interest = CON
 14493 00001267 B90500                  	mov	cx,5		; CX = length of info buffer
 14494 0000126A 89DA                    	mov	dx,bx		; DX = country ID = default
 14495                                  	;mov	di,offset TRANGROUP:CountryPtrInfo
 14496 0000126C BF[B0A9]                	mov	di,CountryPtrInfo
 14497                                  				; ES:DI = ptr to info buffer
 14498 0000126F CD21                    	int	21h		; call DOS
 14499 00001271 7305                    	jnc	short scRet	; success
 14500                                  
 14501                                  ;*	Set CountryPtrId = 0 to signal no collating table.
 14502                                  
 14503                                  scNoTable:			;M028
 14504 00001273 C606[B0A9]00            	mov	byte [CountryPtrId],0
 14505                                  scRet:
 14506 00001278 C3                      	retn
 14507                                  
 14508                                  ; ---------------------------------------------------------------------------
 14509                                  
 14510                                  ;***	SetOptions - check and set options
 14511                                  ;
 14512                                  ;	ENTRY	nothing
 14513                                  ;
 14514                                  ;	EXIT	nothing
 14515                                  ;
 14516                                  ;	USED	AX,BX,CX,DX
 14517                                  ;
 14518                                  ;	EFFECTS
 14519                                  ;
 14520                                  ;	  Bits may contain modified option settings.
 14521                                  ;	  Display_Ioctl table, including LinPerPag variable, is filled in.
 14522                                  ;	  LeftOnPage is initialized to # lines till end of page is handled.
 14523                                  ;	  PerLine is set according to /w presence.
 14524                                  
 14525                                  	; 16/02/2023
 14526                                  
 14527                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 14528                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:12BEh
 14529                                  
 14530                                  SetOptions:
 14531                                  
 14532                                  ;	If bare listing requested, cancel wide listings.
 14533                                  
 14534                                  	;;;test	Bits,mask bare
 14535                                  	;;test	word [_Bits],8
 14536                                  	;test	byte [_Bits],8
 14537                                  	; 07/06/2023
 14538 00001279 F606[7CA0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 14539 0000127E 7411                    	jz	short setopts1
 14540                                  	;;;and	Bits,not mask wide	;M007;Allow /p with /b
 14541                                  	;;and	word [_Bits],0FFFEh
 14542                                  	;;and	byte [_Bits],0FEh
 14543                                  	; 07/06/2023
 14544 00001280 8026[7CA0]FD            	and	byte [_Bits],~mask.wide ; 0FDh ; MSDOS 6.0
 14545                                  
 14546                                  ;setopts1:	; MSDOS 5.0 COMMAND.COM
 14547                                  	; 07/06/2023
 14548                                   	; MSDOS 6.22 COMMAND.COM
 14549                                  setopts0:
 14550                                  	;test	word [_Bits],12h  ; (mask bare) or (mask wide)
 14551 00001285 F606[7CA0]12            	test	byte [_Bits],(mask.bare|mask.wide)
 14552 0000128A 7405                    	jz      short setopts1
 14553                                  	;and 	word [_Bits],0FFFEh ; not mask cratio
 14554 0000128C 8026[7CA0]FE            	and	byte [_Bits],~mask.cratio
 14555                                  
 14556                                  setopts1:
 14557                                  ;	Set # lines per display page.
 14558                                  
 14559                                  ;M01  Obtain screen height from ROM BIOS data area
 14560                                  ;
 14561                                  ;M01	mov	LinPerPag,LINESPERPAGE	; default value
 14562                                  
 14563 00001291 1E                      	push	ds
 14564                                  	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
 14565 00001292 B84000                  	mov	ax,40h
 14566 00001295 8ED8                    	mov	ds,ax			;
 14567                                  	;Assume	DS:ROMBIOS_DATA
 14568                                  
 14569                                  	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
 14570 00001297 A08400                  	mov	al,[84h]
 14571 0000129A 1F                      	pop	ds			;
 14572                                  	;Assume	DS:Trangroup
 14573                                  
 14574 0000129B 08C0                    	or	al,al			; If zero specified
 14575 0000129D 7502                    	jnz	short setopts2		;
 14576                                  
 14577                                  	;mov	al,LINESPERPAGE 	; assume 24 rows
 14578 0000129F B019                    	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
 14579                                  setopts2:
 14580 000012A1 30E4                    	xor	ah,ah
 14581                                  setopts3:
 14582 000012A3 FEC0                    	inc	al			; height + 1 ;M018
 14583                                  
 14584 000012A5 A3[08A2]                	mov	[LinPerPag],ax		; set the rows now
 14585                                  
 14586                                  ; Now the console driver can change the rows if it knows better (M01 end)
 14587                                  
 14588                                  	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE
 14589                                  					; IOCTL for handles
 14590 000012A8 B80C44                  	mov	ax,440Ch
 14591                                  	;mov	bx,STDOUT		; handle #
 14592 000012AB BB0100                  	mov	bx,1
 14593                                  	;mov	ch,IOC_SC		; screen
 14594 000012AE B503                    	mov	ch,3
 14595                                  	;mov	cl,get_generic		; get display info
 14596 000012B0 B17F                    	mov	cl,7Fh
 14597 000012B2 BA[F8A1]                	mov	dx,Display_Ioctl	; info block
 14598 000012B5 CD21                    	int	21h			; call DOS
 14599                                  
 14600 000012B7 A1[08A2]                	mov	ax,[LinPerPag]		; AX = # lines per page
 14601 000012BA A3[1B9E]                	mov	[LeftOnPage],ax		; initialize # lines left on page
 14602                                  
 14603                                  ;	Set # entries per line.
 14604                                  
 14605                                  	;mov	byte [PerLine],NORMPERLIN
 14606                                  					; # entries per line without /w
 14607 000012BD C606[1A9E]01            	mov	byte [PerLine],1
 14608                                  	;;;test	Bits,mask wide
 14609                                  	;;test	word [_Bits],1
 14610                                  	;test	byte [_Bits],1
 14611                                  	; 07/06/2023
 14612 000012C2 F606[7CA0]02            	test	byte [_Bits],mask.wide ; 2 ; MSDOS 6.0
 14613 000012C7 7405                    	jz	short setopts4
 14614                                  	;mov	byte [PerLine],WIDEPERLIN
 14615                                  					; # entries per line with /w
 14616 000012C9 C606[1A9E]05            	mov	byte [PerLine],5
 14617                                  setopts4:
 14618                                  				;M011;start;The following code checks if a drive
 14619                                  				;letter has been parsed into SrcBuf, and if
 14620                                  				;so, the correct drive number is loaded into
 14621                                  				;the first FCB, at offset 5C.
 14622                                  
 14623                                  	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
 14624 000012CE 803E[13A1]3A            	cmp	byte [SrcBuf+1],':'
 14625 000012D3 750A                    	jne	short soRet
 14626                                  	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
 14627 000012D5 A0[12A1]                	mov	al,[SrcBuf]
 14628                                  	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
 14629 000012D8 24DF                    	and	al,0DFh ; ~20h ; not 20h
 14630 000012DA 2C40                    	sub	al,'@'	; 40h			; convert to 1-based number (1=A)
 14631 000012DC A25C00                  	mov	[FCB],al  ; [5Ch]		; store in first FCB
 14632                                  						;M011;end
 14633                                  soRet:
 14634 000012DF C3                      	retn
 14635                                  
 14636                                  ; ---------------------------------------------------------------------------
 14637                                  
 14638                                  ;***	CrunchPath - analyze supplied or default pathname
 14639                                  ;
 14640                                  ;	ENTRY	PathPos = ptr to pathname buffer
 14641                                  ;		PathCnt = length of pathname, not incl trailing delimiter
 14642                                  ;		Pathname in buffer must end in delimiter (like CR) and
 14643                                  ;		 must have space for another char after the delimiter.
 14644                                  ;
 14645                                  ;	EXIT	CY = clear if no error
 14646                                  ;		We are changed to directory found in pathname
 14647                                  ;		Previous directory ready to be restored via RestUDir
 14648                                  ;		FCB filename fields contain filename (possibly w/ wildcards)
 14649                                  ;
 14650                                  ;		If error occurred,
 14651                                  ;		CY = set
 14652                                  ;		ComSw = error bits (see ErrorRec)
 14653                                  ;		If ComSw not set,
 14654                                  ;		Ready for DOS Get Extended Error call
 14655                                  
 14656                                  	; 16/02/2023
 14657                                  CrunchPath:
 14658 000012E0 E80102                  	call	FileIsDevice
 14659 000012E3 7507                    	jne	short crpath1	; not a device, skip ahead
 14660                                  	;;;or	ComSw,mask dev	; signal file is device
 14661                                  	;;or	word [COMSW],1
 14662                                  	;or	byte [COMSW],1
 14663 000012E5 800E[089E]01            	or	byte [COMSW],mask.dev
 14664 000012EA EB2F                    	jmp	short cpErr	; return error
 14665                                  crpath1:
 14666 000012EC FF36[80A0]              	push	word [PathPos]	; save ptr to pathname
 14667 000012F0 C606[88A0]FF            	mov	byte [DirFlag],-1
 14668                                  				; tell PathCrunch not to parse file into FCB
 14669 000012F5 E8D218                  	call	PathCrunch	; change to directory in pathname
 14670 000012F8 C606[88A0]00            	mov	byte [DirFlag],0
 14671                                  				; reset our little flag
 14672 000012FD 5E                      	pop	si		; SI = ptr to pathname
 14673 000012FE 7208                    	jc	short cpNoDir	; didn't find directory path
 14674 00001300 741A                    	jz	short cpRet	; found directory path w/ no filename
 14675                                  				;  - leave wildcard default in FCB and return
 14676                                  
 14677                                  ;*	We found a directory, and there was a filename attached.
 14678                                  ;	DestTail = ptr to ASCIIZ filename
 14679                                  
 14680 00001302 8B36[ACA0]              	mov	si,[DestTail]	; SI = ptr to filename
 14681 00001306 EB28                    	jmp	short cpFile	; go parse the file into FCB
 14682                                  
 14683                                  ;*	PathCrunch failed to find a directory in the pathname.
 14684                                  ;
 14685                                  ;	Msg_Numb = error code
 14686                                  ;	DestIsDir = nonzero if path delimiter char's occur in pathname
 14687                                  ;	SI = ptr to pathname (now an ASCIIZ string)
 14688                                  
 14689                                  cpNoDir:
 14690 00001308 A1[25A2]                	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
 14691 0000130B 09C0                    	or	ax,ax
 14692 0000130D 750C                    	jnz	short cpErr	  ; error occurred - return it
 14693 0000130F 803E[AAA0]00            	cmp	byte [DestIsDir],0
 14694 00001314 7407                    	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
 14695                                  crpath3:
 14696                                  	;;;or	ComSw,mask baddir ; signal invalid directory name
 14697                                  	;;or	word [COMSW],2
 14698                                  	;or	byte [COMSW],2
 14699 00001316 800E[089E]02            	or	byte [COMSW],mask.baddir
 14700                                  	;jmp	short cpErr	  ; return error
 14701                                  	; 16/02/2023
 14702                                  cpErr:
 14703 0000131B F9                      	stc			  ; return error
 14704                                  cpRet:
 14705 0000131C C3                      	retn
 14706                                  
 14707                                  cpMaybe:
 14708                                  ;	SI = ptr to pathname
 14709                                  
 14710                                  	;cmp	byte [si+1],COLON_CHAR
 14711 0000131D 807C013A                	cmp	byte [si+1],':'
 14712 00001321 7501                    	jne	short crpath2	  ; no drive specifier, skip ahead
 14713 00001323 AD                      	lodsw			  ; SI = ptr past drive specifier "d:"
 14714                                  crpath2:
 14715 00001324 813C2E2E                	cmp	word [si],".."
 14716 00001328 7506                    	jne	short cpFile	  ; if not "..", treat as a file
 14717 0000132A 807C0200                	cmp	byte [si+2],0
 14718                                  	;jne	short cpFile	  ; or if there's more after "..", treat as file
 14719                                  	;;;;or	ComSw,mask baddir ; signal invalid directory
 14720                                  	;;;or	word [COMSW],2
 14721                                  	;;or	byte [COMSW],2
 14722                                  	;or	byte [COMSW],mask.baddir
 14723                                  	;jmp	short cpErr	  ; return error
 14724                                  	; 16/02/2023
 14725 0000132E 74E6                    	je	short crpath3
 14726                                  
 14727                                  ;	The preceding code was taken from the old DIR routine.
 14728                                  ;	It's garbage, I'm afraid. It's meant to check for ".."
 14729                                  ;	occurring when we're at the root directory. Too bad it
 14730                                  ;	doesn't handle problems with "..\..", etc.
 14731                                  
 14732                                  ;	We're ready to parse a filename into the FCB.
 14733                                  ;	SI = ptr to ASCIIZ filename
 14734                                  
 14735                                  cpFile:	
 14736 00001330 BF5C00                  	mov	di,FCB	; 5Ch	; DI = ptr to FCB
 14737 00001333 B80E29                  	mov	ax,290Eh
 14738                                  	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
 14739                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
 14740                                  				; wildcards already in FCB used as defaults
 14741 00001336 CD21                    	int	21h
 14742 00001338 F8                      	clc			; return success
 14743                                  	;jmp	short cpRet
 14744                                  	; 16/02/2023
 14745 00001339 C3                      	retn
 14746                                  
 14747                                  ;cpErr:
 14748                                  ;	stc			; return error
 14749                                  ;cpRet:
 14750                                  ;	retn
 14751                                  
 14752                                  ; ---------------------------------------------------------------------------
 14753                                  
 14754                                  ;***	InstallCtrlC - install our private control-C handler
 14755                                  ;
 14756                                  ;	Put our control-c handler in front of command.com's default
 14757                                  ;	handler, to make sure the user's default directory gets restored.
 14758                                  ;	This shouldn't be necessary, but, for now, there are situations
 14759                                  ;	where the TDATA segment is left in a modified state when a
 14760                                  ;	control-c occurs.  This means that the transient will be
 14761                                  ;	reloaded, and the user's directory cannot be restored.
 14762                                  ;
 14763                                  ;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
 14764                                  ;
 14765                                  ;	ENTRY	nothing
 14766                                  ;
 14767                                  ;	EXIT	nothing
 14768                                  ;
 14769                                  ;	USED	AX,BX,DX
 14770                                  ;
 14771                                  ;	EFFECTS
 14772                                  ;
 14773                                  ;	  CtrlCHandler address placed in int 23 vector.
 14774                                  ;
 14775                                  ;	NOTE
 14776                                  ;
 14777                                  ;	  Command.com's basic control-c handler will be restored
 14778                                  ;	  to the int 23 vector by the HeadFix routine, after DIR finishes.
 14779                                  
 14780                                  	; 16/02/2023
 14781                                  InstallCtrlC:
 14782 0000133A 06                      	push	es			; preserve ES
 14783 0000133B B82335                  	mov	ax,3523h
 14784                                  	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
 14785                                  	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
 14786 0000133E CD21                    	int	21h
 14787 00001340 891E[B5A9]              	mov	[OldCtrlCHandler],bx	; save old int 23 vector
 14788 00001344 8C06[B7A9]              	mov	[OldCtrlCHandler+2],es	 
 14789 00001348 07                      	pop	es			; restore ES
 14790                                  
 14791 00001349 BA[341B]                	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
 14792 0000134C B82325                  	mov	ax,2523h
 14793                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
 14794                                  	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
 14795 0000134F CD21                    	int	21h
 14796 00001351 C3                      	retn
 14797                                  
 14798                                  ; ---------------------------------------------------------------------------
 14799                                  
 14800                                  ;***	ListSubds - search and list files in subdirectories
 14801                                  ;
 14802                                  ;	ENTRY	Current directory (on selected drive) is top of subdir tree
 14803                                  ;		FCB is still set up for file searches
 14804                                  ;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
 14805                                  ;
 14806                                  ;	EXIT	CY = clear if no error
 14807                                  ;		FileCnt = # files found & displayed
 14808                                  ;		FileSiz = total size of files found
 14809                                  ;
 14810                                  ;		If error,
 14811                                  ;		CY = set
 14812                                  ;		Ready for DOS Get Extended Error call
 14813                                  ;
 14814                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14815                                  ;
 14816                                  ;	EFFECTS
 14817                                  ;
 14818                                  ;	  FileCntTotal, FileSizTotal are updated.
 14819                                  ;	  Subdirectories may be listed on standard output device.
 14820                                  ;
 14821                                  ;	NOTES
 14822                                  ;
 14823                                  ;	  ListSubds seeds the recursive entry point lsNode with a ptr
 14824                                  ;	   to a buffer where we'll stack up subdirectory filenames.
 14825                                  ;	   Each name is stored ASCIIZ.
 14826                                  
 14827                                  	; 16/02/2023
 14828                                  ListSubds:
 14829                                  	;invoke	SetRest1		; make sure user's dir gets restored
 14830 00001352 E8DC1E                  	call	SetRest1
 14831                                  
 14832 00001355 BB[6CA1]                	mov	bx,ScanBuf   		; BX = ptr to child name buffer
 14833                                  lsNode:
 14834 00001358 C60700                  	mov	byte [bx],0		; start with null child name
 14835                                  lsLoop:
 14836 0000135B E81002                  	call	FindNextChild		; search for next subdirectory
 14837 0000135E 7235                    	jc	short lsErr		; search failed - examine error
 14838                                  
 14839 00001360 89DA                    	mov	dx,bx			; DX = ptr to child's name
 14840 00001362 E8A904                  	call	ChangeDir		; enter child directory
 14841                                  
 14842                                  					; M023;start
 14843 00001365 7306                    	jnc	short lstsd1		; check for error
 14844                                  	;cmp	ax,3
 14845 00001367 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
 14846 0000136A 74EF                    	je	short lsLoop		; yes, skip over this subdirectory
 14847                                  	;jmp	short lsRet		; no, other error: DIR must fail
 14848                                  	; 16/02/2023			; M023;end
 14849 0000136C C3                      	retn
 14850                                  lstsd1:	
 14851 0000136D 53                      	push	bx
 14852 0000136E E8AB02                  	call	ListDir			; list the directory
 14853 00001371 5B                      	pop	bx
 14854                                  
 14855                                  ;	Note we're ignoring errors returned here.
 14856                                  
 14857 00001372 89DF                    	mov	di,bx			; DI = ptr to child's name
 14858 00001374 B90D00                  	mov	cx,13			; CX = max name length w/ null
 14859 00001377 30C0                    	xor	al,al			; AL = zero byte to look for
 14860 00001379 F2AE                    	repne	scasb			; DI = ptr to next name pos'n in buf
 14861 0000137B 53                      	push	bx			; save ptr to child's name
 14862 0000137C 89FB                    	mov	bx,di			; BX = ptr to next name pos'n in buf
 14863 0000137E E8D7FF                  	call	lsNode			; recurse from new node
 14864 00001381 5B                      	pop	bx			; BX = ptr to child's name
 14865 00001382 9C                      	pushf				; save error condition
 14866                                  	
 14867                                  	;;shove	0
 14868                                  	;mov	ax,0
 14869 00001383 29C0                    	sub	ax,ax ; 0
 14870 00001385 50                      	push	ax
 14871                                  	;shove	".."
 14872 00001386 B82E2E                  	mov	ax,'..'  ; 2E2Eh
 14873 00001389 50                      	push	ax
 14874 0000138A 89E2                    	mov	dx,sp			; DX = ptr to "..",0 on stack
 14875 0000138C E87F04                  	call	ChangeDir		; return to parent directory
 14876 0000138F 58                      	pop	ax			; restore stack
 14877 00001390 58                      	pop	ax
 14878                                  
 14879 00001391 9D                      	popf				; restore error condition from child
 14880                                  	;jc	short lsRet		; return error
 14881                                  	;jmp	short lsLoop		; look for more children
 14882                                  	; 16/02/2023
 14883 00001392 73C7                    	jnc	short lsLoop
 14884 00001394 C3                      	retn
 14885                                  lsErr:
 14886 00001395 E8AA0E                  	call	get_ext_error_number	; AX = extended error code
 14887                                  	;cmp	ax,2
 14888 00001398 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 14889 0000139B 7406                    	je	short lsRet		; file not found, we're ok
 14890                                  	;cmp	ax,18
 14891 0000139D 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 14892 000013A0 7401                    	je	short lsRet		; no more files, we're ok
 14893 000013A2 F9                      	stc				; return other errors
 14894                                  lsRet:	
 14895 000013A3 C3                      	retn
 14896                                  
 14897                                  ; ---------------------------------------------------------------------------
 14898                                  
 14899                                  	;break	<DIR support routines>
 14900                                  
 14901                                  ;***	SUPPORT ROUTINES
 14902                                  
 14903                                  ; ----------------------
 14904                                  
 14905                                  ;***	CheckChild - check potential subdirectory name for FindNextChild
 14906                                  ;
 14907                                  ;	ENTRY	DirBuf contains DOS Find-buffer with potential child
 14908                                  ;		BX = ptr to last child's name
 14909                                  ;		BP = ptr to temp child's name
 14910                                  ;
 14911                                  ;	EXIT	nothing
 14912                                  ;
 14913                                  ;	USED	AX,CX,SI,DI
 14914                                  ;
 14915                                  ;	EFFECTS
 14916                                  ;
 14917                                  ;	  Filename pointed to by BP may be changed.
 14918                                  ;
 14919                                  ;	NOTES
 14920                                  ;
 14921                                  ;	  Potential filename replaces temp filename if:
 14922                                  ;	   it's a subdirectory file;
 14923                                  ;	   it doesn't start with a '.';
 14924                                  ;	   it's alphanumerically greater than last child's name;
 14925                                  ;	   and it's alphanumerically less than temp name.
 14926                                  
 14927                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14928                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 14929                                  CheckChild:
 14930                                  	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
 14931 000013A4 F606[3FA0]10            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
 14932 000013A9 741D                    	jz	short ccRet	; not a subdirectory file- return
 14933                                  
 14934                                  	; 16/02/2023
 14935 000013AB BE[48A0]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14936 000013AE 803C2E                  	cmp	byte [si],'.'
 14937                                  	;;cmp	DirBuf.find_buf_pname,'.'
 14938                                  	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
 14939 000013B1 7415                    	je	short ccRet	; starts with a dot- return
 14940                                  
 14941                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14942                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14943 000013B3 89DF                    	mov	di,bx
 14944 000013B5 E86D04                  	call	CmpAscz		; compare candidate to last child's name
 14945 000013B8 760E                    	jna	short ccRet	; it's not above it- return
 14946                                  
 14947                                  	; 07/06/2023
 14948                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14949                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14950                                  	; si = DIRBUF+FIND_BUF.PNAME
 14951 000013BA 89EF                    	mov	di,bp
 14952 000013BC E86604                  	call	CmpAscz		; compare candidate to temp name
 14953 000013BF 7307                    	jnb	short ccRet	; it's not below it- return
 14954                                  
 14955                                  ;	New kid is alright. Copy to temp.
 14956                                  
 14957                                  	; 07/06/2023
 14958                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14959                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14960                                  	; si = DIRBUF+FIND_BUF.PNAME
 14961 000013C1 89EF                    	mov	di,bp
 14962 000013C3 B90D00                  	mov	cx,13
 14963 000013C6 F3A4                    	rep	movsb
 14964                                  ccRet:
 14965 000013C8 C3                      	retn
 14966                                  
 14967                                  ; ---------------------------------------------------------------------------
 14968                                  
 14969                                  ;***	CmpEntry - compare one directory entry to another in sort order
 14970                                  ;
 14971                                  ;	Compare one directory entry against another according to
 14972                                  ;	the sort codes in DestBuf. One or more comparisons
 14973                                  ;	may be made of file name, extension, time/date, and
 14974                                  ;	size.  Comparisons may be made for upward or downward
 14975                                  ;	sort order.
 14976                                  ;
 14977                                  ;	ENTRY	ES:BX = ptr to entry to compare
 14978                                  ;		ES:BP = ptr to entry to be compared against
 14979                                  ;		DestBuf contains sort codes (see DestBuf)
 14980                                  ;		DS = TRANGROUP seg addr
 14981                                  ;
 14982                                  ;	EXIT	BX = unchanged
 14983                                  ;		BP = unchanged
 14984                                  ;		Condition flags set for same, above, or below
 14985                                  ;		 comparing BX entry against BP entry.
 14986                                  ;		 'Same, above, below' translate to 'same, after, before'.
 14987                                  ;
 14988                                  ;	USED:	AX,CX,DX,SI,DI
 14989                                  
 14990                                  	; 16/02/2023
 14991                                  CmpEntry:
 14992 000013C9 BE[AFA0]                	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
 14993                                  ceLoop:
 14994 000013CC 31C0                    	xor	ax,ax		; AX = 0
 14995 000013CE 8A04                    	mov	al,[si]		; AL = sort code
 14996 000013D0 08C0                    	or	al,al
 14997 000013D2 741C                    	jz	short ceDone	; sort code is zero, we're done
 14998 000013D4 46                      	inc	si		; DS:SI = ptr to next sort code
 14999 000013D5 56                      	push	si		; save ptr to next sort code
 15000 000013D6 FEC8                    	dec	al
 15001 000013D8 D0E0                    	shl	al,1
 15002                                  	;sal	al,1		; AX = index into cmp call table
 15003                                  				; CY set for downward sort order
 15004 000013DA 89C6                    	mov	si,ax		; SI = index into cmp call table
 15005 000013DC 2E8B84[F113]            	mov	ax,[cs:si+FieldCmps]
 15006                                  				; AX = addr of compare routine
 15007 000013E1 7204                    	jc	short ceDn	; downwards sort - go swap entries
 15008 000013E3 FFD0                    	call	ax 		; do upwards sort
 15009 000013E5 EB06                    	jmp	short ceNs
 15010                                  ceDn:
 15011 000013E7 87DD                    	xchg	bx,bp		; swap entry ptrs for downward sort order
 15012 000013E9 FFD0                    	call	ax		; do sort
 15013 000013EB 87DD                    	xchg	bx,bp		; swap ptrs back
 15014                                  ceNs:
 15015 000013ED 5E                      	pop	si		; SI = ptr to next sort code
 15016 000013EE 74DC                    	je	short ceLoop	; compare showed no difference, keep trying
 15017                                  ceDone:
 15018                                  
 15019                                  ;	Get here either from unequal compare or sort code = 0.
 15020                                  ;	In the latter case, condition codes indicate equality,
 15021                                  ;	which is correct.
 15022                                  
 15023 000013F0 C3                      	retn
 15024                                  
 15025                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15026                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)
 15027                                  
 15028                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 15029                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:144Eh)
 15030                                  
 15031                                  FieldCmps:		; call table of entry comparisons
 15032 000013F1 [FD13]                  	dw	CmpName
 15033 000013F3 [0814]                  	dw	CmpExt
 15034 000013F5 [4614]                  	dw	CmpTime
 15035 000013F7 [6214]                  	dw	CmpSize
 15036 000013F9 [6714]                  	dw	CmpType
 15037                                  	; 05/06/2023 - Retro DOS 4.2 COMMAND.COM
 15038 000013FB [7514]                  	dw	CmpCratio
 15039                                  
 15040                                  ; ---------------------------------------------------------------------------
 15041                                  
 15042                                  ;***	CmpName - compare file name of two entries
 15043                                  ;***	CmpExt - compare extension of two entries
 15044                                  ;
 15045                                  ;	ENTRY	ES:BX = ptr to one entry
 15046                                  ;		ES:BP = ptr to another entry
 15047                                  ;
 15048                                  ;	EXIT	BX = unchanged
 15049                                  ;		BP = unchanged
 15050                                  ;		Condition flags set for same, above, or below
 15051                                  ;		comparing BX entry to BP entry.
 15052                                  ;
 15053                                  ;	USED:	AX,CX,DX,SI,DI
 15054                                  
 15055                                  	; 16/02/2023
 15056                                  CmpName:
 15057 000013FD 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 15058 000013FF 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 15059                                  	;;add	si,filename	; ES:SI = ptr to BX name
 15060                                  	;add	si,1
 15061                                  	; 25/04/2023
 15062 00001401 46                      	inc	si
 15063                                  	;;add	di,filename	; ES:DI = ptr to BP name
 15064                                  	;add	di,1
 15065                                  	; 25/04/2023
 15066 00001402 47                      	inc	di
 15067                                  	;mov	cx,size filename
 15068                                  				; CX = length of name
 15069 00001403 B90800                  	mov	cx,8
 15070 00001406 EB0C                    	jmp	short CmpStr
 15071                                  
 15072                                  CmpExt:
 15073                                  	; 07/06/2023
 15074                                  	;mov	si,bx		; ES:SI = ptr to BX entry
 15075                                  	;mov	di,bp		; ES:DI = ptr to BP entry
 15076                                  	;;add	si,fileext	; ES:SI = ptr to BX extension
 15077                                  	;add	si,9
 15078                                  	;;add	di,fileext	; ES:DI = ptr to BP extension
 15079                                  	;add	di,9
 15080                                  	;
 15081 00001408 BE0900                  	mov	si,9
 15082 0000140B 89F7                    	mov	di,si ; mov di,9
 15083 0000140D 01DE                    	add	si,bx
 15084 0000140F 01EF                    	add	di,bp
 15085                                  	;
 15086                                  	;mov	cx,size fileext	; CX = length of extension field
 15087 00001411 B90300                  	mov	cx,3
 15088                                  
 15089                                  ;	Bugbug:	use symbol for subfunction code.
 15090                                  
 15091                                  CmpStr:	
 15092 00001414 803E[B0A9]06            	cmp	byte [CountryPtrId],6
 15093 00001419 7527                    	jne	short cnNoCollTable
 15094                                  				; no collating table available
 15095                                  
 15096                                  ;*	Compare strings using collating table.
 15097                                  ;
 15098                                  ;	ES:SI = ptr to 1st string
 15099                                  ;	ES:DI = ptr to 2nd string
 15100                                  ;	CX = length
 15101                                  
 15102 0000141B 55                      	push	bp		; preserve BP
 15103 0000141C 53                      	push	bx		; preserve BX
 15104 0000141D 1E                      	push	ds		; preserve DS
 15105 0000141E C51E[B1A9]              	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
 15106                                  	;assume	ds:NOTHING
 15107 00001422 8B2F                    	mov	bp,[bx]		; BP = size of collating table
 15108 00001424 43                      	inc	bx
 15109 00001425 43                      	inc	bx		; DS:BX = ptr to collating values
 15110                                  				; DS:[BX]-2 = size of table
 15111 00001426 31C0                    	xor	ax,ax		; AX = 0 for starters
 15112                                  
 15113                                  ;	Bugbug:	Investigate removing collating table length checks.
 15114                                  
 15115                                  cnNextChar:
 15116 00001428 268A05                  	mov	al,[es:di]	; AL = AX = char from 2nd string
 15117 0000142B 47                      	inc	di		; ES:DI = ptr to next char 2nd string
 15118 0000142C 39E8                    	cmp	ax,bp		; compare to collating table length
 15119 0000142E 7301                    	jae	short cn1 	; char not in table
 15120 00001430 D7                      	xlat				
 15121                                  cn1:				; AL = AX = collating value
 15122 00001431 89C2                    	mov	dx,ax		; DX = collating value from 2nd string
 15123                                  	;lods	byte ptr es:[si]
 15124 00001433 26AC                    	es	lodsb		; AL = AX = char from 1st string
 15125                                  				; ES:SI = ptr to next char 1st string
 15126 00001435 39E8                    	cmp	ax,bp		; compare to collating table length
 15127 00001437 7301                    	jae	short cn2	; char not in table
 15128 00001439 D7                      	xlat				
 15129                                  cn2:				; AL = AX = collating value
 15130 0000143A 39D0                    	cmp	ax,dx		; compare collating values
 15131 0000143C E1EA                    	loope	cnNextChar	; until unequal or no more left
 15132                                  
 15133 0000143E 1F                      	pop	ds		; restore DS
 15134                                  	;assume	ds:TRANGROUP
 15135 0000143F 5B                      	pop	bx		; restore BX
 15136 00001440 5D                      	pop	bp		; restore BP
 15137 00001441 C3                      	retn
 15138                                  
 15139                                  ;*	If no collating table is available, simply compare raw ASCII values.
 15140                                  ;	Don't we wish we could just do this all the time?  Sigh.
 15141                                  
 15142                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15143                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
 15144                                  cnNoCollTable:
 15145                                  	;repe	cmps byte ptr es:[si],[di]
 15146                                  				;db 0F3h,26h,0A6h,0C3h
 15147 00001442 F3                      	repe	; 0F3h
 15148 00001443 26                      	es	; 26h
 15149 00001444 A6                      	cmpsb	; 0A6h
 15150 00001445 C3                      	retn	; 0C3h
 15151                                  
 15152                                  ; ---------------------------------------------------------------------------
 15153                                  
 15154                                  ;***	CmpTime - compare entries by date/time
 15155                                  ;
 15156                                  ;	ENTRY	ES:BX = ptr to one entry
 15157                                  ;		ES:BP = ptr to another entry
 15158                                  ;
 15159                                  ;	EXIT	BX = unchanged
 15160                                  ;		BP = unchanged
 15161                                  ;		Condition flags set for same, above, or below
 15162                                  ;		 comparing BX entry to BP entry.
 15163                                  ;
 15164                                  ;	USED:	CX,SI,DI
 15165                                  ;
 15166                                  ;	NOTE	Filetime and filedate fields in our private entry
 15167                                  ;		structure must be adjacent and in that order.
 15168                                  
 15169                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15170                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15171                                  CmpTime:
 15172 00001446 89DE                    	mov	si,bx
 15173 00001448 89EF                    	mov	di,bp
 15174                                  	;add	si,filedate + size filedate - 1
 15175 0000144A 83C610                  	add	si,16 ; 15+2-1
 15176                                  	;add	di,filedate + size filedate - 1
 15177 0000144D 83C710                  	add	di,16 ; 15+2-1
 15178                                  	; 07/06/2023
 15179 00001450 BE1000                  	mov	si,16
 15180                                  CmpST2:		; 07/06/2023
 15181 00001453 89F7                    	mov	di,si	; mov di,16
 15182 00001455 01DE                    	add	si,bx
 15183 00001457 01EF                    	add	di,bp
 15184                                  
 15185                                  	;mov	cx,size filetime + size filedate
 15186 00001459 B90400                  	mov	cx,4 ; 2+2
 15187 0000145C FD                      	std
 15188                                  	;repe	cmps byte ptr es:[si],[di]
 15189                                  				;db 0F3h,26h,0A6h, 0FCh,0C3h
 15190 0000145D F3                      	repe	; 0F3h
 15191 0000145E 26                      	es	; 26h
 15192 0000145F A6                      	cmpsb	; 0A6h
 15193                                  	
 15194 00001460 FC                      	cld	; 0FCh
 15195 00001461 C3                      	retn	; 0C3h
 15196                                  
 15197                                  ; ---------------------------------------------------------------------------
 15198                                  
 15199                                  ;***	CmpSize - compare entries by size
 15200                                  ;
 15201                                  ;	ENTRY	ES:BX = ptr to one entry
 15202                                  ;		ES:BP = ptr to another entry
 15203                                  ;
 15204                                  ;	EXIT	BX = unchanged
 15205                                  ;		BP = unchanged
 15206                                  ;		Condition flags set for same, above, or below
 15207                                  ;		 comparing BX entry to BP entry.
 15208                                  ;
 15209                                  ;	USED:	CX,SI,DI
 15210                                  
 15211                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15212                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15213                                  CmpSize:
 15214                                  	;mov	si,bx
 15215                                  	;mov	di,bp
 15216                                  	;;add	si,filesize + size filesize - 1
 15217                                  	;add	si,20  ; 17+4-1
 15218                                  	;;add	di,filesize + size filesize - 1
 15219                                  	;add	di,20  ; 17+4-1
 15220                                  	; 07/06/2023
 15221 00001462 BE1400                  	mov	si,20
 15222                                  	;;;
 15223 00001465 EBEC                    	jmp	short CmpST2 ; 07/06/2023
 15224                                  	;;;
 15225                                  ;CmpST2:
 15226                                  ;	mov	di,si	; mov di,20
 15227                                  ;	add	si,bx
 15228                                  ;	add	di,bp
 15229                                  ;
 15230                                  ;	;mov	cx,size filesize
 15231                                  ;	mov	cx,4
 15232                                  ;	std
 15233                                  ;	;repe	cmps byte ptr es:[si],[di]
 15234                                  ;				;db 0F3h,26h,0A6h
 15235                                  ;	repe	; 0F3h
 15236                                  ;	es	; 26h
 15237                                  ;	cmpsb	; 0A6h
 15238                                  ;
 15239                                  ;	cld
 15240                                  ;	retn
 15241                                  
 15242                                  ; ---------------------------------------------------------------------------
 15243                                  
 15244                                  ;***	CmpType - compare entries by file type (subdirectory or not)
 15245                                  ;
 15246                                  ;	ENTRY	ES:BX = ptr to one entry
 15247                                  ;		ES:BP = ptr to another entry
 15248                                  ;
 15249                                  ;	EXIT	BX = unchanged
 15250                                  ;		BP = unchanged
 15251                                  ;		Condition flags set for same, above, or below
 15252                                  ;		 comparing BX entry to BP entry.
 15253                                  ;
 15254                                  ;	USED:	AX
 15255                                  
 15256                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 15257                                  CmpType:
 15258                                  	;mov	al,es:[bx].fileattr
 15259 00001467 268A470C                	mov	al,[es:bx+12]
 15260                                  	;mov	ah,es:[bp].fileattr
 15261 0000146B 268A660C                	mov	ah,[es:bp+12]
 15262                                  	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
 15263                                  	;and	ax,1010h
 15264 0000146F 251010                  	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
 15265 00001472 38C4                    	cmp	ah,al
 15266 00001474 C3                      	retn
 15267                                  
 15268                                  ; ---------------------------------------------------------------------------
 15269                                  
 15270                                  ;***	CmpCratio - compare entries by compression ratio
 15271                                  ;
 15272                                  ;	ENTRY	ES:BX = ptr to one entry
 15273                                  ;		ES:BP = ptr to another entry
 15274                                  ;
 15275                                  ;	EXIT	BX = unchanged
 15276                                  ;		BP = unchanged
 15277                                  ;		Condition flags set for same, above, or below
 15278                                  ;		 comparing BX entry to BP entry.
 15279                                  ;
 15280                                  ;	USED:	AX
 15281                                  
 15282                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 15283                                  CmpCratio:
 15284                                  	;mov	al,es:[bx].compratio
 15285 00001475 268A4715                	mov	al,[es:bx+21]	
 15286                                  	;cmp	al,es:[bp].compratio
 15287 00001479 263A4615                	cmp     al,[es:bp+21]
 15288 0000147D C3                      	retn
 15289                                  
 15290                                  ; ---------------------------------------------------------------------------
 15291                                  
 15292                                  ;***	DefaultAttr - set default attribute conditions
 15293                                  ;
 15294                                  ;	ENTRY	nothing
 15295                                  ;
 15296                                  ;	EXIT	CY clear
 15297                                  ;
 15298                                  ;	USED
 15299                                  ;
 15300                                  ;	EFFECTS
 15301                                  ;
 15302                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 15303                                  
 15304                                  	; 16/02/2023
 15305                                  DefaultAttr:
 15306                                  	;mov	byte [AttrSpecified],6
 15307 0000147E C606[84A0]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
 15308                                  					; specify H and S
 15309 00001483 C606[85A0]00            	mov	byte [AttrSelect],0	; H and S must be off
 15310 00001488 F8                      	clc				; return success
 15311                                  dtRet:	; 18/02/2023
 15312 00001489 C3                      	retn
 15313                                  
 15314                                  ; ---------------------------------------------------------------------------
 15315                                  
 15316                                  ;***	DisplayTotals - display grand total stats
 15317                                  ;
 15318                                  ;	If we searched subdirectories, display the total # files found
 15319                                  ;	 and total size of files found.
 15320                                  ;	Display disk space remaining.
 15321                                  ;
 15322                                  ;	ENTRY	FileCntTotal, FileSizTotal contain correct values
 15323                                  ;		Bits contains setting of /s
 15324                                  ;		FCB contains drive #
 15325                                  ;
 15326                                  ;	EXIT	nothing
 15327                                  ;
 15328                                  ;	USES	AX,DX
 15329                                  ;		FileSiz
 15330                                  
 15331                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15332                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h
 15333                                  
 15334                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15335                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:14F1h
 15336                                  
 15337                                  DisplayTotals:
 15338                                  	;;;test	Bits,mask subd
 15339                                  	;;test	word [_Bits],4
 15340                                  	;test	byte [_Bits],4
 15341                                  	; 07/06/2023
 15342 0000148A F606[7CA0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0
 15343 0000148F 7432                    	jz	short dtFree		; no subdirectories- do bytes free
 15344                                  
 15345 00001491 E88D16                  	call	CRLF2			; start on new line
 15346 00001494 E82204                  	call	UseLine
 15347                                  
 15348 00001497 BA[0F94]                	mov	dx,total_ptr
 15349 0000149A E87240                  	call	std_printf		; "Total:",cr,lf
 15350 0000149D E81904                  	call	UseLine
 15351                                  	;;;
 15352                                  	; 07/06/2023
 15353                                  	; MSDOS 6.22 COMMAND.COM
 15354                                  	;test	word [_Bits],1		; mask.cratio
 15355 000014A0 F606[7CA0]01            	test	byte [_Bits],mask.cratio
 15356 000014A5 740E                    	jz      short dtCntSize
 15357 000014A7 A1[2F9E]                	mov     ax,[ccluUsedTotal]
 15358 000014AA A3[2D9E]                	mov     [ccluUsedDir],ax
 15359 000014AD BE[399E]                	mov     si,csecUsedTotal
 15360 000014B0 BF[359E]                	mov     di,csecUsedDir
 15361 000014B3 A5                      	movsw
 15362 000014B4 A5                      	movsw
 15363                                  dtCntSize:    
 15364                                  	;;;
 15365 000014B5 A1[239E]                	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
 15366 000014B8 BE[279E]                	mov	si,FileSizTotal
 15367 000014BB BF[1F9E]                	mov	di,FileSiz
 15368 000014BE A5                      	movsw
 15369 000014BF A5                      	movsw				; move total size to size variable
 15370 000014C0 E8FC05                  	call	DisplayCntSiz		; display file count & size &
 15371                                  dtFree: 				;   (maybe) compression ratio
 15372 000014C3 B436                    	mov	ah,36h
 15373                                  	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
 15374 000014C5 8A165C00                	mov	dl,[FCB] ; [5Ch]	; DL = drive#
 15375 000014C9 CD21                    	int	21h			; call DOS
 15376 000014CB 83F8FF                  	cmp	ax,-1			; check 'invalid drive' return code
 15377 000014CE 74B9                    	jz	short dtRet		; can't get drive space - return
 15378 000014D0 F7E1                    	mul	cx
 15379 000014D2 F7E3                    	mul	bx
 15380 000014D4 A3[9AA0]                	mov	[Bytes_Free],ax
 15381 000014D7 8916[9CA0]              	mov	[Bytes_Free+2],dx
 15382 000014DB BA[1E92]                	mov	dx,bytmes_ptr
 15383 000014DE E82E40                  	call	std_printf		; "nnn bytes free",cr,lf
 15384                                  	;call	UseLine
 15385                                  ;dtRet:
 15386                                  	;retn
 15387                                  	; 18/02/2023
 15388 000014E1 E9D503                  	jmp	UseLine
 15389                                  
 15390                                  ; ---------------------------------------------------------------------------
 15391                                  
 15392                                  ;***	FileIsDevice - see if file looks like a device
 15393                                  ;
 15394                                  ;	ENTRY	PathPos = ptr to pathname
 15395                                  ;		PathCnt = length of pathname w/o terminating char
 15396                                  ;		DirBuf is DOS DTA
 15397                                  ;
 15398                                  ;	EXIT	ZR = set if file looks like a device
 15399                                  ;
 15400                                  ;	USED	AX,BX,CX,DX,DI
 15401                                  ;
 15402                                  ;	EFFECTS
 15403                                  ;
 15404                                  ;	  DTA buffer holds results of Find First function
 15405                                  ;
 15406                                  ;	NOTES
 15407                                  ;
 15408                                  ;	  We try to flag devices in two ways. First, we try
 15409                                  ;	  the DOS Find First function. It returns attribute bit 6
 15410                                  ;	  set on a successful find if it identifies a device name.
 15411                                  ;	  Unfortunately, it returns 'path not found' for a device
 15412                                  ;	  name terminated with colon, such as "CON:". So, we look
 15413                                  ;	  for any colon in the pathname after the 2nd character,
 15414                                  ;	  and flag the pathname as a device if we find one.
 15415                                  
 15416                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15417                                  FileIsDevice:
 15418 000014E4 8B16[80A0]              	mov	dx,[PathPos]	 ; DX = ptr to pathname
 15419                                  
 15420 000014E8 89D7                    	mov	di,dx
 15421 000014EA 033E[7EA0]              	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
 15422 000014EE 30DB                    	xor	bl,bl		 ; BL = NUL to terminate pathname with
 15423 000014F0 861D                    	xchg	bl,[di] 	 ; BL = saved pathname terminating char
 15424                                  
 15425 000014F2 31C9                    	xor	cx,cx		 ; CX = attribute mask (normal search)
 15426 000014F4 B44E                    	mov	ah,4Eh
 15427                                  	;mov	ah,Find_First	 ; AH = DOS Find First function code
 15428 000014F6 CD21                    	int	21h	 	 ; call DOS
 15429 000014F8 861D                    	xchg	bl,[di]		 ; restore pathname terminating char
 15430 000014FA 720A                    	jc	short piCol	 ; didn't find a dir entry, check for colon
 15431                                  
 15432                                  ;	Found a dir entry, see if Find First thinks it's a device.
 15433                                  
 15434                                  	;test	byte [DIRBUF+21],40h
 15435 000014FC F606[3FA0]40            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 15436 00001501 7403                    	jz	short piCol	 ; device attribute not set, look for colon
 15437 00001503 31C9                    	xor	cx,cx		 ; it's a device, return ZR flag
 15438                                  	;jmp	short piRet
 15439                                  	; 25/04/2023
 15440                                  piRet:
 15441 00001505 C3                      	retn
 15442                                  
 15443                                  ;	Device attribute not returned by Find First function. But
 15444                                  ;	let's check for a colon anywhere in the pathname after the
 15445                                  ;	second byte.
 15446                                  ;
 15447                                  ;	DI = ptr to byte after pathname
 15448                                  
 15449                                  piCol:
 15450 00001506 4F                      	dec	di		 ; DI = ptr to last char in pathname
 15451 00001507 B03A                    	mov	al,':'
 15452                                  	;mov	al,COLON_CHAR	 ; AL = colon char to search for
 15453 00001509 8B0E[7EA0]              	mov	cx,[PathCnt]	 ; CX = # chars to scan
 15454 0000150D 49                      	dec	cx
 15455 0000150E 49                      	dec	cx		 ; ignore 1st two chars of pathname
 15456 0000150F 09C9                    	or	cx,cx
 15457 00001511 78F2                    	js	short piRet	 ; if < 2 chars in pathname, just return
 15458 00001513 09FF                    	or	di,di		 ; clear ZR in case CX = 0
 15459 00001515 FD                      	std			 ; scan downward
 15460 00001516 F2AE                    	repne	scasb
 15461 00001518 FC                      	cld			 ; restore default upward direction
 15462                                  
 15463                                  ;	After scanning, the ZR flag is set to indicate presence of a colon.
 15464                                  ;piRet:
 15465 00001519 C3                      	retn
 15466                                  
 15467                                  ;FileIsDevice endp
 15468                                  
 15469                                  ; ---------------------------------------------------------------------------
 15470                                  
 15471                                  ;***	FindFirst - find first directory entry to display
 15472                                  ;***	FindNext - find next directory entry to display
 15473                                  ;
 15474                                  ;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
 15475                                  ;		AttrSpecified, AttrSelect are set
 15476                                  ;
 15477                                  ;	EXIT	CY = clear if successful
 15478                                  ;		BX = offset in TPA buffer of directory entry found
 15479                                  ;
 15480                                  ;		If unsuccessful,
 15481                                  ;		CY = set
 15482                                  ;		AX = DOS error code
 15483                                  ;		DOS Get Extended Error call will get error code
 15484                                  ;
 15485                                  ;		NOTE: if entries were loaded into TPA, AX contains
 15486                                  ;		ERROR_NO_MORE_FILES when no more entries are available,
 15487                                  ;		but DOS Get Extended Error call WON'T return the correct
 15488                                  ;		error. That's ok, because we'll see the value in AX
 15489                                  ;		and recognize it as a non-error condition.
 15490                                  ;
 15491                                  ;	USED	AX,CX,DX,SI,DI
 15492                                  ;
 15493                                  ;	EFFECTS
 15494                                  ;
 15495                                  ;	  Entries in memory may be marked as output.
 15496                                  ;	  If not sorted, entry is loaded at TPA.
 15497                                  ;
 15498                                  ;	NOTES
 15499                                  ;
 15500                                  ;	  If we don't find a qualifying file, we return after the final
 15501                                  ;	   DOS Find File call. A DOS Get Extended Error call will then
 15502                                  ;	   indicate an appropriate condition.
 15503                                  
 15504                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15505                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15506                                  
 15507                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15508                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1585h
 15509                                  	
 15510                                  FindFirst:
 15511                                  	;mov	ax,offset TRANGROUP:GetFirst
 15512 0000151A B8[F115]                	mov	ax,GetFirst
 15513 0000151D EB03                    	jmp	short ffFindEntry
 15514                                  
 15515                                  	; 18/02/2023
 15516                                  FindNext:
 15517                                  	;mov	ax,offset TRANGROUP:GetNext
 15518 0000151F B8[FF15]                	mov	ax,GetNext
 15519                                  
 15520                                  ;	AX = address of correct disk get routine to use.
 15521                                  
 15522                                  ffFindEntry:
 15523 00001522 06                      	push	es			; save TRANGROUP seg addr
 15524                                  	;;;test	Bits,mask inmem
 15525                                  	;;test	word [_Bits],20h
 15526                                  	;test	byte [_Bits],20h
 15527                                  	; 07/06/2023
 15528 00001523 F606[7CA0]40            	test	byte [_Bits],mask.inmem ; 40h ; MSDOS 6.0
 15529 00001528 7405                    	jz	short ffDisk		; entries not in memory, search disk
 15530                                  
 15531                                  ;	Entries are loaded in memory to sort out. Find the first one.
 15532                                  ;	There will always be one, or LoadEntries would've failed.
 15533                                  
 15534 0000152A E81A00                  	call	FindInMem		; find first entry in TPA
 15535 0000152D EB16                    	jmp	short ffRet		; return what TPA search returns
 15536                                  
 15537                                  ;	Get entry from disk.
 15538                                  
 15539                                  ffDisk:
 15540 0000152F FFD0                    	call	ax			; get entry from disk
 15541 00001531 720E                    	jc	short ffGetErr		; get & return error
 15542 00001533 8E06[F59D]              	mov	es,[TPA]		; ES = seg addr of TPA
 15543 00001537 31FF                    	xor	di,di			; ES:DI = ptr to TPA
 15544 00001539 89FB                    	mov	bx,di			; BX = offset of entry in TPA
 15545 0000153B E85F01                  	call	LoadEntry		; load entry to TPA
 15546 0000153E F8                      	clc				; return success
 15547 0000153F EB04                    	jmp	short ffRet
 15548                                  
 15549                                  ffGetErr:
 15550 00001541 E8FE0C                  	call	 get_ext_error_number	; AX = DOS error code
 15551 00001544 F9                      	stc
 15552                                  ffRet:
 15553 00001545 07                      	pop	es			; ES = TRANGROUP seg addr again
 15554 00001546 C3                      	retn
 15555                                  
 15556                                  ; ---------------------------------------------------------------------------
 15557                                  
 15558                                  ;***	FindInMem - find next directory entry in TPA buffer
 15559                                  ;
 15560                                  ;	ENTRY	TPA is loaded (see LoadEntries)
 15561                                  ;
 15562                                  ;	EXIT	BX = offset in TPA of entry found
 15563                                  ;
 15564                                  ;		If no more files,
 15565                                  ;		CY = set
 15566                                  ;		AX = DOS 'no more files' error code
 15567                                  ;
 15568                                  ;	USED	AX,BX,CX,DX,SI,DI,BP,ES
 15569                                  ;
 15570                                  ;	EFFECTS
 15571                                  ;
 15572                                  ;	  Entry found is flagged as 'used' (see EntryStruc).
 15573                                  
 15574                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15575                                  FindInMem:
 15576 00001547 8E06[F59D]              	mov	es,[TPA]		; ES = TPA seg addr
 15577 0000154B 31DB                    	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
 15578 0000154D FC                      	cld				; make sure default string direction is up
 15579                                  	
 15580 0000154E E86D00                  	call	FindOneInMem		; locate an entry
 15581 00001551 720E                    	jc	short fiNoMore		; none left, set up 'no more files' error
 15582                                  
 15583                                  ;	BX = ptr to entry in TPA
 15584                                  
 15585                                  fiBest:
 15586 00001553 89DD                    	mov	bp,bx			; BP = ptr to best entry so far
 15587                                  fiNext:
 15588 00001555 E87300                  	call	FindNextInMem		; locate next entry
 15589 00001558 720C                    	jc	short fiFound		; no more, best entry so far wins
 15590                                  
 15591                                  ;	BX = ptr to next entry
 15592                                  
 15593 0000155A E86CFE                  	call	CmpEntry		; compare it to best found so far (BP)
 15594 0000155D 73F6                    	jnb	short fiNext		; it's not better, go look at next one
 15595 0000155F EBF2                    	jmp	short fiBest		; it's better, go mark it as best so far
 15596                                  
 15597                                  fiNoMore:
 15598                                  
 15599                                  ;	No more entries available in TPA. Set up 'no more files' error.
 15600                                  
 15601                                  	;mov	ax,18
 15602 00001561 B81200                  	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
 15603 00001564 F9                      	stc				; return error
 15604                                  	;jmp	short fiRet
 15605                                  	; 18/02/2023
 15606 00001565 C3                      	retn
 15607                                  
 15608                                  fiFound:
 15609 00001566 89EB                    	mov	bx,bp			; BX = ptr to best entry found
 15610 00001568 26C60701                	mov	byte [es:bx],1		; mark entry 'used'
 15611 0000156C F8                      	clc				; return success
 15612                                  fiRet:
 15613 0000156D C3                      	retn
 15614                                  
 15615                                  ; ---------------------------------------------------------------------------
 15616                                  
 15617                                  ;***	FindNextChild - find next subdirectory in current directory
 15618                                  ;
 15619                                  ;	ENTRY	BX = ptr to last child found, ASCIIZ filename
 15620                                  ;		DirBuf is established DTA
 15621                                  ;
 15622                                  ;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
 15623                                  ;
 15624                                  ;		If failure,
 15625                                  ;		CY = set
 15626                                  ;		DOS Get Extended Error call will get error
 15627                                  ;
 15628                                  ;	USED	AX,CX,DX,SI,DI,BP
 15629                                  ;
 15630                                  ;	EFFECTS
 15631                                  ;
 15632                                  ;	  DirBuf is used for find first/next calls.
 15633                                  ;
 15634                                  ;	NOTES
 15635                                  ;
 15636                                  ;	  We keep on checking files until DOS returns an error. If
 15637                                  ;	  the error is 'no more files' and the temp filename is not
 15638                                  ;	  the initial high tag, copy the temp to the child's name spot
 15639                                  ;	  and return success. Otherwise, send the error back to caller.
 15640                                  ;
 15641                                  ;	  This routine depends on DS,ES,CS, & SS all being equal.
 15642                                  
 15643                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15644                                  FindNextChild:
 15645 0000156E 83EC0C                  	sub	sp,12			; make temp filename buf on stack
 15646                                  	;shove	00FFh			; temp filename = high tag
 15647 00001571 B8FF00                  	mov	ax,0FFh
 15648 00001574 50                      	push	ax
 15649 00001575 89E5                    	mov	bp,sp			; BP = ptr to temp filename buf
 15650                                  	;shove	"*"	
 15651 00001577 B02A                    	mov	al,'*'  ; ax = 002Ah
 15652 00001579 50                      	push	ax
 15653                                  	;;shove	".*" 
 15654                                  	;mov	ax,"*."
 15655                                  	;mov	ax,2E2Ah
 15656 0000157A B42E                    	mov	ah,'.'
 15657 0000157C 50                      	push	ax
 15658 0000157D E87D05                  	call	GetDriveLtr		; AX = "d:"
 15659 00001580 50                      	push	ax
 15660 00001581 89E2                    	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack
 15661                                  
 15662                                  ;	See that the stack is restored properly at the end of this proc.
 15663                                  
 15664                                  	;mov	cx,10h
 15665 00001583 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15666 00001586 B44E                    	mov	ah,4Eh
 15667                                  	;mov	ah,Find_First
 15668 00001588 CD21                    	int	21h			; DOS- Find First matching file
 15669 0000158A 722C                    	jc	short fcRet		; return error
 15670                                  
 15671 0000158C E815FE                  	call	CheckChild		; check child against last, temp
 15672                                  fcNext:	
 15673                                  	;mov	cx,10h
 15674 0000158F B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15675 00001592 B44F                    	mov	ah,4Fh
 15676                                  	;mov	ah,Find_Next
 15677 00001594 CD21                    	int	21h			; DOS- Find Next matching file
 15678 00001596 7205                    	jc	short fcErr		; examine error
 15679                                  
 15680 00001598 E809FE                  	call	CheckChild		; check child against last, temp
 15681 0000159B EBF2                    	jmp	short fcNext		; go find another child
 15682                                  
 15683                                  fcErr:
 15684 0000159D E8A20C                  	call	get_ext_error_number	; AX = extended error code
 15685                                  	;cmp	ax,18
 15686 000015A0 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
 15687 000015A3 7512                    	jne	short fcNope		; some other error- return it
 15688                                  
 15689                                  ;	We ran out of files. See if we qualified at least one.
 15690                                  
 15691 000015A5 807E00FF                	cmp	byte [bp],0FFh
 15692 000015A9 740C                    	je	short fcNope		; temp filename is unused- no child
 15693                                  
 15694                                  ;	Move temp filename to child name position.
 15695                                  
 15696 000015AB 89EE                    	mov	si,bp			; SI = ptr to temp filename
 15697 000015AD 89DF                    	mov	di,bx			; DI = ptr to child name pos'n
 15698                                  fcMove:
 15699 000015AF AC                      	lodsb				; AL = next byte of filename
 15700 000015B0 AA                      	stosb				; store byte
 15701 000015B1 08C0                    	or	al,al
 15702 000015B3 7403                    	jz	short fcRet		; byte was zero, return success (CY clear)
 15703 000015B5 EBF8                    	jmp	short fcMove		; go move another byte
 15704                                  fcNope:
 15705 000015B7 F9                      	stc				; return error
 15706                                  fcRet:
 15707 000015B8 9F                      	lahf
 15708 000015B9 83C414                  	add	sp,20			; restore stack
 15709 000015BC 9E                      	sahf
 15710 000015BD C3                      	retn
 15711                                  
 15712                                  ; ---------------------------------------------------------------------------
 15713                                  
 15714                                  ;***	FindOneInMem - find the first available entry in TPA
 15715                                  ;***	FindNextInMem - find the next available entry in TPA
 15716                                  ;
 15717                                  ;	ENTRY	ES = TPA seg addr
 15718                                  ;		BX = ptr to entry in TPA
 15719                                  ;
 15720                                  ;	EXIT	BX = ptr to entry found
 15721                                  ;		CY = set if no more entries available in TPA
 15722                                  ;
 15723                                  ;	USED	AL
 15724                                  
 15725                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15726                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15727                                  FindOneInMem:
 15728 000015BE 268A07                  	mov	al,[es:bx]		; examine 'used' byte of starting entry
 15729 000015C1 3C01                    	cmp	al,1
 15730 000015C3 7406                    	je	short FindNextInMem	; entry has already been used
 15731 000015C5 3CFF                    	cmp	al,0FFh
 15732 000015C7 7407                    	je	short foNoMore		; 0FFh, we're at the end of the list
 15733                                  
 15734                                  ;	BX = ptr to entry that hasn't been output yet.
 15735                                  
 15736 000015C9 F8                      	clc				; return success
 15737 000015CA C3                      	retn
 15738                                  
 15739                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15740                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:163Ah
 15741                                  FindNextInMem:
 15742                                  	; 07/06/2023
 15743                                  	;add	bx,21 ; MSDOS 5.0
 15744                                  	; 07/06/2023
 15745 000015CB 83C316                  	add	bx,22 ; MSDOS 6.0  ; size EntryStruc (22 = 21 + compratio)
 15746                                  	;add	bx,size EntryStruc	; BX = ptr to next entry
 15747 000015CE EBEE                    	jmp	short FindOneInMem	; go look at it
 15748                                  foNoMore:
 15749 000015D0 F9                      	stc				; ran out of entries, return failure
 15750 000015D1 C3                      	retn
 15751                                  
 15752                                  ; ---------------------------------------------------------------------------
 15753                                  
 15754                                  ;***	GetEnvValue - get value of our environment variable
 15755                                  ;
 15756                                  ;	ENTRY	DS, ES = TRANGROUP seg addr
 15757                                  ;
 15758                                  ;	EXIT	CY = set if environment variable not in environment
 15759                                  ;
 15760                                  ;		Otherwise:
 15761                                  ;		SI = ptr to environment variable asciiz value in TRANGROUP
 15762                                  ;
 15763                                  ;	USED	AX,BX,CX,DX,DI
 15764                                  ;		(We assume the (almost) worst, since we don't know about
 15765                                  ;		Find_Name_In_Environment.)
 15766                                  ;
 15767                                  ;	EFFECTS
 15768                                  ;
 15769                                  ;	  ScanBuf is loaded with value text
 15770                                  
 15771                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15772                                  GetEnvValue:
 15773 000015D2 06                      	push	es				; save ES
 15774                                  	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
 15775 000015D3 BE[9B94]                	mov	si,DirEnvVar	; "DIRCMD="
 15776                                  	;invoke	Find_Name_In_Environment
 15777 000015D6 E88C12                  	call	find_name_in_environment
 15778 000015D9 7214                    	jc	short geRet			; name not found in environment
 15779                                  
 15780                                  ;	ES:DI = ptr to value of environment variable
 15781                                  ;	We're assuming DS, CS, and SS are unchanged.
 15782                                  
 15783 000015DB 1E                      	push	ds
 15784 000015DC 06                      	push	es
 15785 000015DD 1F                      	pop	ds
 15786 000015DE 07                      	pop	es
 15787                                  
 15788                                  	;assume	ds:nothing
 15789                                  
 15790                                  ;	DS = seg addr of environment variable value (in environment segment)
 15791                                  ;	ES = TRANGROUP seg addr
 15792                                  
 15793 000015DF 89FE                    	mov	si,di				; DS:SI = ptr to value string
 15794                                  	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
 15795 000015E1 BF[6CA1]                	mov	di,ScanBuf
 15796                                  geLoop:
 15797                                  ;@@:	
 15798 000015E4 AC                      	lodsb
 15799 000015E5 08C0                    	or	al,al
 15800 000015E7 AA                      	stosb
 15801                                  	;loopnz	@B		; move the string, including trailing null
 15802 000015E8 E0FA                    	loopnz	geLoop
 15803                                  
 15804 000015EA 06                      	push	es
 15805 000015EB 1F                      	pop	ds		; DS = TRANGROUP seg addr again
 15806                                  	;assume	ds:TRANGROUP
 15807                                  
 15808                                  	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
 15809 000015EC BE[6CA1]                	mov	si,ScanBuf
 15810                                  geRet:
 15811 000015EF 07                      	pop	es				; restore ES
 15812 000015F0 C3                      	retn
 15813                                  
 15814                                  ; ---------------------------------------------------------------------------
 15815                                  
 15816                                  ;***	GetFirst - get first directory entry from disk
 15817                                  ;
 15818                                  ;	ENTRY	DOS DTA established at DirBuf
 15819                                  ;		FCB contains drive # and filename
 15820                                  ;		Current directory (on selected drive) is the one to search
 15821                                  ;		AttrSpecified & AttrSelect masks set
 15822                                  ;
 15823                                  ;	EXIT	CY = clear if success
 15824                                  ;		DirBuf contains extended FCB for file found
 15825                                  ;
 15826                                  ;		If unsuccessful,
 15827                                  ;		CY = set
 15828                                  ;		Ready for DOS Get Extended Error call
 15829                                  ;
 15830                                  ;	USED	AX,DX
 15831                                  ;
 15832                                  ;	EFFECTS
 15833                                  ;
 15834                                  ;	  FCB-7 = 0FFh to mark extended FCB
 15835                                  ;	  FCB-1 = attribute mask to find all files
 15836                                  ;	  These fields should remain unmodified for GetNext calls.
 15837                                  ;
 15838                                  ;***	GetNext - get next directory entry from disk
 15839                                  ;
 15840                                  ;	ENTRY	As for GetFirst, plus
 15841                                  ;		FCB-7 set up as extended FCB w/ find-all attribute byte
 15842                                  ;
 15843                                  ;	EXIT	As for GetFirst
 15844                                  ;
 15845                                  ;	USED	AX,DX
 15846                                  
 15847                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15848                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15849                                  
 15850                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 15851                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1660h
 15852                                  GetFirst:
 15853                                  	;mov	byte [55h],0FFh	; -1
 15854 000015F1 C6065500FF              	mov	byte [FCB-7],0FFh	; signal extended FCB
 15855                                  	;mov	byte [5Bh],16h
 15856 000015F6 C6065B0016              	mov	byte [FCB-1],ATTR_ALL ; 16h
 15857                                  					; find any file
 15858                                  	; 07/06/2023
 15859                                  	;mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
 15860 000015FB B411                    	mov	ah,11h
 15861                                  	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
 15862                                  	; 07/06/2023
 15863                                  	;int	21h			; call DOS
 15864                                  	;shl	al,1			; CY = set if error
 15865                                  	;jc	short gfRet		; return error
 15866                                  	;jmp	short gfFound		; go look at attr's
 15867                                  	; 07/06/2023
 15868 000015FD EB02                    	jmp	short GetFrstNxt
 15869                                  GetNext:
 15870                                  	; 07/06/2023
 15871                                  	;;mov	dx,55h
 15872                                  	;mov	dx,FCB-7		; DX = ptr to extended FCB
 15873 000015FF B412                    	mov	ah,12h
 15874                                  	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
 15875                                  GetFrstNxt:
 15876                                  	; 07/06/2023
 15877 00001601 BA5500                  	mov	dx,FCB-7 ; mov dx,55h
 15878                                  	;
 15879 00001604 CD21                    	int	21h			; call DOS
 15880 00001606 D0E0                    	shl	al,1			; CY = set if error
 15881 00001608 7211                    	jc	short gfRet		; return error
 15882                                  
 15883                                  ;*	Found an entry. Check attributes.
 15884                                  gfFound:
 15885                                  	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
 15886                                  	;mov	al,[DIRBUF+19]
 15887 0000160A A0[3DA0]                	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
 15888 0000160D 8A26[84A0]              	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
 15889 00001611 20E0                    	and	al,ah			; AL = pertinent attr's of file
 15890 00001613 2226[85A0]              	and	ah,[AttrSelect]		; AH = attr settings to match
 15891 00001617 38E0                    	cmp	al,ah
 15892 00001619 75E4                    	jne	short GetNext		; attr's don't match, look for another
 15893                                  gfRet:
 15894 0000161B C3                      	retn
 15895                                  
 15896                                  ; ---------------------------------------------------------------------------
 15897                                  
 15898                                  ;***	ListDir - search for and list files in the current directory
 15899                                  ;
 15900                                  ;	List header, files, and trailer for current directory on selected
 15901                                  ;	drive. Header & trailer are listed if at least one file is found.
 15902                                  ;	If no qualifying files are found, no display output occurs.
 15903                                  ;
 15904                                  ;	ENTRY	Current directory (on selected drive) is the one to be listed
 15905                                  ;		FCB contains selected drive # and filename spec
 15906                                  ;		Option bits, attribute masks, and sort codes set up
 15907                                  ;
 15908                                  ;	EXIT	CY = clear if no error
 15909                                  ;		FileCnt = # files found & displayed
 15910                                  ;
 15911                                  ;		If error,
 15912                                  ;		CY = set
 15913                                  ;		Ready for DOS Get Extended Error call
 15914                                  ;
 15915                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 15916                                  ;		FileSiz
 15917                                  ;
 15918                                  ;	EFFECTS
 15919                                  ;
 15920                                  ;	  FileCntTotal, FileSizTotal are updated.
 15921                                  ;	  Files found are listed. A directory header and trailer are
 15922                                  ;	   displayed only if files are found.
 15923                                  
 15924                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15925                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh
 15926                                  
 15927                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 15928                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1694h
 15929                                  ListDir:
 15930 0000161C 31C0                    	xor	ax,ax ; 0
 15931 0000161E A3[1D9E]                	mov	[FileCnt],ax		; zero file count
 15932 00001621 A3[1F9E]                	mov	[FileSiz],ax		; zero file size accumulator
 15933 00001624 A3[219E]                	mov	[FileSiz+2],ax
 15934                                  
 15935                                  	; 08/06/2023
 15936                                  	; MSDOS 6.0
 15937                                  ;ifdef DBLSPACE_HOOKS
 15938 00001627 A3[2D9E]                	mov	[ccluUsedDir],ax 	; zero count clusters used
 15939 0000162A A3[359E]                	mov	[csecUsedDir],ax	; zero count compressed sectors used
 15940 0000162D A3[379E]                	mov	[csecUsedDir+2],ax
 15941                                  ;endif	
 15942                                  	;cmp	byte [DestBuf],0	; check for sort code
 15943                                  	; 31/07/2024
 15944 00001630 3806[AFA0]              	cmp	[DestBuf],al ; 0
 15945 00001634 740A                    	je	short ld1		; no sort
 15946 00001636 E83000                  	call	LoadEntries		; load entries for sorted listing
 15947 00001639 7305                    	jnc	short ld1		; no error - continue
 15948 0000163B E8040C                  	call	get_ext_error_number	; AX = DOS error code
 15949                                  	; 19/02/2023
 15950                                  	;stc
 15951 0000163E EB12                    	jmp	short ldErr		; return error
 15952                                  ld1:
 15953 00001640 E8D7FE                  	call	FindFirst		; find first file
 15954 00001643 720D                    	jc	short ldErr		; not found, return error
 15955                                  
 15956                                  ;	BX = offset in TPA buffer of entry found
 15957                                  
 15958 00001645 E82B03                  	call	DisplayHeader		; if at least one file, display header
 15959                                  ldNext:
 15960 00001648 E8F902                  	call	DisplayFile		; display the file entry
 15961                                  ;ldNext:
 15962 0000164B E8D1FE                  	call	FindNext		; find another file
 15963 0000164E 7202                    	jc	short ldErr		; not found
 15964                                  	;call	DisplayFile		; display entry
 15965                                  	;jmp	short ldNext		; go find another one
 15966                                  	; 19/02/2023
 15967 00001650 EBF6                    	jmp	short ldNext
 15968                                  ldErr:
 15969                                  	;cmp	ax,2
 15970 00001652 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 15971 00001655 7407                    	je	short ldDone		; file not found, we're done
 15972                                  	;cmp	ax,18
 15973 00001657 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 15974 0000165A 7402                    	je	short ldDone		; no more files, we're done
 15975 0000165C F9                      	stc
 15976                                  	;jmp	short ldRet
 15977                                  	; 19/02/2023
 15978 0000165D C3                      	retn
 15979                                  ldDone:
 15980 0000165E 833E[1D9E]00            	cmp	word [FileCnt],0
 15981                                  	;je	short ld2		; no files found, just return
 15982                                  	; 25/04/2023
 15983 00001663 7403                    	jz	short ldRet
 15984 00001665 E84704                  	call	DisplayTrailer		; display trailing info
 15985                                  	; 08/06/2023
 15986                                  	; cf=0
 15987                                  ;ld2:	
 15988                                  	;clc				; return success
 15989                                  ldRet:
 15990 00001668 C3                      	retn
 15991                                  
 15992                                  ; ---------------------------------------------------------------------------
 15993                                  
 15994                                  ;***	LoadEntries - attempt to load entries from current directory
 15995                                  ;
 15996                                  ;	Load all qualifying directory entries from the current directory
 15997                                  ;	into the TPA. If an error is returned by FindFirst/FindNext calls
 15998                                  ;	other than 'no more files', return to caller with carry flag set.
 15999                                  ;	If we run out of buffer space, display a message that we haven't
 16000                                  ;	enough memory to sort this directory, but return without error.
 16001                                  ;	Other routines know whether or not entries have been loaded by
 16002                                  ;	the 'inmem' flag bit, which we set here.
 16003                                  ;
 16004                                  ;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
 16005                                  ;	this allows sorting over 3000 entries in a directory.
 16006                                  ;
 16007                                  ;	ENTRY	Tpa = buffer seg addr
 16008                                  ;		BytCnt = buffer length, in bytes
 16009                                  ;		Current directory (on selected drive) is the one to load
 16010                                  ;		FCB contains drive # and filespec
 16011                                  ;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
 16012                                  ;
 16013                                  ;	EXIT	CY = set if error
 16014                                  ;		If error, DOS Get Extended Error will get error info
 16015                                  ;
 16016                                  ;	USED	AX,CX,DX,SI,DI
 16017                                  ;
 16018                                  ;	EFFECTS
 16019                                  ;
 16020                                  ;	  Inmem bit of Bits = set if load succeeded.
 16021                                  ;	  Tpa buffer contains directory entries.
 16022                                  ;	  Byte after last entry = 0FFh.
 16023                                  
 16024                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16025                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16026                                  LoadEntries:
 16027 00001669 06                      	push	es			; save TRANGROUP seg addr
 16028 0000166A 8E06[F59D]              	mov	es,[TPA]		; ES = TPA seg addr
 16029 0000166E 31FF                    	xor	di,di			; ES:DI = destination ptr
 16030                                  	;;;and	Bits,not mask inmem	; signal entries not loaded
 16031                                  	; MSDOS 5.0
 16032                                  	;;and	word [_Bits],0FFDFh
 16033                                  	;and	byte [_Bits],0DFh	; not 20h
 16034                                  	; 08/06/2023
 16035                                  	;and	byte [_Bits],0BFh	; ~20h ; MSDOS 6.0
 16036 00001670 8026[7CA0]BF            	and	byte [_Bits],~mask.inmem ; 0BFh ; MSDOS 6.0
 16037                                  
 16038 00001675 E879FF                  	call	GetFirst		; look for first file
 16039 00001678 7221                    	jc	short leRet		; return any error
 16040 0000167A E82000                  	call	LoadEntry		; load entry into TPA
 16041                                  leNext:
 16042 0000167D E87FFF                  	call	GetNext			; get another file
 16043 00001680 720F                    	jc	short leLoaded		; assume any error is no more files
 16044 00001682 A1[129E]                	mov	ax,[BYTCNT]		; AX = size of TPA
 16045 00001685 29F8                    	sub	ax,di			; AX = bytes left in TPA
 16046                                  	; 08/06/2023
 16047                                  	;;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
 16048                                  	;cmp	ax,23 ; 21+2 ; MSDOS 5.0
 16049 00001687 83F818                  	cmp	ax,24 ; 22+2 ; MSDOS 6.0
 16050 0000168A 720E                    	jb	short leOk		; not enough memory left, give up
 16051 0000168C E80E00                  	call	LoadEntry		; load entry into TPA
 16052 0000168F EBEC                    	jmp	short leNext		; go get another file
 16053                                  
 16054                                  leLoaded:
 16055 00001691 26C605FF                	mov	byte [es:di],0FFh	; mark end of entry list
 16056                                  	;;;or	Bits,mask inmem		; signal entries loaded in memory
 16057                                  	; MSDOS 5.0
 16058                                  	;;or	word [_Bits],20h
 16059                                  	;or	byte [_Bits],20h
 16060                                  	; 08/06/2023
 16061                                  	;or	byte [_Bits],40h	; MSDOS 6.0
 16062 00001695 800E[7CA0]40            	or	byte [_Bits],mask.inmem ; 40h ; MSDOS 6.0 
 16063                                  	; 25/04/2023
 16064                                  	; cf = 0
 16065                                  leOk:
 16066 0000169A F8                      	clc				; return no error
 16067                                  leRet:
 16068 0000169B 07                      	pop	es			; ES = TRANGROUP seg addr again
 16069 0000169C C3                      	retn
 16070                                  
 16071                                  ; ---------------------------------------------------------------------------
 16072                                  
 16073                                  ;***	LoadEntry - load directory entry from DirBuf ext'd FCB
 16074                                  ;
 16075                                  ;	ENTRY	ES:DI = ptr to load point in TPA
 16076                                  ;		DirBuf contains extended FCB of entry to load
 16077                                  ;
 16078                                  ;	EXIT	ES:DI = ptr to next byte available in TPA
 16079                                  ;
 16080                                  ;	USED	AX,CX,SI
 16081                                  ;
 16082                                  ;	NOTES
 16083                                  ;
 16084                                  ;	  I could've used symbolic offsets and sizes of fields from
 16085                                  ;	   the dir_entry struc to do this, but this is time-critical,
 16086                                  ;	   so I hard-wired the structure of the DOS 4.x returned FCB,
 16087                                  ;	   as well as our private directory entry structure.
 16088                                  ;
 16089                                  ;	  We force a zero size for subdirectory files. A zero size is
 16090                                  ;	   ordinarily returned for subdirectories, but with Novell
 16091                                  ;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.
 16092                                  
 16093                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16094                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
 16095                                  	
 16096                                  	; 07/06/2023 - Retro DOS v4.2 COMMAND.COM
 16097                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:171Ch
 16098                                  LoadEntry:
 16099                                  	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
 16100 0000169D BE[32A0]                	mov	si,DIRBUF+8
 16101 000016A0 30C0                    	xor	al,al				; AL = 0
 16102 000016A2 AA                      	stosb					; 'used' byte = false
 16103 000016A3 B90B00                  	mov	cx,11
 16104 000016A6 F3A4                    	rep	movsb				; transfer filename & extension
 16105 000016A8 AC                      	lodsb					; AL = attrib byte
 16106 000016A9 AA                      	stosb					; store attrib byte
 16107                                  	;add	si,10 ; 22-11-1
 16108                                  	;add	si,dir_time-dir_attr-1		; skip to time field
 16109 000016AA 83C60A                  	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
 16110 000016AD A5                      	movsw					; transfer time
 16111 000016AE A5                      	movsw					; transfer date
 16112                                  
 16113                                  ; 08/06/2023
 16114                                  ; MSDOS 5.0
 16115                                  %if 0
 16116                                  	inc	si				; skip alloc unit
 16117                                  	inc	si
 16118                                  	;and	al,10h
 16119                                  	and	al,ATTR_DIRECTORY
 16120                                  	jnz	short leSetDirSize		; force zero size for subdir
 16121                                  	movsw
 16122                                  	movsw					; transfer size
 16123                                  	retn
 16124                                  leSetDirSize:
 16125                                  	xor	ax,ax ; 0
 16126                                  	stosw
 16127                                  	stosw					; store zero size
 16128                                  	retn
 16129                                  %endif
 16130                                  
 16131                                  ; 08/06/2023
 16132                                  ; MSDOS 6.0
 16133                                  %if 1
 16134                                  ;ifdef DBLSPACE_HOOKS
 16135 000016AF 88C1                    	mov	cl,al				; attrib to cl
 16136 000016B1 AD                      	lodsw					; allocation unit (cluster
 16137                                  	;and	cl,10h
 16138 000016B2 80E110                  	and	cl,ATTR_DIRECTORY
 16139 000016B5 751E                    	jnz	short leSetDirSize		; force zero size for subdir
 16140 000016B7 A5                      	movsw
 16141 000016B8 A5                      	movsw					; transfer size
 16142                                  	
 16143                                  	;;test	word [_Bits],1
 16144                                  	;test	word [_Bits],mask.cratio	; compression ratio report?
 16145 000016B9 F606[7CA0]01            	test	byte [_Bits],mask.cratio
 16146 000016BE 7504                    	jnz	short leCalcRatio		; yup
 16147                                  
 16148 000016C0 31C0                    	xor	ax,ax
 16149 000016C2 AA                      	stosb					; dummy compression ratio
 16150 000016C3 C3                      	retn
 16151                                  leCalcRatio:
 16152 000016C4 E83106                  	call	CalcCompRatio			; takes cluster in AX
 16153 000016C7 09C0                    	or	ax,ax				;   returns ratio in AX
 16154 000016C9 740E                    	jz	short leNoRatio			; 0 means couldn't calculate
 16155 000016CB FECC                    	dec	ah				; pack 1.0 - 16.0 comp ratio
 16156 000016CD B104                    	mov	cl,4				;   into 2 nibbles.  Store
 16157 000016CF D2E4                    	shl	ah,cl				;   1-16 as 0-15 in hi nibble,
 16158 000016D1 08E0                    	or	al,ah				;   tenths (0-9) in low nibble
 16159 000016D3 AA                      	stosb
 16160 000016D4 C3                      	retn
 16161                                  leSetDirSize:
 16162 000016D5 31C0                    	xor	ax,ax ; 0
 16163 000016D7 AB                      	stosw
 16164 000016D8 AB                      	stosw					; store zero size
 16165                                  leNoRatio:
 16166 000016D9 FEC8                    	dec	al				; al = FFh = special invalid
 16167 000016DB AA                      	stosb					; compression ratio
 16168 000016DC C3                      	retn
 16169                                  ;endif
 16170                                  %endif
 16171                                  
 16172                                  ; ---------------------------------------------------------------------------
 16173                                  
 16174                                  ;***	NoOrder - turn sorting off
 16175                                  ;
 16176                                  ;	ENTRY	nothing
 16177                                  ;
 16178                                  ;	EXIT	CY clear
 16179                                  ;
 16180                                  ;	USED	AX
 16181                                  ;
 16182                                  ;	EFFECTS
 16183                                  ;
 16184                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 16185                                  
 16186                                  	; 19/02/2023
 16187                                  NoOrder:
 16188 000016DD C606[AFA0]00            	mov	byte [DestBuf],0
 16189                                  				; no sort
 16190 000016E2 F8                      	clc			; no error
 16191 000016E3 C3                      	retn
 16192                                  
 16193                                  ; ---------------------------------------------------------------------------
 16194                                  
 16195                                  ;***	OnOffSw - record occurence of on/off option switch
 16196                                  ;
 16197                                  ;	ENTRY	DI = index into word list of switches
 16198                                  ;
 16199                                  ;	EXIT	CY clear
 16200                                  ;
 16201                                  ;	USED	AX,CX
 16202                                  ;
 16203                                  ;	EFFECTS
 16204                                  ;
 16205                                  ;	  Bits modified to indicate option state.
 16206                                  
 16207                                  	; 19/02/2023
 16208                                  OnOffSw:
 16209 000016E4 89F9                    	mov	cx,di		; CX = index into word list of options
 16210 000016E6 D1E9                    	shr	cx,1
 16211 000016E8 D1E9                    	shr	cx,1		; CX = bit position of option
 16212 000016EA B80100                  	mov	ax,1		
 16213 000016ED D3E0                    	shl	ax,cl		; AX = bit mask of option
 16214 000016EF F7C70200                	test	di,2		; check if it is a negated option
 16215 000016F3 7405                    	jz	short oo1	; it's negated
 16216                                  	;or	Bits,ax		; turn option on
 16217 000016F5 0906[7CA0]              	or	[_Bits],ax
 16218                                  	;jmp	short ooRet
 16219                                  	; 19/02/2023
 16220                                  	;cf=0
 16221 000016F9 C3                      	retn
 16222                                  oo1:	
 16223 000016FA F7D0                    	not	ax		; AX = complemented bit mask of option
 16224                                  	;and	Bits,ax		; turn option off
 16225 000016FC 2106[7CA0]              	and	[_Bits],ax
 16226                                  ooRet:
 16227                                  	; 19/02/2023
 16228                                  	;cf=0
 16229                                  	;clc			; always return success
 16230 00001700 C3                      	retn
 16231                                  
 16232                                  ; ---------------------------------------------------------------------------
 16233                                  
 16234                                  ;***	ParseAttr - parse and record /A option
 16235                                  ;
 16236                                  ;	ENTRY	BX = ptr to system parser result buffer for /A occurence
 16237                                  ;
 16238                                  ;	EXIT	CY = set if error occurs parsing attribute conditions
 16239                                  ;
 16240                                  ;		For parse error, we set up for Std_EPrintf call:
 16241                                  ;		AX = parse error code, like system parser
 16242                                  ;		DX = ptr to message block
 16243                                  ;
 16244                                  ;	USED	AX,CX,DX,DI
 16245                                  ;
 16246                                  ;	EFFECTS
 16247                                  ;
 16248                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 16249                                  ;	  If parse error occurs, attribute conditions parsed so far hold.
 16250                                  ;
 16251                                  ;	  For parse error, we set up for Std_EPrintf call:
 16252                                  ;	  Msg_Disp_Class = parse error message class
 16253                                  ;	  Message block (see DX) is set up for parse error message
 16254                                  
 16255                                  	; 19/02/2023
 16256                                  ParseAttr:
 16257 00001701 56                      	push	si			; save SI
 16258 00001702 C606[84A0]00            	mov	byte [AttrSpecified],0	; cancel all attribute conditions
 16259                                  
 16260                                  ;	Each /A invocation starts by assuming all files are to be listed.
 16261                                  
 16262                                  	;;mov	si,word ptr [bx].ValuePtr
 16263                                  					; SI = ptr to string after /A
 16264                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16265 00001707 8B7704                  	mov	si,[bx+4]
 16266                                  paLoop:	
 16267 0000170A BA0100                  	mov	dx,1			; DX = 1 (for un-negated attribute)
 16268 0000170D AC                      	lodsb				; AL = next char in string
 16269 0000170E 08C0                    	or	al,al
 16270                                  	;jz	short paOk		; it's terminating null, we're done
 16271                                  	; 19/02/2023
 16272 00001710 742F                    	jz	short paRet ; cf=0
 16273 00001712 3C2D                    	cmp	al,'-'
 16274 00001714 7502                    	jne	short pa1		; not '-', go look for letter
 16275 00001716 4A                      	dec	dx			; DX = 0 (for negated attribute)
 16276 00001717 AC                      	lodsb				; AL = next char
 16277                                  pa1:	
 16278                                  	;mov	di,offset TRANGROUP:AttrLtrs 
 16279                                  					; DI = ptr to attrib letter list
 16280 00001718 BF[6897]                	mov	di,AttrLtrs ; "RHSvDA"
 16281                                  	;mov	cx,6
 16282 0000171B B90600                  	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
 16283 0000171E F2AE                    	repne	scasb			; look for our letter in the list
 16284 00001720 751B                    	jne	short paErr		; not found, return error
 16285                                  
 16286 00001722 F7D1                    	not	cx
 16287                                  	;add	cx,6
 16288 00001724 83C106                  	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5
 16289                                  
 16290                                  ;	Note that we rely on AttrLtrs to be in the attribute bit order,
 16291                                  ;	starting from bit 0.
 16292                                  
 16293                                  ;	Record this attribute bit in AttrSpecified.
 16294                                  
 16295 00001727 B001                    	mov	al,1
 16296 00001729 D2E0                    	shl	al,cl			; AL = mask for our bit
 16297 0000172B 0806[84A0]              	or	[AttrSpecified],al	; set it in the 'specified' mask
 16298                                  
 16299                                  ;	Record the selected state for this attribute in AttrSelect.
 16300                                  ;	DX = 0 or 1, the selected state for this attribute.
 16301                                  
 16302 0000172F F6D0                    	not	al			; AL = mask for all other bits
 16303 00001731 2006[85A0]              	and	[AttrSelect],al		; clear our bit
 16304 00001735 D2E2                    	shl	dl,cl			; DL = our bit state in position
 16305 00001737 0816[85A0]              	or	[AttrSelect],dl		; set selected attr state
 16306 0000173B EBCD                    	jmp	short paLoop		; go look at next char
 16307                                  
 16308                                  ;	The attribute letter string is invalid.
 16309                                  
 16310                                  paErr:	
 16311 0000173D E8CE03                  	call	SetupParamError		; set message up for Std_EPrintf
 16312 00001740 F9                      	stc		   		; return error
 16313                                  	; 19/02/2023
 16314                                  	;jmp	short paRet
 16315                                  ;paOk:
 16316                                  	;clc				; return success		
 16317                                  paRet:	
 16318 00001741 5E                      	pop	si			; restore SI
 16319 00001742 C3                      	retn
 16320                                  
 16321                                  ; ---------------------------------------------------------------------------
 16322                                  
 16323                                  ;***	ParseLine - parse a line of text
 16324                                  ;
 16325                                  ;	Parse text until an EOL (CR or NUL) is found, or until a parse
 16326                                  ;	error occurs.
 16327                                  ;
 16328                                  ;	ENTRY	DS:SI = ptr to text
 16329                                  ;		CS, DS, ES = TRANGROUP seg addr
 16330                                  ;
 16331                                  ;	EXIT	AX = last return code from system parser
 16332                                  ;		CX = # positional parameters (pathnames) found - 0 or 1
 16333                                  ;
 16334                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 16335                                  ;		DX = ptr to message block
 16336                                  ;
 16337                                  ;	USED	BX,CX,DX,SI,DI
 16338                                  ;
 16339                                  ;	EFFECTS
 16340                                  ;
 16341                                  ;	  Bits may contain new option settings.
 16342                                  ;	  DestBuf may contain new series of sort codes.
 16343                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 16344                                  ;	  SrcBuf may contain a new default pathname/filespec.
 16345                                  ;	  PathPos, PathCnt updated for new pathname.
 16346                                  ;
 16347                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 16348                                  ;	  Msg_Disp_Class = parse error class
 16349                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 16350                                  ;	  Message block (see DX) is set up for parse error message
 16351                                  
 16352                                  	; 19/02/2023
 16353                                  Parse_Line:
 16354                                  	; 04/05/2023
 16355 00001743 BF[3698]                	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
 16356 00001746 31C9                    	xor	cx,cx			; CX = # positionals found
 16357                                  plPars:
 16358 00001748 E8BE0F                  	call	Parse_With_Msg		; call parser
 16359 0000174B 83F8FF                  	cmp	ax,-1
 16360                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
 16361 0000174E 7411                    	je	short plRet		; EOL encountered, return
 16362 00001750 83F800                  	cmp	ax,RESULT_NO_ERROR ; 0
 16363 00001753 750C                    	jne	short plRet		; parse error occurred, return
 16364                                  
 16365                                  ;	Parse call succeeded. We have a filespec or a switch.
 16366                                  ;	DX = ptr to result buffer
 16367                                  
 16368 00001755 89D3                    	mov	bx,dx			; BX = ptr to parse result buffer
 16369 00001757 803F05                  	cmp	byte [bx],RESULT_FILESPEC ; 5
 16370 0000175A 7406                    	je	short plFil		; we have a filespec
 16371                                  
 16372 0000175C E87500                  	call	ParseSwitch		; else we have a switch
 16373                                  	;jc	short plRet		; error parsing switch, return
 16374                                  	;jmp	short plPars		; parse more
 16375                                  	; 19/02/2023
 16376 0000175F 73E7                    	jnc	short plPars
 16377                                  plRet:
 16378 00001761 C3                      	retn	
 16379                                  plFil:	
 16380 00001762 E8D200                  	call	CopyPathname		; copy pathname into our buffer
 16381 00001765 EBE1                    	jmp	short plPars		; parse more
 16382                                  ;plRet:
 16383                                  ;	retn
 16384                                  
 16385                                  ; ---------------------------------------------------------------------------
 16386                                  
 16387                                  ;***	ParseOrder - parse and record /O option
 16388                                  ;
 16389                                  ;	ENTRY	BX = ptr to system parser result buffer for /O occurence
 16390                                  ;
 16391                                  ;	EXIT	CY = set if error occurs parsing order
 16392                                  ;
 16393                                  ;		For parse error, we set up for Std_EPrintf call:
 16394                                  ;		AX = parse error code, like system parser
 16395                                  ;		DX = ptr to message block
 16396                                  ;
 16397                                  ;	USED	AX,CX,DX,DI
 16398                                  ;
 16399                                  ;	EFFECTS
 16400                                  ;
 16401                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 16402                                  ;
 16403                                  ;	  For parse error, we set up for Std_EPrintf call:
 16404                                  ;	  Msg_Disp_Class = parse error message class
 16405                                  ;	  Message block (see DX) is set up for parse error message
 16406                                  
 16407                                  	; 19/02/2023 - Retro DOS v4.0 COMMAND.COM
 16408                                  	;
 16409                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16410                                  	; MSDOS 6.22 COMMAND.COM
 16411                                  ParseOrder:
 16412 00001767 56                      	push	si			; save SI
 16413 00001768 53                      	push	bx			; save ptr to result buffer
 16414                                  
 16415                                  	;;mov	si,word ptr [bx].ValuePtr
 16416                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16417 00001769 8B7704                  	mov	si,[bx+4]		; SI = ptr to order letters
 16418                                  	;mov	bx,offset TRANGROUP:DestBuf
 16419                                  	; 08/06/2023
 16420 0000176C BB[AFA0]                	mov	bx,DestBuf		; BX = ptr to sort code buffer
 16421 0000176F 8A04                    	mov	al,[si]			; AL = 1st char of order string
 16422 00001771 08C0                    	or	al,al
 16423 00001773 750E                    	jnz	short poLtr		; not NUL, go parse letters
 16424                                  
 16425                                  ;	We have /O alone. Set standard sort order.
 16426                                  ;	Note hardwired dependency on character order in OrderLtrs.
 16427                                  
 16428 00001775 C60705                  	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
 16429 00001778 43                      	inc	bx
 16430 00001779 C60701                  	mov	byte [bx],1		; then by name
 16431 0000177C 43                      	inc	bx
 16432 0000177D C60702                  	mov	byte [bx],2		; then by extension
 16433 00001780 43                      	inc	bx
 16434 00001781 EB2F                    	jmp	short poOk		; return success
 16435                                  
 16436                                  ;	We have /O<something>. Parse sort order letters.
 16437                                  
 16438                                  poLtr:	
 16439 00001783 30D2                    	xor	dl,dl			; DL = 0 (upward sort)
 16440 00001785 AC                      	lodsb				; AL = next sort order letter
 16441 00001786 08C0                    	or	al,al
 16442 00001788 7428                    	jz	short poOk		; NUL found, return success
 16443                                  
 16444 0000178A 3C2D                    	cmp	al,'-'
 16445 0000178C 7503                    	jne	short po1		; not '-', go look for letter
 16446 0000178E B280                    	mov	dl,80h			; DL = downward sort mask
 16447 00001790 AC                      	lodsb				; AL = next char
 16448                                  po1:
 16449                                  	;mov	di,offset TRANGROUP:OrderLtrs
 16450                                  	; 08/06/2023
 16451 00001791 BF[6E97]                	mov	di,OrderLtrs ;"NEDSGC"	; DI = ptr to list of letters
 16452                                  	; (NUM_ORDER_LTRS = 6 for MSDOS 6.22 COMMAND.COM)
 16453                                  	; ((N,E,D,S,G for MSDOS 5.0 and N,E,D,S,G,C for MSDOS 6.22)) 
 16454                                  	;mov	cx,6 ; 08/06/2023
 16455 00001794 B90600                  	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
 16456 00001797 F2AE                    	repne	scasb			; look for our letter in the list
 16457 00001799 7510                    	jne	short poErr		; not found, return error
 16458                                  
 16459 0000179B F7D9                    	neg	cx
 16460                                  	;add	cx,6 ; 08/06/2023
 16461 0000179D 83C106                  	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6
 16462                                  
 16463 000017A0 08D1                    	or	cl,dl			; CL = sort code with up/dn bit
 16464 000017A2 880F                    	mov	[bx],cl			; store sort order code in buffer
 16465 000017A4 43                      	inc	bx			; BX = ptr to next spot in buffer
 16466                                  	;cmp	bx,offset TRANGROUP:EndDestBuf
 16467 000017A5 81FB[06A1]              	cmp	bx,EndDestBuf
 16468                                  	;jae	short poErr		; too many letters
 16469                                  	;
 16470                                  	;jmp	short poLtr		; go look at next char
 16471                                  	; 19/02/2023
 16472 000017A9 72D8                    	jb	short poLtr
 16473                                  
 16474                                  ;	The sort order string is invalid.  
 16475                                  
 16476                                  poErr:
 16477 000017AB 5B                      	pop	bx			; BX = ptr to result buffer
 16478 000017AC E85F03                  	call	SetupParamError		; set message up for Std_EPrintf
 16479 000017AF F9                      	stc				; return failure
 16480 000017B0 EB04                    	jmp	short poRet
 16481                                  poOk:	
 16482 000017B2 C60700                  	mov	byte [bx],0		; mark end of sort code list
 16483 000017B5 5B                      	pop	bx			; BX = ptr to result buffer
 16484                                  	; 19/02/2023
 16485                                  	;cf=0
 16486                                  	;clc				; return success
 16487                                  poRet:
 16488 000017B6 5E                      	pop	si			; restore SI
 16489 000017B7 C3                      	retn
 16490                                  
 16491                                  ; ---------------------------------------------------------------------------
 16492                                  ; MSDOS 6.0
 16493                                  	; 08/06/2023
 16494                                  
 16495                                  ;ifdef DBLSPACE_HOOKS
 16496                                  
 16497                                  ;***	ParseRatio - parse and record /C[H] option
 16498                                  ;
 16499                                  ;	ENTRY	BX = ptr to system parser result buffer for /C occurence
 16500                                  ;		DI = index into word list of switches
 16501                                  ;
 16502                                  ;	EXIT	CY = set if error occurs parsing order
 16503                                  ;
 16504                                  ;		For parse error, we set up for Std_EPrintf call:
 16505                                  ;		AX = parse error code, like system parser
 16506                                  ;		DX = ptr to message block
 16507                                  ;
 16508                                  ;	USED	AX,CX,DX,DI
 16509                                  ;
 16510                                  ;	EFFECTS
 16511                                  ;
 16512                                  ;	  Bits modified to indicate option state.
 16513                                  ;	  fUseHostSize is set to zero for /C, non-zero for /CH.
 16514                                  ;
 16515                                  ;	  For parse error, we set up for Std_EPrintf call:
 16516                                  ;	  Msg_Disp_Class = parse error message class
 16517                                  ;	  Message block (see DX) is set up for parse error message
 16518                                  
 16519                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16520                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:184Ch
 16521                                  
 16522                                  ParseRatio:	;proc
 16523 000017B8 E829FF                  	call	OnOffSw			; turn on option bit
 16524 000017BB 56                      	push	si			; save SI
 16525                                  	;;mov	si,word ptr [bx].ValuePtr
 16526                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16527 000017BC 8B7704                  	mov	si,[bx+4]		; SI = ptr to possible H option
 16528 000017BF 8A04                    	mov	al,[si] 		; AL = null or 'H'
 16529 000017C1 08C0                    	or	al,al
 16530 000017C3 740A                    	jz	short prDone		; if null, no H option to check
 16531 000017C5 3C48                    	cmp	al,'H' 			; only H is allowed, make sure that's
 16532 000017C7 7406                    	je	short prDone		;   what it is
 16533 000017C9 E84203                  	call	SetupParamError		; set message up for Std_EPrintf
 16534 000017CC F9                      	stc				; return failure
 16535 000017CD EB03                    	jmp	short prRet
 16536                                  prDone:
 16537 000017CF A2[909E]                	mov	[fUseHostSize],al	; set Host cluster size flag
 16538                                  	; 08/06/2023
 16539                                  	;clc
 16540                                  	;;cf = 0
 16541                                  prRet:	
 16542 000017D2 5E                      	pop	si
 16543 000017D3 C3                      	retn
 16544                                  
 16545                                  ;ParseRatio	;endp
 16546                                  ;endif
 16547                                  
 16548                                  ; ---------------------------------------------------------------------------
 16549                                  
 16550                                  ;***	ParseSwitch - parse a switch
 16551                                  ;
 16552                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 16553                                  ;		     a switch
 16554                                  ;
 16555                                  ;	EXIT	CY = set if parse error occurred
 16556                                  ;
 16557                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 16558                                  ;		AX = parse error code, like system parser
 16559                                  ;		DX = ptr to message block
 16560                                  ;
 16561                                  ;	USED	AX,BX,DX
 16562                                  ;
 16563                                  ;	EFFECTS
 16564                                  ;
 16565                                  ;	  Bits may contain new option settings.
 16566                                  ;	  DestBuf may contain new series of sort codes.
 16567                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 16568                                  ;
 16569                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 16570                                  ;	  Msg_Disp_Class = parse error class
 16571                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 16572                                  ;	  Message block (see DX) is set up for parse error message
 16573                                  
 16574                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16575                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
 16576                                  
 16577                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16578                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1869h
 16579                                  ParseSwitch:
 16580 000017D4 51                      	push	cx			; save CX
 16581 000017D5 57                      	push	di			; save DI
 16582                                  
 16583                                  	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
 16584                                  	;mov	ax,[bx+ResultBuffer.SynPtr]
 16585 000017D6 8B4702                  	mov	ax,[bx+2]
 16586                                  	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
 16587 000017D9 BF[8D98]                	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
 16588                                  	; 08/06/2023
 16589                                  	; (NUM_DIR_SWS = 16 for MSDOS 6.0)
 16590                                  	;mov	cx,16
 16591 000017DC B91000                  	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
 16592 000017DF FC                      	cld				; scan direction = upward
 16593 000017E0 F2AF                    	repne	scasw			; locate synonym ptr in list
 16594                                  	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
 16595 000017E2 81EF[8F98]              	sub	di,Dir_Sw_Ptrs+2
 16596                                  
 16597                                  ;	DI = index into word list of synonym ptrs
 16598                                  
 16599 000017E6 2EFF95[EE17]            	call	word [cs:di+SwHandler]	; use same index into call table
 16600                                  
 16601 000017EB 5F                      	pop	di			; restore DI
 16602 000017EC 59                      	pop	cx			; restore CX
 16603                                  
 16604 000017ED C3                      	retn
 16605                                  
 16606                                  ; ---------------------------------------------------------------------------
 16607                                  
 16608                                  ;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
 16609                                  ;	Simple on/off switches must occur first in both lists, and must be
 16610                                  ;	  in order of option bits in Bits, starting with bit 0.
 16611                                  
 16612                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16613                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh
 16614                                  
 16615                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16616                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1883h
 16617                                  SwHandler:
 16618                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 16619                                  		; ifdef DBLSPACE_HOOKS
 16620 000017EE [E416]                  	dw	OnOffSw 	; /-C
 16621 000017F0 [B817]                  	dw	ParseRatio	; /C[H]
 16622                                  	;	; endif	
 16623 000017F2 [E416]                  	dw	OnOffSw		; /-W
 16624 000017F4 [E416]                  	dw	OnOffSw		; /W
 16625 000017F6 [E416]                  	dw	OnOffSw		; /-P
 16626 000017F8 [E416]                  	dw	OnOffSw		; /P
 16627 000017FA [E416]                  	dw	OnOffSw		; /-S
 16628 000017FC [E416]                  	dw	OnOffSw		; /S
 16629 000017FE [E416]                  	dw	OnOffSw		; /-B
 16630 00001800 [E416]                  	dw	OnOffSw		; /B
 16631 00001802 [E416]                  	dw	OnOffSw		; /-L	;M010
 16632 00001804 [E416]                  	dw	OnOffSw		; /L	;M010
 16633 00001806 [DD16]                  	dw	NoOrder		; /-O
 16634 00001808 [6717]                  	dw	ParseOrder	; /O
 16635 0000180A [7E14]                  	dw	DefaultAttr	; /-A
 16636 0000180C [0117]                  	dw	ParseAttr	; /A
 16637                                  
 16638                                  ; ---------------------------------------------------------------------------
 16639                                  
 16640                                  	;break	<DIR utility routines>
 16641                                  
 16642                                  ;***	UTILITY ROUTINES
 16643                                  ; ---------------------- 
 16644                                  
 16645                                  ; ---------------------------------------------------------------------------
 16646                                  
 16647                                  ;***	ChangeDir - change directory on target drive
 16648                                  ;
 16649                                  ;	ENTRY	FCB contains drive #
 16650                                  ;		DS:DX = ptr to ASCIIZ string w/o drive specifier
 16651                                  ;
 16652                                  ;	EXIT	Changed current directory on drive
 16653                                  ;
 16654                                  ;		If error,
 16655                                  ;		CY = set
 16656                                  ;		DOS Get Extended Error call will get error
 16657                                  ;
 16658                                  ;	USED	AX,DX,SI,DI
 16659                                  ;
 16660                                  ;	EFFECTS
 16661                                  ;
 16662                                  ;	  DirBuf is used to build "d:string".
 16663                                  
 16664                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16665                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h
 16666                                  
 16667                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16668                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:18A3h
 16669                                  ChangeDir:
 16670                                  	;mov	di,offset TRANGROUP:DirBuf
 16671 0000180E BF[2AA0]                	mov	di,DIRBUF
 16672 00001811 E8E902                  	call	GetDriveLtr	; AX = "d:"
 16673 00001814 AB                      	stosw			; put drive specifier in buffer
 16674 00001815 89D6                    	mov	si,dx		; SI = ptr to argument string
 16675                                  cdLoop:
 16676 00001817 AC                      	lodsb
 16677 00001818 AA                      	stosb			; move byte to buffer
 16678 00001819 08C0                    	or	al,al
 16679 0000181B 75FA                    	jne	short cdLoop	; continue until null transferred
 16680                                  
 16681                                  	;mov	dx,offset TRANGROUP:DirBuf
 16682 0000181D BA[2AA0]                	mov	dx,DIRBUF	; DX = ptr to "d:string"
 16683                                  	;mov	ah,CHDir
 16684 00001820 B43B                    	mov	ah,3Bh
 16685 00001822 CD21                    	int	21h		; change directory
 16686 00001824 C3                      	retn			; return what CHDIR returns
 16687                                  
 16688                                  ; ---------------------------------------------------------------------------
 16689                                  
 16690                                  ;***	CmpAscz - compare two ASCIIZ strings alphanumerically
 16691                                  ;
 16692                                  ;	ENTRY	DS:SI = ptr to one ASCIIZ string
 16693                                  ;		ES:DI = ptr to another ASCIIZ string
 16694                                  ;
 16695                                  ;	EXIT	flags set after REPE CMPSB
 16696                                  ;
 16697                                  ;	USED	AL,CX,SI,DI
 16698                                  ;
 16699                                  ;	NOTES
 16700                                  ;
 16701                                  ;	Maximum run of comparison is length of DS:SI string.
 16702                                  ;	This ensures that two identical strings followed by
 16703                                  ;	random characters will compare correctly.
 16704                                  
 16705                                  	; 19/02/2023
 16706                                  CmpAscz:
 16707                                  	; 07/06/2023
 16708 00001825 56                      	push	si ; *
 16709                                  	;
 16710 00001826 57                      	push	di
 16711                                  
 16712 00001827 89F7                    	mov	di,si
 16713 00001829 30C0                    	xor	al,al
 16714 0000182B B9FFFF                  	mov	cx,0FFFFh
 16715 0000182E F2AE                    	repne	scasb
 16716 00001830 F7D1                    	not	cx
 16717                                  
 16718 00001832 5F                      	pop	di
 16719 00001833 F3A6                    	repe	cmpsb
 16720                                  
 16721                                  	; 07/06/2023
 16722 00001835 5E                      	pop	si ; *
 16723                                  	;
 16724 00001836 C3                      	retn
 16725                                  
 16726                                  ; ---------------------------------------------------------------------------
 16727                                  
 16728                                  ;***	CopyPathname - copy pathname to our buffer
 16729                                  ;
 16730                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 16731                                  ;		     a filespec
 16732                                  ;
 16733                                  ;	EXIT	nothing
 16734                                  ;
 16735                                  ;	USED	AX
 16736                                  ;
 16737                                  ;	EFFECTS
 16738                                  ;
 16739                                  ;	  SrcBuf may contain a new pathname/filespec.
 16740                                  ;	  PathPos, PathCnt updated for new pathname.
 16741                                  
 16742                                  	; 19/02/2023
 16743                                  CopyPathname:
 16744 00001837 56                      	push	si
 16745                                  	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
 16746                                  	;lds	si,[bx+ResultBuffer.ValuePtr]
 16747 00001838 C57704                  	lds	si,[bx+4]
 16748                                  	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
 16749 0000183B E8B719                  	call	Move_To_SrcBuf
 16750 0000183E 5E                      	pop	si
 16751 0000183F C3                      	retn
 16752                                  
 16753                                  ; ---------------------------------------------------------------------------
 16754                                  
 16755                                  ;***	CountFile - update counters with current file
 16756                                  ;
 16757                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16758                                  ;
 16759                                  ;	EXIT	nothing
 16760                                  ;
 16761                                  ;	USED	AX,DX
 16762                                  ;
 16763                                  ;	EFFECTS
 16764                                  ;
 16765                                  ;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16766                                  
 16767                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16768                                  CountFile:
 16769 00001840 06                      	push	es			; save TRANGROUP seg addr
 16770 00001841 8E06[F59D]              	mov	es,[TPA]		; ES = TPA seg addr
 16771                                  
 16772 00001845 FF06[1D9E]              	inc	word [FileCnt]		; # files this directory
 16773 00001849 FF06[239E]              	inc	word [FileCntTotal]	; # files total
 16774 0000184D 7504                    	jnz	short cntf1
 16775 0000184F FF06[259E]              	inc	word [FileCntTotal+2]
 16776                                  cntf1:
 16777                                  	;mov	ax,word ptr es:[bx].filesize
 16778                                  					; AX = low word of file size
 16779                                  	;mov	dx,word ptr es:[bx].filesize+2
 16780                                  					; DX = high word of file size
 16781 00001853 268B4711                	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
 16782 00001857 268B5713                	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
 16783 0000185B 0106[1F9E]              	add	[FileSiz],ax
 16784 0000185F 1116[219E]              	adc	[FileSiz+2],dx		; size of this directory
 16785 00001863 0106[279E]              	add	[FileSizTotal],ax
 16786 00001867 1116[299E]              	adc	[FileSizTotal+2],dx	; total size of files listed
 16787                                  
 16788 0000186B 07                      	pop	es			; ES = TRANGROUP seg addr again
 16789                                  dbRet:	; 19/02/2023
 16790 0000186C C3                      	retn
 16791                                  
 16792                                  ; ---------------------------------------------------------------------------
 16793                                  
 16794                                  ;***	DisplayBare - display filename in bare format
 16795                                  ;
 16796                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16797                                  ;
 16798                                  ;	EXIT	DX = # char's displayed, including dot
 16799                                  ;
 16800                                  ;	USED	AX,CX,SI,DI
 16801                                  ;
 16802                                  ;	EFFECTS
 16803                                  ;
 16804                                  ;	  Filename is displayed in name.ext format, followed by cr/lf.
 16805                                  ;	  If /s is on, complete pathname is displayed.
 16806                                  ;
 16807                                  ;	NOTE
 16808                                  ;
 16809                                  ;	  Directory pseudofiles . and .. and suppressed in bare listing.
 16810                                  
 16811                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16812                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h
 16813                                  
 16814                                  
 16815                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16816                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1900h
 16817                                  
 16818                                  DisplayBare:
 16819                                  ;	Suppress . and .. files from bare listing.
 16820                                  
 16821 0000186D 8CD9                    	mov	cx,ds			; CX = saved TRANGROUP seg addr
 16822 0000186F 8E1E[F59D]              	mov	ds,[TPA]		; DS:BX = ptr to file entry
 16823                                  	;assume	ds:NOTHING
 16824                                  	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
 16825 00001873 807F012E                	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
 16826 00001877 8ED9                    	mov	ds,cx			; DS = TRANGROUP seg addr again
 16827                                  	;assume	ds:TRANGROUP
 16828 00001879 74F1                    	je	short dbRet		; it's . or .. - don't display
 16829                                  
 16830                                  	;;;test	Bits,mask subd
 16831                                  	;;test	word [_Bits],4
 16832                                  	;test	byte [_Bits],4
 16833                                  	; 08/06/2023
 16834 0000187B F606[7CA0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0
 16835 00001880 7431                    	jz	short dbNameExt		; not /s - display filename only
 16836                                  
 16837                                  	;invoke	Build_Dir_String
 16838 00001882 E8170B                  	call	build_dir_string
 16839                                  	;mov	di,offset TRANGROUP:BwdBuf
 16840 00001885 BF[2AA0]                	mov	di,BWDBUF		; ES:DI = ptr to dir string
 16841                                     
 16842                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16843                                  	;;test	word [_Bits],10h
 16844                                  	;test	byte [_Bits],10h
 16845                                  	; 08/06/2023
 16846 00001888 F606[7CA0]20            	test	byte [_Bits],mask.lcase ; 20h ; MSDOS 6.0
 16847                                  	;jz	@F			;M010;lowercase not needed
 16848 0000188D 7405                    	jz	short dbare1
 16849 0000188F 89FE                    	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
 16850 00001891 E8C002                  	call	LowercaseString		;M010;path string is in BwdBuf
 16851                                  dbare1:
 16852                                  ;@@:	
 16853                                  	;xor	al,al			; AL = 0
 16854                                  	; 19/02/2023
 16855 00001894 31C0                    	xor	ax,ax
 16856 00001896 B9FFFF                  	mov	cx,0FFFFh
 16857 00001899 FC                      	cld
 16858 0000189A F2AE                    	repne	scasb			; ES:DI = ptr to byte after null
 16859 0000189C 4F                      	dec	di			; ES:DI = ptr to null byte
 16860                                  
 16861 0000189D 26807DFF5C              	cmp	byte [es:di-1],'\'
 16862                                  	;je	@F
 16863 000018A2 7403                    	je	short dbare2		; already terminated w/ '\'
 16864                                  
 16865                                  	;mov	ax,'\'			; AX = '\',0
 16866 000018A4 B05C                    	mov	al,'\'
 16867 000018A6 AB                      	stosw				; add to dir string
 16868                                  ;@@:
 16869                                  dbare2:
 16870                                  	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
 16871 000018A7 C706[91A0][2AA0]        	mov	word [string_ptr_2],BWDBUF
 16872                                  	;mov	dx,offset TRANGROUP:String_Buf_Ptr
 16873 000018AD BA[9793]                	mov	dx,string_buf_ptr
 16874                                  	;invoke	Std_Printf		; display device & directory path
 16875 000018B0 E85C3C                  	call	std_printf
 16876                                  dbNameExt:
 16877 000018B3 E82D00                  	call	DisplayDotForm		; display name.ext
 16878                                  	;invoke	CrLf2			; display cr/lf
 16879 000018B6 E86812                  	call	CRLF2
 16880                                  	; 19/02/2023
 16881                                  	;call	UseLine			;M007;Allow /p with /b
 16882                                  ;dbRet:
 16883                                  	;retn
 16884                                  
 16885                                  	; 19/02/2023
 16886                                  	;jmp	short UseLine
 16887                                  
 16888                                  ; ---------------------------------------------------------------------------
 16889                                  
 16890                                  ;***	UseLine - use a display line, start a new page if none left
 16891                                  ;
 16892                                  ;	ENTRY	nothing
 16893                                  ;
 16894                                  ;	EXIT	nothing
 16895                                  ;
 16896                                  ;	USED	flags
 16897                                  
 16898                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16899                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
 16900                                  UseLine:
 16901 000018B9 FF0E[1B9E]              	dec	word [LeftOnPage]
 16902 000018BD 833E[1B9E]02            	cmp	word [LeftOnPage],2
 16903 000018C2 771E                    	ja	short ulRet
 16904                                  	; 19/02/2023
 16905                                  	;call	EndPage
 16906                                  ;ulRet:
 16907                                  	;retn
 16908                                  
 16909                                  	; 19/02/2023
 16910                                  	;jmp	short EndPage
 16911                                  
 16912                                  ; ---------------------------------------------------------------------------
 16913                                  
 16914                                  ;***	EndPage - end the current display page
 16915                                  ;
 16916                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16917                                  ;		Current directory (on selected drive) is the one being listed
 16918                                  ;		Bits contains /p setting
 16919                                  ;
 16920                                  ;	EXIT	LeftOnPage = # lines left for next page
 16921                                  ;
 16922                                  ;	USED	AX,DX
 16923                                  ;
 16924                                  ;	EFFECTS
 16925                                  ;
 16926                                  ;	  Pause is invoked to display a message and wait for a keystroke.
 16927                                  ;	  BwdBuf (same as DirBuf) used to build directory string.
 16928                                  
 16929                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16930                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h
 16931                                  
 16932                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16933                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1BADh
 16934                                  EndPage:
 16935                                  	;;;test	Bits,mask pagd
 16936                                  	;;test	word [_Bits],2
 16937                                  	;test	byte [_Bits],2
 16938                                  	; 08/06/2023
 16939 000018C4 F606[7CA0]04            	test	byte [_Bits],mask.pagd ; 4 ; MSDOS 6.0
 16940 000018C9 7410                    	jz	short epNew		; paged display isn't enabled
 16941                                  
 16942 000018CB 53                      	push	bx			; save BX
 16943 000018CC 51                      	push	cx			; save CX
 16944                                  
 16945                                  	;invoke	Pause			; "Press any key to continue..."
 16946 000018CD E83506                  	call	PAUSE
 16947                                  
 16948                                  	;invoke	Build_Dir_String
 16949 000018D0 E8C90A                  	call	build_dir_string
 16950                                  	;mov	dx,offset TRANGROUP:DirCont_Ptr
 16951 000018D3 BA[1B94]                	mov	dx,dircont_ptr
 16952                                  	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
 16953 000018D6 E8283C                  	call	Printf_Crlf
 16954                                  
 16955 000018D9 59                      	pop	cx			; restore CX
 16956 000018DA 5B                      	pop	bx			; restore BX
 16957                                  epNew:	
 16958 000018DB A1[08A2]                	mov	ax,[LinPerPag]		; AX = # lines per page
 16959 000018DE 48                      	dec	ax			; AX = # lines till next EndPage
 16960 000018DF A3[1B9E]                	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
 16961                                  ulRet:	
 16962                                  	; 19/02/2023
 16963 000018E2 C3                      	retn
 16964                                  
 16965                                  ; ---------------------------------------------------------------------------
 16966                                  
 16967                                  ;***	DisplayDotForm - display filename in compressed dot format
 16968                                  ;
 16969                                  ;	Display name.ext, with no cr/lf's. Dot is displayed only
 16970                                  ;	if the filename has a nonblank extension.
 16971                                  ;
 16972                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16973                                  ;
 16974                                  ;	EXIT	DX = # char's displayed, including dot
 16975                                  ;
 16976                                  ;	USED	AX,CX,SI,DI
 16977                                  ;
 16978                                  ;	EFFECTS
 16979                                  ;
 16980                                  ;	  Filename is displayed in name.ext format.
 16981                                  ;
 16982                                  ;	NOTE
 16983                                  ;
 16984                                  ;	  We allow for bogus filenames that have blanks embedded
 16985                                  ;	  in the name or extension.
 16986                                  
 16987                                  ;	Bugbug:	might be a good performance gain if we buffered
 16988                                  ;	up the output and used DOS function 9.
 16989                                  
 16990                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16991                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h
 16992                                  
 16993                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 16994                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1953h
 16995                                  DisplayDotForm:
 16996 000018E3 1E                      	push	ds			; save TRANGROUP seg addr
 16997 000018E4 06                      	push	es			; save ES
 16998 000018E5 2EA1[F59D]              	mov	ax,[cs:TPA]		; AX = TPA seg addr
 16999 000018E9 8ED8                    	mov	ds,ax			; DS:BX = ptr to entry
 17000                                  	;assume	ds:nothing
 17001 000018EB 8EC0                    	mov	es,ax			; ES:BX = ptr to entry
 17002                                  
 17003                                  	; 08/06/2023
 17004                                  	;mov	di,bx			; ES:DI = ptr to entry
 17005                                  	;;;add	di,filename + size filename - 1
 17006                                  	;add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
 17007                                  	;;mov	cx,size filename	; CX = length of name field
 17008                                  	;mov	cx,8
 17009                                  	; 08/06/2023
 17010 000018ED B90800                  	mov	cx,8
 17011 000018F0 89CF                    	mov	di,cx
 17012 000018F2 01DF                    	add	di,bx
 17013                                  
 17014 000018F4 B020                    	mov	al,' '
 17015 000018F6 FD                      	std				; scan down
 17016 000018F7 F3AE                    	repe	scasb			; scan for nonblank
 17017                                  
 17018                                  ;	Assume file name has at least one character.
 17019                                  
 17020 000018F9 41                      	inc	cx			; CX = # chars in name
 17021 000018FA 89CA                    	mov	dx,cx			; DX = # chars to be displayed
 17022                                  
 17023 000018FC 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 17024                                  	;;add	si,filename		; DS:SI = ptr to name
 17025                                  	;add	si,1 
 17026                                  	;		; add si,EntryStruc.filename
 17027                                  	; 25/04/2023
 17028 000018FE 46                      	inc	si
 17029                                  NextNameChar:
 17030 000018FF FC                      	cld
 17031 00001900 AC                      	lodsb				; AL = next char
 17032                                  
 17033                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 17034                                  	;;test	word [ss:_Bits],10h
 17035                                  	;test	byte [ss:_Bits],10h
 17036                                  	; 08/06/2023
 17037 00001901 36F606[7CA0]20          	test	byte [ss:_Bits],mask.lcase ; 20h ; MSDOS 6.0
 17038                                  	;jz	short @F		;M010;lowercase not required
 17039 00001907 7403                    	jz	short ddf1
 17040 00001909 E83D02                  	call	LowerCase		;M010;filename char is in AL
 17041                                  ddf1:
 17042                                  ;@@:	
 17043                                  	;invoke	Print_Char		; display it
 17044 0000190C E83E0A                  	call	PRINT_CHAR
 17045 0000190F E2EE                    	loop	NextNameChar
 17046                                  
 17047                                  ;	Now do extension.
 17048                                  
 17049 00001911 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 17050                                  	;add	di,fileext + size fileext - 1
 17051 00001913 83C70B                  	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
 17052                                  	;mov	cx,size fileext		; CX = length of ext field
 17053 00001916 B90300                  	mov	cx,3
 17054 00001919 B020                    	mov	al,' '
 17055 0000191B FD                      	std				; scan down
 17056 0000191C F3AE                    	repe	scasb			; scan for nonblank
 17057 0000191E 7420                    	je	short ddDone		; no nonblank chars in ext
 17058                                  
 17059 00001920 41                      	inc	cx			; CX = # chars in ext
 17060 00001921 01CA                    	add	dx,cx			; DX = total # chars to be displayed
 17061 00001923 42                      	inc	dx			;      including dot
 17062                                  
 17063 00001924 B02E                    	mov	al,'.'
 17064 00001926 E8240A                  	call	PRINT_CHAR
 17065 00001929 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 17066                                  	;add	si,fileext		; DS:SI = ptr to ext
 17067 0000192B 83C609                  	add	si,9
 17068                                  
 17069                                  NextExtChar:
 17070 0000192E FC                      	cld
 17071 0000192F AC                      	lodsb				; AL = next char
 17072                                  
 17073                                  	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
 17074                                  	;;test	word [cs:_Bits],10h
 17075                                  	;test	byte [cs:_Bits],10h
 17076                                  	; 08/06/2023
 17077 00001930 2EF606[7CA0]20          	test	byte [cs:_Bits],mask.lcase ; 20h ; MSDOS 6.0
 17078                                  	;jz	short @F		;M010;lowercase not required
 17079 00001936 7403                    	jz	short ddf2
 17080 00001938 E80E02                  	call	LowerCase		;M010;fileext char is in AL
 17081                                  ;@@:	
 17082                                  ddf2:
 17083                                  	;invoke	Print_Char		; display it
 17084 0000193B E80F0A                  	call	PRINT_CHAR
 17085 0000193E E2EE                    	loop	NextExtChar
 17086                                  ddDone:
 17087 00001940 07                      	pop	es			; restore ES
 17088 00001941 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 17089                                  	;assume	ds:TRANGROUP
 17090 00001942 FC                      	cld				; leave direction flag = up
 17091 00001943 C3                      	retn
 17092                                  
 17093                                  ; ---------------------------------------------------------------------------
 17094                                  
 17095                                  ;***	DisplayFile - display file entry, update counters
 17096                                  ;
 17097                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17098                                  ;		Bits contains /w, /p settings
 17099                                  ;
 17100                                  ;	EXIT	nothing
 17101                                  ;
 17102                                  ;	USED	AX,CX,DX,SI,DI,BP
 17103                                  ;
 17104                                  ;	EFFECTS
 17105                                  ;
 17106                                  ;	  Entry is displayed.
 17107                                  ;	  If not /b,
 17108                                  ;	    Cursor is left at end of entry on screen.
 17109                                  ;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 17110                                  ;	  If /b,
 17111                                  ;	    Cursor is left at beginning of next line.
 17112                                  ;	    Cnt's and Siz's aren't updated.
 17113                                  
 17114                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17115                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh
 17116                                  	
 17117                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17118                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:19B9h
 17119                                  
 17120                                  DisplayFile:
 17121                                  	;;;test	Bits,mask bare
 17122                                  	;;test	word [_Bits],8
 17123                                  	;test	byte [_Bits],8
 17124                                  	; 08/06/2023
 17125 00001944 F606[7CA0]10            	test	byte [_Bits],mask.bare ; 16 ; MSDOS 6.0
 17126 00001949 7405                    	jz	short dfNorm		; not /b - do normal display
 17127                                  
 17128 0000194B E81FFF                  	call	DisplayBare		; display file in bare format
 17129 0000194E EB22                    	jmp	short dfRet
 17130                                  dfNorm:	
 17131 00001950 E88200                  	call	DisplayNext		; pos'n cursor for next entry
 17132                                  	;;;test	Bits,mask wide
 17133                                  	;;test	word [_Bits],1
 17134                                  	;test	byte [_Bits],1
 17135                                  	; 08/06/2023
 17136 00001953 F606[7CA0]02            	test	byte [_Bits],mask.wide ; 2 ; MSDOS 6.0
 17137 00001958 7405                    	jz	short dfFull		; full format
 17138 0000195A E87401                  	call	DisplayWide		; wide format
 17139 0000195D EB10                    	jmp	short dfCnt
 17140                                  dfFull:	
 17141 0000195F E83E00                  	call	DisplayName		; display filename & extension
 17142 00001962 E89700                  	call	DisplayTheRest		; display size, date, time
 17143                                  	
 17144                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 17145                                  	; MSDOS 6.0
 17146                                  ;ifdef DBLSPACE_HOOKS
 17147                                  	;;test	Bits,mask cratio
 17148                                  	;test	word [_Bits],1
 17149 00001965 F606[7CA0]01            	test	byte [_Bits],mask.cratio
 17150                                  					; display compression ratio
 17151 0000196A 7403                    	jz	short dfCnt
 17152 0000196C E81A01                  	call	DisplayCompRatio
 17153                                  ;endif
 17154                                  
 17155                                  dfCnt:
 17156 0000196F E8CEFE                  	call	CountFile		; update file counters
 17157                                  dfRet:
 17158                                  dhRet:	; 19/02/2023
 17159 00001972 C3                      	retn
 17160                                  
 17161                                  ; ---------------------------------------------------------------------------
 17162                                  
 17163                                  ;***	DisplayHeader - display directory header of working directory
 17164                                  ;
 17165                                  ;	ENTRY	Current directory (on selected drive) is the one to display
 17166                                  ;		LeftOnPage = # lines left on display page
 17167                                  ;
 17168                                  ;	EXIT	nothing
 17169                                  ;
 17170                                  ;	ERROR EXIT
 17171                                  ;
 17172                                  ;	  Build_Dir_String will exit through CError with "Invalid drive
 17173                                  ;	   specification" if there's a problem obtaining the current
 17174                                  ;	   directory pathname.
 17175                                  ;
 17176                                  ;	USED	AX,DX,SI,DI
 17177                                  ;
 17178                                  ;	EFFECTS
 17179                                  ;
 17180                                  ;	  BwdBuf (which is really the same buffer as DirBuf, which
 17181                                  ;	   we are using for the DTA) contains the directory string.
 17182                                  ;	  LeftOnPage is adjusted.
 17183                                  
 17184                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17185                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17186                                  
 17187                                  DisplayHeader:
 17188                                  	;;;test	Bits,mask bare
 17189                                  	;;test	word [_Bits],8
 17190                                  	;test	byte [_Bits],8
 17191                                  	; 08/06/2023
 17192 00001973 F606[7CA0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 17193 00001978 75F8                    	jnz	short dhRet		; /b - don't display header
 17194                                  
 17195                                  	;;;test	Bits,mask subd
 17196                                  	;;test	word [_Bits],4
 17197                                  	;test	byte [_Bits],4
 17198                                  	; 08/06/2023
 17199 0000197A F606[7CA0]08            	test	byte [_Bits],mask.subd ; 8 ; MSDOS 6.0
 17200 0000197F 7408                    	jz	short dhNorm		; not /s
 17201                                  
 17202                                  ;	For subdirectory listings, put a blank line before the header.
 17203                                  
 17204                                  	;invoke	Crlf2			; start with a blank line
 17205 00001981 E89D11                  	call	CRLF2
 17206 00001984 E832FF                  	call	UseLine
 17207 00001987 EB05                    	jmp	short dhCom
 17208                                  dhNorm:
 17209 00001989 B020                    	mov	al,' ' ; 20h
 17210                                  	;mov	al,BLANK		; if not /s, precede by a blank
 17211 0000198B E8BF09                  	call	PRINT_CHAR		; print a leading blank
 17212                                  dhCom:
 17213 0000198E E80B0A                  	call	build_dir_string
 17214 00001991 BA[1793]                	mov	dx,dirhead_ptr
 17215 00001994 E8783B                  	call	std_printf		; print header & cr/lf
 17216 00001997 E81FFF                  	call	UseLine
 17217 0000199A E88411                  	call	CRLF2			; another cr/lf
 17218                                  	;call	UseLine
 17219                                  ;dhRet:
 17220                                  	;retn
 17221                                  
 17222                                  	; 19/02/2023
 17223 0000199D E919FF                  	jmp	UseLine
 17224                                  
 17225                                  ; ---------------------------------------------------------------------------
 17226                                  
 17227                                  ;***	DisplayName - display file name & extension
 17228                                  ;
 17229                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17230                                  ;
 17231                                  ;	EXIT	nothing
 17232                                  ;
 17233                                  ;	USED	AX,CX,DX,SI,DI
 17234                                  ;
 17235                                  ;	EFFECTS
 17236                                  ;
 17237                                  ;	  Filename & extension are displayed in spread format.
 17238                                  ;	  Cursor is left at end of extension.
 17239                                  
 17240                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17241                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17242                                  
 17243                                  DisplayName:
 17244 000019A0 1E                      	push	ds			; save TRANGROUP seg addr
 17245 000019A1 8E1E[F59D]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 17246                                  	;assume	ds:nothing
 17247 000019A5 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 17248                                  	;;add	si,filename		; DS:SI = ptr to filename
 17249                                  	;add	si,1  ; EntryStruc.filename
 17250                                  	; 08/06/2023
 17251 000019A7 46                      	inc	si
 17252 000019A8 BF[5B9F]                	mov	di,CHARBUF		; ES:DI = ptr to CharBuf
 17253                                  
 17254 000019AB B90800                  	mov	cx,8
 17255 000019AE FC                      	cld
 17256 000019AF F3A4                    	rep	movsb			; move filename to CharBuf
 17257 000019B1 B020                    	mov	al,' '
 17258 000019B3 AA                      	stosb				; add a blank
 17259                                  	;mov	cx,3
 17260                                  	; 08/06/2023
 17261 000019B4 B103                    	mov	cl,3
 17262 000019B6 F3A4                    	rep	movsb			; add extension
 17263 000019B8 30C0                    	xor	al,al
 17264 000019BA AA                      	stosb				; add a NULL
 17265                                  
 17266 000019BB 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 17267                                  	;assume	ds:TRANGROUP
 17268                                  
 17269                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 17270                                  	;;test	word [_Bits],10h
 17271                                  	;test	byte [_Bits],10h
 17272                                  	; 08/06/2023
 17273 000019BC F606[7CA0]20            	test	byte [_Bits],mask.lcase ; 20h ; MSDOS 6.0
 17274 000019C1 7406                    	jz	short dn1		;M010;lowercase not required
 17275 000019C3 BE[5B9F]                	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
 17276 000019C6 E88B01                  	call	LowercaseString		;M010;filename.ext string is in CharBuf
 17277                                  dn1:	
 17278 000019C9 C706[91A0][5B9F]        	mov	word [string_ptr_2],CHARBUF
 17279 000019CF BA[9793]                	mov	dx,string_buf_ptr
 17280                                  	;call	std_printf		; print filename & extension
 17281                                  	;retn
 17282                                  	; 19/02/2023
 17283 000019D2 E93A3B                  	jmp	std_printf
 17284                                  
 17285                                  ; ---------------------------------------------------------------------------
 17286                                  
 17287                                  ;***	DisplayNext - move display cursor to next entry position
 17288                                  ;
 17289                                  ;	ENTRY	LeftOnLine = # entries can still be printed on this line
 17290                                  ;		LeftOnPage = # lines can still be printed for this page
 17291                                  ;		FileCnt = # files in this dir displayed before this one
 17292                                  ;		Bits contains /w setting
 17293                                  ;
 17294                                  ;	EXIT	nothing
 17295                                  ;
 17296                                  ;	USED	AX,DX
 17297                                  ;
 17298                                  ;	EFFECTS
 17299                                  ;
 17300                                  ;	  LeftOnLine will be updated to reflect the entry about to be
 17301                                  ;	   displayed.
 17302                                  ;	  LeftOnPage may be updated.
 17303                                  
 17304                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17305                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17306                                  	
 17307                                  DisplayNext:
 17308 000019D5 833E[1D9E]00            	cmp	word [FileCnt],0
 17309 000019DA 7415                    	je	short dn1st		; 1st file in directory
 17310 000019DC 803E[199E]00            	cmp	byte [LeftOnLine],0
 17311 000019E1 7E08                    	jng	short dnEol	; jle	; no more room on this line
 17312                                  
 17313                                  ;	We are in wide mode (LeftOnLine is always 0 otherwise) and
 17314                                  ;	we still have room for more on this line.
 17315                                  ;	Tab to next position.
 17316                                  
 17317 000019E3 BA[A693]                	mov	dx,tab_ptr
 17318 000019E6 E8263B                  	call	std_printf
 17319 000019E9 EB0C                    	jmp	short dnDone
 17320                                  dnEol:	
 17321                                  ;	Start this entry on a new line.
 17322                                  
 17323 000019EB E83311                  	call	CRLF2		; start on new line
 17324 000019EE E8C8FE                  	call	UseLine
 17325                                  dn1st:
 17326 000019F1 A0[1A9E]                	mov	al,[PerLine]
 17327 000019F4 A2[199E]                	mov	[LeftOnLine],al	; reset # entries left on line
 17328                                  
 17329                                  dnDone:
 17330 000019F7 FE0E[199E]              	dec	byte [LeftOnLine]
 17331                                  				; reflect the entry about to be displayed
 17332 000019FB C3                      	retn
 17333                                  
 17334                                  ; ---------------------------------------------------------------------------
 17335                                  
 17336                                  ;***	DisplayTheRest - display file size/dir, date, time
 17337                                  ;
 17338                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17339                                  ;		Display cursor is at end of file extension
 17340                                  ;
 17341                                  ;	EXIT	nothing
 17342                                  ;
 17343                                  ;	USED	AX,CX,DX,SI,DI,BP
 17344                                  ;
 17345                                  ;	EFFECTS
 17346                                  ;
 17347                                  ;	  File size, date, & time are displayed.
 17348                                  
 17349                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17350                                  
 17351                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17352                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1A7Ch
 17353                                  DisplayTheRest:
 17354 000019FC 06                      	push	es			; save TRANGROUP seg addr
 17355 000019FD 8E06[F59D]              	mov	es,[TPA]		; ES = TPA seg addr
 17356 00001A01 89DD                    	mov	bp,bx			; BP = offset of entry in TPA
 17357                                  	;;test	es:[bp].fileattr,ATTR_DIRECTORY
 17358                                  	;test	byte [es:bp+EntryStruc.fileattr],10h
 17359 00001A03 26F6460C10              	test	byte [es:bp+12],ATTR_DIRECTORY
 17360 00001A08 7415                    	jz	short drNonDir		; not a directory file
 17361                                  
 17362                                  ;	For a directory file, display <DIR> instead of size.
 17363                                  
 17364 00001A0A BA[A993]                	mov	dx,dmes_ptr
 17365 00001A0D E8FF3A                  	call	std_printf
 17366                                  	; 08/06/2023
 17367                                  	;jmp	short drCom
 17368                                  
 17369                                  	; 08/06/2023
 17370                                  	; MSDOS 6.22 COMMAND.COM (disassembled source code)
 17371 00001A10 F606[9393]40            	test    byte [screen_f_1],40h	; 80 columns ?
 17372 00001A15 7406                    	jz      short dr_0      	; no
 17373 00001A17 BA[AC93]                	mov     dx,space_4_ptr		; 4 space chars
 17374 00001A1A E8F23A                  	call    std_printf
 17375                                  dr_0:
 17376 00001A1D EB16                    	jmp	short drCom		; skip to common fields
 17377                                  
 17378                                  drNonDir:
 17379                                  ;	For a non-directory file, display file size.
 17380                                  
 17381                                  	;;mov	dx,word ptr es:[bp].filesize
 17382                                  	;mov	dx,[es:bp+EntryStruc.filesize]
 17383 00001A1F 268B5611                	mov	dx,[es:bp+17]
 17384 00001A23 8916[8DA0]              	mov	[File_Size_Low],dx
 17385                                  	;;mov	dx,word ptr es:[bp].filesize+2
 17386                                  	;mov	dx,[es:bp+EntryStruc.filesize+2]
 17387 00001A27 268B5613                	mov	dx,[es:bp+19]
 17388 00001A2B 8916[8FA0]              	mov	[File_Size_High],dx
 17389 00001A2F BA[8993]                	mov	dx,disp_file_size_ptr
 17390 00001A32 E8DA3A                  	call	std_printf
 17391                                  drCom:
 17392                                  ;	For all files, display date & time.
 17393                                  
 17394                                  	;;mov	ax,es:[bp].filedate	; AX = date word
 17395                                  	;mov	ax,[es:bp+EntryStruc.filedate]
 17396 00001A35 268B460F                	mov	ax,[es:bp+15]
 17397 00001A39 09C0                    	or	ax,ax			; test for null date (DOS 1.x)
 17398 00001A3B 7448                    	jz	short drDone		; no date, skip date/time display
 17399 00001A3D 89C3                    	mov	bx,ax			; BX = date word
 17400 00001A3F 83E01F                  	and	ax,1Fh			; AX = day of month
 17401 00001A42 88C2                    	mov	dl,al			; DL = day of month
 17402 00001A44 89D8                    	mov	ax,bx			; AX = date word
 17403 00001A46 B105                    	mov	cl,5
 17404 00001A48 D3E8                    	shr	ax,cl			; shift day out
 17405 00001A4A 240F                    	and	al,0Fh			; AL = month
 17406 00001A4C 88C6                    	mov	dh,al			; DH = month
 17407 00001A4E 88F9                    	mov	cl,bh
 17408 00001A50 D0E9                    	shr	cl,1			; CL = year - 1980
 17409 00001A52 30ED                    	xor	ch,ch			; CX = year - 1980
 17410 00001A54 83C150                  	add	cx,80			; CX = 2-digit year
 17411 00001A57 80F964                  	cmp	cl,100
 17412 00001A5A 7203                    	jb	short dr_1		; not year 2000 yet, skip ahead
 17413 00001A5C 80E964                  	sub	cl,100			; adjust for 21st century
 17414                                  dr_1:	
 17415 00001A5F 86F2                    	xchg	dh,dl			; DX = month/day
 17416 00001A61 890E[EA93]              	mov	[DirDat_Yr],cx		; move year to msg block
 17417 00001A65 8916[EC93]              	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
 17418                                  	;;mov	cx,es:[bp].filetime	; CX = file time
 17419                                  	;mov	cx,[es:bp+EntryStruc.filetime]
 17420 00001A69 268B4E0D                	mov	cx,[es:bp+13]
 17421 00001A6D E310                    	jcxz	drPrint			; no time field - go print
 17422 00001A6F D1E9                    	shr	cx,1
 17423 00001A71 D1E9                    	shr	cx,1
 17424 00001A73 D1E9                    	shr	cx,1			; CH = hours
 17425 00001A75 D0E9                    	shr	cl,1
 17426 00001A77 D0E9                    	shr	cl,1			; CL = minutes
 17427 00001A79 86E9                    	xchg	ch,cl			; CX = hr/min
 17428 00001A7B 890E[F593]              	mov	[DirTim_Hr_Min],cx	; move time to msg block
 17429                                  drPrint:
 17430 00001A7F BA[E593]                	mov	dx,dirdattim_ptr
 17431 00001A82 E88A3A                  	call	std_printf		; print date & time
 17432                                  drDone:
 17433 00001A85 07                      	pop	es			; ES = TRANGROUP seg addr again	
 17434 00001A86 89EB                    	mov	bx,bp			; BX = offset of entry in TPA again
 17435                                  ;dtrRet:
 17436                                  	; 19/02/2023
 17437 00001A88 C3                      	retn
 17438                                  
 17439                                  ; ---------------------------------------------------------------------------
 17440                                  ; MSDOS 6.0
 17441                                  
 17442                                  ;ifdef DBLSPACE_HOOKS
 17443                                  
 17444                                  ;***	DisplayCompRatio - display compression ratio
 17445                                  ;
 17446                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17447                                  ;
 17448                                  ;	EXIT	nothing
 17449                                  ;
 17450                                  ;	USED	AX,CX,DX
 17451                                  ;
 17452                                  ;	EFFECTS
 17453                                  ;
 17454                                  ;	  File compression ratio is displayed.
 17455                                  
 17456                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17457                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1B09h
 17458                                  
 17459                                  DisplayCompRatio:	;proc
 17460 00001A89 06                      	push	es			; save TRANGROUP seg addr
 17461 00001A8A 8E06[F59D]              	mov	es,[TPA]		; ES = TPA seg addr
 17462                                  	;;mov	al,es:[bx].compratio
 17463                                  	;mov	al,[es:bx+EntryStruc.compratio]
 17464 00001A8E 268A4715                	mov	al,[es:bx+15h]
 17465 00001A92 3CFF                    	cmp	al,0FFh			; invalid/no compression ratio?
 17466 00001A94 7417                    	je	short dcrRet
 17467                                  
 17468 00001A96 88C4                    	mov	ah,al			; unpack compression ratio
 17469 00001A98 B104                    	mov	cl,4
 17470 00001A9A D2EC                    	shr	ah,cl			; isolate whole number portion
 17471 00001A9C FEC4                    	inc	ah			; 0-15 = 1-16
 17472 00001A9E 240F                    	and	al,0Fh 			; isolate tenths
 17473                                  
 17474 00001AA0 8826[98A0]              	mov	[Dir_CRatio_1],ah
 17475 00001AA4 A2[99A0]                	mov	[Dir_CRatio_2],al
 17476                                  	;mov	dx,offset TRANGROUP:DirCompRatio_Ptr
 17477                                  	;invoke	Std_Printf
 17478 00001AA7 BA[5594]                	mov	dx,DirCompRatio_Ptr
 17479 00001AAA E8623A                  	call	std_printf	
 17480                                  dcrRet:
 17481 00001AAD 07                      	pop	es
 17482                                  dtrRet:		; 08/06/2023
 17483 00001AAE C3                      	retn
 17484                                  
 17485                                  ;DisplayCompRatio	;endp
 17486                                  
 17487                                  ;endif
 17488                                  
 17489                                  ; ---------------------------------------------------------------------------
 17490                                  
 17491                                  ;***	DisplayTrailer - display trailing lines for directory listing
 17492                                  ;
 17493                                  ;	ENTRY	LeftOnPage = # lines left on display page
 17494                                  ;		FileCnt = # files listed
 17495                                  ;		FileSiz = total size of files listed
 17496                                  ;
 17497                                  ;	EXIT	nothing
 17498                                  ;
 17499                                  ;	USED
 17500                                  ;
 17501                                  ;	EFFECTS
 17502                                  ;
 17503                                  ;	  Trailing info lines are displayed
 17504                                  
 17505                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17506                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17507                                  
 17508                                  DisplayTrailer:
 17509                                  	;;;test	Bits,mask bare
 17510                                  	;;test	word [_Bits],8
 17511                                  	;test	byte [_Bits],8
 17512                                  	; 08/06/2023
 17513 00001AAF F606[7CA0]10            	test	byte [_Bits],mask.bare ; 10h ; MSDOS 6.0
 17514 00001AB4 75F8                    	jnz	short dtrRet		; /b - don't display trailer
 17515                                  
 17516 00001AB6 E86810                  	call	CRLF2			; start on new line
 17517 00001AB9 E8FDFD                  	call	UseLine
 17518 00001ABC A1[1D9E]                	mov	ax,[FileCnt]		; AX = # files found
 17519                                  
 17520                                  ;	DisplayTotals uses this entry point.
 17521                                  ;
 17522                                  DisplayCntSiz:
 17523                                  ;	AX = # files
 17524                                  ;	FileSiz = dword total size of files
 17525                                  
 17526 00001ABF A3[96A0]                	mov	[Dir_Num],ax		; load # files
 17527 00001AC2 BA[1092]                	mov	dx,dirmes_ptr		; DX = ptr to message block
 17528 00001AC5 E8473A                  	call	std_printf		; "nnn File(s)"
 17529                                  
 17530 00001AC8 BA[0194]                	mov	dx,bytes_ptr
 17531 00001ACB E8413A                  	call	std_printf		; "nnn bytes",cr,lf
 17532                                  	; 19/02/2023
 17533                                  	;call	UseLine
 17534                                  ;dtrRet:
 17535                                  	;retn
 17536                                  
 17537                                  	; 19/02/2023
 17538 00001ACE E9E8FD                  	jmp	UseLine
 17539                                  
 17540                                  ; ---------------------------------------------------------------------------
 17541                                  
 17542                                  ;***	DisplayWide - display filename in wide format
 17543                                  ;
 17544                                  ;	ENTRY	BX = offset of entry in TPA buffer
 17545                                  ;
 17546                                  ;	EXIT	nothing
 17547                                  ;
 17548                                  ;	USED	AX,CX,DX,SI,DI
 17549                                  ;
 17550                                  ;	EFFECTS
 17551                                  ;
 17552                                  ;	  Name.ext is displayed. Cursor left at end of field (padded
 17553                                  ;	  with blanks). Subdirectory files are displayed as [name.ext].
 17554                                  
 17555                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17556                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah
 17557                                  
 17558                                  DisplayWide:
 17559 00001AD1 1E                      	push	ds			; save TRANGROUP seg addr
 17560 00001AD2 8E1E[F59D]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 17561                                  	;assume	ds:nothing
 17562                                  
 17563                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 17564                                  	;test	byte [bx+EntryStruc.fileattr],10h
 17565 00001AD6 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 17566 00001ADA 9C                      	pushf	; 03/08/2024
 17567 00001ADB 7405                    	jz	short dw1		; not a subdirectory file
 17568 00001ADD B05B                    	mov	al,'['
 17569 00001ADF E86B08                  	call	PRINT_CHAR		; prefix subdirectory
 17570                                  dw1:	
 17571 00001AE2 E8FEFD                  	call	DisplayDotForm		; display name.ext
 17572                                  
 17573                                  ;	DX = # chars displayed in name.ext
 17574                                  
 17575                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 17576                                  	;test	byte [bx+EntryStruc.fileattr],10h
 17577                                  	; 03/08/2024
 17578                                  	;test	byte [bx+12],ATTR_DIRECTORY
 17579 00001AE5 9D                      	popf	; 03/08/2024
 17580 00001AE6 7405                    	jz	short dw2		; not a subdirectory file
 17581 00001AE8 B05D                    	mov	al,']'
 17582 00001AEA E86008                  	call	PRINT_CHAR		; postfix subdirectory
 17583                                  dw2:
 17584                                  ;	Pad field with blanks.
 17585                                  
 17586                                  	;mov	cx,size filename + size fileext + 1
 17587 00001AED B90C00                  	mov	cx,12 ; 8+3+1
 17588                                  					; CX = field size
 17589 00001AF0 29D1                    	sub	cx,dx			; CX = # pad char's
 17590 00001AF2 E307                    	jcxz	dwDone
 17591 00001AF4 B020                    	mov	al,' '
 17592                                  dw3:	
 17593 00001AF6 E85408                  	call	PRINT_CHAR
 17594 00001AF9 E2FB                    	loop	dw3
 17595                                  dwDone:	
 17596 00001AFB 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 17597                                  	;assume	ds:TRANGROUP
 17598 00001AFC C3                      	retn
 17599                                  
 17600                                  ; ---------------------------------------------------------------------------
 17601                                  
 17602                                  ;***	GetDriveLtr - get target drive letter
 17603                                  ;
 17604                                  ;	ENTRY	FCB contains drive #
 17605                                  ;
 17606                                  ;	EXIT	AX = "d:"
 17607                                  ;
 17608                                  ;	USED	nothing
 17609                                  
 17610                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17611                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
 17612                                  GetDriveLtr:
 17613 00001AFD A05C00                  	mov	al,[FCB] ; 5Ch	; AL = target drive #
 17614 00001B00 08C0                    	or	al,al
 17615 00001B02 7505                    	jnz	short gdl1	; not current drive default, skip ahead
 17616 00001B04 A0[059E]                	mov	al,[CURDRV]	; AL = current drive #
 17617 00001B07 FEC0                    	inc	al		; AL = 1-based drive #
 17618                                  gdl1:	
 17619 00001B09 0440                    	add	al,'A'-1 ; 40h	; AL = target drive letter
 17620 00001B0B B43A                    	mov	ah,':'		; AX = "d:"
 17621 00001B0D C3                      	retn
 17622                                  
 17623                                  ; ---------------------------------------------------------------------------
 17624                                  
 17625                                  ;***	SetupParamError - set up for Std_EPrintf parameter parse error message
 17626                                  ;
 17627                                  ;	Do for our /O and /A string parsers what Parse_With_Msg does
 17628                                  ;	for system parser calls. Set up a message substitution block,
 17629                                  ;	etc. for invalid value strings. I copied the procedure from
 17630                                  ;	Setup_Parse_Error_Msg.
 17631                                  ;
 17632                                  ;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
 17633                                  ;		
 17634                                  ;
 17635                                  ;	EXIT	AX = system parser error return code for bad param format
 17636                                  ;		DX = ptr to message description block for Std_EPrintf
 17637                                  ;
 17638                                  ;	USED	SI
 17639                                  ;
 17640                                  ;	EFFECTS
 17641                                  ;
 17642                                  ;	  Msg_Disp_Class = parse error message class
 17643                                  ;	  Message block (see DX) is set up for parse error message
 17644                                  
 17645                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17646                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
 17647                                  SetupParamError:
 17648 00001B0E B80900                  	mov	ax,9			; parse error #
 17649 00001B11 C606[CE91]02            	mov	byte [msg_disp_class],parse_msg_class
 17650                                  	;mov	byte [msg_disp_class],2
 17651 00001B16 A3[D091]                	mov	[extend_buf_ptr],ax
 17652                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 17653 00001B19 8B7704                  	mov	si,[bx+4]
 17654 00001B1C 8936[91A0]              	mov	[string_ptr_2],si
 17655 00001B20 C606[D291]01            	mov	byte [extend_buf_sub],one_subst
 17656                                  	;mov	byte [extend_buf_sub],1
 17657 00001B25 BA[D091]                	mov	dx,extend_buf_ptr
 17658 00001B28 C3                      	retn
 17659                                  
 17660                                  ; ---------------------------------------------------------------------------
 17661                                  
 17662                                  ;***	ZeroTotals - zero grand total file count, size
 17663                                  ;
 17664                                  ;	ENTRY	nothing
 17665                                  ;
 17666                                  ;	EXIT	nothing
 17667                                  ;
 17668                                  ;	USED	AX
 17669                                  ;
 17670                                  ;	EFFECTS
 17671                                  ;
 17672                                  ;	  FileCntTotal & FileSizTotal are zeroed.
 17673                                  ;
 17674                                  ;	NOTES
 17675                                  ;
 17676                                  ;	  FileCntTotal throuth csecUsedTotal must be together!
 17677                                  
 17678                                  ; 05/06/2023
 17679                                  ;ifdef DBLSPACE_HOOKS
 17680                                  ;csecSIZE EQU size csecUsed + size csecUsedDir + size csecUsedTotal
 17681                                  ;ccluSIZE EQU size ccluUsed + size ccluUsedDir + size ccluUsedTotal
 17682                                  ;endif
 17683                                  
 17684                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17685                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h
 17686                                  
 17687                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 17688                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1C08h	
 17689                                  ZeroTotals:
 17690 00001B29 BF[239E]                	mov	di,FileCntTotal
 17691                                  
 17692                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 17693                                  	;;mov	cx,size FileCntTotal+size FileSizTotal
 17694                                  	;mov	cx,8
 17695                                  	;ifdef DBLSPACE_HOOKS
 17696                                  	;mov	cx,size FileCntTotal+size FileSizTotal+csecSIZE+ccluSIZE
 17697                                  	;endif
 17698 00001B2C B91A00                  	mov	cx,26
 17699                                  
 17700 00001B2F 30C0                    	xor	al,al
 17701 00001B31 F3AA                    	rep	stosb
 17702 00001B33 C3                      	retn	
 17703                                  
 17704                                  ; ---------------------------------------------------------------------------
 17705                                  
 17706                                  ;***	CtrlCHandler - our own control-c handler
 17707                                  ;
 17708                                  ;	Make sure user's default directory gets restored. See notes
 17709                                  ;	at InstallCtrlCHandler.
 17710                                  ;
 17711                                  ;	ENTRY	control-c
 17712                                  ;
 17713                                  ;	EXIT	to OldCtrlCHandler
 17714                                  ;
 17715                                  ;	USED	DS,flags
 17716                                  ;
 17717                                  ;	EFFECTS
 17718                                  ;
 17719                                  ;	  Restore user's default directory.
 17720                                  ;
 17721                                  ;	NOTES
 17722                                  ;
 17723                                  ;	  This handler is only installed after calling PathCrunch,
 17724                                  ;	  which sets UserDir1, so the restoration will work.
 17725                                  ;
 17726                                  ;	  The original control-c vector will be restored, whether
 17727                                  ;	  or not this one is invoked, in the HeadFix routine.
 17728                                  
 17729                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17730                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh
 17731                                  
 17732                                  	; 05/06/2023 - Retro DOS v4.2 COMMAND.COM
 17733                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1C13h ; *
 17734                                  
 17735                                  CtrlCHandler:	;proc far
 17736                                  
 17737                                  ;SR;
 17738                                  ; Save all registers used: ds, dx, ax. I know ax is being used by the 
 17739                                  ;CtrlC handler, am not sure about ds & dx. Save them to be safe
 17740                                  ;
 17741 00001B34 1E                      	push	ds
 17742 00001B35 0E                      	push	cs
 17743 00001B36 1F                      	pop	ds			; DS = TRANGROUP seg addr
 17744 00001B37 50                      	push	ax
 17745 00001B38 53                      	push	bx ; *
 17746 00001B39 52                      	push	dx
 17747 00001B3A E8A101                  	call	CloseCVF ; * 		; close CVF file if open
 17748 00001B3D E89E0E                  	call	RestUDir		; restore user's default directory
 17749 00001B40 5A                      	pop	dx
 17750 00001B41 5B                      	pop	bx ; *
 17751 00001B42 58                      	pop	ax
 17752 00001B43 1F                      	pop	ds
 17753 00001B44 2EFF2E[B5A9]            	jmp	far [cs:OldCtrlCHandler]
 17754                                  					; go to previous int 23 handler
 17755                                  
 17756                                  ; ---------------------------------------------------------------------------
 17757                                  
 17758                                  ;M010;start
 17759                                  ;***	LowerCase - convert ASCII character in AL to lowercase
 17760                                  ;
 17761                                  ;	ENTRY	AL = character to be displayed
 17762                                  ;
 17763                                  ;	EXIT	AL is lowercase
 17764                                  ;
 17765                                  ;	USED	nothing
 17766                                  
 17767                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17768                                  LowerCase:
 17769 00001B49 3C41                    	cmp	al,'A'		; ensure AL is in range 'A'-'Z'
 17770 00001B4B 7206                    	jb	short lcRet
 17771 00001B4D 3C5A                    	cmp	al,'Z'
 17772 00001B4F 7702                    	ja	short lcRet
 17773                                  
 17774 00001B51 0C20                    	or	al,20h		; convert to ASCII lowercase (UpperCase+32)-->LowerCase
 17775                                  lcRet:
 17776 00001B53 C3                      	retn
 17777                                  
 17778                                  ; ---------------------------------------------------------------------------
 17779                                  
 17780                                  ;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
 17781                                  ;
 17782                                  ;	ENTRY	DS:SI points to start of ASCIIZ string
 17783                                  ;		ES = DS
 17784                                  ;
 17785                                  ;	EXIT	nothing
 17786                                  ;	
 17787                                  ;	USED	AL,SI
 17788                                  
 17789                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17790                                  LowercaseString:
 17791 00001B54 57                      	push	di			; save di
 17792 00001B55 89F7                    	mov	di,si			; ES:DI --> ASCIIZ string
 17793 00001B57 FC                      	cld
 17794                                  NextChar: 
 17795 00001B58 AC                      	lodsb				; get character from string into al
 17796 00001B59 08C0                    	or	al,al			; are we at end of string?
 17797 00001B5B 7406                    	jz	short EndOfString
 17798                                  
 17799 00001B5D E8E9FF                  	call	LowerCase		; convert character to lowercase
 17800 00001B60 AA                      	stosb				; store character back into buffer
 17801 00001B61 EBF5                    	jmp	short NextChar		; repeat until end of string
 17802                                  
 17803                                  EndOfString:
 17804 00001B63 5F                      	pop	di			; restore di
 17805 00001B64 C3                      	retn
 17806                                  
 17807                                  ;M010;end
 17808                                  
 17809                                  
 17810                                  ; 08/06/2023
 17811                                  ; ---------------------------------------------------------------------------
 17812                                  ; MSDOS 6.2(2) COMMAND.COM procedure only !
 17813                                  ; -----------------------------------------
 17814                                  ; Hex-Rays IDA / disassembled source code ! modified for NASM by Erdogan Tan
 17815                                  ; ---------------------------------------------------------------------------
 17816                                  
 17817                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17818                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1C44h
 17819                                  screen_f_set:
 17820                                  	; set dir display parameters depending on screen width (# of columns)
 17821 00001B65 1E                      	push	ds
 17822 00001B66 B84000                  	mov	ax,40h
 17823 00001B69 8ED8                    	mov	ds,ax
 17824 00001B6B 833E4A0028              	cmp	word [4Ah],40	; Check ROMBIOS DATA colums per row
 17825                                  				; value (80 or 40)
 17826 00001B70 1F                      	pop	ds
 17827 00001B71 7527                    	jnz	short columns_80 ; 80 columns per line (video mode 3)
 17828 00001B73 8026[9393]BF            	and	byte [screen_f_1],0BFh ; ~40h
 17829 00001B78 C706[9493]0A0A          	mov	word [screen_f_2],0A0Ah ; 10 bytes (file size field)
 17830 00001B7E 8026[1A92]BF            	and	byte [screen_f_3],0BFh
 17831 00001B83 8026[0B94]BF            	and	byte [screen_f_4],0BFh
 17832 00001B88 C706[0C94]0A0A          	mov	word [screen_f_5],0A0Ah ; 10 bytes (file size field)
 17833 00001B8E 8026[2892]BF            	and	byte [screen_f_6],0BFh
 17834 00001B93 C706[2992]1C1C          	mov	word [screen_f_7],1C1Ch ; 28 bytes (free bytes field)
 17835                                  	;jmp	short screen_f_set_retn
 17836 00001B99 C3                      	retn
 17837                                  columns_80:
 17838 00001B9A 800E[9393]40            	or	byte [screen_f_1],40h
 17839 00001B9F C706[9493]0E0E          	mov	word [screen_f_2],0E0Eh ; 14 bytes (file size field)
 17840 00001BA5 800E[1A92]40            	or	byte [screen_f_3],40h
 17841 00001BAA 800E[0B94]40            	or	byte [screen_f_4],40h
 17842 00001BAF C706[0C94]0E0E          	mov	word [screen_f_5],0E0Eh ; 14 bytes (file size field)
 17843 00001BB5 800E[2892]40            	or	byte [screen_f_6],40h
 17844 00001BBA C706[2992]2020          	mov	word [screen_f_7],2020h ; 32 bytes (free bytes field)
 17845                                  screen_f_set_retn:
 17846 00001BC0 C3                      	retn
 17847                                  
 17848                                  ;============================================================================
 17849                                  ; CRATIO.ASM, MSDOS 6.0, 1992
 17850                                  ;============================================================================
 17851                                  ; 08/06/2023 - Retro DOS v4.2
 17852                                  
 17853                                  ; The code to calculate compression ratios requires access to the drive's
 17854                                  ; (DOS) FAT and MagicDrv FAT regions.  Two buffers are used (one for each
 17855                                  ; FAT type).  pbufDOSFAT and pbufMDFAT contain the offset to the buffers,
 17856                                  ; segFATBuf contains the segment (both buffers are in the same segment).
 17857                                  ; The buffers are of variable size: cFATEntries contains the size of the
 17858                                  ; buffers in terms of the number of FAT entries they can contain.
 17859                                  
 17860                                  ; ---------------------------------------------------------------------------
 17861                                  
 17862                                  ;***	OpenCVF - open Compressed Volume File for compression ratio report
 17863                                  ;
 17864                                  ;	ENTRY
 17865                                  ;		FCB setup with drive for DIR
 17866                                  ;
 17867                                  ;	EXIT	If successful, CY clear, CVF file open, fhCVF has file handle,
 17868                                  ;		szCVF has \0 terminated CVF file name, MDBPB loaded.
 17869                                  ;
 17870                                  ;		If unsuccessful, CY set
 17871                                  ;
 17872                                  ;	USED	AX, BX, CX, DX, SI, DI
 17873                                  
 17874                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 17875                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1CA1h
 17876                                  OpenCVF:
 17877 00001BC1 B8FFFF                  	mov	ax,-1
 17878 00001BC4 A3[3D9E]                	mov	[fhCVF],ax		;indicate CVF not open
 17879 00001BC7 A3[939E]                	mov	[entInBuf],ax		;  and no FAT entries in buffers
 17880                                  
 17881 00001BCA 8A165C00                	mov	dl,[FCB] ; mov dl,5Ch	;target drive of DIR cmd
 17882 00001BCE 08D2                    	or	dl,dl			;default drive?
 17883 00001BD0 7404                    	jz	short ocvf_default
 17884 00001BD2 FECA                    	dec	dl			;no, from 1=A to 0=A
 17885 00001BD4 EB04                    	jmp	short ocvf_swap_info
 17886                                  
 17887                                  ocvf_default:
 17888 00001BD6 8A16[059E]              	mov	dl,[CURDRV]		;0=A, 1=B, ...
 17889                                  
 17890                                  ocvf_swap_info:
 17891 00001BDA B8114A                  	mov	ax,4A11h ; multMagicDrv	;magicdrv Int 2Fh multiplex ID
 17892 00001BDD BB0100                  	mov	bx,1	 ; MD_DRIVE_MAP	;get drive swap info
 17893 00001BE0 CD2F                    	int	2fh
 17894                                  
 17895 00001BE2 09C0                    	or	ax,ax			;0 if okay
 17896 00001BE4 7573                    	jnz	short ocvf_error
 17897                                  
 17898 00001BE6 F6C380                  	test	bl,80h 			;80h set if compressed volume
 17899 00001BE9 746E                    	jz	short ocvf_error
 17900                                  
 17901 00001BEB 80E37F                  	and	bl,7Fh 			;bl = host drive, bh = seq #
 17902                                  
 17903                                  	; The CVF may have been mounted from a swapped host drive, in which
 17904                                  	; case the host drive returned in BL is the original host (now
 17905                                  	; swapped with a CVF).	Make a second drive swap info call on the
 17906                                  	; returned host to see if it must be accessed by a different drive
 17907                                  	; letter.
 17908                                  
 17909 00001BEE 53                      	push	bx
 17910 00001BEF 52                      	push	dx			;save dl, orig drive letter
 17911                                  
 17912 00001BF0 B8114A                  	mov	ax,4A11h ; mov ax,multMagicDrv
 17913 00001BF3 88DA                    	mov	dl,bl
 17914 00001BF5 BB0100                  	mov	bx,1	 ; mov bx,MD_DRIVE_MAP
 17915 00001BF8 CD2F                    	int	2fh
 17916                                  
 17917 00001BFA 5A                      	pop	dx
 17918 00001BFB 59                      	pop	cx			;bx from 1st drive swap info call
 17919                                  
 17920 00001BFC 09C0                    	or	ax,ax			;0 if okay
 17921 00001BFE 7559                    	jnz	short ocvf_error
 17922                                  
 17923 00001C00 80E37F                  	and	bl,7Fh
 17924 00001C03 87D9                    	xchg	bx,cx			;bx = 1st, cx = 2nd swap results
 17925                                  
 17926 00001C05 38CA                    	cmp	dl,cl			;2nd swap info call return orig drive?
 17927 00001C07 7402                    	je	short ocvf_got_host	;yes, 1st swap info call returned host
 17928                                  
 17929 00001C09 88CB                    	mov	bl,cl			;no, use swapped host, orig seq #
 17930                                  ocvf_got_host:
 17931                                  	; Build the filename of the Compressed Volume File
 17932                                  
 17933                                  	;mov	di,offset TRANGROUP:szCVF
 17934                                  					;CVF name buffer
 17935 00001C0B BF[3F9E]                	mov	di,szCVF
 17936                                  
 17937 00001C0E 88D8                    	mov	al,bl
 17938 00001C10 0441                    	add	al,'A'
 17939 00001C12 B43A                    	mov	ah,':'
 17940 00001C14 FC                      	cld
 17941 00001C15 AB                      	stosw				; drive:
 17942                                  
 17943                                  	;mov	si,offset TRANGROUP:sCVFRoot
 17944                                  					; \name.
 17945 00001C16 BE[0499]                	mov	si,sCVFRoot	; "\DBLSPACE"
 17946                                  	;mov	cx,cbCVFRoot
 17947 00001C19 B90A00                  	mov	cx,10
 17948 00001C1C F3A4                    	rep	movsb
 17949                                  
 17950 00001C1E 83C703                  	add	di,3			; point past extension
 17951 00001C21 30C0                    	xor	al,al
 17952 00001C23 FD                      	std
 17953 00001C24 AA                      	stosb				; null terminate
 17954                                  
 17955 00001C25 88F8                    	mov	al,bh			; seq #
 17956 00001C27 B30A                    	mov	bl,10
 17957                                  	;mov	cx,3			; 3 digit ext/seq #
 17958 00001C29 B103                    	mov	cl,3
 17959                                  ;@@:
 17960 00001C2B 30E4                    ocvf_1:	xor	ah,ah			; convert seq # to ascii
 17961 00001C2D F6F3                    	div	bl			;   and store as CVF extension
 17962 00001C2F 80C430                  	add	ah,'0'
 17963 00001C32 86E0                    	xchg	ah,al
 17964 00001C34 AA                      	stosb
 17965 00001C35 88E0                    	mov	al,ah
 17966                                  	;loop	@b
 17967 00001C37 E2F2                    	loop	ocvf_1
 17968                                  
 17969 00001C39 FC                      	cld
 17970                                  
 17971                                  	; Now open the Compressed Volume File
 17972                                  
 17973                                  	; 08/06/2023
 17974                                  	; MSDOS 6.22 COMMAND.COM code only !
 17975                                  	;;;
 17976 00001C3A BF[3F9E]                	mov	di,szCVF ; *
 17977 00001C3D C745045256              	mov	word [di+4],5652h ; 'RV' (DRVSPACE)
 17978 00001C42 B8003D                  	mov	ax,3D00h
 17979                                  	;mov	dx,szCVF
 17980 00001C45 89FA                    	mov	dx,di ; *
 17981 00001C47 CD21                    	int	21h     ; DOS - 2+ - OPEN DISK FILE WITH HANDLE
 17982                                  			; DS:DX -> ASCIZ filename
 17983                                  			; AL = access mode
 17984                                  			; 0 - read
 17985 00001C49 7310                    	jnb     short ocvf_2
 17986 00001C4B C74504424C              	mov	word [di+4],4C42h ; 'BL' (DBLSPACE)
 17987                                  	;;;
 17988                                  
 17989                                  	;mov	ax,(OPEN shl 8) or 00h 	;compatibility mode/read access
 17990 00001C50 B8003D                  	mov	ax,3D00h
 17991                                  	;;mov	dx,offset TRANGROUP:szCVF
 17992                                  	;mov	dx,szCVF
 17993 00001C53 89FA                    	mov	dx,di ; *
 17994 00001C55 CD21                    	int	21h
 17995                                  	;jc	short ocvf_error
 17996                                  	; 18/06/2023
 17997 00001C57 7302                    	jnc	short ocvf_2
 17998                                  ocvf_error:	; 18/06/2023
 17999 00001C59 F9                      	stc				;indicate failure
 18000 00001C5A C3                      	retn
 18001                                  ocvf_2:
 18002 00001C5B A3[3D9E]                	mov	[fhCVF],ax		; success, save CVF file handle
 18003                                  
 18004                                  	; Read the extended MagicDrv BPB
 18005                                  
 18006 00001C5E 89C3                    	mov	bx,ax
 18007                                  	;mov	ah,READ
 18008 00001C60 B43F                    	mov	ah,3Fh
 18009                                  	;mov	cx,size MD_BPB
 18010 00001C62 B94000                  	mov	cx,64
 18011                                  	;mov	dx,offset TRANGROUP:MDBPB
 18012 00001C65 BA[4F9E]                	mov	dx,MDBPB
 18013 00001C68 CD21                    	int	21h
 18014 00001C6A 7204                    	jc	short ocvf_error1
 18015                                  
 18016 00001C6C 39C8                    	cmp	ax,cx			; get it all?
 18017 00001C6E 7405                    	je	short ocvf_pick_cluster_size
 18018                                  					; yes...
 18019                                  ocvf_error1:
 18020 00001C70 E86B00                  	call	CloseCVF
 18021                                  	; 18/06/2023
 18022                                  ;ocvf_error:
 18023 00001C73 F9                      	stc				;indicate failure
 18024                                  	;jmp	short ocvf_ret
 18025 00001C74 C3                      	retn
 18026                                  
 18027                                  	; Determine the cluster size to use for ratio calculation
 18028                                  
 18029                                  ocvf_pick_cluster_size:
 18030 00001C75 803E[909E]00            	cmp	byte [fUseHostSize],0 	; user want Host drive cluster size?
 18031 00001C7A 7411                    	je	short ovcf_use_CVF_size	; no, use CVF cluster size
 18032                                  
 18033                                  	;mov	ah,Get_Drive_Data	; get the host drive cluster size
 18034 00001C7C B41C                    	mov	ah,1Ch
 18035 00001C7E 8A16[3F9E]              	mov	dl,[szCVF]
 18036                                  	;sub	dl,40h	
 18037 00001C82 80EA40                  	sub	dl,'A'-1		; 1 = A, 2 = B, ...
 18038 00001C85 1E                      	push	ds
 18039 00001C86 CD21                    	int	21h
 18040 00001C88 1F                      	pop	ds
 18041                                  
 18042 00001C89 3CFF                    	cmp	al,0FFh			; host drive cluster size in AL if okay,
 18043 00001C8B 7503                    	jne	short ovcf_set_size	;   failed = 0FFh
 18044                                  
 18045                                  ovcf_use_CVF_size:
 18046                                  	;mov	al,[MDBPB.dos_bpb.csecPerClu]
 18047 00001C8D A0[5C9E]                	mov	al,[MDBPB+0Dh]		; using CVF cluster size
 18048                                  
 18049                                  ovcf_set_size:
 18050 00001C90 A2[8F9E]                	mov	[csecPerCluster],al
 18051                                  
 18052                                  	; Lastly, setup the FAT buffers
 18053                                  ocvf_set_buf:
 18054 00001C93 A1[129E]                	mov	ax,[BYTCNT]		; if >= 32k TPA space available,
 18055 00001C96 A3[149E]                	mov	[savBytCnt],ax		;   setup larger FAT buffers
 18056 00001C99 3D0080                  	cmp	ax,32*1024  ; 8000h
 18057 00001C9C 7318                    	jae	short ocvf_big_buf
 18058                                  
 18059                                  	; small TPA, use small resident buffers
 18060                                  
 18061                                  	;mov	word ptr [cFATEntries],cRES_FAT_ENTRIES
 18062 00001C9E C706[919E]2000          	mov	word [cFATEntries],32 ; cRES_FAT_ENTRIES
 18063 00001CA4 8C1E[959E]              	mov	[segFATBuf],ds
 18064                                  	;mov	word ptr [pbufDOSFAT],offset TRANGROUP:bufDOSFAT
 18065                                  	;mov	word ptr [pbufMDFAT],offset TRANGROUP:bufMDFAT
 18066 00001CA8 C706[979E][9B9E]        	mov	word [pbufDOSFAT],bufDOSFAT
 18067 00001CAE C706[999E][DB9E]        	mov	word [pbufMDFAT],bufMDFAT
 18068                                  	;jmp	short ocvf_success
 18069                                  	; 08/06/2023
 18070                                  	; cf = 1
 18071 00001CB4 F8                      	clc
 18072 00001CB5 C3                      	retn
 18073                                  
 18074                                  ocvf_big_buf:
 18075                                  	;mov	bx,cBIG_FAT_ENTRIES
 18076 00001CB6 BB0001                  	mov	bx,256
 18077 00001CB9 891E[919E]              	mov	[cFATEntries],bx
 18078                                  
 18079 00001CBD D1E3                    	shl	bx,1			; 6 bytes per entry (2 for DOS FAT, 4 MD FAT)
 18080 00001CBF 89D9                    	mov	cx,bx			; entries * 2
 18081 00001CC1 D1E3                    	shl	bx,1
 18082 00001CC3 01CB                    	add	bx,cx			; bx = # entries * 6
 18083                                  
 18084 00001CC5 29D8                    	sub	ax,bx			; reduce TPA size by size of FAT buffers
 18085 00001CC7 2500FE                  	and	ax,0FE00h		; init code rounds BytCnt down to multiple of
 18086 00001CCA A3[129E]                	mov	[BYTCNT],ax		;   512 bytes -- a no-op with some buf sizes.
 18087                                  
 18088 00001CCD 8B1E[F59D]              	mov	bx,[TPA]		; buffers in the TPA
 18089 00001CD1 891E[959E]              	mov	[segFATBuf],bx
 18090 00001CD5 A3[979E]                	mov	[pbufDOSFAT],ax		; DOS FAT buffer offset
 18091 00001CD8 01C8                    	add	ax,cx			;   + DOS FAT buffer size
 18092 00001CDA A3[999E]                	mov	[pbufMDFAT],ax 		;   = MD FAT buffer offset
 18093                                  	; 08/06/2023
 18094                                  	; cf = 0
 18095                                  ;ocvf_success:
 18096                                  	;clc				;indicate success
 18097                                  ocvf_ret:
 18098 00001CDD C3                      	retn
 18099                                  
 18100                                  ; ---------------------------------------------------------------------------
 18101                                  
 18102                                  ;***	CloseCVF - close Compressed Volume File
 18103                                  ;
 18104                                  ;	ENTRY	fhCVF has file handle
 18105                                  ;
 18106                                  ;	EXIT
 18107                                  ;
 18108                                  ;	USED	AX, BX, CX, DX
 18109                                  
 18110                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18111                                  CloseCVF:
 18112 00001CDE 8B1E[3D9E]              	mov	bx,[fhCVF]		; -1 unless file is open
 18113 00001CE2 83FBFF                  	cmp	bx,-1 ; 0FFFFh
 18114 00001CE5 7410                    	je	short ccvf_ret
 18115                                  
 18116                                  	;mov	ah,CLOSE
 18117 00001CE7 B43E                    	mov	ah,3Eh
 18118 00001CE9 CD21                    	int	21h
 18119                                  
 18120 00001CEB C706[3D9E]FFFF          	mov	word [fhCVF],-1 ; 0FFFFh ; don't try to close again
 18121                                  
 18122 00001CF1 A1[149E]                	mov	ax,[savBytCnt]		; 'deallocate' DOS & MD FAT buffers
 18123 00001CF4 A3[129E]                	mov	[BYTCNT],ax		;   by restoring old TPA byte count
 18124                                  ccvf_ret:
 18125 00001CF7 C3                      	retn
 18126                                  
 18127                                  ; ---------------------------------------------------------------------------
 18128                                  
 18129                                  ;***	CalcCompRatio - calculate file compression ratio
 18130                                  ;
 18131                                  ;	ENTRY	AX = starting cluster of file to get compression ratio of
 18132                                  ;
 18133                                  ;	EXIT	AX = compression ratio.  Example: a ratio of 2.7 to 1.0
 18134                                  ;		     will return AH = 02h & AL = 07h
 18135                                  ;		ccluUsed set to # DOS clusters used by file
 18136                                  ;		csecUsed set to # compressed sectors used by file
 18137                                  ;		ccluUsedDir, ccluUsedTotal, csecUsedDir, csecUsedTotal updated
 18138                                  ;	USED	none
 18139                                  
 18140                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18141                                  CalcCompRatio:
 18142 00001CF8 53                      	push	bx
 18143 00001CF9 51                      	push	cx
 18144 00001CFA 52                      	push	dx
 18145 00001CFB 06                      	push	es
 18146 00001CFC 8E06[959E]              	mov	es,[segFATBuf]		; es is pointer to FAT buffers
 18147                                  	;assume	es:nothing
 18148                                  
 18149 00001D00 31DB                    	xor	bx,bx			; zero count of sectors & clusters used
 18150 00001D02 891E[2B9E]              	mov	[ccluUsed],bx
 18151 00001D06 891E[319E]              	mov	[csecUsed],bx
 18152 00001D0A 891E[339E]              	mov	[csecUsed+2],bx
 18153                                  ccr_next:
 18154 00001D0E 83F802                  	cmp	ax,2			; sanity check the DOS FAT value
 18155 00001D11 7250                    	jb	short ccr_screwy
 18156                                  
 18157 00001D13 83F8F0                  	cmp	ax,0FFF0h		; end of file?
 18158 00001D16 7352                    	jae	short ccr_eof
 18159                                  
 18160 00001D18 E84701                  	call	CheckFATBuffers 	; make sure buffers contain target
 18161 00001D1B 7246                    	jc	short ccr_screwy	;   FAT entries
 18162                                  
 18163 00001D1D E82901                  	call	GetMDFATEntry		; returns corresponding entry in BX:CX
 18164 00001D20 7241                    	jc	short ccr_screwy
 18165                                  
 18166 00001D22 D1E3                    	shl	bx,1			; used bit to CY
 18167 00001D24 733D                    	jnc	short ccr_screwy	; better be used!
 18168                                  
 18169 00001D26 88FD                    	mov	ch,bh			; save uncompressed count
 18170                                  
 18171 00001D28 D1E3                    	shl	bx,1			; get count into position
 18172 00001D2A 81E3000F                	and	bx,0F00h		; bh = count of compressed sectors used
 18173 00001D2E 86FB                    	xchg	bh,bl			; bx = count
 18174 00001D30 43                      	inc	bx			; 0 - 15 means 1 - 16 used
 18175                                  
 18176 00001D31 011E[319E]              	add	[csecUsed],bx
 18177 00001D35 8316[339E]00            	adc	word [csecUsed+2],0
 18178                                  
 18179 00001D3A 89C2                    	mov	dx,ax			; save cluster # in dx
 18180                                  
 18181 00001D3C 88E8                    	mov	al,ch			; uncompressed count to al
 18182 00001D3E B103                    	mov	cl,3
 18183 00001D40 D2E8                    	shr	al,cl			; get uncompressed count into position
 18184 00001D42 83E00F                  	and	ax,000Fh		; ax = uncompressed count (0 - 15)
 18185 00001D45 4B                      	dec	bx			; bx = compressed count (0 - 15)
 18186 00001D46 39D8                    	cmp	ax,bx			; if the compressed cnt > uncompressed
 18187                                  	;jae	@f			;   fudge a little and use the larger
 18188 00001D48 7302                    	jae	short ccr_1 ; jnb
 18189 00001D4A 89D8                    	mov	ax,bx
 18190                                  ;@@:	
 18191                                  ccr_1:
 18192 00001D4C 8A0E[8F9E]              	mov	cl,[csecPerCluster]	; round up to the number of clusters
 18193 00001D50 30ED                    	xor	ch,ch			;   required for uncompressed
 18194 00001D52 01C8                    	add	ax,cx			;   sectors
 18195 00001D54 F6F1                    	div	cl
 18196 00001D56 30E4                    	xor	ah,ah
 18197 00001D58 0106[2B9E]              	add	[ccluUsed],ax
 18198                                  
 18199 00001D5C 89D0                    	mov	ax,dx			; restore cluster #
 18200 00001D5E E8A900                  	call	GetDOSFATEntry		; retuns next DOS FAT entry in AX
 18201                                  	;jc	short ccr_screwy
 18202                                  	;jmp	short ccr_next
 18203                                  	; 08/06/2023
 18204 00001D61 73AB                    	jnc	short ccr_next
 18205                                  ccr_screwy:
 18206 00001D63 31C0                    	xor	ax,ax			; something screwy happened, set
 18207                                  					;   ratio to 0.0 and exit
 18208                                  ccr_ret:
 18209 00001D65 07                      	pop	es
 18210 00001D66 5A                      	pop	dx
 18211 00001D67 59                      	pop	cx
 18212 00001D68 5B                      	pop	bx
 18213 00001D69 C3                      	retn
 18214                                  
 18215                                  	; Reached the end-of-file, now calculate the ratio as the
 18216                                  	; number of DOS sectors used / number of compressed sectors used.
 18217                                  
 18218                                  ccr_eof:
 18219 00001D6A A1[2B9E]                	mov	ax,[ccluUsed]
 18220 00001D6D 0106[2D9E]              	add	[ccluUsedDir],ax	; update cluster used totals
 18221 00001D71 0106[2F9E]              	add	[ccluUsedTotal],ax
 18222                                  
 18223 00001D75 8B0E[339E]              	mov	cx,[csecUsed+2]
 18224 00001D79 8B1E[319E]              	mov	bx,[csecUsed]		; cx:bx = # compressed sectors used
 18225                                  
 18226 00001D7D 011E[359E]              	add	[csecUsedDir],bx	; update sector used totals
 18227 00001D81 110E[379E]              	adc	[csecUsedDir+2],cx
 18228 00001D85 011E[399E]              	add	[csecUsedTotal],bx
 18229 00001D89 110E[3B9E]              	adc	[csecUsedTotal+2],cx
 18230                                  
 18231 00001D8D E80200                  	call	ComputeRatio		; ax=clusters used, cx:bx=sectors used
 18232                                  
 18233 00001D90 EBD3                    	jmp	short ccr_ret
 18234                                  
 18235                                  	; 08/06/2023
 18236                                  ;ccr_screwy:
 18237                                  ;	xor	ax,ax			; something screwy happened, set
 18238                                  ;					;   ratio to 0.0 and exit
 18239                                  ;ccr_ret:
 18240                                  ;	pop	es
 18241                                  ;	pop	dx
 18242                                  ;	pop	cx
 18243                                  ;	pop	bx
 18244                                  ;	retn
 18245                                  
 18246                                  ; ---------------------------------------------------------------------------
 18247                                  
 18248                                  ;***	ComputeRatio - calculate ratio of compressed sectors used to
 18249                                  ;		       (would be) DOS sectors used
 18250                                  ;
 18251                                  ;	Entry
 18252                                  ;		AX = DOS clusters used, cx:bx = compressed sectors used
 18253                                  ;	Exit
 18254                                  ;		ah = whole portion, al = tenths
 18255                                  ;
 18256                                  ;	Used	BX, CX, DX
 18257                                  
 18258                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18259                                  ComputeRatio:
 18260 00001D92 56                      	push	si
 18261 00001D93 57                      	push	di
 18262                                  
 18263 00001D94 89DE                    	mov	si,bx
 18264 00001D96 89CF                    	mov	di,cx			; save cx:bx in di:si
 18265                                  
 18266 00001D98 8A1E[8F9E]              	mov	bl,[csecPerCluster]
 18267 00001D9C 30FF                    	xor	bh,bh
 18268 00001D9E F7E3                    	mul	bx			; dx:ax = # DOS sectors used
 18269 00001DA0 89F3                    	mov	bx,si			; restore bx
 18270                                  
 18271 00001DA2 E83800                  	call	Div32			; dx:ax = quotient, cx:bx = remainder
 18272                                  
 18273 00001DA5 50                      	push	ax			; save quotient
 18274                                  
 18275 00001DA6 89D8                    	mov	ax,bx			; if no remainder, tenths will be 0
 18276 00001DA8 09C8                    	or	ax,cx			;   which is in AX so skip following
 18277 00001DAA 7423                    	jz	short cr_got_tenths	;   (happens frequently)
 18278                                  
 18279                                  	; Multiply the reminder by 10, add half the divisor so result is
 18280                                  	; rounded up, and divide again to get tenths digit
 18281                                  
 18282 00001DAC 89C8                    	mov	ax,cx
 18283 00001DAE 31D2                    	xor	dx,dx
 18284 00001DB0 89D9                    	mov	cx,bx
 18285 00001DB2 BB0A00                  	mov	bx,10
 18286 00001DB5 F7E3                    	mul	bx
 18287 00001DB7 91                      	xchg	ax,cx
 18288 00001DB8 F7E3                    	mul	bx
 18289 00001DBA 01CA                    	add	dx,cx			; dx:ax = remainder * 10
 18290                                  
 18291 00001DBC 89F9                    	mov	cx,di
 18292 00001DBE 89F3                    	mov	bx,si
 18293 00001DC0 D1E9                    	shr	cx,1
 18294 00001DC2 D1DB                    	rcr	bx,1			; cx:bx = 1/2 divisor
 18295 00001DC4 01D8                    	add	ax,bx
 18296 00001DC6 11CA                    	adc	dx,cx			; dx:ax = remainder * 10 + 1/2 divisor
 18297                                  
 18298 00001DC8 89F9                    	mov	cx,di
 18299 00001DCA 89F3                    	mov	bx,si
 18300                                  
 18301 00001DCC E80E00                  	call	Div32
 18302                                  
 18303                                  cr_got_tenths:
 18304 00001DCF 5B                      	pop	bx			; original quotient
 18305 00001DD0 88DC                    	mov	ah,bl
 18306                                  
 18307 00001DD2 3C0A                    	cmp	al,10			; if the tenths rounded up to the
 18308 00001DD4 7204                    	jb	short cr_exit 		;   next whole number, adjust the
 18309                                  					;   whole number part and 0 the
 18310 00001DD6 FEC4                    	inc	ah			;   tenths  (i.e. round 1.97 to 2.0)
 18311 00001DD8 30C0                    	xor	al,al
 18312                                  cr_exit:
 18313 00001DDA 5F                      	pop	di
 18314 00001DDB 5E                      	pop	si
 18315                                  
 18316 00001DDC C3                      	retn
 18317                                  
 18318                                  ; --------------------------------------------------------------------------- 
 18319                                  
 18320                                  ;***	Div32 - 32 bit divide for computing ratios
 18321                                  ;
 18322                                  ;	Entry	DX:AX = dividend, CX:BX = divisor
 18323                                  ;
 18324                                  ;	Exit	DX:AX = quotient, CX:BX = reminder
 18325                                  
 18326                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18327                                  Div32:
 18328 00001DDD E322                    	jcxz	d32_16bit		; differently if 16bit divisor
 18329                                  
 18330 00001DDF 56                      	push	si
 18331 00001DE0 57                      	push	di
 18332                                  
 18333                                  	; Brute force divide by subtraction. This is okay because worse case
 18334                                  	; the dividend will only be 16 times greater, and typically about 2
 18335                                  	; times
 18336                                  
 18337 00001DE1 31F6                    	xor	si,si
 18338 00001DE3 89F7                    	mov	di,si			; di:si is quotient
 18339                                  ;@@:
 18340                                  div32_1:
 18341 00001DE5 29D8                    	sub	ax,bx			; subtract divisor
 18342 00001DE7 19CA                    	sbb	dx,cx
 18343 00001DE9 7208                    	jc	short d32_too_far
 18344                                  
 18345 00001DEB 83C601                  	add	si, 1			; accumulate quotient
 18346 00001DEE 83D700                  	adc	di, 0
 18347                                  	;jmp	short @b
 18348 00001DF1 EBF2                    	jmp	short div32_1
 18349                                  
 18350                                  d32_too_far:
 18351 00001DF3 01D8                    	add	ax,bx			; fix the last subtraction
 18352 00001DF5 11CA                    	adc	dx,cx
 18353                                  
 18354 00001DF7 89F9                    	mov	cx,di
 18355 00001DF9 89F3                    	mov	bx,si			; dx:ax = remainder, cx:bx = quoient
 18356                                  
 18357 00001DFB 93                      	xchg	ax,bx
 18358 00001DFC 87D1                    	xchg	dx,cx			; dx:ax = quoient, cx:bx = remainder
 18359                                  
 18360 00001DFE 5F                      	pop	di
 18361 00001DFF 5E                      	pop	si
 18362                                  
 18363 00001E00 C3                      	retn
 18364                                  
 18365                                  d32_16bit:
 18366 00001E01 F7F3                    	div	bx			; divide dx:ax by bx
 18367                                  
 18368 00001E03 89D3                    	mov	bx,dx			; remainder to cx:bx
 18369 00001E05 31D2                    	xor	dx,dx			; quotient to dx:ax
 18370 00001E07 89D1                    	mov	cx,dx
 18371 00001E09 C3                      	retn
 18372                                  
 18373                                  ; --------------------------------------------------------------------------- 
 18374                                  
 18375                                  ;***	GetDOSFATEntry - returns next cluster in file's FAT chain
 18376                                  ;
 18377                                  ;	Entry	AX = current cluster number
 18378                                  ;		ES = segment of FAT buffer
 18379                                  ;		Entry should be in FAT buffer
 18380                                  ;
 18381                                  ;	Exit	AX = next cluster number
 18382                                  ;		CY set if error
 18383                                  ;
 18384                                  ;	Uses	BX
 18385                                  
 18386                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18387                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1EF2h
 18388                                  GetDOSFATEntry:
 18389 00001E0A 2B06[939E]              	sub	ax,[entInBuf]		; calc entry # in buffer
 18390 00001E0E 7212                    	jc	short gdf_ret 		; CY already set for error
 18391                                  
 18392 00001E10 89C3                    	mov	bx,ax
 18393                                  
 18394                                  	;cmp	MDBPB.f12BitFAT, 0	; 12 or 16 bit FAT?
 18395 00001E12 803E[8C9E]00            	cmp	byte [MDBPB+3Dh],0
 18396 00001E17 750A                    	jnz	short gdf_12		; go do 12
 18397                                  
 18398 00001E19 D1E3                    	shl	bx,1			; offset = entry * 2
 18399 00001E1B 031E[979E]              	add	bx,[pbufDOSFAT]
 18400 00001E1F 268B07                  	mov	ax,[es:bx]
 18401                                  	; 08/06/2023
 18402                                  	; cf = 0
 18403                                  ;gdf_success:
 18404                                  	;clc				; success
 18405                                  gdf_ret:
 18406 00001E22 C3                      	retn
 18407                                  
 18408                                  gdf_12:
 18409 00001E23 D1EB                    	shr	bx,1
 18410 00001E25 01C3                    	add	bx,ax			; offset to entry = entry * 1.5
 18411 00001E27 031E[979E]              	add	bx,[pbufDOSFAT]
 18412                                  
 18413                                  ;	ES:BX points to the word containing the desired 12 bit FAT entry.
 18414                                  ;	For odd entries, the upper 12 bits are valid, for even entries
 18415                                  ;	the low 12 bits are valid.  odd: OOOx  even: xEEE
 18416                                  
 18417 00001E2B A801                    	test	al,1			; is current entry odd?
 18418                                  
 18419 00001E2D 268B07                  	mov	ax,[es:bx]		; word with FAT entry
 18420 00001E30 7505                    	jnz	short gdf_odd
 18421                                  
 18422 00001E32 25FF0F                  	and	ax,0FFFh		; keep low 12 bits for even
 18423 00001E35 EB08                    	jmp	short gdf_testEOF
 18424                                  
 18425                                  gdf_odd:
 18426 00001E37 89CB                    	mov	bx,cx			; (save cx in bx)
 18427 00001E39 B104                    	mov	cl,4
 18428 00001E3B D3E8                    	shr	ax,cl			; upper 12 bits for odd
 18429 00001E3D 89D9                    	mov	cx,bx			; (restore cx)
 18430                                  
 18431                                  gdf_testEOF:
 18432 00001E3F 3DF00F                  	cmp	ax,0FF0h		; valid entry?
 18433                                  	;jb	short gdf_success
 18434 00001E42 F5                      	cmc	; cf = 1 <--> cf = 0
 18435 00001E43 73DD                    	jnc	short gdf_ret	
 18436                                  
 18437 00001E45 80CCF0                  	or	ah,0F0h			; caller expects 16 bit special values
 18438                                  	;jmp	short gdf_success
 18439                                  	; cf = 0
 18440 00001E48 C3                      	retn
 18441                                  
 18442                                  ; --------------------------------------------------------------------------- 
 18443                                  
 18444                                  ;***	GetMDFATEntry - returns requested MD FAT entry
 18445                                  ;
 18446                                  ;	Entry	AX = current DOS cluster number
 18447                                  ;		ES = segment of FAT buffer
 18448                                  ;		Entry should be in FAT buffer
 18449                                  ;
 18450                                  ;	Exit	BX:CX = corresponding MD FAT entry
 18451                                  ;		CY set if error
 18452                                  ;
 18453                                  ;	Uses	None
 18454                                  
 18455                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18456                                  GetMDFATEntry:
 18457 00001E49 89C3                    	mov	bx,ax
 18458 00001E4B 2B1E[939E]              	sub	bx,[entInBuf]		; calc entry # in buffer
 18459 00001E4F 7210                    	jc	short gmf_ret 		; CY already set for error return
 18460                                  
 18461 00001E51 D1E3                    	shl	bx,1
 18462 00001E53 D1E3                    	shl	bx,1			; * 4 bytes per MDFAT entry
 18463                                  
 18464 00001E55 031E[999E]              	add	bx,[pbufMDFAT]
 18465 00001E59 268B0F                  	mov	cx,[es:bx]
 18466 00001E5C 268B5F02                	mov	bx,[es:bx+2]
 18467                                  
 18468 00001E60 F8                      	clc
 18469                                  gmf_ret:
 18470 00001E61 C3                      	retn
 18471                                  
 18472                                  ; --------------------------------------------------------------------------- 
 18473                                  
 18474                                  ;***	CheckFATBuffers - check that target FAT entry is in FAT buffers.  If
 18475                                  ;			  not, fill the buffers starting with the requested
 18476                                  ;			  entry.
 18477                                  ;
 18478                                  ;	ENTRY	AX = FAT entry #
 18479                                  ;		ES = segment of FAT buffers
 18480                                  ;
 18481                                  ;	EXIT	FAT buffers contain target entry, or CY set if error
 18482                                  ;		entInBuf updated
 18483                                  ;
 18484                                  ;	USED	BX
 18485                                  
 18486                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18487                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1F4Bh
 18488                                  
 18489                                  CheckFATBuffers:
 18490 00001E62 89C3                    	mov	bx,ax
 18491 00001E64 2B1E[939E]              	sub	bx,[entInBuf]
 18492 00001E68 7208                    	jb	short cfb_load_fat
 18493                                  
 18494 00001E6A 2B1E[919E]              	sub	bx,[cFATEntries]
 18495 00001E6E 7302                    	jae	short cfb_load_fat ; jnb
 18496                                  
 18497 00001E70 F8                      	clc
 18498 00001E71 C3                      	retn
 18499                                  
 18500                                  	; Desired entry isn't in the FAT buffers, reload the buffers to
 18501                                  	; include it
 18502                                  
 18503                                  cfb_load_fat:
 18504 00001E72 50                      	push	ax
 18505 00001E73 51                      	push	cx
 18506 00001E74 52                      	push	dx
 18507                                  
 18508                                  	; Start with the DOS FAT buffer
 18509                                  
 18510 00001E75 31C9                    	xor	cx,cx			; zero high offset to FAT file position
 18511                                  
 18512                                  	;cmp	MDBPB.f12BitFAT, 0	; 12 or 16 bit FAT?
 18513 00001E77 803E[8C9E]00            	cmp	byte [MDBPB+3Dh],0
 18514 00001E7C 7509                    	jnz	short cfb_12		; go do 12
 18515                                  
 18516 00001E7E A3[939E]                	mov	[entInBuf],ax		; this entry is first
 18517                                  
 18518 00001E81 D1E0                    	shl	ax,1			; 2 bytes per cluster #
 18519 00001E83 D1D1                    	rcl	cx,1			; cx:ax = offset to FAT entry
 18520                                  
 18521 00001E85 EB0B                    	jmp	short cfb_common
 18522                                  
 18523                                  cfb_12:
 18524                                  	;and	al,not 1 ; 0FEh		; start with even # entry
 18525 00001E87 24FE                    	and	al,~1
 18526 00001E89 A3[939E]                	mov	[entInBuf],ax
 18527                                  
 18528 00001E8C 89C3                    	mov	bx,ax
 18529 00001E8E D1EB                    	shr	bx,1
 18530 00001E90 01D8                    	add	ax,bx			; ax = offset to FAT entry
 18531                                  					;      (entry # * 1.5)
 18532                                  cfb_common:
 18533 00001E92 89C3                    	mov	bx,ax			; cx:bx = offset to FAT entry
 18534                                  
 18535                                  	;mov	ax,[MDBPB.csecMDReserved] ; # magicDrv reserved sectors
 18536 00001E94 A1[769E]                	mov	ax,[MDBPB+27h]
 18537                                  	;add	ax,[MDBPB.dos_bpb.csecReserved]
 18538 00001E97 0306[5D9E]              	add	ax,[MDBPB+0Eh]
 18539                                  
 18540                                  	;mul	word [MDBPB.dos_bpb.cbPerSec]
 18541 00001E9B F726[5A9E]              	mul	word [MDBPB+0Bh]	; DX:AX = DOS FAT file origin
 18542 00001E9F 01D8                    	add	ax,bx
 18543 00001EA1 11CA                    	adc	dx,cx			; DX:AX = file offset to read from
 18544                                  
 18545 00001EA3 8B0E[919E]              	mov	cx,[cFATEntries]	; size to read
 18546 00001EA7 D1E1                    	shl	cx,1
 18547 00001EA9 8B1E[979E]              	mov	bx,[pbufDOSFAT]		; es:bx = location to read
 18548                                  
 18549 00001EAD E83500                  	call	ReadCVFile
 18550 00001EB0 722F                    	jc	short cfb_error
 18551                                  
 18552                                  	; Now read the corresponding MagicDrv FAT entries
 18553                                  
 18554                                  	;mov	ax,[MDBPB.secMDFATStart]
 18555 00001EB2 A1[739E]                	mov	ax,[MDBPB+24h]
 18556 00001EB5 40                      	inc	ax
 18557                                  	;mul	word [MDBPB.dos_bpb.cbPerSec]
 18558 00001EB6 F726[5A9E]              	mul	word [MDBPB+0Bh]	; DX:AX = MDFAT file offset
 18559                                  
 18560 00001EBA 8B1E[939E]              	mov	bx,[entInBuf]
 18561 00001EBE 31C9                    	xor	cx,cx			; CX:BX = 32 bit cluster #
 18562                                  	;add	bx,[MDBPB.cluFirstData]
 18563 00001EC0 031E[7C9E]              	add	bx,[MDBPB+2Dh]
 18564 00001EC4 11C9                    	adc	cx,cx			; CX:BX = MDFAT entry #
 18565                                  
 18566 00001EC6 D1E3                    	shl	bx,1
 18567 00001EC8 D1D1                    	rcl	cx,1
 18568 00001ECA D1E3                    	shl	bx,1
 18569 00001ECC D1D1                    	rcl	cx,1			; * 4 bytes per MDFAT entry
 18570                                  
 18571 00001ECE 01D8                    	add	ax,bx
 18572 00001ED0 11CA                    	adc	dx,cx			; DX:AX = file offset of MDFAT entry
 18573                                  
 18574 00001ED2 8B0E[919E]              	mov	cx,[cFATEntries]
 18575 00001ED6 D1E1                    	shl	cx,1
 18576 00001ED8 D1E1                    	shl	cx,1			; size to read
 18577 00001EDA 8B1E[999E]              	mov	bx,[pbufMDFAT]		; es:bx = location to read into
 18578                                  
 18579 00001EDE E80400                  	call	ReadCVFile
 18580                                  	;jnc	short cfb_ret ; cf = 0 ; 08/06/2023
 18581                                  	; 08/06/2023
 18582                                  	; cf = 1
 18583                                  cfb_error:
 18584                                  	;stc
 18585                                  cfb_ret:
 18586 00001EE1 5A                      	pop	dx
 18587 00001EE2 59                      	pop	cx
 18588 00001EE3 58                      	pop	ax
 18589 00001EE4 C3                      	retn
 18590                                  
 18591                                  ; --------------------------------------------------------------------------- 
 18592                                  
 18593                                  ;***	ReadCVFile - read from the Compressed Volume File
 18594                                  ;
 18595                                  ;	Entry	DX:AX file offset, ES:BX buffer location, CX length in bytes
 18596                                  ;
 18597                                  ;	Exit	CY set if error, else data read
 18598                                  ;
 18599                                  ;	Uses	AX, BX, CX, DX
 18600                                  
 18601                                  	; 08/06/2023 - Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 18602                                  ReadCVFile:
 18603 00001EE5 53                      	push	bx			; save buffer loc
 18604 00001EE6 51                      	push	cx			; save read length
 18605                                  
 18606 00001EE7 89D1                    	mov	cx,dx
 18607 00001EE9 89C2                    	mov	dx,ax			; cx:dx = file offset of fat entry
 18608                                  	;mov	ax,(LSEEK shl 8) or 0
 18609 00001EEB B80042                  	mov	ax,4200h
 18610 00001EEE 8B1E[3D9E]              	mov	bx,[fhCVF]
 18611 00001EF2 CD21                    	int	21h
 18612 00001EF4 720E                    	jc	short rcf_ret 		; CY set for error return
 18613                                  
 18614                                  	;mov	ah,READ
 18615 00001EF6 B43F                    	mov	ah,3Fh
 18616 00001EF8 59                      	pop	cx			; read length
 18617 00001EF9 5A                      	pop	dx			; buffer loc offset
 18618 00001EFA 1E                      	push	ds
 18619 00001EFB 06                      	push	es
 18620 00001EFC 1F                      	pop	ds			; buffer loc segment
 18621 00001EFD CD21                    	int	21h
 18622 00001EFF 1F                      	pop	ds
 18623 00001F00 7202                    	jc	short rcf_ret 		; CY set for error return
 18624                                  
 18625 00001F02 39C8                    	cmp	ax,cx			; read it all?
 18626                                  	;je	short rcf_ret 		; yes, CY clear
 18627                                  	; 08/06/2023	
 18628                                  	; ax < cx
 18629                                  	;stc				; end-of-file?
 18630                                  rcf_ret:
 18631 00001F04 C3                      	retn
 18632                                  
 18633                                  ;============================================================================
 18634                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 18635                                  ;============================================================================
 18636                                  ; 09/10/2018 - Retro DOS v3.0
 18637                                  
 18638                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
 18639                                  
 18640                                  ; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18641                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah
 18642                                  
 18643                                  ; =============== S U B	R O U T	I N E =======================================
 18644                                  
 18645                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18646                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:1FF4h
 18647                                  PAUSE:
 18648 00001F05 BA[6292]                	mov	dx,PAUSEMES_PTR ; 19/02/2023
 18649 00001F08 E80436                  	call	std_printf
 18650 00001F0B E819E7                  	call	GETKEYSTROKE
 18651                                  	;call	CRLF2
 18652                                  	;retn
 18653                                  	; 19/02/2023
 18654 00001F0E E9100C                  	jmp	CRLF2
 18655                                  
 18656                                  ; ---------------------------------------------------------------------------
 18657                                  
 18658                                  ;****************************************************************
 18659                                  ;*
 18660                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
 18661                                  ;*
 18662                                  ;* FUNCTION:	PARSE command line for file or path name and /P
 18663                                  ;*		and invoke PATHCRUNCH. If an error occurs, set
 18664                                  ;*		up an error message and transfer control to CERROR.
 18665                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
 18666                                  ;*		entered or SLASHP_ERASE if /P entered.
 18667                                  ;*
 18668                                  ;* INPUT:	command line at offset 81H
 18669                                  ;*
 18670                                  ;* OUTPUT:	if no error:
 18671                                  ;*		FCB at 5ch set up with filename(s) entered
 18672                                  ;*		Current directory set to entered directory
 18673                                  ;*
 18674                                  ;****************************************************************
 18675                                  
 18676                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18677                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
 18678                                  
 18679                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18680                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2001h
 18681                                  ERASE:
 18682                                  	; MSDOS 6.0
 18683                                  
 18684                                  	;assume	ds:trangroup,es:trangroup
 18685                                  
 18686 00001F11 BE8100                  	mov	si,81h		;AC000; get command line
 18687 00001F14 C706[089E]0000          	mov	word [COMSW],0 	;AN000; clear switch indicator
 18688 00001F1A BF[2B98]                	mov	di,PARSE_ERASE
 18689                                  				;AN000; Get address of PARSE_ERASE
 18690 00001F1D 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18691                                  erase_scan:
 18692 00001F1F 31D2                    	xor	dx,dx		;AN000;
 18693 00001F21 E8E507                  	call	Parse_With_Msg	;AC018; call parser
 18694                                  	
 18695                                  	;cmp	ax,-1  ; 0FFFFh
 18696                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 18697                                  	;je	short good_line	;AN000; yes - done parsing
 18698                                  	;;cmp	ax,0
 18699                                  	;;cmp	ax,RESULT_NO_ERROR ; 0
 18700                                  	;and	ax,ax		;AC000; did we have an error?
 18701                                  	;jnz	short errj2	;AC000; yes exit
 18702                                  	; 10/06/2023
 18703 00001F24 40                      	inc	ax  ; cmp ax,-1
 18704 00001F25 743C                    	jz	short good_line ; 0FFFFh -> 0
 18705 00001F27 48                      	dec	ax  ; cmp ax,0	
 18706 00001F28 7566                    	jnz	short errj2  ; 1 -> 0
 18707                                  	; ax = 0
 18708                                  
 18709 00001F2A 813E[E3A9][9E97]        	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
 18710                                  				;AN000; was /P entered?
 18711 00001F30 741C                    	je	short set_erase_prompt
 18712                                  				;AN000; yes - go set prompt
 18713                                  ;
 18714                                  ; Must be filespec since no other matches occurred. move filename to srcbuf
 18715                                  ;
 18716 00001F32 56                      	push	si		;AC000; save position in line
 18717 00001F33 C536[E5A9]              	lds	si,[PARSE1_ADDR]
 18718                                  				;AC000; get address of filespec
 18719                                  	;cmp	byte [si+1],colon_char
 18720 00001F37 807C013A                	cmp	byte [si+1],':'	;AC000; drive specified?
 18721 00001F3B 750B                    	jne	short erase_drive_ok
 18722                                  				;AC000; no - continue
 18723                                  	;cmp	byte [si+2],END_OF_LINE_OUT	
 18724 00001F3D 807C0200                	cmp	byte [si+2],0	;AC000; was only drive entered?
 18725 00001F41 7505                    	jne	short erase_drive_ok
 18726                                  				;AC000; no - continue
 18727 00001F43 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
 18728                                  				;AN022; get message number in control block
 18729 00001F46 EB3D                    	jmp	short extend_setup
 18730                                  				;AC000; exit
 18731                                  erase_drive_ok:
 18732 00001F48 E8AA12                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 18733 00001F4B 5E                      	pop	si		;AC000; get position back
 18734 00001F4C EBD1                    	jmp	short erase_scan
 18735                                  				;AN000; continue parsing
 18736                                  set_erase_prompt:
 18737 00001F4E 833E[089E]00            	cmp	word [COMSW],0 	;AN018; was /P already entered?
 18738 00001F53 7408                    	jz	short ok_to_set_erase_prompt
 18739                                  				;AN018; no go set switch
 18740                                  	;mov	ax,1
 18741 00001F55 B80100                  	mov	ax,MoreArgs_Ptr 
 18742                                  				;AN018; set up too many arguments
 18743 00001F58 E8BD07                  	call	setup_parse_error_msg
 18744                                  				;AN018; set up an error message
 18745 00001F5B EB33                    	jmp	short errj2	;AN018; exit
 18746                                  
 18747                                  ok_to_set_erase_prompt: 	;AN018;
 18748 00001F5D FF06[089E]              	inc	word [COMSW]	;AN000; indicate /p specified
 18749 00001F61 EBBC                    	jmp	short erase_scan
 18750                                  				;AN000; continue parsing
 18751                                  good_line:			;G  We know line is good
 18752 00001F63 E8640C                  	call	PathCrunch
 18753 00001F66 730D                    	jnc	short checkdr
 18754 00001F68 A1[25A2]                	mov	ax,[Msg_Numb]	;AN022; get message number
 18755                                  	;cmp	ax,0		;AN022; was message flag set?
 18756 00001F6B 09C0                    	or	ax,ax
 18757 00001F6D 7516                    	jnz	short extend_setup
 18758                                  				;AN022; yes - print out message
 18759                                  	;cmp	byte [DestIsDir],0
 18760 00001F6F 3806[AAA0]              	cmp	[DestIsDir],al 	; No CHDIRs worked
 18761 00001F73 750D                    	jnz	short badpath_err
 18762                                  				;AC022; see if they should have
 18763                                  checkdr:
 18764 00001F75 833E[089E]00            	cmp	word [COMSW],0 	;AN000; was /p specified
 18765 00001F7A 7403                    	jz	short notest2j	;AN000; no - go to notest2
 18766 00001F7C E9061B                  	jmp	slashp_erase	;AN000; yes - go to slashp_erase
 18767                                  notest2j:
 18768 00001F7F E99E1A                  	jmp	notest2
 18769                                  
 18770                                  badpath_err:			;AN022; "Path not found" message
 18771 00001F82 B80300                  	mov	ax,ERROR_PATH_NOT_FOUND ; 3
 18772                                  				;AN022; set up error number
 18773                                  extend_setup:			;AN022;
 18774                                  	;mov	byte [msg_disp_class],1
 18775 00001F85 C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class
 18776                                  				;AN022; set up extended error msg class
 18777 00001F8A BA[D091]                	mov	dx,extend_buf_ptr
 18778                                  				;AC022; get extended message pointer
 18779 00001F8D A3[D091]                	mov	[extend_buf_ptr],ax
 18780                                  				;AN022; get message number in control block
 18781                                  errj2:				;AC022; exit jump
 18782 00001F90 E90F0F                  	jmp	cerror		;AN022;
 18783                                  
 18784                                  ; ---------------------------------------------------------------------------
 18785                                  
 18786                                  ; ****************************************************************
 18787                                  ; *
 18788                                  ; * ROUTINE:	 CRENAME - rename file(s)
 18789                                  ; *
 18790                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
 18791                                  ; *		 filename. Invoke PATHCRUNCH on the full filespec.
 18792                                  ; *		 Make sure the second filespec only contains a
 18793                                  ; *		 filename. If both openands are valid, attempt
 18794                                  ; *		 to rename the file.
 18795                                  ; *
 18796                                  ; * INPUT:	 command line at offset 81H
 18797                                  ; *
 18798                                  ; * OUTPUT:	 none
 18799                                  ; *
 18800                                  ; ****************************************************************
 18801                                  
 18802                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18803                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18804                                  CRENAME:
 18805                                  	; MSDOS 6.0
 18806                                  	;assume	ds:trangroup,es:trangroup
 18807                                  
 18808 00001F93 BE8100                  	mov	si,81h		;AC000; Point to command line
 18809 00001F96 BF[AD98]                	mov	di,PARSE_RENAME
 18810                                  				;AN000; Get address of PARSE_RENAME
 18811 00001F99 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18812 00001F9B 31D2                    	xor	dx,dx		;AN000;
 18813 00001F9D E86907                  	call	Parse_With_Msg	;AC018; call parser
 18814                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 18815 00001FA0 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 18816                                  ;	jz	short crename_no_parse_error
 18817                                  				;AC000; no - continue
 18818 00001FA2 752C                    	jnz	short crename_parse_error
 18819                                  				;AC000; Yes, fail. (need long jump)
 18820                                  ;
 18821                                  ;  Get first file name returned from parse into our buffer
 18822                                  ;
 18823                                  crename_no_parse_error:
 18824 00001FA4 56                      	push	si		;AN000; save position in line
 18825 00001FA5 C536[E5A9]              	lds	si,[PARSE1_ADDR]
 18826                                  				;AN000; get address of filespec
 18827 00001FA9 E84912                  	call    Move_To_SrcBuf	;AN000; move to srcbuf
 18828 00001FAC 5E                      	pop	si		;AN000; restore position in line
 18829                                  
 18830 00001FAD 31D2                    	xor	dx,dx		;AN000; clear dx
 18831 00001FAF E85707                  	call	Parse_With_Msg	;AC018; call parser
 18832                                  	;cmp	ax,RESULT_NO_ERROR
 18833 00001FB2 21C0                    	and	ax,ax ; 0 ?	;AN000; did we have an error?
 18834 00001FB4 751A                    	jnz	short crename_parse_error
 18835                                  				;AN000; Yes, fail.
 18836                                  ;
 18837                                  ;  Check the second file name for drive letter colon
 18838                                  ;
 18839 00001FB6 56                      	push	si		;AN000; save position in line
 18840 00001FB7 C536[E5A9]              	lds	si,[PARSE1_ADDR]
 18841                                  				;AC000; get address of path
 18842                                  	;mov	al,':'		;AC000;
 18843                                  	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
 18844 00001FBB 807C013A                	cmp	byte [si+1],':'
 18845 00001FBF 7511                    	jnz	short ren_no_drive
 18846                                  				;AN000; Yes, error
 18847                                  	;mov	byte [msg_disp_class],2
 18848 00001FC1 C606[CE91]02            	mov	byte [msg_disp_class],parse_msg_class
 18849                                  				;AN000; set up parse error msg class
 18850 00001FC6 BA[D091]                	mov	dx,extend_buf_ptr
 18851                                  				;AC000; get extended message pointer
 18852                                  	;mov	word [extend_buf_ptr],0Ah
 18853 00001FC9 C706[D091]0A00          	mov	word [extend_buf_ptr],BadParm_Ptr
 18854                                  				;AN000; get "Invalid parameter" message number
 18855 00001FCF 5E                      	pop	si		;AN000;
 18856                                  crename_parse_error:		;AC022;
 18857 00001FD0 EB64                    	jmp	short errj	;AC000;
 18858                                  
 18859                                  ;  Get second file name returned from parse into the fCB. Save
 18860                                  ;  character after file name so we can later check to make sure it
 18861                                  ;  isn't a path character.
 18862                                  
 18863                                  ren_no_drive:
 18864 00001FD2 BF6C00                  	mov	di,FCB+10h ; 6Ch
 18865                                  				;AC000; set up to parse second file name
 18866                                  	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
 18867 00001FD5 B80129                  	mov	ax,2901h
 18868 00001FD8 CD21                    	int	21h		;AC000; do the function
 18869 00001FDA AC                      	lodsb			;AC000; Load char after filename
 18870 00001FDB A2[A2A0]                	mov	[One_Char_Val],al
 18871                                  				;AN000; save char after filename
 18872 00001FDE 5E                      	pop	si		;AN000; get line position back
 18873                                  ;
 18874                                  ; We have source and target. See if any args beyond.
 18875                                  ;
 18876 00001FDF BF[AD98]                	mov	di,PARSE_RENAME
 18877                                  				;AC000; get address of parse_rename
 18878 00001FE2 E80E07                  	call	parse_check_eol ;AC000; are we at end of line?
 18879 00001FE5 75E9                    	jnz	short crename_parse_error
 18880                                  				;AN000; no, fail.
 18881 00001FE7 E8E00B                  	call	PathCrunch
 18882 00001FEA BA[E191]                	mov	dx,BADCPMES_PTR
 18883 00001FED 74A1                    	jz	short errj2	; If 1st parm a dir, print error msg
 18884 00001FEF 730F                    	jnc	short notest3
 18885 00001FF1 A1[25A2]                	mov	ax,[Msg_Numb]	;AN022; get message number
 18886                                  	;cmp	ax,0		;AN022; was message flag set?
 18887 00001FF4 21C0                    	and	ax,ax ; 0 ?
 18888 00001FF6 758D                    	jnz	short extend_setup
 18889                                  				;AN022; yes - print out message
 18890                                  	;cmp	byte [DestIsDir],0
 18891 00001FF8 3806[AAA0]              	cmp	[DestIsDir],al	; No CHDIRs worked
 18892 00001FFC 7402                    	jz	short notest3 	; see if they should have
 18893 00001FFE EB82                    	Jmp	badpath_err	;AC022; set up error
 18894                                  notest3:
 18895 00002000 A0[A2A0]                	mov	al,[One_Char_Val]
 18896                                  				;AN000; move char into AX
 18897 00002003 BA[FF91]                	mov	dx,INORNOT_PTR 
 18898                                  				; Load invalid fname error ptr
 18899 00002006 E8B30B                  	call	pathchrcmp	; Is the char in al a path sep?
 18900 00002009 742B                    	jz	short errj	; Yes, error - 2nd arg must be
 18901                                  				;  filename only.
 18902                                  	;mov	ah,FCB_Rename
 18903 0000200B B417                    	mov	ah,17h
 18904 0000200D BA5C00                  	mov	dx,FCB ; 5Ch
 18905 00002010 CD21                    	int	21h
 18906 00002012 3CFF                    	cmp	al,0FFh		; Did an error occur??
 18907 00002014 7506                    	jne	short renameok
 18908                                  
 18909 00002016 E82902                  	call	get_ext_error_number
 18910                                  				;AN022; get extended error
 18911 00002019 50                      	push	ax		;AC022; Save results
 18912 0000201A B0FF                    	mov	al,0FFh		; Restore original error state
 18913                                  renameok:
 18914 0000201C 50                      	push	ax
 18915 0000201D E8BE09                  	call	RestUDir
 18916 00002020 58                      	pop	ax
 18917 00002021 FEC0                    	inc	al
 18918                                  	;;retnz
 18919                                  	;jz	short rn1
 18920                                  	;retn	
 18921 00002023 7514                    	jnz	short ret56
 18922                                  rn1:
 18923 00002025 58                      	pop	ax		;AC022; get the error number back
 18924 00002026 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
 18925                                  				;AN022; error file not found?
 18926 00002029 7408                    	je	short use_renerr
 18927                                  				;AN022; yes - use generic error message
 18928 0000202B 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5 
 18929                                  				;AN022; error file not found?
 18930 0000202E 7403                    	je	short use_renerr
 18931                                  				;AN022; yes - use generic error message
 18932 00002030 E952FF                  	jmp	extend_setup	;AN022; need long jump - use extended error
 18933                                  
 18934                                  use_renerr:
 18935 00002033 BA[DE91]                	mov	dx,RENERR_PTR	;AC022;
 18936                                  errj:
 18937 00002036 E9690E                  	jmp	cerror
 18938                                  ret56:
 18939                                  ;typefil_ret:	; 20/02/2023 ; 17/04/2023	
 18940 00002039 C3                      	retn
 18941                                  
 18942                                  ; ---------------------------------------------------------------------------
 18943                                  
 18944                                  ;****************************************************************
 18945                                  ;*
 18946                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
 18947                                  ;*		standard output device
 18948                                  ;*
 18949                                  ;* SYNTAX:	TYPE filespec
 18950                                  ;*
 18951                                  ;* FUNCTION:	If a valid filespec is found, read the file until
 18952                                  ;*		1Ah and display the contents to STDOUT.
 18953                                  ;*
 18954                                  ;* INPUT:	command line at offset 81H
 18955                                  ;*
 18956                                  ;* OUTPUT:	none
 18957                                  ;*
 18958                                  ;****************************************************************
 18959                                  
 18960                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18961                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 18962                                  TYPEFIL:
 18963                                  	; MSDOS 6.0	
 18964                                  	;assume	ds:trangroup,es:trangroup
 18965                                  
 18966 0000203A BE8100                  	mov	si,81h
 18967 0000203D BF[1998]                	mov	di,PARSE_MRDIR
 18968                                  				;AN000; Get address of PARSE_MRDIR
 18969 00002040 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 18970 00002042 31D2                    	xor	dx,dx		;AN000;
 18971 00002044 E8C206                  	call	Parse_With_Msg	;AC018; call parser
 18972                                  	;cmp	ax,RESULT_NO_ERROR
 18973 00002047 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 18974 00002049 751E                    	jnz	short typefil_parse_error
 18975                                  				;AN000; yes - issue error message
 18976                                  
 18977 0000204B 56                      	push	si		;AC000; save position in line
 18978 0000204C C536[E5A9]              	lds	si,[PARSE1_ADDR]
 18979                                  				;AC000; get address of filespec
 18980 00002050 E8A211                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 18981 00002053 5E                      	pop	si		;AC000; get position back
 18982 00002054 BF[1998]                	mov	di,PARSE_MRDIR
 18983                                  				;AC000; get address of parse_mrdir
 18984 00002057 E89906                  	call	parse_check_eol ;AC000; are we at end of line?
 18985                                  	;jz	short gottarg 	;AC000; yes - continue
 18986                                  	; 20/02/2023
 18987                                  ;typefil_parse_error:		;AN000; no - set up error message and exit
 18988                                  	;jmp	cerror
 18989 0000205A 750D                    	jnz	short typefil_parse_error
 18990                                  gottarg:
 18991 0000205C E8DD0F                  	call	SETPATH
 18992 0000205F F606[AEA0]02            	test	byte [DestInfo],00000010b ; 2
 18993                                  				; Does the filespec contain wildcards
 18994 00002064 7406                    	jz	short nowilds 	; No, continue processing
 18995 00002066 BA[FF91]                	mov	dx,INORNOT_PTR	; Yes, report error
 18996                                  	; 20/02/2023
 18997                                  typefil_parse_error:
 18998 00002069 E9360E                  	jmp	cerror
 18999                                  nowilds:
 19000                                  	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
 19001 0000206C B8006C                  	mov	ax,6C00h
 19002                                  	;mov	bx,read_open_mode ; 0
 19003                                  				;AN000; get open mode for TYPE
 19004 0000206F 31C9                    	xor	cx,cx		;AN000; no special files
 19005 00002071 89CB                    	mov	bx,cx ; 20/02/2023
 19006 00002073 BA0101                  	mov	dx,101h
 19007                                  	;mov	dx,read_open_flag ; 101h
 19008                                  				;AN000; set up open flags
 19009 00002076 BE[12A1]                	mov	si,SrcBuf	;AN030; get file name
 19010 00002079 CD21                    	int	21h
 19011 0000207B 7313                    	jnc	short typecont	; If open worked, continue. Otherwise load
 19012                                  
 19013                                  typerr: 			;AN022;
 19014 0000207D 0E                      	push	cs		;AN022; make sure we have local segment
 19015 0000207E 1F                      	pop	ds		;AN022;
 19016 0000207F E8B001                  	call	Set_Ext_Error_Msg ;AN022;
 19017 00002082 C706[91A0][12A1]        	mov	word [string_ptr_2],SrcBuf 
 19018                                  				;AC022; get address of failed string
 19019                                  	;mov	byte [extend_buf_sub],1
 19020 00002088 C606[D291]01            	mov	byte [extend_buf_sub],one_subst
 19021                                  				;AC022; put number of subst in control block
 19022 0000208D E9120E                  	jmp	cerror		;AC022; exit
 19023                                  
 19024                                  typecont:
 19025 00002090 89C3                    	mov	bx,ax		;AC000; get Handle
 19026                                  ;M043
 19027                                  ; We should do the LSEEK for filesize only if this handle belongs to a file
 19028                                  ;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
 19029                                  ;indicate it is a device.
 19030                                  ;
 19031                                  	;mov	ax,(IOCTL shl 8) or 0
 19032 00002092 B80044                  	mov	ax,4400h
 19033 00002095 CD21                    	int	21h
 19034                                  
 19035 00002097 F6C280                  	test	dl,80h		;is it a device?
 19036 0000209A 7408                    	jz	short not_device
 19037                                  				;no, a file
 19038                                  
 19039 0000209C C706[DFA9]FFFF          	mov	word [TypeFilSiz+2],-1 ; 0FFFFh
 19040                                  				;indicate it is a device
 19041 000020A2 EB17                    	jmp	short dotype
 19042                                  not_device:
 19043                                  ;SR;
 19044                                  ; Find the filesize by seeking to the end and then reset file pointer to
 19045                                  ;start of file
 19046                                  
 19047                                  	;mov	ax,(LSEEK shl 8) or 2
 19048 000020A4 B80242                  	mov	ax,4202h
 19049 000020A7 31D2                    	xor	dx,dx
 19050 000020A9 89D1                    	mov	cx,dx		;seek  to end of file
 19051 000020AB CD21                    	int	21h
 19052                                  
 19053 000020AD A3[DDA9]                	mov	[TypeFilSiz],ax
 19054 000020B0 8916[DFA9]              	mov	[TypeFilSiz+2],dx ;store filesize
 19055                                  	;mov	ax,(LSEEK shl 8) or 0
 19056 000020B4 B80042                  	mov	ax,4200h
 19057 000020B7 31D2                    	xor	dx,dx
 19058 000020B9 CD21                    	int	21h	        ;reset file pointer to start
 19059                                  dotype:				;M043
 19060 000020BB C606[D6A1]00            	mov	byte [zflag],0 	; Reset ^Z flag
 19061 000020C0 8E1E[F59D]              	mov	ds,[TPA]
 19062 000020C4 31D2                    	xor	dx,dx
 19063                                  	;ASSUME	DS:NOTHING
 19064                                  typelp:
 19065 000020C6 2E803E[D6A1]00          	cmp	byte [cs:zflag],0
 19066                                  				;AC050; Is the ^Z flag set?
 19067                                  	;retnz			; Yes, return
 19068                                  	; 17/04/2023
 19069 000020CC 7401                    	jz	short tf1
 19070 000020CE C3                      	retn
 19071                                  tf1:
 19072 000020CF 2E8B0E[129E]            	mov	cx,[cs:BYTCNT]	;AC056; No, continue
 19073                                  
 19074                                  ;Update the filesize left to read
 19075                                  
 19076 000020D4 2E833E[DFA9]FF          	cmp	word [cs:TypeFilSiz+2],-1
 19077                                  				;is it a device? M043
 19078 000020DA 7431                    	je	short typ_read	;yes, just read from it; M043
 19079                                  
 19080 000020DC 2E833E[DFA9]00          	cmp	word [cs:TypeFilSiz+2],0
 19081                                  				;more than 64K left?
 19082 000020E2 740D                    	jz	short lt64k	;no, do word subtraction
 19083 000020E4 2E290E[DDA9]            	sub	[cs:TypeFilSiz],cx
 19084 000020E9 2E831E[DFA9]00          	sbb	word [cs:TypeFilSiz+2],0
 19085                                  				;update filesize
 19086 000020EF EB1C                          	jmp	short typ_read	;do the read
 19087                                  lt64k:
 19088 000020F1 2E3B0E[DDA9]            	cmp	cx,[cs:TypeFilSiz]
 19089                                  				;readsize <= buffer?
 19090 000020F6 7610                    	jbe	short gtbuf	; yes, just update readsize
 19091                                  
 19092                                  ;Buffer size is larger than bytes to read
 19093                                  
 19094 000020F8 2E8B0E[DDA9]            	mov	cx,[cs:TypeFilSiz]
 19095 000020FD E361                    	jcxz	typelp_ret
 19096 000020FF 2EC706[DDA9]0000        	mov	word [cs:TypeFilSiz],0
 19097 00002106 EB05                    	jmp	short typ_read
 19098                                  gtbuf:
 19099 00002108 2E290E[DDA9]            	sub	[cs:TypeFilSiz],cx
 19100                                  				;update filesize remaining
 19101                                  typ_read:
 19102                                  	;mov	ah,read
 19103 0000210D B43F                    	mov	ah,3Fh
 19104 0000210F CD21                    	int	21h
 19105 00002111 7303                    	jnc	short tf2	;M043
 19106 00002113 E967FF                  	jmp	typerr		;M043
 19107                                  tf2:				;M043
 19108                                  ;M043;	jc	typerr		;AN022; Exit if error
 19109                                  
 19110 00002116 89C1                    	mov	cx,ax
 19111 00002118 E346                    	jcxz	typelp_ret	;AC000; exit if nothing read
 19112 0000211A 1E                      	push	ds
 19113 0000211B 07                      	pop	es		; Check to see if a ^Z was read.
 19114                                  	;assume es:nothing
 19115 0000211C 31FF                    	xor	di,di
 19116 0000211E 50                      	push	ax
 19117 0000211F B01A                    	mov	al,1Ah
 19118 00002121 F2AE                    	repnz	scasb
 19119 00002123 58                      	pop	ax
 19120 00002124 91                      	xchg	ax,cx
 19121                                  	;cmp	ax,0
 19122 00002125 21C0                    	and	ax,ax
 19123 00002127 7506                    	jnz	short foundz	; Yes, handle it
 19124 00002129 807DFF1A                	cmp	byte [di-1],1Ah	; No, double check
 19125 0000212D 750A                    	jnz	short typecont2	; No ^Z, continue
 19126                                  foundz:
 19127 0000212F 29C1                    	sub	cx,ax		; Otherwise change cx so that only those
 19128 00002131 49                      	dec	cx		;  bytes up to but NOT including the ^Z
 19129 00002132 0E                      	push	cs		;  will be typed.
 19130 00002133 07                      	pop	es
 19131                                  	;assume es:trangroup
 19132 00002134 26F616[D6A1]            	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
 19133                                  typecont2:			;  will quit after this write.
 19134 00002139 53                      	push	bx
 19135 0000213A BB0100                  	mov	bx,1
 19136                                  	;mov	ah,Write
 19137 0000213D B440                    	mov	ah,40h
 19138 0000213F CD21                    	int	21h
 19139 00002141 5B                      	pop	bx
 19140 00002142 720C                    	jc	short Error_outputj
 19141 00002144 39C8                    	cmp	ax,cx
 19142 00002146 7503                    	jnz	short tf3	;M043
 19143 00002148 E97BFF                  	jmp	typelp		;M043
 19144                                  tf3:				;M043
 19145                                  ;M043;	jz	short typelp
 19146 0000214B 49                      	dec	cx
 19147 0000214C 39C8                    	cmp	ax,cx
 19148                                  	;;retz			; One less byte OK (^Z)
 19149                                  	;jnz	short Error_outputj
 19150                                  ;tf4:
 19151                                  	;retn
 19152 0000214E 7410                    	jz	short typelp_ret ; 20/02/2023
 19153                                  
 19154                                  Error_outputj:
 19155 00002150 BB0100                  	mov	bx,1
 19156                                  	;mov	ax,IOCTL SHL 8
 19157 00002153 B80044                  	mov	ax,4400h
 19158 00002156 CD21                    	int	21h
 19159 00002158 F6C280                  	test	dl,80h
 19160                                  	;test	dl,devid_ISDEV
 19161                                  	;;retnz			; If device, no error message
 19162                                  	;jnz	short tf4
 19163 0000215B 7503                    	jnz	short typelp_ret
 19164 0000215D E9420A                  	jmp	error_output
 19165                                  typelp_ret:
 19166 00002160 C3                      	retn
 19167                                  
 19168                                  ; ---------------------------------------------------------------------------
 19169                                  
 19170                                  ; VOLUME command displays the volume ID on the specified drive
 19171                                  
 19172                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19173                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19174                                  	; 10/06/2023
 19175                                  VOLUME:
 19176                                  	; MSDOS 6.0
 19177 00002161 BE8100                  	mov	si,81h
 19178 00002164 BF[0798]                	mov	di,PARSE_VOL
 19179                                  				;AN000; Get address of PARSE_VOL
 19180 00002167 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 19181 00002169 31D2                    	xor	dx,dx		;AN000;
 19182 0000216B E89B05                  	call	Parse_With_Msg	;AC018; call parser
 19183                                  
 19184                                  	;cmp	ax,-1 ; 0FFFFh
 19185                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 19186                                  	;je	short OkVolArg	;AC000; Yes, display default volume ID
 19187                                  	;;cmp	ax,RESULT_NO_ERROR
 19188                                  	;;cmp	ax,0		;AC000; did we have an error?
 19189                                  	;or	ax,ax ; 0?
 19190                                  	;jnz	short badvolarg	;AC000; Yes, fail.
 19191                                  	; 10/06/2023
 19192 0000216E 40                      	inc	ax  ; cmp ax,-1
 19193 0000216F 7443                    	jz	short OkVolArg ; 0FFFFh -> 0
 19194 00002171 48                      	dec	ax  ; cmp ax,0
 19195 00002172 750A                    	jnz	short badvolarg ; 1 -> 0
 19196                                  	; ax = 0
 19197                                  
 19198                                  ; We have parsed off the drive. See if there are any more chars left
 19199                                  
 19200 00002174 BF[0798]                	mov	di,PARSE_VOL
 19201                                  				;AC000; get address of parse_vol
 19202 00002177 31D2                    	xor	dx,dx		;AC000;
 19203 00002179 E87705                  	call	parse_check_eol ;AC000; call parser
 19204 0000217C 7436                    	jz	short OkVolArg	;AC000; yes, end of road
 19205                                  
 19206                                  ; The line was not interpretable. Report an error.
 19207                                  
 19208                                  badvolarg:
 19209 0000217E E9210D                  	jmp	cerror
 19210                                  
 19211                                  ; ---------------------------------------------------------------------------
 19212                                  
 19213                                  ;***	DisAppend - disable APPEND
 19214                                  ;
 19215                                  ;	ENTRY	nothing
 19216                                  ;
 19217                                  ;	EXIT	nothing
 19218                                  ;
 19219                                  ;	USED	AX,BX
 19220                                  ;
 19221                                  ;	EFFECTS
 19222                                  ;
 19223                                  ;	  APPEND is disabled. If it was active, it will be re-enabled
 19224                                  ;	  after the command finishes, by the HeadFix routine.
 19225                                  ;
 19226                                  ;	NOTE
 19227                                  ;
 19228                                  ;	  This routine must not be called more than once during a single
 19229                                  ;	  command cycle. The second call would permanently disable APPEND.
 19230                                  
 19231                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19232                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh
 19233                                  	
 19234                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19235                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2289h
 19236                                  
 19237                                  	; MSDOS 6.0
 19238                                  DisAppend:
 19239 00002181 1E                      	push	ds			; save DS
 19240 00002182 06                      	push	es			; save ES
 19241 00002183 57                      	push	di
 19242                                  
 19243                                  	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
 19244 00002184 B800B7                  	mov	ax,0B700h
 19245 00002187 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19246 00002189 08C0                    	or	al,al
 19247 0000218B 7423                    	jz	short daRet		; APPEND not installed, return
 19248                                  
 19249                                  	;mov	ax,APPENDDOS		; AX = Get Append Version code
 19250 0000218D B802B7                  	mov	ax,0B702h
 19251 00002190 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19252 00002192 83F8FF                  	cmp	ax,0FFFFh
 19253 00002195 7519                    	jne	short daRet		; it's not a local version, return
 19254                                  
 19255                                  	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
 19256 00002197 B806B7                  	mov	ax,0B706h
 19257 0000219A CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19258                                  
 19259 0000219C 8E1E[F39D]              	mov	ds,[RESSEG]		; DS = resident seg addr
 19260                                  
 19261 000021A0 891E[6002]              	mov	[Append_State],bx	; Append_State = saved APPEND state
 19262 000021A4 C606[6202]FF            	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state
 19263                                  
 19264 000021A9 31DB                    	xor	bx,bx			; BX = APPEND state = off
 19265                                  	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
 19266 000021AB B807B7                  	mov	ax,0B707h
 19267 000021AE CD2F                    	int	2Fh			; talk to APPEND via multiplex
 19268                                  daRet:	
 19269 000021B0 5F                      	pop	di
 19270 000021B1 07                      	pop	es			; restore ES
 19271 000021B2 1F                      	pop	ds			; restore DS
 19272                                  
 19273 000021B3 C3                      	retn
 19274                                  
 19275                                  ; ---------------------------------------------------------------------------
 19276                                  
 19277                                  ; Find the Volume ID on the disk.
 19278                                  
 19279                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19280                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19281                                  	
 19282                                  	; MSDOS 6.0
 19283                                  OkVolArg:
 19284 000021B4 E8CAFF                  	call	DisAppend		; disable APPEND
 19285 000021B7 E86709                  	call	CRLF2
 19286                                  	;mov	al,blank			
 19287 000021BA B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 19288 000021BC E88E01                  	call	PRINT_CHAR		;AN051;  before volume message
 19289 000021BF 1E                      	push	ds
 19290 000021C0 07                      	pop	es
 19291                                  
 19292                                  ; Volume IDs are only findable via extended FCBs or find_first with attributes
 19293                                  ; of volume_id ONLY.
 19294                                  
 19295 000021C1 BF5500                  	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
 19296 000021C4 B0FF                    	mov	al,-1 ; 0FFh		; Tag to indicate Extention
 19297 000021C6 AA                      	stosb
 19298 000021C7 31C0                    	xor	ax,ax			; Zero padding to volume label
 19299 000021C9 AB                      	stosw
 19300 000021CA AB                      	stosw
 19301 000021CB AA                      	stosb
 19302 000021CC B008                    	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
 19303 000021CE AA                      	stosb
 19304 000021CF 47                      	inc	di			; Skip drive byte; it is already set
 19305 000021D0 B90B00                  	mov	cx,11			; fill in remainder of file
 19306 000021D3 B03F                    	mov	al,'?'
 19307 000021D5 F3AA                    	rep	stosb
 19308                                  
 19309                                  ; Set up transfer address (destination of search first information)
 19310                                  
 19311 000021D7 BA[2AA0]                	mov	dx,DIRBUF
 19312                                  	;mov	ah,Set_DMA
 19313 000021DA B41A                    	mov	ah,1Ah
 19314 000021DC CD21                    	int	21h
 19315                                  
 19316                                  ; Do the search
 19317                                  
 19318 000021DE BA5500                  	mov	dx,FCB-7 ; 55h
 19319                                  	;mov	ah,Dir_Search_First
 19320 000021E1 B411                    	mov	ah,11h
 19321 000021E3 CD21                    	int	21h
 19322                                  
 19323                                  ;********************************
 19324                                  ; Print volume ID info
 19325                                  
 19326 000021E5 50                      	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
 19327 000021E6 A05C00                  	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
 19328 000021E9 0440                    	add	al,'@'  ; add al,40h
 19329 000021EB 3C40                    	cmp	al,'@'
 19330 000021ED 7505                    	jne	short drvok
 19331 000021EF A0[059E]                	mov	al,[CURDRV]
 19332                                  	;add	al,capital_A
 19333 000021F2 0441                    	add	al,'A'
 19334                                  drvok:
 19335 000021F4 A2[A4A0]                	mov	[vol_drv],al		;AC000; get drive letter into argument
 19336 000021F7 58                      	pop	ax			;AC000; get return code back
 19337 000021F8 08C0                    	or	al,al			;AC000; volume label found?
 19338 000021FA 7405                    	jz	short Get_vol_name	;AC000; volume label exists - go get it
 19339 000021FC BA[CB92]                	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
 19340 000021FF EB13                    	jmp	short print_serial	;AC000; go print it
 19341                                  
 19342                                  Get_vol_name:
 19343 00002201 BF[5B9F]                	mov	di,CHARBUF
 19344 00002204 89FA                    	mov	dx,di
 19345 00002206 BE[32A0]                	mov	si,DIRBUF+8		;AN000;  3/3/KK
 19346 00002209 B90B00                  	mov	cx,11			;AN000;  3/3/KK
 19347 0000220C F3A4                    	rep	movsb			;AN000;  3/3/KK
 19348                                  
 19349 0000220E 30C0                    	xor	al,al			;AC000; store a zero to terminate the string
 19350 00002210 AA                      	stosb
 19351 00002211 BA[D992]                	mov	dx,VolMes_Ptr		;AC000; set up message
 19352                                  
 19353                                  print_serial:
 19354                                  
 19355                                  ; Attempt to get the volume serial number from the disk. If an error
 19356                                  ; occurs, do not print volume serial number.
 19357                                  
 19358 00002214 52                      	push	dx			;AN000; save message offset
 19359                                  	;mov	ax,(GetSetMediaID SHL 8)
 19360 00002215 B80069                  	mov	ax,6900h		;AC036; Get the volume serial info
 19361 00002218 8A1E5C00                	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
 19362 0000221C BA[0AA2]                	mov	dx,vol_ioctl_buf	;AN000;target buffer
 19363 0000221F CD21                    	int	21h			;AN000; do the call
 19364                                  			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
 19365                                  			; AL = 00h get serial number / 01h set serial number
 19366                                  			; BL = drive (0=default, 1=A, 2=B, etc)
 19367                                  			; DS:DX -> disk info
 19368 00002221 5A                      	pop	dx			;AN000; get message offset back
 19369 00002222 720B                    	jc	short printvol_end	;AN000; if error, just go print label
 19370 00002224 E8E832                  	call	std_printf		;AC000; go print volume message
 19371                                  	;mov	al,blank				
 19372 00002227 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 19373 00002229 E82101                  	call	PRINT_CHAR		;AN051;  before volume message
 19374 0000222C BA[F292]                	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
 19375                                  printvol_end:
 19376 0000222F E9DD32                  	jmp	std_printf		;AC000; go print and exit
 19377                                  
 19378                                  ; ---------------------------------------------------------------------------
 19379                                  
 19380                                  ;****************************************************************
 19381                                  ;*
 19382                                  ;* ROUTINE:	Set_ext_error_msg
 19383                                  ;*
 19384                                  ;* FUNCTION:	Sets up extended error message for printing
 19385                                  ;*
 19386                                  ;* INPUT:	return from INT 21
 19387                                  ;*
 19388                                  ;* OUTPUT:	extended error message set up in extended error
 19389                                  ;*		buffer.
 19390                                  ;*
 19391                                  ;****************************************************************
 19392                                  	
 19393                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19394                                  
 19395                                  	; MSDOS 6.0
 19396                                  Set_Ext_Error_Msg:			;AN000;
 19397 00002232 E80D00                  	call	get_ext_error_number	;AC022; get the extended error
 19398 00002235 C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class
 19399                                  	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
 19400 0000223A BA[D091]                	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
 19401 0000223D A3[D091]                	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
 19402 00002240 F9                      	stc				;AN000; make sure carry is set
 19403 00002241 C3                      	retn				;AN000; return
 19404                                  
 19405                                  ; ---------------------------------------------------------------------------
 19406                                  
 19407                                  ;****************************************************************
 19408                                  ;*
 19409                                  ;* ROUTINE:	Get_ext_error_number
 19410                                  ;*
 19411                                  ;* FUNCTION:	Does get extended error function call
 19412                                  ;*
 19413                                  ;* INPUT:	return from INT 21
 19414                                  ;*
 19415                                  ;* OUTPUT:	AX - extended error number
 19416                                  ;*
 19417                                  ;****************************************************************
 19418                                  
 19419                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19420                                  
 19421                                  	; MSDOS 6.0
 19422                                  get_ext_error_number:			;AN022;
 19423                                  
 19424                                  	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
 19425                                  					;AN022; save registers
 19426 00002242 53                      	push	bx
 19427 00002243 51                      	push	cx
 19428 00002244 52                      	push	dx
 19429 00002245 56                      	push	si
 19430 00002246 57                      	push	di
 19431 00002247 55                      	push	bp
 19432 00002248 06                      	push	es
 19433 00002249 1E                      	push	ds
 19434                                  	;mov	ah,GetExtendedError	;AN022; get extended error
 19435 0000224A B459                    	mov	ah,59h
 19436 0000224C 31DB                    	xor	bx,bx			;AN022; clear BX
 19437 0000224E CD21                    	int	21h			;AN022;
 19438                                  			; DOS - 3+ - GET EXTENDED ERROR CODE
 19439                                  			; BX = version code (0000h for DOS 3.x)
 19440                                  
 19441                                  	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
 19442                                  					;AN022; restore registers
 19443 00002250 1F                      	pop	ds
 19444 00002251 07                      	pop	es
 19445 00002252 5D                      	pop	bp
 19446 00002253 5F                      	pop	di
 19447 00002254 5E                      	pop	si
 19448 00002255 5A                      	pop	dx
 19449 00002256 59                      	pop	cx
 19450 00002257 5B                      	pop	bx
 19451                                  
 19452 00002258 C3                      	retn				;AN022; return
 19453                                  
 19454                                  ;============================================================================
 19455                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
 19456                                  ;============================================================================
 19457                                  ; 08/10/2018 - Retro DOS v3.0
 19458                                  
 19459                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
 19460                                  
 19461                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 19462                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h
 19463                                  
 19464                                  ; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19465                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 2361h
 19466                                  
 19467                                  ; ---------------------------------------------------------------------------
 19468                                  
 19469                                  ; MSDOS 6.0
 19470                                  ;***	Version - display DOS version
 19471                                  ;
 19472                                  ;	SYNTAX	ver [/debug]
 19473                                  ;
 19474                                  ;		/debug - display additional DOS configuration info
 19475                                  ;
 19476                                  ;	ENTRY	command-line tail is in PSP
 19477                                  ;
 19478                                  ;	EXIT	if successful, nothing
 19479                                  ;		if parse fails,
 19480                                  ;		  parse error message is set up (for Std_EPrintf)
 19481                                  ;		    AX = system parser error code
 19482                                  ;		    DX = ptr to message block
 19483                                  ;		  we jump to CError
 19484                                  ;
 19485                                  ;	EFFECTS
 19486                                  ;	  If parse fails, a parse error message is displayed.
 19487                                  ;	  Otherwise, version message is displayed.
 19488                                  ;	  If /debug is specified, additional DOS info is displayed.
 19489                                  
 19490                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19491                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19492                                  VERSION:
 19493                                  	;assume	ds:TRANGROUP,es:TRANGROUP
 19494                                  
 19495                                  ;	Parse command line for /debug switch.
 19496                                  
 19497 00002259 BE8100                  	mov	si,81h			; DS:SI = ptr to command tail
 19498 0000225C BF[CA98]                	mov	di,PARSE_VER		; ES:DI = ptr to parse block
 19499 0000225F 31C9                    	xor	cx,cx			; CX = # positional param's found
 19500 00002261 E8A504                  	call	Parse_With_Msg
 19501                                  
 19502 00002264 B301                    	mov	bl,1			; BL = flag = /debug present
 19503                                  	;cmp	ax,RESULT_NO_ERROR
 19504                                  	;cmp	ax,0
 19505                                  	;je	short verPrintVer	; something parsed - must be /debug
 19506 00002266 09C0                    	or	ax,ax
 19507 00002268 740A                    	jz	short verPrintVer 
 19508 0000226A FECB                    	dec	bl			; BL = flag = no /debug present
 19509                                  	;cmp	ax,END_OF_LINE ; -1
 19510 0000226C 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 19511                                  
 19512                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 19513                                  %if 0
 19514                                  	je	short verPrintVer	; reached end of line - ok
 19515                                  %else
 19516 0000226F 7414                    	je	short not_truever_sw
 19517                                  %endif
 19518                                  
 19519                                  ;	The parse failed. Error message has been set up.
 19520                                  
 19521 00002271 E92E0C                  	jmp	cerror
 19522                                  
 19523                                  verPrintVer:
 19524                                  
 19525                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 19526                                  %if 1
 19527                                  check_t_switch:
 19528 00002274 813E[E3A9][EA98]        	cmp	word [PARSE1_SYN],SLASH_T_SYN ; "/T" ; /t switch
 19529 0000227A 7509                    	jne	short not_truever_sw
 19530 0000227C BA[0E99]                	mov	dx,RD4CMD_VER_MSG
 19531 0000227F B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9 ; print the message
 19532 00002281 CD21                    	int	21h
 19533 00002283 EB43                    	jmp	short verDone
 19534                                  not_truever_sw:
 19535                                  %endif
 19536 00002285 53                      	push	bx			; save /debug flag
 19537 00002286 E89808                  	call	CRLF2
 19538 00002289 E83F00                  	call	PRINT_VERSION
 19539 0000228C E89208                  	call	CRLF2
 19540 0000228F 5B                      	pop	bx   			; BL = /debug flag
 19541 00002290 08DB                    	or	bl,bl
 19542 00002292 7434                    	jz	short verDone		; /debug is false - we're done
 19543                                  
 19544                                  ;*	For /debug, display DOS internal revision and DOS location
 19545                                  ;	(low memory, HMA, or ROM).
 19546                                  
 19547                                  ;	Bugbug:	use symbols for bitmasks below.
 19548                                  
 19549                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
 19550 00002294 B80633                  	mov	ax,3306h
 19551 00002297 CD21                    	int	21h
 19552                                  		; DOS - 5+ Get TRUE Version Number
 19553                                  		; (BL major, BH minor, DL revision, DH flags)
 19554 00002299 88D0                    	mov	al,dl			;revision number in dl; M013
 19555 0000229B 88F7                    	mov	bh,dh			;flags in dh now; M013
 19556                                  ;M032	and	al,7			; AL = DOS internal revision
 19557 0000229D 3C19                    	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
 19558                                  	;jbe	short @f	 ;M032	; A-to-Z revision ok
 19559 0000229F 7602                    	jbe	short ver1
 19560 000022A1 B0E9                    	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
 19561                                  ;@@:
 19562                                  ver1:
 19563 000022A3 0441                    	add	al,'A' ; 41h		; AL = DOS internal rev letter
 19564 000022A5 A2[A2A0]                	mov	[One_Char_Val],al
 19565 000022A8 BA[2994]                	mov	dx,dosrev_ptr
 19566 000022AB E86132                  	call	std_printf		; print DOS internal revision
 19567                                  
 19568 000022AE B104                    	mov	cl,4
 19569 000022B0 D2EF                    	shr	bh,cl			; CY = DOS in ROM
 19570 000022B2 7209                    	jc	short verRom
 19571 000022B4 D0EF                    	shr	bh,1			; CY = DOS in HMA
 19572 000022B6 720A                    	jc	short verHma
 19573                                  
 19574                                  ;	DOS isn't in ROM or HMA, so it must be in lower memory.
 19575                                  
 19576                                  	;mov	dx,offset TRANGROUP:DosLow_Ptr
 19577 000022B8 BA[3D94]                	mov	dx,DosLow_Ptr
 19578 000022BB EB08                    	jmp	short verPrintLoc
 19579                                  verRom: 
 19580                                  	;mov	dx,offset TRANGROUP:DosRom_Ptr
 19581 000022BD BA[3794]                	mov	dx,DosRom_Ptr
 19582 000022C0 EB03                    	jmp	short verPrintLoc
 19583                                  verHma: 
 19584                                  	;mov	dx,offset TRANGROUP:DosHma_Ptr
 19585 000022C2 BA[3A94]                	mov	dx,DosHma_Ptr
 19586                                  verPrintLoc:
 19587 000022C5 E84732                  	call	std_printf
 19588                                  verDone:
 19589 000022C8 E95608                  	jmp	CRLF2
 19590                                  
 19591                                  ; 21/02/2023
 19592                                  ;	; MSDOS 3.3
 19593                                  ;VERSION:
 19594                                  ;	call	CRLF2
 19595                                  ;	call	PRINT_VERSION
 19596                                  ;	jmp	CRLF2
 19597                                  
 19598                                  ; =============== S U B	R O U T	I N E =======================================
 19599                                  
 19600                                  	; 21/02/2023 - Retro DOS v4.0
 19601                                  PRINT_VERSION:
 19602                                  	;mov	ah,GET_VERSION ; 30h
 19603 000022CB B430                    	mov	ah,30h
 19604 000022CD CD21                    	int	21h	; DOS -	GET DOS	VERSION
 19605                                  			; Return: AL = major version number (00h for DOS 1.x)
 19606 000022CF 50                      	push	ax
 19607 000022D0 30E4                    	xor	ah,ah
 19608 000022D2 A3[9EA0]                	mov	[Major_Ver_Num],ax
 19609 000022D5 58                      	pop	ax
 19610 000022D6 86E0                    	xchg	ah,al
 19611 000022D8 30E4                    	xor	ah,ah
 19612 000022DA A3[A0A0]                	mov	[Minor_Ver_Num],ax
 19613 000022DD BA[B292]                	mov	dx,VerMes_Ptr
 19614 000022E0 E92C32                  	jmp	std_printf
 19615                                  
 19616                                  ; =============== S U B	R O U T	I N E =======================================
 19617                                  
 19618                                  	; 21/02/2023 - Retro DOS v4.0
 19619                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19620                                  PRINT_PROMPT:
 19621 000022E3 1E                      	push	ds
 19622 000022E4 0E                      	push	cs
 19623 000022E5 1F                      	pop	ds		; Make sure DS is in TRANGROUP
 19624 000022E6 06                      	push	es
 19625 000022E7 E87805                  	call	find_prompt	; Look for prompt string
 19626 000022EA 7206                    	jc	short PP0	; Can't find one
 19627 000022EC 26803D00                	cmp	byte [es:di],0
 19628 000022F0 7524                    	jnz	short PP1
 19629                                  PP0:				; Use default prompt
 19630 000022F2 E86700                  	call	PRINT_DRIVE
 19631 000022F5 B03E                    	mov	al,'>'
 19632                                  	;mov	al,SYM
 19633 000022F7 E85300                  	call	PRINT_CHAR
 19634 000022FA EB36                    	jmp	short PP5
 19635                                  ;PP1:
 19636                                  ;	mov	al,[es:di]	; Get a char
 19637                                  ;	inc	di
 19638                                  ;	or	al,al
 19639                                  ;	jz	short PP5	; Nul terminated
 19640                                  ;	; 21/02/2023
 19641                                  ;	cmp	al,'$' ; 24h
 19642                                  ;	;cmp	al,[DOLLAR]	; Meta character
 19643                                  ;	jz	short PP2	; Nope
 19644                                  ;	call	PRINT_CHAR
 19645                                  ;	jmp	short PP1
 19646                                  PP2:
 19647 000022FC 268A05                  	mov	al,[es:di]
 19648 000022FF 47                      	inc	di
 19649                                  	;mov	bx,CLSSTRING+2	; "[2J"
 19650 00002300 BB[9895]                	mov	bx,PROMPT_TABLE-3
 19651 00002303 08C0                    	or	al,al
 19652 00002305 742B                    	jz	short PP5
 19653                                  PP3:
 19654 00002307 83C303                  	add	bx,3
 19655                                  	; 21/02/2023
 19656 0000230A E82C06                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 19657                                  	;call	UPCONV_MAPCALL  ; MSDOS 3.3
 19658 0000230D 3A07                    	cmp	al,[bx]
 19659 0000230F 7416                    	jz	short PP4
 19660 00002311 803F00                  	cmp	byte [bx],0
 19661 00002314 75F1                    	jnz	short PP3
 19662                                  	;jmp	short PP1
 19663                                  	; 21/02/2023
 19664                                  PP1:
 19665 00002316 268A05                  	mov	al,[es:di]	; Get a char
 19666 00002319 47                      	inc	di
 19667 0000231A 08C0                    	or	al,al
 19668 0000231C 7414                    	jz	short PP5	; Nul terminated
 19669                                  	; 21/02/2023
 19670 0000231E 3C24                    	cmp	al,'$' ; 24h
 19671                                  	;cmp	al,[DOLLAR]	; Meta character
 19672 00002320 74DA                    	jz	short PP2	; Nope
 19673 00002322 E82800                  	call	PRINT_CHAR
 19674 00002325 EBEF                    	jmp	short PP1
 19675                                  PP4:
 19676 00002327 06                      	push	es
 19677 00002328 57                      	push	di
 19678 00002329 0E                      	push	cs
 19679 0000232A 07                      	pop	es
 19680 0000232B FF5701                  	call	word [bx+1]
 19681 0000232E 5F                      	pop	di
 19682 0000232F 07                      	pop	es
 19683 00002330 EBE4                    	jmp	short PP1
 19684                                  PP5:
 19685 00002332 07                      	pop	es		; Restore segments
 19686 00002333 1F                      	pop	ds
 19687 00002334 C3                      	retn
 19688                                  
 19689                                  ; ---------------------------------------------------------------------------
 19690                                  
 19691                                  PRINT_BACK:
 19692                                  	; 21/02/2023
 19693 00002335 BA[AF93]                	mov	dx,dback_ptr
 19694 00002338 E9D431                  	jmp	std_printf
 19695                                  
 19696                                  ; ---------------------------------------------------------------------------
 19697                                  
 19698                                  PRINT_EQ:
 19699 0000233B B03D                    	mov	al,'='
 19700 0000233D EB0E                    	jmp	short PRINT_CHAR
 19701                                  
 19702                                  ; ---------------------------------------------------------------------------
 19703                                  
 19704                                  PRINT_ESC:
 19705 0000233F B01B                    	mov	al,1Bh
 19706 00002341 EB0A                    	jmp	short PRINT_CHAR
 19707                                  
 19708                                  ; ---------------------------------------------------------------------------
 19709                                  
 19710                                  	; 21/02/2023
 19711                                  PRINT_G:
 19712                                  	;mov	al,[RABRACKET]
 19713 00002343 B03E                    	mov	al,'>' ; 3Eh
 19714 00002345 EB06                    	jmp	short PRINT_CHAR
 19715                                  
 19716                                  ; ---------------------------------------------------------------------------
 19717                                  
 19718                                  	; 21/02/2023
 19719                                  PRINT_L:
 19720                                  	;mov	al,[LABRACKET]
 19721 00002347 B03C                    	mov	al,'<' ; 3Ch
 19722 00002349 EB02                    	jmp	short PRINT_CHAR
 19723                                  
 19724                                  ; ---------------------------------------------------------------------------
 19725                                  
 19726                                  	; 21/02/2023
 19727                                  Print_B:
 19728                                  	;mov	al,[VBAR]
 19729 0000234B B07C                    	mov	al,'|' ; 7Ch
 19730                                  
 19731                                  ; =============== S U B	R O U T	I N E =======================================
 19732                                  
 19733                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19734                                  PRINT_CHAR:
 19735                                  	; MSDOS 6.0
 19736                                  
 19737                                  ;	Bugbug:	Why bother with ds,es here?
 19738                                  		
 19739 0000234D 06                      	push	es
 19740 0000234E 1E                      	push	ds
 19741 0000234F 07                      	pop	es
 19742 00002350 57                      	push	di
 19743 00002351 52                      	push	dx
 19744 00002352 88C2                    	mov	dl,al		;AC000; Get char into al
 19745                                  	;mov	ah,STD_CON_OUTPUT
 19746                                  				;AC000; print the char to stdout
 19747 00002354 B402                    	mov	ah,2
 19748 00002356 CD21                    	int	21h		;AC000;
 19749 00002358 5A                      	pop	dx
 19750 00002359 5F                      	pop	di
 19751 0000235A 07                      	pop	es
 19752 0000235B C3                      	retn
 19753                                  
 19754                                  ; ---------------------------------------------------------------------------
 19755                                  
 19756                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19757                                  PRINT_DRIVE:
 19758                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 19759 0000235C B419                    	mov	ah,19h
 19760 0000235E CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
 19761 00002360 0441                    	add	al,'A'
 19762                                  	;add	al,[CAPITAL_A]
 19763                                  	;call	PRINT_CHAR
 19764                                  	;retn
 19765                                  	; 21/02/2023
 19766 00002362 EBE9                    	jmp	short PRINT_CHAR
 19767                                  
 19768                                  ; ---------------------------------------------------------------------------
 19769                                  
 19770                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19771                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h
 19772                                  
 19773                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19774                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2460h
 19775                                  
 19776                                  build_dir_for_prompt:
 19777 00002364 30D2                    	xor	dl,dl
 19778 00002366 BE[2AA0]                	mov	si,BWDBUF
 19779 00002369 89F7                    	mov	di,si
 19780 0000236B A0[059E]                	mov	al,[CURDRV]
 19781 0000236E 0441                    	add	al,'A'
 19782 00002370 B43A                    	mov	ah,':'
 19783 00002372 AB                      	stosw
 19784 00002373 A0[F89D]                	mov	al,[DIRCHAR]
 19785 00002376 AA                      	stosb
 19786 00002377 87F7                    	xchg	si,di
 19787 00002379 893E[91A0]              	mov	[string_ptr_2],di
 19788                                  	;mov	ah,CURRENT_DIR ; 47h
 19789 0000237D B447                    	mov	ah,47h
 19790 0000237F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 19791                                  			; DL = drive (0=default,1=A,etc.)
 19792                                  			; DS:SI	points to 64-byte buffer area
 19793                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 19794 00002381 BA[9793]                	mov	dx,string_buf_ptr
 19795 00002384 7303                    	jnc	short doprint
 19796                                  	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
 19797 00002386 BA[5F92]                	mov	dx,BADCURDRV
 19798                                  doprint:
 19799                                  	;call	std_printf
 19800                                  	;retn
 19801 00002389 E98331                  	jmp	std_printf
 19802                                  
 19803                                  ; =============== S U B	R O U T	I N E =======================================
 19804                                  
 19805                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19806                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh
 19807                                  
 19808                                  build_dir_for_chdir:
 19809 0000238C E80D00                  	call	build_dir_string
 19810 0000238F BA[2AA0]                	mov	dx,DIRBUF
 19811 00002392 8916[91A0]              	mov	[string_ptr_2],dx
 19812                                  	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
 19813                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 19814 00002396 BA[9793]                	mov	dx,string_buf_ptr
 19815                                  	;call	std_printf
 19816                                  	;retn
 19817                                  	; 21/02/2023
 19818                                  	;jmp	short doprint
 19819 00002399 E97331                  	jmp	std_printf
 19820                                  
 19821                                  ; =============== S U B	R O U T	I N E =======================================
 19822                                  
 19823                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19824                                  build_dir_string:
 19825 0000239C 8A165C00                	mov	dl,[FCB] ; mov dl,[5Ch]
 19826 000023A0 88D0                    	mov	al,dl
 19827 000023A2 0440                    	add	al,'@'	; 40h
 19828 000023A4 3C40                    	cmp	al,'@'
 19829 000023A6 7506                    	jne	short gotdrive
 19830 000023A8 0206[059E]              	add	al,[CURDRV]
 19831 000023AC FEC0                    	inc	al
 19832                                  gotdrive:
 19833 000023AE 50                      	push	ax
 19834 000023AF BE[2DA0]                	mov	si,BWDBUF+3
 19835                                  	;mov	ah,CURRENT_DIR ; 47h
 19836 000023B2 B447                    	mov	ah,47h
 19837 000023B4 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 19838                                  			; DL = drive (0=default,1=A,etc.)
 19839                                  			; DS:SI	points to 64-byte buffer area
 19840 000023B6 7305                    	jnc	short dpbisok
 19841 000023B8 0E                      	push	cs
 19842 000023B9 1F                      	pop	ds
 19843 000023BA E9ED09                  	jmp	DRVBAD
 19844                                  dpbisok:
 19845 000023BD BF[2AA0]                	mov	di,BWDBUF
 19846 000023C0 89FA                    	mov	dx,di
 19847 000023C2 58                      	pop	ax
 19848 000023C3 B43A                    	mov	ah,':'
 19849 000023C5 AB                      	stosw
 19850 000023C6 A0[F89D]                	mov	al,[DIRCHAR]
 19851 000023C9 AA                      	stosb
 19852 000023CA C3                      	retn
 19853                                  
 19854                                  ; ---------------------------------------------------------------------------
 19855                                  
 19856                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19857                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
 19858                                  
 19859                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 19860                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:24C9h
 19861                                  PATH:
 19862                                  	; MSDOS 6.0
 19863 000023CB 30C0                    	xor	al,al			;AN049; Set up holding buffer
 19864 000023CD BF[219B]                	mov	di,SRCXNAME		;AN049;  for PATH while parsing
 19865 000023D0 AA                      	stosb				;AN049; Initialize PATH to null
 19866 000023D1 4F                      	dec	di			;AN049; point to the start of buffer
 19867 000023D2 E8DE0C                  	call	PGETARG 		; Pre scan for arguments
 19868 000023D5 7460                    	jz	short disppath		; Print the current path
 19869                                  	;cmp	al,semicolon		;AC049; NUL path argument?
 19870 000023D7 3C3B                    	cmp	al,';' ; 3Bh
 19871 000023D9 7503                    	jne	short pathslp 		;AC049;
 19872 000023DB 46                      	inc	si			;AN049; point past semicolon
 19873 000023DC EB1B                    	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
 19874                                  pathslp:					; Get the user specified path
 19875 000023DE AC                      	lodsb				; Get a character
 19876 000023DF 3C0D                    	cmp	al,0Dh
 19877                                  	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
 19878 000023E1 7434                    	je	short path_eol		;AC049; yes - end of command
 19879 000023E3 E82905                  	call	testkanj		;See if DBCS
 19880 000023E6 7405                    	jz	short notkanj2		;No - continue
 19881 000023E8 AA                      	stosb				;AC049; Yes - store the first byte
 19882 000023E9 AC                      	lodsb				;skip second byte of DBCS
 19883                                  path_hold:				;AN049;
 19884 000023EA AA                      	stosb				;AC049; Store a byte in the PATH buffer
 19885 000023EB EBF1                    	jmp	short pathslp		;continue parsing
 19886                                  notkanj2:
 19887 000023ED E84905                  	call	UPCONV			;upper case the character
 19888                                  
 19889 000023F0 3C3B                    	cmp	al,';' ; 3Bh
 19890                                  	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
 19891 000023F2 74F6                    	je	short path_hold		;AC049; go store it
 19892 000023F4 E83F07                  	call	DELIM			;delimiter?
 19893 000023F7 75F1                    	jnz	short path_hold		;AC049; no - go store character
 19894                                  scan_white:				;AN049; make sure were at EOL
 19895 000023F9 AC                      	lodsb				;AN049; get a character
 19896 000023FA 3C0D                    	cmp	al,0Dh
 19897                                  	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
 19898 000023FC 7419                    	je	short path_eol		;AN049; yes - go set path
 19899 000023FE 3C20                    	cmp	al,' ' ; 20h
 19900                                  	;cmp	al,blank		;AN049; whitespace?
 19901 00002400 74F7                    	je	short scan_white	;AN049; yes - continue scanning
 19902                                  	;cmp	al,9
 19903 00002402 3C09                    	cmp	al,tab_chr ; 9		;AN049; whitespace?
 19904 00002404 74F3                    	je	short scan_white	;AN049; yes - continue scanning
 19905                                  
 19906 00002406 BA[D091]                	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
 19907                                  	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
 19908 00002409 C706[D091]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 19909                                  	;mov	byte [msg_disp_class],2		
 19910                                  					;AN049; set up parse error msg class
 19911 0000240F C606[CE91]02            	mov	byte [msg_disp_class],parse_msg_class
 19912 00002414 E98B0A                  	jmp	cerror			;AN049;
 19913                                  path_eol:				;AN049; Parsing was clean
 19914 00002417 30C0                    	xor	al,al			;AN049; null terminate the PATH
 19915 00002419 AA                      	stosb				;AN049;    buffer
 19916 0000241A E84004                  	call	find_path		;AN049; Find PATH in environment
 19917 0000241D E81404                  	call	delete_path		;AC049; Delete any offending name
 19918 00002420 E8CA04                  	call	scan_double_null	;AC049; Scan to end of environment
 19919 00002423 E89A04                  	call	move_name		;AC049; move in PATH=
 19920 00002426 BE[219B]                	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
 19921                                  store_path:				;AN049; Store the PATH in the environment
 19922 00002429 AC                      	lodsb				;AN049; Get a character
 19923                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
 19924 0000242A 20C0                    	and	al,al ; al=0 ?
 19925 0000242C 7405                    	jz	short got_paths		;AN049; yes - exit
 19926 0000242E E82A05                  	call	store_char		;AN049; no - store character
 19927 00002431 EBF6                    	jmp	short store_path	;AN049; continue
 19928                                  got_paths:				;AN049; we're finished
 19929 00002433 31C0                    	xor	ax,ax			;	null terminate the PATH in
 19930 00002435 AB                      	stosw				;    	the environment
 19931 00002436 C3                      	retn
 19932                                  disppath:
 19933 00002437 E82304                  	call	find_path		;AN049;
 19934 0000243A E80300                  	call	print_path
 19935                                  	;call	CRLF2
 19936                                  	;retn
 19937                                  	; 21/02/2023
 19938 0000243D E9E106                  	jmp	CRLF2
 19939                                  
 19940                                  ; =============== S U B	R O U T	I N E =======================================
 19941                                  
 19942                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19943                                  print_path:
 19944 00002440 26803D00                	cmp	byte [es:di],0
 19945 00002444 750A                    	jnz	short path1
 19946                                  path0:
 19947 00002446 BA[2593]                	mov	dx,NULLPATH_PTR
 19948 00002449 0E                      	push	cs
 19949 0000244A 07                      	pop	es
 19950 0000244B 0E                      	push	cs
 19951 0000244C 1F                      	pop	ds
 19952 0000244D E9BF30                  	jmp	std_printf
 19953                                  path1:
 19954 00002450 06                      	push	es
 19955 00002451 1F                      	pop	ds
 19956 00002452 83EF05                  	sub	di,5
 19957 00002455 89FE                    	mov	si,di
 19958 00002457 E8AD04                  	call	SCASB2		; Look for null
 19959                                  	;cmp	cx,0FFh ; 255
 19960                                  	; 21/02/2023
 19961                                  	;ch = 0
 19962 0000245A 80F9FF                  	cmp	cl,255
 19963 0000245D 74E7                    	je	short path0
 19964 0000245F 0E                      	push	cs
 19965 00002460 07                      	pop	es
 19966 00002461 BF[87A7]                	mov	di,Arg_Buf
 19967                                  	;mov	dx,100h ; 256
 19968                                  	;sub	dx,cx
 19969                                  	;xchg	dx,cx
 19970                                  	; 21/02/2023
 19971 00002464 F6D9                    	neg	cl ; 256-cl
 19972 00002466 F3A4                    	rep	movsb
 19973 00002468 BA[6D93]                	mov	dx,arg_buf_ptr
 19974 0000246B 0E                      	push	cs
 19975 0000246C 1F                      	pop	ds
 19976 0000246D E99F30                  	jmp	std_printf
 19977                                  
 19978                                  ; ---------------------------------------------------------------------------
 19979                                  
 19980                                  ; ****************************************************************
 19981                                  ; *
 19982                                  ; * ROUTINE:	 CLS
 19983                                  ; *
 19984                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
 19985                                  ; *		 installed, send a control string to clear the
 19986                                  ; *		 screen.
 19987                                  ; *
 19988                                  ; * INPUT:	 command line at offset 81H
 19989                                  ; *
 19990                                  ; * OUTPUT:	 none
 19991                                  ; *
 19992                                  ; ****************************************************************
 19993                                  
 19994                                  	; MSDOS 6.0
 19995                                  
 19996                                  ANSI_installed	equ 0FFh
 19997                                  
 19998                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19999                                  	; 08/06/2023 - Retro DOS v4.2 COMMAND.COM
 20000                                  CLS:
 20001                                  	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
 20002                                  	;mov	ah,1Ah
 20003                                  	;mov	al,0			;AN000;
 20004 00002470 B8001A                  	mov	ax,1A00h
 20005 00002473 CD2F                    	int	2Fh			;AN000;
 20006                                  		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
 20007                                  		; Return: AL = FFh if installed
 20008 00002475 3CFF                    	cmp	al,ANSI_installed	;AN000;
 20009 00002477 7429                    	je	short ansicls 		;AN000; installed - go do ANSI CLS
 20010                                  
 20011                                  check_lines:
 20012                                  	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
 20013 00002479 B80C44                  	mov	ax,440Ch		;AN000; get lines per page on display
 20014                                  	;mov	bx,stdout		;AN000; lines for stdout
 20015 0000247C BB0100                  	mov	bx,1   ; handle
 20016                                  	;;mov	ch,ioc_sc		;AN000; type is display
 20017                                  	;mov	ch,3   ; CON device	
 20018                                  	;;mov	cl,get_generic		;AN000; get information
 20019                                  	;mov	cl,7Fh ; minor function, get display info
 20020                                  	; 25/04/2023
 20021 0000247F B97F03                  	mov	cx,037Fh
 20022 00002482 BA[F8A1]                	mov	dx,Display_Ioctl	;AN000;
 20023 00002485 CD21                    	int	21h			;AN000;
 20024 00002487 720A                    	jc	short no_variable	;AN000; function had error, use default
 20025                                  		; 21/02/2023
 20026                                  		; ds:dx = parameter block
 20027                                  		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
 20028                                  		; offset 00h  byte  level (0 for DOS 4.0)
 20029                                  		;   	 01h  byte  reserved
 20030                                  		;   	 02h  word  length of following data
 20031                                  		;   	 04h  word  control flags
 20032                                  		;	       bit 0 set for blink, clear for intensity
 20033                                  		;	       bits 1 to 15 reserved
 20034                                  		;   	 06h  byte  mode type (1=text, 2=graphics)
 20035                                  		;   	 07h  byte  reserved
 20036                                  		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
 20037                                  		;   	 0Ah  word  pixel columns
 20038                                  		;   	 0Ch  word  pixel rows
 20039                                  		;   	 0Eh  word  character columns
 20040                                  		;   	 10h  word  character rows
 20041                                  	
 20042                                  	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
 20043                                  	;				;AN000; get number of rows returned
 20044                                  	;mov	dh,al			;AN000; set number of rows
 20045                                  	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
 20046                                  	;				;AN000; get number of columns returned
 20047                                  	;mov	dl,al			;AN000; set number of columns
 20048                                  	; 21/02/2023
 20049 00002489 8A16[06A2]              	mov	dl,[display_width]
 20050 0000248D 8A36[08A2]              	mov	dh,[LinPerPag]
 20051 00002491 EB3B                    	jmp	short regcls		;AN000; go do cls
 20052                                  
 20053                                  no_variable:
 20054                                  	;;mov	bx,stdout		;AC000; set handle as stdout
 20055                                  	;mov	bx,1
 20056                                  	; bx = 1
 20057                                  	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
 20058 00002493 B80044                  	mov	ax,4400h
 20059 00002496 CD21                    	int	21h			;AC000;
 20060 00002498 F6C280                  	test	dl,80h
 20061                                  	;test	dl,devid_ISDEV		;AC000; is handle a device
 20062 0000249B 7405                    	jz	short ansicls 		;AC000; If a file put out ANSI
 20063 0000249D F6C210                  	test	dl,10h
 20064                                  	;test	dl,devid_SPECIAL	;AC000;
 20065 000024A0 7505                    	jnz	short cls_normal	;AC000; If not special CON, do ANSI
 20066                                  
 20067                                  ansicls:
 20068 000024A2 E85200                  	call	ansi_cls		;AN000; clear the screen
 20069 000024A5 EB2C                    	jmp	short cls_ret		;AN000; exit
 20070                                  
 20071                                  ; Get video mode
 20072                                  
 20073                                  cls_normal:				;AC000;
 20074                                  	;mov	ah,get_video_state	;AC000; set up to get video state
 20075 000024A7 B40F                    	mov	ah,0Fh
 20076                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 20077 000024A9 CD10                    	int	10h
 20078 000024AB 3C03                    	cmp	al,3
 20079                                  	;cmp	al,video_alpha		;AC000; see if in text mode
 20080 000024AD 760A                    	jbe	short DoAlpha
 20081 000024AF 3C07                    	cmp	al,7
 20082                                  	;cmp	al,video_bw		;AC000; see if black & white card
 20083 000024B1 7406                    	je	short DoAlpha
 20084                                  
 20085                                  ; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
 20086                                  ; be just as bogus and set the mode that we just got. This will blank the
 20087                                  ; screen too.
 20088                                  
 20089                                  	;mov	ah,set_video_mode	;AC000; set video mode call
 20090 000024B3 B400                    	mov	ah,0
 20091                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 20092 000024B5 CD10                    	int	10h
 20093 000024B7 EB1A                    	jmp	short cls_ret		;AC000; exit
 20094                                  
 20095                                  DoAlpha:
 20096                                  
 20097                                  ; Get video mode and number of columns to scroll
 20098                                  
 20099                                  ;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
 20100                                  ;M01   adaptors. We circumvent this by reaching directly into the BIOS data
 20101                                  ;M01   area
 20102                                  ;M01   Commented out code here is the original
 20103                                  ;M01	mov	ah,get_video_state	;AC000; set up to get current video state
 20104                                  ;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
 20105                                  ;M01	mov	dl,ah
 20106                                  ;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen
 20107                                  
 20108                                  ;M01   Following code lifted from a fix Compaq applied to ANSI
 20109                                  
 20110 000024B9 1E                      	push	ds
 20111                                  	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
 20112 000024BA B84000                  	mov	ax,40h
 20113 000024BD 8ED8                    	mov	ds,ax			;  *			M01
 20114                                  
 20115                                  	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
 20116 000024BF 8A164A00                	mov	dl,[4Ah]
 20117                                  	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
 20118 000024C3 8A368400                	mov	dh,[84h]
 20119 000024C7 1F                      	pop	ds			;			M01
 20120                                  
 20121 000024C8 08F6                    	or	dh,dh			; Q:ZERO		M01
 20122 000024CA 7502                    	jnz	short regcls		;  *JMP IF NO		M01
 20123                                  
 20124                                  	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
 20125                                  	; 25/04/2023
 20126 000024CC B619                    	mov	dh,25
 20127                                  regcls:
 20128 000024CE FEC6                    	inc	dh			; height+1		M018
 20129 000024D0 E80100                  	call	reg_cls 		; go clear the screen
 20130                                  cls_ret:
 20131 000024D3 C3                      	retn				; exit
 20132                                  
 20133                                  ; ---------------------------------------------------------------------------
 20134                                  
 20135                                  ; MSDOS 6.0
 20136                                  
 20137                                  ; ****************************************************************
 20138                                  ; *
 20139                                  ; * ROUTINE:	 REG_CLS
 20140                                  ; *
 20141                                  ; * FUNCTION:	 Clear the screen using INT 10H.
 20142                                  ; *
 20143                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
 20144                                  ; *		 DH = NUMBER OF ROWS
 20145                                  ; *
 20146                                  ; * OUTPUT:	 none
 20147                                  ; *
 20148                                  ; ****************************************************************
 20149                                  
 20150                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20151                                  reg_cls:
 20152                                  ; Set overscan to black.
 20153                                  
 20154 000024D4 FECE                    	dec	dh			; decrement rows and columns
 20155 000024D6 FECA                    	dec	dl			;  to zero base
 20156 000024D8 52                      	push	dx			; save rows,columns
 20157                                  	;mov	ah,set_color_palette	; set up to set the color to blank
 20158 000024D9 B40B                    	mov	ah,0Bh
 20159 000024DB 31DB                    	xor	bx,bx
 20160                                  	;int	video_io_int		; do int 10h - BIOS video IO
 20161 000024DD CD10                    	int	10h
 20162 000024DF 5A                      	pop	dx			;  restore rows,colums
 20163                                  
 20164 000024E0 31C0                    	xor	ax,ax			; zero out ax
 20165 000024E2 89C1                    	mov	cx,ax			;  and cx
 20166                                  
 20167                                  ; Scroll active page
 20168                                  
 20169                                  	;mov	ah,scroll_video_page	; set up to scroll page up
 20170 000024E4 B406                    	mov	ah,6
 20171                                  	;mov	bh,video_attribute	; attribute for blank line
 20172 000024E6 B707                    	mov	bh,7
 20173 000024E8 30DB                    	xor	bl,bl			; set BL to 0
 20174                                  	;int	video_io_int		; do int 10h - BIOS video IO
 20175 000024EA CD10                    	int	10h
 20176                                  
 20177                                  ; Seek to cursor to 0,0
 20178                                  
 20179                                  ;M022 following two lines added
 20180                                  	;mov	ah,get_video_state	; get current video page in BH
 20181 000024EC B40F                    	mov	ah,0Fh
 20182                                  	;int	video_io_int
 20183 000024EE CD10                    	int	10h
 20184                                  	;mov	ah,set_cursor_position	; set up to set cursor position
 20185 000024F0 B402                    	mov	ah,2
 20186 000024F2 31D2                    	xor	dx,dx			; row and column 0
 20187                                  ;M022	mov	bh,0
 20188                                  	;int	video_io_int		; do into 10h - BIOS video IO
 20189 000024F4 CD10                    	int	10h
 20190                                  
 20191 000024F6 C3                      	retn
 20192                                  
 20193                                  ; ---------------------------------------------------------------------------
 20194                                  
 20195                                  ; MSDOS 6.0
 20196                                  
 20197                                  ; ****************************************************************
 20198                                  ; *
 20199                                  ; * ROUTINE:	 ANSI_CLS
 20200                                  ; *
 20201                                  ; * FUNCTION:	 Clear the screen using by writing a control code
 20202                                  ; *		 to STDOUT.
 20203                                  ; *
 20204                                  ; * INPUT:	 none
 20205                                  ; *
 20206                                  ; * OUTPUT:	 none
 20207                                  ; *
 20208                                  ; ****************************************************************
 20209                                  
 20210                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20211                                  ansi_cls:			;AC000;
 20212 000024F7 BE[9695]                	mov	si,CLSSTRING
 20213                                  			; db 4,1Bh,'[2J'
 20214 000024FA AC                      	lodsb
 20215 000024FB 88C1                    	mov	cl,al	; al = 4
 20216 000024FD 30ED                    	xor	ch,ch
 20217                                  	;mov	ah,Raw_CON_IO
 20218 000024FF B406                    	mov	ah,6
 20219                                  clrloop:
 20220 00002501 AC                      	lodsb
 20221 00002502 88C2                    	mov	dl,al
 20222 00002504 CD21                    	int	21h
 20223                                  		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 20224 00002506 E2F9                    	loop	clrloop
 20225 00002508 C3                      	retn
 20226                                  
 20227                                  ;============================================================================
 20228                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
 20229                                  ;============================================================================
 20230                                  ; 08/10/2018 - Retro DOS v3.0
 20231                                  
 20232                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
 20233                                  
 20234                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 20235                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh
 20236                                  
 20237                                  ; ---------------------------------------------------------------------------
 20238                                  
 20239                                  ; ****************************************************************
 20240                                  ; *
 20241                                  ; * ROUTINE:	 CTTY - Change console
 20242                                  ; *
 20243                                  ; * SYNTAX:	 CTTY device
 20244                                  ; *
 20245                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
 20246                                  ; *		 duplicate the device handle to STDIN, STDOUT and
 20247                                  ; *		 STDERR. This routine returns to LODCOM1.
 20248                                  ; *
 20249                                  ; * INPUT:	 command line at offset 81H
 20250                                  ; *
 20251                                  ; * OUTPUT:	 none
 20252                                  ; *
 20253                                  ; ****************************************************************
 20254                                  
 20255                                  	; 21/02/2023 - Retro DOS v4.0
 20256                                  	; 08/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 20257                                  	; 10/06/2023
 20258                                  CTTY:
 20259                                  	; MSDOS 6.0
 20260 00002509 1E                      	push	ds			;AN000; Get local ES
 20261 0000250A 07                      	pop	es			;AN000;
 20262 0000250B BE8100                  	mov	si,81h			;AC000; Get command argument for CTTY
 20263 0000250E BF[B898]                	mov	di,PARSE_CTTY
 20264                                  					;AC000; Get address of PARSE_CTTY
 20265 00002511 31C9                    	xor	cx,cx			;AC000; clear cx,dx
 20266 00002513 31D2                    	xor	dx,dx			;AC000;
 20267 00002515 E84125                  	call	cmd_parse		;AC000; call parser
 20268                                  
 20269                                  	;cmp	ax,-1 ; 0FFFFh
 20270                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 20271                                  	;je	short ctty_error	;AN000; yes - error
 20272                                  	;;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
 20273                                  	;and	ax,ax ; ax > 0 ?
 20274                                  	;jnz	short ctty_error	;AN000; YES -ERROR
 20275                                  	; 10/06/2023
 20276 00002518 40                      	inc	ax  ; cmp ax,-1
 20277 00002519 7434                    	jz	short ctty_error  ; 0FFFFh -> 0
 20278 0000251B 48                      	dec	ax  ; cmp ax,0
 20279 0000251C 7531                    	jnz	short ctty_error  ; 1 -> 0
 20280                                  	; ax = 0
 20281                                  
 20282 0000251E 56                      	push	si			;AN000; save position in line
 20283 0000251F C536[E5A9]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 20284 00002523 BF[12A1]                	mov	di,SrcBuf		;AN000; get address of srcbuf
 20285                                  ctty_move_filename:			;AN000; put filespec in srcbuf
 20286 00002526 AC                      	lodsb				;AN000; get a char from buffer
 20287 00002527 AA                      	stosb				;AN000; store in srcbuf
 20288                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
 20289 00002528 08C0                    	or	al,al ; al = 0 ?
 20290 0000252A 75FA                    	jnz	short ctty_move_filename ; 26/04/2023
 20291                                  					;AN000; no - keep moving
 20292 0000252C 5E                      	pop	si			;AN000; get line position back
 20293 0000252D BF[B898]                	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
 20294 00002530 E8C001                  	call	parse_check_eol 	;AN000; are we at end of line?
 20295                                  	;jz	short nocolon 		;AN000; yes - continue
 20296                                  	; 21/02/2023
 20297 00002533 751A                    	jnz	short ctty_error
 20298                                  ;ctty_error:
 20299                                  	;jmp	short isbaddev		;AC000; yes - exit
 20300                                  
 20301                                  	; 21/02/2023
 20302                                  	; MSDOS 3.3
 20303                                  	;call	SETPATH
 20304                                  	;dec	si
 20305                                  	;dec	si
 20306                                  	;cmp	byte [si],':'
 20307                                  	;jnz	short NOCOLON
 20308                                  	;mov	byte [si],0
 20309                                  nocolon:
 20310                                  	; 21/02/2023
 20311                                  	; MSDOS 6.0
 20312 00002535 BA[12A1]                	mov	dx,SrcBuf
 20313                                  ;NOCOLON:
 20314                                  	; MSDOS 3.3 & MSDOS 6.0
 20315                                  	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
 20316                                  	;mov	ax,(OPEN<<8)|2 ; 3D02h
 20317 00002538 B8023D                  	mov	ax,3D02h ; 21/02/2023
 20318 0000253B CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 20319                                  			; DS:DX	-> ASCIZ filename
 20320                                  			; AL = access mode
 20321                                  			; 2 - read & write
 20322 0000253D 7210                    	jc	short isbaddev
 20323 0000253F 89C3                    	mov	bx,ax
 20324                                  	;mov	ax,IOCTL*256 ; 4400h
 20325 00002541 B80044                  	mov	ax,4400h
 20326 00002544 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 20327                                  			; BX = file or device handle
 20328 00002546 F6C280                  	test	dl,80h
 20329 00002549 750C                    	jnz	short devisok
 20330                                  closedev:
 20331                                  	;mov	ah,CLOSE ; 3Eh ; Close initial handle
 20332 0000254B B43E                    	mov	ah,3Eh
 20333 0000254D CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 20334                                  			; BX = file handle
 20335                                  ctty_error:
 20336                                  isbaddev:
 20337 0000254F BA[2B93]                	mov	dx,BADDEV_PTR
 20338 00002552 E8BA2F                  	call	std_printf
 20339 00002555 EB40                    	jmp	short resret
 20340                                  
 20341                                  	;nop
 20342                                  devisok:
 20343                                  	; 21/02/2023
 20344                                  	; MSDOS 6.0
 20345 00002557 52                      	push	dx		;AN007; save device info
 20346                                  	; 08/06/2023
 20347 00002558 A1[B293]                	mov	ax,[acrlf_ptr]	;AN021; get message number for 0d, 0a
 20348                                  	;mov	dh,util_msg_class
 20349 0000255B B6FF                    	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
 20350 0000255D 53                      	push	bx		;AN021; save handle
 20351 0000255E E89130                  	call	TSYSGETMSG	;AN021; get the address of the message
 20352 00002561 89F2                    	mov	dx,si		;AN021; get address into dx
 20353                                  	;mov	ax,(Write shl 8)
 20354 00002563 B80040                  	mov	ax,4000h	;AN007; write to device
 20355 00002566 B90200                  	mov	cx,2		;AN007; write two bytes
 20356 00002569 CD21                    	int	21h		;AN007;
 20357 0000256B 5B                      	pop	bx		;AN021; get back handle
 20358 0000256C 5A                      	pop	dx		;AN007; get back device info
 20359 0000256D 72DC                    	jc	short closedev	;AN007; if error, quit
 20360                                  
 20361                                  	; MSDOS 3.3 & MSDOS 6.0
 20362 0000256F 30F6                    	xor	dh,dh
 20363 00002571 80CA03                  	or	dl,3
 20364                                  	;;mov	ax,(IOCTL SHL 8) OR 1
 20365                                  	;mov	ax,(IOCTL<<8)|1 ; 4401h
 20366 00002574 B80144                  	mov	ax,4401h
 20367 00002577 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 20368                                  			; BX = device handle,DH = 0
 20369                                  			; DL = device information to set 
 20370                                  			;	(bits 0-7 from	function 0)
 20371 00002579 53                      	push	bx
 20372 0000257A B90300                  	mov	cx,3
 20373 0000257D 31DB                    	xor	bx,bx
 20374                                  iclloop:			; Close basic handles
 20375                                  	;mov	ah,CLOSE ; 3Eh
 20376 0000257F B43E                    	mov	ah,3Eh
 20377 00002581 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 20378                                  			; BX = file handle
 20379 00002583 43                      	inc	bx
 20380 00002584 E2F9                    	loop	iclloop
 20381 00002586 5B                      	pop	bx		; Get handle
 20382                                  	;mov	ah,XDUP ; 45h
 20383 00002587 B445                    	mov	ah,45h
 20384 00002589 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 20385                                  			; BX = file handle to duplicate
 20386                                  	;mov	ah,XDUP ; 45h
 20387 0000258B B445                    	mov	ah,45h
 20388 0000258D CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 20389                                  			; BX = file handle to duplicate
 20390                                  	;mov	ah,XDUP ; 45h
 20391 0000258F B445                    	mov	ah,45h
 20392 00002591 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 20393                                  			; BX = file handle to duplicate
 20394                                  	;mov	ah,CLOSE ; 3Eh
 20395 00002593 B43E                    	mov	ah,3Eh
 20396 00002595 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 20397                                  			; BX = file handle
 20398                                  resret:
 20399 00002597 8E1E[F39D]              	mov	ds,[RESSEG]
 20400 0000259B 1E                      	push	ds
 20401                                  	;mov	ax,[18h]
 20402 0000259C A11800                  	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
 20403 0000259F A3[3D02]                	mov	[Io_Save],ax
 20404                                  	;;;mov	ax,31Eh ; MSDOS 3.3
 20405                                  	;;mov	ax,LODCOM1
 20406                                  	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
 20407                                  	;mov	ax,175h ; MSDOS 6.0
 20408 000025A2 B8[7400]                	mov	ax,TrnLodCom1_Trap
 20409 000025A5 50                      	push	ax
 20410                                  
 20411 000025A6 CB                      	retf		; Far return
 20412                                  
 20413                                  ; ---------------------------------------------------------------------------
 20414                                  
 20415                                  ;****************************************************************
 20416                                  ;*
 20417                                  ;* ROUTINE:	CHCP - Change code page internal command
 20418                                  ;*		(added DOS 3.30 07/21/86)
 20419                                  ;*
 20420                                  ;* SYNTAX:	CHCP [xxx]
 20421                                  ;*		where xxx is a valid code page
 20422                                  ;*
 20423                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
 20424                                  ;*		6402H to set the code page to xxxx. If no parameters
 20425                                  ;*		are specified, CHCP will use INT 21H function 6401H
 20426                                  ;*		to get global code page and display it to the user.
 20427                                  ;*
 20428                                  ;* INPUT:	command line at offset 81H
 20429                                  ;*
 20430                                  ;* OUTPUT:	none
 20431                                  ;*
 20432                                  ;****************************************************************
 20433                                  
 20434                                  NLSFUNC_installed equ  0FFh
 20435                                  set_global_cp	  equ  2
 20436                                  get_global_cp	  equ  1
 20437                                  
 20438                                  	; 21/02/2023 - Retro DOS v4.0
 20439                                  	; 09/06/2023 - Retro DOS v4.2 COMMAND.COM
 20440                                  	; 10/06/2023
 20441                                  CHCP:
 20442                                  	; MSDOS 6.0
 20443 000025A7 1E                      	push	ds		;AN000; Get local ES
 20444 000025A8 07                      	pop	es		;AN000;
 20445 000025A9 BE8100                  	mov	si,81h		;AC000; Get command argument for CHCP
 20446 000025AC BF[C497]                	mov	di,PARSE_CHCP
 20447                                  				;AN000; Get address of PARSE_CHCP
 20448 000025AF 31C9                    	xor	cx,cx		;AC000; clear cx,dx
 20449 000025B1 31D2                    	xor	dx,dx		;AC000;
 20450 000025B3 E85301                  	call    Parse_With_Msg	;AC018; call parser
 20451                                  
 20452                                  	;cmp	ax,-1
 20453                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 20454                                  	;;jne	short setcp	;AC000; no go get number & set code page
 20455                                  	;je	short getcp	;AC000; yes - no parm - get code page
 20456                                  ;setcp:
 20457                                  	;;cmp	ax,0
 20458                                  	;;cmp	ax,RESULT_NO_ERROR
 20459                                  	;			;AN000; did we have an error?
 20460                                  	;;jne	short cp_error	;AC018; yes - go issue message
 20461                                  	;and	ax,ax ; ax > 0 ?
 20462                                  	;jnz	short cp_error	
 20463                                  	; 10/06/2023
 20464 000025B6 40                      	inc	ax  ; cmp ax,-1	
 20465 000025B7 745C                    	jz	short getcp ; 0FFFFh -> 0
 20466 000025B9 48                      	dec	ax  ; cmp ax,0
 20467 000025BA 7556                    	jnz	short cp_error ; 1 -> 0
 20468                                  	; ax = 0
 20469                                  
 20470                                  	;;push	cx		;AN000; save positional count
 20471                                  	;mov	bx,PARSE1_ADDR	;AN000; get number returned
 20472                                  	;;mov	cx,[bx]		;AN000;  into cx
 20473                                  	;;mov	[system_cpage],cx
 20474                                  	;			;AN000; save user input number
 20475                                  	;;pop	cx		;AC000; restore positional count
 20476                                  	;; 21/02/2023
 20477                                  	;mov	di,[bx]
 20478                                  	;mov	[system_cpage],di
 20479                                  	; 09/06/2023	
 20480 000025BC 8B1E[E5A9]              	mov	bx,[PARSE1_ADDR]
 20481 000025C0 891E[8BA0]              	mov	[system_cpage],bx
 20482                                  	;
 20483 000025C4 BF[C497]                	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
 20484 000025C7 E82901                  	call	parse_check_eol ;AN000; are we at end of line?
 20485 000025CA 7546                    	jnz	short cp_error	;AC000; no - exit
 20486                                  okset:
 20487                                  	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
 20488                                  	;mov	ah,14h
 20489                                  	;mov	al,0		;AN000;
 20490 000025CC B80014                  	mov	ax,1400h
 20491 000025CF CD2F                    	int	2Fh		;AN000;
 20492                                  	;cmp	al,0FFh
 20493 000025D1 3CFF                    	cmp	al,NLSFUNC_installed
 20494                                  				;AN000;
 20495 000025D3 7405                    	je	short got_NLS 	;AN000; Yes - continue
 20496 000025D5 BA[5992]                	mov	dx,NLSFUNC_PTR
 20497                                  				;AN000; no - set up error message
 20498 000025D8 EB38                    	jmp	short cp_error	;AN000; error exit
 20499                                  
 20500                                  	; 21/02/2023
 20501                                  got_NLS:
 20502                                  	; MSDOS 6.0
 20503 000025DA 8B1E[8BA0]              	mov	bx,[system_cpage]
 20504                                  				;AN000; get user input code page
 20505                                  ;SET_CP_TBL_NUM:
 20506                                  	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
 20507                                  	;
 20508                                  	; MSDOS 3.3 & MSDOS 6.0
 20509                                  	;;mov	ah,GETSETCDPG 	;get/set global code page function
 20510                                  	;mov	ah,66h
 20511                                  	;;mov	al,set_global_cp 
 20512                                  	;mov	al,2		;minor - set
 20513                                  	; 26/04/2023
 20514 000025DE B80266                  	mov	ax,6602h
 20515 000025E1 CD21                    	int	21h
 20516                                  		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
 20517                                  		; BX = active code page
 20518                                  		; DX = system code page (active page at boot time)
 20519                                  
 20520 000025E3 733F                    	jnc	short chcp_return
 20521                                  				;no error - exit
 20522                                  
 20523 000025E5 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
 20524 000025E8 7515                    	jnz	short chcp_other_error
 20525                                  
 20526                                  	;mov	ah,GETEXTENDEDERROR ; 59h
 20527 000025EA B459                    	mov	ah,59h
 20528 000025EC 31DB                    	xor	bx,bx
 20529 000025EE CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 20530                                  			; BX = version code (0000h for DOS 3.x)
 20531                                  
 20532 000025F0 83F80D                  	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
 20533 000025F3 7505                    	jne	short no_countrysys ; 26/04/2023
 20534                                  	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
 20535 000025F5 BA[5C92]                	mov	dx,INV_CODE_PAGE
 20536                                  	;jmp	cerror
 20537 000025F8 EB18                    	jmp	short cp_error
 20538                                  
 20539                                  	; 21/02/2023
 20540                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 20541                                  no_countrysys:
 20542                                  ;M045;	mov	byte [msg_disp_class],ext_msg_class	   
 20543                                  ;					;AN000; set up extended error msg class
 20544                                  ;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
 20545                                  ;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
 20546                                  					;AN000; get message number in control block
 20547 000025FA BA[4694]                	mov	dx,NoCntry_Ptr
 20548 000025FD EB13                    	jmp	short cp_error
 20549                                  
 20550                                  chcp_other_error:		; end of p716
 20551                                  	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
 20552 000025FF B459                    	mov	ah,59h
 20553 00002601 31DB                    	xor	bx,bx
 20554 00002603 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 20555                                  			; BX = version code (0000h for DOS 3.x)
 20556 00002605 83F841                  	cmp	ax,65		;was it access denied?
 20557 00002608 7505                    	jne	short none_set	;no - assume all failed
 20558 0000260A BA[3D92]                	mov	dx,cp_not_all_ptr
 20559                                  				;set up message
 20560                                  	;jmp	cerror		;AC000; error exit
 20561 0000260D EB03                    	jmp     short cp_error
 20562                                  none_set:
 20563 0000260F BA[2F92]                	mov	dx,cp_not_set_ptr
 20564                                  				;set up message
 20565                                  cp_error:
 20566 00002612 E98D08                  	jmp	cerror		;exit
 20567                                  getcp:
 20568                                  	;;mov	ah,GETSETCDPG ; 66h
 20569                                  	;mov	ah,66h		;get/set global code page function	
 20570                                  	;;mov	al,get_global_cp ; 1
 20571                                  	;mov	al,1		;minor - get
 20572                                  	; 26/04/2023
 20573 00002615 B80166                  	mov	ax,6601h
 20574 00002618 CD21                    	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
 20575 0000261A 891E[8BA0]              	mov	[system_cpage],bx
 20576                                  				;get active cp for output
 20577 0000261E BA[4B92]                	mov	dx,cp_active_ptr
 20578 00002621 E8EB2E                  	call	std_printf	;print it out
 20579                                  chcp_return:
 20580 00002624 C3                      	retn
 20581                                  
 20582                                  ; ---------------------------------------------------------------------------
 20583                                  
 20584                                  ; ****************************************************************
 20585                                  ; *
 20586                                  ; * ROUTINE:	 TRUENAME
 20587                                  ; *
 20588                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
 20589                                  ; *		 Parses the command line. If a path is found, set
 20590                                  ; *		 SRCXNAME to path. If only a drive letter is found,
 20591                                  ; *		 set SRCXNAME to the drive letter. If no path
 20592                                  ; *		 is found, set the path of SRCXNAME to dot (.) for
 20593                                  ; *		 current directory. Use the NAME TRANSLATE system
 20594                                  ; *		 call to get the real name and  then display the 
 20595                                  ; *		 real name. If an error occurs issue an error
 20596                                  ; *		 message and transfer control to  CERROR.
 20597                                  ; *
 20598                                  ; * INPUT:	 command line at offset 81H
 20599                                  ; *
 20600                                  ; * OUTPUT:	 none
 20601                                  ; *
 20602                                  ; ****************************************************************
 20603                                  
 20604                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20605                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
 20606                                  
 20607                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 20608                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2741h
 20609                                  
 20610                                  TRUENAME:				;AN000; TRUENAME entry point
 20611 00002625 1E                      	push	ds			;AN000; Get local ES
 20612 00002626 07                      	pop	es			;AN000;
 20613 00002627 BE8100                  	mov	si,81h			;AN000; Get command line
 20614 0000262A BF[2298]                	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
 20615 0000262D 31C9                    	xor	cx,cx			;AN000; clear cx,dx
 20616 0000262F 31D2                    	xor	dx,dx			;AN000;
 20617 00002631 E8D500                  	call	Parse_With_Msg		;AC018; call parser
 20618                                  
 20619 00002634 BF[219B]                	mov	di,SRCXNAME		;AN000; get address of srcxname
 20620                                  	;cmp	ax,0FFFFh
 20621                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 20622                                  	;je	short tn_eol		;AN000; yes - go process
 20623                                  	;; 22/02/2023
 20624                                  	;;cmp	ax,0
 20625                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 20626                                  	;;jne	short tn_parse_error	;AN000; yes - go issue message
 20627                                  	;and	ax,ax ; ax = 0 ?
 20628                                  	;jnz	short tn_parse_error ; no, parse error	
 20629                                  	; 10/06/2023
 20630 00002637 40                      	inc	ax  ; 0FFFFh -> 0 ; cmp ax,0FFFFh
 20631 00002638 7433                    	jz	short tn_eol ; ah = 0 ; *
 20632 0000263A 48                      	dec	ax  ; 1 -> 0 ; cmp ax, 0
 20633 0000263B 752D                    	jnz	short tn_parse_error
 20634                                  	
 20635                                  	;cmp	byte [PARSE1_TYPE],6
 20636 0000263D 803E[E1A9]06            	cmp	byte [PARSE1_TYPE],result_drive
 20637                                  					;AN000; was a drive entered?
 20638                                  	;je	short tn_drive		;AN000; yes - go process
 20639                                  	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
 20640                                  	; 23/02/2023
 20641 00002642 7512                    	jne	short tn_filespec
 20642                                  
 20643                                  ;tn_eol: 
 20644                                  ;	;mov	ah,0			;AN000; no parameters on line
 20645                                  ;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 20646                                  ;	;mov	al,dot_chr		;AN000;   for current dir
 20647                                  ;	mov	al,'.'
 20648                                  ;	stosw				;AN000; store in srcxname
 20649                                  ;	jmp	short tn_doit		;AN000; go do command
 20650                                  
 20651                                  tn_drive:				;AN000; a drive was entered
 20652 00002644 56                      	push	si			;AN000; save position in line
 20653 00002645 BE[E5A9]                	mov	si,PARSE1_ADDR		;AN000; get address of drive
 20654 00002648 AC                      	lodsb				;AN000; get the drive number
 20655 00002649 0440                    	add	al,"A"-1 ; 40h		;AN000; convert it to char
 20656 0000264B AA                      	stosb				;AN000; store it in srcxname
 20657                                  	;mov	ax,dot_colon		;AN000; get colon and . and
 20658 0000264C B83A2E                  	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
 20659 0000264F AB                      	stosw				;AN000;  store in srcxname
 20660                                  	;mov	al,0
 20661 00002650 B000                    	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
 20662 00002652 AA                      	stosb				;AN000;
 20663 00002653 5E                      	pop	si			;AN000; get line position back
 20664 00002654 EB0C                    	jmp	short tn_check_eol	;AN000; check to make sure eol
 20665                                  
 20666                                  tn_filespec:				;AN000; a filespec was entered
 20667 00002656 56                      	push	si			;AN000; save position in line
 20668 00002657 C536[E5A9]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 20669                                  
 20670                                  tn_move_filename:			;AN000; put filespec in srcxname
 20671 0000265B AC                      	lodsb				;AN000; get a char from buffer
 20672 0000265C AA                      	stosb				;AN000; store in srcxname
 20673                                  	;;cmp	al,0
 20674                                  	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
 20675 0000265D 08C0                    	or	al,al ; al = 0 ?
 20676 0000265F 75FA                    	jnz	short tn_move_filename	;AN000; no - keep moving
 20677 00002661 5E                      	pop	si			;AN000; get line position back
 20678                                  
 20679                                  tn_check_eol:				;AN000; make sure no extra parms
 20680 00002662 BF[2298]                	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
 20681 00002665 E88B00                  	call	parse_check_eol 	;AN000; are we at end of line?
 20682 00002668 7406                    	jz	short tn_doit 		;AN000; Yes - do the command
 20683                                  tn_parse_error: 			;AN000; A parse error occurred
 20684 0000266A E93508                  	jmp	cerror			;AN000; Go to error routine
 20685                                  
 20686                                  tn_eol: 
 20687                                  	;23/02/2023
 20688                                  	;;mov	ah,0			;AN000; no parameters on line
 20689                                  	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 20690                                  	;;mov	al,dot_chr		;AN000;   for current dir
 20691                                  	;mov	al,'.'
 20692                                  	; 10/06/2023
 20693                                  	;mov	ax,002Eh
 20694                                  	; ah = 0 ; *
 20695 0000266D B02E                    	mov	al,'.'  ;dot_chr ; 2Eh
 20696                                  	;	
 20697 0000266F AB                      	stosw				;AN000; store in srcxname
 20698                                  	; 23/02/2023
 20699                                  	;jmp	short tn_doit		;AN000; go do command
 20700                                  
 20701                                  tn_doit:				;AN000;
 20702 00002670 BE[219B]                	mov	si,SRCXNAME		;AN000; set up srcxname as source
 20703 00002673 BF[529C]                	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
 20704 00002676 B460                    	mov	ah,xNameTrans		;AN000; do name translate call
 20705                                  	;mov	ah,60h
 20706 00002678 CD21                    	int	21h			;AN000;
 20707 0000267A 7311                    	jnc	short tn_print_xname	;AN000; If no error - print result
 20708                                  
 20709 0000267C E8B3FB                  	call	Set_Ext_Error_Msg	;AN000; get extended message
 20710 0000267F C706[91A0][219B]        	mov	word [string_ptr_2],SRCXNAME
 20711                                  					;AN000; get address of failed string
 20712                                  	;mov	byte [extend_buf_sub],1
 20713 00002685 C606[D291]01            	mov	byte [extend_buf_sub],one_subst
 20714                                  					;AN000; put number of subst in control block
 20715 0000268A E91508                  	jmp	cerror			;AN000; Go to error routine
 20716                                  
 20717                                  tn_print_xname: 			;AN000;
 20718 0000268D C706[91A0][529C]        	mov	word [string_ptr_2],COMBUF
 20719                                  					;AN000; Set up address of combuf
 20720 00002693 BA[9793]                	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
 20721 00002696 E88804                  	call	CRLF2			;AN000; print a crlf
 20722                                  	;call	Printf_Crlf		;AN000; print it out
 20723                                  	;retn				;AN000;
 20724                                  	; 23/02/2023
 20725 00002699 E9652E                  	jmp	Printf_Crlf
 20726                                  
 20727                                  ; ---------------------------------------------------------------------------
 20728                                  
 20729                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20730                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
 20731                                  
 20732                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 20733                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:27C3h
 20734                                  _$EXIT:
 20735                                  	; MSDOS 6.0
 20736 0000269C 1E                      	push	ds			;AN000; save data segment
 20737 0000269D 8E1E[F39D]              	mov	ds,[RESSEG]		;AN000; get resident data segment
 20738                                  	;assume	ds:resgroup		;AN000;
 20739                                  
 20740 000026A1 803E[4002]00            	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
 20741 000026A6 740A                    	jz	short free_com		;AN045; no - free everything
 20742                                  
 20743                                  ;	We're a permanent command.
 20744                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
 20745                                  
 20746 000026A8 833E[4302]FF            	cmp	word [SingleCom],-1	;M034
 20747 000026AD 7412                    	je	short no_reset		;M034 ; exit singlecom
 20748 000026AF E952DA                  	jmp	TCOMMAND		;permanent command, recycle
 20749                                  
 20750                                  free_com:
 20751                                  	;mov	ax,(multdos shl 8 or message_2f)
 20752 000026B2 B82E12                  	mov	ax,122Eh		;AN060; reset parse message pointers
 20753                                  	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
 20754 000026B5 B205                    	mov	dl,5
 20755 000026B7 8B3E[5802]              	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
 20756 000026BB 8E06[5A02]              	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
 20757 000026BF CD2F                    	int	2Fh			;AN000; go set it
 20758                                  no_reset:				;AN045;
 20759 000026C1 1F                      	pop	ds			;AN000; restore local data segment
 20760                                  	;assume	ds:trangroup		;AN000;
 20761                                  ;M040
 20762                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
 20763                                  ;this, restores user dir if flag is set and resets the flag.
 20764                                  
 20765                                  	;invoke	RestUDir1		;restore user dir if needed ;M040
 20766 000026C2 E80C03                  	call	RestUDir1
 20767 000026C5 8E06[F39D]              	mov	es,[RESSEG]
 20768                                  	;assume	es:resgroup
 20769                                  
 20770 000026C9 26A1[DC01]              	mov	ax,[es:Parent]
 20771                                  	;mov	[es:16h],ax
 20772                                  	;mov	[es:PDB_Parent_PID],ax
 20773 000026CD 26A31600                	mov	[es:PDB.PARENT_PID],ax
 20774 000026D1 26A1[DE01]              	mov	ax,[es:OldTerm]
 20775                                  	;mov	[es:0Ah],ax
 20776                                  	;mov	[es:PDB_Exit],ax
 20777 000026D5 26A30A00                	mov	[es:PDB.EXIT],ax
 20778 000026D9 26A1[E001]              	mov	ax,[es:OldTerm+2]
 20779                                  	;mov	[es:0Ch],ax
 20780                                  	;mov	[es:PDB_Exit+2],ax
 20781 000026DD 26A30C00                	mov	[es:PDB.EXIT+2],ax
 20782                                  
 20783 000026E1 06                      	push	es
 20784 000026E2 8E06[019E]              	mov	es,[TRAN_TPA]
 20785                                  	;mov	ah,DEALLOC
 20786 000026E6 B449                    	mov	ah,49h
 20787 000026E8 CD21                    	int	21h			; Now running in "free" space
 20788 000026EA 07                      	pop	es
 20789                                  
 20790                                  	;mov	ah,Exit
 20791 000026EB B44C                    	mov	ah,4Ch
 20792                                  	;mov	al,byte ptr RetCode
 20793 000026ED 26A0[3802]              	mov	al,[es:RetCode]
 20794 000026F1 CD21                    	int	21h
 20795                                  
 20796                                  ; ---------------------------------------------------------------------------
 20797                                  
 20798                                  ; MSDOS 6.0
 20799                                  ; ****************************************************************
 20800                                  ; *
 20801                                  ; * ROUTINE:	 PARSE_CHECK_EOL
 20802                                  ; *
 20803                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
 20804                                  ; *		 If not end of line, set up to print parse
 20805                                  ; *		 error message. ASSUMES NO MORE PARAMETERS ARE
 20806                                  ; *		 EXPECTED!
 20807                                  ; *
 20808                                  ; * INPUT:	 DS:SI	  last output from parser
 20809                                  ; *		 ES:DI	  points to parse block
 20810                                  ; *		 CX	  last output from parser
 20811                                  ; *
 20812                                  ; * OUTPUT:	 AX	  parser return code
 20813                                  ; *
 20814                                  ; *		 if end of line found
 20815                                  ; *		     zero flag set
 20816                                  ; *		 else
 20817                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 20818                                  ; *
 20819                                  ; ****************************************************************
 20820                                  
 20821                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20822                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h
 20823                                  
 20824                                  parse_check_eol:
 20825 000026F3 31D2                    	xor	dx,dx			;AN000;
 20826 000026F5 8936[89A0]              	mov	[parse_last],si 	;AN018; save start of parameter
 20827 000026F9 E85D23                  	call	cmd_parse		;AN000; call parser
 20828 000026FC 3CFF                    	cmp	al,-1 ; 0FFh
 20829                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
 20830 000026FE 7408                    	je	short parse_good_eol	;AN000; yes - no problem
 20831                                  	;cmp	ax,0
 20832                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
 20833 00002700 21C0                    	and	ax,ax ; ax = 0 ?
 20834 00002702 7501                    	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
 20835 00002704 40                      	inc	ax			;AN018; set AX to 1 and turn off zero flag
 20836                                  ok_to_setup_pmsg:
 20837 00002705 E81000                  	call	setup_parse_error_msg	;AN018; go set up error message
 20838                                  parse_good_eol:
 20839                                  parse_msg_good:	; 23/02/2023
 20840 00002708 C3                      	retn				;AN000;
 20841                                  
 20842                                  ; ---------------------------------------------------------------------------
 20843                                  
 20844                                  ; MSDOS 6.0
 20845                                  ; ****************************************************************
 20846                                  ; *
 20847                                  ; * ROUTINE:	 PARSE_WITH_MSG
 20848                                  ; *
 20849                                  ; * FUNCTION:	 Calls parser. If an error occurred, the error
 20850                                  ; *		 message is set up.
 20851                                  ; *
 20852                                  ; * INPUT:	 DS:SI	  last output from parser
 20853                                  ; *		 ES:DI	  points to parse block
 20854                                  ; *		 CX	  last output from parser
 20855                                  ; *
 20856                                  ; * OUTPUT:	 AX	  parser return code
 20857                                  ; *
 20858                                  ; *		 if no error
 20859                                  ; *		     outputs from parser
 20860                                  ; *		 else
 20861                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 20862                                  ; *		     error message set up for STD_PRINTF
 20863                                  ; *
 20864                                  ; ****************************************************************
 20865                                  
 20866                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20867                                  Parse_With_Msg:
 20868 00002709 8936[89A0]              	mov	[parse_last],si 	;AN018; save start of parameter
 20869 0000270D E84923                  	call	cmd_parse		;AN018; call parser
 20870 00002710 3CFF                    	cmp	al,-1 ; 0FFh
 20871                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
 20872 00002712 74F4                    	je	short parse_msg_good	;AN018; yes - no problem
 20873                                  	;cmp	ax,0
 20874                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
 20875 00002714 09C0                    	or	ax,ax ; ax = 0 ?
 20876 00002716 74F0                    	jz	short parse_msg_good	;AN018; yes - no problem
 20877                                  	; 23/02/2023
 20878                                  	;call	setup_parse_error_msg	;AN018; go set up error message
 20879                                  ;parse_msg_good:
 20880                                  	;retn				;AN018;
 20881                                  	; 23/02/2023
 20882                                  	;jmp	short setup_parse_error_msg	
 20883                                  
 20884                                  ; ---------------------------------------------------------------------------
 20885                                  
 20886                                  ; MSDOS 6.0
 20887                                  ; ****************************************************************
 20888                                  ; *
 20889                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
 20890                                  ; *
 20891                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
 20892                                  ; *		 message is set up.
 20893                                  ; *
 20894                                  ; * INPUT:	 AX	     Parse error number
 20895                                  ; *		 SI	     Set to past last parameter
 20896                                  ; *		 Parse_last  Set to start of last parameter
 20897                                  ; *
 20898                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
 20899                                  ; *		 error message set up for STD_PRINTF
 20900                                  ; *
 20901                                  ; ****************************************************************
 20902                                  
 20903                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20904                                  setup_parse_error_msg:
 20905 00002718 C606[CE91]02            	mov	byte [msg_disp_class],parse_msg_class
 20906                                  	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
 20907 0000271D BA[D091]                	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
 20908 00002720 C60400                  	mov	byte [si],END_OF_LINE_OUT ; 0
 20909                                  					;AC018; terminate the parameter string
 20910 00002723 A3[D091]                	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
 20911 00002726 83F802                  	cmp	ax,2
 20912                                  	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
 20913 00002729 740D                    	je	short setup_parse_msg_ret
 20914                                  					;AN018;    no subst
 20915 0000272B 8B36[89A0]              	mov	si,[parse_last] 	;AC018; get start of parameter
 20916 0000272F 8936[91A0]              	mov	[string_ptr_2],si 	;AC018; get address of failed string
 20917 00002733 C606[D291]01            	mov	byte [extend_buf_sub],one_subst
 20918                                  					;AC018; put number of subst in control block
 20919                                  	;mov	byte [extend_buf_sub],1
 20920                                  setup_parse_msg_ret:
 20921 00002738 46                      	inc	si			;AN018; make sure zero flag not set
 20922 00002739 C3                      	retn				;AC018;
 20923                                  
 20924                                  ;============================================================================
 20925                                  ; TENV.ASM, MSDOS 6.0, 1991
 20926                                  ;============================================================================
 20927                                  ; 08/10/2018 - Retro DOS v3.0
 20928                                  
 20929                                  ; TITLE	Part6 COMMAND Transient routines.
 20930                                  
 20931                                  ;	Environment utilities and misc. routines
 20932                                  
 20933                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
 20934                                  
 20935                                  ; 23/02/2023 - Retro DOS v4.0 (& v4.1)
 20936                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh
 20937                                  
 20938                                  ; ---------------------------------------------------------------------------
 20939                                  
 20940                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20941                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 20942                                  ADD_PROMPT:
 20943 0000273A E8FC00                  	call	delete_prompt	; Delete any existing prompt
 20944 0000273D E8AD01                  	call	scan_double_null
 20945                                  
 20946                                  ADD_PROMPT2:
 20947 00002740 56                      	push	si
 20948 00002741 E89B01                  	call	GETARG
 20949 00002744 5E                      	pop	si
 20950 00002745 7501                    	jnz	short ADD_PROMPT3
 20951                                  ADD_PROMPT_RETN:
 20952 00002747 C3                      	retn
 20953                                  ADD_PROMPT3:			; Pre scan for arguments
 20954 00002748 E87501                  	call	move_name	; Move in name
 20955 0000274B E89101                  	call	GETARG
 20956 0000274E 56                      	push	si
 20957 0000274F EB53                    	jmp	short ADD_NAME
 20958                                  
 20959                                  ;break	The SET command
 20960                                  
 20961                                  ; Input: DS:SI points to a CR terminated string
 20962                                  ; Output: carry flag is set if no room
 20963                                  ;	  otherwise name is added to environment
 20964                                  
 20965                                  DISP_ENVJ:
 20966 00002751 E9BC00                  	jmp	DISP_ENV
 20967                                  
 20968                                  ADD_NAME_TO_ENVIRONMENT:
 20969 00002754 E88801                  	call	GETARG
 20970 00002757 74F8                    	jz	short DISP_ENVJ
 20971                                  
 20972                                  ; check if line contains exactly one equals sign
 20973                                  
 20974 00002759 31DB                    	xor	bx,bx		; = count is 0
 20975 0000275B 56                      	push	si		; Save pointer to beginning of line
 20976                                  EQLP:
 20977 0000275C AC                      	lodsb			; Get a char
 20978 0000275D 3C0D                    	cmp	al,13 ; 0Dh	; IF CR we're all done
 20979 0000275F 740F                    	je	short QUEQ	
 20980 00002761 3C3D                    	cmp	al,'='		; Look for = sign	
 20981 00002763 75F7                    	jne	short EQLP	; not there, get next char
 20982 00002765 FEC3                    	inc	bl		; Otherwise increment EQ count
 20983 00002767 803C0D                  	cmp	byte [si],13	; Look for CR following = sign
 20984 0000276A 75F0                    	jne	short EQLP
 20985 0000276C FEC7                    	inc	bh		; Set BH=1 means no parameters
 20986 0000276E EBEC                    	jmp	short EQLP	; And look for more
 20987                                  QUEQ:
 20988 00002770 5E                      	pop	si		; Restore beginning of line
 20989 00002771 FECB                    	dec	bl		; Zero flag means only one EQ
 20990 00002773 7406                    	jz	short ONEQ	; Good line
 20991 00002775 BA[6892]                	mov	dx,SYNTMES_PTR
 20992 00002778 E92707                  	jmp	cerror
 20993                                  ONEQ:
 20994 0000277B 53                      	push	bx
 20995 0000277C E8BD00                  	call	delete_name_in_environment
 20996 0000277F 5B                      	pop	bx
 20997 00002780 FECF                    	dec	bh
 20998 00002782 74C3                    	jz	short ADD_PROMPT_RETN
 20999 00002784 E86601                  	call	scan_double_null
 21000 00002787 89FB                    	mov	bx,di		; Save ptr to beginning of env var name
 21001 00002789 E83401                  	call	move_name
 21002 0000278C 56                      	push	si
 21003 0000278D 87DF                    	xchg	bx,di		; Switch ptrs to beginning and end of
 21004                                  				;  env var name
 21005                                  		
 21006                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
 21007                                  ; necessary in the resident for re-reading the transient. Let's look for
 21008                                  ; COMSPEC=
 21009                                  
 21010 0000278F C606[7497]00            	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
 21011 00002794 BE[9394]                	mov	si,COMSPECSTR ; "COMSPEC="
 21012 00002797 B90400                  	mov	cx,4
 21013 0000279A F3A7                    	repe	cmpsw
 21014 0000279C 7504                    	jnz	short NOT_COMSPEC
 21015                                  				; Zero set => exact match
 21016 0000279E FE06[7497]              	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
 21017                                  	;mov	byte [COMSPEC_FLAG],1
 21018                                  NOT_COMSPEC:
 21019 000027A2 89DF                    	mov	di,bx		; Load ptr to end of env var name
 21020                                  ADD_NAME:
 21021 000027A4 5E                      	pop	si		; Add the value of the new env var
 21022 000027A5 56                      	push	si		;  to the environment.
 21023                                  ADD_NAME1:
 21024 000027A6 AC                      	lodsb
 21025 000027A7 3C0D                    	cmp	al,13 ; 0Dh
 21026 000027A9 7405                    	je	short ADD_NAME_RET
 21027 000027AB E8AD01                  	call	store_char
 21028 000027AE EBF6                    	jmp	short ADD_NAME1
 21029                                  ADD_NAME_RET:
 21030 000027B0 5E                      	pop	si
 21031 000027B1 803E[7497]00            	cmp	byte [comspec_flag],0
 21032                                  				; If the new env var is comspec,	
 21033                                  ADD_NAME_JZ_RET:
 21034 000027B6 748F                    	jz	short ADD_PROMPT_RETN 
 21035                                  				;  copy the value into the
 21036                                  				;  comspec var in the resident
 21037                                  
 21038                                  ; We have changed the COMSPEC variable. We need to update the resident
 21039                                  ; pieces necessary to reread in the info. First, skip all delimiters
 21040                                  
 21041 000027B8 E87303                  	call	scanoff
 21042 000027BB 8E06[F39D]              	mov	es,[RESSEG]	;  comspec var in the resident
 21043                                  
 21044                                  ; Make sure that the printer knows where the beginning of the string is
 21045                                  
 21046 000027BF BF[E901]                	mov	di,ComSpec
 21047 000027C2 89FB                    	mov	bx,di
 21048                                  
 21049                                  ; Generate drive letter for display
 21050                                  
 21051 000027C4 31C0                    	xor	ax,ax		;g assume no drive first
 21052 000027C6 26A2[3202]              	mov	[es:ComDrv],al
 21053                                  	; 23/02/2023
 21054                                  	; MSDOS 6.0 (& 5.0)
 21055 000027CA 50                      	push	ax		;AN000; 3/3/KK
 21056 000027CB 8A04                    	mov	al,[si]		;AN000; 3/3/KK
 21057 000027CD E83F01                  	call	testkanj	;AN000; 3/3/KK	
 21058 000027D0 58                      	pop	ax		;AN000; 3/3/KK
 21059 000027D1 7518                    	jnz	short _GOTDRIVE
 21060                                  	;
 21061 000027D3 807C013A                	cmp	byte [si+1],':'	; drive specified?
 21062 000027D7 7512                    	jne	short _GOTDRIVE
 21063 000027D9 8A04                    	mov	al,[si]		; get his specified drive
 21064                                  	; 23/02/2023
 21065 000027DB E85B01                  	call	UPCONV
 21066                                  	;call	UPCONV_MAPCALL	; convert to uppercase
 21067 000027DE 2C41                    	sub	al,'A'		; convert to 0-based
 21068 000027E0 83C702                  	add	di,2
 21069 000027E3 FEC0                    	inc	al		; convert to 1-based number
 21070 000027E5 26A2[3202]              	mov	[es:ComDrv],al
 21071                                  
 21072                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
 21073                                  ; done here..
 21074                                  	;add	al,40h
 21075 000027E9 0440                    	add	al,'A'-1
 21076                                  _GOTDRIVE:
 21077                                  	; 23/02/2023
 21078                                  	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
 21079                                  	;mov	[es:PUTBACKSUBSTPTR],di
 21080                                  	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
 21081 000027EB 26893E[C801]            	mov	[es:PutBackComSpec],di
 21082                                  				;g point to beginning of name after drive
 21083                                  	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
 21084                                  	;mov	[es:PUTBACKDRV],al
 21085                                  	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
 21086 000027F0 26A2[CD01]              	mov	[es:PutBackDrv],al
 21087                                  
 21088                                  ; Copy chars until delim      	
 21089                                  
 21090 000027F4 89DF                    	mov	di,bx
 21091                                  COPY_COMSPEC:
 21092 000027F6 AC                      	lodsb
 21093 000027F7 E83C03                  	call	DELIM
 21094 000027FA 7407                    	jz	short COPYDONE
 21095 000027FC 3C0D                    	cmp	al,13 ; 0Dh
 21096 000027FE 7403                    	je	short COPYDONE
 21097 00002800 AA                      	stosb
 21098 00002801 EBF3                    	jmp	short COPY_COMSPEC
 21099                                  COPYDONE:
 21100 00002803 30C0                    	xor	al,al		; Null terminate the string and quit
 21101 00002805 AA                      	stosb
 21102                                  	;mov	byte [comspec_flag],0
 21103 00002806 A2[7497]                	mov	[comspec_flag],al ; 0 ; 23/02/2023
 21104 00002809 4F                      	dec	di
 21105 0000280A 26893E[2902]            	mov	[es:ComSpec_End],di
 21106 0000280F C3                      	retn
 21107                                  
 21108                                  DISP_ENV:
 21109 00002810 8E1E[F39D]              	mov	ds,[RESSEG]
 21110 00002814 8E1E[DC03]              	mov	ds,[EnvirSeg]
 21111                                  	; assume ds:nothing
 21112 00002818 31F6                    	xor	si,si
 21113                                  PENVLP:
 21114 0000281A 803C00                  	cmp	byte [si],0
 21115 0000281D 7497                    	jz	short ADD_NAME_JZ_RET
 21116 0000281F BF[87A7]                	mov	di,Arg_Buf
 21117                                  PENVLP2:
 21118 00002822 AC                      	lodsb
 21119 00002823 AA                      	stosb
 21120 00002824 08C0                    	or	al,al
 21121 00002826 75FA                    	jnz	short PENVLP2
 21122 00002828 BA[6D93]                	mov	dx,arg_buf_ptr
 21123 0000282B 1E                      	push	ds
 21124 0000282C 06                      	push	es
 21125 0000282D 1F                      	pop	ds
 21126                                  	; assume ds:nothing
 21127 0000282E E8D02C                  	call	Printf_Crlf
 21128 00002831 1F                      	pop	ds
 21129 00002832 EBE6                    	jmp	short PENVLP
 21130                                  
 21131                                  ; =============== S U B	R O U T	I N E =======================================
 21132                                  
 21133                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21134                                  delete_path:
 21135 00002834 BE[8794]                	mov	si,PATH_TEXT ; "PATH="
 21136 00002837 EB03                    	jmp	short delete_name_in_environment
 21137                                  
 21138                                  ; =============== S U B	R O U T	I N E =======================================
 21139                                  
 21140                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21141                                  delete_prompt:
 21142 00002839 BE[8C94]                	mov	si,PROMPT_TEXT ; "PROMPT="
 21143                                  
 21144                                  ; ---------------------------------------------------------------------------
 21145                                  
 21146                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21147                                  delete_name_in_environment:
 21148                                  
 21149                                  ; Input: DS:SI points to a "=" terminated string
 21150                                  ; Output: carry flag is set if name not found
 21151                                  ;	  otherwise name is deleted
 21152                                  
 21153 0000283C 56                      	push	si
 21154 0000283D 1E                      	push	ds
 21155 0000283E E82C00                  	call	FIND		; ES:DI points to name
 21156 00002841 7217                    	jc	short del1
 21157 00002843 89FE                    	mov	si,di		; Save it
 21158 00002845 E8BF00                  	call	SCASB2		; Scan for the nul
 21159 00002848 87F7                    	xchg	si,di
 21160                                  ;SR;
 21161                                  ; If we have only one env string, then the double null is lost when the last
 21162                                  ;string is deleted and we have an invalid empty environment with only a
 21163                                  ;single null. To avoid this, we will look for the double null case and then
 21164                                  ;move an extra null char.
 21165                                  ; Bugbug: The only possible problem is that the last pathstring
 21166                                  ;will be followed by a triple null. Is this really a problem?
 21167                                  
 21168                                  	; MSDOS 6.0
 21169 0000284A 26803C00                	cmp	byte [es:si],0	;null char?
 21170 0000284E 7501                    	jnz	short not_dnull	;no, we are at a double null
 21171 00002850 4E                      	dec	si		;point at the double null
 21172                                  not_dnull:
 21173                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21174 00002851 E86901                  	call	GETENVSIZ
 21175 00002854 29F1                    	sub	cx,si
 21176 00002856 06                      	push	es
 21177 00002857 1F                      	pop	ds		; ES:DI points to name
 21178                                  				; DS:SI points to next name
 21179 00002858 F3A4                    	rep	movsb
 21180                                  del1:
 21181 0000285A 1F                      	pop	ds
 21182 0000285B 5E                      	pop	si
 21183                                  find_retn:
 21184 0000285C C3                      	retn
 21185                                  
 21186                                  ; =============== S U B	R O U T	I N E =======================================
 21187                                  
 21188                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21189                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
 21190                                  find_path:
 21191 0000285D BE[8794]                	mov	si,PATH_TEXT ; "PATH="
 21192 00002860 EB03                    	jmp	short find_name_in_environment
 21193                                  
 21194                                  ; =============== S U B	R O U T	I N E =======================================
 21195                                  
 21196                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21197                                  find_prompt:
 21198 00002862 BE[8C94]                	mov	si,PROMPT_TEXT ; "PROMPT="
 21199                                  
 21200                                  ; ---------------------------------------------------------------------------
 21201                                  
 21202                                  find_name_in_environment:
 21203                                  
 21204                                  ; Input: DS:SI points to a "=" terminated string
 21205                                  ; Output: ES:DI points to the arguments in the environment
 21206                                  ;	  zero is set if name not found
 21207                                  ;	  carry flag is set if name not valid format
 21208                                  
 21209 00002865 E80500                  	call	FIND		; Find the name
 21210 00002868 72F2                    	jc	short find_retn	; Carry means not found	
 21211 0000286A E99600                  	jmp	SCASB1		; Scan for = sign
 21212                                  
 21213                                  ; ---------------------------------------------------------------------------
 21214                                  	;nop
 21215                                  
 21216                                  ; =============== S U B	R O U T	I N E =======================================
 21217                                  
 21218                                  ; On return of FIND1, ES:DI points to beginning of name
 21219                                  
 21220                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 21221                                  FIND:
 21222 0000286D FC                      	cld
 21223 0000286E E84100                  	call	COUNT0		; CX = Length of name
 21224 00002871 8E06[F39D]              	mov	es,[RESSEG]
 21225                                  	;assume es:RESGROUP
 21226 00002875 268E06[DC03]            	mov	es,[es:EnvirSeg]
 21227                                  	;assume es:NOTHING
 21228 0000287A 31FF                    	xor	di,di
 21229                                  find1:	
 21230 0000287C 51                      	push	cx
 21231 0000287D 56                      	push	si
 21232 0000287E 57                      	push	di
 21233                                  find11:
 21234 0000287F AC                      	lodsb
 21235                                  	; 23/02/2023 
 21236                                  	; MSDOS 6.0 (& 5.0)
 21237 00002880 E88C00                  	call	testkanj	
 21238 00002883 740F                    	jz	short notkanj3
 21239 00002885 4E                      	dec	si
 21240 00002886 AD                      	lodsw
 21241 00002887 47                      	inc	di
 21242 00002888 47                      	inc	di
 21243 00002889 263B45FE                	cmp	ax,[es:di-2]
 21244 0000288D 7511                    	jne	short find12
 21245 0000288F 49                      	dec	cx
 21246 00002890 E2ED                    	loop	find11
 21247 00002892 EB0C                    	jmp	short find12
 21248                                  notkanj3:
 21249 00002894 E8A200                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 21250                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 21251 00002897 47                      	inc	di
 21252 00002898 263A45FF                	cmp	al,[es:di-1]
 21253 0000289C 7502                    	jne	short find12
 21254 0000289E E2DF                    	loop	find11
 21255                                  find12:
 21256 000028A0 5F                      	pop	di
 21257 000028A1 5E                      	pop	si
 21258 000028A2 59                      	pop	cx
 21259 000028A3 74B7                    	jz	short find_retn
 21260 000028A5 51                      	push	cx
 21261 000028A6 E85E00                  	call	SCASB2		; Scan for a nul
 21262 000028A9 59                      	pop	cx
 21263 000028AA 26803D00                	cmp	byte [es:di],0
 21264 000028AE 75CC                    	jnz	short find1
 21265 000028B0 F9                      	stc			; Indicate not found
 21266 000028B1 C3                      	retn
 21267                                  
 21268                                  ; =============== S U B	R O U T	I N E =======================================
 21269                                  
 21270                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21271                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
 21272                                  COUNT0:
 21273 000028B2 1E                      	push	ds
 21274 000028B3 07                      	pop	es
 21275                                  	;assume es:nothing
 21276 000028B4 89F7                    	mov	di,si
 21277                                  ;COUNT1:
 21278 000028B6 57                      	push	di		; Count number of chars until "="
 21279 000028B7 E84900                  	call	SCASB1
 21280                                  	; 23/02/2023
 21281                                  ;	jmp	short COUNTX
 21282                                  ;COUNT2:
 21283                                  ;	push	di		; Count number of chars until nul
 21284                                  ;	call	SCASB2
 21285                                  ;COUNTX:
 21286 000028BA 59                      	pop	cx
 21287 000028BB 29CF                    	sub	di,cx
 21288 000028BD 87F9                    	xchg	di,cx
 21289                                  move_name_retn:
 21290 000028BF C3                      	retn
 21291                                  
 21292                                  ; =============== S U B	R O U T	I N E =======================================
 21293                                  
 21294                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21295                                  move_name:
 21296 000028C0 803C0D                  	cmp	byte [si],13 ; 0Dh
 21297 000028C3 74FA                    	je	short move_name_retn
 21298 000028C5 AC                      	lodsb
 21299                                  	; 23/02/2023 
 21300                                  	; MSDOS 6.0 (& 5.0)
 21301 000028C6 E84600                  	call	testkanj		
 21302 000028C9 7409                    	jz	short notkanj1
 21303 000028CB E88D00                  	call	store_char
 21304 000028CE AC                      	lodsb
 21305 000028CF E88900                  	call	store_char
 21306 000028D2 EBEC                    	jmp	short move_name
 21307                                  notkanj1: 
 21308 000028D4 E86200                  	call	UPCONV
 21309                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3
 21310 000028D7 E88100                  	call	store_char
 21311 000028DA 3C3D                    	cmp	al,'='
 21312 000028DC 75E2                    	jne	short move_name
 21313                                  getarg_retn:
 21314 000028DE C3                      	retn
 21315                                  
 21316                                  ; =============== S U B	R O U T	I N E =======================================
 21317                                  
 21318                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21319                                  GETARG:
 21320 000028DF BE8000                  	mov	si,80h
 21321 000028E2 AC                      	lodsb
 21322 000028E3 08C0                    	or	al,al
 21323 000028E5 74F7                    	jz	short getarg_retn
 21324 000028E7 E84402                  	call	scanoff
 21325 000028EA 3C0D                    	cmp	al,13 ; 0Dh
 21326                                  sdn_retn:
 21327 000028EC C3                      	retn
 21328                                  
 21329                                  ; =============== S U B	R O U T	I N E =======================================
 21330                                  
 21331                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
 21332                                  ; there is NO double NULL, merely a string that is empty.
 21333                                  
 21334                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21335                                  scan_double_null:
 21336 000028ED 8E06[F39D]              	mov	es,[RESSEG]
 21337 000028F1 268E06[DC03]            	mov	es,[es:EnvirSeg]
 21338 000028F6 31FF                    	xor	di,di
 21339                                  
 21340                                  ; Top cycle-point. If the string here is empty, then we are done
 21341                                  
 21342                                  sdn1:
 21343 000028F8 26803D00                	cmp	byte [es:di],0	; nul string?
 21344 000028FC 74EE                    	jz	short sdn_retn	; yep, all done
 21345 000028FE E80600                  	call	SCASB2
 21346 00002901 EBF5                    	jmp	short sdn1
 21347                                  
 21348                                  ; =============== S U B	R O U T	I N E =======================================
 21349                                  
 21350                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21351                                  SCASB1:
 21352 00002903 B03D                    	mov	al,'='		; Scan for an =
 21353 00002905 EB02                    	jmp	short SCASBX
 21354                                  
 21355                                  ; =============== S U B	R O U T	I N E =======================================
 21356                                  
 21357                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21358                                  SCASB2:
 21359 00002907 30C0                    	xor	al,al		; Scan for a nul
 21360                                  
 21361                                  ; ---------------------------------------------------------------------------
 21362                                  
 21363                                  	; 23/02/2023
 21364                                  SCASBX:
 21365 00002909 B90001                  	mov	cx,256
 21366 0000290C F2AE                    	repne	scasb
 21367 0000290E C3                      	retn
 21368                                  
 21369                                  ; =============== S U B	R O U T	I N E =======================================
 21370                                  
 21371                                  ; MSDOS 6.0
 21372                                  
 21373                                  ;Bugbug: This is Kanji stuff - put it in conditionals
 21374                                  
 21375                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 21376                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
 21377                                  testkanj:
 21378 0000290F 1E                      	push	ds			;AN000;  3/3/KK
 21379 00002910 56                      	push	si			;AN000;  3/3/KK
 21380 00002911 50                      	push	ax			;AN000;  3/3/KK
 21381 00002912 2E8E1E[F39D]            	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
 21382 00002917 C536[5C02]              	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
 21383                                  ktlop:					;AN000;  3/3/KK
 21384 0000291B 833C00                  	cmp	word [si],0		;AN000;  end of Table 3/3/KK
 21385 0000291E 740E                    	je	short notlead 		;AN000;  3/3/KK
 21386 00002920 58                      	pop	ax			;AN000;  3/3/KK
 21387 00002921 50                      	push	ax			;AN000;  3/3/KK
 21388 00002922 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 21389 00002924 7208                    	jb	short notlead 		;AN000;  3/3/KK
 21390 00002926 46                      	inc	si			;AN000;  3/3/KK
 21391 00002927 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 21392 00002929 7607                    	jbe	short islead		;AN000;  3/3/KK
 21393 0000292B 46                      	inc	si			;AN000;  3/3/KK
 21394 0000292C EBED                    	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
 21395                                  notlead:				;AN000;  3/3/KK
 21396 0000292E 31C0                    	xor	ax,ax			;AN000;  set zero 3/3/KK
 21397 00002930 EB03                    	jmp	short ktret		;AN000;  3/3/KK
 21398                                  islead: 				;AN000;  3/3/KK
 21399 00002932 31C0                    	xor	ax,ax			;AN000;  reset zero 3/3/KK
 21400 00002934 40                      	inc	ax			;AN000;  3/3/KK
 21401                                  ktret:					;AN000;  3/3/KK
 21402 00002935 58                      	pop	ax			;AN000;  3/3/KK
 21403 00002936 5E                      	pop	si			;AN000;  3/3/KK
 21404 00002937 1F                      	pop	ds			;AN000;  3/3/KK
 21405 00002938 C3                      	retn				;AN000;  3/3/KK
 21406                                  
 21407                                  ; =============== S U B	R O U T	I N E =======================================
 21408                                  
 21409                                  ; MSDOS 6.0
 21410                                  
 21411                                  ; ****************************************************************
 21412                                  ; *
 21413                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 21414                                  ; *
 21415                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 21416                                  ; *		 the character in AL from the file upper case table
 21417                                  ; *		 in DOS if character if above  ascii 128, else
 21418                                  ; *		 subtracts 20H if between "a" and "z".
 21419                                  ; *
 21420                                  ; * INPUT:	 AL	      char to be upper cased
 21421                                  ; *		 FUCASE_ADDR  set to the file upper case table
 21422                                  ; *
 21423                                  ; * OUTPUT:	 AL	      upper cased character
 21424                                  ; *
 21425                                  ; ****************************************************************
 21426                                  
 21427                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21428                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
 21429                                  
 21430                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 21431                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2A6Eh
 21432                                  UPCONV:
 21433 00002939 3C80                    	cmp	al,80h			;AN000;  see if char is > ascii 128
 21434 0000293B 7213                    	jb	short oth_fucase	;AN000;  no - upper case math
 21435 0000293D 2C80                    	sub	al,80h			;AN000;  only upper 128 chars in table
 21436 0000293F 1E                      	push	ds			;AN000;
 21437 00002940 53                      	push	bx			;AN000;
 21438 00002941 8E1E[F39D]              	mov	ds,[RESSEG]		;AN000;  get resident data segment
 21439                                  	;lds	bx,dword ptr FUCase_Addr+1
 21440 00002945 C51E[5402]              	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
 21441 00002949 83C302                  	add	bx,2			;AN000;  skip over first word
 21442                                  	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
 21443 0000294C D7                      	xlat
 21444 0000294D 5B                      	pop	bx			;AN000;
 21445 0000294E 1F                      	pop	ds			;AN000;
 21446                                  	;jmp	short upconv_end	;AN000;  we finished - exit
 21447                                  	; 10/06/2023
 21448                                  upconv_end:
 21449                                  	; 24/02/2023
 21450 0000294F C3                      	retn
 21451                                  oth_fucase:				;AN000;
 21452 00002950 3C61                    	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
 21453 00002952 72FB                    	jb	short upconv_end	;AC000;    subtract 20h to get
 21454 00002954 3C7A                    	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
 21455 00002956 77F7                    	ja	short upconv_end	;AC000;
 21456 00002958 2C20                    	sub	al,20h			;AC000; Change lower-case to upper
 21457                                  ;upconv_end:	; 10/06/2023		;AN000;
 21458 0000295A C3                      	retn
 21459                                  
 21460                                  ; ---------------------------------------------------------------------------
 21461                                  
 21462                                  ; MSDOS 3.3
 21463                                  
 21464                                  	; 24/02/2023
 21465                                  ;UPCONV_MAPCALL:
 21466                                  	;			; If between "a" and "z"
 21467                                  	;cmp	al,[small_a]
 21468                                  	;jb	short UPCONV_END
 21469                                  	;cmp	al,[small_z]
 21470                                  	;ja	short UPCONV_END
 21471                                  	;sub	al,20h		; Change lower-case to upper
 21472                                  ;UPCONV_END:
 21473                                  	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
 21474                                  	;			  ; 	  for (current) country
 21475                                  	;retn
 21476                                  
 21477                                  ; =============== S U B	R O U T	I N E =======================================
 21478                                  
 21479                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
 21480                                  
 21481                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21482                                  store_char:
 21483 0000295B 51                      	push	cx
 21484 0000295C 53                      	push	bx
 21485                                  
 21486                                  	; 24/02/2023
 21487                                  	;;16/10/2018
 21488                                  	; MSDOS 6.0
 21489 0000295D 06                      	push	es		;AN056;*
 21490 0000295E 1E                      	push	ds		;AN056; Save local DS
 21491 0000295F 8E1E[F39D]              	mov	ds,[RESSEG]	;AN056; Get resident segment
 21492 00002963 8E06[DC03]              	mov	es,[EnvirSeg]	;AN056; Get environment segment
 21493 00002967 1F                      	pop	ds		;AN056; Get local segment back
 21494                                  
 21495                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21496 00002968 E85200                  	call	GETENVSIZ
 21497 0000296B 89CB                    	mov	bx,cx		; Save room for double nul
 21498 0000296D 83EB02                  	sub	bx,2
 21499 00002970 39DF                    	cmp	di,bx
 21500 00002972 723F                    	jb	short store1
 21501 00002974 50                      	push	ax
 21502 00002975 51                      	push	cx
 21503 00002976 53                      	push	bx		; Save Size of environment
 21504 00002977 E85DDE                  	call	FREE_TPA
 21505 0000297A 5B                      	pop	bx
 21506 0000297B 83C302                  	add	bx,2		; Recover true environment size
 21507                                  
 21508 0000297E 81FB0080                	cmp	bx,8000h	; Don't let environment grow > 32K
 21509 00002982 7203                    	jb	short envsiz_ok
 21510                                  bad_env_size:			;AN056;
 21511 00002984 F9                      	stc
 21512 00002985 EB16                    	jmp	short envnoset
 21513                                  	;nop
 21514                                  envsiz_ok:
 21515 00002987 B104                    	mov	cl,4
 21516 00002989 D3EB                    	shr	bx,cl		; Convert back to paragraphs
 21517 0000298B 43                      	inc	bx
 21518                                  	; 24/02/2023
 21519                                  	; MSDOS 6.0
 21520 0000298C 8CC1                    	mov	cx,es		;AN056; Get environment segment
 21521 0000298E 01D9                    	add	cx,bx		;AN056; Add in size of environment
 21522 00002990 83C120                  	add	cx,20h		;AN056; Add in some TPA
 21523 00002993 8CC8                    	mov	ax,cs		;AN056; Get the transient segment
 21524 00002995 39C1                    	cmp	cx,ax		;AN056; Are we hitting the transient?
 21525 00002997 73EB                    	jnb	short bad_env_size
 21526                                  				;AN056; Yes - don't do it!!!
 21527                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21528 00002999 B44A                    	mov	ah,4Ah
 21529                                  	;mov	ah,SETBLOCK ; 4Ah
 21530 0000299B CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 21531                                  			; ES = segment address of block	to change
 21532                                  			; BX = new size	in paragraphs
 21533                                  envnoset:
 21534 0000299D 9C                      	pushf
 21535 0000299E 06                      	push	es
 21536 0000299F 8E06[F39D]              	mov	es,[RESSEG]
 21537 000029A3 E841DE                  	call	ALLOC_TPA
 21538 000029A6 07                      	pop	es
 21539 000029A7 9D                      	popf
 21540 000029A8 59                      	pop	cx
 21541 000029A9 58                      	pop	ax
 21542                                  	; 10/06/2023
 21543 000029AA 7307                    	jnc	short store1
 21544                                  	; 24/02/2023
 21545 000029AC 07                      	pop	es ; MSDOS 6.0	;AN056;*	
 21546                                  	;jnc	short store1
 21547 000029AD BA[E791]                	mov	dx,ENVERR_PTR
 21548 000029B0 E9EF04                  	jmp	cerror
 21549                                  store1:	
 21550 000029B3 AA                      	stosb
 21551 000029B4 26C7050000              	mov	word [es:di],0	; NULL IS AT END
 21552                                  	; 24/02/2023
 21553 000029B9 07                      	pop	es ; MSDOS 6.0	;AN056;*
 21554 000029BA 5B                      	pop	bx
 21555 000029BB 59                      	pop	cx
 21556 000029BC C3                      	retn
 21557                                  
 21558                                  ; =============== S U B	R O U T	I N E =======================================
 21559                                  
 21560                                  	; 24/02/2023
 21561                                  GETENVSIZ:
 21562                                  
 21563                                  ;Get size of environment in bytes, rounded up to paragraph boundry
 21564                                  ;ES has environment segment
 21565                                  ;Size returned in CX, all other registers preserved
 21566                                  
 21567 000029BD 06                      	push	es
 21568 000029BE 50                      	push	ax
 21569 000029BF 8CC0                    	mov	ax,es
 21570 000029C1 48                      	dec	ax		;Point at arena
 21571 000029C2 8EC0                    	mov	es,ax
 21572                                  	;mov	ax,[es:3]
 21573 000029C4 26A10300                	mov	ax,[es:ARENA.size]
 21574 000029C8 B104                    	mov	cl,4
 21575 000029CA D3E0                    	shl	ax,cl		;Convert to bytes
 21576 000029CC 89C1                    	mov	cx,ax
 21577 000029CE 58                      	pop	ax
 21578 000029CF 07                      	pop	es
 21579                                  getenvsiz_retn:
 21580 000029D0 C3                      	retn
 21581                                  
 21582                                  ; =============== S U B	R O U T	I N E =======================================
 21583                                  
 21584                                  	; 24/02/2023
 21585                                  RestUDir1:
 21586 000029D1 1E                      	push	ds
 21587 000029D2 8E1E[F39D]              	mov	ds,[RESSEG]
 21588 000029D6 803E[3F02]00            	cmp	byte [RestDir],0
 21589 000029DB 1F                      	pop	ds
 21590 000029DC 74F2                    	jz	short getenvsiz_retn
 21591                                  
 21592                                  ; =============== S U B	R O U T	I N E =======================================
 21593                                  
 21594                                  	; 24/02/2023
 21595                                  RestUDir:
 21596 000029DE BA[D59C]                	mov	dx,USERDIR1
 21597 000029E1 B43B                    	mov	ah,3Bh
 21598                                  	;mov	ah,CHDir ; 3Bh
 21599 000029E3 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21600                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21601 000029E5 30C0                    	xor	al,al
 21602                                  	;call	SETREST
 21603                                  	;retn
 21604                                  	; 24/02/2023
 21605 000029E7 E94908                  	jmp	SETREST
 21606                                  
 21607                                  ;============================================================================
 21608                                  ; TENV2.ASM, MSDOS 6.0, 1991
 21609                                  ;============================================================================
 21610                                  ; 07/10/2018 - Retro DOS v3.0
 21611                                  
 21612                                  ; TITLE	Part6 COMMAND Transient routines.
 21613                                  
 21614                                  ;	Environment utilities and misc. routines
 21615                                  
 21616                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
 21617                                  
 21618                                  ; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21619                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h
 21620                                  
 21621                                  ; ---------------------------------------------------------------------------
 21622                                  
 21623                                  ; ****************************************************************
 21624                                  ; *
 21625                                  ; * ROUTINE:	 $CHDIR
 21626                                  ; *
 21627                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
 21628                                  ; *		 line. If path is found, CHDIR to path. If a drive
 21629                                  ; *		 letter is found, get and display the current dir
 21630                                  ; *		 of the specified drive. If nothing is found, get
 21631                                  ; *		 and display the current dir of the default drive.
 21632                                  ; *
 21633                                  ; * INPUT:	 command line at offset 81H
 21634                                  ; *
 21635                                  ; * OUTPUT:	 none
 21636                                  ; *
 21637                                  ; ****************************************************************
 21638                                  
 21639                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21640                                  
 21641                                  	; 10/06/2023 - Retro DOS v4.2 COMMAND.COM
 21642                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2B21h
 21643                                  _$CHDIR:
 21644                                  	; MSDOS 6.0
 21645 000029EA BE8100                  	mov	si,81h
 21646 000029ED BF[2298]                	mov	di,PARSE_CHDIR
 21647                                  				;AN000; Get address of PARSE_CHDIR
 21648 000029F0 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 21649 000029F2 31D2                    	xor	dx,dx		;AN000;
 21650 000029F4 E812FD                  	call	Parse_With_Msg	;AC018; call parser
 21651                                  	
 21652                                  	;cmp	ax,-1
 21653                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 21654                                  	;je	short bwdj	; No args
 21655                                  	;;cmp	ax,0
 21656                                  	;;cmp	ax,RESULT_NO_ERROR
 21657                                  	;			;AC000; did we have an error?
 21658                                  	;or	ax,ax ; ax = 0 ?
 21659                                  	;jnz	short ChDirErr	;AC018; yes - exit
 21660                                  	
 21661                                  	; 10/06/2023
 21662 000029F7 40                      	inc	ax	; cmp ax,-1
 21663 000029F8 7414                    	jz	short bwdj ; 0FFFFh -> 0
 21664 000029FA 48                      	dec	ax	; cmp ax,0
 21665 000029FB 756D                    	jnz	short ChDirErr ; 1 -> 0
 21666                                  	; ax = 0
 21667                                  
 21668                                  	;cmp	byte [PARSE1_TYPE],6
 21669 000029FD 803E[E1A9]06            	cmp	byte [PARSE1_TYPE],result_drive
 21670                                  				;AC000; was a drive entered?
 21671 00002A02 7511                    	jne	short REALCD	; no
 21672                                  
 21673                                  ; D: was found. See if there is anything more.
 21674                                  
 21675 00002A04 BF[2298]                	mov	di,PARSE_CHDIR
 21676                                  				;AC000; get address of parse_chdir
 21677 00002A07 31D2                    	xor	dx,dx		;AC000;
 21678 00002A09 E8E7FC                  	call	parse_check_eol ;AC000; call parser
 21679 00002A0C 755C                    	jnz	short ChDirErr	;AC000;
 21680                                  bwdj:
 21681 00002A0E E87BF9                  	call	build_dir_for_chdir
 21682                                  				; Drive only specified
 21683 00002A11 E80D01                  	call	CRLF2
 21684                                  chdir_retn:
 21685 00002A14 C3                      	retn
 21686                                  
 21687                                  	; 24/02/2023
 21688                                  	; MSDOS 3.3
 21689                                  	;mov	ax,[COMSW]
 21690                                  	;or	ax,[ALLSWITCH]
 21691                                  	;mov	dx,BADPARMPTR
 21692                                  	;jnz	short CHDIR_ERR
 21693                                  	;mov	si,81h
 21694                                  	;call	SCANOFF
 21695                                  	;cmp	al,0Dh		; are we at end of line?
 21696                                  	;je	short BWDJ	; No args
 21697                                  	;inc	si
 21698                                  	;lodsb
 21699                                  	;cmp	al,':'
 21700                                  	;jne	short REALCD
 21701                                  	;push	si
 21702                                  	;call	SCANOFF
 21703                                  	;pop	si
 21704                                  	;cmp	al,0Dh		; was a drive entered?
 21705                                  	;jne	short REALCD	; no
 21706                                  ;BWDJ:
 21707                                  	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
 21708                                  	;call	CRLF2
 21709                                  ;CHDIR_RETN:
 21710                                  	;retn
 21711                                  
 21712                                  	; 24/02/2023
 21713                                  	; MSDOS 6.0
 21714                                  REALCD:
 21715 00002A15 56                      	push	si		;AN000; save position in line
 21716 00002A16 C536[E5A9]              	lds	si,[PARSE1_ADDR]
 21717                                  				;AN000; get address of filespec
 21718 00002A1A E8D807                  	call	Move_To_SrcBuf	;AN000; move to srcbuf
 21719 00002A1D 5E                      	pop	si		;AN000; restore position in line
 21720 00002A1E BF[2298]                	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
 21721 00002A21 31D2                    	xor	dx,dx		;AC000;
 21722 00002A23 E8CDFC                  	call	parse_check_eol ;AC000; call parser
 21723 00002A26 7542                    	jnz	short ChDirErr	;AC000;
 21724                                  	
 21725 00002A28 E81106                  	call	SETPATH
 21726 00002A2B F606[AEA0]02            	test	byte [DestInfo],2
 21727 00002A30 7518                    	jnz	short BadChDir
 21728                                  
 21729                                  	; 26/04/2023
 21730 00002A32 B43B                    	mov	ah,3Bh
 21731                                  	;mov	ah,CHDir
 21732 00002A34 CD21                    	int	21h
 21733 00002A36 73DC                    	jnc	short chdir_retn
 21734                                  	
 21735 00002A38 E807F8                  	call	get_ext_error_number
 21736                                  				;AN022; get the extended error
 21737 00002A3B 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 21738                                  				;AN022; see if path not found
 21739 00002A3E 740A                    	je	short BadChDir	;AN022; yes - issue old message
 21740                                  ;SR;
 21741                                  ; We want to issue "Invalid Directory" message even if the path is valid
 21742                                  ;but is not a directory. The extended error returns "Access denied" which
 21743                                  ;is kind of confusing. Issue the old message if access denied error is 
 21744                                  ;returned
 21745                                  
 21746 00002A40 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 21747 00002A43 7405                    	je	short BadChDir
 21748                                  	
 21749 00002A45 E89E00                  	call	set_ext_error_subst ;AN022;
 21750 00002A48 EB20                    	jmp	short ChDirErr	;AN022;
 21751                                  
 21752                                  BadChDir:
 21753 00002A4A BA[0B93]                	mov	dx,badcd_ptr
 21754                                  ;ChDirErr:
 21755                                  ;	call	std_eprintf
 21756                                  ;mkdir_retn:
 21757                                  	;retn
 21758                                  	; 24/02/2023
 21759 00002A4D EB1B                    	jmp	short ChDirErr	;AN022;
 21760                                  
 21761                                  	; 24/02/2023
 21762                                  	; MSDOS 3.3
 21763                                  ;REALCD:
 21764                                  	;call	SETPATH
 21765                                  	;test	byte [DESTINFO],2
 21766                                  	;jnz	short BADCHDIR
 21767                                  	;mov	ah,CHDir ; 3Bh
 21768                                  	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21769                                  	;		; DS:DX	-> ASCIZ directory name	(may include drive)
 21770                                  	;jnc	short CHDIR_RETN
 21771                                  ;BADCHDIR:
 21772                                  	;mov	dx,BADCDPTR
 21773                                  ;CHDIR_ERR:
 21774                                  	;call	STD_EPRINTF
 21775                                  ;MKDIR_RETN:
 21776                                  	;retn
 21777                                  
 21778                                  ; =============== S U B	R O U T	I N E =======================================
 21779                                  
 21780                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21781                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
 21782                                  
 21783                                  	; 11/06/2023 - Retro DOS v4.2
 21784                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2B8Ch
 21785                                  _$MKDIR:
 21786                                  	; MSDOS 6.0
 21787 00002A4F E86300                  	call	SETRMMK
 21788 00002A52 7216                    	jc	short MkDirErr
 21789                                  
 21790 00002A54 B439                    	mov	ah,39h
 21791                                  	;mov	ah,MKDIR
 21792 00002A56 CD21                    	int	21h
 21793 00002A58 7313                    	jnc	short mkdir_retn
 21794                                  
 21795 00002A5A E8E5F7                  	call	get_ext_error_number	
 21796                                  				;AN022; get the extended error
 21797 00002A5D 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 21798                                  				;AN022; see if path not found
 21799 00002A60 742A                    	je	short MD_other_err
 21800                                  				;AN022; yes - issue old message
 21801 00002A62 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 21802                                  				;AN022; access denied?
 21803 00002A65 7407                    	je	short badmderr	;AN022; yes - see if file exists
 21804                                  	
 21805 00002A67 E87C00                  	call	set_ext_error_subst
 21806                                  				;AN022;
 21807                                  	;jmp	short MkDirerr	;AC022; yes - go print it
 21808                                  	; 24/02/2023
 21809                                  ChDirErr:
 21810                                  MkDirErr:
 21811                                  RmDirErr:
 21812 00002A6A E89A2A                  	call	std_eprintf
 21813                                  mkdir_retn:
 21814                                  rmdir_retn:
 21815 00002A6D C3                      	retn
 21816                                  	
 21817                                  badmderr:
 21818 00002A6E BA[219B]                	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
 21819 00002A71 B41A                    	mov	ah,1Ah
 21820                                  	;mov	ah,Set_DMA	;AN006;
 21821 00002A73 CD21                    	int	21h		;AN006;
 21822                                  	
 21823 00002A75 B44E                    	mov	ah,4Eh
 21824                                  	;mov	ah,Find_First	;AN006; see if file/dir exists
 21825                                  	;mov	cx,10h
 21826 00002A77 B91000                  	mov	cx,ATTR_DIRECTORY
 21827                                  				;AN006;   search for directory
 21828 00002A7A CD21                    	int	21h		;AN006;
 21829 00002A7C 720E                    	jc	short MD_other_err
 21830                                  				;AN006; doesn't exist - must be something else
 21831                                  	;;mov	dl,SRCXNAME.find_buf_attr
 21832                                  				;AN006; we found a file/dir
 21833                                  	;mov	dl,[SRCXNAME+21] 
 21834 00002A7E 8A16[369B]              	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
 21835 00002A82 F6C210                  	test	dl,ATTR_DIRECTORY
 21836                                  				;AN006; was it a directory?
 21837 00002A85 7405                    	jz	short MD_other_err
 21838                                  				;AN006; no - must have been a file
 21839 00002A87 BA[FE93]                	mov	dx,MD_EXISTS_PTR
 21840                                  				;AN006; set up already exists error
 21841 00002A8A EBDE                    	jmp	short MkDirErr	;AN006; make sure we didn't have network error
 21842                                  MD_other_err:			;AN006;
 21843 00002A8C BA[0E93]                	mov	dx,badmkd_ptr
 21844                                  ;MkDirErr:
 21845                                  	;call	std_eprintf
 21846                                  	;retn
 21847                                  	; 24/02/2023
 21848 00002A8F EBD9                    	jmp	short MkDirErr
 21849                                  
 21850                                  	; 24/02/2023
 21851                                  	; MSDOS 3.3
 21852                                  	;call	SETRMMK
 21853                                  	;jb	short MKDIRERR
 21854                                  	;mov	ah,MKDIR ; 39h
 21855                                  	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
 21856                                  	;		; DS:DX	-> ASCIZ pathname (may include drive)
 21857                                  	;jnc	short MKDIR_RETN
 21858                                  	;mov	dx,BADMKDPTR
 21859                                  	;call	GET_EXT_ERR_NUMBER
 21860                                  ;MKDIRERR:
 21861                                  	;call	STD_EPRINTF
 21862                                  	;retn
 21863                                  
 21864                                  ; =============== S U B	R O U T	I N E =======================================
 21865                                  
 21866                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21867                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
 21868                                  	; 11/06/2023 - Retro DOS v4.2
 21869                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2C00h
 21870                                  _$RMDIR:
 21871 00002A91 E82100                  	call	SETRMMK
 21872 00002A94 72D4                    	jb	short RmDirErr
 21873 00002A96 7518                    	jnz	short badrderr
 21874                                  
 21875 00002A98 B43A                    	mov	ah,3Ah
 21876                                  	;mov	ah,RMDIR ; 3Ah
 21877 00002A9A CD21                    	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
 21878                                  			; DS:DX	-> ASCIZ pathname (may include drive)
 21879 00002A9C 73CF                    	jnc	short rmdir_retn ; 24/02/2023
 21880                                  
 21881                                  	; 24/02/2023
 21882                                  	; MSDOS 6.0
 21883 00002A9E E8A1F7                  	call	get_ext_error_number
 21884                                  				;AN022; get the extended error
 21885 00002AA1 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 21886                                  				;AN022; see if path not found
 21887 00002AA4 740A                    	je	short badrderr	;AN022; yes - issue old message
 21888 00002AA6 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 21889                                  				;AN022; access denied?
 21890 00002AA9 7405                    	je	short badrderr	;AN022; yes - issue old message
 21891                                  
 21892 00002AAB E83800                  	call	set_ext_error_subst
 21893                                  				;AN022;
 21894 00002AAE EBBA                    	jmp	short RmDirErr	;AC022; yes - go print it
 21895                                  
 21896                                  	; MSDOS 6.0
 21897                                  badrderr:
 21898                                  	; 24/02/2023
 21899 00002AB0 BA[1193]                	mov	dx,badrmd_ptr
 21900 00002AB3 EBB5                    	jmp	short RmDirErr
 21901                                  ;RmDirErr:
 21902                                  	;call	std_eprintf
 21903                                  ;;rmdir_retn
 21904                                  	;retn
 21905                                  
 21906                                  	; 24/02/2023
 21907                                  	; MSDOS 3.3
 21908                                  	;mov	dx,BADRMDPTR
 21909                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 21910                                  ;RMDIRERR:
 21911                                  	;call	STD_EPRINTF
 21912                                  ;RMDIR_RETN:
 21913                                  	;retn
 21914                                  
 21915                                  ; =============== S U B	R O U T	I N E =======================================
 21916                                  
 21917                                  ; 	<Common MkDir/RmDir set up code>
 21918                                  ;****************************************************************
 21919                                  ;*
 21920                                  ;* ROUTINE:	SETRMMK
 21921                                  ;*
 21922                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
 21923                                  ;*		commands. Parses the command line for a required
 21924                                  ;*		filespec.
 21925                                  ;*
 21926                                  ;* INPUT:	command line at offset 81H
 21927                                  ;*
 21928                                  ;* OUTPUT:	carry clear
 21929                                  ;*		    DS:DX points to ASCIIZ argument
 21930                                  ;*		carry set
 21931                                  ;*		    DS:DX has error message pointer
 21932                                  ;*
 21933                                  ;****************************************************************
 21934                                  
 21935                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21936                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
 21937                                  	; 11/06/2023 - Retro DOS v4.2
 21938                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2BCEh
 21939                                  SETRMMK:
 21940                                  	; MSDOS 6.0
 21941 00002AB5 BE8100                  	mov	si,81h
 21942 00002AB8 BF[1998]                	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
 21943 00002ABB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 21944 00002ABD 31D2                    	xor	dx,dx		;AN000;
 21945                                  	;invoke	Parse_With_Msg	;AC000; call parser
 21946 00002ABF E847FC                  	call	Parse_With_Msg
 21947                                  	;cmp	ax,0
 21948                                  	;cmp	ax,RESULT_NO_ERROR
 21949 00002AC2 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 21950 00002AC4 7519                    	jnz	short noargerr	;AC000; yes - exit
 21951                                  
 21952 00002AC6 BF[219B]                	mov	di,SRCXNAME
 21953                                  				;AN000; get address of srcxname
 21954 00002AC9 57                      	push	di		;AN000; save address
 21955 00002ACA 56                      	push	si		;AN000; save position in line
 21956 00002ACB C536[E5A9]              	lds	si,[PARSE1_ADDR]
 21957                                  				;AN000; get address of path
 21958                                  mrdir_move_filename:		;AN000; put filespec in srcxname
 21959 00002ACF AC                      	lodsb			;get a char from buffer
 21960 00002AD0 AA                      	stosb			;AN000; store in srcxname
 21961                                  	;cmp	al,0
 21962                                  	;cmp	al,END_OF_LINE_OUT
 21963 00002AD1 20C0                    	and	al,al ; 0 ?	;AC000; it char a terminator?
 21964 00002AD3 75FA                    	jnz	short mrdir_move_filename
 21965                                  				;AC000; no - keep moving
 21966 00002AD5 5E                      	pop	si		;AN000; get line position back
 21967                                  
 21968                                  ; we have scanned an argument.	See if any args beyond.
 21969                                  
 21970 00002AD6 BF[1998]                	mov	di,PARSE_MRDIR
 21971 00002AD9 E817FC                  	call	parse_check_eol ;AC000; are we at end of line?
 21972 00002ADC 5A                      	pop	dx		;AC000; get address of SRCXNAME
 21973                                  	;retz			;yes - return no error
 21974 00002ADD 7406                    	jz	short setrmmk_retn
 21975                                  noargerr:
 21976 00002ADF BA[D091]                	mov	dx,extend_buf_ptr
 21977                                  				;AC000; get extended message pointer
 21978 00002AE2 31C0                    	xor	ax,ax
 21979 00002AE4 F9                      	stc
 21980                                  setrmmk_retn:
 21981 00002AE5 C3                      	retn
 21982                                  
 21983                                  	; 24/02/2023
 21984                                  	; MSDOS 3.3
 21985                                  ;SETRMMK:
 21986                                  	;mov	si,81h
 21987                                  	;call	SCANOFF
 21988                                  	;cmp	al,0Dh
 21989                                  	;je	short NOARGERR
 21990                                  	;mov	dx,si
 21991                                  ;SETRMMK1:
 21992                                  	;lodsb
 21993                                  	;call	DELIM
 21994                                  	;jz	short SETRMMK3
 21995                                  	;cmp	al,0Dh
 21996                                  	;jne	short SETRMMK1
 21997                                  	;mov	byte [si-1],0
 21998                                  ;SETRMMK2:
 21999                                  	;retn
 22000                                  ;SETRMMK3:
 22001                                  	;mov	byte [si-1],0
 22002                                  	;push	si
 22003                                  	;call	SCANOFF
 22004                                  	;pop	si
 22005                                  	;cmp	al,0Dh
 22006                                  	;je	short SETRMMK2
 22007                                  ;NOARGERR:
 22008                                  	;mov	dx,BADARGSPTR
 22009                                  	;xor	ax,ax
 22010                                  	;stc
 22011                                  ;SETRMMK_RETN:
 22012                                  	;retn
 22013                                  
 22014                                  ; =============== S U B	R O U T	I N E =======================================
 22015                                  
 22016                                  ; MSDOS 6.0
 22017                                  
 22018                                  ;****************************************************************
 22019                                  ;*
 22020                                  ;* ROUTINE:	Set_ext_error_subst
 22021                                  ;*
 22022                                  ;* FUNCTION:	Sets up substitution for extended error
 22023                                  ;*
 22024                                  ;* INPUT:	AX - extended error number
 22025                                  ;*		DX - offset of string
 22026                                  ;*
 22027                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
 22028                                  ;*
 22029                                  ;****************************************************************
 22030                                  
 22031                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22032                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
 22033                                  set_ext_error_subst:
 22034                                  	;mov	byte [msg_disp_class],1
 22035 00002AE6 C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class
 22036                                  					;AN022; set up extended error msg class
 22037 00002AEB 8916[91A0]              	mov	[string_ptr_2],dx 	;AN022; get address of failed string
 22038                                  	;mov	byte [extend_buf_sub],1
 22039 00002AEF C606[D291]01            	mov	byte [extend_buf_sub],one_subst
 22040                                  	;AN022; put number of subst in control block
 22041 00002AF4 BA[D091]                	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
 22042 00002AF7 A3[D091]                	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
 22043                                  savudir_err_retn: ; 24/02/2023
 22044 00002AFA C3                      	retn				;AN022; return
 22045                                  
 22046                                  ; =============== S U B	R O U T	I N E =======================================
 22047                                  
 22048                                  ; <SavUDir - preserve the users current directory on a particular drive>
 22049                                  
 22050                                  ; SavUDir - move the user's current directory on a drive into UserDir1
 22051                                  ; SavUDir1 - move the user's current directory on a drive into a specified
 22052                                  ;   buffer
 22053                                  ;
 22054                                  ;   Inputs:	DL has 1-based drive number
 22055                                  ;		ES:DI has destination buffer (SavUDir1 only)
 22056                                  ;   Outputs:	Carry Clear
 22057                                  ;		    DS = TranGroup
 22058                                  ;		Carry Set
 22059                                  ;		    AX has error code
 22060                                  ;   Registers Modified: AX, SI
 22061                                  
 22062                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22063                                  SAVUDIR:
 22064 00002AFB BF[D59C]                	mov	di,USERDIR1
 22065                                  ; --------------
 22066                                  SAVUDIR1:
 22067 00002AFE 88D0                    	mov	al,dl
 22068 00002B00 0440                    	add	al,'@' ; 40h
 22069 00002B02 3C40                    	cmp	al,'@' ; 40h
 22070 00002B04 7506                    	jne	short GOTUDRV
 22071 00002B06 0206[059E]              	add	al,[CURDRV]
 22072 00002B0A FEC0                    	inc	al		; A = 1
 22073                                  GOTUDRV:
 22074 00002B0C AA                      	stosb
 22075 00002B0D 8A26[F89D]              	mov	ah,[DIRCHAR]
 22076 00002B11 B03A                    	mov	al,':' ; 3Ah
 22077 00002B13 AB                      	stosw
 22078 00002B14 06                      	push	es
 22079 00002B15 1F                      	pop	ds
 22080 00002B16 89FE                    	mov	si,di
 22081 00002B18 B447                    	mov	ah,47h ; 24/02/2023
 22082                                  	;mov	ah,CURRENT_DIR	; 47h
 22083 00002B1A CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 22084                                  			; DL = drive (0=default,1=A,etc.)
 22085                                  			; DS:SI	points to 64-byte buffer area
 22086 00002B1C 72DC                    	jc	short savudir_err_retn ; 24/02/2023
 22087 00002B1E 0E                      	push	cs
 22088 00002B1F 1F                      	pop	ds
 22089 00002B20 C3                      	retn
 22090                                  
 22091                                  ; =============== S U B	R O U T	I N E =======================================
 22092                                  
 22093                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22094                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
 22095                                  CRLF2:
 22096 00002B21 52                      	push	dx
 22097 00002B22 BA[B293]                	mov	dx,acrlf_ptr
 22098 00002B25 1E                      	push	ds
 22099 00002B26 0E                      	push	cs
 22100 00002B27 1F                      	pop	ds
 22101 00002B28 E8E429                  	call	std_printf
 22102 00002B2B 1F                      	pop	ds
 22103 00002B2C 5A                      	pop	dx
 22104 00002B2D C3                      	retn
 22105                                  
 22106                                  ; =============== S U B	R O U T	I N E =======================================
 22107                                  
 22108                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
 22109                                  ; may NOT be TRANGROUP
 22110                                  
 22111                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22112                                  scanoff:
 22113 00002B2E AC                      	lodsb
 22114 00002B2F E80400                  	call	DELIM
 22115 00002B32 74FA                    	jz	short scanoff
 22116 00002B34 4E                      	dec	si		; Point to first non-delimiter
 22117                                  scanoff_retn:
 22118 00002B35 C3                      	retn
 22119                                  
 22120                                  ; =============== S U B	R O U T	I N E =======================================
 22121                                  
 22122                                  ; Input:    AL is character to classify
 22123                                  ; Output:   Z set if delimiter
 22124                                  ;	    NZ set otherwise
 22125                                  ; Registers modified: none
 22126                                  
 22127                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22128                                  DELIM:
 22129 00002B36 3C20                    	cmp	al,' '	 ;20h
 22130 00002B38 74FB                    	je	short scanoff_retn
 22131 00002B3A 3C3D                    	cmp	al,'='  ; 3Dh
 22132 00002B3C 74F7                    	je	short scanoff_retn
 22133 00002B3E 3C2C                    	cmp	al,','	; 2Ch
 22134 00002B40 74F3                    	je	short scanoff_retn
 22135 00002B42 3C3B                    	cmp	al,';'	 ;3Bh
 22136 00002B44 74EF                    	je	short scanoff_retn
 22137 00002B46 3C09                    	cmp	al,9		; Check for TAB character
 22138 00002B48 74EB                    	je	short scanoff_retn
 22139 00002B4A 3C0A                    	cmp	al,0Ah		; Check for line feed character - BAS
 22140 00002B4C C3                      	retn
 22141                                  
 22142                                  
 22143                                  ; =============== S U B	R O U T	I N E =======================================
 22144                                  
 22145                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22146                                  FCB_TO_ASCZ:			
 22147                                  	; Convert DS:SI to ASCIZ ES:DI
 22148 00002B4D B90800                  	mov	cx,8
 22149                                  MAINNAME:
 22150 00002B50 AC                      	lodsb
 22151 00002B51 3C20                    	cmp	al,' ' ; 20h
 22152 00002B53 7401                    	jz	short SKIPSPC
 22153 00002B55 AA                      	stosb
 22154                                  SKIPSPC:
 22155 00002B56 E2F8                    	loop	MAINNAME
 22156 00002B58 AC                      	lodsb
 22157 00002B59 3C20                    	cmp	al,' '
 22158 00002B5B 740F                    	je	short GOTNAME
 22159 00002B5D 88C4                    	mov	ah,al
 22160                                  	; 24/02/2023
 22161 00002B5F B02E                    	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
 22162                                  	;mov	al,[DOT_CHR]  ; MSDOS 3.3
 22163                                  	;stosb
 22164                                  	;xchg	al,ah
 22165                                  	;stosb
 22166                                  	; 24/02/2023
 22167 00002B61 AB                      	stosw
 22168 00002B62 B102                    	mov	cl,2
 22169                                  EXTNAME:
 22170 00002B64 AC                      	lodsb
 22171 00002B65 3C20                    	cmp	al,' '
 22172 00002B67 7403                    	je	short GOTNAME
 22173 00002B69 AA                      	stosb
 22174 00002B6A E2F8                    	loop	EXTNAME
 22175                                  GOTNAME:
 22176 00002B6C 30C0                    	xor	al,al
 22177 00002B6E AA                      	stosb
 22178                                  STRCOMP_RETN:
 22179 00002B6F C3                      	retn
 22180                                  
 22181                                  ; =============== S U B	R O U T	I N E =======================================
 22182                                  
 22183                                  ; Compare ASCIZ DS:SI with ES:DI.
 22184                                  ; SI,DI destroyed.
 22185                                  
 22186                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22187                                  STRCOMP:	
 22188 00002B70 A6                      	cmpsb
 22189 00002B71 75FC                    	jnz	short STRCOMP_RETN ; Strings not equal
 22190 00002B73 807CFF00                	cmp	byte [si-1],0	; Hit NUL terminator?	
 22191                                  	;jz	short STRCOMP_RETN ; Yes, strings equal
 22192                                  	;jmp	short STRCOMP	; Equal so far, keep going
 22193                                  	; 24/02/2023
 22194 00002B77 75F7                    	jnz	short STRCOMP
 22195 00002B79 C3                      	retn
 22196                                  
 22197                                  ; =============== S U B	R O U T	I N E =======================================
 22198                                  
 22199                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22200                                  CRPRINT:
 22201 00002B7A 50                      	push	ax
 22202                                  	;mov	al,13	; 0Dh
 22203 00002B7B B00D                    	mov	al,0Dh
 22204 00002B7D 51                      	push	cx
 22205 00002B7E 57                      	push	di
 22206 00002B7F 89D7                    	mov	di,dx
 22207 00002B81 B9FFFF                  	mov	cx,65535 ; 0FFFFh
 22208 00002B84 06                      	push	es
 22209 00002B85 1E                      	push	ds
 22210 00002B86 07                      	pop	es
 22211 00002B87 F2AE                    	repne	scasb		; LOOK FOR TERMINATOR
 22212 00002B89 C645FF00                	mov	byte [di-1],0	; nul terminate the string
 22213 00002B8D 07                      	pop	es
 22214 00002B8E 8916[91A0]              	mov	[string_ptr_2],dx
 22215                                  	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
 22216 00002B92 BA[9793]                	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
 22217 00002B95 E87729                  	call	std_printf
 22218                                  	;mov	byte [di-1],13
 22219 00002B98 C645FF0D                	mov	byte [di-1],0Dh	; now put the CR back
 22220 00002B9C 7204                    	jb	short error_output
 22221 00002B9E 5F                      	pop	di
 22222 00002B9F 59                      	pop	cx
 22223 00002BA0 58                      	pop	ax
 22224 00002BA1 C3                      	retn
 22225                                  
 22226                                  ; ---------------------------------------------------------------------------
 22227                                  
 22228                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22229                                  error_output:
 22230 00002BA2 0E                      	push	cs
 22231 00002BA3 1F                      	pop	ds
 22232 00002BA4 8E06[F39D]              	mov	es,[RESSEG]
 22233 00002BA8 BA[E491]                	mov	dx,NOSPACE_PTR
 22234 00002BAB 26803E[B502]00          	cmp	byte [es:PipeFlag],0
 22235 00002BB1 7406                    	jz	short go_to_error
 22236 00002BB3 E80209                  	call	PipeOff
 22237 00002BB6 BA[3193]                	mov	dx,PIPEEMES_PTR
 22238                                  go_to_error:
 22239 00002BB9 E9E602                  	jmp	cerror
 22240                                  
 22241                                  ; =============== S U B	R O U T	I N E =======================================
 22242                                  
 22243                                  ;---- Mod for path invocation ----
 22244                                  
 22245                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 22246                                  pathchrcmp:
 22247                                  	; 18/03/2023	
 22248                                  	;push	ax
 22249                                  	;mov	ah,'/' ; 2Fh
 22250                                  	;cmp	[SWITCHAR],ah
 22251 00002BBC 803E[F79D]2F            	cmp	byte [SWITCHAR],'/' ; 2Fh
 22252 00002BC1 7404                    	je	short noslasht
 22253 00002BC3 3C2F                    	cmp	al,'/'
 22254 00002BC5 7402                    	je	short pccont
 22255                                  noslasht:
 22256 00002BC7 3C5C                    	cmp	al,'\' ; 5Ch
 22257                                  pccont:	
 22258                                  	;pop	ax
 22259 00002BC9 C3                      	retn
 22260                                  
 22261                                  ; =============== S U B	R O U T	I N E =======================================
 22262                                  
 22263                                  ; PATHCRUNCH -
 22264                                  ;
 22265                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
 22266                                  ;       PathPos = ptr to string with pathname in it
 22267                                  ;       PathCnt = length of string
 22268                                  ;
 22269                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
 22270                                  ;       PathCnt = length left in string
 22271                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
 22272                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
 22273                                  ;       If path crunched successfully,
 22274                                  ;         CY = clear
 22275                                  ;         Current directory is changed to directory in pathname
 22276                                  ;         UserDir1 contains previous directory for use by RestUDir
 22277                                  ;         RestDir = nonzero to flag later restoration of user's dir
 22278                                  ;         DestTail = ptr to beginning of filename
 22279                                  ;         If filename found in pathname,
 22280                                  ;           ZR = clear
 22281                                  ;           FCB filename fields contain filename
 22282                                  ;         If filename not found (pure directory path),
 22283                                  ;           ZR = set
 22284                                  ;           FCB filename fields are wildcarded with ?'s
 22285                                  ;       If pathcrunch failed (no ChDir's worked),
 22286                                  ;         CY = set
 22287                                  ;         Msg_Numb = extended error code
 22288                                  ;
 22289                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
 22290                                  ;       FCB by setting DirFlag. In this case, the FCB is returned
 22291                                  ;       with the filename wildcarded.
 22292                                  
 22293                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 22294                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h
 22295                                  
 22296                                  	; 11/06/2023 - Retro DOS v4.2
 22297                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2D11h
 22298                                  PathCrunch:
 22299                                  	; MSDOS 6.0
 22300 00002BCA C706[25A2]0000          	mov     word [Msg_Numb],0
 22301                                  				;AN022; Set up message flag
 22302                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22303                                  	;mov	dl,[5Ch]
 22304 00002BD0 8A165C00                	mov	dl,[FCB]	; DL = drive # (1 = A)
 22305 00002BD4 E824FF                  	call	SAVUDIR		; save current directory in UserDir1
 22306                                  	; MSDOS 6.0
 22307 00002BD7 7233                     	jc	short pcrunch_cderrj
 22308                                  				;AN022; if error on current dir - report
 22309 00002BD9 E86004                  	call	SETPATH		; scan past switches, whitespace
 22310                                  
 22311                                  ;       DX = ptr to pathname, NULL-terminated
 22312                                  ;       PathPos = ptr to byte after NULL at end of pathname
 22313                                  
 22314                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22315 00002BDC F606[AEA0]02            	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
 22316 00002BE1 752C                    	jnz	short trypeel	; wildcard seen, peel filename
 22317                                  
 22318                                  	;mov	ah,CHDir ; 3Bh
 22319 00002BE3 B43B                    	mov	ah,3Bh
 22320 00002BE5 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 22321                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 22322                                  	; MSDOS 6.0
 22323 00002BE7 7313                    	jnc	short chdir_worked	;AN022; no error - continue
 22324                                  	
 22325 00002BE9 E856F6                  	call	get_ext_error_number    ;AN022; get the extended error
 22326 00002BEC 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
 22327 00002BEF 741E                    	je	short trypeel		;AC022;    keep trying
 22328 00002BF1 83F805                  	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
 22329 00002BF4 7419                    	je	short trypeel		;AC022;    keep trying
 22330 00002BF6 A3[25A2]                	mov	[Msg_Numb],ax           ;AN022; set up message flag
 22331 00002BF9 E99C00                  	jmp	peelfail                ;AN022; exit with other error
 22332                                  
 22333                                  	; MSDOS 3.3
 22334                                  	;jc	short trypeel
 22335                                  chdir_worked:
 22336                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22337 00002BFC E83206                  	call	SetRest1	; set 'Restore Directory' flag true
 22338 00002BFF B03F                    	mov	al,'?'		; if pure dir, wildcard filename in FCB
 22339 00002C01 BF5D00                  	mov	di,5Dh  ; FCB+1
 22340 00002C04 B90B00                  	mov	cx,11
 22341 00002C07 F3AA                    	rep	stosb
 22342 00002C09 30C0                    	xor	al,al		; return carry clear, zero set
 22343 00002C0B C3                      	retn
 22344                                  
 22345                                  pcrunch_cderrj: 		;AN022; need this for long jmp
 22346 00002C0C E98100                  	jmp	pcrunch_cderr	;AN022;
 22347                                  
 22348                                  trypeel:
 22349 00002C0F 8B36[80A0]              	mov	si,[PathPos]
 22350 00002C13 4E                      	dec	si		; SI = ptr to NULL at end of pathname
 22351 00002C14 8A44FF                  	mov	al,[si-1]	; AL = last char of pathname
 22352                                  	; 25/02/2023
 22353                                  	; MSDOS 5.0 (& 6.0)
 22354 00002C17 803E[40A2]00            	cmp	byte [KPARSE],0
 22355 00002C1C 7505                    	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
 22356                                  	
 22357 00002C1E E89BFF                  	call	pathchrcmp
 22358 00002C21 7475                    	jz	short peelfail	; Trailing '/'
 22359                                  delstrt:
 22360 00002C23 89F1                    	mov	cx,si		; CX = ptr to NULL at end of pathname
 22361 00002C25 89D6                    	mov	si,dx		; SI = ptr to start of pathname
 22362 00002C27 52                      	push	dx		; save ptr to pathname
 22363                                  delloop:
 22364 00002C28 39CE                    	cmp	si,cx
 22365                                  	;jz	short BADRET
 22366                                  	; 25/02/2023
 22367 00002C2A 7413                    	je	short gotdele	; no char's left, we have what we have
 22368 00002C2C AC                      	lodsb			; AL = next char of pathname
 22369 00002C2D E8DFFC                  	call	testkanj
 22370 00002C30 7403                    	jz	short notkanj8	; not Kanji, move along
 22371 00002C32 46                      	inc	si
 22372 00002C33 EBF3                    	jmp	short delloop	
 22373                                  
 22374                                  	; 25/02/2023
 22375                                  	; MSDOS 3.3
 22376                                  	;mov	al,[si]
 22377                                  	;call	PATHCHRCMP
 22378                                  	;jz	short TRYCD
 22379                                  	;dec	si
 22380                                  	;jmp	short delloop
 22381                                  
 22382                                  notkanj8:
 22383 00002C35 E884FF                  	call	pathchrcmp
 22384 00002C38 75EE                    	jnz	short delloop	; not a path delimiter, keep looking
 22385 00002C3A 89F2                    	mov	dx,si
 22386 00002C3C 4A                      	dec	dx		; DX = ptr to last delimiter found	
 22387 00002C3D EBE9                    	jmp	short delloop	; go look for more
 22388                                  
 22389                                  	; 25/02/2023
 22390                                  	; MSDOS 5.0 (& 6.0)
 22391                                  gotdele:
 22392 00002C3F 89D6                    	mov	si,dx		; SI = ptr to pathname or last delim
 22393 00002C41 5A                      	pop	dx		; DX = ptr to pathname
 22394 00002C42 39D6                    	cmp	si,dx
 22395 00002C44 7454                    	je	short badret	; didn't find path delim
 22396 00002C46 89F1                    	mov	cx,si		; CX = ptr to last path delimiter
 22397 00002C48 89D6                    	mov	si,dx		; SI = ptr to pathname
 22398                                  delloop2:			; Set value of KPARSE
 22399 00002C4A 39CE                    	cmp	si,cx
 22400 00002C4C 7412                    	je	short trycd	; roll up till SI meets CX
 22401 00002C4E C606[40A2]00            	mov	byte [KPARSE],0
 22402 00002C53 AC                      	lodsb
 22403 00002C54 E8B8FC                  	call	testkanj
 22404 00002C57 74F1                    	jz	short delloop2
 22405 00002C59 46                      	inc	si
 22406 00002C5A FE06[40A2]              	inc	byte [KPARSE]
 22407 00002C5E EBEA                    	jmp	short delloop2
 22408                                  
 22409                                  trycd:
 22410 00002C60 50                      	push	ax
 22411                                  	; 25/02/2023
 22412 00002C61 B02E                    	mov	al,'.'
 22413                                  	;mov	al,[DOT_CHR]	; AL = '.'
 22414                                  	; MSDOS 6.0
 22415 00002C63 384401                  	cmp	[si+1],al	; check for '.' after path delim
 22416                                  				;M019; allow continuation if '. ' or 
 22417                                  				;M019; '..' is not found.
 22418 00002C66 7509                    	jne	short trycd1	;M019; '.' not found
 22419 00002C68 384402                  	cmp	[si+2],al	;M019; check for '..'
 22420 00002C6B 7404                    	je	short trycd1	;M019; found '..'
 22421 00002C6D 807C0200                	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
 22422                                  trycd1:	
 22423 00002C71 58                      	pop     ax
 22424 00002C72 7424                    	jz	short peelfail	; if . or .., pure cd should have worked
 22425                                  
 22426                                  	; 25/02/2023
 22427                                  	; MSDOS 3.3
 22428                                  	;cmp	[si+1],	al	; check for '.' after path delim
 22429                                  	;pop	ax
 22430                                  	;jz	short PEELFAIL	; if . or .., pure cd should have worked
 22431                                  
 22432                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22433 00002C74 8A44FF                  	mov	al,[si-1]
 22434 00002C77 3C3A                    	cmp	al,':' 		; Special case d:\file
 22435 00002C79 741F                    	je	short badret
 22436                                  	; 25/02/2023
 22437                                  	; MSDOS 6.0
 22438 00002C7B 803E[40A2]00            	cmp	byte [KPARSE],0
 22439 00002C80 7505                    	jnz	short notdoublesl
 22440 00002C82 E837FF                  	call	pathchrcmp
 22441                                  	;jnz	short notdoublesl
 22442                                  				; Last char is 2nd KANJI byte, might be '\'
 22443                                  	; 25/02/2023
 22444 00002C85 7411                    	jz	short peelfail 
 22445                                  ;peelfail:
 22446                                  	;stc
 22447                                  	;retn
 22448                                  
 22449                                  notdoublesl:
 22450 00002C87 C60400                  	mov	byte [si],0
 22451                                  	;mov	ah,CHDir ; 3Bh
 22452 00002C8A B43B                    	mov	ah,3Bh
 22453 00002C8C CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 22454                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 22455 00002C8E 7320                    	jnc	short cdsucc
 22456                                  
 22457                                  	; 25/02/2023
 22458                                  	; MSDOS 6.0
 22459                                  pcrunch_cderr:
 22460 00002C90 E8AFF5                  	call	get_ext_error_number
 22461                                  				;AN022; get the extended error
 22462 00002C93 A3[25A2]                	mov	[Msg_Numb],ax	;AN022; set up message flag
 22463 00002C96 09F6                    	or	si,si		;AN022; set up zero flag to not zero
 22464                                  peelfail: ; 25/02/2023
 22465 00002C98 F9                      	stc			;AN022; set up carry flag
 22466                                  pcrunch_retn:
 22467 00002C99 C3                      	retn
 22468                                  
 22469                                  badret:
 22470                                  	; MSDOS 3.3 & MSDOS 6.0
 22471 00002C9A 8A04                    	mov	al,[si]
 22472 00002C9C E81DFF                  	call	pathchrcmp	; Special case 'DIRCHAR'file
 22473 00002C9F F9                      	stc
 22474 00002CA0 75F7                    	jnz	short pcrunch_retn
 22475 00002CA2 30DB                    	xor	bl,bl
 22476 00002CA4 865C01                  	xchg	bl,[si+1]
 22477                                  	;mov	ah,CHDir ; 3Bh
 22478 00002CA7 B43B                    	mov	ah,3Bh
 22479 00002CA9 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 22480                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 22481                                  	;jc	short pcrunch_retn ; MSDOS 3.3
 22482                                  	; 25/02/2023
 22483 00002CAB 72E3                    	jc	short pcrunch_cderr
 22484                                  				;AN022; go to error exit 
 22485 00002CAD 885C01                  	mov	[si+1],bl
 22486                                  cdsucc:
 22487 00002CB0 E87E05                  	call	SetRest1
 22488 00002CB3 46                      	inc	si		; Reset zero
 22489 00002CB4 8936[ACA0]              	mov	[DestTail],si
 22490                                  	; 25/02/2023
 22491                                  	; MSDOS 6.0
 22492 00002CB8 9C                      	pushf			;AN015; save flags
 22493 00002CB9 803E[88A0]FF            	cmp	byte [DirFlag],-1
 22494                                  				;AN015; don't do parse if in DIR
 22495 00002CBE 7408                    	je	short pcrunch_end
 22496                                  				;AN015;
 22497                                  	; MSDOS 3.3 & MSDOS 6.0
 22498 00002CC0 BF5C00                  	mov	di,FCB  ; 5Ch
 22499                                  	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
 22500 00002CC3 B80229                  	mov	ax,2902h	
 22501 00002CC6 CD21                    	int	21h		; Parse with default drive
 22502                                  			; DOS -	PARSE FILENAME
 22503                                  			; DS:SI	-> string to parse
 22504                                  			; ES:DI	-> buffer to fill with unopened	FCB
 22505                                  			; AL = bit mask	to control parsing
 22506                                  	; MSDOS 3.3
 22507                                  	;retn
 22508                                  
 22509                                  pcrunch_end:
 22510 00002CC8 9D                      	popf			;AN015; get flags back
 22511 00002CC9 C3                      	retn
 22512                                  
 22513                                  ;============================================================================
 22514                                  ; TMISC1.ASM, MSDOS 6.0, 1991
 22515                                  ;============================================================================
 22516                                  ; 05/10/2018 - Retro DOS v3.0
 22517                                  
 22518                                  ;TITLE	Part7 COMMAND Transient Routines
 22519                                  
 22520                                  ;	More misc routines
 22521                                  
 22522                                  ;---------------------------
 22523                                  ; We can get rid of this switch processing code if we can take
 22524                                  ; care of the remaining two calls to switch, later in the file.
 22525                                  ; However, I have not checked whether or not any other files use
 22526                                  ; switch -- after all, it IS public!
 22527                                  ;---------------------------
 22528                                  
 22529                                  ; 14/06/2023
 22530                                  SWCOUNT	EQU 8	; MSDOS 6.22		; Length of switch_list
 22531                                  ; 28/03/2023
 22532                                  ;SWCOUNT  EQU  6  ; MSDOS 6.0 (& MSDOS 5.0)
 22533                                  ;;SWCOUNT EQU  5  ; MSDOS 3.3	
 22534                                  
 22535                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
 22536                                  
 22537                                  ; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 22538                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h
 22539                                  
 22540                                  ; ---------------------------------------------------------------------------
 22541                                  
 22542                                  	; 25/02/2023
 22543                                  RETSW:
 22544 00002CCA 93                      	xchg	ax,bx		; Put switches in AX
 22545 00002CCB C3                      	retn
 22546                                  
 22547                                  ; =============== S U B	R O U T	I N E =======================================
 22548                                  
 22549                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 22550                                  	; 11/06/2023 - Retro DOS 4.2 COMMAND.COM
 22551                                  SWITCH:
 22552 00002CCC 31DB                    	xor	bx,bx		; Initialize - no switches set
 22553                                  SWLOOP:
 22554 00002CCE E85DFE                  	call	scanoff		; Skip any delimiters
 22555 00002CD1 3A06[F79D]              	cmp	al,[SWITCHAR]	; Is it a switch specifier?
 22556 00002CD5 75F3                    	jnz	short RETSW	; No -- we're finished
 22557 00002CD7 81CB0080                	or	bx,8000h
 22558                                  	;or	bx,FSWITCH	; Indicate there is a switch specified
 22559 00002CDB 46                      	inc	si		; Skip over the switch character
 22560 00002CDC E84FFE                  	call	scanoff
 22561 00002CDF 3C0D                    	cmp	al,0Dh
 22562 00002CE1 74E7                    	je	short RETSW	; Oops
 22563 00002CE3 46                      	inc	si
 22564                                  
 22565                                  	; Convert lower case input to upper case
 22566                                  
 22567 00002CE4 E852FC                  	call	UPCONV
 22568                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 22569                                  
 22570 00002CE7 BF[6097]                	mov	di,switch_list	; "-Y?VBAPW" (for MSDOS 6.22) ; 11/06/2023
 22571                                  				; "?VBAPW" (for MSDOS 6.0)
 22572                                  				; ("VBAPW" (for MSDOS 3.3))
 22573                                  	; 11/06/2023
 22574                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2E33h
 22575 00002CEA B90800                  	mov	cx,8  ; MSDOS 6.22	   	
 22576                                  	;mov	cx,6  ; MSDOS 6.0 (& MSDOS 5.0)
 22577                                  	;;mov	cx,5  ; MSDOS 3.3
 22578                                  	;;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
 22579                                  		
 22580                                  	;nop
 22581                                  		
 22582 00002CED F2AE                    	repne	scasb		; Look for matching switch
 22583 00002CEF 7507                    	jnz	short BADSW
 22584 00002CF1 B80100                  	mov	ax,1
 22585 00002CF4 D3E0                    	shl	ax,cl		; Set a bit for the switch
 22586 00002CF6 09C3                    	or	bx,ax
 22587                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
 22588 00002CF8 EBD4                    	jmp	short SWLOOP
 22589                                  ;BADSW:
 22590                                  	;jmp	short SWLOOP
 22591                                  ;DRVBAD:
 22592                                  ;	mov	dx,baddrv_ptr
 22593                                  ;	jmp	cerror
 22594                                  EXTERNALJ:
 22595 00002CFA E90501                  	jmp	EXTERNAL
 22596                                  FNDCOM:				; search the internal command table
 22597 00002CFD 08C0                    	or	al,al		; Get real length of first arg
 22598 00002CFF 74F9                    	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
 22599                                  				;  to be external.
 22600                                  ; barryf code starts here
 22601                                  
 22602 00002D01 E82703                  	call	test_append	; see if APPEND installed
 22603 00002D04 7429                    	jz	short CONTCOM	; not loaded
 22604                                  
 22605                                  APPEND_INTERNAL:
 22606 00002D06 8A0E[AB9F]              	mov	cl,[IDLEN]
 22607 00002D0A B500                    	mov	ch,0
 22608 00002D0C 890E[80A0]              	mov	[PathPos],cx
 22609                                  	
 22610                                  	; 25/02/2023	
 22611                                  	; MSDOS 6.0
 22612 00002D10 FE06[27A2]              	inc 	byte [append_exec]
 22613                                  				;AN041; set APPEND to ON
 22614 00002D14 E8B603                  	call	IOSET		; re-direct the o'l io
 22615                                  
 22616 00002D17 BE[AB9F]                	mov	si,IDLEN	; address command name, DS already set	
 22617 00002D1A BAFFFF                  	mov	dx,-1 ; 0FFFFh	; set invoke function
 22618                                  		
 22619                                  	; MSDOS 6.0
 22620 00002D1D BF[F954]                	mov	di,append_parse
 22621                                  				;AN010; Get the entry point for PARSE for APPEND
 22622                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22623 00002D20 B801AE                  	mov	ax,0AE01h
 22624 00002D23 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal
 22625                                  			; - INSTALLABLE	COMMAND	- EXECUTE
 22626                                  			; DX = FFFFh, DS:SI -> buffer
 22627                                  			; Return: buffer at DS:SI filled with a	length byte
 22628                                  			; followed by the uppercase internal command
 22629                                  			; to execute (if length not 0)
 22630                                  	; 25/02/2023
 22631                                  	; INT 2Fh
 22632                                  	; 	AX = AE01h
 22633                                  	; entry:
 22634                                  	; 	DX = magic value FFFFh
 22635                                  	; 	CH = 00h
 22636                                  	; 	CL = length of command name
 22637                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 22638                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 22639                                  	; return:
 22640                                  	;	DS:SI buffer updated
 22641                                  	;	if length byte is nonzero, the following bytes contain
 22642                                  	;	the uppercase internal command to execute and the command line
 22643                                  	; 	buffer contains the command's parameters
 22644                                  	;	(the first DS:[SI] bytes are ignored)
 22645                                  	;
 22646                                  	; Format of COMMAND.COM command line buffer:
 22647                                  	;	Offset  Size    Description
 22648                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 22649                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 22650                                  	;	N BYTEs command line text, terminated by 0Dh
 22651                                  	;
 22652                                  	; Format of command name buffer:
 22653                                  	;	Offset  Size    Description
 22654                                  	;	00h     BYTE    length of command name
 22655                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 22656                                  
 22657 00002D25 803E[AB9F]00            	cmp	byte [IDLEN],0 ; execute requested
 22658 00002D2A 7503                    	jne	short CONTCOM
 22659 00002D2C E9A300                  	jmp	CMD_DONE
 22660                                  
 22661                                  	;nop
 22662                                  CONTCOM:			; continue with internal scan
 22663 00002D2F BF[DF95]                	mov	di,COMTAB
 22664 00002D32 31C9                    	xor	cx,cx
 22665                                  FINDCOM:
 22666 00002D34 BE[AC9F]                	mov	si,ID		; pointer to command argument
 22667 00002D37 8A0D                    	mov	cl,[di]		; load length of internal command
 22668 00002D39 47                      	inc	di		; advance past length
 22669 00002D3A E3BE                    	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
 22670 00002D3C 3A0E[AB9F]              	cmp	cl,[IDLEN]	; that of the command argument
 22671 00002D40 7506                    	jne	short ABCD	; lengths not equal ==> strings not eq
 22672 00002D42 890E[80A0]              	mov	[PathPos],cx	; store length of command
 22673 00002D46 F3A6                    	repe	cmpsb
 22674                                  ABCD:					
 22675 00002D48 9F                      	lahf			; save the good ol' flags
 22676 00002D49 01CF                    	add	di,cx		; skip over remaining internal, if any
 22677 00002D4B 8A05                    	mov	al,[di]		; load drive-check indicator byte (DCIB)
 22678 00002D4D A2[039E]                	mov	[CHKDRV],al	; save command flag byte in chkdrv
 22679 00002D50 47                      	inc	di		; increment DI (OK, OK, I'll stop)
 22680 00002D51 8B1D                    	mov	bx,[di]		; load internal command address
 22681 00002D53 47                      	inc	di		; skip over the puppy
 22682 00002D54 47                      	inc	di
 22683                                  		
 22684                                  	; MSDOS 6.0
 22685 00002D55 8B15                    	mov	dx,[di]		; load ptr to help msg #s
 22686 00002D57 47                      	inc	di
 22687 00002D58 47                      	inc	di
 22688 00002D59 9E                      	sahf			; remember those flags?
 22689 00002D5A 75D8                    	jnz	short FINDCOM	; well, if all the cmps worked...
 22690                                  
 22691                                  ; All messages get redirected.
 22692                                  
 22693 00002D5C 803E[27A2]00            	cmp     byte [append_exec],0
 22694                                  				;AN041; APPEND just executed?
 22695 00002D61 7503                    	jnz 	short DONT_SET_IO
 22696                                  				;AN041; Yes - this junk is already set
 22697 00002D63 E86703                  	call	IOSET		; re-direct the ol' i/o
 22698                                  
 22699                                  DONT_SET_IO:			;AN041;
 22700                                  
 22701                                  ; Check for /?. Certain commands, flagged fLimitHelp,
 22702                                  ; respond to /? only if it is the only command-line argument.
 22703                                  
 22704 00002D66 A1[089E]                	mov	ax,[COMSW]	; AX = switches after command
 22705 00002D69 0B06[0E9E]              	or	ax,[AllSwitch]	; AX = all switches
 22706                                  	;and	ax,SwitchQues	
 22707 00002D6D 83E020                  	and	ax,20h
 22708 00002D70 7426                    	jz	short DRIVE_CHECK
 22709                                  				; /? not in command line
 22710 00002D72 F606[039E]04            	test	byte [CHKDRV],4	
 22711                                  	;test	byte [CHKDRV],fLimitHelp
 22712 00002D77 7407                    	jz	short DO_HELP	; /? allowed in combination
 22713                                  
 22714                                  ; Make sure /? is the only argument on the command line.
 22715                                  
 22716 00002D79 833E[01A5]02            	cmp	word [ARG+ARG_UNIT.argvcnt],2
 22717 00002D7E 7518                    	jne	short DRIVE_CHECK
 22718                                  				; /? not only arg - ignore
 22719                                  
 22720                                  ; Note: this is all the check we need, even against things like /??.
 22721                                  ; Our argv parser breaks /?? into two args, /? and ?.
 22722                                  
 22723                                  DO_HELP:
 22724                                  ; DX = ptr to word list of msg #s, terminated by zero word
 22725                                  
 22726 00002D80 89D6                    	mov	si,dx		; SI = ptr to list of msg #s
 22727                                      	;mov	ax,no_subst	; AL = no subst's code
 22728 00002D82 B80000                  	mov	ax,0
 22729 00002D85 50                      	push	ax		; build subst block on stack
 22730                                  
 22731                                  NEXT_HELP_MSG:
 22732 00002D86 AD                      	lodsw			; AX = help msg # or zero
 22733 00002D87 09C0                    	or	ax,ax
 22734 00002D89 7409                    	jz	short HELP_DONE
 22735 00002D8B 50                      	push	ax		; SS:SP = ptr to subst block
 22736                                  				; (msg # and no_subst byte)
 22737                                  ;; We assume DS = SS.
 22738                                  	
 22739 00002D8C 89E2                    	mov     dx,sp		; DS:DX = ptr to subst block
 22740 00002D8E E87E27                  	call	std_printf	; display help message	
 22741 00002D91 58                      	pop	ax		; remove msg # from stack
 22742 00002D92 EBF2                    	jmp	short NEXT_HELP_MSG
 22743                                  
 22744                                  HELP_DONE:
 22745 00002D94 58                      	pop	ax		; clean up stack
 22746 00002D95 E96CD3                  	jmp	TCOMMAND	
 22747                                  
 22748                                  	; 25/02/2023
 22749                                  	; MSDOS 3.3
 22750                                  	;sahf			; remember those flags?
 22751                                  	;jnz	short FINDCOM	; well, if all the cmps worked...
 22752                                  	;call	IOSET		; re-direct the ol' i/o
 22753                                  
 22754                                  DRIVE_CHECK:
 22755 00002D98 F606[039E]01            	test	byte [CHKDRV],1
 22756                                  	;test	byte [CHKDRV],FCHECKDRIVE 
 22757                                  				; did we wanna check those drives?
 22758 00002D9D 7411                    	jz	short NOCHECK
 22759 00002D9F A0[069E]                	mov	al,[PARM1]	; parse_file_descriptor results tell
 22760 00002DA2 0A06[079E]              	or	al,[PARM2]	; us whether those drives were OK
 22761 00002DA6 3CFF                    	cmp	al,-1
 22762 00002DA8 7506                    	jne	short NOCHECK
 22763                                  	;jmp	DRVBAD
 22764                                  	; 25/02/2023
 22765                                  DRVBAD:
 22766 00002DAA BA[2C92]                	mov	dx,baddrv_ptr
 22767 00002DAD E9F200                  	jmp	cerror
 22768                                  
 22769                                  ; The user may have omitted the space between the command and its arguments.
 22770                                  ; We need to copy the remainder of the user's command line into the buffer.
 22771                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
 22772                                  ; into the command line at 80.
 22773                                  
 22774                                  NOCHECK:
 22775 00002DB0 E85B02                  	call	cmd_copy
 22776                                  SWITCHECK:
 22777                                  	;test	byte [CHKDRV],2
 22778 00002DB3 F606[039E]02            	test	byte [CHKDRV],fSwitchAllowed 
 22779                                  				; Does the command take switches
 22780 00002DB8 7516                    	jnz	short REALWORK	; Yes, process the command
 22781 00002DBA E82F00                  	call	noswit		; No, check to see if any switches
 22782 00002DBD 7511                    	jnz	short REALWORK	; None, process the command
 22783                                  
 22784                                  	; MSDOS 6.0
 22785                                  	;mov	byte [msg_disp_class],2
 22786 00002DBF C606[CE91]02            	mov	byte [msg_disp_class],parse_msg_class
 22787                                  				;AN000; set up parse error msg class
 22788 00002DC4 BA[D091]                	mov	dx,extend_buf_ptr	
 22789                                  				;AC000; get extended message pointer
 22790                                  	;mov	word [extend_buf_ptr],3
 22791 00002DC7 C706[D091]0300          	mov	word [extend_buf_ptr],BadSwt_Ptr
 22792                                  				;AN000; get "Invalid switch" message number
 22793 00002DCD E9D200                  	jmp	cerror		; Print error and chill out...
 22794                                  
 22795                                  	; 25/02/2023
 22796                                  	; MSDOS 3.3
 22797                                  	;mov	dx,BADPARMPTR
 22798                                  	;jmp	CERROR
 22799                                  
 22800                                  REALWORK:
 22801 00002DD0 FFD3                    	call	bx		; do some real work, at last
 22802                                  
 22803                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
 22804                                  ; otherwise, go get another command.
 22805                                  
 22806                                  CMD_DONE:
 22807 00002DD2 0E                      	push	cs		; g  restore data segment
 22808 00002DD3 1F                      	pop	ds		; g
 22809 00002DD4 1E                      	push	ds
 22810 00002DD5 8E1E[F39D]              	mov	ds,[RESSEG]	; g  save data segment
 22811                                  	;cmp	byte [Call_Flag],1
 22812                                  				; G  Is a call in progress?
 22813 00002DD9 803E[4E02]01            	cmp	byte [Call_Flag],call_in_progress
 22814 00002DDE C606[4E02]00            	mov	byte [Call_Flag],0
 22815                                  				; G  Either way, reset flag
 22816 00002DE3 1F                      	pop	ds		; g  get data segment back
 22817 00002DE4 7403                    	jz	short INCALL	; G
 22818 00002DE6 E91BD3                  	jmp	TCOMMAND	; chill out...
 22819                                  INCALL:
 22820                                  	;jmp	DOCOM1
 22821                                  	; 11/06/2023
 22822                                  	; Retro DOS v4.2 - MSDOS 6.22 COMMAND.COM
 22823 00002DE9 E907D5                  	jmp	DOCOM0
 22824                                  
 22825                                  ; =============== S U B	R O U T	I N E =======================================
 22826                                  
 22827                                  	; 25/02/2023
 22828                                  noswit:
 22829 00002DEC 57                      	push	di		; Save di
 22830 00002DED BF8100                  	mov	di,81h		; di = ptr to command args
 22831 00002DF0 BE8000                  	mov	si,80h		; Get address of length of command args
 22832 00002DF3 AC                      	lodsb			; Load length
 22833 00002DF4 88C1                    	mov	cl,al		; Move length to cl
 22834 00002DF6 30ED                    	xor	ch,ch		; Zero ch
 22835 00002DF8 2EA0[F79D]              	mov	al,[cs:SWITCHAR] ; al = switch character
 22836                                  	;cmp	al,0		; Turn off ZF
 22837                                  	; 25/02/2023
 22838 00002DFC 20C0                    	and	al,al
 22839 00002DFE F2AE                    	repne	scasb		; Scan for a switch character and return
 22840 00002E00 5F                      	pop	di		;  with ZF set if one was found
 22841 00002E01 C3                      	retn
 22842                                  
 22843                                  ; ---------------------------------------------------------------------------
 22844                                  
 22845                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 22846                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h
 22847                                  
 22848                                  EXTERNAL:
 22849 00002E02 E82602                  	call	test_append	; check to see if append installed
 22850 00002E05 7403                    	jz	short NOT_BARRYF
 22851                                  				; no - truly external command
 22852 00002E07 E9FCFE                  	jmp	APPEND_INTERNAL	; yes - go to Barryf code
 22853                                  
 22854                                  NOT_BARRYF:
 22855 00002E0A 2EC606[049E]00          	mov	byte [cs:FILTYP],0
 22856 00002E10 2E8A16[119E]            	mov	dl,[cs:SPECDRV]
 22857 00002E15 2E8816[AB9F]            	mov	[cs:IDLEN],dl
 22858 00002E1A 2EC606[A5A0]00          	mov	byte [cs:ROM_CALL],0
 22859 00002E20 52                      	push	dx
 22860 00002E21 BA[AB9F]                	mov	dx,IDLEN
 22861 00002E24 E8A6D6                  	call	ROM_SCAN
 22862 00002E27 5A                      	pop	dx
 22863                                  	;jnc	short POSTSAVE
 22864 00002E28 7305                    	jnc	short DO_SCAN
 22865 00002E2A 2EFE06[A5A0]            	inc	byte [cs:ROM_CALL]
 22866                                  	;jmp	short POSTSAVE
 22867                                  
 22868                                  	;nop
 22869                                  DO_SCAN:
 22870                                  POSTSAVE:
 22871 00002E2F BF[1B9D]                	mov	di,EXECPATH
 22872 00002E32 C60500                  	mov	byte [di],0	; Initialize to current directory
 22873                                  	
 22874 00002E35 2E803E[A5A0]00          	cmp	byte [cs:ROM_CALL],0
 22875                                  	;jz	short RESEARCH
 22876                                  	; 25/02/2023
 22877                                  	;jmp	short NEOEXECUTE
 22878 00002E3B 750F                    	jnz	short NEOEXECUTE	
 22879                                  
 22880                                  	;nop
 22881                                  RESEARCH:
 22882 00002E3D E87008                  	call	path_search	; find the mother (result in execpath)
 22883 00002E40 09C0                    	or	ax,ax		; did we find anything?
 22884                                  	;jz	short BADCOMJ45	; null means no (sob)
 22885                                  	; 25/02/2023
 22886 00002E42 7459                    	jz	short BADCOM
 22887 00002E44 83F804                  	cmp	ax,4		; 04H and 08H are .exe and .com
 22888                                  				; fuckin' sixteen-bit machine ought
 22889                                  	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
 22890                                  				; DISPLACEMENT!!
 22891                                  	;;jmp	short NEOEXECUTE
 22892                                  	;jmp	short EXECUTE	
 22893                                  	; 25/02/2023
 22894 00002E47 7D03                    	jnl	short EXECUTE ; jge
 22895                                  
 22896                                  	; 02H is .bat
 22897                                  
 22898                                  	;nop
 22899                                  BATCOMJ:
 22900 00002E49 E911DA                  	jmp	BATCOM
 22901                                  
 22902                                  	; 25/02/2023
 22903                                  ;BADCOMJ45:
 22904                                  	;jmp	short BADCOM
 22905                                  
 22906                                  	;nop
 22907                                  EXECUTE:
 22908                                  NEOEXECUTE:
 22909 00002E4C E87E02                  	call	IOSET
 22910                                  
 22911                                  ; MSDOS 6.0
 22912                                  ;M051
 22913                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
 22914                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
 22915                                  ;After a close, this would still leave one open active resulting in sharing
 22916                                  ;errors on subsequent opens of the redirected file.
 22917                                  
 22918                                  LH_EXECUTE:			;M051	
 22919 00002E4F 8E06[019E]              	mov	es,[TRAN_TPA]
 22920                                  	;mov	ah,DEALLOC ; 49h
 22921 00002E53 B449                    	mov	ah,49h
 22922 00002E55 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 22923                                  			; ES = segment address of area to be freed
 22924                                  				; Now running in "free" space
 22925 00002E57 8E06[F39D]              	mov	es,[RESSEG]
 22926 00002E5B 26FE06[3702]            	inc	byte [es:ExtCom] ; Indicate external command
 22927 00002E60 26C606[3F02]00          	mov	byte [es:RestDir],0 
 22928                                  				; Since USERDIR1 is in transient, insure
 22929                                  				; this flag value for re-entry to COMMAND
 22930                                  	; MSDOS 6.0
 22931 00002E66 BE[1B9D]                	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
 22932 00002E69 BF[0004]                	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
 22933                                  	;mov	cx,LENMSGORPATHBUF
 22934 00002E6C B95000                  	mov	cx,80
 22935 00002E6F FC                      	cld
 22936 00002E70 F3A4                    	rep	movsb		; copy program pathname to resident
 22937                                  
 22938                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22939 00002E72 BF5C00                  	mov	di,FCB ; 5Ch
 22940 00002E75 89FE                    	mov	si,di
 22941                                  	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
 22942 00002E77 B152                    	mov	cl,82 ; 25/02/2023
 22943 00002E79 F3A5                    	rep	movsw		; Transfer parameters to resident header
 22944                                  	
 22945                                  	; 25/02/2023
 22946                                  	;mov	dx,EXECPATH  ; MSDOS 3.3
 22947                                  	; MSDOS 6.0 (& 5.0)
 22948                                  	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
 22949 00002E7B BA[0004]                	mov	dx,SafePathBuffer
 22950 00002E7E 06                      	push	es
 22951 00002E7F 1F                      	pop	ds
 22952                                  
 22953                                  	;mov	bx,offset RESGROUP:EXEC_BLOCK
 22954 00002E80 BB[DC03]                	mov	bx,Exec_Block  ; = offset EnvirSeg
 22955                                  	;mov	ax,EXEC*256 ; 4B00h
 22956 00002E83 B8004B                  	mov	ax,4B00h
 22957                                  	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
 22958 00002E86 2EF606[A5A0]FF          	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
 22959 00002E8C 7403                    	jz	short OK_EXEC
 22960 00002E8E E9B5D6                  	jmp	ROM_EXEC
 22961                                  
 22962                                  OK_EXEC:
 22963                                  
 22964                                  ; we are now running in free space. Anything we do from here on may get
 22965                                  ; trashed. Move the stack (also in free space) to allocated space because
 22966                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
 22967                                  
 22968 00002E91 8CC1                    	mov	cx,es
 22969 00002E93 8ED1                    	mov	ss,cx
 22970 00002E95 BC[D404]                	mov	sp,RStack
 22971                                  	; MSDOS 3.3
 22972                                  	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
 22973                                  	; 25/02/2023
 22974                                  	; MSDOS 6.0
 22975 00002E98 2EFF2E[F99D]            	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident
 22976                                  
 22977                                  ; ---------------------------------------------------------------------------
 22978                                  
 22979                                  	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
 22980                                  BADCOM:
 22981 00002E9D 0E                      	push	cs
 22982 00002E9E 1F                      	pop	ds
 22983 00002E9F BA[F391]                	mov	dx,BADNAM_PTR
 22984                                  cerror:		
 22985 00002EA2 E86226                  	call	std_eprintf
 22986 00002EA5 E95CD2                  	jmp	TCOMMAND
 22987                                  
 22988                                  ; =============== S U B	R O U T	I N E =======================================
 22989                                  
 22990                                  ; Prescan converts the input buffer into a canonicalized form.
 22991                                  ; All redirections and pipes are removed.
 22992                                  
 22993                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22994                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h
 22995                                  
 22996                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 22997                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:2FFBh
 22998                                  
 22999                                  PRESCAN:
 23000 00002EA8 31C9                    	xor	cx,cx
 23001 00002EAA 8E06[F39D]              	mov	es,[RESSEG]
 23002 00002EAE BE[549C]                	mov	si,COMBUF+2
 23003 00002EB1 89F7                    	mov	di,si
 23004                                  COUNTQUOTES:
 23005 00002EB3 AC                      	lodsb			; get a byte
 23006 00002EB4 3C22                    	cmp	al,22h	; '"'	; is it a quote?
 23007 00002EB6 7504                    	jne	short COUNTEND	; no, try for end of road
 23008 00002EB8 FEC5                    	inc	ch		; bump count
 23009 00002EBA EBF7                    	jmp	short COUNTQUOTES
 23010                                  				; go get next char
 23011                                  COUNTEND:
 23012 00002EBC 3C0D                    	cmp	al,0Dh	; 13	; end of road?
 23013 00002EBE 75F3                    	jne	short COUNTQUOTES
 23014                                  				; no, go back for next char
 23015                                  	; 26/02/2023
 23016                                  	; MSDOS 5.0 (& 6.0)
 23017 00002EC0 51                      	push	cx		; save count
 23018 00002EC1 89FE                    	mov	si,di		; restore pointer to begining
 23019                                  KanjiScan:
 23020 00002EC3 AC                      	lodsb			; get a byte
 23021 00002EC4 E848FA                  	call	testkanj	; is it a leadin byte
 23022 00002EC7 740F                    	jz	short KanjiQuote
 23023                                  				; no, check for quotes
 23024 00002EC9 88C4                    	mov	ah,al		; save leadin
 23025 00002ECB AC                      	lodsb			; get trailing byte
 23026 00002ECC 3D2020                  	cmp	ax,2020h
 23027                                  	;cmp	ax,DB_SPACE	; is it Kanji space
 23028 00002ECF 75F2                    	jne	short KanjiScan	; no, go get next
 23029 00002ED1 C744FE2020              	mov	word [si-2],2020h
 23030                                  				; replace with spaces
 23031 00002ED6 EBEB                    	jmp	short KanjiScan	; go get next char
 23032                                  	
 23033                                  KanjiQuote:
 23034 00002ED8 3C22                    	cmp	al,22h	; '"'	; beginning of quoted string
 23035 00002EDA 750D                    	jne	short KanjiEnd	; no, check for end
 23036 00002EDC FECD                    	dec	ch		; drop count
 23037 00002EDE 74E3                    	jz	short KanjiScan	; if count is zero, no quoting
 23038                                  KanjiQuoteLoop:
 23039 00002EE0 AC                      	lodsb			; get next byte
 23040 00002EE1 3C22                    	cmp	al,22h	; '"'	; is it another quote
 23041 00002EE3 75FB                    	jne	short KanjiQuoteLoop
 23042                                  				; no, get another
 23043 00002EE5 FECD                    	dec	ch		; yes, drop count
 23044 00002EE7 EBDA                    	jmp	short KanjiScan	; go get next char
 23045                                  KanjiEnd:
 23046 00002EE9 3C0D                    	cmp	al,13 ; 0Dh	; end of line character?
 23047 00002EEB 75D6                    	jne	short KanjiScan	; go back to beginning
 23048 00002EED 59                      	pop	cx		; get back original count
 23049                                  	; 26/04/2023
 23050 00002EEE 89FE                    	mov	si,di		; restore pointer to beginning
 23051                                  	
 23052                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23053                                  PRESCANLP:
 23054 00002EF0 AC                      	lodsb
 23055                                  	; 26/02/2023
 23056 00002EF1 E81BFA                  	call	testkanj
 23057 00002EF4 740C                    	jz	short NOTKANJ6
 23058                                  	; MSDOS 6.0
 23059 00002EF6 8805                    	mov	[di],al
 23060 00002EF8 47                      	inc	di		; fake STOSB into DS
 23061 00002EF9 AC                      	lodsb			; grab second byte
 23062 00002EFA 8805                    	mov	[di],al		; fake stosb into DS
 23063 00002EFC FEC1                    	inc	cl
 23064 00002EFE FEC1                    	inc	cl
 23065 00002F00 EBEE                    	jmp	short PRESCANLP
 23066                                  
 23067                                  NOTKANJ6:
 23068                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23069 00002F02 3C22                    	cmp	al,'"'	; 22h	; " character
 23070 00002F04 7510                    	jne	short TRYGREATER
 23071 00002F06 FECD                    	dec	ch
 23072 00002F08 740C                    	jz	short TRYGREATER
 23073                                  QLOOP:
 23074 00002F0A 8805                    	mov	[di],al
 23075 00002F0C 47                      	inc	di
 23076 00002F0D FEC1                    	inc	cl
 23077 00002F0F AC                      	lodsb
 23078 00002F10 3C22                    	cmp	al,'"'		; " character
 23079 00002F12 75F6                    	jne	short QLOOP
 23080 00002F14 FECD                    	dec	ch
 23081                                  TRYGREATER:
 23082 00002F16 3C3E                    	cmp	al,'>' ; 3Eh
 23083                                  	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
 23084                                  	;;cmp	al,[RABRACKET]	; MSDOS 3.3
 23085 00002F18 7557                    	jne	short NOOUT
 23086                                  
 23087                                  ; We have found a ">" char. We need to see if there is another ">"
 23088                                  ; following it.
 23089                                  
 23090 00002F1A 3804                    	cmp	[si],al
 23091 00002F1C 7506                    	jne	short NOAPPND
 23092 00002F1E AC                      	lodsb
 23093 00002F1F 26FE06[6302]            	inc	byte [es:Re_Out_App] ; Flag >>
 23094                                  NOAPPND:
 23095                                  ; Now we attempt to find the file name. First, scan off all whitespace
 23096                                  
 23097 00002F24 E807FC                  	call	scanoff
 23098                                  
 23099                                  	; 26/02/2023
 23100                                  	; MSDOS 6.0
 23101 00002F27 3C3C                    	cmp	al,'<' ; 3Ch
 23102                                  	;cmp	al,labracket	;AN040; was there no filename?
 23103 00002F29 7404                    	je	short REOUT_ERRSET
 23104                                  				;AN040; yes - set up error
 23105                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23106 00002F2B 3C0D                    	cmp	al,0Dh
 23107 00002F2D 750D                    	jnz	short GOTREOFIL
 23108                                  
 23109                                  ; There was no file present. Set us up at end-of-line.
 23110                                  
 23111                                  REOUT_ERRSET:			;AN040; set up for an error
 23112 00002F2F C6050D                  	mov	byte [di],0Dh	; Clobber first ">"
 23113 00002F32 26C706[6402]0900        	mov	word [es:Re_OutStr],9
 23114                                  				; Cause an error later
 23115 00002F39 E9A900                  	jmp	PRESCANEND
 23116                                  
 23117                                  GOTREOFIL:
 23118 00002F3C 57                      	push	di
 23119                                  	;mov	di,offset RESGROUP:RE_OUTSTR
 23120 00002F3D BF[6402]                	mov	di,Re_OutStr
 23121 00002F40 89FB                    	mov	bx,di
 23122 00002F42 06                      	push	es
 23123                                  
 23124                                  	; 26/02/2023
 23125                                  	; MSDOS 6.0
 23126                                  SETREOUTSTR:			; Get the output redirection name
 23127                                  				; MSKK06 07/14/89
 23128 00002F43 51                      	push	cx		; save cx
 23129 00002F44 B94D00                  	mov	cx,64+13	; CX = max string length
 23130                                  SETREOUTSTR_LOOP:
 23131 00002F47 AC                      	lodsb
 23132 00002F48 3C0D                    	cmp	al,0Dh
 23133 00002F4A 741A                    	je	short GOTRESTR_J
 23134 00002F4C E8E7FB                  	call	DELIM
 23135 00002F4F 7415                    	jz	short GOTRESTR_J
 23136 00002F51 3A06[F79D]              	cmp	al,[SWITCHAR]
 23137 00002F55 740F                    	je	short GOTRESTR_J
 23138 00002F57 3C22                    	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
 23139 00002F59 7413                    	je	short PIPEERRSYNJ5_J
 23140                                  				;AN033; Yes - get out quick - or system crashes
 23141 00002F5B 3C3C                    	cmp	al,'<' ; 3Ch
 23142                                  	;cmp	al,labracket	;AN002; Is char for input redirection
 23143 00002F5D 7404                    	je	short ABRACKET_TERM
 23144                                  				;AN002; yes - end of string
 23145 00002F5F 3C3E                    	cmp	al,'>' ; 3Eh
 23146                                  	;cmp	al,rabracket	;AN002; Is char for output redirection
 23147 00002F61 7506                    	jne	short NO_ABRACKET
 23148                                  				;AN002; no - not end of string
 23149                                  ABRACKET_TERM:			;AN002; have end of string by < or >
 23150 00002F63 4E                      	dec	si		;AN002; back up over symbol
 23151 00002F64 B020                    	mov	al,20h ; BLANK	;AN002; show delimiter as char
 23152                                  GOTRESTR_J:
 23153 00002F66 59                      	pop	cx		; MSKK06 07/14/89
 23154 00002F67 EB58                    	jmp	short GOTRESTR	;AN002; go process it
 23155                                  NO_ABRACKET:			;AN002; NOT AT END OF STRING
 23156 00002F69 AA                      	stosb			; store it into resgroup
 23157 00002F6A E2DB                    	loop	SETREOUTSTR_LOOP
 23158                                  				; MSKK06 07/14/89
 23159 00002F6C EBF8                    	jmp	short GOTRESTR_J
 23160                                  PIPEERRSYNJ5_J:
 23161 00002F6E 59                      	pop	cx		; recover CX
 23162 00002F6F EB4B                    	jmp	short PIPEERRSYNJ5
 23163                                  
 23164                                  	; 26/02/2023
 23165                                  ;	; MSDOS 3.3
 23166                                  ;SETREOUTSTR_LOOP:		; Get the output redirection name
 23167                                  ;	lodsb
 23168                                  ;	cmp	al,0Dh
 23169                                  ;	jz	short GOTRESTR
 23170                                  ;	call	DELIM
 23171                                  ;	jz	short GOTRESTR
 23172                                  ;	cmp	al,[SWITCHAR]
 23173                                  ;	je	short GOTRESTR
 23174                                  ;	cmp	al,'"'
 23175                                  ;	jne	short NO_ABRACKET
 23176                                  ;	dec	ch
 23177                                  ;NO_ABRACKET:
 23178                                  ;	stosb
 23179                                  ;	jmp	short SETREOUTSTR_LOOP
 23180                                  
 23181                                  NOOUT:
 23182                                  	; 26/02/2023
 23183                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23184 00002F71 3C3C                    	cmp	al, '<' ; 3Ch
 23185                                  	;cmp	al,labracket	; MSDOS 6.0
 23186                                  	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
 23187 00002F73 7523                    	jne	short CHKPIPE
 23188 00002F75 89F3                    	mov	bx,si		; Save loc of "<"
 23189 00002F77 E8B4FB                  	call	scanoff
 23190                                  	; MSDOS 6.0
 23191 00002F7A 3C3E                    	cmp	al,'>' ; 3Eh
 23192                                  	;cmp	al,rabracket	;AN040; was there no filename?
 23193 00002F7C 7404                    	je	short REIN_ERRSET ;AN040; yes - set up error
 23194                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23195 00002F7E 3C0D                    	cmp	al,0Dh
 23196 00002F80 750B                    	jne	short GOTREIFIL
 23197                                  REIN_ERRSET:			;AN040; set up for error
 23198 00002F82 C6050D                  	mov	byte [di],0Dh	; Clobber "<"
 23199 00002F85 C706[9E9D]0900          	mov	word [RE_INSTR],9 
 23200                                  				; Cause an error later
 23201 00002F8B EB58                    	jmp	short PRESCANEND
 23202                                  GOTREIFIL:
 23203 00002F8D 57                      	push	di
 23204 00002F8E BF[9E9D]                	mov	di,RE_INSTR
 23205 00002F91 89FB                    	mov	bx,di
 23206 00002F93 06                      	push	es
 23207 00002F94 0E                      	push	cs
 23208 00002F95 07                      	pop	es		; store in TRANGROUP
 23209                                  	; 26/04/2023
 23210                                  	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
 23211 00002F96 EBAB                    	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
 23212                                  				; Get the input redirection name
 23213                                  CHKPIPE:
 23214 00002F98 88C4                    	mov	ah,al
 23215                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23216 00002F9A 80FC7C                  	cmp	ah,'|' ; 7Ch
 23217                                  	;cmp	ah,ALTPIPECHR ; 7Ch
 23218                                  	;je	short ISPIPE3
 23219                                  	;; MSDOS 6.0
 23220                                  	;cmp	ah,'|' ; 7Ch
 23221                                  	;;cmp	al,vbar ; 7Ch
 23222                                  	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
 23223 00002F9D 7539                    	jne	short CONTPRESCAN
 23224                                  ISPIPE3:
 23225                                  ; Only push the echo flag if we are entering the pipe for the first time.
 23226                                  
 23227 00002F9F 26803E[B502]00          	cmp	byte [es:PipeFlag],0
 23228 00002FA5 7505                    	jne	short NOECHOPUSH
 23229 00002FA7 26D026[3B02]            	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
 23230                                  NOECHOPUSH:
 23231 00002FAC 26FE06[B502]            	inc	byte [es:PipeFlag]
 23232 00002FB1 E87AFB                  	call	scanoff
 23233 00002FB4 3C0D                    	cmp	al,0Dh
 23234 00002FB6 7404                    	je	short PIPEERRSYNJ5
 23235                                  	; 26/02/2023
 23236 00002FB8 3C7C                    	cmp	al,'|' ; 7Ch
 23237                                  	;cmp	al,ALTPIPECHR ; 7Ch
 23238                                  	;je	short PIPEERRSYNJ5
 23239                                  	;; MSDOS 6.0
 23240                                  	;cmp	al,'|' ; 7Ch
 23241                                  	;;cmp	al,vbar ; 7Ch
 23242                                  	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
 23243 00002FBA 751C                    	jne	short CONTPRESCAN
 23244                                  
 23245                                  PIPEERRSYNJ5:
 23246 00002FBC 06                      	push	es
 23247 00002FBD 1F                      	pop	ds
 23248 00002FBE E99C02                  	jmp	PIPEERRSYN
 23249                                  
 23250                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
 23251                                  ; than just a : in the redir string.
 23252                                  
 23253                                  GOTRESTR:
 23254 00002FC1 86E0                    	xchg	ah,al
 23255 00002FC3 B03A                    	mov	al,':' ; 3Ah
 23256 00002FC5 29FB                    	sub	bx,di		; compute negative of number of chars
 23257 00002FC7 83FBFF                  	cmp	bx,-1		; is there just a :?
 23258 00002FCA 7407                    	je	short NOTRAILCOL ; yep, don't change
 23259 00002FCC 263845FF                	cmp	[es:di-1],al	; Trailing ':' OK on devices
 23260 00002FD0 7501                    	jne	short NOTRAILCOL
 23261 00002FD2 4F                      	dec	di		; Back up over trailing ':'
 23262                                  NOTRAILCOL:
 23263 00002FD3 30C0                    	xor	al,al
 23264 00002FD5 AA                      	stosb			; NUL terminate the string
 23265 00002FD6 07                      	pop	es
 23266 00002FD7 5F                      	pop	di		; Remember the start
 23267                                  CONTPRESCAN:
 23268 00002FD8 8825                    	mov	[di],ah		; "delete" the redirection string
 23269 00002FDA 47                      	inc	di
 23270 00002FDB 80FC0D                  	cmp	ah,0Dh
 23271 00002FDE 7405                    	je	short PRESCANEND
 23272 00002FE0 FEC1                    	inc	cl
 23273 00002FE2 E90BFF                  	jmp	PRESCANLP
 23274                                  PRESCANEND:
 23275 00002FE5 26803E[B502]00          	cmp	byte [es:PipeFlag],0
 23276 00002FEB 7414                    	jz	short ISNOPIPE
 23277                                  
 23278                                  	; 11/06/2023
 23279                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:314Ah
 23280                                  	;mov	di,48Ah		; PipeStr ; RESGROUP:EndInit+160
 23281                                  	;mov	[es:488h],di	; [es:PipePtr],di
 23282                                  				; (RESGROUP:EndInit+158)
 23283                                  	; 26/02/2023
 23284                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
 23285                                  	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
 23286                                  	;;			; (EndInit+160]
 23287                                  	;mov	di,offset RESGROUP:PIPESTR
 23288 00002FED BF[5703]                	mov	di,PipeStr	; RESGROUP:EndInit+160
 23289                                  
 23290                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
 23291                                  	;;mov	[es:3BEh],di	; [es:EndInit+158]
 23292 00002FF0 26893E[5503]            	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
 23293                                  	
 23294 00002FF5 BE[549C]                	mov	si,COMBUF+2
 23295 00002FF8 E833FB                  	call	scanoff
 23296                                  PIPESETLP:			; Transfer the pipe into the resident
 23297 00002FFB AC                      	lodsb			; pipe buffer
 23298 00002FFC AA                      	stosb
 23299 00002FFD 3C0D                    	cmp	al,0Dh
 23300 00002FFF 75FA                    	jnz	short PIPESETLP
 23301                                  ISNOPIPE:
 23302 00003001 880E[539C]              	mov	[COMBUF+1],cl
 23303 00003005 26803E[B502]00          	cmp	byte [es:PipeFlag],0
 23304 0000300B 0E                      	push	cs
 23305 0000300C 07                      	pop	es
 23306 0000300D C3                      	retn
 23307                                  
 23308                                  ; =============== S U B	R O U T	I N E =======================================
 23309                                  
 23310                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23311                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
 23312                                  cmd_copy:
 23313 0000300E BE[549C]                	mov	si,COMBUF+2
 23314 00003011 E81AFB                  	call	scanoff		; advance past separators...
 23315 00003014 0336[80A0]              	add	si,[PathPos]
 23316 00003018 BF8100                  	mov	di,81h
 23317 0000301B 31C9                    	xor	cx,cx
 23318                                  cmdcopy:
 23319 0000301D AC                      	lodsb
 23320 0000301E AA                      	stosb
 23321 0000301F 3C0D                    	cmp	al,0Dh
 23322 00003021 7403                    	je	short copy_done
 23323 00003023 41                      	inc	cx
 23324 00003024 EBF7                    	jmp	short cmdcopy
 23325                                  copy_done:
 23326 00003026 880E8000                	mov	[80h],cl
 23327 0000302A C3                      	retn
 23328                                  
 23329                                  ; =============== S U B	R O U T	I N E =======================================
 23330                                  
 23331                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23332                                  test_append:
 23333 0000302B BB[529C]                	mov	bx,COMBUF	; barry can address
 23334 0000302E BE[AB9F]                	mov	si,IDLEN	; address command name, DS already set 	
 23335 00003031 BAFFFF                  	mov	dx,-1
 23336 00003034 B800AE                  	mov	ax,0AE00h
 23337 00003037 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
 23338                                  			; - INSTALLABLE	COMMAND	- INSTALL CHECK
 23339                                  			; DX = FFFFh,[BX -> command line
 23340                                  			; Return: AL = FFh if this command is a TSR extension 
 23341                                  			;		   to COMMAND.COM
 23342                                  			; AL = 00h if the command should be executed as	usual
 23343                                  	;cmp	al,0
 23344 00003039 08C0                    	or	al,al ; 25/02/2023
 23345 0000303B C3                      	retn
 23346                                  
 23347                                  	; 25/02/2023
 23348                                  	; INT 2Fh
 23349                                  	; 	AX = AE00h
 23350                                  	; entry:
 23351                                  	; 	DX = magic value FFFFh
 23352                                  	; 	CH = FFh
 23353                                  	; 	CL = length of command line tail
 23354                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 23355                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 23356                                  	; return:
 23357                                  	;	AL = FFh if this command is a TSR extension to COMMAND.COM
 23358                                  	;	AL = 00h if the command should be executed as usual
 23359                                  	;
 23360                                  	; Format of COMMAND.COM command line buffer:
 23361                                  	;	Offset  Size    Description
 23362                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 23363                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 23364                                  	;	N BYTEs command line text, terminated by 0Dh
 23365                                  	;
 23366                                  	; Format of command name buffer:
 23367                                  	;	Offset  Size    Description
 23368                                  	;	00h     BYTE    length of command name
 23369                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 23370                                  
 23371                                  ;============================================================================
 23372                                  ; TMISC2.ASM, MSDOS 6.0, 1991
 23373                                  ;============================================================================
 23374                                  ; 05/10/2018 - Retro DOS v3.0
 23375                                  
 23376                                  ;	More misc routines
 23377                                  
 23378                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
 23379                                  
 23380                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23381                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh
 23382                                  
 23383                                  ; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23384                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3199h
 23385                                  
 23386                                  ; =============== S U B	R O U T	I N E =======================================
 23387                                  
 23388                                  SETPATH:
 23389                                  
 23390                                  ; ENTRY PathPos = ptr to string
 23391                                  ;       PathCnt = length of string
 23392                                  ;
 23393                                  ; EXIT  PathPos = ptr to string after pathname
 23394                                  ;       PathCnt = length of rest of string
 23395                                  ;       DX = ptr to pathname in string, made ASCIIZ
 23396                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
 23397                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
 23398                                  ;
 23399                                  ;       A null character is dropped at the end of the pathname. If the
 23400                                  ;       character in that spot previously was CR, it is copied into the
 23401                                  ;       following byte. So there must be at least two two character 
 23402                                  ;       positions in the buffer following the pathname.
 23403                                  
 23404                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23405                                  	
 23406                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23407                                  	; MSDOS 6.0
 23408                                  	;mov	ax,[PathCnt]	;AC000; get length of string
 23409                                  	;mov	si,[PathPos]	;AC000; get start of source buffer
 23410                                  
 23411                                  	; 26/02/2023
 23412                                  	; MSDOS 3.3
 23413                                  	;mov	si,80h
 23414                                  	;lodsb
 23415                                  	;xor	ah,ah
 23416                                  	;mov	[PATCNT],ax
 23417                                  	;mov	[PATHPOS],si
 23418                                  GETPATH:
 23419                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23420 0000303C C606[AEA0]00            	mov	byte [DestInfo],0
 23421 00003041 C606[AAA0]00            	mov	byte [DestIsDir],0
 23422 00003046 8B36[80A0]              	mov	si,[PathPos]	; SI = ptr to string
 23423 0000304A 8B0E[7EA0]              	mov	cx,[PathCnt]	; CX = string length
 23424 0000304E 89F2                    	mov	dx,si		; DX = ptr to string
 23425 00003050 E34D                    	jcxz	PATHDONE	; string length is zero, we're done
 23426 00003052 51                      	push	cx		; save string length
 23427 00003053 56                      	push	si		; save ptr to string
 23428 00003054 E875FC                  	call	SWITCH
 23429                                  
 23430                                  ;       After Switch, SI has been scanned past any switches, and
 23431                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
 23432                                  
 23433 00003057 A3[82A0]                	mov	[PathSw],ax	; PathSw = switch occurrence mask
 23434 0000305A 5B                      	pop	bx		; BX = ptr to original string
 23435 0000305B 29F3                    	sub	bx,si		; BX = -(# chars scanned by Switch)
 23436 0000305D 59                      	pop	cx		; CX = string length
 23437 0000305E 01D9                    	add	cx,bx		; CX = string length from current SI
 23438 00003060 89F2                    	mov	dx,si		; DX = ptr to current string
 23439                                  SKIPPATH:
 23440                                  	; 26/02/2023
 23441                                  	; MSDOS 6.0
 23442 00003062 C606[40A2]00            	mov	byte [KPARSE],0
 23443                                  SKIPPATH2:
 23444 00003067 E336                    	jcxz	PATHDONE	; string length is zero, we're done
 23445 00003069 49                      	dec	cx		; CX = length left after next char
 23446 0000306A AC                      	lodsb			; AL = next char of string
 23447                                  				; SI = ptr to char after this one
 23448                                  	; 26/02/2023
 23449 0000306B E8A1F8                  	call	testkanj
 23450 0000306E 7408                    	jz	short TESTPPSEP
 23451 00003070 49                      	dec	cx
 23452 00003071 46                      	inc	si
 23453 00003072 FE06[40A2]              	inc	byte [KPARSE]
 23454 00003076 EBEF                    	jmp	short SKIPPATH2
 23455                                  TESTPPSEP:
 23456 00003078 E841FB                  	call	pathchrcmp	; compare AL to path delimiter char
 23457 0000307B 7504                    	jnz	short TESTPMETA	; it's not a path delim
 23458 0000307D FE06[AAA0]              	inc	byte [DestIsDir]
 23459                                  				; DestIsDir = 1, signalling path char
 23460                                  TESTPMETA:
 23461 00003081 3C3F                    	cmp	al,'?'
 23462 00003083 7505                    	jne	short TESTPSTAR	; char is not '?'
 23463 00003085 800E[AEA0]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 23464                                  TESTPSTAR:
 23465 0000308A 3C2A                    	cmp	al,'*'
 23466                                  	;cmp	al,[STAR] ; MSDOS 3.3	
 23467 0000308C 7505                    	jne	short TESTPDELIM ; char is not '*'
 23468 0000308E 800E[AEA0]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 23469                                  TESTPDELIM:
 23470 00003093 E8A0FA                  	call	DELIM		; compare AL to all delimiters
 23471 00003096 7406                    	jz	short PATHDONEDEC ; delimiter found, back up & leave
 23472 00003098 3A06[F79D]              	cmp	al,[SWITCHAR]
 23473 0000309C 75C4                    	jne	short SKIPPATH	; char isn't switch, go get next char
 23474                                  PATHDONEDEC:
 23475 0000309E 4E                      	dec	si		; SI = ptr to char after pathname
 23476                                  PATHDONE:
 23477 0000309F 30C0                    	xor	al,al		; AL = NULL
 23478 000030A1 8604                    	xchg	al,[si]		; place NULL after pathname
 23479 000030A3 46                      	inc	si		; SI = ptr to byte after NULL
 23480 000030A4 3C0D                    	cmp	al,0Dh		; were we at end of line?
 23481 000030A6 7502                    	jne	short NOPSTORE	; not EOL, finish up
 23482 000030A8 8804                    	mov	[si],al		; save EOL after NULL
 23483                                  NOPSTORE:
 23484 000030AA 8936[80A0]              	mov	[PathPos],si	; PathPos = ptr to char after NULL
 23485 000030AE 890E[7EA0]              	mov	[PathCnt],cx	; PathCnt = length of string left
 23486                                  SETPATH_RETN:
 23487 000030B2 C3                      	retn
 23488                                  
 23489                                  ; ---------------------------------------------------------------------------
 23490                                  
 23491                                  PGETARG:
 23492 000030B3 BE8000                  	mov	si,80h
 23493 000030B6 AC                      	lodsb
 23494 000030B7 08C0                    	or	al,al
 23495 000030B9 74F7                    	jz	short SETPATH_RETN
 23496 000030BB E80300                  	call	PSCANOFF
 23497 000030BE 3C0D                    	cmp	al,0Dh
 23498 000030C0 C3                      	retn
 23499                                  
 23500                                  ; ---------------------------------------------------------------------------
 23501                                  
 23502                                  PSCANOFF:
 23503 000030C1 AC                      	lodsb
 23504 000030C2 E871FA                  	call	DELIM
 23505 000030C5 7504                    	jnz	short PSCANOFFD
 23506 000030C7 3C3B                    	cmp	al,';' ; 3Bh
 23507 000030C9 75F6                    	jne	short PSCANOFF	; ';' is not a delimiter
 23508                                  PSCANOFFD:
 23509 000030CB 4E                      	dec	si		; Point to first non-delimiter
 23510 000030CC C3                      	retn
 23511                                  
 23512                                  ; =============== S U B	R O U T	I N E =======================================
 23513                                  
 23514                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23515                                  IOSET:
 23516                                  	; ALL REGISTERS PRESERVED
 23517 000030CD 1E                      	push	ds
 23518 000030CE 52                      	push	dx
 23519 000030CF 50                      	push	ax
 23520 000030D0 53                      	push	bx
 23521 000030D1 51                      	push	cx
 23522 000030D2 2E8E1E[F39D]            	mov	ds,[cs:RESSEG]
 23523 000030D7 803E[B502]00            	cmp	byte [PipeFlag],0
 23524 000030DC 750D                    	jne	short NOREDIR
 23525 000030DE F606[4802]FF            	test	byte [IfFlag],0FFh
 23526 000030E3 7506                    	jnz	short NOREDIR
 23527 000030E5 E88C00                  	call	TESTDOREIN
 23528 000030E8 E80600                  	call	TESTDOREOUT
 23529                                  NOREDIR:
 23530 000030EB 59                      	pop	cx
 23531 000030EC 5B                      	pop	bx
 23532 000030ED 58                      	pop	ax
 23533 000030EE 5A                      	pop	dx
 23534 000030EF 1F                      	pop	ds
 23535                                  IOSET_RETN:	; 06/08/2024
 23536 000030F0 C3                      	retn
 23537                                  
 23538                                  ; =============== S U B	R O U T	I N E =======================================
 23539                                  
 23540                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23541                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
 23542                                  	; 06/08/2024
 23543                                  TESTDOREOUT:
 23544 000030F1 803E[6402]00            	cmp	byte [Re_OutStr],0
 23545                                  	;je	short NOREOUT  ; MSDOS 3.3
 23546                                  	; 26/02/2023
 23547                                  	;jne	short REOUTEXISTS
 23548                                  	;jmp	NOREOUT
 23549                                  	; 06/08/2024
 23550 000030F6 74F8                    	jz	short IOSET_RETN
 23551                                  REOUTEXISTS:
 23552 000030F8 803E[6302]00            	cmp	byte [Re_Out_App],0
 23553 000030FD 745D                    	je	short REOUTCRT
 23554                                  
 23555 000030FF BA[6402]                	mov	dx,Re_OutStr
 23556                                  
 23557                                  	; 26/02/2023
 23558                                  	; MSDOS 6.0
 23559                                  	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
 23560 00003102 B8023D                  	mov	ax,3D02h
 23561                                  	; MSDOS 3.3
 23562                                  	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
 23563                                  
 23564                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23565 00003105 50                      	push	ax
 23566 00003106 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23567                                  			; DS:DX	-> ASCIZ filename
 23568                                  			; AL = access mode
 23569                                  			; 1 - write
 23570 00003108 5B                      	pop	bx
 23571 00003109 724B                    	jc	short OpenWriteError
 23572                                  
 23573                                  	; 26/02/2023
 23574                                  	; MSDOS 6.0
 23575 0000310B 89C3                    	mov	bx,ax
 23576                                  	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
 23577 0000310D B80044                  	mov	ax,4400h
 23578 00003110 CD21                    	int	21h			;AN035;
 23579                                  			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 23580                                  			; BX = file or device handle
 23581 00003112 F6C280                  	test	dl,80h
 23582                                  	;test	dl,devid_ISDEV		;AN035; Is it a device?
 23583 00003115 7554                    	jnz	short SET_REOUT		;AN035; Yes, don't read from it
 23584                                  	
 23585                                  	;mov	ax,(LSEEK SHL 8) OR 2
 23586 00003117 B80242                  	mov	ax,4202h
 23587 0000311A B9FFFF                  	mov	cx,-1			;AC011; MOVE TO EOF -1
 23588 0000311D 89CA                    	mov	dx,cx			;AC011;
 23589 0000311F CD21                    	int	21h
 23590                                  			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 23591                                  			; AL = method: offset from end of file
 23592 00003121 0E                      	push	cs			;AN011; Get transient seg to DS
 23593 00003122 1F                      	pop	ds			;AN011;
 23594                                  
 23595                                  	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
 23596 00003123 B8003F                  	mov	ax,3F00h
 23597 00003126 B90100                  	mov	cx,1			;AN011;  file into one_char_val
 23598 00003129 BA[A2A0]                	mov	dx,One_Char_Val		;AN011;
 23599 0000312C CD21                    	int	21h			;AN011;
 23600                                  			; DOS - 2+ - READ FROM FILE WITH HANDLE
 23601                                  			; BX = file handle, CX = number of bytes to read
 23602                                  			; DS:DX -> buffer
 23603 0000312E 7226                    	jc	short OpenWriteError	;AN011; If error, exit
 23604 00003130 39C8                    	cmp	ax,cx			;AN017; Did we read 1 byte?
 23605 00003132 7517                    	jnz	short reout_0_length	;AN017; No - file must be 0 length
 23606                                  
 23607 00003134 803E[A2A0]1A            	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
 23608 00003139 8E1E[F39D]              	mov	ds,[RESSEG]		;AN011; Get resident segment back
 23609 0000313D 752C                    	jne	short SET_REOUT		;AN011; No, just continue
 23610                                  
 23611                                  	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
 23612 0000313F B80142                  	mov	ax,4201h
 23613 00003142 B9FFFF                  	mov	cx,-1			;AN011; LSEEK back one byte
 23614                                  setreout_p:	; 26/02/2023
 23615 00003145 89CA                    	mov	dx,cx			;AN011;
 23616 00003147 CD21                    	int	21h			;AN011;
 23617 00003149 EB20                    	jmp	short SET_REOUT
 23618                                  reout_0_length: 			;AN017; We have a 0 length file
 23619                                  	; ds = cs ; 26/02/2023
 23620                                  	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
 23621                                  					;AN017; Get resident segment back
 23622                                  	; 26/02/2023
 23623 0000314B 8E1E[F39D]              	mov	ds,[RESSEG]
 23624                                  	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
 23625 0000314F B80042                  	mov	ax,4200h
 23626 00003152 31C9                    	xor	cx,cx			;AN017; Offset is 0
 23627                                  	;mov	dx,cx			;AN017;
 23628                                  	;int	21h			;AN017;
 23629                                  	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
 23630                                  	; 26/02/2023
 23631 00003154 EBEF                    	jmp	short setreout_p
 23632                                  
 23633                                  	; 26/02/2023
 23634                                  	; MSDOS 3.3
 23635                                  	;xor	dx,dx
 23636                                  	;xor	cx,cx
 23637                                  	;mov	bx,ax
 23638                                  	;mov	ax,(LSEEK<<8)|2 ; 4202h
 23639                                  	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 23640                                  	;		; AL = method: offset from end of file
 23641                                  	;jmp	short SET_REOUT
 23642                                  
 23643                                  	; MSDOS 3.3 (& MSDOS 6.0)
 23644                                  OpenWriteError:
 23645                                  	;cmp	ax,5
 23646 00003156 83F805                  	cmp	ax,ERROR_ACCESS_DENIED
 23647 00003159 F9                      	stc
 23648                                  	;;je	short REDIRERR ; MSDOS 3.3
 23649                                  	; 26/02/2023
 23650                                  	;jnz	short REOUTCRT
 23651                                  	;jmp	REDIRERR
 23652 0000315A 743B                    	je	short REDIRERR
 23653                                  
 23654                                  REOUTCRT:
 23655 0000315C BA[6402]                	mov	dx,Re_OutStr
 23656 0000315F 31C9                    	xor	cx,cx
 23657                                  	;mov	ah,CREAT ; 3Ch
 23658 00003161 B43C                    	mov	ah,3Ch
 23659 00003163 50                      	push	ax
 23660 00003164 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 23661                                  			; CX = attributes for file
 23662                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 23663 00003166 5B                      	pop	bx
 23664                                  	;jc	short REDIRERR ; MSDOS 3.3
 23665                                  	; 26/02/2023
 23666                                  	;jnc	short NOREDIRERR
 23667                                  	;jmp	REDIRERR
 23668 00003167 722E                    	jc	short REDIRERR
 23669                                  
 23670                                  NOREDIRERR:
 23671 00003169 89C3                    	mov	bx,ax
 23672                                  SET_REOUT:
 23673                                  
 23674                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
 23675                                  ; spot. We invalidate the new JFN we got.
 23676                                  
 23677 0000316B B0FF                    	mov	al,0FFh
 23678                                  	;xchg	al,[bx+18h]
 23679 0000316D 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23680 00003170 A21900                  	mov	[PDB.JFN_TABLE+1],al
 23681                                  	; 06/08/2024
 23682                                  NOREOUT:
 23683                                  ;IOSET_RETN:	; 17/04/2023
 23684 00003173 C3                      	retn
 23685                                  
 23686                                  ; =============== S U B	R O U T	I N E =======================================
 23687                                  
 23688                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23689                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 23690                                  	; 06/08/2024
 23691                                  TESTDOREIN:
 23692 00003174 2E803E[9E9D]00          	cmp	byte [cs:RE_INSTR],0
 23693                                  	;jz	short IOSET_RETN
 23694                                  	; 06/08/2024
 23695 0000317A 74F7                    	jz	short NOREOUT
 23696 0000317C 1E                      	push	ds
 23697 0000317D 0E                      	push	cs
 23698 0000317E 1F                      	pop	ds
 23699 0000317F BA[9E9D]                	mov	dx,RE_INSTR
 23700                                  	;mov	ax,OPEN*256 ; 3D00h
 23701 00003182 B8003D                  	mov	ax,3D00h
 23702 00003185 89C3                    	mov	bx,ax
 23703 00003187 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 23704                                  			; DS:DX	-> ASCIZ filename
 23705                                  			; AL = access mode
 23706                                  			; 0 - read
 23707 00003189 1F                      	pop	ds
 23708                                  
 23709 0000318A 720B                    	jc	short REDIRERR
 23710                                  
 23711 0000318C 89C3                    	mov	bx,ax
 23712 0000318E B0FF                    	mov	al,0FFh
 23713                                  
 23714                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
 23715                                  ; spot. We invalidate the new JFN we got.
 23716                                  
 23717                                  	;xchg	al,[bx+18h]
 23718 00003190 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23719 00003193 A21800                  	mov	[PDB.JFN_TABLE],al
 23720 00003196 C3                      	retn
 23721                                  
 23722                                  ; ---------------------------------------------------------------------------
 23723                                  
 23724                                  ; We had some kind of error on the redirection. Figure out what the
 23725                                  ; appropriate message should be; BX has the system call that failed
 23726                                  
 23727                                  REDIRERR:
 23728 00003197 0E                      	push	cs
 23729 00003198 1F                      	pop	ds
 23730 00003199 E82E00                  	call	TriageError  ; MSDOS 6.0
 23731                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 23732                                  
 23733                                  ; At this point, we have recognized the network-generated access denied error.
 23734                                  ; The correct message is in DX
 23735                                  
 23736 0000319C 83F841                  	cmp	ax,65
 23737 0000319F 7408                    	je	short _CERRORJ	;AC000; just issue message returned
 23738 000031A1 80FF3D                  	cmp	bh,OPEN ; 3Dh
 23739 000031A4 7406                    	je	short OpenError
 23740 000031A6 BA[EA91]                	mov	dx,FULLDIR_PTR
 23741                                  _CERRORJ:
 23742 000031A9 E9F6FC                  	jmp	cerror
 23743                                  
 23744                                  OpenError:
 23745                                  ; The system call was an OPEN. Report either file not found or path not found.
 23746                                  
 23747                                  	; 26/02/2023
 23748                                  	; MSDOS 6.0
 23749                                  	;mov	byte [cs:msg_disp_class],1
 23750 000031AC 2EC606[CE91]01          	mov	byte [cs:msg_disp_class],ext_msg_class
 23751                                  				;AN000; set up extended error msg class
 23752 000031B2 BA[D091]                	mov	dx,extend_buf_ptr
 23753                                  				;AC000; get extended message pointer
 23754 000031B5 2EA3[D091]              	mov	[cs:extend_buf_ptr],ax
 23755                                  				;AN000; get message number in control block
 23756 000031B9 E9E6FC                  	jmp	cerror
 23757                                  
 23758                                  	; 26/02/2023
 23759                                  	; MSDOS 3.3
 23760                                  	;mov	dx,FNOTFOUNDPTR
 23761                                  	;;cmp	ax,2
 23762                                  	;cmp	ax,ERROR_FILE_NOT_FOUND
 23763                                  	;je	short _CERRORJ
 23764                                  	;mov	dx,ACCDENPTR
 23765                                  	;;cmp	ax,5 ; Access denied error
 23766                                  	;cmp	ax,ERROR_ACCESS_DENIED
 23767                                  	;je	short _CERRORJ
 23768                                  	;	; ERROR_PATH_NOT_FOUND
 23769                                  	;mov	dx,PNOTFOUNDPTR
 23770                                  	;jmp	CERROR
 23771                                  
 23772                                  ; =============== S U B	R O U T	I N E =======================================
 23773                                  
 23774                                  ; Compute length of string (including NUL) in DS:SI into CX. Change no other
 23775                                  ; registers
 23776                                  
 23777                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 23778                                  dstrlen:
 23779 000031BC 50                      	push	ax
 23780 000031BD 31C9                    	xor	cx,cx
 23781 000031BF FC                      	cld
 23782                                  dloop:
 23783 000031C0 AC                      	lodsb
 23784 000031C1 41                      	inc	cx
 23785 000031C2 08C0                    	or	al,al
 23786 000031C4 75FA                    	jnz	short dloop
 23787 000031C6 29CE                    	sub	si,cx
 23788 000031C8 58                      	pop	ax
 23789                                  TRIAGEERR_RETN:
 23790 000031C9 C3                      	retn
 23791                                  
 23792                                  ; =============== S U B	R O U T	I N E =======================================
 23793                                  
 23794                                  ;Break	<Extended error support>
 23795                                  
 23796                                  TriageError:  ; MSDOS 6.0
 23797                                  
 23798                                  ; TriageError will examine the return from a carry-set system call and
 23799                                  ; return the correct error if applicable.
 23800                                  ;
 23801                                  ;   Inputs:	outputs from a carry-settable system call
 23802                                  ;		No system calls may be done in the interrim
 23803                                  ;   Outputs:	If carry was set on input
 23804                                  ;		   carry set on output
 23805                                  ;		   DX contains trangroup offset to printf message
 23806                                  ;		else
 23807                                  ;		   No registers changed
 23808                                  
 23809                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
 23810                                  
 23811                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23812                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h
 23813                                  
 23814                                  ; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23815                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 333Ch
 23816                                  
 23817                                  GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
 23818 000031CA 73FD                    	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
 23819 000031CC 9C                      	pushf
 23820 000031CD 53                      	push	bx
 23821 000031CE 51                      	push	cx
 23822 000031CF 56                      	push	si
 23823 000031D0 57                      	push	di
 23824 000031D1 55                      	push	bp
 23825 000031D2 06                      	push	es
 23826 000031D3 1E                      	push	ds
 23827 000031D4 50                      	push	ax
 23828 000031D5 52                      	push	dx
 23829 000031D6 B459                    	mov	ah,59h
 23830                                  	;mov	ah,GETEXTENDEDERROR
 23831 000031D8 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 23832                                  			; BX = version code (0000h for DOS 3.x)
 23833 000031DA 59                      	pop	cx
 23834 000031DB 5B                      	pop	bx		; restore original AX
 23835 000031DC BA[F691]                	mov	dx,ACCDEN_PTR
 23836 000031DF 83F841                  	cmp	ax,65		; network access denied?
 23837 000031E2 7404                    	je	short NoMove	; Yes, return it.
 23838 000031E4 89D8                    	mov	ax,bx
 23839 000031E6 89CA                    	mov	dx,cx
 23840                                  NoMove:
 23841 000031E8 1F                      	pop	ds
 23842 000031E9 07                      	pop	es
 23843 000031EA 5D                      	pop	bp
 23844 000031EB 5F                      	pop	di
 23845 000031EC 5E                      	pop	si
 23846 000031ED 59                      	pop	cx
 23847 000031EE 5B                      	pop	bx
 23848 000031EF 9D                      	popf
 23849 000031F0 C3                      	retn
 23850                                  
 23851                                  ; =============== S U B	R O U T	I N E =======================================
 23852                                  
 23853                                  	; Far call from resident portion/segment of COMMAND.COM
 23854                                  
 23855                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
 23856                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h
 23857                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3363h
 23858                                  
 23859                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23860                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23861                                  Triage_Init:
 23862 000031F1 E8D6FF                  	call	TriageError	 ; MSDOS 6.0
 23863                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 23864 000031F4 CB                      	retf
 23865                                  
 23866                                  ; =============== S U B	R O U T	I N E =======================================
 23867                                  
 23868                                  ; MSDOS 6.0
 23869                                  
 23870                                  ; ****************************************************************
 23871                                  ; *
 23872                                  ; * ROUTINE:	 MOVE_TO_SRCBUF
 23873                                  ; *
 23874                                  ; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
 23875                                  ; *		 terminating 0 to 0dH.	Set PATHCNT to length of
 23876                                  ; *		 string.  Set PATHPOS to start of SRCBUF.
 23877                                  ; *
 23878                                  ; * INPUT:	 DS:SI points to ASCIIZ string
 23879                                  ; *		 ES    points to TRANGROUP
 23880                                  ; *
 23881                                  ; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
 23882                                  ; *		 PATHCNT set to length of string
 23883                                  ; *		 PATHPOS set to start of SRCBUF
 23884                                  ; *		 CX,AX	 changed
 23885                                  ; *
 23886                                  ; ****************************************************************
 23887                                  
 23888                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23889                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 23890                                  Move_To_SrcBuf:
 23891 000031F5 56                      	push	si			;AN000;  save si,di
 23892 000031F6 57                      	push	di			;AN000;
 23893 000031F7 51                      	push	cx			;AN000;
 23894 000031F8 BF[12A1]                	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
 23895 000031FB 31C9                    	xor	cx,cx			;AN000; clear cx for counint
 23896 000031FD 89C8                    	mov	ax,cx			;AN000; clear ax
 23897 000031FF 57                      	push	di			;AN000; save start of srcbuf
 23898 00003200 AC                      	lodsb				;AN000; get a character from DS:SI
 23899                                  mts_get_chars:				;AN000;
 23900                                  	;cmp	al,0			;AN000; was it a null char?
 23901 00003201 20C0                    	and 	al,al ; al = 0 ?
 23902 00003203 7405                    	jz	short mts_end_string	;AN000; yes - exit
 23903 00003205 AA                      	stosb				;AN000; no - store it in srcbuf
 23904 00003206 41                      	inc	cx			;AN000; increment length count
 23905 00003207 AC                      	lodsb				;AN000; get a character from DS:SI
 23906 00003208 EBF7                    	jmp	short mts_get_chars	;AN000; go check it
 23907                                  mts_end_string: 			;AN000; we've reached the end of line
 23908                                  	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
 23909 0000320A B00D                    	mov	al,0Dh
 23910 0000320C AA                      	stosb				;AN000;
 23911 0000320D 5F                      	pop	di			;AN000; restore start of srcbuf
 23912 0000320E 0E                      	push	cs			;AN000; set DS to local segment
 23913 0000320F 1F                      	pop	ds			;AN000;
 23914 00003210 890E[7EA0]              	mov	[PathCnt],cx		;AN000; set patchcnt to length count
 23915 00003214 893E[80A0]              	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
 23916 00003218 59                      	pop	cx			;AN000; restore cx,di,si
 23917 00003219 5F                      	pop	di			;AN000;
 23918 0000321A 5E                      	pop	si			;AN000;
 23919 0000321B C3                      	retn				;AN000; exit
 23920                                  
 23921                                  ;============================================================================
 23922                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 23923                                  ;============================================================================
 23924                                  ; 03/10/2018 - Retro DOS v3.0
 23925                                  
 23926                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
 23927                                  
 23928                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23929                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h
 23930                                  
 23931                                  ; =============== S U B	R O U T	I N E =======================================
 23932                                  
 23933                                  	; 26/02/2023
 23934                                  SINGLETEST:
 23935 0000321C 1E                      	push	ds
 23936 0000321D 2E8E1E[F39D]            	mov	ds,[cs:RESSEG]
 23937 00003222 833E[4302]00            	cmp	word [SingleCom],0
 23938 00003227 7406                    	jz	short TESTDONE
 23939 00003229 813E[4302]FFEF          	cmp	word [SingleCom],0EFFFh
 23940                                  TESTDONE:
 23941 0000322F 1F                      	pop	ds
 23942 00003230 C3                      	retn
 23943                                  
 23944                                  ; =============== S U B	R O U T	I N E =======================================
 23945                                  
 23946                                  	; 26/02/2023
 23947                                  SetRest1:
 23948 00003231 B001                    	mov	al,1
 23949                                  
 23950                                  ; ---------------------------------------------------------------------------
 23951                                  
 23952                                  SETREST:
 23953 00003233 1E                      	push	ds
 23954 00003234 8E1E[F39D]              	mov	ds,[RESSEG]
 23955 00003238 A2[3F02]                	mov	[RestDir],al
 23956 0000323B 1F                      	pop	ds
 23957 0000323C C3                      	retn
 23958                                  
 23959                                  ; =============== S U B	R O U T	I N E =======================================
 23960                                  
 23961                                  ; Note that we need to handle the same thing that RestDir handles: the
 23962                                  ; requirement that we try only once to restore the user's environment after
 23963                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
 23964                                  ; disappear, we just give up.
 23965                                  
 23966                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 23967                                  	;
 23968                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 23969                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:33AFh
 23970                                  PIPEDEL:
 23971 0000323D 1E                      	push	ds
 23972 0000323E 52                      	push	dx
 23973 0000323F 2E8E1E[F39D]            	mov	ds,[cs:RESSEG]
 23974                                  	;mov	dx,3EAh	; MSDOS 6.22 COMMAND.COM - TRANGROUP:33B1h
 23975                                  	;;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
 23976                                  			; Pipe1 = offset RESGROUP:EndInit
 23977 00003244 BA[B702]                	mov	dx,Pipe1	; Clean up in case ^C
 23978                                  	;mov	ah,Unlink ; 41h
 23979 00003247 B441                    	mov	ah,41h
 23980 00003249 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 23981                                  			; DS:DX	-> ASCIZ pathname of file to delete
 23982                                  			;		(no wildcards allowed)
 23983                                  
 23984                                  	;mov	dx,439h	; MSDOS 6.22 COMMAND.COM - TRANGROUP:33BDh
 23985                                  	;;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
 23986                                  			; Pipe2 = offset RESGROUP:EndInit+79
 23987 0000324B BA[0603]                	mov	dx,Pipe2
 23988                                  	;mov	ah,Unlink ; 41h
 23989 0000324E B441                    	mov	ah,41h
 23990 00003250 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 23991                                  			; DS:DX	-> ASCIZ pathname of file to delete
 23992                                  			;		(no wildcards allowed)
 23993 00003252 5A                      	pop	dx
 23994 00003253 E86202                  	call	PipeOff
 23995 00003256 C606[B602]00            	mov	byte [PipeFiles],0
 23996 0000325B 1F                      	pop	ds
 23997 0000325C C3                      	retn
 23998                                  
 23999                                  ; ---------------------------------------------------------------------------
 24000                                  
 24001                                  	; 26/02/2023
 24002                                  PIPEERRSYN:
 24003 0000325D BA[6892]                	mov	dx,SYNTMES_PTR
 24004 00003260 E8DAFF                  	call	PIPEDEL
 24005 00003263 0E                      	push	cs
 24006 00003264 1F                      	pop	ds
 24007 00003265 E93AFC                  	jmp	cerror
 24008                                  
 24009                                  ; ---------------------------------------------------------------------------
 24010                                  
 24011                                  	; 26/02/2023
 24012                                  PIPERR:
 24013 00003268 9C                      	pushf
 24014 00003269 E85EFF                  	call    TriageError
 24015                                  	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
 24016 0000326C 50                      	push	ax		; Save results from TriageError
 24017 0000326D 52                      	push	dx
 24018 0000326E BA[3193]                	mov	dx,PIPEEMES_PTR
 24019 00003271 E8C9FF                  	call	PIPEDEL
 24020 00003274 0E                      	push	cs
 24021 00003275 1F                      	pop	ds
 24022 00003276 E88E22                  	call	std_eprintf
 24023 00003279 5A                      	pop	dx		; Restore results from TriageError
 24024 0000327A 58                      	pop	ax
 24025 0000327B 9D                      	popf
 24026 0000327C 83F841                  	cmp	ax,65
 24027 0000327F 7503                    	jne	short TCOMMANDJ
 24028 00003281 E91EFC                  	jmp	cerror
 24029                                  
 24030                                  TCOMMANDJ:
 24031 00003284 E97DCE                  	jmp	TCOMMAND
 24032                                  
 24033                                  ; ---------------------------------------------------------------------------
 24034                                  
 24035                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 24036                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24037                                  PIPEPROCSTRT:
 24038 00003287 8E1E[F39D]              	mov	ds,[RESSEG]
 24039 0000328B FE06[B602]              	inc	byte [PipeFiles] ; Flag that the pipe files exist
 24040                                  
 24041                                  	; MSDOS 6.0
 24042 0000328F 06                      	push	es
 24043 00003290 57                      	push	di
 24044 00003291 1E                      	push	ds
 24045 00003292 56                      	push	si
 24046                                  	
 24047 00003293 1E                      	push	ds
 24048 00003294 06                      	push	es
 24049 00003295 1F                      	pop	ds			;ds = TRANGROUP
 24050 00003296 BE[F698]                	mov	si,TempVarName		;ds:si = "TEMP="
 24051                                  
 24052                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
 24053                                  ;so the routine is not really general
 24054                                  
 24055 00003299 E8C9F5                  	call	find_name_in_environment
 24056                                  					;es:di points at path
 24057 0000329C 1F                      	pop	ds			;ds = DATARES again
 24058 0000329D 721F                    	jc	short no_temp_path
 24059                                  	
 24060 0000329F 1E                      	push	ds
 24061 000032A0 06                      	push	es
 24062 000032A1 1F                      	pop	ds
 24063 000032A2 07                      	pop	es			;swap ds and es
 24064 000032A3 89FE                    	mov	si,di			;ds:si points at path
 24065                                  	
 24066 000032A5 E8AA02                  	call	skip_white		;skip white space chars
 24067                                  
 24068                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
 24069                                  
 24070 000032A8 E8B302                  	call	copy_pipe_path		;copy the pipe path
 24071                                  	
 24072                                  ;Check if the TEMP path is valid
 24073                                  
 24074 000032AB 06                      	push	es
 24075 000032AC 1F                      	pop	ds			;ds = DATARES
 24076                                  	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
 24077                                  	;;mov	dx,320h ; MSDOS 5.0 - offset EndInit
 24078                                  	;mov	dx,3EAh	; MSDOS 6.22 - offset EndInit
 24079 000032AD BA[B702]                	mov	dx,Pipe1
 24080                                  	;mov	ax,(CHMOD shl 8) or 0
 24081 000032B0 B80043                  	mov	ax,4300h
 24082 000032B3 CD21                    	int	21h
 24083 000032B5 7207                    	jc	short no_temp_path
 24084                                  	
 24085 000032B7 F7C11000                	test	cx,10h			;is it a directory?
 24086 000032BB 7501                    	jnz	short no_temp_path	;yes, continue (carry clear)
 24087                                  	
 24088 000032BD F9                      	stc				;no, indicate fail
 24089                                  no_temp_path:
 24090 000032BE 5E                      	pop	si
 24091 000032BF 1F                      	pop	ds
 24092 000032C0 5F                      	pop	di
 24093 000032C1 07                      	pop	es
 24094 000032C2 730B                    	jnc	short crt_temp		;path found, create tempfiles
 24095                                  
 24096                                  	; 27/02/2023
 24097                                  	; MSDOS 3.3
 24098                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 24099                                  	;				; Get current drive
 24100                                  	;int	21h ; DOS - GET DEFAULT DISK NUMBER
 24101                                  	;add	al,[cs:CAPITAL_A]
 24102                                  	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
 24103                                  	;mov	bx,PIPE1
 24104                                  	;mov	[bx],al
 24105                                  	;xor	ah,ah			; nul terminate path names
 24106                                  	;mov	byte [PIPE1+3],ah
 24107                                  	;mov	byte [PIPE2+3],ah
 24108                                  
 24109                                  	; MSDOS 6.0
 24110                                  ;SR;
 24111                                  ; We want to create temp files in the current directory rather than in the 
 24112                                  ;root of the drive. This is because the number of files that can be present
 24113                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
 24114                                  
 24115                                  	;mov	ah,'.'
 24116                                  	;mov	[Pipe1],ah	; = RESGROUP:EndInit
 24117                                  	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
 24118                                  	;xor	ah,ah
 24119                                  	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
 24120                                  	;mov	[Pipe2+1],ah		;create files in current dir
 24121                                  	; 27/02/2023
 24122 000032C4 B92E00                  	mov	cx,002Eh
 24123 000032C7 890E[B702]              	mov	[Pipe1],cx
 24124 000032CB 890E[0603]              	mov	[Pipe2],cx
 24125                                  crt_temp:
 24126                                  	; MSDOS 6.0
 24127                                  	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
 24128                                  	;;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
 24129                                  	;mov	dx,3EAh ; MSDOS 6.22 COMMAND.COM	
 24130 000032CF BA[B702]                	mov	dx,Pipe1
 24131                                  	; MSDOS 3.3
 24132                                  	;mov	dx,bx
 24133                                  	
 24134                                  	; MSDOS 3.3 (& MSDOS 6.0)
 24135 000032D2 31C9                    	xor	cx,cx
 24136                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 24137 000032D4 B45A                    	mov	ah,5Ah
 24138 000032D6 CD21                    	int	21h
 24139                                  		; DOS -	3+ - CREATE UNIQUE FILE
 24140                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 24141                                  		; receive generated filename
 24142                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 24143 000032D8 728E                    	jc	short PIPERR	; Couldn't create
 24144                                  
 24145 000032DA 89C3                    	mov	bx,ax
 24146                                  	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 24147 000032DC B43E                    	mov	ah,3Eh
 24148 000032DE CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 24149                                  			; BX = file handle
 24150                                  	;;;mov	dx,PIPE2
 24151                                  	;;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
 24152                                  	;mov	dx,439h ; MSDOS 6.22 COMMAND.COM
 24153 000032E0 BA[0603]                	mov	dx,Pipe2
 24154                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 24155 000032E3 B45A                    	mov	ah,5Ah
 24156 000032E5 CD21                    	int	21h
 24157                                  		; DOS -	3+ - CREATE UNIQUE FILE
 24158                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 24159                                  		; receive generated filename
 24160                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 24161                                  	; 17/04/2023
 24162                                  	;jc	short PIPERR
 24163                                  	; 27/02/2023
 24164 000032E7 7303                    	jnc	short pps1
 24165 000032E9 E97CFF                  	jmp	PIPERR
 24166                                  pps1:
 24167 000032EC 89C3                    	mov	bx,ax
 24168 000032EE B43E                    	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 24169 000032F0 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 24170                                  				; BX = file handle
 24171                                  	;call	near ptr TESTDOREIN ; Set up a redirection if specified
 24172 000032F2 E87FFE                  	call	TESTDOREIN
 24173                                  	;mov	si,[488h] ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24174 000032F5 8B36[5503]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 24175 000032F9 833E[4302]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 24176 000032FE 7506                    	jne	short NOSINGP
 24177 00003300 C706[4302]00F0          	mov	word [SingleCom],0F000h ; Flag single command pipe
 24178                                  NOSINGP:
 24179 00003306 EB29                    	jmp	short FIRSTPIPE
 24180                                  
 24181                                  ; ---------------------------------------------------------------------------
 24182                                  
 24183                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 24184                                  	; 11/06/2026 - Retro DOS v4.2 COMMAND.COM
 24185                                  PIPEPROC:
 24186 00003308 8026[3B02]FE            	and	byte [EchoFlag],0FEh  ; force current echo to be off
 24187                                  	;;mov	si,[488h] ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24188 0000330D 8B36[5503]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 24189 00003311 AC                      	lodsb
 24190                                  	; 27/02/2023
 24191 00003312 3C7C                    	cmp	al,'|'		
 24192                                  	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
 24193                                  	;je	short ISPIPE1	; Yes
 24194                                  	;cmp	al,'|'
 24195                                  	;;cmp	al,[cs:VBAR]
 24196 00003314 7403                    	je	short ISPIPE1
 24197 00003316 E98400                  	jmp	PIPEEND		; Pipe done
 24198                                  ISPIPE1:
 24199 00003319 8B16[D803]              	mov	dx,[InPipePtr]	; Get the input file name
 24200                                  	;mov	ax,OPEN*256 ; 3D00h
 24201 0000331D B8003D                  	mov	ax,3D00h
 24202 00003320 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 24203                                  			; DS:DX	-> ASCIZ filename
 24204                                  			; AL = access mode
 24205                                  			; 0 - read
 24206                                  PIPEERRJ:
 24207 00003322 7303                    	jnc	short NO_PIPEERR
 24208 00003324 E941FF                  	jmp	PIPERR		; Lost the pipe file
 24209                                  NO_PIPEERR:
 24210 00003327 89C3                    	mov	bx,ax
 24211 00003329 B0FF                    	mov	al,0FFh
 24212                                  	;xchg	al,[bx+18h]
 24213 0000332B 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 24214 0000332E A21800                  	mov	[PDB.JFN_TABLE],al	; Redirect
 24215                                  FIRSTPIPE:
 24216 00003331 BF[549C]                	mov	di,COMBUF+2
 24217 00003334 31C9                    	xor	cx,cx
 24218 00003336 803C0D                  	cmp	byte [si],0Dh	; '|<CR>'
 24219 00003339 7503                    	jne	short PIPEOK1
 24220                                  PIPEERRSYNJ:
 24221 0000333B E91FFF                  	jmp	PIPEERRSYN
 24222                                  PIPEOK1:
 24223                                  	;;;mov	al,[cs:VBAR]
 24224                                  	; 27/02/2023
 24225                                  	;;mov	al,vbar
 24226                                  	;mov	al,'|'
 24227                                  	;cmp	[si],al		; '||'
 24228                                  	;je	short PIPEERRSYNJ
 24229 0000333E 803C7C                  	cmp	byte [si],'|'
 24230                                  	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
 24231 00003341 74F8                    	je	short PIPEERRSYNJ
 24232                                  PIPECOMLP:
 24233 00003343 AC                      	lodsb
 24234 00003344 AA                      	stosb
 24235                                  	; 27/02/2023
 24236 00003345 E8C7F5                  	call	testkanj
 24237 00003348 7405                    	jz	short NOTKANJ5
 24238 0000334A A4                      	movsb
 24239                                  ;  Added following 2 commands to the fix pipe bug.
 24240 0000334B 41                      	inc	cx		;AN000;  3/3/KK
 24241 0000334C 41                      	inc	cx		;AN000;  3/3/KK
 24242 0000334D EBF4                    	jmp	short PIPECOMLP
 24243                                  NOTKANJ5:
 24244 0000334F 3C0D                    	cmp	al,0Dh
 24245 00003351 7438                    	je	short LASTPIPE
 24246 00003353 41                      	inc	cx
 24247                                  	; 27/02/2023
 24248 00003354 3C7C                    	cmp	al,'|'
 24249                                  	;cmp	al,ALTPIPECHR
 24250                                  	;je	short ISPIPE2
 24251                                  	;;cmp	al,[cs:VBAR]
 24252                                  	;cmp	al,vbar
 24253 00003356 75EB                    	jne	short PIPECOMLP
 24254                                  ISPIPE2:
 24255 00003358 26C645FF0D              	mov	byte [es:di-1],0Dh
 24256 0000335D 49                      	dec	cx
 24257                                  	;mov	[cs:COMBUF+1],cl
 24258                                  	; 27/02/2023
 24259 0000335E 26880E[539C]            	mov	[es:COMBUF+1],cl
 24260 00003363 4E                      	dec	si
 24261                                  	;;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 24262                                  	; 11/06/2023 - MSDOS 6.22 COMMAND.COM
 24263                                  	;mov	[488h],si ; [PipePtr] = [EndInit+158]
 24264 00003364 8936[5503]              	mov	[PipePtr],si		; On to next pipe element
 24265                                  			; mov [EndInit+158],si
 24266 00003368 8B16[DA03]              	mov	dx,[OutPipePtr]
 24267 0000336C 51                      	push	cx
 24268 0000336D 31C9                    	xor	cx,cx
 24269                                  	;mov	ax,CREAT*256 ; 3C00h
 24270 0000336F B8003C                  	mov	ax,3C00h
 24271 00003372 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 24272                                  			; CX = attributes for file
 24273                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 24274 00003374 59                      	pop	cx
 24275 00003375 72AB                    	jc	short PIPEERRJ		; Lost the file
 24276 00003377 89C3                    	mov	bx,ax
 24277 00003379 B0FF                    	mov	al,0FFh
 24278                                  	;xchg	al,[bx+18h]
 24279 0000337B 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 24280 0000337E A21900                  	mov	[PDB.JFN_TABLE+1],al
 24281 00003381 8716[D803]              	xchg	dx,[InPipePtr]	; Swap for next element of pipe
 24282 00003385 8916[DA03]              	mov	[OutPipePtr],dx
 24283 00003389 EB0D                    	jmp	short PIPECOM
 24284                                  LASTPIPE:
 24285                                  	;mov	[cs:COMBUF+1],cl 
 24286                                  	; 27/02/2023
 24287 0000338B 26880E[539C]            	mov	[es:COMBUF+1],cl
 24288 00003390 4E                      	dec	si
 24289                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 24290                                  	;mov	[488h],si ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24291 00003391 8936[5503]              	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
 24292                                  		; mov [EndInit+158],si
 24293 00003395 E859FD                  	call	TESTDOREOUT	; Set up the redirection if specified
 24294                                  PIPECOM:
 24295 00003398 0E                      	push	cs
 24296 00003399 1F                      	pop	ds
 24297 0000339A E97DCF                  	jmp	NOPIPEPROC	; Process the pipe element
 24298                                  PIPEEND:
 24299 0000339D E89DFE                  	call	PIPEDEL
 24300 000033A0 813E[4302]00F0          	cmp	word [SingleCom],0F000h
 24301 000033A6 7506                    	jnz	short NOSINGP2
 24302 000033A8 C706[4302]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
 24303                                  NOSINGP2:
 24304 000033AE E953CD                  	jmp	TCOMMAND
 24305                                  
 24306                                  ; =============== S U B	R O U T	I N E =======================================
 24307                                  
 24308                                  ; Date and time are set during initialization and use
 24309                                  ; this routines since they need to do a long return
 24310                                  
 24311                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 24312                                  DATINIT:
 24313 000033B1 2E8C1E[F39D]            	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 24314 000033B6 06                      	push	es
 24315 000033B7 1E                      	push	ds		; Going to use the previous stack
 24316 000033B8 8CC8                    	mov	ax,cs		; Set up the appropriate segment registers
 24317 000033BA 8EC0                    	mov	es,ax
 24318 000033BC 8ED8                    	mov	ds,ax
 24319 000033BE E82B22                  	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 24320 000033C1 BA[90A9]                	mov	dx,INTERNATVARS
 24321 000033C4 B80038                  	mov	ax,3800h
 24322                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
 24323 000033C7 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 24324                                  			; get current-country info
 24325                                  			; DS:DX	-> buffer for returned info
 24326                                  	; 20/10/2018
 24327 000033C9 C70681000D00            	mov	word [81h],0Dh ; Want to prompt for date during initialization
 24328 000033CF C606[529C]80            	mov	byte [COMBUF],128 ; Init COMBUF
 24329 000033D4 C706[539C]010D          	mov	word [COMBUF+1],0D01h
 24330 000033DA E80600                  	call	DATE
 24331 000033DD E86200                  	call	CTIME
 24332 000033E0 1F                      	pop	ds
 24333 000033E1 07                      	pop	es
 24334 000033E2 CB                      	retf	; far return
 24335                                  
 24336                                  ; =============== S U B	R O U T	I N E =======================================
 24337                                  
 24338                                  ; MSDOS 6.0
 24339                                  
 24340                                  ; ****************************************************************
 24341                                  ; *
 24342                                  ; * ROUTINE:	 DATE - Set system date
 24343                                  ; *
 24344                                  ; * FUNCTION:	 If a date is specified, set the system date,
 24345                                  ; *		 otherwise display the current system date and
 24346                                  ; *		 prompt the user for a new date.  If an invalid
 24347                                  ; *		 date is specified, issue an error message and
 24348                                  ; *		 prompt for a new date.  If the user enters
 24349                                  ; *		 nothing when prompted for a date, terminate.
 24350                                  ; *
 24351                                  ; * INPUT:	 command line at offset 81H
 24352                                  ; *
 24353                                  ; * OUTPUT:	 none
 24354                                  ; *
 24355                                  ; ****************************************************************
 24356                                  
 24357                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24358                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
 24359                                  
 24360                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24361                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:356Eh
 24362                                  DATE:
 24363 000033E3 BE8100                  	mov	si,81h			; Accepting argument for date inline
 24364 000033E6 BF[E397]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 24365 000033E9 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 24366 000033EB 31D2                    	xor	dx,dx			;AN000;
 24367 000033ED E86916                  	call	cmd_parse		;AC000; call parser
 24368                                  
 24369                                  	; 27/02/2023
 24370                                  	;cmp	ax,-1
 24371                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24372                                  	;je	short PRMTDAT 		;AC000; yes - go ask for date
 24373                                  	;;cmp	ax,0
 24374                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24375                                  	;;jne	short DATERR		;AN000; yes - go issue message
 24376                                  	; 26/04/2023
 24377                                  	;or	ax,ax ; ax = 0 ?
 24378                                  	;jnz	short DATERR
 24379                                  	;;jmp	short COMDAT		;AC000; we have a date
 24380                                  	; 11/06/2023
 24381 000033F0 40                      	inc	ax  ; cmp ax,-1
 24382 000033F1 7428                    	jz	short PRMTDAT ; 0FFFFh -> 0
 24383 000033F3 48                      	dec	ax  ; cmp ax,0
 24384 000033F4 7541                    	jnz	short DATERR ; 1 -> 0
 24385                                  	; ax = 0
 24386                                  
 24387                                  	; 27/02/2023
 24388                                  COMDAT:
 24389 000033F6 8B0E[EDA9]              	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
 24390 000033FA 8A36[EFA9]              	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
 24391 000033FE 8A16[F0A9]              	mov	dl,[DATE_DAY]		;AC000;  date function call.
 24392 00003402 51                      	push	cx			;AC000; save date
 24393 00003403 52                      	push	dx			;AC000;
 24394 00003404 B90100                  	mov	cx,1			;AC000; set 1 positional entered
 24395 00003407 31D2                    	xor	dx,dx			;AN029;
 24396 00003409 E84D16                  	call	cmd_parse		;AN029; call parser
 24397 0000340C 3CFF                    	cmp	al,0FFh ; -1
 24398                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 24399 0000340E 5A                      	pop	dx			;AC000; retrieve date
 24400 0000340F 59                      	pop	cx			;AC000;
 24401 00003410 7525                    	jnz	short DATERR		;AC000; extra stuff on line - try again
 24402                                  	; 26/04/2023
 24403                                  	;mov	ah,SET_DATE		;yes - set date
 24404 00003412 B42B                    	mov	ah,2Bh
 24405 00003414 CD21                    	int	21h
 24406                                  			; DOS - SET CURRENT DATE
 24407                                  			; DL = day, DH = month, CX = year
 24408                                  			; Return: AL = 00h if no error /= FFh if bad value sent to routine
 24409 00003416 08C0                    	or	al,al
 24410 00003418 751D                    	jnz	short DATERR
 24411                                  date_end:
 24412 0000341A C3                      	retn
 24413                                  
 24414                                  PRMTDAT:
 24415                                  	; Print "Current date is
 24416 0000341B E81508                  	call	GetDate 		;AN000; get date for output
 24417                                  
 24418 0000341E 86F2                    	xchg	dh,dl			;AN000; switch month & day
 24419 00003420 890E[7E92]              	mov	[CurDat_yr],cx		;AC000; put year into message control block
 24420 00003424 8916[8092]              	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
 24421 00003428 BA[6E92]                	mov	dx,CurDat_Ptr		;AC000; set up message for output
 24422 0000342B E8E120                  	call	std_printf
 24423                                  
 24424                                  ;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
 24425                                  ;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block
 24426                                  
 24427                                  GET_NEW_DATE:				;AN000;
 24428 0000342E E8BC00                  	call	GETDAT			;AC000; prompt user for date
 24429                                  	
 24430                                  	; 11/06/2023
 24431                                  	;cmp	ax,0FFFFh ; -1
 24432                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24433                                  	;je	short date_end		;AC000; yes - exit
 24434                                  	; 26/04/2023
 24435                                  	;;cmp	ax,0
 24436                                  	;;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24437                                  	;;;jnz	short DATERR		;AN000; yes - go issue message
 24438                                  	;; 27/02/2023
 24439                                  	;;jz	short COMDAT
 24440                                  	; 26/04/2023
 24441                                  	;and	ax,ax ; 0 ?
 24442                                  	;jz	short COMDAT
 24443                                  
 24444                                  	; 11/06/2023
 24445 00003431 40                      	inc	ax  ; cmp ax,-1
 24446 00003432 74E6                    	jz	short date_end ; 0FFFFh -> 0
 24447 00003434 48                      	dec	ax  ; cmp ax,0
 24448 00003435 74BF                    	jz	short COMDAT ; 1 -> 0
 24449                                  	; ax > 0
 24450                                  
 24451                                  ;COMDAT:
 24452                                  ;	....
 24453                                  DATERR:
 24454 00003437 E8E7F6                  	call	CRLF2			;AN028; print out a blank line
 24455 0000343A BA[6B92]                	mov	dx,BADDAT_PTR
 24456 0000343D E8CF20                  	call	std_printf
 24457 00003440 EBEC                    	jmp	short GET_NEW_DATE	;AC000; get date again
 24458                                  
 24459                                  ; =============== S U B	R O U T	I N E =======================================
 24460                                  
 24461                                  ; MSDOS 6.0
 24462                                  
 24463                                  ; TIME gets and sets the time
 24464                                  
 24465                                  ; ****************************************************************
 24466                                  ; *
 24467                                  ; * ROUTINE:	 TIME - Set system time
 24468                                  ; *
 24469                                  ; * FUNCTION:	 If a time is specified, set the system time,
 24470                                  ; *		 otherwise display the current system time and
 24471                                  ; *		 prompt the user for a new time.  If an invalid
 24472                                  ; *		 time is specified, issue an error message and
 24473                                  ; *		 prompt for a new time.  If the user enters
 24474                                  ; *		 nothing when prompted for a time, terminate.
 24475                                  ; *
 24476                                  ; * INPUT:	 command line at offset 81H
 24477                                  ; *
 24478                                  ; * OUTPUT:	 none
 24479                                  ; *
 24480                                  ; ****************************************************************
 24481                                  
 24482                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24483                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
 24484                                  
 24485                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24486                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:35D7h
 24487                                  CTIME:
 24488 00003442 BE8100                  	mov	si,81h			; Accepting argument for time inline
 24489 00003445 BF[F597]                	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
 24490 00003448 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 24491 0000344A 31D2                    	xor	dx,dx			;AN000;
 24492 0000344C E80A16                  	call	cmd_parse		;AC000; call parser
 24493                                  	
 24494                                  	; 27/02/2023
 24495                                  	;cmp	ax,-1
 24496                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24497                                  	;je	short PRMTTIM 		;AC000; yes - prompt for time
 24498                                  	;;cmp	ax,0
 24499                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24500                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 24501                                  	;and	ax,ax ; ax = 0 ?
 24502                                  	;jnz	short TIMERR
 24503                                  	;;jmp	short COMTIM		;AC000; we have a time
 24504                                  	; 11/06/2023
 24505 0000344F 40                      	inc	ax  ; cmp ax,-1
 24506 00003450 742C                    	jz	short PRMTTIM ; 0FFFFh -> 0
 24507 00003452 48                      	dec	ax  ; cmp ax,0
 24508 00003453 7548                    	jnz	short TIMERR ; 1 -> 0
 24509                                  	; ax = 0
 24510                                  	
 24511                                  	; 27/02/2023
 24512                                  COMTIM:
 24513 00003455 8A2E[F5A9]              	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
 24514 00003459 8A0E[F6A9]              	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
 24515 0000345D 8A36[F7A9]              	mov	dh,[TIME_SECONDS]	;AC000;  time function call
 24516 00003461 8A16[F8A9]              	mov	dl,[TIME_FRACTION]	;AC000;
 24517 00003465 51                      	push	cx			;AC000; save time
 24518 00003466 52                      	push	dx			;AC000;
 24519 00003467 B90100                  	mov	cx,1			;AC000; set 1 positional parm entered
 24520 0000346A 31D2                    	xor	dx,dx			;AN029;
 24521 0000346C E8EA15                  	call	cmd_parse		;AN029; call parser
 24522 0000346F 3CFF                    	cmp	al, -1
 24523                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 24524 00003471 5A                      	pop	dx			;AC000; retieve time
 24525 00003472 59                      	pop	cx			;AC000;
 24526 00003473 7528                    	jnz	short TIMERR		;AC000; extra stuff on line - try again
 24527                                  SAVTIM:
 24528                                  	;mov	ah,SET_TIME
 24529 00003475 B42D                    	mov	ah,2Dh
 24530 00003477 CD21                    	int	21h
 24531 00003479 08C0                    	or	al,al
 24532 0000347B 7520                    	jnz	short TIMERR		;AC000; if an error occured, try again
 24533                                  time_end:
 24534 0000347D C3                      	retn
 24535                                  
 24536                                  PRMTTIM:
 24537                                  	;Printf "Current time is ... "
 24538                                  
 24539                                  	;mov	ah,Get_Time		;AC000; get the current time
 24540 0000347E B42C                    	mov	ah,2Ch
 24541 00003480 CD21                    	int	21h			;AC000;   Get time in CX:DX
 24542 00003482 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 24543 00003484 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 24544 00003486 890E[A092]              	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 24545 0000348A 8916[A292]              	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 24546 0000348E BA[9B92]                	mov	dx,CurTim_Ptr		;AC000; set up message for output
 24547 00003491 E87B20                  	call	std_printf
 24548                                  
 24549                                  ;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
 24550                                  ;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block
 24551                                  
 24552                                  GET_NEW_TIME:
 24553 00003494 E8AE00                  	call	GETTIM			;AC000;
 24554                                  	
 24555                                  	; 11/06/2023
 24556                                  	;cmp	ax,-1
 24557                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 24558                                  	;je	short time_end		;AC000;
 24559                                  	;;cmp	ax,0
 24560                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 24561                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 24562                                  	;or	ax,ax  ; ax = 0 ?
 24563                                  	;;jnz	short TIMERR
 24564                                  	; 27/02/2023
 24565                                  	;jz	short COMTIM
 24566                                  
 24567                                  	; 11/06/2023
 24568 00003497 40                      	inc	ax  ; cmp ax,-1
 24569 00003498 74E3                    	jz	short time_end ; 0FFFFh -> 0
 24570 0000349A 48                      	dec	ax  ; cmp ax,0
 24571 0000349B 74B8                    	jz	short COMTIM ; 1 -> 0
 24572                                  	; ax > 0
 24573                                  
 24574                                  ;COMTIM:
 24575                                  ;	....
 24576                                  TIMERR:
 24577 0000349D E881F6                  	call	CRLF2			;AN028; print out a blank line
 24578 000034A0 BA[9892]                	mov	dx,BadTim_Ptr
 24579 000034A3 E86920                  	call	std_printf		; Print error message
 24580 000034A6 EBEC                    	jmp	short GET_NEW_TIME	;AC000; Try again
 24581                                  
 24582                                  ; =============== S U B	R O U T	I N E =======================================
 24583                                  
 24584                                  ; MSDOS 6.0
 24585                                  
 24586                                  ; Set the special flag in the INIT flag to the value in CX.
 24587                                  
 24588                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24589                                  SetInitFlag:
 24590 000034A8 8E1E[F39D]              	mov	ds,[RESSEG]
 24591                                  
 24592 000034AC 8026[B402]FD            	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
 24593                                  	;and	byte [InitFlag],0FDh
 24594 000034B1 080E[B402]              	or	byte [InitFlag],cl
 24595 000034B5 0E                      	push	cs
 24596 000034B6 1F                      	pop	ds
 24597 000034B7 C3                      	retn
 24598                                  
 24599                                  ; =============== S U B	R O U T	I N E =======================================
 24600                                  
 24601                                  ; MSDOS 6.0
 24602                                  
 24603                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24604                                  PipeOff:
 24605 000034B8 1E                      	push	ds
 24606 000034B9 50                      	push	ax
 24607 000034BA 2E8E1E[F39D]            	mov	ds,[cs:RESSEG]
 24608 000034BF 30C0                    	xor	al,al
 24609 000034C1 8606[B502]              	xchg	[PipeFlag],al
 24610 000034C5 08C0                    	or	al,al
 24611 000034C7 7404                    	jz	short PipeOffDone
 24612 000034C9 D02E[3B02]              	shr	byte [EchoFlag],1
 24613                                  PipeOffDone:
 24614 000034CD 58                      	pop	ax
 24615 000034CE 1F                      	pop	ds
 24616 000034CF C3                      	retn
 24617                                  
 24618                                  ; =============== S U B	R O U T	I N E =======================================
 24619                                  
 24620                                  ; MSDOS 6.0
 24621                                  
 24622                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24623                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24624                                  PRINT_TIME:
 24625                                  	;mov	ah,Get_Time
 24626 000034D0 B42C                    	mov	ah,2Ch
 24627 000034D2 CD21                    	int	21h			; Get time in CX:DX
 24628                                  
 24629 000034D4 06                      	push	es
 24630 000034D5 0E                      	push	cs
 24631 000034D6 07                      	pop	es
 24632 000034D7 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 24633 000034D9 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 24634 000034DB 2E890E[DC93]            	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 24635 000034E0 2E8916[DE93]            	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 24636 000034E5 BA[D793]                	mov	dx,promtim_ptr		;AC000; set up message for output
 24637 000034E8 E82420                  	call	std_printf
 24638                                  
 24639                                  ;AD061; mov	word [cs:PromTim_hr_min],0
 24640                                  					;AC000; reset hour, minutes, seconds, and hundredths
 24641                                  ;AD061; mov	word [cs:PromTim_Sec_hn],0
 24642                                  					;AC000;  pointers in control block
 24643 000034EB 07                      	pop	es
 24644 000034EC C3                      	retn
 24645                                  
 24646                                  ; =============== S U B	R O U T	I N E =======================================
 24647                                  
 24648                                  ; MSDOS 6.0
 24649                                  
 24650                                  ; ****************************************************************
 24651                                  ; *
 24652                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 24653                                  ; *
 24654                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 24655                                  ; *		 INFORMATION and issues the "Enter new date"
 24656                                  ; *		 message with the proper date format. COMBUF
 24657                                  ; *		 is reset to get a date from the command line.
 24658                                  ; *		 The PARSE_DATE blocks are then reset and the
 24659                                  ; *		 PARSE function call is issued.
 24660                                  ; *
 24661                                  ; * INPUT:	 NONE
 24662                                  ; *
 24663                                  ; * OUTPUT:	 COMBUF
 24664                                  ; *		 PARSER RETURN CODES
 24665                                  ; *
 24666                                  ; ****************************************************************
 24667                                  
 24668                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24669                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
 24670                                  
 24671                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24672                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:368Ch
 24673                                  GETDAT:
 24674                                  	;mov	ax,(International SHL 8)
 24675 000034ED B80038                  	mov	ax,3800h
 24676                                  					; Determine what format the date
 24677 000034F0 BA5C00                  	mov	dx,5Ch			;  should be entered in and
 24678 000034F3 CD21                    	int	21h			;  print a message describing it
 24679                                  			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 24680                                  			; get current-country info
 24681                                  			; DS:DX -> buffer for returned info
 24682 000034F5 89D6                    	mov	si,dx
 24683 000034F7 AD                      	lodsw
 24684 000034F8 2E8B16[B593]            	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
 24685 000034FD 48                      	dec	ax
 24686 000034FE 780C                    	js	short printformat
 24687 00003500 2E8B16[B893]            	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
 24688 00003505 7405                    	jz	short printformat
 24689 00003507 2E8B16[BB93]            	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
 24690                                  printformat:
 24691 0000350C 89D0                    	mov	ax,dx			;AN000; get message number of format
 24692                                  	;mov	dh,util_msg_class	;AN000; this is a utility message
 24693 0000350E B6FF                    	mov	dh,-1 ; 0FFh
 24694 00003510 E8DF20                  	call	TSYSGETMSG		;AN000; get the address of the message
 24695 00003513 2E8936[8F92]            	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
 24696 00003518 BA[8A92]                	mov	dx,NewDat_Ptr		;AC000; get address of message to print
 24697 0000351B E8F11F                  	call	std_printf
 24698                                  	;mov	word [cs:NewDat_Format],no_subst
 24699                                  					;AN000; reset subst block
 24700 0000351E 2EC706[8F92]0000        	mov	word [cs:NewDat_Format],0
 24701                                  
 24702                                  	; 28/02/2023
 24703 00003525 BF[E397]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 24704                                  ; 28/02/2023
 24705                                  gettim_p:	
 24706                                  	;mov	ah,Std_Con_String_Input
 24707 00003528 B40A                    	mov	ah,0Ah
 24708 0000352A BA[529C]                	mov	dx,COMBUF
 24709 0000352D B90200                  	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 24710 00003530 E875FF                  	call	SetInitFlag		;  prompting for date.
 24711 00003533 CD21                    	int	21h			; Get input line
 24712 00003535 31C9                    	xor	cx,cx			; Reset bit in InitFlag that indicates
 24713 00003537 E86EFF                  	call	SetInitFlag		;  prompting for date.
 24714 0000353A E8E4F5                  	call	CRLF2
 24715                                  	; 28/02/2023
 24716                                  	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 24717                                  ;gettim_p: ; 28/02/2023
 24718 0000353D BE[549C]                	mov	si,COMBUF+2
 24719                                  	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
 24720 00003540 31D2                    	xor	dx,dx			;AN000;
 24721                                  	;call	cmd_parse		;AC000; call parser
 24722                                  	;retn
 24723                                  	; 28/02/2023
 24724 00003542 E91415                  	jmp	cmd_parse
 24725                                  
 24726                                  ; =============== S U B	R O U T	I N E =======================================
 24727                                  
 24728                                  ; MSDOS 6.0
 24729                                  
 24730                                  ; ****************************************************************
 24731                                  ; *
 24732                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 24733                                  ; *
 24734                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 24735                                  ; *		 INFORMATION and issues the "Enter new time"
 24736                                  ; *		 message. COMBUF is reset to get a time from the
 24737                                  ; *		 command line. The PARSE_TIME blocks are then
 24738                                  ; *		 reset and the PARSE function call is issued.
 24739                                  ; *
 24740                                  ; * INPUT:	 NONE
 24741                                  ; *
 24742                                  ; * OUTPUT:	 COMBUF
 24743                                  ; *		 PARSER RETURN CODES
 24744                                  ; *
 24745                                  ; ****************************************************************
 24746                                  
 24747                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24748                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
 24749                                  
 24750                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24751                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:36E7h
 24752                                  GETTIM:
 24753 00003545 31C9                    	xor	cx,cx			; Initialize hours and minutes to zero
 24754 00003547 BA[A992]                	mov	dx,NewTim_Ptr
 24755 0000354A E8C21F                  	call	std_printf
 24756                                  
 24757                                  	; 28/02/2023
 24758 0000354D BF[F597]                	mov	di,PARSE_TIME
 24759 00003550 EBD6                    	jmp	short gettim_p
 24760                                  
 24761                                  ; 28/02/2023
 24762                                  ;	;mov	ah,Std_Con_String_Input
 24763                                  ;	mov	ah,0Ah
 24764                                  ;	mov	dx,COMBUF
 24765                                  ;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 24766                                  ;	call	SetInitFlag		;  prompting for time.
 24767                                  ;	int	21h			; Get input line
 24768                                  ;	; 28/02/2023
 24769                                  ;	xor	cx,cx			; Reset bit in InitFlag that indicates
 24770                                  ;	call	SetInitFlag		;  prompting for time.
 24771                                  ;	call	CRLF2
 24772                                  ;	; 28/02/2023
 24773                                  ;	;mov	si,COMBUF+2
 24774                                  ;	; 28/02/2023
 24775                                  ;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
 24776                                  ;	; 28/02/2023
 24777                                  ;	jmp	short gettim_p	
 24778                                  ;	; 28/02/2023
 24779                                  ;	;;xor	cx,cx			;AN000; clear counter for positionals
 24780                                  ;	;xor	dx,dx			;AN000;
 24781                                  ;	;call	cmd_parse		;AC000; call parser
 24782                                  ;	;retn
 24783                                  
 24784                                  
 24785                                  ; =============== S U B	R O U T	I N E =======================================
 24786                                  
 24787                                  ; MSDOS 6.0
 24788                                  
 24789                                  ;Skip_white: Skips over the whitespace chars that could be present after
 24790                                  ;the '=' sign in the environment variable before the actual path.
 24791                                  ;
 24792                                  ;	ENTRY:	ds:si = arguments of the environment variable
 24793                                  ;
 24794                                  ;	EXIT:	ds:si = start of the path
 24795                                  ;
 24796                                  ;	REGISTERS AFFECTED: ax
 24797                                  
 24798                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24799                                  skip_white:
 24800 00003552 FC                      	cld
 24801                                  skw_lp:
 24802 00003553 AC                      	lodsb
 24803 00003554 3C20                    	cmp	al,' '			;blank char?
 24804 00003556 74FB                    	jz	short skw_lp		;yes, skip it
 24805 00003558 3C09                    	cmp	al,9			;tab char?
 24806 0000355A 74F7                    	jz	short skw_lp		;yes, skip it
 24807 0000355C 4E                      	dec	si			;point at first non-white
 24808 0000355D C3                      	retn
 24809                                  
 24810                                  ; =============== S U B	R O U T	I N E =======================================
 24811                                  
 24812                                  ; MSDOS 6.0
 24813                                  
 24814                                  ;Copy_pipe_path: This routine copies the path from the TEMP environment
 24815                                  ;variable into the path buffers Pipe1 & Pipe2.
 24816                                  ;
 24817                                  ;	ENTRY:	ds:si = path to be copied
 24818                                  ;		es = RESGROUP
 24819                                  ;
 24820                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 24821                                  ;
 24822                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 24823                                  
 24824                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24825                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h
 24826                                  
 24827                                  	; 11/06/2023 - Retro DOS v4.2 COMMAND.COM
 24828                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:371Eh
 24829                                  copy_pipe_path:
 24830 0000355E B9FFFF                  	mov	cx,0FFFFh ; 65535
 24831 00003561 30C0                    	xor	al,al
 24832                                  
 24833 00003563 89F7                    	mov	di,si
 24834 00003565 06                      	push	es			;save es
 24835 00003566 1E                      	push	ds
 24836 00003567 07                      	pop	es			;es:di = path to be copied
 24837                                  	
 24838 00003568 FC                      	cld
 24839 00003569 57                      	push	di
 24840 0000356A F2AE                    	repnz	scasb			;look for the null char
 24841 0000356C 5F                      	pop	di
 24842                                  
 24843 0000356D 07                      	pop	es			;es = RESGROUP again
 24844                                  
 24845 0000356E F7D1                    	not	cx			;length including the null
 24846                                  
 24847                                  	;;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
 24848                                  	;;mov	di,3EAh ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24849                                  	;mov	di,offset DATARES:Pipe1
 24850 00003570 BF[B702]                	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
 24851 00003573 57                      	push	di
 24852 00003574 51                      	push	cx			
 24853 00003575 F3A4                    	rep	movsb			;copy path into Pipe1
 24854 00003577 59                      	pop	cx
 24855 00003578 5F                      	pop	di
 24856                                  
 24857 00003579 1E                      	push	ds
 24858 0000357A 06                      	push	es
 24859 0000357B 1F                      	pop	ds			;ds:si = Pipe1
 24860 0000357C 89FE                    	mov	si,di
 24861                                  	;;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
 24862                                  	;;mov	di,439h ; MSDOS 6.22 COMMAND.COM ; 11/06/2023
 24863                                  	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 24864 0000357E BF[0603]                	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
 24865 00003581 F3A4                    	rep	movsb			;copy path into Pipe2
 24866 00003583 1F                      	pop	ds
 24867 00003584 C3                      	retn
 24868                                  
 24869                                  ;============================================================================
 24870                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 24871                                  ;============================================================================
 24872                                  ; 03/10/2018 - Retro DOS v3.0
 24873                                  
 24874                                  ;----------------------------------------------------------------------------
 24875                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 24876                                  ; argv[argvcnt] array. The most important difference between this array and
 24877                                  ; the tradition UNIX format is the extra cparse information included with
 24878                                  ; each argument element.
 24879                                  ;---------------
 24880                                  ; ENTRY:
 24881                                  ;	BL	     special delimiter for cparse -- not implemented)
 24882                                  ;---------------
 24883                                  ; EXIT:
 24884                                  ;	CF	    set if error
 24885                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 24886                                  ;	argv[]	    array of cparse flags and pointers to arguments
 24887                                  ;	argvcnt     argument count
 24888                                  ;---------------
 24889                                  ; NOTE(S):
 24890                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 24891                                  ;	*   Parseflags record contains cparse flags, as follows:
 24892                                  ;		sw_flag 	--	was this arg a switch?
 24893                                  ;		wildcard	--	whether or not it contained a * or ?
 24894                                  ;		path_sep	--	maybe it was a pathname
 24895                                  ;		unused		--	for future expansion
 24896                                  ;		special_delim	--	was there an initial special delimiter?
 24897                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 24898                                  ;	*   Relationship between input, cparse output, and comtail can be
 24899                                  ;	    found in the following chart. Despite the claim of the cparse
 24900                                  ;	    documentation that, "Token buffer always starts d: for non switch
 24901                                  ;	    tokens", such is not the case (see column two, row two).
 24902                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 24903                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 24904                                  ;	    STARTEL addresses) will be null. This is clearly just a
 24905                                  ;	    documentation error.
 24906                                  ;	*   cparse also returns a switch code in BP for each switch it
 24907                                  ;	    recognizes on the command line.
 24908                                  ;	*   arglen for each token does NOT include the terminating null.
 24909                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 24910                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 24911                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 24912                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 24913                                  ;	    line parsing may result in slightly different behavior than
 24914                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 24915                                  ;
 24916                                  ;	    Input		    Cparse		Command Line (80H)
 24917                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 24918                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 24919                                  ;	foo.bat 		foo.bat 		foo.bat
 24920                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 24921                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 24922                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 24923                                  
 24924                                  ; =============== S U B	R O U T	I N E =======================================
 24925                                  
 24926                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 24927                                  
 24928                                  ; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24929                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh
 24930                                  
 24931                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 24932                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3745h
 24933                                  
 24934                                  ; 27/07/2024 - Retro DOS v4.0-v4.1-v4.2-v5.0 COMMAND.COM (PARSELINE)
 24935                                  ; PCDOS 7.1 - COMMAND.COM, transient portion/segment offset 35F5h
 24936                                  
 24937                                  PARSELINE:
 24938 00003585 50                      	push	ax			; most of these are clobbered
 24939 00003586 53                      	push	bx			; by cparse...
 24940 00003587 51                      	push	cx
 24941 00003588 52                      	push	dx
 24942 00003589 57                      	push	di
 24943 0000358A 56                      	push	si
 24944 0000358B 9C                      	pushf
 24945                                  	;mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
 24946 0000358C C706[07A8]FFFF          	mov	word [LASTARG],-1 ; last argument at which to accumulate
 24947 00003592 31C0                    	xor	ax,ax
 24948                                  	;;mov	cx,1348
 24949                                  	; 27/07/2024
 24950                                  	;mov	cx,1092  ; PCDOS 7.1 COMMAND.COM
 24951 00003594 B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092
 24952 00003597 A2[95A0]                	mov	[cpyflag],al ; 0 ; 27/07/2024
 24953 0000359A BF[41A2]                	mov	di,ARG
 24954 0000359D F3AA                    	rep	stosb
 24955                                  	;mov	word [ARGBUF_PTR],ARG_ARGBUF
 24956 0000359F C706[85A7][05A5]        	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
 24957                                  	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 24958                                  	;mov	word [ARG+ARG_UNIT.argswinfo],0
 24959 000035A5 A3[03A5]                	mov	[ARG+ARG_UNIT.argswinfo],ax ; 0 ; 27/07/2024
 24960                                  	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 24961                                  	;mov	word [ARG+ARG_UNIT.argvcnt],0
 24962 000035A8 A3[01A5]                	mov	[ARG+ARG_UNIT.argvcnt],ax ; 0 ; 27/07/2024 
 24963 000035AB BE[549C]                	mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 24964                                  
 24965                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 24966                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 24967                                  ; otherwise. This is done so that commands can get arg pointers into their
 24968                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 24969                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 24970                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 24971                                  ; the command to be repeated or the transient part of command has been
 24972                                  ; reloaded.
 24973                                  
 24974 000035AE 1E                      	push	ds
 24975 000035AF 8E1E[F39D]              	mov	ds,[RESSEG]
 24976                                  	;cmp	byte [ForFlag],0
 24977 000035B3 3806[4902]              	cmp	[ForFlag],al ; 0 ; 27/07/2024
 24978 000035B7 1F                      	pop	ds
 24979 000035B8 7510                    	jnz	short PCONT
 24980                                  	;mov	di,ARG_ARGFORCOMBUF
 24981 000035BA BF[05A6]                	mov	di,ARG+ARG_UNIT.argforcombuf
 24982 000035BD 30ED                    	xor	ch,ch
 24983 000035BF 8A0E[539C]              	mov	cl,[COMBUF+1]
 24984 000035C3 FEC1                    	inc	cl
 24985 000035C5 F3A4                    	rep	movsb
 24986                                  	;mov	si,ARG_ARGFORCOMBUF
 24987 000035C7 BE[05A6]                	mov	si,ARG+ARG_UNIT.argforcombuf
 24988                                  PCONT:
 24989 000035CA BF[87A7]                	mov	di,TPBUF	; destination is temporary token buffer
 24990 000035CD B320                    	mov	bl,' '		; no special delimiter, for now
 24991                                  PARSELOOP:
 24992 000035CF 8936[09A8]              	mov	[COMPTR],si	; save ptr into original command buffer
 24993 000035D3 31ED                    	xor	bp,bp		; switch information put here by cparse
 24994 000035D5 C606[23A2]00            	mov	byte [expand_star],0 ; don't expand *'s to ?'s
 24995 000035DA E851F5                  	call	scanoff		; skip leading blanks...
 24996 000035DD E8B412                  	call	cparse		; byte off a token (args in SI, DI, BL)
 24997 000035E0 730B                    	jnb	short MORE_PRSE
 24998 000035E2 09ED                    	or	bp,bp		; Check for trailing switch character
 24999 000035E4 7403                    	jz	short PARSEDONE
 25000 000035E6 E81700                  	call	newarg		; We hit CR but BP is non-zero. The
 25001                                  				;   typical cause of this is that a
 25002                                  				;   switch char IMMEDIATELY preceeds
 25003                                  				;   the CR. We have an argument, but it
 25004                                  				;   is sort of an error.
 25005                                  	;jmp	short PARSEDONE	; We're done (found the CR).
 25006                                  	; 01/03/2023
 25007                                  PARSEDONE:
 25008 000035E9 9D                      	popf
 25009 000035EA F8                      	clc
 25010 000035EB EB0C                    	jmp	short PARSE_EXIT
 25011                                  
 25012                                  MORE_PRSE:
 25013 000035ED C606[95A0]02            	mov	byte [cpyflag],2
 25014                                  				; tell CPARSE that 1st token is done
 25015 000035F2 E80B00                  	call	newarg		; add to argv array (CX has char count)
 25016 000035F5 73D8                    	jnb	short PARSELOOP	; was everything OK?
 25017                                  	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 25018                                  	; 01/03/2023
 25019                                  ;PARSEDONE:
 25020                                  	;popf
 25021                                  	;clc
 25022                                  	;jmp	short PARSE_EXIT
 25023                                  
 25024                                  PARSE_ERROR:			; error entry (er, exit) point
 25025 000035F7 9D                      	popf
 25026 000035F8 F9                      	stc
 25027                                  PARSE_EXIT:			; depend on not changing CF
 25028 000035F9 5E                      	pop	si
 25029 000035FA 5F                      	pop	di
 25030 000035FB 5A                      	pop	dx
 25031 000035FC 59                      	pop	cx
 25032 000035FD 5B                      	pop	bx
 25033 000035FE 58                      	pop	ax
 25034 000035FF C3                      	retn
 25035                                  
 25036                                  ; =============== S U B	R O U T	I N E =======================================
 25037                                  
 25038                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 25039                                  ;
 25040                                  ; ENTRY:
 25041                                  ;   BH			argflags
 25042                                  ;   CX			character count in argstring
 25043                                  ;   DI			pointer to argstring
 25044                                  ;   comptr		ptr to starting loc of current token in original command
 25045                                  ;   [STARTEL]		cparse's answer to where the last element starts
 25046                                  ; EXIT:
 25047                                  ;   argbufptr		points to next free section of argbuffer
 25048                                  ;   arg.argbuf		contains null-terminated argument strings
 25049                                  ;   arg.argvcnt 	argument count
 25050                                  ;   arg.argv[]		array of flags and pointers
 25051                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 25052                                  ;   CF			set if error
 25053                                  ;   AL			carry set:  error code; otherwise, zero
 25054                                  
 25055                                  	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25056                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25057                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM 
 25058                                  	;	     & Retro DOS v4.2 COMMAND.COM (2024 modification)
 25059                                  newarg:
 25060 00003600 53                      	push	bx
 25061 00003601 51                      	push	cx
 25062 00003602 52                      	push	dx
 25063 00003603 57                      	push	di
 25064 00003604 56                      	push	si
 25065 00003605 9C                      	pushf
 25066 00003606 E86200                  	call	arg_switch		; if it's a switch, record switch info
 25067                                  					; LEAVE SWITCH ON COMMAND LINE!!
 25068                                  	;;;jc	short newarg_done 	; previous arg's switches -- and leave
 25069                                  
 25070                                  	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 25071 00003609 833E[01A5]40            	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 25072 0000360E 7D50                    	jge	short to_many_args	; exceeded array limits
 25073 00003610 88FE                    	mov	dh,bh			
 25074                                  	;mov	bx,[ARG_ARGVCNT]	; save argflags	
 25075 00003612 8B1E[01A5]              	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 25076                                  	;inc	word [ARG_ARGVCNT]
 25077 00003616 FF06[01A5]              	inc	word [ARG+ARG_UNIT.argvcnt]
 25078                                  	;mov	ax,ARG_ARGV
 25079 0000361A B8[41A2]                	mov	ax,ARG+ARG_UNIT.argv
 25080 0000361D E87E00                  	call	argv_calc		; convert offset to pointer
 25081                                  	;mov	[BX].argsw_word,0 	; no switch information, yet...
 25082                                  	;mov	word [bx+7],0
 25083 00003620 C747070000              	mov	word [bx+ARGV_ELE.argsw_word],0
 25084                                  	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
 25085                                  	;mov	[bx+5],cx
 25086 00003625 894F05                  	mov	[bx+ARGV_ELE.arglen],cx 
 25087                                  	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
 25088                                  	;mov	[bx+2],dh
 25089 00003628 887702                  	mov	[bx+ARGV_ELE.argflags],dh
 25090 0000362B 8B36[85A7]              	mov	si,[ARGBUF_PTR]
 25091                                  	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
 25092                                  	;mov	[bx+ARGV_ELE.argpointer],si
 25093 0000362F 8937                    	mov	[bx],si			
 25094 00003631 0336[E7A1]              	add	si,[STARTEL]		; save startel from new location
 25095 00003635 29FE                    	sub	si,di			; form pointer into argbuf
 25096                                  	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 25097                                  	;mov	[bx+3],si
 25098 00003637 897703                  	mov	[bx+ARGV_ELE.argstartel],si
 25099 0000363A 8B36[09A8]              	mov	si,[COMPTR]
 25100                                  	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 25101                                  	;mov	[bx+9],si
 25102 0000363E 897709                  	mov	[bx+ARGV_ELE.arg_ocomptr],si
 25103 00003641 89FE                    	mov	si,di			; now save argstring in argbuffer
 25104 00003643 8B3E[85A7]              	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
 25105                                  
 25106                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 25107                                  ; PCDOS 7.1 COMMAND.COM
 25108                                  %if 0
 25109                                  	add	di,cx			; sure we're not about to run off
 25110                                  	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 25111                                  	;;cmp	di,ARG_ARGBUF+255
 25112                                  	;cmp	di,ARG+ARG_UNIT.argbuf+127
 25113                                  	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 25114                                  	jge	short buf_oflow		; the end of the buffer (plus null byte)
 25115                                  	sub	di,cx
 25116                                  %else
 25117                                  	; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 25118                                  	;mov	bx,ARG_ARGBUF+127
 25119 00003647 BB[84A5]                	mov	bx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 25120 0000364A 29FB                    	sub	bx,di	; sure we're not about to run off
 25121 0000364C 39CB                    	cmp	bx,cx
 25122 0000364E 7302                    	jnb	short newarg_@
 25123 00003650 89D9                    	mov	cx,bx	
 25124                                  %endif
 25125                                  
 25126                                  newarg_@:	; 27/07/2024
 25127 00003652 FC                      	cld
 25128 00003653 F3A4                    	rep	movsb
 25129 00003655 B000                    	mov	al,ANULL ; 0		; tack a null byte on the end
 25130 00003657 AA                      	stosb
 25131 00003658 893E[85A7]              	mov	[ARGBUF_PTR],di		; update argbufptr after copy
 25132                                  newarg_done:
 25133 0000365C 9D                      	popf
 25134 0000365D F8                      	clc
 25135 0000365E EB05                    	jmp	short newarg_exit
 25136                                  
 25137                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 25138                                  ; PCDOS 7.1 COMMAND.COM
 25139                                  %if 0
 25140                                  to_many_args:
 25141                                  	mov	ax,1
 25142                                  	jmp	short newarg_error
 25143                                  buf_oflow:
 25144                                  	mov	ax,2
 25145                                  %else
 25146                                  ; 27/07/2024 - Retro DOS v5.0 COMMAND.COM
 25147                                  ;buf_oflow:
 25148                                  ;	; 27/07/2024
 25149                                  ;	; PCDOS 7.1 COMMAND.COM
 25150                                  ;	sub	di,cx
 25151                                  ;	;mov	cx,ARG_ARGBUF+7Fh
 25152                                  ;	mov	cx,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 25153                                  ;	sub	cx,di
 25154                                  ;	jmp     short newarg_@
 25155                                  to_many_args:
 25156 00003660 B80100                  	mov	ax,1
 25157                                  %endif
 25158                                  
 25159                                  newarg_error:
 25160 00003663 9D                      	popf
 25161 00003664 F9                      	stc
 25162                                  newarg_exit:
 25163 00003665 5E                      	pop	si
 25164 00003666 5F                      	pop	di
 25165 00003667 5A                      	pop	dx
 25166 00003668 59                      	pop	cx
 25167 00003669 5B                      	pop	bx
 25168 0000366A C3                      	retn
 25169                                  
 25170                                  ; =============== S U B	R O U T	I N E =======================================
 25171                                  
 25172                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 25173                                  ; event that it is, and we can recognize
 25174                                  ;
 25175                                  ; ENTRY:
 25176                                  ;   As in <newarg>.
 25177                                  ; EXIT:
 25178                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 25179                                  ; NOTE(S):
 25180                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 25181                                  ;	on the order of definition in the <switch_list> variable and the
 25182                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 25183                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 25184                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 25185                                  ;   *	The <switch_list> declared below is redundant to one declared in
 25186                                  ;	TDATA.ASM, and used in TCODE.ASM.
 25187                                  ;   *	An ugly routine.
 25188                                  
 25189                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 25190                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25191                                  arg_switch:
 25192 0000366B 50                      	push	ax
 25193 0000366C 53                      	push	bx
 25194 0000366D 51                      	push	cx
 25195 0000366E 57                      	push	di
 25196 0000366F 9C                      	pushf
 25197 00003670 F6C701                  	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
 25198 00003673 741C                    	jz	short arg_no_switch0
 25199 00003675 833E[07A8]FF            	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
 25200 0000367A 741B                    	je	short arg_no_switch1 	; no, so leading switches don't matter
 25201 0000367C 8B1E[07A8]              	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
 25202                                  	;mov	ax,offset TRANGROUP:arg.argv
 25203                                  	;mov	ax,ARG_ARGV
 25204 00003680 B8[41A2]                	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 25205 00003683 E81800                  	call	argv_calc
 25206                                  	;or	[BX].argsw_word,BP
 25207                                  	;or	[bx+7],bp
 25208 00003686 096F07                  	or	[bx+ARGV_ELE.argsw_word],bp
 25209                                  	;or	arg.argswinfo,BP
 25210                                  	;or	[ARG_ARGSWINFO],bp
 25211 00003689 092E[03A5]              	or	[ARG+ARG_UNIT.argswinfo],bp
 25212                                  arg_yes_switch:
 25213 0000368D 9D                      	popf
 25214 0000368E F9                      	stc
 25215 0000368F EB08                    	jmp	short arg_switch_exit
 25216                                  
 25217                                  arg_no_switch0:
 25218                                  	;mov	ax,[ARG_ARGVCNT]
 25219 00003691 A1[01A5]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 25220 00003694 A3[07A8]                	mov	[LASTARG],ax
 25221                                  arg_no_switch1:
 25222 00003697 9D                      	popf
 25223 00003698 F8                      	clc
 25224                                  arg_switch_exit:
 25225 00003699 5F                      	pop	di
 25226 0000369A 59                      	pop	cx
 25227 0000369B 5B                      	pop	bx
 25228 0000369C 58                      	pop	ax
 25229 0000369D C3                      	retn
 25230                                  
 25231                                  ; =============== S U B	R O U T	I N E =======================================
 25232                                  
 25233                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 25234                                  ; the supplied array.  Method used for computing the address is:
 25235                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 25236                                  ; ENTRY:
 25237                                  ;   AX	    --	    base of array
 25238                                  ;   BX	    --	    array index
 25239                                  ; EXIT:
 25240                                  ;   BX	    --	    byte offset
 25241                                  
 25242                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 25243                                  argv_calc:
 25244 0000369E 50                      	push	ax		; Save base
 25245 0000369F 88D8                    	mov	al,bl		; al = array index
 25246                                  	;mov	bl,11
 25247 000036A1 B30B                    	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 25248 000036A3 F6E3                    	mul	bl		; ax = base offset
 25249 000036A5 5B                      	pop	bx		; Get base
 25250 000036A6 01D8                    	add	ax,bx		; Add in base offset
 25251 000036A8 93                      	xchg	ax,bx		; Restore ax and put byte offset in bx
 25252 000036A9 C3                      	retn
 25253                                  
 25254                                  ; ---------------------------------------------------------------------------
 25255                                  	
 25256                                  	;db 0Ah dup(0)
 25257                                  	;times 10 db 0
 25258                                  
 25259 000036AA 90<rep 6h>              align 16
 25260                                  
 25261                                  ;============================================================================
 25262                                  ; PATH1.ASM, MSDOS 6.0, 1991
 25263                                  ;============================================================================
 25264                                  ; 03/10/2018 - Retro DOS v3.0
 25265                                  
 25266                                  ;----------------------------------------------------------------------------
 25267                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 25268                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 25269                                  ;    given a pathname, attempts to find a corresponding executable or batch
 25270                                  ;    file on disk. Directories specified in the user's search path will be
 25271                                  ;    searched for a matching file, if a match is not found in the current
 25272                                  ;    directory and if the pathname is actually only an MSDOS filename.
 25273                                  ;    <Path_Search> assumes that the parsed command name can be found in
 25274                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 25275                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 25276                                  ;    information could be placed in argv[0], or <Path_Search> could be
 25277                                  ;    (easily) modified to make no assumptions about where its input is found.
 25278                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 25279                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 25280                                  ;    allocated memory. This is handy for for-loop processing, and anything
 25281                                  ;    else that wants to save the whole shebang and then process other command
 25282                                  ;    lines.
 25283                                  ;
 25284                                  ; Alan L, OS/MSDOS				    August 15, 1983
 25285                                  ;
 25286                                  ; ENTRY:
 25287                                  ;   <Path_Search>:	    argv[0].
 25288                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 25289                                  ; EXIT:
 25290                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 25291                                  ;   <Save_Args>:	    success flag, segment address of new memory
 25292                                  ; NOTE(S):
 25293                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 25294                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 25295                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 25296                                  ;	does not function as specified; see <Parseline> for more details.
 25297                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 25298                                  ;	need to know about. This extra information is stored in a switch_flag
 25299                                  ;	word with each command-line argument; the switches themselves will not
 25300                                  ;	appear in the resulting arg structure.
 25301                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 25302                                  ;----------------------------------------------------------------------------
 25303                                  
 25304                                  ; =============== S U B	R O U T	I N E =======================================
 25305                                  
 25306                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 25307                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 25308                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 25309                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 25310                                  ; have a match, either in the current working directory if we were handed
 25311                                  ; a filename, or in the specified directory, given a pathname. If this call
 25312                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 25313                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 25314                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 25315                                  ; either the first invocation of search or on one of the succeeding calls
 25316                                  ; sets up the appropriate information for copying the successful pathname
 25317                                  ; prefix (if any) into the result buffer, followed by the successful filename
 25318                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 25319                                  ;
 25320                                  ; ENTRY:
 25321                                  ;   argv[0]		--	command name and associated information
 25322                                  ; EXIT:
 25323                                  ;   AX			--	non-zero indicates type of file found
 25324                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 25325                                  ; NOTE(S):
 25326                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 25327                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 25328                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 25329                                  ;	if search returns an .exe or .bat.
 25330                                  ;   5)	Clobbers dma address.
 25331                                  
 25332                                  PBUFLEN 	EQU	128		; length of EXECPATH
 25333                                  PATH_SEP_CHAR	EQU	';'
 25334                                  
 25335                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 25336                                  
 25337                                  	;special_delim equ 128
 25338                                  	;path_sep equ 4
 25339                                  	;wildcard equ 2
 25340                                  	;sw_flag  equ 1
 25341                                  
 25342                                  ;----------------------------------------------------------------------------
 25343                                  
 25344                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 25345                                  
 25346                                  ; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25347                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h
 25348                                  
 25349                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25350                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 387Bh
 25351                                  
 25352                                  path_search:
 25353 000036B0 53                      	push	bx
 25354 000036B1 51                      	push	cx
 25355 000036B2 52                      	push	dx		; could use a "stack 'em" instruction
 25356 000036B3 56                      	push	si
 25357 000036B4 57                      	push	di
 25358 000036B5 55                      	push	bp
 25359 000036B6 9C                      	pushf
 25360                                  
 25361                                  	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 25362                                  	;test	byte [ARGV0_ARG_FLAGS],3
 25363 000036B7 F606[43A2]03            	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
 25364 000036BC 7403                    	jz	short path_search_ok
 25365                                  path_failure_jmp:
 25366 000036BE E9C100                  	jmp	path_failure	; ambiguous commands not allowed
 25367                                  
 25368                                  path_search_ok:
 25369 000036C1 E85201                  	call	STORE_PCHAR	; figure out the pathname separator
 25370 000036C4 BA[0BA8]                	mov	dx,FBUF		; clobber old dma value with
 25371 000036C7 B8001A                  	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
 25372 000036CA CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 25373                                  			; DS:DX	-> disk	transfer buffer
 25374 000036CC 06                      	push	es
 25375 000036CD E88DF1                  	call	find_path	; get a handle (ES:DI) on user path
 25376 000036D0 8C06[36A8]              	mov	[pathinfo+0],es	; and squirrel it away
 25377 000036D4 893E[38A8]              	mov	[pathinfo+2],di	; "old" pathstring pointer
 25378 000036D8 893E[3AA8]              	mov	[pathinfo+4],di	; "new" pathstring pointer
 25379 000036DC 07                      	pop	es
 25380                                  	
 25381 000036DD BB8000                  	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 25382 000036E0 BE[1B9D]                	mov	si,EXECPATH
 25383 000036E3 E88002                  	call	STRIP
 25384 000036E6 72D6                    	jc	short path_failure_jmp ; if possible, of course
 25385                                  		
 25386 000036E8 89F2                    	mov	dx,si		; search (EXECPATH, error_message)
 25387 000036EA C706[8BA8][2C92]        	mov	word [search_error],baddrv_ptr
 25388 000036F0 E89F01                  	call	PSEARCH		; must do at least one search
 25389 000036F3 09C0                    	or	ax,ax		; find anything?
 25390 000036F5 7469                    	jz	short path_noinit
 25391                                  				; failure ... search farther
 25392 000036F7 89C5                    	mov	bp,ax		; success... save filetype code
 25393 000036F9 BF[1B9D]                	mov	di,EXECPATH
 25394                                  	;mov	si,ds:arg.argv[0].argpointer
 25395                                  	;mov	si,[ARG_ARGV]
 25396 000036FC 8B36[41A2]              	mov	si,[ARG+ARGV_ELE.argpointer]
 25397                                  	;mov	cx,ds:arg.argv[0].argstartel
 25398                                  	;mov	cx,[ARGV0_ARGSTARTEL]
 25399 00003700 8B0E[44A2]              	mov	cx,[ARG+ARGV_ELE.argstartel]
 25400 00003704 29F1                    	sub	cx,si		; compute prefix bytes to copy
 25401                                  
 25402                                  ; We have the number of bytes in the prefix (up to the final component).
 25403                                  ; We need to form the complete pathname including leading drive and current
 25404                                  ; directory.
 25405                                  ;
 25406                                  ; Is there a drive letter present?
 25407                                  
 25408 00003706 B43A                    	mov	ah,':'
 25409 00003708 83F902                  	cmp	cx,2		; room for drive letter?
 25410 0000370B 7205                    	jb	short adddrive	; no, stick it in
 25411 0000370D 386401                  	cmp	[si+1],	ah	; colon present?
 25412 00003710 7408                    	je	short movedrive	; yes, just move it
 25413                                  adddrive:
 25414 00003712 A0[059E]                	mov	al,[CURDRV]	; get current drive
 25415 00003715 0441                    	add	al,'A'		; convert to uppercase letter
 25416 00003717 AB                      	stosw			; store d:
 25417 00003718 EB05                    	jmp	short checkpath
 25418                                  
 25419                                  movedrive:
 25420 0000371A AD                      	lodsw			; move d:
 25421 0000371B AB                      	stosw
 25422 0000371C 83E902                  	sub	cx,2		; 2 bytes less to move
 25423                                  checkpath:
 25424 0000371F 0C20                    	or	al,20h
 25425 00003721 88C2                    	mov	dl,al
 25426                                  	;sub	dl,60h
 25427 00003723 80EA60                  	sub	dl,'a'-1	; convert to 1-based for current dir
 25428                                  
 25429                                  ; Stick in beginning path char
 25430                                  
 25431 00003726 A0[3CA8]                	mov	al,[psep_char]
 25432 00003729 AA                      	stosb
 25433                                  
 25434                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 25435                                  ; Otherwise, get current dir for DL.
 25436                                  
 25437 0000372A 83F901                  	cmp	cx,1		; is there room for path char?
 25438 0000372D 720A                    	jb	short addpath	; no, go add path
 25439 0000372F AC                      	lodsb
 25440 00003730 49                      	dec	cx
 25441 00003731 3A06[3CA8]              	cmp	al,[psep_char]	; is there a path separator?
 25442 00003735 741C                    	je	short movepath	; yes, go move remainder of path
 25443 00003737 41                      	inc	cx
 25444 00003738 4E                      	dec	si		; undo the lodsb
 25445                                  addpath:
 25446 00003739 56                      	push	si
 25447 0000373A 89FE                    	mov	si,di		; remainder of buffer
 25448 0000373C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25449 0000373F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25450                                  			; DL = drive (0=default,1=A,etc.)
 25451                                  			; DS:SI	points to 64-byte buffer area
 25452                                  
 25453                                  ; The previous current dir will succeed a previous find_first already worked.
 25454                                  ;
 25455                                  ; Find end of string.
 25456                                  
 25457 00003741 89F7                    	mov	di,si
 25458 00003743 5E                      	pop	si
 25459 00003744 A0[3CA8]                	mov	al,[psep_char]
 25460 00003747 803D00                  	cmp	byte [di],0	; root (empty dir string)?
 25461 0000374A 7407                    	jz	short movepath	; yes, no need for path char
 25462                                  scanend:
 25463                                  	;cmp	byte [di],0	; end of string?
 25464                                  	;jz	short foundend
 25465                                  	;inc	di
 25466                                  	;jmp	short scanend
 25467                                  	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
 25468 0000374C 47                      	inc	di
 25469 0000374D 803D00                  	cmp	byte [di],0
 25470 00003750 75FA                    	jnz	short scanend
 25471                                  
 25472                                  ; Stick in a trailing path char.
 25473                                  
 25474                                  foundend:
 25475 00003752 AA                      	stosb
 25476                                  
 25477                                  ; Move remaining part of path. Skip leading path char if present.
 25478                                  
 25479                                  movepath:
 25480 00003753 3804                    	cmp	[si],al		; first char a path char?
 25481 00003755 7502                    	jne	short copypath
 25482                                  	; 26/04/2023
 25483 00003757 46                      	inc	si		; move past leading char
 25484 00003758 49                      	dec	cx		; drop from count
 25485                                  copypath:
 25486 00003759 E302                    	jcxz	_copydone	; no chars to move!
 25487 0000375B F3A4                    	rep	movsb
 25488                                  _copydone:
 25489 0000375D E9A100                  	jmp	path_success
 25490                                  				; run off and form complete pathname
 25491                                  path_noinit:
 25492                                  	;test	ds:arg.argv[0].argflags, MASK path_sep
 25493                                  	;test	byte [ARGV0_ARG_FLAGS],4
 25494 00003760 F606[43A2]04            	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
 25495 00003765 751B                    	jnz	short path_failure
 25496                                  				; complete pathname specified ==> fail
 25497                                  	;mov	bh,';'
 25498 00003767 B73B                    	mov	bh,PATH_SEP_CHAR
 25499                                  				; semicolon terminates pathstring
 25500                                  	;mov	dx,ds:arg.argv[0].argstartel
 25501                                  				; this is where the last element starts
 25502                                  	;mov	dx,[ARGV0_ARGSTARTEL]
 25503 00003769 8B16[44A2]              	mov	dx,[ARG+ARGV_ELE.argstartel]
 25504                                  	;sub	dx,ds:arg.argv[0].argpointer
 25505                                  				; form pointer into EXECPATH,
 25506                                  	;sub	dx,[ARG_ARGV]
 25507 0000376D 2B16[41A2]              	sub	dx,[ARG+ARGV_ELE.argpointer]
 25508 00003771 81C2[1B9D]              	add	dx,EXECPATH	; skipping over drive spec, if any
 25509                                  path_loop:
 25510 00003775 E8AD00                  	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
 25511 00003778 89C5                    	mov	bp,ax		; save filetype code
 25512 0000377A 9F                      	lahf			; save flags, just in case
 25513 0000377B 09ED                    	or	bp,bp		; did path_crunch find anything?
 25514 0000377D 7508                    	jnz	short path_found
 25515 0000377F 9E                      	sahf			; see? needed those flags, after all!
 25516 00003780 73F3                    	jnc	short path_loop	; is there anything left to the path?
 25517                                  path_failure:
 25518 00003782 31C0                    	xor	ax,ax
 25519 00003784 E98700                  	jmp	path_exit
 25520                                  
 25521                                  path_found:				; pathinfo[] points to winner
 25522 00003787 BF[1B9D]                	mov	di,EXECPATH
 25523                                  	;mov	cx,pathinfo[4]
 25524 0000378A 8B0E[3AA8]              	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
 25525                                  	;mov	si,pathinfo[2]
 25526 0000378E 8B36[38A8]              	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string
 25527                                  
 25528                                  ;	BAS Nov 20/84
 25529                                  ;   Look at the pathname and expand . and .. if they are the first element
 25530                                  ;   in the pathname (after the drive letter)
 25531                                  
 25532 00003792 06                      	push	es
 25533                                  	;push	pathinfo[0]
 25534 00003793 FF36[36A8]              	push	word [pathinfo+0]
 25535 00003797 07                      	pop	es
 25536                                  ;SR;
 25537                                  ; Oops! Gets fooled if path= \;..
 25538                                  ; We should also check if a drive letter is really present
 25539                                  ;
 25540 00003798 26807C022E              	cmp	byte [es:si+2],'.'
 25541                                  				; Look for Current dir at start of path
 25542 0000379D 7534                    	jne	short path_cpy
 25543                                  
 25544                                  	; 18/03/2023
 25545                                  	; MSDOS 6.0
 25546 0000379F 26807C013A              	cmp	byte [es:si+1],':'
 25547                                  				; does path have drive letter?
 25548 000037A4 752D                    	jne	short path_cpy	; no, copy the path string
 25549                                  
 25550 000037A6 51                      	push	cx		; Save pointer to end of string
 25551                                  	;mov	al,[es:si]
 25552                                  	;mov	[di],al		; Copy drive letter, :, and root char
 25553                                  	;mov	al,[es:si+1]	; to EXECPATH
 25554                                  	;mov	[di+1],al
 25555                                  	; 05/05/2023
 25556 000037A7 268B04                  	mov	ax,[es:si]
 25557 000037AA 8905                    	mov	[di],ax
 25558 000037AC A0[3CA8]                	mov	al,[psep_char]
 25559 000037AF 884502                  	mov	[di+2],	al
 25560 000037B2 56                      	push	si		; Save pointer to begining of string
 25561 000037B3 268A14                  	mov	dl,[es:si]	; Convert device letter for cur dir
 25562 000037B6 80CA20                  	or	dl,20h
 25563                                  	;sub	dl,60h
 25564 000037B9 80EA60                  	sub	dl,'a'-1
 25565 000037BC 89FE                    	mov	si,di		; pointer to EXECPATH
 25566 000037BE 83C603                  	add	si,3		; Don't wipe out drive and root info
 25567 000037C1 B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25568 000037C4 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25569                                  			; DL = drive (0=default,1=A,etc.)
 25570                                  			; DS:SI	points to 64-byte buffer area
 25571 000037C6 E8F3F9                  	call	dstrlen		; Determine length of present info
 25572 000037C9 01CE                    	add	si,cx		; Don't copy over drive and root info
 25573 000037CB 4E                      	dec	si
 25574 000037CC 89F7                    	mov	di,si		; Point to end of target string
 25575 000037CE 5E                      	pop	si		; Restore pointer to begining of string
 25576 000037CF 83C603                  	add	si,3		; Point past drive letter, :, .
 25577 000037D2 59                      	pop	cx		; Restore pointer to end of string
 25578                                  path_cpy:
 25579 000037D3 07                      	pop	es
 25580 000037D4 29F1                    	sub	cx,si		; yields character count
 25581 000037D6 1E                      	push	ds		; time to switch segments
 25582 000037D7 FF36[36A8]              	push	word [pathinfo+0]
 25583                                  				; string lives in this segment
 25584 000037DB 1F                      	pop	ds
 25585 000037DC FC                      	cld
 25586                                  
 25587                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25588                                  	; MSDOS 5.0 (& MSDOS 5.0)
 25589                                  	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
 25590                                  kloop:
 25591 000037DD AC                      	lodsb			;AN000;  3/3/KK
 25592 000037DE AA                      	stosb			;AN000;  3/3/KK
 25593 000037DF E82DF1                  	call	testkanj	;AN000;  3/3/KK
 25594 000037E2 7410                    	jz	short _notkanj1	;AN000;  3/3/KK
 25595 000037E4 49                      	dec	cx		;AN000;  3/3/KK
 25596 000037E5 E307                    	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
 25597 000037E7 A4                      	movsb			;AN000;  3/3/KK
 25598 000037E8 49                      	dec	cx		;AN000;  3/3/KK
 25599 000037E9 83F901                  	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
 25600 000037EC 77EF                    	ja	short kloop	;AN000;  no.  3/3/KK
 25601                                  popdone:			;AN000;  3/3/KK
 25602 000037EE 1F                      	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
 25603 000037EF A0[3CA8]                	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
 25604 000037F2 EB0C                    	jmp	short path_store
 25605                                  				;AN000;  3/3/KK
 25606                                  _notkanj1:
 25607                                  	; 26/04/2023
 25608 000037F4 E2E7                    	loop	kloop
 25609 000037F6 1F                      	pop	ds		; return to our segment
 25610 000037F7 4F                      	dec	di		; overwrite terminator
 25611 000037F8 A0[3CA8]                	mov	al,[psep_char]	; with a pathname separator
 25612 000037FB 3A45FF                  	cmp	al,[di-1]
 25613 000037FE 7401                    	je	short path_success
 25614                                  path_store:
 25615 00003800 AA                      	stosb
 25616                                  path_success:
 25617 00003801 BE[3EA8]                	mov	si,search_best_buf
 25618 00003804 31C9                    	xor	cx,cx
 25619                                  path_succ_loop:
 25620 00003806 AC                      	lodsb			; append winning filename to path
 25621 00003807 AA                      	stosb			; (including terminating null)
 25622 00003808 08C0                    	or	al,al
 25623 0000380A 75FA                    	jnz	short path_succ_loop
 25624 0000380C 89E8                    	mov	ax,bp		; retrieve filetype code
 25625                                  path_exit:
 25626 0000380E 9D                      	popf
 25627 0000380F 5D                      	pop	bp
 25628 00003810 5F                      	pop	di
 25629 00003811 5E                      	pop	si		; chill out...
 25630 00003812 5A                      	pop	dx
 25631 00003813 59                      	pop	cx
 25632 00003814 5B                      	pop	bx
 25633 00003815 C3                      	retn
 25634                                  
 25635                                  ; =============== S U B	R O U T	I N E =======================================
 25636                                  
 25637                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 25638                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 25639                                  ;
 25640                                  ; ENTRY:
 25641                                  ; EXIT:
 25642                                  ; NOTE(S):
 25643                                  ;   *	Uses <psep_char>, defined in <path_search>.
 25644                                  
 25645                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25646                                  STORE_PCHAR:
 25647 00003816 50                      	push	ax
 25648 00003817 B02F                    	mov	al,'/'		; is the pathname-element separator
 25649 00003819 E8A0F3                  	call	pathchrcmp	; a regular slash?
 25650 0000381C 7402                    	jz	short STORE_SLASH
 25651                                  				; if yes, remember slash
 25652 0000381E B05C                    	mov	al,'\'
 25653                                  	; 18/03/2023
 25654                                  	;mov	[psep_char],al	; otherwise, remember back-slash
 25655                                  	;pop	ax
 25656                                  	;retn
 25657                                  STORE_SLASH:
 25658 00003820 A2[3CA8]                	mov	[psep_char],al
 25659 00003823 58                      	pop	ax
 25660 00003824 C3                      	retn
 25661                                  
 25662                                  ; =============== S U B	R O U T	I N E =======================================
 25663                                  
 25664                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 25665                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 25666                                  ; additional separator to use for breaking up the path-string. Null is the
 25667                                  ; default. Once the user-string has been formed, search is invoked to see
 25668                                  ; what's out there.
 25669                                  ;
 25670                                  ; ENTRY:
 25671                                  ;   BH			--	additional terminator character
 25672                                  ;   SI			--	pointer into pathstring to be dissected
 25673                                  ;   DX			--	pointer to stripped filename
 25674                                  ; EXIT:
 25675                                  ;   AX			--	non-zero (file type), zero (nothing found)
 25676                                  ;   SI			--	moves along pathstring from call to call
 25677                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 25678                                  ;   [tpbuf]		--	clobbered
 25679                                  ; NOTE(S):
 25680                                  ;   *	Implicit in this code is the ability to specify when to search
 25681                                  ;	the current directory (if at all) through the PATH defined by
 25682                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 25683                                  ;	current directory before the bin and etc directories of drive c).
 25684                                  
 25685                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25686                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
 25687                                  
 25688                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25689                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:39FEh
 25690                                  	
 25691                                  path_crunch:
 25692 00003825 53                      	push	bx
 25693 00003826 51                      	push	cx
 25694 00003827 52                      	push	dx
 25695 00003828 57                      	push	di
 25696 00003829 56                      	push	si
 25697                                  	;pushf	; ** ; 18/03/2023
 25698 0000382A E8E9FF                  	call	STORE_PCHAR	; figure out pathname separator
 25699 0000382D BF[87A7]                	mov	di,TPBUF	; destination of concatenated string
 25700 00003830 8B36[3AA8]              	mov	si,[pathinfo+4]	; "new" pointer to start with
 25701 00003834 8936[38A8]              	mov	[pathinfo+2],si	; becomes "old" pointer
 25702 00003838 1E                      	push	ds		; save old segment pointer
 25703 00003839 FF36[36A8]              	push	word [pathinfo+0]
 25704                                  				; replace with pointer to userpath's
 25705 0000383D 1F                      	pop	ds		; segment
 25706                                  	; 26/04/2023
 25707 0000383E 30C9                    	xor	cl,cl		;AN000; clear flag for later use 3/3/KK
 25708                                  path_cr_copy:
 25709 00003840 AC                      	lodsb			; get a pathname byte
 25710 00003841 08C0                    	or	al,al		; check for terminator(s)
 25711 00003843 7414                    	jz	short path_seg	; null terminates segment & pathstring
 25712 00003845 38F8                    	cmp	al,bh
 25713 00003847 7410                    	je	short path_seg	; BH terminates a pathstring segment
 25714                                  	;
 25715                                  	; 18/03/2023
 25716                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 25717 00003849 E8C3F0                  	call	testkanj	;AN000; 3/3/KK
 25718 0000384C 7406                    	jz	short _notkanj2	;AN000; 3/3/KK
 25719 0000384E AA                      	stosb			;AN000; 3/3/KK
 25720 0000384F A4                      	movsb			;AN000; 3/3/KK
 25721 00003850 B101                    	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK
 25722 00003852 EBEC                    	jmp	short path_cr_copy
 25723                                  _notkanj2:
 25724 00003854 30C9                    	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
 25725                                  	;
 25726 00003856 AA                      	stosb
 25727 00003857 EBE7                    	jmp	short path_cr_copy
 25728                                  
 25729                                  path_seg:
 25730 00003859 1F                      	pop	ds		; restore old data segment
 25731 0000385A 8936[3AA8]              	mov	[pathinfo+4],si	; save "new" pointer for next time
 25732 0000385E 88C3                    	mov	bl,al		; remember if we saw null or not...
 25733                                  				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 25734 00003860 31C0                    	xor	ax,ax		; in case nothing in pathstr...
 25735 00003862 81FF[87A7]              	cmp	di,TPBUF	; was there really anything in pathstr?
 25736 00003866 7421                    	je	short path_cr_leave
 25737                                  				; if nothing was copied, pathstr empty
 25738                                  path_cr_look:
 25739 00003868 A0[3CA8]                	mov	al,[psep_char]	; form complete pathname
 25740                                  	;
 25741                                  	; 18/03/2023
 25742                                  	; MSDOS 6.0
 25743 0000386B 08C9                    	or	cl,cl ; *	;AN000; 3/3/KK
 25744 0000386D 7505                    	jnz	short path_cr_store
 25745                                  				;AN000; this is a trailing byte of ECS code 3/3/KK
 25746                                  	;
 25747 0000386F 3A45FF                  	cmp	al,[di-1]	; add pathname separator for suffix
 25748 00003872 7401                    	je	short path_cr_l1
 25749                                  path_cr_store:
 25750 00003874 AA                      	stosb
 25751                                  path_cr_l1:
 25752 00003875 89D6                    	mov	si,dx
 25753                                  path_cr_l2:
 25754 00003877 AC                      	lodsb			; tack the stripped filename onto
 25755 00003878 AA                      	stosb			; the end of the path, up to and
 25756 00003879 08C0                    	or	al,al		; including the terminating null
 25757 0000387B 75FA                    	jnz	short path_cr_l2
 25758 0000387D BA[87A7]                	mov	dx,TPBUF	; and look for an appropriate file...
 25759 00003880 C706[8BA8][2893]        	mov	word [search_error],BADPMES_PTR
 25760                                  	;invoke search
 25761 00003886 E80900                  	call	PSEARCH		; results are in AX & search_best_buf
 25762                                  
 25763                                  	; 18/03/2023
 25764                                  ;path_cr_leave:
 25765                                  	;or	bl,bl		; did we finish off the pathstring?
 25766                                  	;jz	short path_cr_empty
 25767                                  	;			; null in BL means all gone...
 25768                                  	;popf	; **		; otherwise, plenty left
 25769                                  	;clc
 25770                                  	;jmp	short path_cr_exit
 25771                                  ;path_cr_empty:
 25772                                  	;popf	; **
 25773                                  	;stc
 25774                                  ;path_cr_exit:
 25775                                  
 25776                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25777                                  path_cr_leave:
 25778                                  	;popf ; ** ; 18/03/2023
 25779 00003889 80FB01                  	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
 25780                                  
 25781                                  path_cr_exit:
 25782 0000388C 5E                      	pop	si
 25783 0000388D 5F                      	pop	di
 25784 0000388E 5A                      	pop	dx
 25785 0000388F 59                      	pop	cx
 25786 00003890 5B                      	pop	bx
 25787 00003891 C3                      	retn
 25788                                  
 25789                                  ;============================================================================
 25790                                  ; PATH2.ASM, MSDOS 6.0, 1991
 25791                                  ;============================================================================
 25792                                  ; 02/10/2018 - Retro DOS v3.0
 25793                                  
 25794                                  ;----------------------------------------------------------------------------
 25795                                  ;   SEARCH, when given a pathname, attempts to find a file with
 25796                                  ; one of the following extensions: .com, .exe, .bat (highest to
 25797                                  ; lowest priority). Where conflicts arise, the extension with
 25798                                  ; the highest priority is favored.
 25799                                  ; ENTRY:
 25800                                  ;   DX		--	pointer to null-terminated pathname
 25801                                  ;   fbuf	--	dma buffer for findfirst/next
 25802                                  ; EXIT:
 25803                                  ;   AX		--	8)  file found with .com extension
 25804                                  ;			4)  file found with .exe extension
 25805                                  ;			2)  file found with .bat extension
 25806                                  ;			0)  no such file to be found
 25807                                  ;   (if AX is non-zero:)
 25808                                  ;   [search_best]	identical to AX
 25809                                  ;   [search_best_buf]	null-terminated filename
 25810                                  ; NOTES:
 25811                                  ;   1) Requires caller to have allocated a dma buffer and executed a setdma.
 25812                                  ;---------------
 25813                                  ; CONSTANTS:
 25814                                  ;---------------
 25815                                  SEARCH_FILE_NOT_FOUND	EQU	0
 25816                                  SEARCH_COM		EQU	8
 25817                                  SEARCH_EXE		EQU	4
 25818                                  SEARCH_BAT		EQU	2
 25819                                  FNAME_LEN		EQU	8
 25820                                  FNAME_MAX_LEN		EQU	13
 25821                                  DOT			EQU	'.'
 25822                                  WILDCHAR		EQU	'?'
 25823                                  
 25824                                  
 25825                                  ; =============== S U B	R O U T	I N E =======================================
 25826                                  
 25827                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 25828                                  
 25829                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25830                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
 25831                                  
 25832                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25833                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3A73h
 25834                                  PSEARCH:
 25835 00003892 51                      	push	cx
 25836 00003893 52                      	push	dx
 25837 00003894 57                      	push	di
 25838 00003895 56                      	push	si
 25839                                  	;pushf	; ** ; 18/03/2023
 25840 00003896 52                      	push	dx		; check drivespec (save pname ptr)
 25841 00003897 89D7                    	mov	di,dx		; working copy of pathname
 25842 00003899 BE[4BA8]                	mov	si,search_curdir_buf
 25843 0000389C 31D2                    	xor	dx,dx		; zero means current drive
 25844 0000389E 807D013A                	cmp	byte [di+1],':'	; is there a drive spec?
 25845 000038A2 7508                    	jne	short SEARCH_DIR_CHECK
 25846 000038A4 8A15                    	mov	dl,[di]		; get the drive byte
 25847 000038A6 80E2DF                  	and	dl,0DFh ; ~20h	; uppercase the sucker
 25848 000038A9 80EA40                  	sub	dl,'@' ; 40h	; and convert to drive number
 25849                                  SEARCH_DIR_CHECK:
 25850 000038AC B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25851 000038AF CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25852                                  			; DL = drive (0=default,1=A,etc.)
 25853                                  			; DS:SI	points to 64-byte buffer area
 25854 000038B1 5A                      	pop	dx		; directory? If we can't we'll
 25855 000038B2 724C                    	jc	short SEARCH_INVALID_DRIVE
 25856                                  				; assume it's a bad drive...
 25857 000038B4 B91300                  	mov	cx,search_attr	; 13h
 25858                                  				; filetypes to search for
 25859 000038B7 B8004E                  	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 25860 000038BA CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 25861                                  			; CX = search attributes
 25862                                  			; DS:DX	-> ASCIZ filespec
 25863                                  			; (drive,path, and wildcards allowed)
 25864 000038BC 7249                    	jc	short SEARCH_NO_FILE
 25865 000038BE C606[3DA8]00            	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
 25866 000038C3 C606[3EA8]00            	mov	byte [search_best_buf],ANULL
 25867                                  				; 0 ; nothing's been found, yet
 25868                                  SEARCH_LOOP:
 25869 000038C8 E84300                  	call	SEARCH_FTYPE	; determine if .com, &c...
 25870 000038CB 3A06[3DA8]              	cmp	al,[search_best]
 25871                                  				; better than what we've found so far?
 25872 000038CF 7E13                    	jle	short SEARCH_NEXT
 25873                                  				; no, look for another
 25874 000038D1 A2[3DA8]                	mov	[search_best],al
 25875                                  				; found something... save its code
 25876                                  	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 25877                                  	;mov	si,FBUF_PNAME
 25878 000038D4 BE[29A8]                	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
 25879 000038D7 BF[3EA8]                	mov	di,search_best_buf
 25880 000038DA B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25881 000038DD FC                      	cld
 25882 000038DE F3A4                    	rep	movsb		; save complete pathname representation
 25883 000038E0 3C08                    	cmp	al,SEARCH_COM	; 8
 25884                                  				; have we found the best of all?
 25885 000038E2 740A                    	je	short SEARCH_DONE
 25886                                  SEARCH_NEXT:			; keep on looking
 25887 000038E4 B91300                  	mov	cx,search_attr ; 13h
 25888 000038E7 B8004F                  	mov	ax,Find_Next*256 ; 4F00h ; next match
 25889 000038EA CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 25890                                  			; [DTA]	= data block from
 25891                                  			; last AH = 4Eh/4Fh call
 25892 000038EC 73DA                    	jnc	short SEARCH_LOOP
 25893                                  SEARCH_DONE:			; it's all over with...
 25894 000038EE A0[3DA8]                	mov	al,[search_best]
 25895                                  				; pick best to return with
 25896                                  	; 18/03/2023
 25897                                  	; MSDOS 6.0
 25898 000038F1 803E[F7A1]01            	cmp	byte [ext_entered],1
 25899                                  				;AN005; Did user request a specific ext?
 25900 000038F6 7411                    	je	short SEARCH_EXIT
 25901                                  				;AN005; no - exit
 25902 000038F8 A0[F7A1]                	mov	al,[ext_entered]
 25903                                  				;AN005; yes - get the real file type back
 25904 000038FB A2[3DA8]                	mov	[search_best],al
 25905                                  				;AN005; save the real file type
 25906                                  	;
 25907 000038FE EB09                    	jmp	short SEARCH_EXIT
 25908                                  
 25909                                  SEARCH_INVALID_DRIVE:		; Tell the user path/drive
 25910 00003900 8B16[8BA8]              	mov	dx,[search_error]
 25911                                  				; appropriate error message
 25912 00003904 E8081C                  	call	std_printf	; and pretend no file found
 25913                                  
 25914                                  SEARCH_NO_FILE:			; couldn't find a match
 25915                                  	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 25916                                  	; 18/03/2023
 25917 00003907 31C0                    	xor	ax,ax
 25918                                  SEARCH_EXIT:
 25919                                  	;popf	; ** ; 18/03/2023
 25920 00003909 5E                      	pop	si
 25921 0000390A 5F                      	pop	di
 25922 0000390B 5A                      	pop	dx
 25923 0000390C 59                      	pop	cx
 25924 0000390D C3                      	retn
 25925                                  
 25926                                  ; =============== S U B	R O U T	I N E =======================================
 25927                                  
 25928                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 25929                                  ;
 25930                                  ; ENTRY:
 25931                                  ;   fbuf    --	dma buffer containing filename
 25932                                  ; EXIT:
 25933                                  ;   AX	    --	file code, as given in search header
 25934                                  ; NOTE(S):
 25935                                  ;   *	Implicit assumption that NULL == search_file_not_found
 25936                                  
 25937                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25938                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 25939                                  SEARCH_FTYPE:
 25940 0000390E 57                      	push	di
 25941 0000390F 56                      	push	si
 25942                                  	;mov	ax,ANULL ; 0	; find the end of the filename
 25943                                  	; 18/02/2023
 25944 00003910 31C0                    	xor	ax,ax ; ax = 0		
 25945                                  	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 25946                                  	;mov	di,FBUF_PNAME
 25947 00003912 BF[29A8]                	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
 25948 00003915 B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25949 00003918 FC                      	cld
 25950 00003919 F2AE                    	repnz	scasb		; search for the terminating null
 25951 0000391B 7535                    	jnz	short FTYPE_EXIT
 25952                                  				; weird... no null byte at end
 25953 0000391D 83EF05                  	sub	di,5		; . + E + X + T + NULL
 25954                                  
 25955                                  	; Compare .COM
 25956                                  
 25957 00003920 BE[5497]                	mov	si,comext ; ".COM"
 25958 00003923 89F8                    	mov	ax,di
 25959 00003925 A7                      	cmpsw
 25960 00003926 7508                    	jnz	short FTYPE_EXE
 25961 00003928 A7                      	cmpsw
 25962 00003929 7505                    	jnz	short FTYPE_EXE
 25963                                  	;mov	ax,8
 25964 0000392B B80800                  	mov	ax,SEARCH_COM	; success!
 25965 0000392E EB22                    	jmp	short FTYPE_EXIT
 25966                                  
 25967                                  	; Compare .EXE
 25968                                  FTYPE_EXE:			; still looking... now for '.exe'
 25969 00003930 89C7                    	mov	di,ax
 25970 00003932 BE[5897]                	mov	si,exeext ; ".EXE"
 25971 00003935 A7                      	cmpsw
 25972 00003936 7508                    	jnz	short FTYPE_BAT
 25973 00003938 A7                      	cmpsw
 25974 00003939 7505                    	jnz	short FTYPE_BAT
 25975                                  	;mov	ax,4
 25976 0000393B B80400                  	mov	ax,SEARCH_EXE	; success!
 25977 0000393E EB12                    	jmp	short FTYPE_EXIT
 25978                                  
 25979                                  	; Compare .BAT
 25980                                  FTYPE_BAT:			; still looking... now for '.bat'
 25981 00003940 89C7                    	mov	di,ax
 25982 00003942 BE[5C97]                	mov	si,batext ; ".BAT"
 25983 00003945 A7                      	cmpsw
 25984 00003946 7508                    	jnz	short FTYPE_FAIL
 25985 00003948 A7                      	cmpsw
 25986 00003949 7505                    	jnz	short FTYPE_FAIL
 25987                                  	;mov	ax,2
 25988 0000394B B80200                  	mov	ax,SEARCH_BAT	; success!
 25989 0000394E EB02                    	jmp	short FTYPE_EXIT
 25990                                  
 25991                                  FTYPE_FAIL:			; file doesn't match what we need
 25992                                  	;mov	ax,ANULL ; 0
 25993                                  	; 18/03/2023
 25994 00003950 29C0                    	sub	ax,ax  ; ax = 0
 25995                                  FTYPE_EXIT:
 25996                                  	; 18/03/2023
 25997                                  	; MSDOS 6.0
 25998 00003952 803E[F7A1]01            	cmp	byte [ext_entered],1
 25999                                  				;AN005; was an extension entered?
 26000 00003957 740A                    	jz	short FTYPE_DONE
 26001                                  				;AN005; no - exit
 26002                                  	;cmp	ax,ANULL	;AN005; was any match found
 26003 00003959 21C0                    	and	ax,ax  ; ax = 0 ?
 26004 0000395B 7406                    	jz	short FTYPE_DONE
 26005                                  				;AN005; no - exit
 26006 0000395D A2[F7A1]                	mov	[ext_entered],al
 26007                                  				;AN005; save the match type found
 26008 00003960 B80800                  	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
 26009                                  FTYPE_DONE:
 26010 00003963 5E                      	pop	si
 26011 00003964 5F                      	pop	di
 26012 00003965 C3                      	retn
 26013                                  
 26014                                  ; =============== S U B	R O U T	I N E =======================================
 26015                                  
 26016                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 26017                                  ; replacing any extension with wildcards.
 26018                                  ;
 26019                                  ; ENTRY:
 26020                                  ;	BX	--	maximum length of destination buffer
 26021                                  ;	DS:SI	--	address of destination buffer
 26022                                  ;	argv[0] --	command name to be stripped
 26023                                  ; EXIT:
 26024                                  ;	CF	--	set if failure, clear if successful
 26025                                  ; NOTE(S):
 26026                                  
 26027                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26028                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26029                                  STRIP:
 26030 00003966 50                      	push	ax
 26031 00003967 53                      	push	bx
 26032 00003968 51                      	push	cx
 26033 00003969 52                      	push	dx
 26034 0000396A 57                      	push	di
 26035 0000396B 56                      	push	si
 26036                                  	;pushf	; ** ; 18/03/2023
 26037                                  		
 26038                                  	; 05/05/2023
 26039                                  	; MSDOS 6.0
 26040 0000396C C606[F7A1]01            	mov	byte [ext_entered],1
 26041                                  				;AN005; assume no extension on file name
 26042                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26043                                  	;mov	dx,[ARG_ARGV]
 26044                                  	;mov	dx,ds:arg.argv[0].argpointer
 26045                                  				; save pointer to beginning of argstring
 26046                                  	;mov	dx,[ARGV0_ARGPOINTER]
 26047 00003971 8B16[41A2]              	mov	dx,[ARG+ARGV_ELE.argpointer]
 26048                                  	;mov	di,ds:arg.argv[0].argstartel
 26049                                  				; beginning of last pathname element
 26050                                  	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 26051 00003975 8B3E[44A2]              	mov	di,[ARG+ARGV_ELE.argstartel]
 26052 00003979 803D00                  	cmp	byte [di],0	; *STARTEL == NULL means no command
 26053 0000397C 743D                    	je	short STRIP_ERROR
 26054 0000397E 89D1                    	mov	cx,dx		; compute where end of argstring lies
 26055                                  	;add	cx,ds:arg.argv[0].arglen
 26056                                  	;add	cx,[ARGV0_ARGLEN]
 26057 00003980 030E[46A2]              	add	cx,[ARG+ARGV_ELE.arglen]
 26058 00003984 29F9                    	sub	cx,di		; and then find length of last element
 26059 00003986 41                      	inc	cx		; include null as well
 26060 00003987 B02E                    	mov	al,'.'
 26061                                  	;mov	al,DOT		; let's find the filetype extension
 26062 00003989 FC                      	cld
 26063 0000398A F2AE                    	repnz	scasb		; wind up pointing to either null or dot
 26064                                  
 26065                                  	; 18/03/2023
 26066                                  	; MSDOS 6.0
 26067 0000398C E307                    	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
 26068 0000398E B000                    	mov	al,0 ; 18/03/2023
 26069                                  	;mov	byte [ext_entered],0
 26070 00003990 A2[F7A1]                	mov	[ext_entered],al
 26071                                  				;AN005; we found an extension
 26072                                  	;;mov	al,ANULL	;AN005; continue scanning until the
 26073                                  	;mov	al,0
 26074 00003993 F2AE                    	repnz	scasb		;AN005; end of line is reached.
 26075                                  PROCESS_EXT:
 26076                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26077 00003995 89F9                    	mov	cx,di		; pointer to end of argstring yields
 26078 00003997 29D1                    	sub	cx,dx		; number of bytes to be copied
 26079 00003999 83EB04                  	sub	bx,4		; can argstring fit into dest. buffer?
 26080 0000399C 39D9                    	cmp	cx,bx
 26081 0000399E 7F1B                    	jg	short STRIP_ERROR
 26082                                  				; if not, we must have a bad pathname
 26083 000039A0 89F7                    	mov	di,si		; destination buffer
 26084 000039A2 89D6                    	mov	si,dx		; source is beginning of pathname
 26085 000039A4 FC                      	cld
 26086 000039A5 F3A4                    	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 26087                                  
 26088                                  	; 18/03/2023
 26089                                  	; MSDOS 6.0
 26090 000039A7 803E[F7A1]01            	cmp	byte [ext_entered],1
 26091                                  				;AN005; if an extension was entered
 26092 000039AC 750A                    	jne	short SKIP_WILDS ; cf = 1 ; 12/06/2023
 26093                                  				;AN005;    don't set up wildcard ext.
 26094                                  
 26095                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26096 000039AE 4F                      	dec	di		; overwrite null or dot
 26097 000039AF AA                      	stosb			; with a dot
 26098 000039B0 B03F                    	mov	al,'?'
 26099                                  	;mov	al,WILDCHAR	; now add wildcards
 26100 000039B2 AA                      	stosb
 26101 000039B3 AA                      	stosb
 26102 000039B4 AA                      	stosb
 26103 000039B5 B000                    	mov	al,0
 26104                                  	;mov	al,ANULL	; and a terminating null	
 26105 000039B7 AA                      	stosb
 26106                                  SKIP_WILDS:
 26107                                  	;popf	; ** ; 18/03/2023
 26108 000039B8 F8                      	clc
 26109 000039B9 EB01                    	jmp	short STRIP_EXIT ; chill out...
 26110                                  
 26111                                  STRIP_ERROR:
 26112                                  	;popf	; ** ; 18/03/2023
 26113 000039BB F9                      	stc
 26114                                  STRIP_EXIT:
 26115 000039BC 5E                      	pop	si
 26116 000039BD 5F                      	pop	di
 26117 000039BE 5A                      	pop	dx
 26118 000039BF 59                      	pop	cx
 26119 000039C0 5B                      	pop	bx
 26120 000039C1 58                      	pop	ax
 26121 000039C2 C3                      	retn
 26122                                  
 26123                                  ; =============== S U B	R O U T	I N E =======================================
 26124                                  
 26125                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 26126                                  ;
 26127                                  ; structure in newly allocated memory. The argv[] structure is found at the
 26128                                  ; beginning of this area. The caller indicates how much extra space is
 26129                                  ; needed in the resulting structure; Save_Args returns a segment number and
 26130                                  ; an offset into that area, indicating where the caller may preserve its own
 26131                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 26132                                  ; ENTRY:
 26133                                  ;   BX	    --	size (in bytes) of extra area to allocate
 26134                                  ; EXIT:
 26135                                  ;   AX	    --	segment of new area.
 26136                                  ;   CF	    --	set if unable to save a copy.
 26137                                  ; NOTE(S):
 26138                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 26139                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 26140                                  ;	paragraphs.
 26141                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 26142                                  ;	as the caller of Save_Args requests.
 26143                                  ;   3)	AX is undefined if CF indicates an error.
 26144                                  
 26145                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26146                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26147                                  SAVE_ARGS:
 26148 000039C3 53                      	push	bx
 26149 000039C4 51                      	push	cx
 26150 000039C5 52                      	push	dx
 26151 000039C6 57                      	push	di
 26152 000039C7 56                      	push	si
 26153 000039C8 55                      	push	bp
 26154                                  	; 01/05/2023
 26155                                  	; 26/04/2023
 26156                                  	;pushf ; **
 26157                                  	;add	bx,1363		; space for arg structure, round up
 26158 000039C9 81C35304                	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 26159                                  			; 1092+15 ; 31/07/2024
 26160 000039CD B104                    	mov	cl,4		; to paragraph size and convert
 26161 000039CF D3EB                    	shr	bx,cl		; size in bytes to size in paragraphs
 26162 000039D1 B80048                  	mov	ax,ALLOC*256 ; 4800h
 26163 000039D4 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 26164                                  			; BX = number of 16-byte paragraphs desired
 26165 000039D6 7241                    	jc	short SAVE_ERROR ; ***
 26166 000039D8 89C5                    	mov	bp,ax		; save segment id
 26167 000039DA 06                      	push	es		; save TRANGROUP address
 26168 000039DB 8EC0                    	mov	es,ax		; switch to new memory segment
 26169                                  	; assume es:nothing
 26170                                  	;mov	cx,1348		; get back structure size
 26171 000039DD B94404                  	mov	cx,ARG_UNIT.SIZE ; 1092 ; 31/07/2024
 26172 000039E0 31FF                    	xor	di,di		; destination is new memory area
 26173                                  	;mov	si,ARG_ARGV
 26174 000039E2 BE[41A2]                	mov	si,ARG		; source is arg structure
 26175                                  	; 09/08/2024
 26176 000039E5 56                      	push	si
 26177 000039E6 F3A4                    	rep	movsb		; move that sucker!
 26178                                  	;mov	cx,arg.argvcnt 	; adjust argv pointers
 26179                                  	;mov	cx,[ARG_ARGVCNT]
 26180 000039E8 8B0E[01A5]              	mov	cx,[ARG+ARG_UNIT.argvcnt]
 26181 000039EC 31C0                    	xor	ax,ax		; base address for argv_calc
 26182                                  
 26183                                  ;	Bugbug:	What did they mean by this?
 26184                                  ;	Note that the replacement line produces exactly the same code.
 26185                                  ;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 26186                                  ;	mov	SI, OFFSET TRANGROUP:arg
 26187                                  
 26188                                  	;;mov	si,ARG_ARGV
 26189                                  	;mov	si,ARG
 26190                                  	; 09/08/2024
 26191 000039EE 5E                      	pop	si
 26192                                  SAVE_PTR_LOOP:
 26193 000039EF 49                      	dec	cx		; exhausted all args?
 26194 000039F0 7C24                    	jl	short SAVE_DONE
 26195 000039F2 89CB                    	mov	bx,cx		; get arg index and
 26196 000039F4 E8A7FC                  	call	argv_calc	; convert to a pointer
 26197                                  	;mov	dx,ds:arg.argv[bx].argpointer
 26198                                  	;mov	dx,[ARG_ARGV+bx]
 26199 000039F7 8B97[41A2]              	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 26200 000039FB 29F2                    	sub	dx,si		; adjust argpointer
 26201                                  	;mov	es:argv[BX].argpointer,dx
 26202                                  	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 26203 000039FD 268917                  	mov	[es:bx],dx
 26204                                  	;mov	dx,ds:arg.argv[bx].argstartel
 26205                                  	;mov	dx,[ARGV0_ARGSTARTEL+bx]
 26206 00003A00 8B97[44A2]              	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 26207 00003A04 29F2                    	sub	dx,si		; and adjust argstartel
 26208                                  	;mov	es:argv[bx].argstartel,dx
 26209                                  	;mov	[es:bx+3],dx
 26210 00003A06 26895703                	mov	[es:bx+ARGV_ELE.argstartel],dx
 26211                                  	;mov	dx,ds:arg.argv[bx].arg_ocomptr
 26212                                  	;mov	dx,[ARGV0_OCOMPTR+bx]
 26213 00003A0A 8B97[4AA2]              	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 26214 00003A0E 29F2                    	sub	dx,si		; and adjust arg_ocomptr
 26215                                  	;mov	es:argv[bx].arg_ocomptr,dx
 26216                                  	;mov	[es:bx+9],dx
 26217 00003A10 26895709                	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 26218 00003A14 EBD9                    	jmp	short SAVE_PTR_LOOP
 26219                                  SAVE_DONE:
 26220 00003A16 07                      	pop	es		; back we go to TRANGROUP
 26221                                  	; assume es:nothing
 26222 00003A17 89E8                    	mov	ax,bp		; restore segment id
 26223                                  	; 26/04/2023
 26224                                  	; cf = 0 ; *
 26225                                  	;jmp	short SAVE_OK
 26226                                  
 26227                                  	; 26/04/2023
 26228                                  ;SAVE_ERROR:
 26229                                  ;	; 26/04/2023
 26230                                  ;	;popf ; **
 26231                                  ;	stc
 26232                                  ;	jmp	short SAVE_EXIT
 26233                                  
 26234                                  SAVE_OK:
 26235                                  	; 26/04/2023
 26236                                  	;popf ; **
 26237                                  	; 26/04/2023
 26238                                  	; cf = 0 ; *
 26239                                  	;clc
 26240                                  SAVE_EXIT:
 26241                                  SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
 26242 00003A19 5D                      	pop	bp
 26243 00003A1A 5E                      	pop	si
 26244 00003A1B 5F                      	pop	di
 26245 00003A1C 5A                      	pop	dx
 26246 00003A1D 59                      	pop	cx
 26247 00003A1E 5B                      	pop	bx
 26248                                  answ_no:	; 26/04/2023
 26249 00003A1F C3                      	retn
 26250                                  
 26251                                  ;============================================================================
 26252                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 26253                                  ;============================================================================
 26254                                  ; 02/10/2018 - Retro DOS v3.0
 26255                                  
 26256                                  ; Title	COMMAND Language midifiable Code Transient
 26257                                  
 26258                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 26259                                  
 26260                                  ; =============== S U B	R O U T	I N E =======================================
 26261                                  
 26262                                  ; ****************************************************************
 26263                                  ; *
 26264                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 26265                                  ; *
 26266                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 26267                                  ; *		 user for Y/N if necessary. If an error occurs,
 26268                                  ; *		 set up an error message and go to CERROR.
 26269                                  ; *
 26270                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 26271                                  ; *		 Current directory set to entered directory
 26272                                  ; *
 26273                                  ; * OUTPUT:	 none
 26274                                  ; *
 26275                                  ; ****************************************************************
 26276                                  ;
 26277                                  ; ARE YOU SURE prompt when deleting *.*
 26278                                  
 26279                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26280                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26281                                  notest2:
 26282 00003A20 B90B00                  	mov	cx,11
 26283 00003A23 BE5D00                  	mov	si,FCB+1 ; 5Dh
 26284                                  ambspec:
 26285 00003A26 AC                      	lodsb
 26286 00003A27 3C3F                    	cmp	al,'?'
 26287 00003A29 7502                    	jne	short allfil
 26288 00003A2B E2F9                    	loop	ambspec
 26289                                  allfil:
 26290                                  	; 19/03/2023
 26291                                  	;cmp	cx,0
 26292 00003A2D 09C9                    	or	cx,cx
 26293 00003A2F 752E                    	jnz	short noprmpt
 26294                                  askagn:	
 26295 00003A31 BA[AF92]                	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
 26296 00003A34 E8D81A                  	call	std_printf
 26297 00003A37 BE8000                  	mov	si,80h
 26298 00003A3A 89F2                    	mov	dx,si
 26299 00003A3C C7047800                	mov	word [si],120	; zero length
 26300                                  	;mov	ax,0C0Ah
 26301 00003A40 B80A0C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
 26302 00003A43 CD21                    	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 26303                                  			; AL must be 01h,06h,07h,08h or 0Ah.
 26304 00003A45 AD                      	lodsw
 26305 00003A46 08E4                    	or	ah,ah
 26306 00003A48 74E7                    	jz	short askagn
 26307 00003A4A E8E1F0                  	call	scanoff
 26308                                  	; 19/03/2023
 26309                                  	; MSDOS 6.0
 26310 00003A4D E80C02                  	call	char_in_xlat	; Convert to upper case
 26311                                  	;retc			; return if function not supported
 26312                                  	; 19/03/2023
 26313                                  	;jnc	short check_yn
 26314                                  ;answ_no:
 26315                                  	;retn
 26316 00003A50 72CD                    	jc	short answ_no
 26317                                  
 26318                                  	; 19/03/2023
 26319                                  	; AL = 0 if it was (country depended) NO character
 26320                                  	; AL = 1 if it was (country depenced) YES character
 26321                                  
 26322                                  	; MSDOS 3.3
 26323                                  	;call	UPCONV
 26324                                  
 26325                                  	; 19/03/2023	
 26326                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26327                                  	;cmp	al,[CAPITAL_N]
 26328                                  	;jne	short CHECK_Y
 26329                                  	;retn
 26330                                  ;CHECK_Y:
 26331                                  	;cmp	al,[CAPITAL_Y]
 26332                                  	;pushf
 26333                                  	;call	CRLF2
 26334                                  	;popf
 26335                                  	;jne	short ASKAGN
 26336                                  
 26337                                  check_yn:
 26338                                  	; 19/03/2023
 26339                                  	;cmp	al,0	; NO character
 26340 00003A52 08C0                    	or	al,al
 26341 00003A54 74C9                    	jz	short answ_no
 26342                                  	;cmp	al,1	 ;YES character
 26343 00003A56 FEC8                    	dec	al ; 1 -> 0 --> zf = 1
 26344 00003A58 9C                      	pushf
 26345 00003A59 E8C5F0                  	call	CRLF2
 26346 00003A5C 9D                      	popf
 26347 00003A5D 75D2                    	jnz	short askagn
 26348                                  noprmpt:
 26349 00003A5F B413                    	mov	ah,FCB_Delete ; 13h
 26350 00003A61 BA5C00                  	mov	dx,FCB ; 5Ch
 26351 00003A64 CD21                    	int	21h	; DOS -	DELETE FILE via	FCB
 26352                                  			; DS:DX	-> FCB with filename field filled with
 26353                                  			; template for deletion ('?' wildcard allowed,but not '*')
 26354                                  			; Return: AL = 00h file	found,FFh file	not found
 26355 00003A66 FEC0                    	inc	al
 26356 00003A68 7403                    	jz	short eraerr
 26357                                  	; 26/04/2023
 26358                                  	;call	RestUDir
 26359                                  ;answ_no:
 26360                                  	;retn
 26361 00003A6A E971EF                  	jmp	RestUDir ; 26/04/2023
 26362                                  
 26363                                  	; 19/03/2023
 26364                                  	; MSDOS 6.0
 26365                                  eraerr:
 26366                                  	;invoke	set_ext_error_msg
 26367                                  				;AN022; set up the extended error
 26368 00003A6D E8C2E7                  	call	Set_Ext_Error_Msg
 26369 00003A70 52                      	push	dx		;AN022; save message
 26370                                  	;invoke	RESTUDIR
 26371 00003A71 E86AEF                  	call	RestUDir
 26372 00003A74 5A                      	pop	dx		;AN022; restore message
 26373                                  	
 26374 00003A75 833E[D091]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 26375                                  				;AN022; convert no more files to
 26376 00003A7A 7506                    	jne	short cerrorj2	;AN022;  file not found
 26377 00003A7C C706[D091]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
 26378                                  				;AN000; get message number in control block
 26379                                  cerrorj2:
 26380 00003A82 E91DF4                  	jmp	cerror
 26381                                  	
 26382                                  	; 19/03/2023
 26383                                  	; MSDOS 3.3
 26384                                  ;ERAERR:	
 26385                                  	;mov	ah,Set_DMA ; 1Ah
 26386                                  	;mov	dx,FCB ; 5Ch
 26387                                  	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 26388                                  	;			; DS:DX	-> disk	transfer buffer
 26389                                  	;mov	ah,Dir_Search_First ; 11h
 26390                                  	;int	21h		; DOS -	SEARCH FIRST USING FCB
 26391                                  	;			; DS:DX	-> FCB
 26392                                  	;push	ax
 26393                                  	;call	RESTUDIR
 26394                                  	;pop	ax
 26395                                  	;mov	dx,FNOTFOUNDPTR
 26396                                  	;inc	al
 26397                                  	;jz	short CERRORJ
 26398                                  	;mov	dx,ACCDENPTR
 26399                                  	;jmp	CERROR
 26400                                  
 26401                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26402                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h
 26403                                  
 26404                                  ; ****************************************************************
 26405                                  ; *
 26406                                  ; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
 26407                                  ; *
 26408                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 26409                                  ; *		 user for Y/N where necessary. If an error occurs
 26410                                  ; *		 set up and error message and transfer control
 26411                                  ; *		 to CERROR.
 26412                                  ; *
 26413                                  ; * INPUT:	 FCB at 5Ch set up with filename(s) entered
 26414                                  ; *		 Current directory set to entered directory
 26415                                  ; *
 26416                                  ; * OUTPUT:	 none
 26417                                  ; *
 26418                                  ; ****************************************************************
 26419                                  
 26420                                  	; 19/03/2023
 26421                                  slashp_erase:				;AN000; entry point
 26422                                  	;invoke	build_dir_string	;AN000; set up current directory string for output
 26423 00003A85 E814E9                  	call	build_dir_string
 26424                                  
 26425 00003A88 B41A                    	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
 26426                                  	;mov	dx,offset trangroup:destdir
 26427 00003A8A BA[E79F]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 26428 00003A8D CD21                    	int	21h			;AN000;
 26429                                  
 26430                                  	;mov	ah,11h
 26431 00003A8F B411                    	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
 26432 00003A91 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
 26433 00003A94 CD21                    	int	21h			;AN000;
 26434 00003A96 FEC0                    	inc	al			;AN000; did an error occur
 26435                                  	;jz	short eraerr		;AN022; go to error exit
 26436                                  	; 26/04/2023
 26437 00003A98 7502                    	jnz	short delete_prompt_loop
 26438                                  
 26439                                  	; 26/04/2023
 26440                                  stop_del:
 26441 00003A9A EBD1                    	jmp	short eraerr		;AN022; go to error exit - need long jmp
 26442                                  
 26443                                  delete_prompt_loop:			;AN000;
 26444                                  	;mov	si,offset trangroup:destdir+1
 26445 00003A9C BE[E89F]                	mov	si,DESTDIR+1		;AN000; set up FCB as source
 26446                                  	;mov	di,offset trangroup:dest
 26447 00003A9F BF[B79F]                	mov	di,DEST			;AN000; set up dest as target
 26448 00003AA2 A0[F89D]                	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
 26449 00003AA5 AA                      	stosb				;AN000;   of DEST
 26450                                  	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
 26451 00003AA6 E8A4F0                  	call	FCB_TO_ASCZ
 26452                                  
 26453                                  slashp_askagn:				;AN000;
 26454 00003AA9 E875F0                  	call	CRLF2			;AN000; print out carriage return, line feed
 26455                                  	;mov	dx,offset trangroup:bwdbuf
 26456 00003AAC BA[2AA0]                	mov	dx,BWDBUF		;AN000; print out current directory string
 26457 00003AAF 89D3                    	mov	bx,dx			;AN000; get string pointer in bx
 26458 00003AB1 807F0300                	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
 26459                                  					;AN000; see if only D:\,0
 26460 00003AB5 7504                    	jnz	short not_del_root	;AN000; no continue
 26461 00003AB7 C6470200                	mov	byte [bx+2],END_OF_LINE_OUT ; 0
 26462                                  					;AN000; yes, get rid of \ ;
 26463                                  not_del_root:				;AN000;
 26464 00003ABB 8916[91A0]              	mov	[string_ptr_2],dx 	;AN000;
 26465                                  	;mov	dx,offset trangroup:string_buf_ptr
 26466 00003ABF BA[9793]                	mov	dx,string_buf_ptr	;AN000;
 26467                                  	;invoke	std_printf		;AN000;
 26468 00003AC2 E84A1A                  	call	std_printf
 26469                                  	;mov	dx,offset trangroup:dest
 26470 00003AC5 BA[B79F]                	mov	dx,DEST			;AN000; print out file name string
 26471 00003AC8 8916[91A0]              	mov	[string_ptr_2],dx 	;AN000;
 26472                                  	;mov	dx,offset trangroup:string_buf_ptr
 26473 00003ACC BA[9793]                	mov	dx,string_buf_ptr	;AN000;
 26474                                  	;invoke	std_printf		;AN000;
 26475 00003ACF E83D1A                  	call	std_printf
 26476                                  	;mov	dx,offset trangroup:Del_Y_N_Ptr
 26477 00003AD2 BA[AC92]                	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
 26478                                  	;invoke	std_printf		;AN000;
 26479 00003AD5 E8371A                  	call	std_printf
 26480                                  
 26481                                  ;;M029	mov	si,80H			;AN000; set up buffer for input
 26482                                  ;;M029	mov	dx,si			;AN000;
 26483                                  ;;M029	mov	word ptr [si],combuflen ;AN000;
 26484                                  ;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
 26485                                  ;;M029	int	21h			;AN000; get input from the user
 26486                                  ;;M029	lodsw				;AN000;
 26487                                  ;;M029	or	ah,ah			;AN000; was a character entered?
 26488                                  ;;M029	jz	short slashp_askagn	;AN000; no - ask again
 26489                                  ;;M029	invoke	scanoff 		;AN000; scan off leading delimiters
 26490                                  
 26491                                  ;	Get a single character input.
 26492                                  
 26493                                  	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
 26494                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
 26495 00003AD8 B8010C                  	mov	ax,0C01h
 26496 00003ADB CD21                    	int	21h			;M029
 26497                                  
 26498 00003ADD E87C01                  	call	char_in_xlat		;AN000; yes - upper case it
 26499                                  	;retc				;AN000; return if function not supported
 26500                                  	; 19/03/2023
 26501 00003AE0 7301                    	jnc	short slashp_check_yn
 26502                                  slashp_ans_no:
 26503 00003AE2 C3                      	retn
 26504                                  
 26505                                  slashp_check_yn:
 26506                                  	; 19/03/2023
 26507                                  	; AL = 0 if it was (country depended) NO character
 26508                                  	; AL = 1 if it was (country depenced) YES character
 26509                                  
 26510                                  	;cmp	al,capital_n		;AN000; was it no?
 26511                                  	;cmp	al,0
 26512 00003AE3 20C0                    	and	al,al ; 0
 26513 00003AE5 7420                    	jz	short next_del_file	;AN000; yes - don't delete file
 26514                                  	;cmp	al,capital_y		;AN000; was it yes?
 26515                                  	;cmp	al,1
 26516 00003AE7 FEC8                    	dec	al  ; 1-> 0 --> zf = 1
 26517                                  	;jz	short delete_this_file	;AN000; yes - delete the file
 26518                                  	;jmp	short slashp_askagn	;AN000; it was neither - ask again
 26519                                  	; 19/03/2023
 26520 00003AE9 75BE                    	jnz	short slashp_askagn
 26521                                  
 26522                                  delete_this_file:			;AN000;
 26523 00003AEB B413                    	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
 26524                                  	;mov	dx,offset trangroup:destdir
 26525 00003AED BA[E79F]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 26526 00003AF0 CD21                    	int	21h			;AN000;
 26527 00003AF2 FEC0                    	inc	al			;AN000; did an error occur?
 26528 00003AF4 7511                    	jnz	short next_del_file	;AN000; no - get next file
 26529                                  ;
 26530                                  ;M041; Begin changes
 26531                                  ; We got an error deleting the file. If this is access denied, we can go on
 26532                                  ;to the next file after printing an error message.
 26533                                  ;
 26534                                  	;invoke	Get_ext_error_number	;see what error we got
 26535 00003AF6 E849E7                  	call	get_ext_error_number
 26536 00003AF9 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 26537                                  					;is it access denied?
 26538 00003AFC 759C                    	jne	short stop_del		;no, some other error
 26539                                  	;invoke	CrLf2			;print a CR-LF
 26540 00003AFE E820F0                  	call	CRLF2
 26541                                  	;invoke set_ext_error_msg	;error message
 26542 00003B01 E82EE7                  	call	Set_Ext_Error_Msg
 26543                                  	;invoke	std_eprintf		;"Access denied"
 26544 00003B04 E8001A                  	call	std_eprintf
 26545                                  	; 26/04/2023
 26546                                  	;jmp	short next_del_file	;try next file
 26547                                  	; 26/04/2023
 26548                                  ;stop_del:
 26549                                  ;;
 26550                                  ;;M041; End changes
 26551                                  ;;
 26552                                  ;	jmp	eraerr			;AN022; go to error exit - need long jmp
 26553                                  
 26554                                  next_del_file:				;AN000;
 26555                                  ;
 26556                                  ; M050 - begin
 26557                                  ; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
 26558                                  ;       with /protect+ and /light+ makes it intercept all
 26559                                  ;       deletes. This hook does not save and restore the DTA correctly.
 26560                                  ;       They save the DWORD in a WORD by mistake! They save both the
 26561                                  ;       segment and the offset in the SAME variable (WORD)!!!
 26562                                  ;
 26563 00003B07 B41A                    	mov	ah,Set_DMA ; 1Ah
 26564                                  	;mov	dx,offset trangroup:destdir
 26565 00003B09 BA[E79F]                	mov	dx,DESTDIR
 26566 00003B0C CD21                    	int	21h
 26567                                  ;
 26568                                  ; M050 - end
 26569                                  
 26570 00003B0E B412                    	mov	ah,Dir_Search_Next ; 12h
 26571                                  					;AN000; search for another file
 26572 00003B10 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000;
 26573 00003B13 CD21                    	int	21h			;AN000;
 26574 00003B15 FEC0                    	inc	al			;AN000; was a file found?
 26575                                  	;jz	short slash_p_exit	;AN000; no - exit
 26576                                  	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
 26577                                  	; 26/04/2023
 26578 00003B17 7583                    	jnz	short delete_prompt_loop
 26579                                  
 26580                                  slash_p_exit:
 26581                                  	;invoke	get_ext_error_number	;AN022; get the extended error number
 26582 00003B19 E826E7                  	call	get_ext_error_number
 26583 00003B1C 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
 26584 00003B1F 7403                    	jz	short good_erase_exit 	;AN022; yes - clean exit
 26585 00003B21 E961E4                  	jmp	extend_setup		;AN022; go issue error message
 26586                                  
 26587                                  good_erase_exit:
 26588                                  	;invoke	restudir		;AN000; we're finished - restore user's dir
 26589 00003B24 E8B7EE                  	call	RestUDir
 26590                                  	;call	CRLF2			;AN000; print out carriage return, line feed
 26591                                  	;retn				;AN000; exit
 26592                                  	; 19/03/2023
 26593 00003B27 E9F7EF                  	jmp	CRLF2
 26594                                  
 26595                                  ; =============== S U B	R O U T	I N E =======================================
 26596                                  
 26597                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 26598                                  
 26599                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26600                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26601                                  _ECHO:
 26602 00003B2A E89900                  	call	ON_OFF
 26603 00003B2D 7212                    	jb	short DOEMES
 26604 00003B2F 8E1E[F39D]              	mov	ds,[RESSEG]
 26605 00003B33 7506                    	jnz	short ECH_OFF
 26606 00003B35 800E[3B02]01            	or	byte [EchoFlag],1
 26607 00003B3A C3                      	retn
 26608                                  
 26609                                  ECH_OFF:
 26610 00003B3B 8026[3B02]FE            	and	byte [EchoFlag],0FEh
 26611 00003B40 C3                      	retn
 26612                                  
 26613                                  	; 19/03/2023
 26614                                  	; MSDOS 6.0 (& MSDOS 5.0)
 26615                                  ;CERRORJ:
 26616                                  	;jmp	cerror
 26617                                  
 26618                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 26619                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 26620                                  
 26621                                  DOEMES:
 26622                                  	; 19/03/2023
 26623                                  	; MSDOS 6.0
 26624                                  	;cmp	cl,0		;AC000; was anything on the line?
 26625 00003B41 20C9                    	and	cl,cl
 26626 00003B43 7409                    	jz	short PECHO	; just display current state.
 26627 00003B45 BA8200                  	mov	dx,82h		; Skip one char after "ECHO"
 26628 00003B48 E82FF0                  	call	CRPRINT
 26629 00003B4B E9D3EF                  	jmp	CRLF2
 26630                                  
 26631                                  	; 19/03/2023
 26632                                  	; MSDOS 3.3
 26633                                  	;call	MOVE_TO_FIRST_ARG
 26634                                  	;jz	short PECHO
 26635                                  	;mov	dx,82h
 26636                                  	;call	CRPRINT
 26637                                  	;jmp	CRLF2
 26638                                  
 26639                                  PECHO:
 26640                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26641 00003B4E 8E1E[F39D]              	mov	ds,[RESSEG]
 26642 00003B52 8A1E[3B02]              	mov	bl,[EchoFlag]
 26643 00003B56 0E                      	push	cs
 26644 00003B57 1F                      	pop	ds
 26645 00003B58 80E301                  	and	bl,1
 26646 00003B5B BA[5393]                	mov	dx,EchoMes_Ptr
 26647 00003B5E EB24                    	jmp	short PYN
 26648                                  
 26649                                  ; ---------------------------------------------------------------------------
 26650                                  
 26651                                  	; 19/03/2023
 26652                                  	; MSDOS 3.3
 26653                                  CERRORJ:
 26654 00003B60 E93FF3                  	jmp	cerror
 26655                                  
 26656                                  ; =============== S U B	R O U T	I N E =======================================
 26657                                  
 26658                                  	; 19/03/2023
 26659                                  	; MSDOS 3.3
 26660                                  ;MOVE_TO_FIRST_ARG:
 26661                                  	;mov	si,81h
 26662                                  	;call	SCANOFF
 26663                                  	;cmp	al,0Dh
 26664                                  	;retn
 26665                                  
 26666                                  ; =============== S U B	R O U T	I N E =======================================
 26667                                  
 26668                                  CNTRLC:
 26669 00003B63 E86000                  	call	ON_OFF
 26670 00003B66 B80133                  	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
 26671 00003B69 720C                    	jc	short PCNTRLC
 26672 00003B6B 7505                    	jnz	short CNTRLC_OFF
 26673 00003B6D B201                    	mov	dl,1
 26674 00003B6F CD21                    	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 26675                                  			; AL = 00h get state / 01h set state / 02h set AND get
 26676                                  			; DL = 00h for OFF or 01h for ON
 26677 00003B71 C3                      	retn
 26678                                  
 26679                                  ; ---------------------------------------------------------------------------
 26680                                  
 26681                                  CNTRLC_OFF:
 26682 00003B72 30D2                    	xor	dl,dl
 26683 00003B74 CD21                    	int	21h		; Turn off ^C check
 26684 00003B76 C3                      	retn
 26685                                  
 26686                                  ; ---------------------------------------------------------------------------
 26687                                  
 26688                                  PCNTRLC:
 26689                                  	; 19/03/2023
 26690                                  	; MSDOS 6.0
 26691                                  	;cmp	cl,0		;AC000; rest of line blank?
 26692 00003B77 08C9                    	or	cl,cl
 26693 00003B79 75E5                    	jnz	short CERRORJ 	; no, oops!
 26694                                  
 26695                                  	; 19/03/2023
 26696                                  	; MSDOS 3.3
 26697                                  	;call	MOVE_TO_FIRST_ARG
 26698                                  	;jnz	short CERRORJ
 26699                                  ;pccont:
 26700                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26701 00003B7B 30C0                    	xor	al,al
 26702 00003B7D CD21                    	int	21h		; get Ctrl-Break state (ah=33h)
 26703 00003B7F 88D3                    	mov	bl,dl
 26704 00003B81 BA[3793]                	mov	dx,CtrlcMes_Ptr
 26705                                  
 26706                                  ; ---------------------------------------------------------------------------
 26707                                  
 26708                                  PYN:	; write "ON" or "OFF" state 
 26709                                  
 26710                                  	; 26/04/2023
 26711                                  	; 19/03/2023
 26712                                  	; MSDOS 3.3
 26713                                  	;call	STD_PRINTF
 26714                                  	;mov	dx,ONMES_PTR	;AC000; get ON pointer
 26715                                  	;or	bl,bl
 26716                                  	;jnz	short PRINTVAL
 26717                                  	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
 26718                                  	
 26719                                  	; 26/04/2023
 26720                                  	; 19/03/2023
 26721                                  	; MSDOS 6.0
 26722 00003B84 BE[6493]                	mov	si,ONMES_PTR
 26723 00003B87 08DB                    	or	bl,bl
 26724 00003B89 7503                    	jnz	short PRINTVAL
 26725 00003B8B BE[6193]                	mov	si,OFFMES_PTR
 26726                                  PRINTVAL:
 26727                                  	; 19/03/2023
 26728                                  	; MSDOS 3.3
 26729                                  	;jmp	STD_PRINTF
 26730                                  
 26731                                  	; 19/03/2023
 26732                                  	; MSDOS 6.0
 26733 00003B8E 52                      	push	dx		;AN000; save offset of message block
 26734 00003B8F 89D3                    	mov	bx,dx		;AN000; save offset value
 26735 00003B91 AD                      	lodsw			;AN000; get message number of on or off
 26736 00003B92 B6FF                    	mov	dh,util_msg_class ; -1 ; 0FFh
 26737                                  				;AN000; this is a utility message
 26738 00003B94 E85B1A                  	call	TSYSGETMSG	;AN000; get the address of the message
 26739                                  	;add	bx,5
 26740 00003B97 83C305                  	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
 26741                                  	
 26742 00003B9A 8937                    	mov	[bx],si		;AN000; put the offset in the message block
 26743 00003B9C 5A                      	pop	dx		;AN000; get message back
 26744 00003B9D E86F19                  	call	std_printf	;AC000; go print message
 26745 00003BA0 C7070000                	mov	word [bx],0	;AN000; zero out message pointer
 26746 00003BA4 C3                      	retn			;AN000; exit
 26747                                  
 26748                                  ; =============== S U B	R O U T	I N E =======================================
 26749                                  
 26750                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
 26751                                  VERIFY:
 26752 00003BA5 E81E00                  	call	ON_OFF
 26753 00003BA8 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 26754 00003BAB 720A                    	jc	short PVERIFY
 26755 00003BAD 7503                    	jnz	short VER_OFF
 26756 00003BAF CD21                    	int	21h	; DOS -	SET VERIFY FLAG
 26757                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 26758 00003BB1 C3                      	retn
 26759                                  
 26760                                  ; ---------------------------------------------------------------------------
 26761                                  
 26762                                  VER_OFF:
 26763 00003BB2 FEC8                    	dec	al
 26764 00003BB4 CD21                    	int	21h		; Turn off verify after write
 26765 00003BB6 C3                      	retn
 26766                                  
 26767                                  ; ---------------------------------------------------------------------------
 26768                                  
 26769                                  PVERIFY:
 26770                                  	; 19/03/2023
 26771                                  	; MSDOS 6.0
 26772                                  	;cmp	cl,0		;AC000; is rest of line blank?
 26773 00003BB7 20C9                    	and	cl,cl
 26774 00003BB9 75A5                    	jnz	short CERRORJ 	; nope...
 26775                                  
 26776                                  	 ;19/03/2023
 26777                                  	; MSDOS 3.3
 26778                                  	;call	MOVE_TO_FIRST_ARG
 26779                                  	;jnz	short CERRORJ
 26780                                  
 26781 00003BBB B454                    	mov	ah,Get_Verify_On_Write ; 54h
 26782 00003BBD CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 26783                                  				; Return: AL = 00h if flag OFF
 26784                                  				; AL = 01h if flag ON
 26785 00003BBF 88C3                    	mov	bl,al
 26786 00003BC1 BA[4593]                	mov	dx,VeriMes_Ptr
 26787 00003BC4 EBBE                    	jmp	short PYN
 26788                                  
 26789                                  ; =============== S U B	R O U T	I N E =======================================
 26790                                  
 26791                                  ; ****************************************************************
 26792                                  ; *
 26793                                  ; * ROUTINE:	 ON_OFF
 26794                                  ; *
 26795                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 26796                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 26797                                  ; *		 routines.
 26798                                  ; *
 26799                                  ; * INPUT:	 command line at offset 81H
 26800                                  ; *		 PARSE_BREAK control block
 26801                                  ; *
 26802                                  ; * OUTPUT:	 If carry is clear
 26803                                  ; *		    If ON is found
 26804                                  ; *		       Zero flag set
 26805                                  ; *		    If OFF is found
 26806                                  ; *		       Zero flag clear
 26807                                  ; *		 If carry set
 26808                                  ; *		    If nothing on command line
 26809                                  ; *		       CL set to zero
 26810                                  ; *		    If error
 26811                                  ; *		       CL contains error value from parse
 26812                                  ; *
 26813                                  ; ****************************************************************
 26814                                  
 26815                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26816                                  ON_OFF:
 26817 00003BC6 BE8100                  	mov	si,81h
 26818                                  
 26819                                  	; 19/03/2023
 26820                                  	; MSDOS 3.3
 26821                                  	;call	SCANOFF		; scan off leading blanks & equal
 26822                                  	;cmp	al,0Dh		; are we at end of line?
 26823                                  	;je	short BAD_ONF	; yes, return error
 26824                                  	;lodsw
 26825                                  	;or	ax,2020h	; convert to lowercase
 26826                                  	;cmp	ax,6E6Fh ;'on'
 26827                                  	;je	short ON_CHECK
 26828                                  	;cmp	ax,666Fh ;'of'
 26829                                  	;jne	short BAD_ONF
 26830                                  	;lodsb
 26831                                  	;or	al,20h		; convert to lowercase		
 26832                                  	;cmp	al,66h	 ; 'f'
 26833                                  	;jne	short BAD_ONF	
 26834                                  	;or	al,66h ; or al,'f'
 26835                                  	;jmp	short OFF_CHECK
 26836                                  ;ON_CHECK:
 26837                                  	;xor	al,al
 26838                                  ;OFF_CHECK:
 26839                                  	;lahf
 26840                                  	;mov	bx,ax
 26841                                  	;call	SCANOFF		; scan off leading blanks & equal
 26842                                  	;cmp	al,0Dh		; are we at end of line?	
 26843                                  	;jne	short BAD_ONF	; no, return error
 26844                                  	;mov	ax,bx
 26845                                  	;sahf
 26846                                  	;clc
 26847                                  	;retn
 26848                                  
 26849                                  	; 19/03/2023
 26850                                  	; MSDOS 6.0
 26851                                  scan_on_off:			;AN032; scan off leading blanks & equal
 26852 00003BC9 AC                      	lodsb			;AN032; get a char
 26853                                  	;cmp	al,blank	;AN032; if whitespace
 26854 00003BCA 3C20                    	cmp	al,20h
 26855 00003BCC 74FB                    	je	short scan_on_off
 26856                                  				;AN032;    keep scanning
 26857 00003BCE 3C09                    	cmp	al,tab_chr	;AN032; if tab
 26858                                  	;cmp	al,09h
 26859 00003BD0 74F7                    	je	short scan_on_off
 26860                                  				;AN032;    keep scanning
 26861                                  	;cmp	al,equal_chr	;AN032; if equal char
 26862 00003BD2 3C3D                    	cmp	al,'=' ; 3Dh
 26863 00003BD4 7401                    	je	short parse_on_off
 26864                                  				;AN032;    start parsing
 26865 00003BD6 4E                      	dec	si		;AN032; if none of above - back up
 26866                                  
 26867                                  parse_on_off:			;AN032;    and start parsing
 26868 00003BD7 BF[A197]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26869 00003BDA 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 26870 00003BDC 31D2                    	xor	dx,dx		;AN000;
 26871 00003BDE E8780E                  	call	cmd_parse	;AC000; call parser
 26872                                  	;cmp	ax,-1 ; 0FFFFh
 26873 00003BE1 83F8FF                  	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 26874 00003BE4 742E                    	je	short BADONF	;AC000; yes, return error
 26875                                  	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
 26876                                  	;cmp	ax,0
 26877 00003BE6 21C0                    	and	ax,ax ; ax = 0 ?
 26878 00003BE8 7404                    	jz	short on_off_there
 26879                                  				;AN000; no - continue
 26880 00003BEA 89C1                    	mov	cx,ax		;AN000; yes - set cl to error code
 26881 00003BEC EB26                    	jmp	short BADONF	;AN000; return error
 26882                                  
 26883                                  on_off_there:
 26884 00003BEE 803E[E2A9]FF            	cmp	byte [PARSE1_CODE],-1 ; 0FFh
 26885                                  				;AN014; was a valid positional present?
 26886 00003BF3 7505                    	jnz	short good_on_off
 26887                                  				;AN014; yes - continue
 26888 00003BF5 B90A00                  	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
 26889                                  	;mov	cx,10 ; 0Ah
 26890 00003BF8 EB1A                    	jmp	short BADONF	;AN014; return error
 26891                                  
 26892                                  good_on_off:			;AN014;
 26893 00003BFA 31C0                    	xor	ax,ax		;AC000; set up return code for
 26894 00003BFC 0A06[E2A9]              	or	al,[PARSE1_CODE]
 26895                                  				;AC000;    ON or OFF in AX
 26896 00003C00 9C                      	pushf			;AN000; save flags
 26897 00003C01 BF[A197]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26898 00003C04 31D2                    	xor	dx,dx		;AN000;
 26899 00003C06 E8500E                  	call	cmd_parse	;AN000; call parser
 26900 00003C09 83F8FF                  	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 26901                                  	;cmp	ax,-1 ; 0FFFFh
 26902 00003C0C 7503                    	jne	short BADONF_flags
 26903                                  				;AN000; NO, return error
 26904 00003C0E 9D                      	popf			;AN000; restore flags
 26905 00003C0F F8                      	clc			;AC000; no error
 26906                                  	;jmp	short on_off_end
 26907                                  				;AN000; return to caller
 26908                                  	; 26/04/2023
 26909 00003C10 C3                      	retn
 26910                                  
 26911                                  BADONF_flags:
 26912 00003C11 89C1                    	mov	cx,ax
 26913 00003C13 9D                      	popf
 26914                                  
 26915                                  ; ---------------------------------------------------------------------------
 26916                                  
 26917                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 26918                                  ; and return the error
 26919                                  
 26920                                  BADONF:
 26921 00003C14 BA[1493]                	mov	dx,bad_on_off_ptr
 26922 00003C17 F9                      	stc
 26923                                  on_off_end:
 26924 00003C18 C3                      	retn
 26925                                  
 26926                                  ;============================================================================
 26927                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 26928                                  ;============================================================================
 26929                                  ; 02/10/2018 - Retro DOS v3.0
 26930                                  
 26931                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 26932                                  
 26933                                  ; =============== S U B	R O U T	I N E =======================================
 26934                                  
 26935                                  	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26936                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
 26937                                  	
 26938                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 26939                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3E20h
 26940                                  PRINT_DATE:
 26941                                  	; 20/03/2023
 26942                                  	; MSDOS 3.3
 26943                                  	;push	es
 26944                                  	;push	di
 26945                                  	;push	cs
 26946                                  	;pop	es
 26947                                  	;mov	di,ARG_BUF
 26948                                  	;mov	ah,Get_Date ; 2Ah
 26949                                  	;int	21h	; DOS -	GET CURRENT DATE
 26950                                  	;		; Return: DL = day,DH = month,	CX = year
 26951                                  	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
 26952                                  	;cbw
 26953                                  	;call	GETDATE
 26954                                  	;call	P_DATE
 26955                                  	;xor	al,al
 26956                                  	;stosb
 26957                                  	;mov	dx,ARG_BUF_PTR
 26958                                  	;call	STD_PRINTF
 26959                                  		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 26960                                  	;pop	es ; !!??!! 
 26961                                  	;pop	di
 26962                                  	;retn
 26963                                  
 26964                                  	; 20/03/2023
 26965                                  	; MSDOS 6.0
 26966 00003C19 06                      	push	es
 26967 00003C1A 57                      	push	di
 26968 00003C1B 0E                      	push	cs
 26969 00003C1C 07                      	pop	es
 26970 00003C1D E81300                  	call	GetDate 		; get date
 26971 00003C20 86F2                    	xchg	dh,dl			;AN000; switch month & day
 26972 00003C22 890E[CE93]              	mov	[promptDat_yr],cx 	;AC000; put year into message control block
 26973 00003C26 8916[D093]              	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
 26974 00003C2A BA[BE93]                	mov	dx,promptdat_ptr	;AC000; set up message for output
 26975 00003C2D E8DF18                  	call	std_printf
 26976                                  	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
 26977                                  	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
 26978 00003C30 5F                      	pop	di			;AC000; restore di,es
 26979 00003C31 07                      	pop	es			;AC000;
 26980 00003C32 C3                      	retn
 26981                                  
 26982                                  ; ---------------------------------------------------------------------------
 26983                                  
 26984                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26985                                  
 26986                                  ;GETDATE:
 26987                                  	; 21/03/2023
 26988                                  	; MSDOS 3.3
 26989                                  	;mov	si,ax
 26990                                  	;shl	si,1
 26991                                  	;add	si,ax
 26992                                  	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 26993                                  	;mov	bx,cx
 26994                                  	;mov	cx,3
 26995                                  	;rep	movsb
 26996                                  	;mov	al,' '
 26997                                  	;stosb
 26998                                  	;retn
 26999                                  
 27000                                  	; 21/03/2023
 27001                                  	; MSDOS 6.0
 27002                                  
 27003                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 27004                                  ; for output. Date will be returned in CX,DX.
 27005                                  
 27006                                  GetDate:
 27007 00003C33 BF[87A7]                	mov	di,Arg_Buf		;AC000; target for day of week
 27008 00003C36 B42A                    	mov	ah,Get_Date ;2Ah	;AC000; get current date
 27009 00003C38 CD21                    	int	21h			;AC000; Get date in CX:DX
 27010 00003C3A 98                      	cbw				;AC000;
 27011 00003C3B 51                      	push	cx			;AN000; save date returned in
 27012 00003C3C 52                      	push	dx			;AN000;  CX:DX
 27013 00003C3D 89C6                    	mov	si,ax
 27014 00003C3F D1E6                    	shl	si,1
 27015 00003C41 01C6                    	add	si,ax			; SI=AX*3
 27016 00003C43 89F1                    	mov	cx,si			;AN000; save si
 27017 00003C45 A1[8792]                	mov	ax,[WeekTab]		;AN000; get message number of weektab
 27018 00003C48 B6FF                    	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
 27019 00003C4A 57                      	push	di			;AN000; save argument buffer
 27020 00003C4B E8A419                  	call	TSYSGETMSG		;AN000; get the address of the message
 27021 00003C4E 5F                      	pop	di			;AN000; retrieve argument buffer
 27022 00003C4F 01CE                    	add	si,cx			;AC000; get day of week
 27023 00003C51 B90300                  	mov	cx,3
 27024 00003C54 F3A4                      	rep	movsb
 27025 00003C56 B000                    	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
 27026 00003C58 AA                      	stosb
 27027 00003C59 5A                      	pop	dx			;AN000; get back date
 27028 00003C5A 59                      	pop	cx			;AN000;
 27029 00003C5B C3                      	retn
 27030                                  
 27031                                  ; =============== S U B	R O U T	I N E =======================================
 27032                                  
 27033                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27034                                  
 27035                                  	; MSDOS 6.0
 27036                                  
 27037                                  ; This routine determines whether the character in AL is a
 27038                                  ; Yes or No character. On return, if AL=0, the character is
 27039                                  ; No, if AL=1, the character is Yes.
 27040                                  
 27041                                  ;	assume	ds:trangroup
 27042                                  
 27043                                  char_in_xlat:	; proc	near
 27044                                  	; 21/03/2023
 27045 00003C5C 88C2                    	mov	dl,al			;AC000; get character into DX
 27046 00003C5E 30F6                    	xor	dh,dh			;AC000;
 27047                                  	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
 27048 00003C60 B82365                  	mov	ax,6523h
 27049 00003C63 CD21                    	int	21h			;AC000;
 27050 00003C65 C3                      	retn
 27051                                  
 27052                                  ;char_in_xlat	endp
 27053                                  
 27054                                  ;============================================================================
 27055                                  ; TENV.ASM, MSDOS 6.0, 1991
 27056                                  ;============================================================================
 27057                                  ; 02/10/2018 - Retro DOS v3.0
 27058                                  
 27059                                  ;	Environment utilities and misc. routines
 27060                                  
 27061                                  ; MSDOS 6.0
 27062                                  ; ****************************************************************
 27063                                  ; *
 27064                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 27065                                  ; *
 27066                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 27067                                  ; *		 the character in AL from the file upper case table
 27068                                  ; *		 in DOS if character if above  ascii 128, else
 27069                                  ; *		 subtracts 20H if between "a" and "z".
 27070                                  ; *
 27071                                  ; * INPUT:	 AL	      char to be upper cased
 27072                                  ; *		 FUCASE_ADDR  set to the file upper case table
 27073                                  ; *
 27074                                  ; * OUTPUT:	 AL	      upper cased character
 27075                                  ; *
 27076                                  ; ****************************************************************
 27077                                  ;
 27078                                  ;assume	ds:trangroup				;AN000;
 27079                                  ;
 27080                                  ;upconv	proc	near				;AN000;
 27081                                  ;
 27082                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 27083                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 27084                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 27085                                  ;	push	ds				;AN000;
 27086                                  ;	push	bx				;AN000;
 27087                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 27088                                  ;assume	ds:resgroup				;AN000;
 27089                                  ;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
 27090                                  ;	add	bx,2				;AN000;  skip over first word
 27091                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 27092                                  ;	pop	bx				;AN000;
 27093                                  ;	pop	ds				;AN000;
 27094                                  ;assume	ds:trangroup				;AN000;
 27095                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 27096                                  ;
 27097                                  ;oth_fucase:					;AN000;
 27098                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 27099                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 27100                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 27101                                  ;	ja	upconv_end			;AC000;
 27102                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 27103                                  ;
 27104                                  ;upconv_end:					;AN000;
 27105                                  ;	ret
 27106                                  ;
 27107                                  ;upconv	endp					;AN000;
 27108                                  
 27109                                  ;============================================================================
 27110                                  ; COPY.ASM, MSDOS 6.0, 1991
 27111                                  ;============================================================================
 27112                                  ; 01/10/2018 - Retro DOS v3.0
 27113                                  
 27114                                  ;	title	COMMAND COPY routines.
 27115                                  
 27116                                  ;/*
 27117                                  ; *                      Microsoft Confidential
 27118                                  ; *                      Copyright (C) Microsoft Corporation 1991
 27119                                  ; *                      All Rights Reserved.
 27120                                  ; */
 27121                                  
 27122                                  ;***	COPY.ASM
 27123                                  
 27124                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 27125                                  
 27126                                  
 27127                                  ;***	MODIFICATION HISTORY
 27128                                  
 27129                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 27130                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 27131                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 27132                                  ;	     to tokens which begin with path characters so that PARSELINE
 27133                                  ;	     will work correctly.
 27134                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 27135                                  ;	     individual tokens. That distinction is no longer needed for
 27136                                  ;	     FOR loop processing.
 27137                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
 27138                                  ;	     1 when Cparse is called from COPY.
 27139                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 27140                                  ;	     mod. It now is conditional on flag like previous mod.
 27141                                  ;11/21/83 NP  Added printf
 27142                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 27143                                  ;	     be added to a token.
 27144                                  ;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
 27145                                  ;	     NOTE: DestHand is the destination handle. There are two
 27146                                  ;	     special values: -1 meaning destination was never opened and
 27147                                  ;	     0 which means that the destination has been openned and
 27148                                  ;	     closed.
 27149                                  ;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
 27150                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 27151                                  ;	     lost on large and multiple file (wildcard) copies.
 27152                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 27153                                  ;	     destination are not equal.
 27154                                  ;
 27155                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 27156                                  ;	     first source file AND we run out of disk space before
 27157                                  ;	     completing the concatenation, restore the first source
 27158                                  ;	     file as best we can. See SeekEnd and CopErr. Bug #859.
 27159                                  ;
 27160                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 27161                                  ;		instead of compatibility mode. This gives lesser sharing
 27162                                  ;		violations when files are opened for read on a copy.
 27163                                  
 27164                                  ; ---------------------------------------------------------------------------
 27165                                  ;***	COPY CODE
 27166                                  ; ---------------------------------------------------------------------------
 27167                                  
 27168                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 27169                                  
 27170                                  ; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27171                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h
 27172                                  
 27173                                  ; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27174                                  ; MSDOS 6.22 - COMMAND.COM, transient portion/segment offset 3E6Dh
 27175                                  
 27176                                  COPY:
 27177                                  	; 	Initialize internal variables.
 27178                                  
 27179 00003C66 31C0                    	xor	ax,ax		; AX = 0
 27180 00003C68 A3[93A0]                	mov	[Copy_num],ax	; # files copied (destinations) = 0
 27181 00003C6B A3[C3A1]                	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 27182 00003C6E A3[0FA1]                	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
 27183 00003C71 A2[109E]                	mov	[CFLAG],al	; 'destination file created' = false
 27184 00003C74 A3[169E]                	mov	[NXTADD],ax	; ptr into TPA buffer = 0
 27185 00003C77 A3[0C9E]                	mov	[DestSwitch],ax	; destination switches = none
 27186 00003C7A A3[E7A1]                	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 27187 00003C7D A3[ACA0]                	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
 27188 00003C80 A2[119E]                	mov	[DestClosed],al	; 'destination file closed' = false
 27189 00003C83 A2[ABA0]                	mov	[DestSiz],al	; length of destination pathname = 0
 27190 00003C86 A2[0EA1]                	mov	[SrcSiz],al	; length of source pathname = 0
 27191 00003C89 A2[AEA0]                	mov	[DestInfo],al	; destination pathname flags = none
 27192 00003C8C A2[11A1]                	mov	[SrcInfo],al	; source pathname flags = none
 27193 00003C8F A2[C5A1]                	mov	[INEXACT],al	; 'inexact copy' = false
 27194 00003C92 A2[AAA0]                	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
 27195 00003C95 A2[0DA1]                	mov	[SrcVars],al	; 'source pathname is directory' = false
 27196 00003C98 A2[D59C]                	mov	[USERDIR1],al	; saved working directory = null
 27197 00003C9B A2[C6A1]                	mov	[NOWRITE],al	; 'no write' (source = dest) = false
 27198 00003C9E A2[049E]                	mov	[RDEOF],al	; 'read end of file' = false
 27199 00003CA1 A3[69A1]                	mov	[SRCHAND],ax	; source handle = 0
 27200 00003CA4 A3[CEA1]                	mov	[CPDATE],ax	; copy date = 0
 27201 00003CA7 A3[D0A1]                	mov	[CPTIME],ax	; copy time = 0
 27202 00003CAA A2[6BA1]                	mov	[SRCISDEV],al	; 'source is device' = false
 27203                                  	; 23/03/2023
 27204                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
 27205 00003CAD A2[D6A1]                	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 27206 00003CB0 A3[D2A1]                	mov	[OFilePtr_Lo],ax
 27207 00003CB3 A3[D4A1]                	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 27208 00003CB6 A2[CAA1]                	mov	[TERMREAD],al	; 'terminate read' = false
 27209 00003CB9 A2[86A0]                	mov	[comma],al	; '"+,," found' = false
 27210 00003CBC A2[87A0]                	mov	[plus_comma],al ; '"+,," found last time' = false (?)
 27211 00003CBF A2[24A2]                	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
 27212 00003CC2 A3[0E9E]                	mov	[AllSwitch],ax	; all switches = none
 27213 00003CC5 A2[079E]                	mov	[ArgC],al	; source/dest argument count = 0
 27214 00003CC8 A2[CCA1]                	mov	[PLUS],al	; '"+" in command line' = false
 27215 00003CCB A2[C7A1]                	mov	[BINARY],al	; 'binary copy' = false
 27216 00003CCE A2[CBA1]                	mov	[ASCII],al	; 'ascii copy' = false
 27217 00003CD1 A3[1D9E]                	mov	[FileCnt],ax	; # files copied (destinations) = 0
 27218 00003CD4 A3[C8A1]                	mov	[WRITTEN],ax	; 'destination written to' = false
 27219 00003CD7 A2[069E]                	mov	[Concat],al	; 'concatenating' = false
 27220 00003CDA A2[0AA1]                	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 27221 00003CDD A3[0BA1]                	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0
 27222                                  	
 27223                                  	; 12/06/2023
 27224                                  	; MSDOS 6.22 COMMAND.COM
 27225                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27226 00003CE0 A2[E3A1]                	mov     [cox_dest_file], al ; MSDOS 6.22
 27227 00003CE3 A2[E4A1]                	mov     [cox_src_file], al  ; MSDOS 6.22
 27228                                  
 27229                                  	;	Initialize buffers with double-nulls.
 27230                                  
 27231 00003CE6 A3[6CA1]                	mov	[ScanBuf],ax
 27232 00003CE9 A3[AFA0]                	mov	[DestBuf],ax
 27233 00003CEC A3[12A1]                	mov	[SrcBuf],ax
 27234 00003CEF A3[70A0]                	mov	[SDIRBUF],ax
 27235 00003CF2 A3[2AA0]                	mov	[DIRBUF],ax
 27236 00003CF5 A3[E79F]                	mov	[DestFcb],ax
 27237                                  
 27238 00003CF8 A2[CDA1]                	mov	[objcnt],al	; # CParse cmd-line objects found = 0
 27239                                  		
 27240 00003CFB 48                      	dec	ax ; -1		; AX = 0FFFFh
 27241 00003CFC A3[06A1]                	mov	[DESTHAND],ax	; destination handle = 'never opened'
 27242 00003CFF A2[189E]                	mov	[FRSTSRCH],al	; 'first search for source' = true
 27243 00003D02 A2[09A1]                	mov	[FIRSTDEST],al	; 'first time for dest' = true
 27244 00003D05 A2[AAA0]                	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
 27245                                  
 27246                                  	; 12/06/2023
 27247                                  	; Retro DOS v4.2 COMMAND.COM
 27248                                  	; MSDOS 6.22 COMMAND.COM code only !
 27249                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27250                                  	;
 27251 00003D08 E8F106                  	call	init_copycmd_option ; MSDOS 6.22 
 27252                                  		
 27253 00003D0B BE8100                  	mov	si,81h		; SI = ptr to command line
 27254                                  	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 27255                                  	; 23/03/2023
 27256 00003D0E B32B                    	mov	bl,'+'
 27257 00003D10 FE06[23A2]              	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
 27258 00003D14 C606[95A0]01            	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true
 27259                                  
 27260                                  	;*	Scan the command line for destination information.
 27261                                  
 27262                                  DESTSCAN:
 27263 00003D19 31ED                    	xor	bp,bp			; BP = switch flag accumulator
 27264 00003D1B BF[6CA1]                	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
 27265                                  	; 23/03/2023
 27266 00003D1E 8936[89A0]              	mov	[parse_last],si		;AN018; save cmd line ptr
 27267 00003D22 E86F0B                  	call	cparse			; parse next object
 27268 00003D25 9C                      	pushf	; (*)			; save CParse flags
 27269 00003D26 FE06[CDA1]              	inc	byte [objcnt]		; count object
 27270 00003D2A F6C780                  	test	bh,80h
 27271 00003D2D 7405                    	jz	short NOCOPY		; no "+" delimiter
 27272 00003D2F C606[CCA1]01            	mov	byte [PLUS],1		; "+" delimiter occurred
 27273                                  NOCOPY:
 27274 00003D34 F6C701                  	test	bh,1
 27275 00003D37 747D                    	jz	short TESTP2		; not a switch
 27276                                  
 27277                                  	;	Found a switch.
 27278                                  
 27279                                  	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
 27280                                  	;
 27281                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27282                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3F43h
 27283                                  CHK_CP_SWITCH:
 27284                                  	; MSDOS 6.0
 27285 00003D39 F7C51000                	test	bp,10h
 27286                                  	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
 27287 00003D3D 740B                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 27288                                  	;test	word [AllSwitch],10h
 27289 00003D3F F606[0E9E]10            	test	byte [AllSwitch],10h
 27290                                  	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
 27291 00003D44 7404                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 27292                                  ;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
 27293                                  	;or	bp,FBadSwitch		;AN018; Set up bad switch
 27294 00003D46 81CD0040                	or	bp,4000h
 27295                                  NOT_SLASHV:
 27296                                  	; ****************************************
 27297                                  	; 12/06/2023
 27298                                  	; Retro DOS v4.2 COMMAND.COM
 27299                                  	; MSDOS 6.22 COMMAND.COM code only !
 27300                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27301                                  	; ****************************************
 27302                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:3F55h
 27303                                  	;
 27304 00003D4A F7C54000                	test    bp,40h			; negative Y (-Y) switch flag
 27305 00003D4E 7417                    	jz	short CHK_SLASHY0
 27306                                  	;
 27307                                  	;test	word [AllSwitch],40h
 27308 00003D50 F606[0E9E]40            	test	byte [AllSwitch],40h	; [AllSwitch] negative (-Y) flag
 27309 00003D55 7507                    	jnz	short NOT_SLASHY1	; N flag
 27310                                  	;test	word [AllSwitch],80h
 27311 00003D57 F606[0E9E]80            	test	byte [AllSwitch],80h	; [AllSwitch] SwitchY (Y) flag
 27312 00003D5C 7404                    	jz	short NOT_SLASHY2
 27313                                  NOT_SLASHY1:
 27314 00003D5E 81CD0040                	or	bp,4000h		; FBadSwitch (Repetitive)
 27315                                  NOT_SLASHY2:				; Set up bad switch
 27316 00003D62 C606[E2A1]00            	mov	byte [cox_y_override],0	; cox_y setting will be used
 27317                                  CHK_SLASHY0:
 27318 00003D67 F7C58000                	test    bp,80h
 27319 00003D6B 742B                    	jz      short CHK_SLASHY4	; not a /Y switch
 27320                                  	;
 27321 00003D6D 8A04                    	mov	al,[si]
 27322 00003D6F 3C79                    	cmp	al,'y'
 27323 00003D71 740A                    	je	short CHK_SLASHY1
 27324 00003D73 3C59                    	cmp	al,'Y'
 27325 00003D75 7406                    	je	short CHK_SLASHY1
 27326 00003D77 81CD0040                	or	bp,4000h		; FBadSwitch
 27327                                  	;				; Set up bad switch
 27328 00003D7B EB1B                    	jmp	short CHK_SLASHY4
 27329                                  CHK_SLASHY1:
 27330 00003D7D C60420                  	mov	byte [si],20h ; ' '
 27331 00003D80 46                      	inc	si
 27332                                  	;test	word [AllSwitch],40h
 27333 00003D81 F606[0E9E]40            	test	byte [AllSwitch],40h	; [AllSwitch] negative (-Y) flag
 27334 00003D86 7507                    	jnz	short CHK_SLASHY2	; N flag
 27335                                  	;test	word [AllSwitch],80h
 27336 00003D88 F606[0E9E]80            	test	byte [AllSwitch],80h	; [AllSwitch] SwitchY (Y) flag
 27337 00003D8D 7404                    	jz	short CHK_SLASHY3
 27338                                  CHK_SLASHY2:
 27339 00003D8F 81CD0040                	or	bp,4000h		; FBadSwitch (Repetitive)
 27340                                  	;				; Set up bad switch
 27341                                  CHK_SLASHY3:
 27342 00003D93 C606[E2A1]01            	mov	byte [cox_y_override],1
 27343                                  CHK_SLASHY4:
 27344                                  	; ****************************************
 27345                                  	; 12/06/2023
 27346                                  ;NOT_SLASHV:
 27347                                  	;or	[DestSwitch],bp		; assume destination
 27348                                  	;or	[AllSwitch],bp		; keep tabs on all switches
 27349                                  
 27350                                  	; 12/06/2023
 27351                                  	; Retro DOS v4.2 COMMAND.COM
 27352                                  	; MSDOS 6.22 COMMAND.COM -TRANGROUP:3FA7h
 27353 00003D98 092E[0C9E]              	or	[DestSwitch],bp		; set [DestSwitch] SwitchY flag to 1
 27354 00003D9C 092E[0E9E]              	or	[AllSwitch],bp		; set [AllSwitch] SwitchY flag to 1
 27355                                  	;test	bp,~SwitchCopy		; Bad switch?
 27356 00003DA0 F7C5237F                	test	bp,7F23h ; MSDOS 6.22	; ~SwitchCopy ; not SwitchCopy
 27357 00003DA4 740A                    	jz	short NOT_BAD_SWITCH	; Switches are okay
 27358                                  
 27359                                  	; 12/06/2023
 27360                                  	; 23/03/2023
 27361                                  	; MSDOS 6.0
 27362                                  	;;test	bp,not SwitchCopy	;AN018; Bad switch?
 27363                                  	;test	bp,7FE3h ; test bp,~SwitchCopy
 27364                                  	;jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
 27365                                  	
 27366 00003DA6 9D                      	popf	; (*)			;AN018; fix up stack
 27367 00003DA7 B80300                  	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
 27368 00003DAA E86BE9                  	call	setup_parse_error_msg	;AN018; setup to print the message
 27369 00003DAD E9F2F0                  	jmp	cerror			;AC018; exit
 27370                                  NOT_BAD_SWITCH:
 27371 00003DB0 9D                      	popf				; restore CParse flags
 27372 00003DB1 7233                    	jc	short CHECKDONE		; found CR
 27373 00003DB3 E963FF                  	jmp	DESTSCAN		; continue scanning for destination
 27374                                  TESTP2:
 27375 00003DB6 9D                      	popf	; (*)			; restore CParse flags
 27376 00003DB7 722D                    	jc	short CHECKDONE		; found CR
 27377 00003DB9 F6C780                  	test	bh,80h
 27378 00003DBC 7504                    	jnz	short GOTPLUS		; found a "+pathname" argument
 27379 00003DBE FE06[079E]              	inc	byte [ArgC]		; count independent pathname args
 27380                                  GOTPLUS:
 27381 00003DC2 56                      	push	si			; save cmd line ptr
 27382 00003DC3 A1[E7A1]                	mov	ax,[STARTEL]		; AX = ptr to last path element
 27383 00003DC6 BE[6CA1]                	mov	si,ScanBuf		; SI = ptr to path string
 27384 00003DC9 29F0                    	sub	ax,si			; AX = offset of last element
 27385 00003DCB BF[AFA0]                	mov	di,DestBuf		; DI = ptr to destination buf
 27386 00003DCE 01F8                    	add	ax,di			; AX = ptr to last element in
 27387                                  					;  destination path buffer
 27388 00003DD0 A3[ACA0]                	mov	[DestTail],ax		; save ptr to last element
 27389 00003DD3 880E[ABA0]              	mov	[DestSiz],cl		; save path string length
 27390 00003DD7 41                      	inc	cx			; CX = mov length (incl null)
 27391 00003DD8 F3A4                    	rep	movsb			; DestBuf = possible destination path
 27392 00003DDA 883E[AEA0]              	mov	[DestInfo],bh		; save CParse info flags
 27393                                  	;mov	word [DestSwitch],0	; clear destination switches
 27394                                  	; 10/08/2024
 27395 00003DDE 890E[0C9E]              	mov	[DestSwitch],cx ; 0
 27396 00003DE2 5E                      	pop	si			; SI = ptr into cmd line again
 27397 00003DE3 E933FF                  	jmp	DESTSCAN		;AC018; continue scanning for dest
 27398                                  
 27399                                  CHECKDONE:
 27400                                  	;	We reached the CR. The destination scan is finished.
 27401                                  
 27402                                  	;	Disallow "copy file1+" as file overwriting itself.
 27403                                  	;
 27404                                  	;	(Note that "copy file1+file2+" will be accepted, and
 27405                                  	;	equivalent to "copy file1+file2".)
 27406                                  
 27407                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 27408                                  	;	through this check, since the switch would count
 27409                                  	;	as another object in ObjCnt.
 27410                                  
 27411 00003DE6 803E[CCA1]01            	cmp	byte [PLUS],1		; "+" with
 27412 00003DEB 7514                    	jnz	short CDCONT
 27413 00003DED 803E[079E]01            	cmp	byte [ArgC],1		; one arg,
 27414 00003DF2 750D                    	jnz	short CDCONT
 27415 00003DF4 803E[CDA1]02            	cmp	byte [objcnt],2		; two objects..
 27416 00003DF9 7506                    	jnz	short CDCONT
 27417 00003DFB BA[F991]                	mov	dx,OVERWR_PTR
 27418 00003DFE E9AE07                  	jmp	COPYERR			; is file overwrite
 27419                                  
 27420                                  CDCONT:
 27421 00003E01 A0[CCA1]                	mov	al,[PLUS]		; AL = '"+" occurred'
 27422 00003E04 A2[069E]                	mov	[Concat],al		; if "+" occurred, we're concatenating
 27423 00003E07 D0E0                    	shl	al,1
 27424 00003E09 D0E0                    	shl	al,1
 27425 00003E0B A2[C5A1]                	mov	[INEXACT],al		; therefore making an inexact copy
 27426                                  	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
 27427 00003E0E A0[079E]                	mov	al,[ArgC]		; AL = # independent arguments
 27428                                  
 27429                                  	; 23/03/2023
 27430                                  	; MSDOS 3.3		
 27431                                  	;or	al,al
 27432                                  	;jz	short CERROR4J
 27433                                  	; MSDOS 6.0
 27434 00003E11 08C0                    	or	al,al
 27435 00003E13 750B                    	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
 27436                                  		
 27437 00003E15 BA[D091]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27438 00003E18 C706[D091]0200          	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
 27439                                  	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
 27440 00003E1E EB0D                    	jmp	short CERROR_PARSEJ	; take parse error exit		
 27441                                  
 27442                                  	; more than 0 args; check if too many
 27443                                  TRY_TOO_MANY:
 27444 00003E20 3C02                    	cmp	al,2
 27445 00003E22 7611                    	jbe	short ACOUNTOK		; <= 2 arguments - ok
 27446                                  
 27447                                  	; 23/03/2023
 27448                                  	; MSDOS 6.0
 27449 00003E24 BA[D091]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27450 00003E27 C706[D091]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 27451                                  	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
 27452                                  CERROR_PARSEJ:
 27453 00003E2D C606[CE91]02            	mov	byte [msg_disp_class],parse_msg_class ; 2
 27454                                  					; parse error message	
 27455                                  CERROR4J:
 27456 00003E32 E96DF0                  	jmp	cerror
 27457                                  
 27458                                  ACOUNTOK:
 27459 00003E35 BD[AAA0]                	mov	bp,DestVars		; BP = base of dest variables
 27460                                  
 27461 00003E38 3C01                    	cmp	al,1
 27462 00003E3A 7520                    	jnz	short GOT2ARGS
 27463                                  
 27464                                  	;	Only one independent pathname argument on command line.
 27465                                  	;	Set destination to d:*.*, where d: is current drive.
 27466                                  
 27467                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 27468                                  	;	The two files would be appended as d:file1, rather than x:file1.
 27469                                  
 27470 00003E3C A0[059E]                	mov	al,[CURDRV]		; AL = current drive (0 = A)
 27471                                  	;add	al,[CAPITAL_A]		; AL = current drive letter
 27472                                  	; 23/03/2023
 27473 00003E3F 0441                    	add	al,'A'
 27474 00003E41 B43A                    	mov	ah,':'			; AX = "d:"
 27475                                  	;mov	byte [bp+1],2
 27476 00003E43 C6460102                	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 27477                                  
 27478 00003E47 BF[AFA0]                	mov	di,DestBuf		; ES:DI = ptr to dest path buf
 27479 00003E4A AB                      	stosw				; store "d:"
 27480                                  		
 27481 00003E4B C706[0C9E]0000          	mov	word [DestSwitch],0	; clear destination switches
 27482                                  	;mov	byte [bp+4],2		
 27483 00003E51 C6460402                	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 27484                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 27485                                  	;mov	byte [bp+0],0		
 27486 00003E55 C6460000                	mov	byte [bp],0
 27487 00003E59 E8090A                  	call	SETSTARS		; add wildcards
 27488                                  GOT2ARGS:
 27489                                  	;	If destination pathname is "d:", add full wildcard filename
 27490                                  
 27491                                  	;cmp	byte [bp+1],2
 27492 00003E5C 807E0102                	cmp	byte [bp+VARSTRUC.SIZ],2
 27493 00003E60 7516                    	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 27494 00003E62 B03A                    	mov	al,':'  ; 3Ah
 27495 00003E64 3806[B0A0]              	cmp	byte [DestBuf+1],al
 27496 00003E68 750E                    	jnz	short NOTSHORTDEST	; it's just a 2-character filename
 27497                                  	;or	byte [bp+4],2
 27498 00003E6A 804E0402                	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 27499 00003E6E BF[B1A0]                	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
 27500                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 27501                                  	;mov	byte [bp+0],0		
 27502 00003E71 C6460000                	mov	byte [bp],0
 27503 00003E75 E8ED09                  	call	SETSTARS		; add wildcards
 27504                                  NOTSHORTDEST:
 27505                                  	;	If destination pathname ends with "\", try to make
 27506                                  	;	sure it's "d:\".
 27507                                  
 27508                                  	;mov	di,[bp+2]
 27509 00003E78 8B7E02                  	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 27510 00003E7B 803D00                  	cmp	byte [di],0
 27511 00003E7E 7515                    	jnz	short CHKSWTCHES	; not a null, so last char not "\"
 27512                                  
 27513 00003E80 BA[0B93]                	mov	dx,badcd_ptr
 27514 00003E83 B03A                    	mov	al,':'
 27515 00003E85 3845FE                  	cmp	[di-2],al
 27516 00003E88 75A8                    	jne	short CERROR4J		; it's not "d:\", exit with error msg
 27517                                  	;mov	byte [bp+0],2
 27518                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 27519 00003E8A C6460002                	mov	byte [bp],2
 27520                                  	;or	byte [bp+4],6
 27521 00003E8E 804E0406                	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 27522                                  					  ;  path character
 27523 00003E92 E8D009                  	call	SETSTARS		; add wildcards
 27524                                  CHKSWTCHES:
 27525                                  	;	We have enough information about the destination for now.
 27526                                  
 27527                                  	;	Turn on verify if requested. Save the current verify flag.
 27528                                  
 27529                                  	; 23/03/2023
 27530                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
 27531                                  	;mov	dx,BADPARMPTR
 27532                                  	
 27533 00003E95 A1[0E9E]                	mov	ax,[AllSwitch]		; AX = all switch flags
 27534                                  
 27535                                  	; 23/03/2023
 27536                                  	; MSDOS 3.3
 27537                                  	;;test	ax,~SWITCHCOPY ; 7FE3h
 27538                                  	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 27539                                  	;jnz	short CERROR4J
 27540                                  	
 27541                                  	; 23/03/2023
 27542                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27543                                  	;test	ax,SwitchV ; 10h
 27544                                  	; 18/04/2023
 27545                                  	;test	ax,10h
 27546 00003E98 A810                    	test	al,10h  ; test al,SwitchV
 27547 00003E9A 7414                    	jz	short NOVERIF		; no /v, no verify
 27548                                  
 27549 00003E9C B454                    	mov	ah,Get_Verify_On_Write ; 54h
 27550 00003E9E CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 27551                                  				; Return: AL = 00h if flag OFF
 27552                                  				; AL = 01h if flag ON
 27553 00003EA0 1E                      	push	ds
 27554 00003EA1 8E1E[F39D]              	mov	ds,[RESSEG]
 27555 00003EA5 30E4                    	xor	ah,ah
 27556 00003EA7 A3[4502]                	mov	[VerVal],ax		; save current verify flag
 27557 00003EAA 1F                      	pop	ds
 27558 00003EAB B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 27559 00003EAE CD21                    	int	21h		; DOS -	SET VERIFY FLAG
 27560                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 27561                                  NOVERIF:
 27562                                  	;*	Scan for first source.
 27563                                  
 27564 00003EB0 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27565 00003EB2 BE8100                  	mov	si,81h			; SI = ptr into command line
 27566                                  	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 27567                                  	; 23/03/2023
 27568 00003EB5 B32B                    	mov	bl,'+' ; 2Bh
 27569                                  SCANFSRC:
 27570 00003EB7 BF[6CA1]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27571 00003EBA E8D709                  	call	cparse			; parse first source pathname
 27572 00003EBD F6C701                  	test	bh,1			; switch?
 27573 00003EC0 75F5                    	jnz	short SCANFSRC		; yes, try again
 27574 00003EC2 092E[0C9E]              	or	[DestSwitch],bp		; include copy-wide switches on dest
 27575                                  
 27576                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 27577                                  
 27578                                  	; 23/03/2023
 27579 00003EC6 F7C50800                	test	bp,8
 27580                                  	;test	bp,SWITCHB
 27581 00003ECA 750C                    	jnz	short NOSETCASC		; /b - explicit binary copy
 27582 00003ECC 803E[069E]00            	cmp	byte [Concat],0
 27583 00003ED1 7405                    	jz	short NOSETCASC		; we're not concatenating
 27584 00003ED3 C606[CBA1]04            	mov	byte [ASCII],4
 27585                                  	;mov	byte [ASCII],SWITCHA	; set ascii copy
 27586                                  NOSETCASC:
 27587 00003ED8 E82604                  	call	SOURCE_SET		; set source variables
 27588 00003EDB E84400                  	call	FRSTSRC			; set up first source copy
 27589 00003EDE E99500                  	jmp	FIRSTENT		; jump into the copy loop
 27590                                  
 27591                                  ; ---------------------------------------------------------------------------
 27592                                  
 27593                                  	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27594                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
 27595                                  ENDCOPY:
 27596                                  	;*	End of the road. Close destination, display # files
 27597                                  	;	copied (meaning # destinations), and go back to main
 27598                                  	;	transient COMMAND code.
 27599                                  
 27600 00003EE1 E83203                  	call	CLOSEDEST
 27601                                  ENDCOPY2:
 27602 00003EE4 BA[0292]                	mov	dx,copied_ptr
 27603 00003EE7 8B36[1D9E]              	mov	si,[FileCnt]
 27604 00003EEB 8936[93A0]              	mov	[Copy_num],si
 27605 00003EEF E81D16                  	call	std_printf
 27606 00003EF2 E90FC2                  	jmp	TCOMMAND		; stack could be messed up
 27607                                  
 27608                                  ; ---------------------------------------------------------------------------
 27609                                  
 27610                                  SRCNONEXIST:
 27611                                  	;*	Source doesn't exist. If concatenating, ignore and continue.
 27612                                  	;	Otherwise, say 'file not found' and quit.
 27613                                  
 27614 00003EF5 803E[069E]00            	cmp	byte [Concat],0
 27615 00003EFA 7543                    	jne	short NEXTSRC		; concatenating - go on to next source
 27616                                  
 27617                                  	; 24/03/2023
 27618                                  	; MSDOS 3.3
 27619                                  	;mov	dx,SRCBUF
 27620                                  	;mov	[STRING_PTR_1],dx
 27621                                  	;mov	dx,STRINGBUF1PTR
 27622                                  	;call	STD_PRINTF
 27623                                  	;mov	dx,FNOTFOUNDPTR
 27624                                  	;jmp	COPYERR
 27625                                  
 27626                                  	; 24/*03/2023
 27627                                  	; MSDOS 6.0
 27628                                  	;	Set up error message.
 27629 00003EFC C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 27630                                  				  	; extended error msg
 27631 00003F01 BA[D091]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 27632 00003F04 C706[D091]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 27633                                  					; 'file not found' msg#
 27634 00003F0A C706[91A0][12A1]        	mov	word [string_ptr_2],SrcBuf
 27635                                  					; point at bad pathname
 27636 00003F10 C606[D291]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27637                                  					; 1 substitution
 27638 00003F15 E99706                  	jmp	COPYERR			; print msg and clean up
 27639                                  
 27640                                  ; ---------------------------------------------------------------------------
 27641                                  
 27642                                  SOURCEPROC:
 27643                                  
 27644                                  	;*	Preparatory processing for each source file.
 27645                                  	;	Called at FrstSrc for first source file.
 27646                                  
 27647 00003F18 E8E603                  	call	SOURCE_SET		; set source variables & ascii/binary
 27648 00003F1B 803E[069E]00            	cmp	byte [Concat],0
 27649 00003F20 750B                    	jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 27650                                  
 27651                                  ; ---------------------------------------------------------------------------
 27652                                  
 27653                                  FRSTSRC:
 27654 00003F22 31C0                    	xor	ax,ax
 27655 00003F24 A2[109E]                	mov	[CFLAG],al		; 'destination not created'
 27656 00003F27 A3[169E]                	mov	[NXTADD],ax		; copy buffer ptr = 0
 27657 00003F2A A2[119E]                	mov	[DestClosed],al		; 'destination not closed'
 27658                                  
 27659                                  LEAVECFLAG:
 27660 00003F2D 8936[C3A1]              	mov	[SRCPT],si		; save cmd-line ptr
 27661 00003F31 BF[D59C]                	mov	di,USERDIR1		; DI = ptr to buf for user's 
 27662                                  						;   current dir
 27663 00003F34 BD[0DA1]                	mov	bp,SrcVars		; BP = base of source variables
 27664 00003F37 E8DB07                  	call	BUILDPATH		; cd to source dir, figure
 27665                                  						;   out stuff about source
 27666 00003F3A 8B36[0FA1]              	mov	si,[SrcTail]		; SI = ptr to source filename
 27667 00003F3E C3                      	retn
 27668                                  
 27669                                  ; ---------------------------------------------------------------------------
 27670                                  
 27671                                  	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27672                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27673                                  NEXTSRC:
 27674                                  	;*	Next source. Come here after handling each pathname.
 27675                                  	;	We're done unless there are additional source pathnames
 27676                                  	;	to be appended.
 27677                                  	;
 27678                                  	;	Note that all files matching an ambiguous pathname
 27679                                  	;	are processed before coming here.
 27680                                  
 27681 00003F3F 803E[CCA1]00            	cmp	byte [PLUS],0
 27682                                  	;jne	short MORECP		; copying "+" sources - keep going
 27683                                  	; 26/04/2023
 27684                                  ;ENDCOPYJ2:
 27685                                  	;jmp	short ENDCOPY
 27686 00003F44 749B                    	je	short ENDCOPY
 27687                                  MORECP:
 27688 00003F46 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 27689 00003F48 8B36[C3A1]              	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 27690                                  	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 27691 00003F4C B32B                    	mov	bl,'+' ; 2Bh
 27692                                  SCANSRC:
 27693 00003F4E BF[6CA1]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 27694 00003F51 E84009                  	call	cparse			; parse first source name
 27695                                  	;jb	short ENDCOPYJ2		; CR found - we're done
 27696                                  	; 26/04/2023
 27697 00003F54 728B                    	jb	short ENDCOPY
 27698                                  
 27699 00003F56 F6C780                  	test	bh,80h
 27700                                  	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 27701                                  	; 26/04/2023
 27702 00003F59 7486                    	jz	short ENDCOPY
 27703                                  
 27704 00003F5B F6C701                  	test	bh,1
 27705 00003F5E 75EE                    	jnz	short SCANSRC		; switch found - keep looking
 27706                                  
 27707                                  	;	ScanBuf contains the next source pathname.
 27708                                  
 27709 00003F60 E8B5FF                  	call	SOURCEPROC		; prepare this source
 27710 00003F63 803E[86A0]01            	cmp	byte [comma],1		; was +,, found last time?
 27711 00003F68 7507                    	jnz	short NOSTAMP		;  no - try for a file
 27712 00003F6A C606[87A0]01            	mov	byte [plus_comma],1	; yes - set flag
 27713 00003F6F EB84                    	jmp	short SRCNONEXIST	; we know we won't find it
 27714                                  
 27715                                  NOSTAMP:
 27716 00003F71 C606[87A0]00            	mov	byte [plus_comma],0	; reset +,, flag
 27717                                  
 27718                                  ; ---------------------------------------------------------------------------
 27719                                  
 27720                                  FIRSTENT:
 27721                                  
 27722                                  ;M047
 27723                                  ; The only case we need to worry about is when the source is wildcarded and
 27724                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 27725                                  ;concatenation. We check for this case.
 27726                                  ;
 27727                                  ;NB: This change has been backed out and replaced by M048. This is not the
 27728                                  ;right place to do this check.
 27729                                  
 27730                                  	;	This is where we enter the loop with the first source.
 27731                                  
 27732 00003F76 BF5C00                  	mov	di,FCB ; 5Ch		; DI = ptr to FCB
 27733 00003F79 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27734 00003F7C CD21                    	int	21h		; DOS -	PARSE FILENAME
 27735                                  				; DS:SI	-> string to parse
 27736                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27737                                  				; AL = bit mask	to control parsing
 27738 00003F7E 803C00                  	cmp	byte [si],0		; did we parse the whole thing?
 27739 00003F81 7516                    	jne	short SRCHDONE		; no, error, simulate 'not found'
 27740 00003F83 A1[12A1]                	mov	ax,[SrcBuf]		; AX = possible "d:"
 27741 00003F86 80FC3A                  	cmp	ah,':'
 27742 00003F89 7402                    	je	short DRVSPEC1		; AX = definite "d:"
 27743 00003F8B B040                    	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
 27744                                  DRVSPEC1:
 27745 00003F8D 0C20                    	or	al,20h			; AL = lowercase drive letter
 27746 00003F8F 2C60                    	sub	al,60h			; AL = drive id (0=current,1=A,..)
 27747                                  	;mov	[5Ch],al
 27748 00003F91 A25C00                  	mov	[FCB],al		; put drive id in FCB
 27749                                  
 27750                                  	;	FCB contains drive and filename to search.
 27751                                  		
 27752 00003F94 B411                    	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'
 27753 00003F96 E86D01                  	call	SEARCH
 27754                                  SRCHDONE:
 27755 00003F99 9C                      	pushf				; save flags from Search
 27756 00003F9A E834EA                  	call	RestUDir1		; restore users current directory
 27757 00003F9D 9D                      	popf				; restore flags from search
 27758 00003F9E 7403                    	jz	short NEXTAMBIG0	; found the source - continue
 27759 00003FA0 E952FF                  	jmp	SRCNONEXIST		; didn't find the source
 27760                                  
 27761                                  NEXTAMBIG0:
 27762 00003FA3 30C0                    	xor	al,al
 27763 00003FA5 8606[189E]              	xchg	al,[FRSTSRCH]
 27764 00003FA9 08C0                    	or	al,al
 27765 00003FAB 740B                    	jz	short NEXTAMBIG
 27766                                  SETNMEL:
 27767 00003FAD B90C00                  	mov	cx,12
 27768 00003FB0 BF[70A0]                	mov	di,SDIRBUF
 27769 00003FB3 BE[2AA0]                	mov	si,DIRBUF
 27770 00003FB6 F3A4                    	rep	movsb			; save very first source name
 27771                                  NEXTAMBIG:
 27772 00003FB8 30C0                    	xor	al,al
 27773 00003FBA A2[C6A1]                	mov	[NOWRITE],al		; turn off nowrite
 27774 00003FBD 8B3E[0FA1]              	mov	di,[SrcTail]
 27775 00003FC1 BE[2BA0]                	mov	si,DIRBUF+1
 27776 00003FC4 E886EB                  	call	FCB_TO_ASCZ		; SrcBuf has complete name
 27777                                  ;MELDO:
 27778                                  	; ****************************************
 27779                                  	; 12/06/2023
 27780                                  	; Retro DOS v4.2 COMMAND.COM
 27781                                  	; MSDOS 6.22 COMMAND.COM code only !
 27782                                  	; (Disassembled source code by using Hex-Rays IDA disassembler)
 27783                                  	; ****************************************
 27784                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:41DBh
 27785                                  MELDO0:
 27786 00003FC7 803E[E2A1]00            	cmp	byte [cox_y_override],0 ; /Y switch override (question) enabled ?
 27787 00003FCC 746C                    	jz	short MELDO ; no
 27788                                  	; ----------------------
 27789                                  	; yes
 27790 00003FCE E85406                  	call	BUILDDEST
 27791 00003FD1 BE[12A1]                	mov	si,SrcBuf
 27792 00003FD4 BF[219B]                	mov	di,SRCXNAME
 27793                                  	;mov	ah,60h
 27794 00003FD7 B460                    	mov	ah,xNameTrans ; 60h
 27795 00003FD9 CD21                    	int	21h	; DOS - RESOLVE PATH STRING TO CANONICAL PATH STRING
 27796                                  			; DS:SI -> ASCIZ relative path string or directory name
 27797                                  			; ES:DI -> 128-byte buffer for ASCIZ canonical fully qualified name
 27798 00003FDB E8A308                  	call	COMPNAME
 27799 00003FDE 7540                    	jnz	short MELDO1    	; different file names
 27800 00003FE0 803E[069E]00            	cmp	byte [Concat],0
 27801 00003FE5 7539                    	jnz	short MELDO1		; concatenating
 27802                                  	; "File cannot be copied onto itself"
 27803 00003FE7 BA[7B93]                	mov	dx,file_name_ptr
 27804 00003FEA E82215                  	call	std_printf
 27805 00003FED E831EB                  	call	CRLF2
 27806 00003FF0 BA[F991]                	mov	dx,OVERWR_PTR
 27807 00003FF3 E9B905                  	jmp	COPYERR
 27808                                  ;MELDO1:
 27809                                  	;cmp	byte [CFLAG],0		; destination file created flag
 27810                                  	;jnz	short MELDO		; yes, new (created) file
 27811                                  	;				; no, overwrite question (must be confirmed)
 27812                                  	;call	get_answer_YNA
 27813                                  	;jb	short MELDO2    	; answer is no
 27814                                  	;cmp	byte [Concat],0
 27815                                  	;jnz	short MELDO
 27816                                  	;cmp	byte [cox_dest_file],0	; is there a (valid) target file ?
 27817                                  	;jnz	short DOREAD    	; yes
 27818                                  	;jmp	short MELDO     	; no, destination/target file does not exist
 27819                                  MELDO2:
 27820 00003FF6 803E[0AA1]00            	cmp	byte [MELCOPY],0	; is 'Mel Hallerman copy' false ?
 27821 00003FFB 7507                    	jnz	short MELDO3    	; no (, it is true)
 27822 00003FFD 803E[069E]00            	cmp	byte [Concat],0
 27823 00004002 7408                    	jz	short MELDO4
 27824                                  MELDO3:
 27825 00004004 C606[119E]01            	mov	byte [DestClosed],1
 27826 00004009 E9D5FE                  	jmp	ENDCOPY
 27827                                  MELDO4:
 27828 0000400C E8EB00                  	call	SEARCHNEXT
 27829 0000400F 74A7                    	jz	short NEXTAMBIG
 27830 00004011 803E[E4A1]00            	cmp	byte [cox_src_file],0
 27831                                  	;jz	short MELDO5
 27832                                  	;jmp	NEXTSRC
 27833                                  	; 18/06/2023
 27834 00004016 7505                    	jnz	short NEXTSRCJ
 27835                                  MELDO5:
 27836 00004018 C606[119E]01            	mov	byte [DestClosed],1
 27837                                  NEXTSRCJ:	; 18/06/2023
 27838 0000401D E91FFF                  	jmp	NEXTSRC
 27839                                  
 27840                                  	; 12/06/2023
 27841                                  MELDO1:
 27842 00004020 803E[109E]00            	cmp	byte [CFLAG],0		; destination file created flag
 27843 00004025 7513                    	jnz	short MELDO     	; yes, new (created) file
 27844                                  					; no, overwrite question (must be confirmed)
 27845 00004027 E81803                  	call	get_answer_YNA
 27846 0000402A 72CA                    	jb	short MELDO2    	; answer is no
 27847 0000402C 803E[069E]00            	cmp	byte [Concat],0
 27848 00004031 7507                    	jnz	short MELDO
 27849 00004033 803E[E3A1]00            	cmp	byte [cox_dest_file],0	; is there a (valid) target file ?
 27850 00004038 7517                    	jnz	short DOREAD    	; yes
 27851                                  	; 12/06/2023
 27852                                  	;jmp	short MELDO     	; no, destination/target file does not exist
 27853                                  
 27854                                  	; ****************************************
 27855                                  	; 12/06/2023
 27856                                  MELDO:
 27857 0000403A 803E[069E]00            	cmp	byte [Concat],0
 27858 0000403F 7507                    	jnz	short SHOWCPNAM		; concatenating - show name
 27859 00004041 F606[11A1]02            	test	byte [SrcInfo],2	; wildcard - show name
 27860 00004046 7409                    	jz	short DOREAD
 27861                                  SHOWCPNAM:
 27862                                  	; 25/03/2023
 27863                                  	; MSDOS 3.3
 27864                                  	;mov	dx,SRCBUF
 27865                                  	;mov	[STRING_PTR_2],dx
 27866                                  	;mov	dx,STRINGBUF2PTR
 27867                                  	;call	STD_PRINTF
 27868                                  	;call	CRLF2
 27869                                  	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
 27870                                  	; MSDOS 6.0 (& MSDOS 5.0
 27871 00004048 BA[7B93]                	mov	dx,file_name_ptr
 27872 0000404B E8C114                  	call	std_printf
 27873 0000404E E8D0EA                  	call	CRLF2
 27874                                  DOREAD:
 27875 00004051 E8C300                  	call	DOCOPY
 27876 00004054 803E[069E]00            	cmp	byte [Concat],0
 27877 00004059 750A                    	jnz	short NODCLOSE		; concatenating - don't close dest
 27878                                  
 27879 0000405B E8B801                  	call	CLOSEDEST		; close current destination
 27880 0000405E 7205                    	jc	short NODCLOSE		; concatenating - dest not closed
 27881                                  
 27882 00004060 C606[109E]00            	mov	byte [CFLAG],0		; 'destination not created'
 27883                                  NODCLOSE:
 27884 00004065 803E[069E]00            	cmp	byte [Concat],0
 27885 0000406A 740A                    	jz	short NOFLUSH
 27886                                  
 27887                                  ;	Concatenating - flush output between source files so LostErr
 27888                                  ;	stuff works correctly.
 27889                                  
 27890                                  	;invoke	FlshFil  ; MSDOS 6.0
 27891                                  	; 25/03/2023
 27892 0000406C E80304                  	call	FlshFil
 27893                                  	;call	FLUSHFIL ; MSDOS 3.3
 27894                                  
 27895 0000406F F606[0AA1]FF            	test	byte [MELCOPY],0FFh
 27896                                  	;jz	short NOFLUSH
 27897                                  	;jmp	short DOMELCOPY
 27898                                  	; 25/03/2023
 27899 00004074 750D                    	jnz	short DOMELCOPY
 27900                                  NOFLUSH:
 27901 00004076 E88100                  	call	SEARCHNEXT		; try next match
 27902 00004079 75A2                    	jnz	short NEXTSRCJ		; not found - finished with 
 27903                                  					;   this source spec
 27904 0000407B C606[119E]00            	mov	byte [DestClosed],0	; 'destination not closed'
 27905 00004080 E935FF                  	jmp	NEXTAMBIG		; do next ambig match
 27906                                  
 27907                                  DOMELCOPY:
 27908 00004083 803E[0AA1]FF            	cmp	byte [MELCOPY],0FFh
 27909 00004088 740D                    	je	short CONTMEL
 27910 0000408A 8B36[C3A1]              	mov	si,[SRCPT]
 27911 0000408E 8936[0BA1]              	mov	[MELSTART],si
 27912 00004092 C606[0AA1]FF            	mov	byte [MELCOPY],0FFh
 27913                                  
 27914                                  CONTMEL:
 27915 00004097 31ED                    	xor	bp,bp
 27916 00004099 8B36[C3A1]              	mov	si,[SRCPT]
 27917                                  	;mov	bl,[PLUS_CHR]
 27918                                  	; 25/03/2023
 27919 0000409D B32B                    	mov	bl,'+'
 27920                                  SCANSRC2:
 27921 0000409F BF[6CA1]                	mov	di,ScanBuf
 27922 000040A2 E8EF07                  	call	cparse
 27923 000040A5 F6C780                  	test	bh,80h
 27924 000040A8 742F                    	jz	short NEXTMEL		; no "+" - go back to start
 27925 000040AA F6C701                  	test	bh,1
 27926 000040AD 75F0                    	jnz	short SCANSRC2		; switch - keep scanning
 27927 000040AF E866FE                  	call	SOURCEPROC
 27928 000040B2 E81CE9                  	call	RestUDir1
 27929 000040B5 BF[AB9F]                	mov	di,DESTFCB2
 27930 000040B8 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27931 000040BB CD21                    	int	21h		; DOS -	PARSE FILENAME
 27932                                  				; DS:SI	-> string to parse
 27933                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27934                                  				; AL = bit mask	to control parsing
 27935 000040BD BB[71A0]                	mov	bx,SDIRBUF+1
 27936 000040C0 BE[AC9F]                	mov	si,DESTFCB2+1
 27937 000040C3 8B3E[0FA1]              	mov	di,[SrcTail]
 27938                                  
 27939 000040C7 E81C06                  	call	BUILDNAME
 27940                                  
 27941 000040CA 803E[069E]00            	cmp	byte [Concat],0
 27942 000040CF 7405                    	je	short MELDOJ		; not concatenating - continue
 27943                                  
 27944                                  	;	Yes, turn off nowrite because this part of the code 
 27945                                  	;	is only reached after the first file has been dealt with.
 27946                                  
 27947 000040D1 C606[C6A1]00            	mov	byte [NOWRITE],0
 27948                                  MELDOJ:
 27949 000040D6 E961FF                  	jmp	MELDO
 27950                                  	; 18/06/2023
 27951                                  ;NEXTSRCJ:
 27952                                  	;jmp	NEXTSRC
 27953                                  
 27954                                  NEXTMEL:
 27955 000040D9 E83A01                  	call	CLOSEDEST
 27956 000040DC 31C0                    	xor	ax,ax
 27957 000040DE A2[109E]                	mov	[CFLAG],al
 27958 000040E1 A3[169E]                	mov	[NXTADD],ax
 27959 000040E4 A2[119E]                	mov	[SPECDRV],al
 27960 000040E7 8B36[0BA1]              	mov	si,[MELSTART]
 27961 000040EB 8936[C3A1]              	mov	[SRCPT],si
 27962 000040EF E80800                  	call	SEARCHNEXT
 27963 000040F2 7403                    	jz	short SETNMELJ
 27964 000040F4 E9EDFD                  	jmp	ENDCOPY2
 27965                                  SETNMELJ:
 27966 000040F7 E9B3FE                  	jmp	SETNMEL
 27967                                  
 27968                                  ; ---------------------------------------------------------------------------
 27969                                  
 27970                                  SEARCHNEXT:
 27971 000040FA B412                    	mov	ah,Dir_Search_Next ; 12h
 27972 000040FC F606[11A1]02            	test	byte [SrcInfo],2
 27973 00004101 7503                    	jnz	short SEARCH		; do search-next if ambig
 27974 00004103 08E4                    	or	ah,ah			; reset zero flag
 27975 00004105 C3                      	retn
 27976                                  
 27977                                  ; ---------------------------------------------------------------------------
 27978                                  
 27979                                  SEARCH:
 27980 00004106 50                      	push	ax
 27981 00004107 B41A                    	mov	ah,Set_DMA ; 1Ah
 27982 00004109 BA[2AA0]                	mov	dx,DIRBUF	; put result of search in dirbuf
 27983 0000410C CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 27984                                  			; DS:DX	-> disk	transfer buffer
 27985 0000410E 58                      	pop	ax		; restore search first/next command
 27986 0000410F BA5C00                  	mov	dx,FCB ; 5Ch
 27987 00004112 CD21                    	int	21h		; Do the search
 27988 00004114 08C0                    	or	al,al
 27989 00004116 C3                      	retn
 27990                                  
 27991                                  ; ---------------------------------------------------------------------------
 27992                                  
 27993                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27994                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 27995                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4335h
 27996                                  DOCOPY:
 27997 00004117 BE[12A1]                	mov	si,SrcBuf	; do name translate of source
 27998 0000411A BF[219B]                	mov	di,SRCXNAME	; save for name comparison
 27999 0000411D B460                    	mov	ah,xNameTrans ; 60h
 28000                                  	;mov	ah,60h
 28001 0000411F CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 28002                                  			; DS:SI	-> ASCIZ relative path string or directory name
 28003                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 28004 00004121 C606[049E]00            	mov	byte [RDEOF],0	; no EOF yet
 28005                                  
 28006                                  	; MSDOS 6.0
 28007                                  	;mov	ax,ExtOpen shl 8	; open the file
 28008                                  	; 26/03/2023
 28009 00004126 B8006C                  	mov	ax,6C00h
 28010                                  ;M046
 28011                                  ; For reads, the sharing mode should be deny none so that any process can
 28012                                  ;open this file again in any other sharing mode. This is mainly to allow
 28013                                  ;multiple command.com's to access the same file without getting sharing
 28014                                  ;violations
 28015                                  ;
 28016                                  	;mov	bx,deny_none|read_open_mode
 28017 00004129 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 28018 0000412C 31C9                    	xor	cx,cx			; no special files
 28019                                  	;mov	dx,read_open_flag	; set up open flags
 28020 0000412E BA0101                  	mov	dx,101h
 28021 00004131 CD21                    	int	21h
 28022                                  	; 26/03/2023
 28023 00004133 7230                    	jc	short Error_On_Source
 28024                                  	;jnc	short OPENOK
 28025                                  
 28026                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 28027                                  	;	They asked for it...
 28028                                  
 28029                                  	;jmp	short Error_On_Source ;AC022; clean up and exit
 28030                                  
 28031                                  	; 26/03/2023
 28032                                  	; MSDOS 3.3
 28033                                  	;mov	dx,SRCBUF
 28034                                  	;mov	ax,OPEN*256 ; 3D00h
 28035                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 28036                                  	;			; DS:DX	-> ASCIZ filename
 28037                                  	;			; AL = access mode
 28038                                  	;			; 0 - read
 28039                                  	;jnc	short OPENOK
 28040                                  	;call	GET_EXT_ERR_NUMBER
 28041                                  	;pushf
 28042                                  	;cmp	ax,65
 28043                                  	;jnz	short DOCOPY_ERR
 28044                                  	;mov	dx,ACCDENPTR
 28045                                  	;call	STD_PRINTF
 28046                                  ;DOCOPY_ERR:
 28047                                  	;popf
 28048                                  	;retn
 28049                                  
 28050                                  	; 26/03/2023
 28051                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28052                                  OPENOK:
 28053 00004135 89C3                    	mov	bx,ax
 28054 00004137 891E[69A1]              	mov	[SRCHAND],bx		; save handle
 28055 0000413B B80057                  	mov	ax,File_Times*256 ; 5700h
 28056 0000413E CD21                    	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 28057                                  				; BX = file handle
 28058                                  
 28059 00004140 7223                    	jc	short Error_On_Source ; MSDOS 6.0
 28060                                  
 28061 00004142 8916[CEA1]              	mov	[CPDATE],dx		; save date
 28062 00004146 890E[D0A1]              	mov	[CPTIME],cx		; save time
 28063                                  
 28064                                  	; MSDOS 6.0
 28065                                  	;jmp	short No_Copy_Xa 	; (xa copy code removed)
 28066                                  	; 26/04/2023
 28067                                  No_Copy_Xa:
 28068                                  	; 26/03/2023
 28069                                  	;mov	bx,[SRCHAND]		;AN022; get handle back
 28070                                  
 28071                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28072 0000414A B80044                  	mov	ax,(IOCTL<<8) ; 4400h
 28073 0000414D CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28074                                  				; BX = file or device handle
 28075                                  	;and	dl,devid_ISDEV ; 80h
 28076                                  	; 18/04/2023
 28077 0000414F 80E280                  	and	dl,80h ; devid_ISDEV
 28078 00004152 8816[6BA1]              	mov	[SRCISDEV],dl		; set source info
 28079 00004156 7436                    	jz	short COPYLP		; source not a device
 28080 00004158 803E[C7A1]00            	cmp	byte [BINARY],0
 28081 0000415D 742F                    	je	short COPYLP		; ascii device ok
 28082 0000415F BA[3493]                	mov	dx,INBDEV_PTR		; cannot do binary input
 28083 00004162 E94A04                  	jmp	COPYERR
 28084                                  
 28085                                  Error_On_Source:			;AN022; we have a BAD error
 28086 00004165 E8CAE0                  	call	Set_Ext_Error_Msg	;AN022; set up the error message
 28087 00004168 C706[91A0][12A1]        	mov	word [string_ptr_2],SrcBuf
 28088                                  				;AN022; get address of failed string
 28089 0000416E C606[D291]01            	mov	byte [extend_buf_sub],one_subst ; 1
 28090                                  				;AN022; put number of subst in control block
 28091 00004173 E89113                  	call	std_eprintf		;AN022; print it
 28092                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 28093 00004176 8B1E[69A1]              	mov	bx,[SRCHAND]
 28094                                  	;cmp	word [SRCHAND],0	;AN022; did we open the file?
 28095                                  	;je	short No_Close_Src	;AN022; no - don't close
 28096 0000417A 09DB                    	or	bx,bx
 28097 0000417C 7403                    	jz	short No_Close_Src
 28098                                  	;call	CLOSESRC		;AN022; clean up
 28099                                  	; 26/03/2023
 28100 0000417E E89000                  	call	CLOSESRC2 ; bx = [SRCHAND]
 28101                                  No_Close_Src:				;AN022;
 28102 00004181 803E[109E]00            	cmp	byte [CFLAG],0		;AN022; was destination created?
 28103 00004186 7403                    	je	short EndCopyJ3		;AN022; no - just cleanup and exit
 28104 00004188 E956FD                  	jmp	ENDCOPY			;AN022; clean up concatenation and exit
 28105                                  EndCopyJ3:				;AN022;
 28106 0000418B E956FD                  	jmp	ENDCOPY2		;AN022;
 28107                                  
 28108                                  	; 26/04/2023
 28109                                  ;No_Copy_Xa:
 28110                                  ;	; 26/03/2023
 28111                                  ;	;mov	bx,[SRCHAND]		;AN022; get handle back
 28112                                  ;
 28113                                  ;	; MSDOS 3.3 (& MSDOS 6.0)
 28114                                  ;	mov	ax,(IOCTL<<8) ; 4400h
 28115                                  ;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28116                                  ;				; BX = file or device handle
 28117                                  ;	;and	dl,devid_ISDEV ; 80h
 28118                                  ;	; 18/04/2023
 28119                                  ;	and	dl,80h ; devid_ISDEV
 28120                                  ;	mov	[SRCISDEV],dl		; set source info
 28121                                  ;	jz	short COPYLP		; source not a device
 28122                                  ;	cmp	byte [BINARY],0
 28123                                  ;	je	short COPYLP		; ascii device ok
 28124                                  ;	mov	dx,INBDEV_PTR		; cannot do binary input
 28125                                  ;	jmp	COPYERR
 28126                                  
 28127                                  COPYLP:
 28128                                  	; 26/03/2023
 28129 0000418E 8B1E[69A1]              	mov	bx,[SRCHAND] ; ? ; 26/03/2023
 28130 00004192 8B0E[129E]              	mov	cx,[BYTCNT]
 28131 00004196 8B16[169E]              	mov	dx,[NXTADD]
 28132 0000419A 29D1                    	sub	cx,dx			; compute available space
 28133 0000419C 750E                    	jnz	short GOTROOM
 28134 0000419E E8D102                  	call	FlshFil   ; MSDOS 6.0
 28135                                  	;call	FLUSHFIL  ; MSDOS 3.3
 28136 000041A1 803E[CAA1]00            	cmp	byte [TERMREAD],0
 28137 000041A6 7565                    	jne	short CLOSESRC		; give up
 28138 000041A8 8B0E[129E]              	mov	cx,[BYTCNT]
 28139                                  GOTROOM:
 28140 000041AC 1E                      	push	ds
 28141 000041AD 8E1E[F59D]              	mov	ds,[TPA]
 28142 000041B1 B43F                    	mov	ah,READ ; 3Fh
 28143 000041B3 CD21                    	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 28144                                  				; BX = file handle,CX = number of bytes to read
 28145                                  				; DS:DX	-> buffer
 28146 000041B5 1F                      	pop	ds
 28147                                  	;jc	short CLOSESRC	; MSDOS 3.3
 28148                                  	; 26/03/2023
 28149 000041B6 72AD                    	jc	short Error_On_Source ; MSDOS 6.0
 28150 000041B8 89C1                    	mov	cx,ax			; get count
 28151 000041BA E351                    	jcxz	CLOSESRC		; no more to read
 28152 000041BC 803E[6BA1]00            	cmp	byte [SRCISDEV],0
 28153 000041C1 7507                    	jne	short NOTESTA		; is a device, ascii mode
 28154 000041C3 803E[CBA1]00            	cmp	byte [ASCII],0
 28155 000041C8 741B                    	je	short BINREAD
 28156                                  NOTESTA:
 28157 000041CA 89CA                    	mov	dx,cx
 28158 000041CC 8B3E[169E]              	mov	di,[NXTADD]
 28159 000041D0 B01A                    	mov	al,1Ah
 28160 000041D2 06                      	push	es
 28161 000041D3 8E06[F59D]              	mov	es,[TPA]		; scan for EOF
 28162 000041D7 F2AE                    	repne	scasb
 28163 000041D9 07                      	pop	es
 28164 000041DA 7505                    	jnz	short USEALL
 28165 000041DC FE06[049E]              	inc	byte [RDEOF]
 28166 000041E0 41                      	inc	cx
 28167                                  USEALL:
 28168 000041E1 29CA                    	sub	dx,cx
 28169 000041E3 89D1                    	mov	cx,dx
 28170                                  BINREAD:
 28171 000041E5 030E[169E]              	add	cx,[NXTADD]
 28172 000041E9 890E[169E]              	mov	[NXTADD],cx
 28173 000041ED 3B0E[129E]              	cmp	cx,[BYTCNT]		; is buffer full?
 28174 000041F1 720C                    	jb	short TESTDEV		; if not, we may have found eof
 28175                                  	; 26/03/2023
 28176 000041F3 E87C02                  	call	FlshFil
 28177                                  	;call	FLUSHFIL
 28178 000041F6 803E[CAA1]00            	cmp	byte [TERMREAD],0
 28179 000041FB 7510                    	jne	short CLOSESRC		; give up
 28180 000041FD EB8F                    	jmp	short COPYLP
 28181                                  TESTDEV:
 28182 000041FF 803E[6BA1]00            	cmp	byte [SRCISDEV],0	; if file then EOF
 28183 00004204 7407                    	je	short CLOSESRC
 28184 00004206 803E[049E]00            	cmp	byte [RDEOF],0
 28185 0000420B 7481                    	je	short COPYLP		; on device, go till ^Z
 28186                                  CLOSESRC:
 28187 0000420D 8B1E[69A1]              	mov	bx,[SRCHAND]
 28188                                  CLOSESRC2:
 28189 00004211 B43E                    	mov	ah,CLOSE ; 3Eh
 28190 00004213 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28191                                  				; BX = file handle
 28192                                  CLOSESRCDEST_RETN:
 28193 00004215 C3                      	retn
 28194                                  
 28195                                  ; ---------------------------------------------------------------------------
 28196                                  
 28197                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28198                                  CLOSEDEST:
 28199                                  
 28200                                  	;	We are called to close the destination.
 28201                                  	;	We need to note whether or not there is any internal data left
 28202                                  	;	to be flushed out.
 28203                                  
 28204 00004216 803E[119E]00            	cmp	byte [DestClosed],0
 28205 0000421B 75F8                    	jne	short CLOSESRCDEST_RETN	; don't double close
 28206 0000421D A0[0C9E]                	mov	al,[DestSwitch]
 28207 00004220 E8E803                  	call	SETASC			; check for b or a switch
 28208 00004223 742E                    	jz	short BINCLOS		;   on destination
 28209 00004225 8B1E[169E]              	mov	bx,[NXTADD]
 28210                                  ;
 28211                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 28212                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 28213                                  ;just return without appending a ^Z incorrectly for the first file (since we
 28214                                  ;are concatenating now). Also, in case it is a single file copy, we will
 28215                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 28216                                  ;performance overhead on single ASCII file copies which now always involve
 28217                                  ;2 writes instead of 1 before. Is this really that important?
 28218                                  ;
 28219                                  ;M048;	cmp	bx,[BYTCNT]		; is memory full?
 28220                                  ;M048;	jne	short PutZ
 28221                                  
 28222                                  	; 26/03/2023
 28223                                  	; MSDOS 3.3
 28224                                  	;cmp	bx,[BYTCNT]		; is memory full?
 28225                                  	;jne	short PUTZ
 28226                                  
 28227                                  	; 26/03/2023
 28228 00004229 E83902                  	call	TRYFLUSH		; flush (and double-check for concat)	
 28229 0000422C 7402                    	jz	short NOCONC
 28230                                  CONCHNG:
 28231 0000422E F9                      	stc
 28232 0000422F C3                      	retn
 28233                                  
 28234                                  NOCONC:	
 28235 00004230 31DB                    	xor	bx,bx
 28236                                  PUTZ:
 28237 00004232 1E                      	push	ds
 28238 00004233 8E1E[F59D]              	mov	ds,[TPA]
 28239 00004237 C7071A00                	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 28240 0000423B 1F                      	pop	ds
 28241 0000423C FF06[169E]              	inc	word [NXTADD]	; make sure our ^z gets written	
 28242 00004240 C606[C6A1]00            	mov	byte [NOWRITE],0
 28243 00004245 A1[C8A1]                	mov	ax,[WRITTEN]
 28244 00004248 0306[169E]              	add	ax,[NXTADD]
 28245 0000424C 7205                    	jc	short BINCLOS	; > 1
 28246 0000424E 83F801                  	cmp	ax,1
 28247 00004251 740C                    	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 28248                                  BINCLOS:
 28249 00004253 E80F02                  	call	TRYFLUSH
 28250 00004256 75D6                    	jnz	short CONCHNG
 28251                                  
 28252                                  	; 26/04/2023
 28253 00004258 833E[C8A1]00            	cmp	word [WRITTEN],0
 28254                                  	; 26/03/2023
 28255 0000425D 7503                    	jnz	short NO_FORGET
 28256                                  FORGETITJ:
 28257                                  	;jz	short FORGETIT	; never wrote nothing
 28258                                  	; 26/03/2023
 28259 0000425F E98500                  	jmp	FORGETIT ; 18/04/2023
 28260                                  NO_FORGET:			; wrote something
 28261 00004262 8B1E[06A1]              	mov	bx,[DESTHAND]
 28262 00004266 8B0E[D0A1]              	mov	cx,[CPTIME]
 28263 0000426A 8B16[CEA1]              	mov	dx,[CPDATE]
 28264 0000426E 803E[C5A1]00            	cmp	byte [INEXACT],0 ; copy not exact?
 28265 00004273 7431                    	je	short DODCLOSE	; if no, copy date & time
 28266 00004275 B42C                    	mov	ah,Get_Time ; 2Ch
 28267 00004277 CD21                    	int	21h		; DOS -	GET CURRENT TIME
 28268                                  				; Return: CH = hours,CL = minutes,DH = seconds
 28269                                  				; DL = hundredths of seconds
 28270 00004279 D0E1                    	shl	cl,1
 28271 0000427B D0E1                    	shl	cl,1		; left justify min in cl
 28272 0000427D D1E1                    	shl	cx,1
 28273 0000427F D1E1                    	shl	cx,1
 28274 00004281 D1E1                    	shl	cx,1		; hours to high 5 bits, min to 5-10
 28275 00004283 D0EE                    	shr	dh,1		; divide seconds by 2 (now 5 bits)
 28276 00004285 08F1                    	or	cl,dh		; and stick into low 5 bits of cx
 28277 00004287 51                      	push	cx		; save packed time
 28278 00004288 B42A                    	mov	ah,Get_Date ; 2Ah
 28279 0000428A CD21                    	int	21h		; DOS -	GET CURRENT DATE
 28280                                  				; Return: DL = day,DH = month,	CX = year
 28281                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 28282 0000428C 81E9BC07                	sub	cx,1980
 28283 00004290 86E9                    	xchg	ch,cl
 28284 00004292 D1E1                    	shl	cx,1		; year to high 7 bits
 28285 00004294 D0E6                    	shl	dh,1		; month to high 3 bits
 28286 00004296 D0E6                    	shl	dh,1
 28287 00004298 D0E6                    	shl	dh,1
 28288 0000429A D0E6                    	shl	dh,1
 28289 0000429C D0E6                    	shl	dh,1		; most sig bit of month in carry
 28290 0000429E 80D500                  	adc	ch,0		; put that bit next to year
 28291 000042A1 08F2                    	or	dl,dh		; or low three of month into day
 28292 000042A3 88EE                    	mov	dh,ch		; get year and high bit of month
 28293 000042A5 59                      	pop	cx
 28294                                  DODCLOSE:
 28295 000042A6 83FB00                  	cmp	bx,0
 28296 000042A9 7E36                    	jle	short CLOSEDONE
 28297 000042AB B80157                  	mov	ax,(File_Times<<8)|1 ; 5701h
 28298 000042AE CD21                    	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 28299                                  				; BX = file handle,CX = time to be set
 28300                                  				; DX = date to be set
 28301                                  	; 26/03/2023
 28302                                  	; MSDOS 6.0
 28303 000042B0 721A                    	jc	short Cleanup_Err ;AN022; handle error
 28304                                  
 28305                                  	;	See if the destination has *anything* in it.
 28306                                  	;	If not, just close and delete it.
 28307                                  
 28308 000042B2 B80242                  	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 28309 000042B5 31D2                    	xor	dx,dx
 28310 000042B7 89D1                    	mov	cx,dx
 28311 000042B9 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 28312                                  			; AL = method: offset from end of file
 28313                                  	;	DX:AX is file size
 28314                                  
 28315 000042BB 09C2                    	or	dx,ax
 28316 000042BD 9C                      	pushf
 28317 000042BE B80044                  	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 28318 000042C1 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28319                                  			; BX = file or device handle
 28320 000042C3 52                      	push	dx		; save them away
 28321 000042C4 B43E                    	mov	ah,CLOSE ; 3Eh
 28322 000042C6 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28323                                  			; BX = file handle
 28324 000042C8 5A                      	pop	dx
 28325                                  
 28326                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 28327                                  	; MSDOS 6.0
 28328 000042C9 730D                    	jnc	short Close_Cont ;AN022; handle error on close
 28329 000042CB 9D                      	popf			;AN022; get the flags back
 28330                                  Cleanup_Err: 			;AN022;
 28331 000042CC E85A00                  	call	CleanUpErr	;AN022; attempt to delete the target
 28332                                  	; 26/03/2023
 28333                                  	;call	DestDelete	;AN022; attempt to delete the target
 28334                                  	;jmp	short FILECLOSED
 28335                                  	;			;AN022; close the file
 28336                                  	; 26/03/2023
 28337                                  DestDel_fclosed:
 28338 000042CF E82700                  	call	DestDelete
 28339                                  FILECLOSED:
 28340 000042D2 FE06[119E]              	inc	byte [DestClosed]
 28341                                  RET50:
 28342 000042D6 F8                      	clc
 28343 000042D7 C3                      	retn
 28344                                  	
 28345                                  Close_Cont:			;AN022; no error - co
 28346                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28347 000042D8 9D                      	popf
 28348 000042D9 7506                    	jnz	short CLOSEDONE
 28349 000042DB F7C28000                	test	dx,80h		; is the destination a device?
 28350                                  	;jnz	short CLOSEDONE	; yes, copy succeeded
 28351                                  	;call	DestDelete
 28352                                  	;jmp	short FILECLOSED
 28353                                  	; 26/03/2023
 28354 000042DF 74EE                    	jz	short DestDel_fclosed
 28355                                  CLOSEDONE:
 28356 000042E1 FF06[1D9E]              	inc	word [FileCnt]
 28357                                  	; 26/03/2023
 28358 000042E5 EBEB                    	jmp	short FILECLOSED
 28359                                  	
 28360                                  ;FILECLOSED:
 28361                                  ;	inc	byte [DestClosed]
 28362                                  ;RET50:
 28363                                  	;clc
 28364                                  	;retn
 28365                                  
 28366                                  FORGETIT:
 28367 000042E7 8B1E[06A1]              	mov	bx,[DESTHAND]
 28368 000042EB E8B8FF                  	call	DODCLOSE	 ; close the dest
 28369 000042EE E80800                  	call	DestDelete
 28370 000042F1 C706[1D9E]0000          	mov	word [FileCnt],0 ; no files transferred
 28371 000042F7 EBDD                    	jmp	short RET50
 28372                                  
 28373                                  ; ---------------------------------------------------------------------------
 28374                                  
 28375                                  	; 26/03/2023
 28376                                  DestDelete:
 28377 000042F9 BA[AFA0]                	mov	dx,DestBuf
 28378 000042FC B441                    	mov	ah,Unlink ; 41h
 28379 000042FE CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 28380                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 28381                                  			;		(no wildcards allowed)
 28382 00004300 C3                      	retn
 28383                                  
 28384                                  ; ---------------------------------------------------------------------------
 28385                                  
 28386                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28387                                  SOURCE_SET:
 28388 00004301 56                      	push	si
 28389 00004302 A1[E7A1]                	mov	ax,[STARTEL]
 28390 00004305 BE[6CA1]                	mov	si,ScanBuf	; adjust to copy
 28391 00004308 29F0                    	sub	ax,si
 28392 0000430A BF[12A1]                	mov	di,SrcBuf
 28393 0000430D 01F8                    	add	ax,di
 28394 0000430F A3[0FA1]                	mov	[SrcTail],ax
 28395 00004312 880E[0EA1]              	mov	[SrcSiz],cl	; save its size
 28396 00004316 41                      	inc	cx		; include the nul
 28397 00004317 F3A4                    	rep	movsb		; save this source
 28398 00004319 883E[11A1]              	mov	[SrcInfo],bh	; save info about it
 28399 0000431D 5E                      	pop	si
 28400 0000431E 89E8                    	mov	ax,bp		; switches so far
 28401 00004320 E8E802                  	call	SETASC		; set a,b switches accordingly
 28402 00004323 E8A6E9                  	call	SWITCH		; get any more switches on this arg
 28403                                  	;call	SETASC		; set
 28404                                  	;retn
 28405                                  	; 26/03/2023
 28406 00004326 E9E202                  	jmp	SETASC
 28407                                  
 28408                                  ; =============== S U B	R O U T	I N E =======================================
 28409                                  
 28410                                  ; MSDOS 6.0
 28411                                  
 28412                                  ;****************************************************************
 28413                                  ;*
 28414                                  ;* ROUTINE:	CleanupErr
 28415                                  ;*
 28416                                  ;* FUNCTION:	Issues extended error message for destination
 28417                                  ;*		if not alreay issued
 28418                                  ;*
 28419                                  ;* INPUT:	return from INT 21
 28420                                  ;*
 28421                                  ;* OUTPUT:	none
 28422                                  ;*
 28423                                  ;****************************************************************
 28424                                  
 28425                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28426                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28427                                  	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
 28428                                  CleanUpErr:	;proc near		;AN022;
 28429                                  
 28430 00004329 803E[24A2]00            	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
 28431 0000432E 7511                    	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
 28432 00004330 E8FFDE                  	call	Set_Ext_Error_Msg	;AN022; set up error message
 28433 00004333 C706[91A0][AFA0]        	mov	word [string_ptr_2],DestBuf 
 28434                                  					;AN022; get address of failed string
 28435 00004339 C606[D291]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 28436                                  					;AN022; put number of subst in control block
 28437 0000433E E8C611                  	call	std_eprintf		;AN022; issue the error message
 28438                                  CleanupErr_Cont:			;AN022;
 28439                                  getansw_8:	; 12/06/2023
 28440 00004341 C3                      	retn				;AN022; return to caller
 28441                                  
 28442                                  ;CleanUpErr	endp			;AN022;
 28443                                  
 28444                                  
 28445                                  ; 12/06/2023
 28446                                  ; ---------------------------------------------------------------------------
 28447                                  ; MSDOS 6.2(2) COMMAND.COM procedure only !
 28448                                  ; -----------------------------------------
 28449                                  ; Hex-Rays IDA / disassembled source code ! modified for NASM by Erdogan Tan
 28450                                  ; ---------------------------------------------------------------------------
 28451                                  
 28452                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28453                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:456Dh
 28454                                  
 28455                                  get_answer_YNA:
 28456 00004342 C606[E3A1]00            	mov	byte [cox_dest_file],0	; clear validation flag
 28457 00004347 B80043                  	mov	ax,4300h
 28458 0000434A BA[AFA0]                	mov	dx,DestBuf
 28459 0000434D CD21                    	int	21h		; DOS -	2+ - GET FILE ATTRIBUTES
 28460                                  				; DS:DX	-> ASCIZ file name or directory
 28461                                  				; name without trailing	slash
 28462                                  	;jnc	short getansw_1
 28463                                  	;jmp	getansw_5
 28464                                  	; 12/06/2023
 28465 0000434F F5                      	cmc
 28466 00004350 73EF                    	jnc	short getansw_8 
 28467                                  getansw_1:
 28468 00004352 FE06[E3A1]              	inc	byte [cox_dest_file]	; valid destination file
 28469 00004356 8D36[D7A1]              	lea	si,cox_sublist_buff
 28470 0000435A C7040B00                	mov	word [si],11		; sublist size, 11 bytes
 28471 0000435E C74402[AFA0]            	mov	word [si+2],DestBuf	; sublist value	(pointer)
 28472 00004363 8C5C04                  	mov	[si+4],ds		; sublist segment
 28473                                  	;mov	byte [si+6],1		; sub id (N of %N)
 28474 00004366 C6440710                	mov	byte [si+7],10h		; data type flags
 28475                                  	;mov	byte [si+8],0		; maximum length (chars)
 28476                                  	;mov	byte [si+9],0		; minimum length (chars)
 28477                                  	;mov	byte [si+10],0		; pad field character (0)
 28478                                  	; 12/06/2023
 28479 0000436A 31C9                    	xor	cx,cx
 28480 0000436C 894C08                  	mov	[si+8],cx ; 0
 28481 0000436F 884C0A                  	mov	[si+10],cl ; 0
 28482 00004372 FEC1                    	inc	cl
 28483 00004374 884C06                  	mov	[si+6],cl ; 1	
 28484                                  
 28485                                  	; 12/06/2023
 28486                                  	;lea	si,cox_sublist_buff
 28487 00004377 B84F04                  	mov	ax,1103			; message number
 28488                                  					; 'Overwrite %1 (Yes/No/All)?'
 28489 0000437A BB0200                  	mov	bx,2			; std error (file handle = 2)
 28490                                  	; 12/06/2023
 28491                                  	;mov	cx,1			; byte count
 28492                                  	; cx = 1
 28493                                  	;mov	dh,0FFh			; message class	(utility)
 28494                                  	;xor	dl,dl			; control flag = 0
 28495 0000437D 31D2                    	xor	dx,dx
 28496 0000437F FECE                    	dec	dh  ; dh = 0FFh
 28497 00004381 E85614                  	call	SYSDISPMSG
 28498                                  	; 12/06/2023
 28499                                  	;xor	bx,bx
 28500                                  	; bh = 0
 28501                                  getansw_2:
 28502 00004384 B8080C                  	mov	ax,0C08h
 28503 00004387 CD21                    	int	21h		; DOS -	CLEAR KEYBOARD BUFFER
 28504                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 28505                                  	;cmp	al,0
 28506                                  	;jz	short getansw_2
 28507                                  	; 12/06/2023
 28508 00004389 20C0                    	and	al,al
 28509 0000438B 74F7                    	jz	short getansw_2
 28510 0000438D 3C0D                    	cmp	al,0Dh
 28511 0000438F 743B                    	je	short getansw_4
 28512 00004391 88C3                    	mov	bl,al
 28513 00004393 88C2                    	mov	dl,al
 28514 00004395 B82065                  	mov	ax,6520h
 28515 00004398 CD21                    	int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
 28516                                  				; AL = function	-
 28517 0000439A 3A16[AC6E]              	cmp	dl,[_Y_es]		; 'Y' ?
 28518 0000439E 740C                    	je	short getansw_3
 28519 000043A0 3A16[AD6E]              	cmp	dl,[_N_o]		; 'N' ?
 28520 000043A4 7406                    	je	short getansw_3
 28521 000043A6 3A16[AE6E]              	cmp	dl,[_A_ll]		; 'A' ?
 28522 000043AA 75D8                    	jne	short getansw_2
 28523                                  getansw_3:
 28524 000043AC 88DF                    	mov	bh,bl
 28525 000043AE 53                      	push	bx
 28526 000043AF 881E[AB6E]              	mov	[MSG_1104],bl
 28527 000043B3 B440                    	mov	ah,40h
 28528 000043B5 BB0200                  	mov	bx,2			; std error (file handle = 2)
 28529 000043B8 B90100                  	mov	cx,1			; byte count
 28530 000043BB BA[AB6E]                	mov	dx,MSG_1104
 28531 000043BE CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28532                                  				; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
 28533 000043C0 B440                    	mov	ah,40h
 28534 000043C2 C606[AB6E]08            	mov	byte [MSG_1104],8	; backspace (move cursor to back)
 28535 000043C7 CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28536                                  				; BX = file handle, CX = number	of bytes to write, DS:DX -> buffer
 28537 000043C9 5B                      	pop	bx
 28538 000043CA EBB8                    	jmp	short getansw_2
 28539                                  getansw_4:
 28540                                  	;cmp	bh,0
 28541                                  	;jz	short getansw_2
 28542                                  	; 12/06/2023
 28543 000043CC 08FF                    	or	bh,bh
 28544 000043CE 74B4                    	jz	short getansw_2
 28545 000043D0 88FA                    	mov	dl,bh
 28546 000043D2 B82065                  	mov	ax,6520h
 28547 000043D5 CD21                    	int	21h		; DOS -	4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
 28548                                  				; AL = function	-
 28549 000043D7 52                      	push	dx
 28550 000043D8 B82E04                  	mov	ax,1070			; message number
 28551 000043DB BB0200                  	mov	bx,2			; std error (file handle = 2)
 28552 000043DE 31C9                    	xor	cx,cx
 28553                                  	;mov	dh,0FFh			; message class	(utility)
 28554                                  	;xor	dl,dl
 28555                                  	; 12/06/2023
 28556 000043E0 31D2                    	xor	dx,dx
 28557 000043E2 FECE                    	dec	dh  ; dh = 0FFh
 28558 000043E4 E8F313                  	call	SYSDISPMSG
 28559 000043E7 5A                      	pop	dx
 28560 000043E8 3A16[AC6E]              	cmp	dl,[_Y_es]
 28561 000043EC 740B                    	jz	short getansw_5
 28562 000043EE 3A16[AD6E]              	cmp	dl,[_N_o]
 28563 000043F2 7406                    	jz	short getansw_6
 28564 000043F4 C606[E2A1]00            	mov	byte [cox_y_override],0
 28565                                  	; 12/06/2023
 28566                                  	;jmp	short $+2
 28567                                  getansw_5:
 28568                                  	; 12/06/2023
 28569                                  	;clc
 28570                                  	; cf = 0
 28571                                  	;jmp	short getansw_7
 28572                                  	; 12/06/2023
 28573 000043F9 C3                      	retn
 28574                                  getansw_6:
 28575                                  gcpcmdo_2:	; 12/06/2023
 28576                                  gecpcmd_3:	; 12/06/2023
 28577 000043FA F9                      	stc
 28578                                  getansw_7:
 28579 000043FB C3                      	retn
 28580                                  
 28581                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28582                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:463Ah
 28583                                  init_copycmd_option:
 28584 000043FC C606[E2A1]01            	mov	byte [cox_y_override],1 ; suppress copy overwrite confirmation
 28585 00004401 06                      	push	es
 28586 00004402 8E06[F39D]              	mov	es,[RESSEG]
 28587 00004406 268E06[DC03]            	mov	es,[es:EnvirSeg]
 28588 0000440B 8D36[FC98]              	lea	si,copycmd		; "COPYCMD="
 28589 0000440F B90800                  	mov	cx,8
 28590 00004412 E83500                  	call	getenv_copycmd
 28591 00004415 7216                    	jc	short icpcmd_3
 28592 00004417 E82000                  	call	get_copycmd_option	; copycmd=/Y or copycmd=/-Y
 28593 0000441A 720F                    	jc	short icpcmd_2
 28594 0000441C 47                      	inc	di			; skip '/'
 28595 0000441D 268A05                  	mov	al,[es:di]
 28596 00004420 24DF                    	and	al,0DFh			; convert to uppercase
 28597 00004422 3C59                    	cmp	al,'Y'
 28598 00004424 7505                    	jnz	short icpcmd_2
 28599                                  icpcmd_1:
 28600 00004426 C606[E2A1]00            	mov	byte [cox_y_override],0	; clear copy overwrite question/confirmation
 28601                                  					; (don't suppress)
 28602                                  icpcmd_2:
 28603 0000442B 07                      	pop	es
 28604 0000442C C3                      	retn
 28605                                  icpcmd_3:				; ...
 28606 0000442D 8E06[F39D]              	mov	es,[RESSEG]
 28607 00004431 803E[9B01]00            	cmp	byte [cox_Y_option],0	; default (/Y) switch option (1 = enabled)
 28608 00004436 74F3                    	jz	short icpcmd_2
 28609 00004438 EBEC                    	jmp	short icpcmd_1
 28610                                  
 28611                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28612                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4679h
 28613                                  get_copycmd_option:
 28614 0000443A 26803D00                	cmp	byte [es:di],0
 28615 0000443E 74BA                    	jz	short gcpcmdo_2
 28616 00004440 26803D2F                	cmp	byte [es:di],'/'
 28617 00004444 7403                    	jz	short gcpcmdo_1
 28618 00004446 47                      	inc	di
 28619 00004447 EBF1                    	jmp	short get_copycmd_option
 28620                                  gcpcmdo_1:
 28621                                  	; 12/06/2023
 28622                                  	;clc
 28623                                  	; cf = 0
 28624                                  	;jmp	short gcpcmdo_3
 28625                                  	; 12/06/2023
 28626 00004449 C3                      	retn
 28627                                  	; 12/06/2023
 28628                                  ;gcpcmdo_2:
 28629                                  ;	stc
 28630                                  ;gcpcmdo_3:
 28631                                  ;	retn
 28632                                  
 28633                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28634                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:468Dh
 28635                                  getenv_copycmd:
 28636 0000444A 31FF                    	xor	di,di
 28637 0000444C 30C0                    	xor	al,al
 28638                                  gecpcmd_1:
 28639                                  	;cmp	byte [es:di],0
 28640                                  	; 12/06/2023
 28641 0000444E 263805                  	cmp	[es:di],al ; 0
 28642 00004451 74A7                    	jz	short gecpcmd_3
 28643 00004453 51                      	push	cx
 28644 00004454 56                      	push	si
 28645 00004455 F3A6                    	repe	cmpsb
 28646 00004457 5E                      	pop	si
 28647 00004458 59                      	pop	cx
 28648 00004459 7409                    	jz	short gecpcmd_2 ; cf = 0
 28649 0000445B 51                      	push	cx
 28650 0000445C B90080                  	mov	cx,32768
 28651 0000445F F2AE                    	repne	scasb	; al = 0
 28652 00004461 59                      	pop	cx
 28653 00004462 EBEA                    	jmp	short gecpcmd_1
 28654                                  gecpcmd_2:
 28655                                  	;clc
 28656                                  	; 12/06/2023
 28657                                  	; cf = 0
 28658                                  	;jmp	short gecpcmd_4
 28659                                  	; 12/06/2023
 28660 00004464 C3                      	retn
 28661                                  	; 12/06/2023
 28662                                  ;gecpcmd_3:
 28663                                  ;	stc
 28664                                  ;gecpcmd_4:
 28665                                  ;	retn
 28666                                  
 28667                                  ;============================================================================
 28668                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 28669                                  ;============================================================================
 28670                                  ; 01/10/2018 - Retro DOS v3.0
 28671                                  
 28672                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 28673                                  
 28674                                  ; =============== S U B	R O U T	I N E =======================================
 28675                                  
 28676                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 28677                                  ;
 28678                                  ;	EXIT	ZR set if concatenate flag unchanged
 28679                                  
 28680                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28681                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
 28682                                  
 28683                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 28684                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:46ADh
 28685                                  TRYFLUSH:
 28686 00004465 A0[069E]                	mov	al,[Concat]
 28687 00004468 50                      	push	ax
 28688                                  	;call	FLUSHFIL
 28689 00004469 E80600                  	call	FlshFil
 28690 0000446C 58                      	pop	ax
 28691 0000446D 3A06[069E]              	cmp	al,[Concat]
 28692 00004471 C3                      	retn
 28693                                  
 28694                                  ; =============== S U B	R O U T	I N E =======================================
 28695                                  
 28696                                  	; 26/03/2023
 28697                                  	; MSDOS 3.3
 28698                                  ;FLUSHFIL:
 28699                                  	;mov	al,[BINARY]
 28700                                  	;mov	ah,[ASCII]
 28701                                  	;push	ax
 28702                                  	;call	FLSHFIL
 28703                                  	;pop	ax
 28704                                  	;mov	[ASCII],ah
 28705                                  	;mov	[BINARY],al
 28706                                  	;retn
 28707                                  
 28708                                  ; =============== S U B	R O U T	I N E =======================================
 28709                                  
 28710                                  ;***	Flshfil - write out any data remaining in copy buffer.
 28711                                  ;
 28712                                  ;	Inputs:
 28713                                  ;	  [NXTADD] = No. of bytes to write
 28714                                  ;	  [CFLAG] <> 0 if file has been created
 28715                                  ;	Outputs:
 28716                                  ;	  [NXTADD] = 0
 28717                                  
 28718                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28719                                  	;
 28720                                  	; 13/06/2023 - Retro DOS v4.2 COMMAND.COM
 28721                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:46BAh
 28722                                  FlshFil:
 28723 00004472 C606[CAA1]00            	mov	byte [TERMREAD],0
 28724 00004477 803E[109E]00            	cmp	byte [CFLAG],0
 28725 0000447C 7403                    	jz	short NotExists
 28726 0000447E E99600                  	jmp	Exists
 28727                                  NotExists:
 28728 00004481 E8A101                  	call	BUILDDEST		; find out all about the destination
 28729 00004484 E8FA03                  	call	COMPNAME		; source and dest. the same?
 28730 00004487 7519                    	jnz	short ProcDest		; if not, go ahead
 28731 00004489 803E[6BA1]00            	cmp	byte [SRCISDEV],0
 28732 0000448E 7512                    	jnz	short ProcDest		; same name on device ok
 28733 00004490 803E[069E]00            	cmp	byte [Concat],0		; concatenation?
 28734 00004495 BA[F991]                	mov	dx,OVERWR_PTR
 28735                                  	;je	short COPERR		; not concatenating - overwrite error
 28736                                  	; 26/03/2023
 28737 00004498 7503                    	jne	short No_Concat_Err
 28738 0000449A E91201                  	jmp	COPYERR
 28739                                  	
 28740                                  No_Concat_Err:	; concatenating
 28741 0000449D C606[C6A1]01            	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
 28742                                  ProcDest:
 28743                                  	; MSDOS 6.0
 28744                                  	;mov	ax,(ExtOpen<<8)		; open the file
 28745                                  	; 26/03/2023
 28746 000044A2 B8006C                  	mov	ax,6C00h
 28747 000044A5 BE[AFA0]                	mov	si,DestBuf		; get file name
 28748                                  ;M046
 28749                                  ; For writes, we want to deny writes by anyone else at the same time that we
 28750                                  ;are writing to it. For instance, on a network, 2 workstations could try
 28751                                  ;writing to the same file. Also, because we opened the source file with
 28752                                  ;DENY NONE, it is fine if the source and destination files are the same as
 28753                                  ;would happen when we append to an existing file.
 28754                                  
 28755                                  	; 26/03/2023
 28756                                  	;mov	bx,deny_write|write_open_mode
 28757 000044A8 BB2100                  	mov	bx,21h			; get open mode for copy; M046
 28758 000044AB 31C9                    	xor	cx,cx			; no special files
 28759                                  	;mov	dx,write_open_flag	; set up open flags
 28760 000044AD BA0101                  	mov	dx,101h	
 28761                                  
 28762 000044B0 803E[C6A1]00            	cmp	byte [NOWRITE],0
 28763 000044B5 7503                    	jne	short DoDestOpen	; don't actually create if nowrite set
 28764                                  	;mov	dx,creat_open_flag	; set up create flags
 28765 000044B7 BA1201                  	mov	dx,112h
 28766                                  
 28767                                  	; 26/03/2023
 28768                                  	; MSDOS 3.3
 28769                                  	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 28770                                  	;cmp	byte [NOWRITE],0
 28771                                  	;jne	short DODESTOPEN
 28772                                  	;mov	ah,CREAT ; 3Ch
 28773                                  	;xor	cx,cx
 28774                                  ;DODESTOPEN:
 28775                                  	;mov	dx,DESTBUF
 28776                                  	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 28777                                  	;		; CX = attributes for file
 28778                                  	;		; DS:DX	-> ASCIZ filename (may include drive and path)
 28779                                  
 28780                                  ; 26/03/2023
 28781                                  ;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 28782                                  ;	;mov	dx,FULDIRPTR
 28783                                  ;	;call	GET_EXT_ERR_NUMBER
 28784                                  ;	;jc	short COPERR
 28785                                  ;
 28786                                  ;	; 01/10/2018
 28787                                  ;	;jnc	short DEST_OPEN_OKAY
 28788                                  ;		
 28789                                  ;	;mov	dx,FULDIRPTR
 28790                                  ;	;call	GET_EXT_ERR_NUMBER
 28791                                  ;	;jmp	short COPERR
 28792                                  ;
 28793                                  ;	jc	short DEST_OPEN_ERROR
 28794                                  
 28795                                  	; 26/03/2023
 28796                                  DoDestOpen:
 28797 000044BA CD21                    	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
 28798                                  			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
 28799                                  			; BH = flags
 28800                                  			; CX = create attribute
 28801                                  			; DL = action if file exists/does not exists
 28802                                  			; DH = 00h (reserved), DS:SI -> ASCIZ file name
 28803                                  
 28804                                  ;	We assume that the error is normal.
 28805                                  ;	TriageError will correct the DX value appropriately.
 28806                                  	
 28807 000044BC 7311                    	jnc	short Dest_Open_Okay
 28808                                  Xa_Set_Error:				;AN030; error occurred on XA
 28809 000044BE E871DD                  	call	Set_Ext_Error_Msg	;AN030; get extended error
 28810                                  
 28811                                  	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
 28812                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
 28813                                  Ext_Err_Set:				;AN030;
 28814 000044C1 C706[91A0][AFA0]        	mov	word [string_ptr_2],DestBuf
 28815                                  					;AN000; get address of failed string
 28816 000044C7 C606[D291]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 28817                                  					;AN030; put number of subst in control block
 28818                                  CopErrJ2:				;AN030;
 28819 000044CC E9E000                  	jmp	COPYERR			;AN030; go issue message
 28820                                  
 28821                                  ;DEST_OPEN_OKAY:
 28822                                  	; 26/03/2023
 28823                                  Dest_Open_Okay:
 28824 000044CF A3[06A1]                	mov	[DESTHAND],ax		; save handle
 28825 000044D2 C606[109E]01            	mov	byte [CFLAG],1		; destination now exists
 28826 000044D7 89C3                    	mov	bx,ax
 28827 000044D9 B80044                  	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
 28828 000044DC CD21                    	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 28829                                  			   	; BX = file or device handle
 28830                                  
 28831 000044DE 8816[08A1]              	mov	[DESTISDEV],dl		; set dest info
 28832                                  	; 18/04/2023
 28833 000044E2 F6C280                  	test	dl,80h
 28834                                  	;test	dl,devid_ISDEV
 28835 000044E5 7430                    	jz	short Exists		; Dest not a device
 28836                                  
 28837                                  ;	Destination is device.
 28838                                  
 28839 000044E7 A0[0C9E]                	mov	al,[DestSwitch]
 28840                                  	; 26/03/2023
 28841 000044EA 240C                    	and	al,0Ch
 28842                                  	;and	al,SWITCHA+SWITCHB ; 4+8
 28843 000044EC 7509                    	jnz	short TestBoth
 28844 000044EE A0[CBA1]                	mov	al,[ASCII]		; neither set, use current setting
 28845 000044F1 0A06[C7A1]              	or	al,[BINARY]
 28846 000044F5 7416                    	jz	short ExSetA		; neither set, default to ascii
 28847                                  TestBoth:
 28848 000044F7 7A1E                    	jpe	short Exists		; both are set, ignore
 28849 000044F9 A808                    	test	al,8
 28850                                  	;test	al,SWITCHB
 28851 000044FB 741A                    	jz	short Exists
 28852                                  	;mov	ax,(IOCTL shl 8) or 1
 28853 000044FD B80144                  	mov	ax,(IOCTL<<8)|1 ; 4401h
 28854 00004500 30F6                    	xor	dh,dh
 28855                                  	; 18/04/2023
 28856 00004502 80CA20                  	or	dl,20h
 28857                                  	;or	dl,devid_RAW
 28858 00004505 8816[08A1]              	mov	[DESTISDEV],dl
 28859 00004509 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 28860                                  			; BX = device handle,DH = 0
 28861                                  			; DL = device information to set (bits 0-7 from	function 0)
 28862 0000450B EB0A                    	jmp	short Exists
 28863                                  
 28864                                  	; 26/03/2023
 28865                                  	; 01/10/2018 - Retro DOS v3.0 modification
 28866                                  ;DEST_OPEN_ERROR:
 28867                                  	;mov	dx,FULDIRPTR
 28868                                  	;call	GET_EXT_ERR_NUMBER
 28869                                  ;COPERR:
 28870                                  	; 26/03/2023
 28871                                  ;CopyErrj:
 28872                                  	;jmp	short COPYERR
 28873                                  
 28874                                  ExSetA:
 28875                                  ;	What we read in may have been in binary mode, flag zapped write OK
 28876                                  
 28877 0000450D C606[CBA1]04            	mov	byte [ASCII],4
 28878                                  	;mov	byte [ASCII],SWITCHA	; set ascii mode
 28879 00004512 800E[C5A1]04            	or	byte [INEXACT],4
 28880                                  	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
 28881                                  Exists:
 28882 00004517 803E[C6A1]00            	cmp	byte [NOWRITE],0
 28883 0000451C 7524                    	jnz	short NoChecking	; if nowrite don't bother with name check
 28884 0000451E 803E[87A0]01            	cmp	byte [plus_comma],1	; don't check if just doing +,,
 28885 00004523 741D                    	jz	short NoChecking
 28886 00004525 E85903                  	call	COMPNAME		; source and dest. the same?
 28887 00004528 7518                    	jnz	short NoChecking	; if not, go ahead
 28888 0000452A 803E[6BA1]00            	cmp	byte [SRCISDEV],0
 28889 0000452F 7511                    	jne	short NoChecking	; same name on device ok
 28890                                  
 28891                                  ;	At this point we know in append (would have gotten overwrite error
 28892                                  ;	on first destination create otherwise), and user trying to specify
 28893                                  ;	destination which has been scribbled already (if dest had been named
 28894                                  ;	first, NoWrite would be set).
 28895                                  
 28896 00004531 BA[FC91]                	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
 28897                                  	;invoke	Std_EprintF		;ac022;
 28898                                  	; 26/03/2023
 28899 00004534 E8D00F                  	call	std_eprintf ; MSDOS 6.0 (& 5.0)
 28900                                  	;call	STD_PRINTF  ; MSDOS 3.3	
 28901 00004537 C706[169E]0000          	mov	word [NXTADD],0		; set return
 28902 0000453D FE06[CAA1]              	inc	byte [TERMREAD]		; tell read to give up
 28903                                  Ret60:
 28904 00004541 C3                      	retn
 28905                                  
 28906                                  NoChecking:
 28907 00004542 8B1E[06A1]              	mov	bx,[DESTHAND]		; get handle
 28908 00004546 31C9                    	xor	cx,cx
 28909 00004548 870E[169E]              	xchg	cx,[NXTADD]
 28910 0000454C E3F3                    	jcxz	Ret60			; if nothing to write, forget it
 28911 0000454E FF06[C8A1]              	inc	word [WRITTEN]		; flag that we wrote something
 28912 00004552 803E[C6A1]00            	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 28913 00004557 7514                    	jnz	short SeekEnd
 28914 00004559 31D2                    	xor	dx,dx
 28915 0000455B 1E                      	push	ds
 28916 0000455C 8E1E[F59D]              	mov	ds,[TPA]
 28917 00004560 B440                    	mov	ah,Write ; 40h
 28918 00004562 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28919                                  			; BX = file handle,CX = number of bytes to write,DS:DX -> buffer
 28920 00004564 1F                      	pop	ds
 28921 00004565 BA[E491]                	mov	dx,NOSPACE_PTR
 28922                                  	;jc	short COPERRP		; failure
 28923                                  	; 26/03/2023
 28924                                  	; MSDOS 6.0
 28925 00004568 7326                    	jnc	short NoChecking2
 28926 0000456A E951FF                  	jmp	Xa_Set_Error
 28927                                  
 28928                                  	; 18/04/2023
 28929                                  	; 26/03/2023
 28930                                  SeekEnd:
 28931 0000456D 31D2                    	xor	dx,dx
 28932 0000456F 87D1                    	xchg	dx,cx
 28933                                  	;mov	ax,(LSEEK shl 8) or 1
 28934 00004571 B80142                  	mov	ax,(LSEEK<<8)|1 ; 4201h
 28935 00004574 CD21                    	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 28936                                  				; AL = method: offset from present location
 28937                                  
 28938                                  	; 26/03/2023
 28939                                  	; MSDOS 6.0
 28940                                  
 28941                                  ;	Save the file pointer in DX:AX to restore the file
 28942                                  ;	with in case the copy should fail.
 28943                                  
 28944 00004576 A3[D2A1]                	mov	[OFilePtr_Lo],ax
 28945 00004579 8916[D4A1]              	mov	[OFilePtr_Hi],dx
 28946                                  
 28947                                  	; 26/03/2023
 28948                                  	; MSDOS 3.3  MSDOS 6.0
 28949                                  
 28950 0000457D 803E[049E]00            	cmp	byte [RDEOF],0
 28951 00004582 740B                    	jz	short Retz60
 28952                                  
 28953                                  ;	^Z has been read - we must set the file size to the current
 28954                                  ;	file pointer location
 28955                                  
 28956 00004584 B440                    	mov	ah,Write ; 40h
 28957 00004586 CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 28958                                  				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 28959                                  
 28960                                  	; 26/03/2023
 28961                                  	; MSDOS 6.0
 28962 00004588 727E                    	jc	short Xa_Set_Error_Jmp	;AC022; failure
 28963                                  
 28964                                  ;	Make note that ^Z was removed, in case the
 28965                                  ;	copy should fail and we need to restore the file.
 28966                                  
 28967 0000458A C606[D6A1]1A            	mov	byte [OCtrlZ],1Ah
 28968                                  Retz60:
 28969 0000458F C3                      	retn
 28970                                  
 28971                                  NoChecking2:
 28972 00004590 29C1                    	sub	cx,ax
 28973 00004592 74AD                    	jz	short Ret60		; wrote all supposed to
 28974                                  	; 18/04/2023
 28975 00004594 F606[08A1]80            	test	byte [DESTISDEV],80h ; devid_ISDEV
 28976                                  	;test	byte [DESTISDEV],devid_ISDEV ;80h
 28977 00004599 7414                    	jz	short COPYERR		; is a file, error
 28978 0000459B F606[08A1]20            	test	byte [DESTISDEV],20h  ; devid_RAW
 28979                                  	;test	byte [DESTISDEV],devid_RAW ; 20h
 28980 000045A0 750A                    	jnz	short DevWrtErr	; is a raw device, error
 28981 000045A2 803E[C5A1]00            	cmp	byte [INEXACT],0
 28982 000045A7 7598                    	jnz	short Ret60		; inexact so ok
 28983 000045A9 49                      	dec	cx
 28984                                  ;Retz60:
 28985 000045AA 7495                    	jz	short Ret60		; wrote one byte less (the ^z)
 28986                                  
 28987                                  DevWrtErr:
 28988 000045AC BA[6793]                	mov	dx,DEVWMES_PTR
 28989                                  	; 26/03/2023
 28990                                  COPYERR:
 28991                                  	;invoke	Std_EPrintF		;AC022;
 28992 000045AF E8550F                  	call	std_eprintf  ; MSDOS 6.0
 28993                                  	;call	STD_PRINTF   ; MSDOS 3.3
 28994                                  CopErrP:
 28995 000045B2 FE06[119E]              	inc	byte [DestClosed]
 28996 000045B6 803E[109E]00            	cmp	byte [CFLAG],0
 28997 000045BB 7448                    	jz	short EndCopyJ		; never actually got it open
 28998 000045BD 8B1E[06A1]              	mov	bx,[DESTHAND]
 28999 000045C1 83FB00                  	cmp	bx,0
 29000 000045C4 7E33                    	jle	short NoClose
 29001                                  
 29002                                  ;	Check to see if we should save part of the destination file.
 29003                                  
 29004                                  	; 26/03/2023
 29005                                  	; MSDOS 6.0
 29006 000045C6 8B0E[D4A1]              	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
 29007 000045CA 8B16[D2A1]              	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
 29008                                  			
 29009 000045CE 89C8                    	mov	ax,cx
 29010 000045D0 09D0                    	or	ax,dx
 29011 000045D2 7421                    	jz	short ceClose		; null file ptr means nothing to save
 29012                                  
 29013                                  ;	Destination was also the first source. Do the best we can to
 29014                                  ;	restore it. Truncate it back to the size we took from it (which
 29015                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 29016                                  ;	file). If a Ctrl-Z was originally read, put it back.
 29017                                  
 29018 000045D4 B80042                  	mov	ax,(LSEEK<<8) ; 4200h
 29019 000045D7 CD21                    	int	21h
 29020                                  
 29021 000045D9 31C9                    	xor	cx,cx			; CX = # bytes to write = 0
 29022 000045DB B440                    	mov	ah,Write ; 40h
 29023 000045DD CD21                    	int	21h			; truncate file
 29024                                  
 29025 000045DF 803E[D6A1]00            	cmp	byte [OCtrlZ],0
 29026 000045E4 7408                    	je	short ceClose0		; no ctrl-z removed from original
 29027 000045E6 41                      	inc	cx			; CX = # bytes to write = 1
 29028 000045E7 BA[D6A1]                	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
 29029 000045EA B440                    	mov	ah,Write ; 40h
 29030 000045EC CD21                    	int	21h			; write ctrl-z
 29031                                  ceClose0:
 29032 000045EE B43E                    	mov	ah,CLOSE ; 3Eh
 29033 000045F0 CD21                    	int	21h			; close it
 29034                                  ;;	;mov	byte [CFLAG],0
 29035 000045F2 E9ECF8                  	jmp	ENDCOPY			; and go home
 29036                                  
 29037                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29038                                  ceClose:
 29039 000045F5 B43E                    	mov	ah,CLOSE ; 3Eh		; close the file
 29040 000045F7 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 29041                                  				; BX = file handle
 29042                                  NoClose:
 29043 000045F9 BA[AFA0]                	mov	dx,DestBuf
 29044 000045FC B441                    	mov	ah,Unlink ; 41h 	; and delete it
 29045 000045FE CD21                    	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 29046                                  				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 29047 00004600 C606[109E]00            	mov	byte [CFLAG],0
 29048                                  EndCopyJ:
 29049 00004605 E9D9F8                  	jmp	ENDCOPY
 29050                                  
 29051                                  Xa_Set_Error_Jmp:			;AN022; go set up error message
 29052 00004608 E9B3FE                  	jmp	Xa_Set_Error
 29053                                  
 29054                                  ;============================================================================
 29055                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 29056                                  ;============================================================================
 29057                                  ; 01/10/2018 - Retro DOS v3.0
 29058                                  
 29059                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 29060                                  
 29061                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29062                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h
 29063                                  
 29064                                  ; =============== S U B	R O U T	I N E =======================================
 29065                                  
 29066                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 29067                                  ;
 29068                                  ;	Given switch vector in AX,
 29069                                  ;	  Set Ascii flag if /a is set
 29070                                  ;	  Clear Ascii flag if /b is set
 29071                                  ;	  Binary set if /b specified
 29072                                  ;	  Leave Ascii unchanged if neither or both are set
 29073                                  ; 	Also sets Inexact if Ascii is ever set. 
 29074                                  ;	AL = Ascii on exit, flags set
 29075                                  
 29076                                  	; 26/03/2023
 29077                                  SETASC:
 29078                                  	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 29079 0000460B 240C                    	and	al,0Ch ; 4+8
 29080 0000460D 7A10                    	jpe	short LOADSW	; even parity - both or neither
 29081 0000460F 50                      	push	ax
 29082                                  	;and	al,SWITCHB  ; 8
 29083 00004610 2408                    	and	al,8
 29084 00004612 A2[C7A1]                	mov	[BINARY],al
 29085 00004615 58                      	pop	ax
 29086                                  	;and	al,SWITCHA
 29087 00004616 2404                    	and	al,4	
 29088 00004618 A2[CBA1]                	mov	[ASCII],al
 29089 0000461B 0806[C5A1]              	or	[INEXACT],al
 29090                                  LOADSW:
 29091 0000461F A0[CBA1]                	mov	al,[ASCII]
 29092 00004622 08C0                    	or	al,al
 29093 00004624 C3                      	retn
 29094                                  
 29095                                  ; =============== S U B	R O U T	I N E =======================================
 29096                                  
 29097                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29098                                  	; 13/06/2023 - Retro DOS v4.2 COMMAND.COM
 29099                                  BUILDDEST:
 29100 00004625 803E[AAA0]FF            	cmp	byte [DestIsDir],-1 ; 0FFh
 29101 0000462A 750C                    	jnz	short KNOWABOUTDEST	; figuring already done
 29102 0000462C BF[D59C]                	mov	di,USERDIR1
 29103 0000462F BD[AAA0]                	mov	bp,DestVars
 29104 00004632 E8E000                  	call	BUILDPATH
 29105 00004635 E899E3                  	call	RestUDir1
 29106                                  
 29107                                  ;	We now know all about the destination
 29108                                  
 29109                                  KNOWABOUTDEST:
 29110 00004638 30C0                    	xor	al,al
 29111 0000463A 8606[09A1]              	xchg	al,[FIRSTDEST]
 29112 0000463E 08C0                    	or	al,al
 29113 00004640 7503                    	jnz	short FIRSTDST
 29114 00004642 E98D00                  	jmp	NOFIRSTDEST
 29115                                  
 29116                                  FIRSTDST:
 29117                                  ;	Create an fcb of the original dest.
 29118                                  
 29119 00004645 8B36[ACA0]              	mov	si,[DestTail]
 29120 00004649 BF[E79F]                	mov	di,DestFcb
 29121 0000464C B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 29122 0000464F CD21                    	int	21h		; DOS -	PARSE FILENAME
 29123                                  				; DS:SI	-> string to parse
 29124                                  				; ES:DI	-> buffer to fill with unopened	FCB
 29125                                  				; AL = bit mask	to control parsing
 29126 00004651 803C00                  	cmp	byte [si],0
 29127 00004654 7406                    	jz	short GOODPARSE
 29128                                  
 29129                                  	; 27/03/2023	
 29130                                  	; MSDOS 6.0
 29131                                  	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
 29132                                  	
 29133 00004656 BA[EA91]                	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
 29134 00004659 E953FF                  	jmp	COPYERR			;AN052;
 29135                                  GOODPARSE:
 29136 0000465C A1[AFA0]                	mov	ax,[DestBuf]		; AX = possible "d:"
 29137 0000465F 80FC3A                  	cmp	ah,':'
 29138 00004662 7402                    	jz	short DRVSPEC4
 29139 00004664 B040                    	mov	al,'@'  ; 40h
 29140                                  DRVSPEC4:
 29141                                  ;	AX = "d:" for following FCB drive computation
 29142                                  
 29143 00004666 8A0E[CBA1]              	mov	cl,[ASCII]		; CL = saved Ascii flag
 29144 0000466A 0C20                    	or	al,20h
 29145 0000466C 2C60                    	sub	al,60h
 29146 0000466E A2[E79F]                	mov	[DestFcb],al		; store drive # in FCB
 29147                                  
 29148                                  ;*	Figure out what copy mode we're in.
 29149                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 29150                                  ;	+n stands for additional sources delimited by +'s.
 29151                                  ;
 29152                                  ;	copy a b	not concatenating
 29153                                  ;	copy a *	not concatenating
 29154                                  ;	copy * a	concatenating
 29155                                  ;	copy * *	not concatenating
 29156                                  ;	copy a+n b	concatenating
 29157                                  ;	copy *+n a	concatenating
 29158                                  ;	copy *+n *	concatenating, Mel Hallerman style
 29159                                  
 29160                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 29161                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 29162                                  
 29163 00004671 A0[AEA0]                	mov	al,[DestInfo]		; AL = destination CParse flags
 29164 00004674 8A26[11A1]              	mov	ah,[SrcInfo]		; AH = source CParse flags
 29165 00004678 250202                  	and	ax,202h			; AH,AL = source,dest wildcard flags
 29166 0000467B 08C0                    	or	al,al
 29167 0000467D 7413                    	jz	short NOTMELCOPY 	; no destination wildcard
 29168                                  
 29169                                  ;	Destination is wildcarded.
 29170                                  	
 29171 0000467F 38E0                    	cmp	al,ah
 29172 00004681 750F                    	jnz	short NOTMELCOPY ; no source wildcard
 29173                                  
 29174                                  ;	Source and destination are both wildcarded.
 29175                                  
 29176 00004683 803E[CCA1]00            	cmp	byte [PLUS],0
 29177 00004688 7408                    	jz	short NOTMELCOPY	; no +'s in source
 29178                                  
 29179                                  ;	Source and destination are wildcarded, and source includes +'s.
 29180                                  ;	It's Mel Hallorman copy time.
 29181                                  
 29182 0000468A FE06[0AA1]              	inc	byte [MELCOPY]		; 'Mel copy' = true
 29183 0000468E 30C0                    	xor	al,al
 29184 00004690 EB06                    	jmp	short SETCONC
 29185                                  
 29186                                  NOTMELCOPY:
 29187 00004692 3402                    	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
 29188 00004694 20E0                    	and	al,ah
 29189 00004696 D0E8                    	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
 29190                                  					;   (implies concatenation)
 29191                                  SETCONC:
 29192 00004698 0A06[CCA1]              	or	al,[PLUS]		; "+" always infers concatenation
 29193                                  
 29194                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 29195                                  
 29196 0000469C A2[069E]                	mov	[Concat],al
 29197 0000469F D0E0                    	shl	al,1
 29198 000046A1 D0E0                    	shl	al,1
 29199 000046A3 A2[C5A1]                	mov	[INEXACT],al		; concatenation -> inexact copy
 29200 000046A6 803E[C7A1]00            	cmp	byte [BINARY],0
 29201 000046AB 7525                    	jne	short NOFIRSTDEST 	; explicit binary copy
 29202                                  
 29203                                  	; 13/06/2023 - Retro DOS v4.2 COMMAND.COM
 29204                                  	; MSDOS 6.0 (MSDOS 5.0)
 29205                                  	;mov	[ASCII],al		; otherwise, concatenate in ascii mode
 29206                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:48FAh
 29207 000046AD 0806[CBA1]              	or	[ASCII],al
 29208                                  
 29209 000046B1 08C9                    	or	cl,cl
 29210 000046B3 751D                    	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly
 29211 000046B5 08C0                    	or	al,al
 29212 000046B7 7419                    	jz	short NOFIRSTDEST 	; Ascii flag did not change state
 29213                                  
 29214                                  ;	At this point there may already be binary read data in the read
 29215                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 29216                                  ;	amount of data in the buffer correctly.
 29217                                  
 29218 000046B9 8B0E[169E]              	mov	cx,[NXTADD]
 29219 000046BD E313                    	jcxz	NOFIRSTDEST		; no data, everything ok
 29220 000046BF B01A                    	mov	al,1Ah
 29221 000046C1 06                      	push	es
 29222 000046C2 31FF                    	xor	di,di
 29223 000046C4 8E06[F59D]              	mov	es,[TPA]
 29224 000046C8 F2AE                    	repne	scasb			; scan for EOF
 29225 000046CA 07                      	pop	es
 29226 000046CB 7505                    	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
 29227 000046CD 4F                      	dec	di			; point at ^z
 29228 000046CE 893E[169E]              	mov	[NXTADD],di		; new buffer length
 29229                                  
 29230                                  NOFIRSTDEST:
 29231 000046D2 BB[2BA0]                	mov	bx,DIRBUF+1		; Source of replacement chars
 29232 000046D5 803E[069E]00            	cmp	byte [Concat],0
 29233 000046DA 7403                    	jz	short GOTCHRSRC		; Not a concat
 29234 000046DC BB[71A0]                	mov	bx,SDIRBUF+1		; Source of replacement chars
 29235                                  GOTCHRSRC:
 29236 000046DF BE[E89F]                	mov	si,DestFcb+1		; Original dest name
 29237 000046E2 8B3E[ACA0]              	mov	di,[DestTail]		; Where to put result
 29238                                  
 29239                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 29240                                  
 29241                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29242                                  BUILDNAME:
 29243 000046E6 B90800                  	mov	cx,8
 29244                                  BUILDMAIN:
 29245 000046E9 AC                      	lodsb
 29246 000046EA 3C3F                    	cmp	al,'?'
 29247 000046EC 7502                    	jne	short NOTAMBIG
 29248 000046EE 8A07                    	mov	al,[bx]
 29249                                  NOTAMBIG:
 29250 000046F0 3C20                    	cmp	al,' '
 29251 000046F2 7401                    	je	short NOSTORE
 29252 000046F4 AA                      	stosb
 29253                                  NOSTORE:
 29254 000046F5 43                      	inc	bx
 29255 000046F6 E2F1                    	loop	BUILDMAIN
 29256 000046F8 B103                    	mov	cl,3
 29257                                  	;mov	al,' ' ; 20h
 29258                                  	;cmp	[si],al
 29259                                  	; 27/03/2023
 29260 000046FA 803C20                  	cmp	byte [si],20h ; ' '
 29261 000046FD 7412                    	je	short ENDDEST		; No extension
 29262                                  	;mov	al,[DOT_CHR]
 29263                                  	; 27/03/2023
 29264 000046FF B02E                    	mov	al,'.' ; 2Eh ; dot_chr
 29265 00004701 AA                      	stosb
 29266                                  BUILDEXT:
 29267 00004702 AC                      	lodsb
 29268 00004703 3C3F                    	cmp	al,'?'
 29269 00004705 7502                    	jne	short NOTAMBIGE
 29270 00004707 8A07                    	mov	al,[bx]
 29271                                  NOTAMBIGE:
 29272 00004709 3C20                    	cmp	al,' '
 29273 0000470B 7401                    	je	short NOSTOREE
 29274 0000470D AA                      	stosb
 29275                                  NOSTOREE:
 29276 0000470E 43                      	inc	bx
 29277 0000470F E2F1                    	loop	BUILDEXT
 29278                                  ENDDEST:
 29279 00004711 30C0                    	xor	al,al
 29280 00004713 AA                      	stosb				; NUL terminate
 29281 00004714 C3                      	retn
 29282                                  
 29283                                  ; =============== S U B	R O U T	I N E =======================================
 29284                                  
 29285                                  	; 28/03/2023
 29286                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29287                                  	;
 29288                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29289                                  BUILDPATH:
 29290 00004715 F6460402                	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
 29291 00004719 7543                    	jnz	short NOTPFILE		; If ambig don't bother with open
 29292 0000471B 89EA                    	mov	dx,bp			; Set DX to spec
 29293 0000471D 83C205                  	add	dx,VARSTRUC.BUF 	; add dx,5
 29294                                  
 29295                                  	; 27/03/2023
 29296                                  	; MSDOS 6.0
 29297 00004720 57                      	push	di			;AN000;
 29298 00004721 B8006C                  	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
 29299                                  	;mov	bx,deny_none|read_open_mode
 29300 00004724 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 29301 00004727 31C9                    	xor	cx,cx			;AN000; no special files
 29302 00004729 89D6                    	mov	si,dx			;AN030; get file name offset
 29303                                  	;mov	dx,read_open_flag	;AN000; set up open flags
 29304 0000472B BA0101                  	mov	dx,101h
 29305 0000472E CD21                    	INT	21h
 29306 00004730 5F                      	pop	di			;AN000;
 29307 00004731 7315                    	jnc	short PURE_FILE		;AN022; is pure file
 29308 00004733 E80CDB                  	call	get_ext_error_number	;AN022; get the extended error
 29309                                  	;cmp	ax,2
 29310 00004736 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
 29311 00004739 7423                    	jz	short NOTPFILE		;AN022;
 29312                                  	;cmp	ax,3
 29313 0000473B 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 29314 0000473E 741E                    	jz	short NOTPFILE		;AN022;
 29315                                  	;cmp	ax,5
 29316 00004740 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 29317 00004743 7419                    	jz	short NOTPFILE		;AN022;
 29318 00004745 E93DD8                  	jmp	extend_setup		;AN022; exit with error
 29319                                  
 29320                                  	; 27/03/2023
 29321                                  	; MSDOS 3.3
 29322                                  	;mov	ax,OPEN*256 ; 3D00h
 29323                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 29324                                  	;			; DS:DX	-> ASCIZ filename
 29325                                  	;			; AL = access mode
 29326                                  	;			; 0 - read
 29327                                  	;jc	short NOTPFILE
 29328                                  
 29329                                  PURE_FILE:
 29330 00004748 89C3                    	mov	bx,ax
 29331 0000474A B80044                  	mov	ax,IOCTL*256 ; 4400h
 29332 0000474D CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 29333                                  				; BX = file or device handle
 29334 0000474F B43E                    	mov	ah,CLOSE ;3Eh
 29335 00004751 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 29336                                  				; BX = file handle
 29337                                  	; 18/04/2023
 29338 00004753 F6C280                  	test	dl,80h
 29339                                  	;test	dl,devid_ISDEV ; test dl,80h
 29340 00004756 7553                    	jnz	short ISADEV
 29341 00004758 F6460404                	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 29342 0000475C 744D                    	jz	short ISADEV
 29343                                  NOTPFILE:
 29344 0000475E 8B5605                  	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 29345                                  	
 29346                                  	; 27/03/2023
 29347                                  	; MSDOS 6.0
 29348 00004761 80FA00                  	cmp	dl,0		     	;AN034; If no drive specified, get
 29349 00004764 7405                    	je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 29350                                  
 29351 00004766 80FE3A                  	cmp	dh,':'
 29352 00004769 7402                    	je	short DRVSPEC5
 29353                                  SET_DRIVE_SPEC:
 29354 0000476B B240                    	mov	dl,'@' ; 40h
 29355                                  DRVSPEC5:
 29356 0000476D 80CA20                  	or	dl,20h
 29357 00004770 80EA60                  	sub	dl,60h		; A = 1
 29358 00004773 E888E3                  	call	SAVUDIR1
 29359                                  	
 29360                                  	; 27/03/2023
 29361                                  	; MSDOS 6.0
 29362 00004776 7306                    	jnc	short CURDIR_OK		;AN022; if error - exit
 29363 00004778 E8C7DA                  	call	get_ext_error_number	;AN022; get the extended error
 29364 0000477B E907D8                  	jmp	extend_setup		;AN022; exit with error
 29365                                  
 29366                                  CURDIR_OK:
 29367 0000477E 89EA                    	mov	dx,bp
 29368                                  	;add	dx,5
 29369 00004780 83C205                  	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 29370                                  	;mov	bh,[bp+4]
 29371 00004783 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 29372 00004786 80E706                  	and	bh,6
 29373 00004789 80FF06                  	cmp	bh,6			; Ambig and path ?
 29374 0000478C 7518                    	jne	short CHECKAMB		; jmp if no
 29375                                  	;mov	si,[bp+2]
 29376 0000478E 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 29377 00004791 B33A                    	mov	bl,':'
 29378 00004793 385CFE                  	cmp	[si-2],bl
 29379 00004796 7506                    	jne	short KNOWNOTSPEC
 29380                                  	;mov	byte [bp+VARSTRUC.ISDIR],2
 29381                                  					; Know is d:/file
 29382                                  	;mov	byte [bp+0],2
 29383 00004798 C6460002                	mov	byte [bp],2
 29384 0000479C EB05                    	jmp	short DOPCDJ
 29385                                  KNOWNOTSPEC:
 29386                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 29387                                  					; Know is path/file
 29388                                  	;mov	byte [bp+0],1
 29389 0000479E C6460001                	mov	byte [bp],1
 29390 000047A2 4E                      	dec	si
 29391                                  DOPCDJ:
 29392 000047A3 E98300                  	jmp	DOPCD
 29393                                  CHECKAMB:
 29394 000047A6 80FF02                  	cmp	bh,2
 29395 000047A9 7505                    	jnz	short CHECKCD
 29396                                  ISSIMPFILE:
 29397                                  ISADEV:
 29398                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 29399                                  	;mov	byte [bp+0],0
 29400 000047AB C6460000                	mov	byte [bp],0
 29401 000047AF C3                      	retn
 29402                                  CHECKCD:
 29403 000047B0 E87EEA                  	call	SetRest1
 29404 000047B3 B43B                    	mov	ah,CHDir ; 3Bh
 29405 000047B5 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 29406                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 29407 000047B7 7239                    	jb	short NOTPDIR
 29408 000047B9 89D7                    	mov	di,dx
 29409 000047BB 31C0                    	xor	ax,ax
 29410 000047BD 89C1                    	mov	cx,ax
 29411 000047BF 49                      	dec	cx
 29412                                  	; 14/06/2023
 29413                                  	;repne	scasb	 ; MSDOS 3.3
 29414                                  
 29415                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29416                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
 29417                                  	; MSDOS 6.0
 29418                                  Kloop:					;AN000;  3/3/KK
 29419 000047C0 268A05                  	mov	al,[es:di]		;AN000;  3/3/KK
 29420 000047C3 47                      	inc	di			;AN000;  3/3/KK
 29421 000047C4 08C0                    	or	al,al			;AN000;  3/3/KK
 29422 000047C6 740C                    	jz	short DONE		;AN000;  3/3/KK
 29423 000047C8 30E4                    	xor	ah,ah			;AN000;  3/3/KK
 29424 000047CA E842E1                  	call	testkanj		;AN000;  3/3/KK
 29425 000047CD 74F1                    	jz	short Kloop		;AN000;  3/3/KK
 29426 000047CF 47                      	inc	di			;AN000;  3/3/KK
 29427 000047D0 FEC4                    	inc	ah			;AN000;  3/3/KK
 29428 000047D2 EBEC                    	jmp	short Kloop		;AN000;  3/3/KK
 29429                                  DONE:
 29430 000047D4 4F                      	dec	di
 29431 000047D5 A0[F89D]                	mov	al,[DIRCHAR]
 29432                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 29433                                  	;mov	byte [bp+0],2
 29434 000047D8 C6460002                	mov	byte [bp],2
 29435                                  	; 27/03/2023
 29436                                  	; MSDOS 6.0
 29437 000047DC 08E4                    	or	ah,ah			;AN000; 3/3/KK
 29438 000047DE 7505                    	jnz	short _STORE_PCHAR	;AN000; 3/3/KK
 29439                                  					;this is the trailing byte of ECS code
 29440                                  	;
 29441 000047E0 3A45FF                  	cmp	al,[di-1]
 29442 000047E3 7405                    	jz	short GOTSRCSLSH
 29443                                  _STORE_PCHAR:
 29444 000047E5 AA                      	stosb
 29445                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 29446                                  	;mov	byte [bp+0],1
 29447 000047E6 C6460001                	mov	byte [bp],1
 29448                                  GOTSRCSLSH:
 29449                                  	;or	byte [bp+4],6
 29450 000047EA 804E0406                	or 	byte [bp+VARSTRUC.INFO],6
 29451 000047EE E87400                  	call	SETSTARS
 29452                                  NOTPDIR_RETN:
 29453 000047F1 C3                      	retn
 29454                                  
 29455                                  	; 28/03/2023
 29456                                  NOTPDIR:
 29457                                  	; MSDOS 6.0
 29458 000047F2 E84DDA                  	call	get_ext_error_number	;AN022; get the extended error
 29459                                  	;cmp	ax,3
 29460 000047F5 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 29461 000047F8 7405                    	je	short NOTPDIR_TRY	;AN022;
 29462                                  	;cmp	ax,5
 29463 000047FA 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 29464 000047FD 7560                    	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
 29465                                  NOTPDIR_TRY:
 29466                                  	; MSDOS 3.3 (& MSDOS 6.0)
 29467                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 29468                                  	;mov	byte [bp+0],0
 29469 000047FF C6460000                	mov	byte [bp],0
 29470                                  	;mov	bh,[bp+4]
 29471 00004803 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 29472 00004806 F6C704                  	test	bh,4
 29473 00004809 74E6                    	jz	short NOTPDIR_RETN	; Know pure file, no path seps
 29474                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 29475                                  	;mov	byte [bp+0],2
 29476 0000480B C6460002                	mov	byte [bp],2
 29477                                  	;mov	si,[bp+2]
 29478 0000480F 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 29479 00004812 803C00                  	cmp	byte [si],0
 29480 00004815 744B                    	je	short BADCDERRJ2	; Trailing '/'
 29481                                  	;mov	bl,[DOT_CHR]
 29482                                  	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 29483                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 29484 00004817 B32E                    	mov	bl,'.'  ; 2Eh ; dot_chr
 29485 00004819 381C                    	cmp	[si],bl
 29486 0000481B 7445                    	je	short BADCDERRJ2	; If . or .. pure cd should have worked
 29487 0000481D B33A                    	mov	bl,':'  ; 3Ah
 29488 0000481F 385CFE                  	cmp	[si-2],bl
 29489 00004822 7405                    	je	short DOPCD		; Know d:/file
 29490                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 
 29491                                  					; Know path/file
 29492                                  	;mov	byte [bp+0],1
 29493 00004824 C6460001                	mov	byte [bp],1
 29494 00004828 4E                      	dec	si			; Point at last '/'
 29495                                  DOPCD:
 29496 00004829 30DB                    	xor	bl,bl
 29497 0000482B 861C                    	xchg	bl,[si]			; Stick in a NUL
 29498 0000482D E801EA                  	call	SetRest1
 29499                                  
 29500                                  	; 28/03/2023
 29501                                  	; MSDOS 6.0 (& MSDOS 5.0)
 29502 00004830 39F2                    	cmp	dx,si			;AN000;  3/3/KK
 29503 00004832 771B                    	ja	short LookBack		;AN000;  3/3/KK
 29504 00004834 56                      	push	si			;AN000;  3/3/KK
 29505 00004835 51                      	push	cx			;AN000;  3/3/KK
 29506 00004836 89F1                    	mov	cx,si			;AN000;  3/3/KK
 29507 00004838 89D6                    	mov	si,dx			;AN000;  3/3/KK
 29508                                  Kloop2: 				;AN000;  3/3/KK
 29509 0000483A AC                      	lodsb				;AN000;  3/3/KK
 29510 0000483B E8D1E0                  	call	testkanj		;AN000;  3/3/KK
 29511 0000483E 7409                    	jz	short NotKanj4		;AN000;  3/3/KK
 29512 00004840 AC                      	lodsb				;AN000;  3/3/KK
 29513 00004841 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 29514 00004843 72F5                    	jb	short Kloop2		;AN000;  3/3/KK
 29515 00004845 59                      	pop	cx			;AN000;  3/3/KK
 29516 00004846 5E                      	pop	si			;AN000;  3/3/KK
 29517 00004847 EB0B                    	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
 29518                                  					;		 trailing path sep
 29519                                  NotKanj4:				;AN000;  3/3/KK
 29520 00004849 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 29521 0000484B 72ED                    	jb	short Kloop2		;AN000;  3/3/KK
 29522 0000484D 59                      	pop	cx			;AN000;  3/3/KK
 29523 0000484E 5E                      	pop	si			;AN000;  3/3/KK
 29524                                  LookBack:				;AN000;  3/3/KK
 29525                                  	; 28/03/2023
 29526                                  	; MSDOS 3.3 & MSDOS 6.0
 29527 0000484F 3A5CFF                  	cmp	bl,[si-1]		; if double slash, then complain.
 29528 00004852 740E                    	je	short BADCDERRJ2
 29529                                  DoCdr:
 29530 00004854 B43B                    	mov	ah,CHDir ; 3Bh
 29531 00004856 CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 29532                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 29533 00004858 861C                    	xchg	bl,[si]
 29534 0000485A 7395                    	jnc	short NOTPDIR_RETN
 29535                                  	
 29536                                  	; 28/03/2023
 29537                                  	; MSDOS 3.3
 29538                                  ;BADCDERRJ2:
 29539                                  	;stc
 29540                                  	;jmp	BADCDERR
 29541                                  
 29542                                  	; 28/03/2023
 29543                                  	; MSDOS 6.0 (& MSDOS 5.0)
 29544 0000485C E8E3D9                  	call	get_ext_error_number	;AN022; get the extended error
 29545                                  EXTEND_SETUPJ:				;AN022;
 29546 0000485F E923D7                  	jmp	extend_setup		;AN022; go issue the error message
 29547                                  BADCDERRJ2:
 29548 00004862 E91DD7                  	jmp	badpath_err		;AC022; go issue path not found message
 29549                                  
 29550                                  ; =============== S U B	R O U T	I N E =======================================
 29551                                  
 29552                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29553                                  SETSTARS:
 29554                                  	;mov	[bp+2],di
 29555 00004865 897E02                  	mov	[bp+VARSTRUC.TTAIL],di
 29556                                  	;add	byte [bp+1],12
 29557 00004868 8046010C                	add	byte [bp+VARSTRUC.SIZ],12
 29558                                  	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 29559                                  	; 28/03/2023
 29560                                  	; MSDOS 6.0
 29561 0000486C B83F2E                  	mov	ax,dot_qmark ; 2E3Fh
 29562                                  	;mov	ax,'?.' ; dot_qmark
 29563                                  
 29564 0000486F B90800                  	mov	cx,8
 29565 00004872 F3AA                    	rep	stosb
 29566 00004874 86C4                    	xchg	al,ah
 29567 00004876 AA                      	stosb
 29568 00004877 86C4                    	xchg	al,ah
 29569 00004879 B103                    	mov	cl,3
 29570 0000487B F3AA                    	rep	stosb
 29571 0000487D 30C0                    	xor	al,al
 29572 0000487F AA                      	stosb
 29573 00004880 C3                      	retn
 29574                                  
 29575                                  ; =============== S U B	R O U T	I N E =======================================
 29576                                  
 29577                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29578                                  	; 12/06/2023 - Retro DOS v4.2 COMMAND.COM
 29579                                  COMPNAME:
 29580 00004881 BE[AFA0]                	mov	si,DestBuf	; do name translate of target
 29581 00004884 BF[789B]                	mov	di,TRGXNAME	; save for name comparison
 29582 00004887 B460                    	mov	ah,xNameTrans ; 60h
 29583                                  	;mov	ah,60h
 29584 00004889 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 29585                                  			; DS:SI	-> ASCIZ relative path string or directory name
 29586                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 29587 0000488B BE[219B]                	mov	si,SRCXNAME	; get name translate of source
 29588 0000488E BF[789B]                	mov	di,TRGXNAME	; get name translate of target
 29589                                  	;call	STRCOMP
 29590                                  	;retn
 29591                                  	; 28/03/2023
 29592 00004891 E9DCE2                  	jmp	STRCOMP
 29593                                  
 29594                                  ;============================================================================
 29595                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 29596                                  ;============================================================================
 29597                                  ; 30/09/2018 - Retro DOS v3.0
 29598                                  ; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29599                                  ; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29600                                  
 29601                                  ;-----------------------------------------------------------------------;
 29602                                  ; ENTRY:								;
 29603                                  ;	DS:SI	Points input buffer					;
 29604                                  ;	ES:DI	Points to the token buffer				;
 29605                                  ;	BL	Special delimiter for this call 			;
 29606                                  ;		    Always checked last 				;
 29607                                  ;		    set it to space if there is no special delimiter	;
 29608                                  ; EXIT: 								;
 29609                                  ;	DS:SI	Points to next char in the input buffer 		;
 29610                                  ;	ES:DI	Points to the token buffer				;
 29611                                  ;	[STARTEL] Points to start of last element of path in token	;
 29612                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 29613                                  ;	CX	Character count 					;
 29614                                  ;	BH	Condition Code						;
 29615                                  ;			Bit 1H of BH set if switch character		;
 29616                                  ;				Token buffer contains char after	;
 29617                                  ;				switch character			;
 29618                                  ;				BP has switch bits set (ORing only)	;
 29619                                  ;			Bit 2H of BH set if ? or * in token		;
 29620                                  ;				if * found element ? filled		;
 29621                                  ;			Bit 4H of BH set if path sep in token		;
 29622                                  ;			Bit 80H of BH set if the special delimiter	;
 29623                                  ;			   was skipped at the start of this token	;
 29624                                  ;		Token buffer always starts d: for non switch tokens	;
 29625                                  ;	CARRY SET							;
 29626                                  ;	    if CR on input						;
 29627                                  ;		token buffer not altered				;
 29628                                  ;									;
 29629                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 29630                                  ; MODIFIES:								;
 29631                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 29632                                  ;									;
 29633                                  ;-----------------------------------------------------------------------;
 29634                                  
 29635                                  ; Modifications to cparse: recognition of right and left parentheses
 29636                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 29637                                  ;
 29638                                  ; Both modifications were installed in the course of adding a coherent
 29639                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 29640                                  ; structure for command-line arguments. This parser relies on cparse to
 29641                                  ; recognize individual tokens.
 29642                                  ;
 29643                                  ; To process for-loops correctly, parentheses must therefore be
 29644                                  ; recognized as tokens. The upper-case conversion code was removed so
 29645                                  ; that commands (such as for and echo) would be able to use the "original"
 29646                                  ; text of the command line.
 29647                                  ;
 29648                                  ; Note also the modification to prevent the automatic conversion of colons
 29649                                  ; into spaces WITHIN THE SOURCE TEXT!
 29650                                  ;
 29651                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 29652                                  ; on the command line.
 29653                                  ;
 29654                                  ; Alan L, OS/MSDOS				    14 August 1983
 29655                                  
 29656                                  ; ---------------------------------------------------------------------------
 29657                                  
 29658                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 29659                                  
 29660                                  ;FSWITCH	EQU	8000h
 29661                                  ;FBADSWITCH	EQU	4000h
 29662                                  
 29663                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 29664                                  
 29665                                  ; =============== S U B	R O U T	I N E =======================================
 29666                                  		
 29667                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29668                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh
 29669                                  
 29670                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 29671                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 4AE3h
 29672                                  cparse:
 29673 00004894 31C0                    	xor	ax,ax
 29674 00004896 893E[E7A1]              	mov	[STARTEL],di		; No path element (Is DI correct?)
 29675 0000489A A2[EAA1]                	mov	[ELPOS],al		; Start in 8 char prefix
 29676                                  	; MSDOS 3.3
 29677                                  	;mov	[SOURCE],al		
 29678                                  	; MSDOS 6.0
 29679 0000489D A2[EBA1]                	mov	[SKPDEL], al		; No skip delimiter yet
 29680 000048A0 88C7                    	mov	bh,al			; Init nothing
 29681 000048A2 9C                      	pushf				; save flags
 29682 000048A3 57                      	push	di			; save the token buffer addrss
 29683 000048A4 31C9                    	xor	cx,cx			; no chars in token buffer
 29684 000048A6 880E[86A0]              	mov	[comma],cl		; reset comma flag
 29685                                  moredelim:
 29686 000048AA AC                      	lodsb
 29687 000048AB E888E2                  	call	DELIM
 29688 000048AE 751D                    	jnz	short SCANCDONE
 29689 000048B0 3C20                    	cmp	al,' '
 29690 000048B2 74F6                    	jz	short moredelim
 29691 000048B4 3C09                    	cmp	al,9
 29692 000048B6 74F2                    	jz	short moredelim
 29693                                  	;xchg	al,[SOURCE]
 29694                                  	; 28/03/2023
 29695 000048B8 8606[EBA1]              	xchg	al,[SKPDEL]
 29696 000048BC 08C0                    	or	al,al
 29697 000048BE 74EA                    	jz	short moredelim		; One non space/tab delimiter allowed
 29698 000048C0 F6C780                  	test	bh,80h			; has a special char been found?
 29699 000048C3 7405                    	jz	short no_comma		; no - just exit
 29700 000048C5 C606[86A0]01            	mov	byte [comma],1		; set comma flag
 29701                                  no_comma:
 29702 000048CA E92A01                  	jmp	x_done			; Nul argument
 29703                                  
 29704                                  SCANCDONE:
 29705                                  	; 28/03/2023
 29706                                  	; MSDOS 6.0
 29707                                  	; -----------------------------------
 29708                                  	; Mod to avoid upper-case conversion.
 29709                                  	; -----------------------------------
 29710                                  	; MSDOS 3.3
 29711                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 29712                                  	;jnz	short cpcont1		; 3/3/KK
 29713                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 29714                                  cpcont1:
 29715                                  	; -----------------------------------
 29716                                  	; 28/03/2023
 29717 000048CD 38D8                    	cmp	al,bl			; Special delimiter?
 29718 000048CF 7505                    	jne	short nospec
 29719 000048D1 80CF80                  	or	bh,80h
 29720 000048D4 EBD4                    	jmp	short moredelim
 29721                                  nospec:
 29722 000048D6 3C0D                    	cmp	al,0Dh			; a CR?
 29723 000048D8 7503                    	jne	short ncperror
 29724 000048DA E91501                  	jmp	cperror
 29725                                  ncperror:
 29726 000048DD 3A06[F79D]              	cmp	al,[SWITCHAR]		; is the char the switch char?
 29727 000048E1 7503                    	jne	short na_switch		; yes, process...
 29728 000048E3 E91401                  	jmp	a_switch
 29729                                  na_switch:
 29730 000048E6 B23A                    	mov	dl,':'
 29731 000048E8 3814                    	cmp	[si],dl
 29732 000048EA 751D                    	jne	short anum_chard	; Drive not specified
 29733                                  	; 28/03/2023
 29734                                  	; MSDOS 6.0 
 29735 000048EC 803E[95A0]01            	cmp	byte [cpyflag],1	; 3/3/KK
 29736 000048F1 7503                    	jne	short cpcont2		; 3/3/KK
 29737 000048F3 E843E0                  	call	UPCONV			; 3/3/KK
 29738                                  cpcont2:
 29739 000048F6 E85901                  	call	move_char
 29740 000048F9 AC                      	lodsb				; Get the ':'
 29741 000048FA E85501                  	call	move_char
 29742 000048FD 893E[E7A1]              	mov	[STARTEL],di
 29743 00004901 C606[E9A1]00            	mov	byte [ELCNT],0
 29744 00004906 E9B300                  	jmp	anum_test
 29745                                  anum_chard:
 29746 00004909 893E[E7A1]              	mov	[STARTEL],di
 29747 0000490D C606[E9A1]00            	mov	byte [ELCNT],0		; Store of this char sets it to one
 29748 00004912 803E[95A0]01            	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
 29749 00004917 751D                    	jnz	short anum_char		; No, don't add drive spec.
 29750 00004919 E8A0E2                  	call	pathchrcmp		; Starts with a pathchar?
 29751 0000491C 7518                    	jnz	short anum_char		; no
 29752 0000491E 50                      	push	ax
 29753 0000491F A0[059E]                	mov	al,[CURDRV]		; Insert drive spec
 29754                                  	;add	al,[CAPITAL_A]
 29755                                  	; 28/03/2023
 29756                                  	; MSDOS 6.0
 29757 00004922 0441                    	add	al,'A' ; 41h
 29758 00004924 E82B01                  	call	move_char
 29759 00004927 B03A                    	mov	al,':' ; 3Ah
 29760 00004929 E82601                  	call	move_char
 29761 0000492C 58                      	pop	ax
 29762 0000492D 893E[E7A1]              	mov	[STARTEL],di
 29763 00004931 C606[E9A1]00            	mov	byte [ELCNT],0
 29764                                  anum_char:
 29765                                  	; 28/03/2023
 29766                                  	; MSDOS 6.0
 29767 00004936 E8D6DF                  	call	testkanj		;AC048			
 29768 00004939 7406                    	jz	short NOTKANJ		;AC048;
 29769 0000493B E81401                  	call	move_char
 29770 0000493E AC                      	lodsb
 29771 0000493F EB78                    	jmp	short notspecial
 29772                                  
 29773                                  NOTKANJ:				;AN048; If not kanji
 29774 00004941 803E[95A0]01            	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
 29775 00004946 7503                    	jne	short TESTDOT 		;AN048;
 29776 00004948 E8EEDF                  	call	UPCONV			;AN048; upper case the char
 29777                                  TESTDOT:
 29778                                  	; 28/03/2023
 29779                                  	;cmp	al,dot_chr  ; 2Eh
 29780 0000494B 3C2E                    	cmp	al,'.'
 29781 0000494D 7509                    	jne	short testquest
 29782 0000494F FE06[EAA1]              	inc	byte [ELPOS] 		; flag in extension
 29783 00004953 C606[E9A1]FF            	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 29784                                  testquest:
 29785 00004958 3C3F                    	cmp	al,'?'  ; 3Fh
 29786 0000495A 7503                    	jnz	short testsplat
 29787 0000495C 80CF02                  	or	bh,2
 29788                                  testsplat:
 29789                                  	;cmp	al,[STAR]
 29790 0000495F 3C2A                    	cmp	al,star	; 2Ah
 29791                                  	; 27/04/2023
 29792                                  	;cmp	al,'*' 
 29793 00004961 7530                    	jne	short testpath
 29794 00004963 80CF02                  	or	bh,2
 29795 00004966 803E[23A2]00            	cmp	byte [expand_star],0
 29796 0000496B 7504                    	jne	short expand_filename
 29797 0000496D EB24                    	jmp	short testpath
 29798                                  
 29799                                  BADPERR2J:
 29800                                  	;jmp	BADPERR2
 29801                                  	; 28/03/2023
 29802                                  	; MSDOS 6.0
 29803 0000496F EB75                    	jmp	short BADPERR2
 29804                                  
 29805                                  expand_filename:
 29806 00004971 B407                    	mov	ah,7
 29807 00004973 803E[EAA1]00            	cmp	byte [ELPOS],0
 29808 00004978 7402                    	jz	short gotelcnt
 29809 0000497A B402                    	mov	ah,2
 29810                                  gotelcnt:
 29811 0000497C B03F                    	mov	al,'?'
 29812 0000497E 2A26[E9A1]              	sub	ah,[ELCNT]
 29813 00004982 72EB                    	jb	short BADPERR2J
 29814 00004984 86E1                    	xchg	ah,cl
 29815 00004986 E309                    	jcxz	testpathx
 29816                                  qmove:
 29817 00004988 86E1                    	xchg	ah,cl
 29818 0000498A E8C500                  	call	move_char
 29819 0000498D 86E1                    	xchg	ah,cl
 29820 0000498F E2F7                    	loop	qmove
 29821                                  testpathx:
 29822 00004991 86E1                    	xchg	ah,cl
 29823                                  testpath:
 29824 00004993 E826E2                  	call	pathchrcmp
 29825 00004996 7521                    	jnz	short notspecial
 29826 00004998 80CF04                  	or	bh,4
 29827 0000499B 803E[23A2]00            	cmp	byte [expand_star],0
 29828 000049A0 7405                    	jz	short no_err_check
 29829 000049A2 F6C702                  	test	bh,2			; If just hit a '/', cannot have ? or * yet
 29830 000049A5 7545                    	jnz	short BADPERR
 29831                                  no_err_check:
 29832 000049A7 893E[E7A1]              	mov	[STARTEL],di	  	; New element
 29833 000049AB FF06[E7A1]              	inc	word [STARTEL]	  	; Point to char after /
 29834 000049AF C606[E9A1]FF            	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
 29835 000049B4 C606[EAA1]00            	mov	byte [ELPOS],0
 29836                                  notspecial:
 29837 000049B9 E89600                  	call	move_char		; just an alphanum string
 29838                                  anum_test:
 29839 000049BC AC                      	lodsb
 29840                                  
 29841                                  	; 28/03/2023
 29842                                  	; MSDOS 6.0
 29843                                  	; -----------------------------------
 29844                                  	; Mod to avoid upper-case conversion.
 29845                                  	; -----------------------------------
 29846                                  	; MSDOS 3.3
 29847                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 29848                                  	;jnz	short cpcont3		; 3/3/KK
 29849                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 29850                                  cpcont3:
 29851                                  	; -----------------------------------
 29852                                  
 29853 000049BD E876E1                  	call	DELIM
 29854 000049C0 7435                    	jz	short x_done
 29855 000049C2 3C0D                    	cmp	al,0Dh
 29856 000049C4 7431                    	je	short x_done
 29857 000049C6 3A06[F79D]              	cmp	al,[SWITCHAR]
 29858 000049CA 742B                    	je	short x_done
 29859 000049CC 38D8                    	cmp	al,bl
 29860 000049CE 7427                    	je	short x_done
 29861 000049D0 3C3A                    	cmp	al,':'			; ':' allowed as trailer because of devices
 29862                                  	; 28/03/2023
 29863                                  	; MSDOS 3.3
 29864                                  	;jnz	short ANUM_CHARJ 
 29865                                  	; MSDOS 6.0
 29866 000049D2 7403                    	je	short FOO15
 29867 000049D4 E95FFF                  	jmp	anum_char
 29868                                  
 29869                                  ; Modification made for parseline.
 29870                                  ; Why would it be necessary to change colons to spaces? In this
 29871                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 29872                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 29873                                  
 29874                                  FOO15:
 29875 000049D7 803E[95A0]02            	cmp	byte [cpyflag],2
 29876 000049DC 7505                    	jnz	short cpcont4
 29877 000049DE E87100                  	call	move_char
 29878 000049E1 EBD9                    	jmp	short anum_test
 29879                                  cpcont4:
 29880 000049E3 46                      	inc	si			; Skip the ':'
 29881 000049E4 EB11                    	jmp	short x_done
 29882                                  
 29883                                  	; 28/03/2023
 29884                                  ;ANUM_CHARJ:
 29885                                  	;jmp	anum_char
 29886                                  
 29887                                  BADPERR2:
 29888 000049E6 BA[E191]                	mov	dx,BADCPMES_PTR
 29889 000049E9 E9B6E4                  	jmp	cerror
 29890                                  
 29891                                  BADPERR:
 29892                                  	; 28/03/2023
 29893                                  	;jmp	BADCDERR  ; MSDOS 3.3	
 29894                                  BADCDERR:
 29895                                  	; MSDOS 6.0
 29896 000049EC BA[0B93]                	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
 29897 000049EF E9B0E4                  	jmp	cerror			;AC022;  message
 29898                                  	
 29899                                  cperror:
 29900 000049F2 4E                      	dec	si			; adjust the pointer
 29901 000049F3 5F                      	pop	di			; retrieve token buffer address
 29902 000049F4 9D                      	popf				; restore flags
 29903 000049F5 F9                      	stc				; set the carry bit
 29904 000049F6 C3                      	retn
 29905                                  
 29906                                  x_done:
 29907 000049F7 4E                      	dec	si			; adjust for next round
 29908                                  
 29909                                  ; Mod to recognize right and left parens as integral tokens.
 29910                                  ;x_done2:
 29911 000049F8 EB51                    	jmp	short out_token
 29912                                  
 29913                                  a_switch:
 29914 000049FA 80CF01                  	or	bh,1			; Indicate switch
 29915                                  	;or	bp,FSWITCH ; 8000h
 29916                                  	; 28/03/2023
 29917 000049FD 81CD0080                	or	bp,8000h
 29918 00004A01 E82AE1                  	call	scanoff
 29919 00004A04 46                      	inc	si
 29920                                  	; 28/03/2023
 29921                                  	; MSDOS 6.0
 29922 00004A05 E807DF                  	call	testkanj		;AN057; See if DBCS lead byte
 29923 00004A08 740D                    	jz	short a_switch_notkanj	;AN057; no - continue processing
 29924 00004A0A E84500                  	call	move_char		;AN057; DBCS - store first byte
 29925 00004A0D AC                      	lodsb				;AN057; get second byte
 29926 00004A0E E84100                  	call	move_char		;AN057; store second byte
 29927                                  	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
 29928 00004A11 81CD0040                	or	bp,4000h
 29929 00004A15 EB34                    	jmp	short out_token 	;AN057; don't bother checking switch
 29930                                  a_switch_notkanj:			;AN057;
 29931 00004A17 3C0D                    	cmp	al,0Dh
 29932 00004A19 7509                    	jne	short Store_swt
 29933 00004A1B B000                    	mov	al,0
 29934 00004A1D AA                      	stosb
 29935                                  	;or	bp,FBADSWITCH ; 4000h
 29936 00004A1E 81CD0040                	or	bp,4000h
 29937 00004A22 EBCE                    	jmp	short cperror		; Trailing switch character error
 29938                                  					;   BP = fSwitch but no switch
 29939                                  					;   bit is set (unknown switch)
 29940                                  Store_swt:
 29941 00004A24 E82B00                  	call	move_char		; store the character
 29942                                  
 29943                                  ; This upconv call must stay. It is used to identify copy-switches
 29944                                  ; on the command line, and won't store anything into the output buffer.
 29945                                  
 29946                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
 29947                                  	; 28/03/2023
 29948 00004A27 E80FDF                  	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
 29949                                  	
 29950 00004A2A 06                      	push	es
 29951 00004A2B 57                      	push	di
 29952 00004A2C 51                      	push	cx
 29953 00004A2D 0E                      	push	cs
 29954 00004A2E 07                      	pop	es
 29955                                  	; 28/03/2023
 29956                                  	; MSDOS 3.3
 29957                                  	;;mov	di,SWITCH_LIST ; "VBAPW"
 29958                                  	; MSDOS 6.0
 29959                                  	;mov	di,switch_list ; "?VBAPW"
 29960                                  	; 14/06/*2023
 29961                                  	; MSDOS 6.22
 29962 00004A2F BF[6097]                	mov	di,switch_list ; "-Y?VBAPW"
 29963                                  
 29964                                  	; MSDOS 3.3
 29965                                  	;mov	cx,SWCOUNT ; 5
 29966                                  	; MSDOS 6.0
 29967                                  	;mov	cx,6  ; SWCOUNT = 6
 29968                                  	; 14/06/2023
 29969                                  	; MSDOS 6.22
 29970 00004A32 B90800                  	mov	cx,8  ; SWCOUNT = 8
 29971                                  
 29972                                  	;or	bp,FBADSWITCH  ; 4000h
 29973 00004A35 81CD0040                	or	bp,4000h
 29974 00004A39 F2AE                    	repne	scasb
 29975 00004A3B 750B                    	jnz	short out_tokenp
 29976                                  	;and	bp,~FBADSWITCH ; 0BFFFh
 29977 00004A3D 81E5FFBF                	and	bp,0BFFFh
 29978 00004A41 B80100                  	mov	ax,1
 29979 00004A44 D3E0                    	shl	ax,cl
 29980 00004A46 09C5                    	or	bp,ax
 29981                                  out_tokenp:
 29982 00004A48 59                      	pop	cx
 29983 00004A49 5F                      	pop	di
 29984 00004A4A 07                      	pop	es
 29985                                  out_token:
 29986 00004A4B B000                    	mov	al,0			; null at the end
 29987 00004A4D AA                      	stosb
 29988 00004A4E 5F                      	pop	di			; restore token buffer pointer
 29989 00004A4F 9D                      	popf
 29990 00004A50 F8                      	clc				; clear carry flag
 29991 00004A51 C3                      	retn
 29992                                  
 29993                                  ; =============== S U B	R O U T	I N E =======================================
 29994                                  
 29995                                  	; 28/03/2023
 29996                                  move_char:
 29997 00004A52 AA                      	stosb				; store char in token buffer
 29998 00004A53 41                      	inc	cx			; increment char count
 29999 00004A54 FE06[E9A1]              	inc	byte [ELCNT]		; increment element count for * substi
 30000 00004A58 C3                      	retn
 30001                                  
 30002                                  ;============================================================================
 30003                                  ; PARSE.ASM, MSDOS 6.0, 1991
 30004                                  ;============================================================================
 30005                                  ; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30006                                  ; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30007                                  
 30008                                  ; -----------------------------
 30009                                  ; (PSDATA.INC, MSDOS 6.0, 1991)
 30010                                  ; -----------------------------
 30011                                  
 30012                                  ;**** Equation field
 30013                                  ;-------- Character code definition
 30014                                  
 30015                                  $P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
 30016                                  $P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
 30017                                  $P_Period	   equ	"."             ;AN020;
 30018                                  $P_Slash	   equ	"/"             ;AN020;
 30019                                  $P_Space	   equ	" "             ;AN000; SBCS blank
 30020                                  $P_Comma	   equ	","             ;AN000;
 30021                                  $P_Switch	   equ	"/"             ;AN000;
 30022                                  $P_Keyword	   equ	"="             ;AN000;
 30023                                  $P_Colon	   equ	":"             ;AN000;
 30024                                  $P_Plus 	   equ	"+"             ;AN000;
 30025                                  $P_Minus	   equ	"-"             ;AN000;
 30026                                  $P_Rparen	   equ	")"             ;AN000;
 30027                                  $P_Lparen	   equ	"("             ;AN000;
 30028                                  ;(deleted ;AN025;) $P_SQuote equ  "'"
 30029                                  $P_DQuote	   equ	'"'             ;AN000;
 30030                                  $P_NULL 	   equ	0		;AN000;
 30031                                  $P_TAB		   equ	9		;AN000;
 30032                                  $P_CR		   equ	0Dh		;AN000;
 30033                                  $P_LF		   equ	0Ah		;AN000;
 30034                                  $P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 30035                                  
 30036                                  $P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 30037                                  $P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 30038                                  
 30039                                  $P_error_filespec  equ  1
 30040                                  
 30041                                  ;----------------------------------------------------------------------------
 30042                                  ; PARMS LABEL	BYTE
 30043                                  ;	DW	PARMSX
 30044                                  ;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
 30045                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 30046                                  ;	DB	" .. "          ; EXTRA DELIMITER LIST,
 30047                                  ;				; TYPICAL ARE ";", "="
 30048                                  ;				; "," & WHITESPACE ALWAYS
 30049                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 30050                                  ;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 30051                                  ;----------------------------------------------------------------------------
 30052                                  
 30053                                  struc $P_PARMS_BLK			;AN000;
 30054 00000000 ????                    .$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 30055 00000002 ??                      .$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
 30056 00000003 ??                      .$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 30057                                  endstruc 				;AN000;
 30058                                  
 30059                                  $P_Len_PARMS	   equ	4		;AN000;
 30060                                  $P_I_Use_Default   equ	0		;AN000; no extra stuff specified
 30061                                  $P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
 30062                                  $P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 30063                                  
 30064                                  ;----------------------------------------------------------------------------
 30065                                  ; PARMSX LABEL	BYTE
 30066                                  ;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
 30067                                  ;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
 30068                                  ;	:				; REPEATS maxp-1 TIMES
 30069                                  ;	DB	maxs			; # OF SWITCHES
 30070                                  ;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
 30071                                  ;	:				; REPEATS maxs-1 TIMES
 30072                                  ;	DB	maxk			; # OF KEYWORD
 30073                                  ;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
 30074                                  ;	:				; REPEATS maxk-1 TIMES
 30075                                  ;----------------------------------------------------------------------------
 30076                                  
 30077                                  struc $P_PARMSX_BLK			;AN000;
 30078 00000000 ??                      .$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
 30079 00000001 ??                      .$P_MaxP: 	 resb 1			;AN000; Maximum positional number
 30080 00000002 ??                      .$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
 30081                                  endstruc				;AN000;
 30082                                  
 30083                                  ; 31/03/2023
 30084                                  ;----------------------------------------------------------------------------
 30085                                  ; << Control field definition >>
 30086                                  ;
 30087                                  ;CONTROL   LABEL   BYTE
 30088                                  ;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
 30089                                  ;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 30090                                  ;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 30091                                  ;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 30092                                  ;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 30093                                  ;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 30094                                  ;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 30095                                  ;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 30096                                  ;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 30097                                  ;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 30098                                  ;				; 0010H=IGNORE ":" AT END IN MATCH
 30099                                  ;				; 0002H=REPEATS ALLOWED
 30100                                  ;				; 0001H=OPTIONAL
 30101                                  ;	   DW FUNCTION_FLAGS
 30102                                  ;				; 0001H=CAP RESULT BY FILE TABLE
 30103                                  ;				; 0002H=CAP RESULT BY CHAR TABLE
 30104                                  ;				; 0010H=REMOVE ":" AT END
 30105                                  ; (tm10)			; 0020H=colon is not necessary for switch
 30106                                  ;
 30107                                  ;	   DW RESULT		; RESULT BUFFER
 30108                                  ;	   DW VALUES		; VALUE LISTS
 30109                                  ;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 30110                                  ;	   DB "...",0		; IF n >0, KEYWORD 1
 30111                                  ;	   :
 30112                                  ;
 30113                                  ;Note:
 30114                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 30115                                  ;      DATE bit simalteniously.
 30116                                  ;
 30117                                  ;      The parser examins each bit along with the following priority.
 30118                                  ;
 30119                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 30120                                  ;      FILE SPEC -> SIMPLE STRING.
 30121                                  ;
 30122                                  ;
 30123                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 30124                                  ;      in the result buffer is capitalized.
 30125                                  ;
 30126                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 30127                                  ;
 30128                                  ;
 30129                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 30130                                  ;      switch, for example, '/A', then STRING points to;
 30131                                  ;
 30132                                  ;		DB    1 	; number of following synonyms
 30133                                  ;		DB   '/A',0
 30134                                  ;
 30135                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 30136                                  ;
 30137                                  ;		DB    1 	; number of following synonyms
 30138                                  ;		DB   'CODEPAGE=',0
 30139                                  ;
 30140                                  ;
 30141                                  ;    - "..." must consist of upper case characters only because the parser
 30142                                  ;      performs pattern matching after converting input to upper case (by
 30143                                  ;      using the current country upper case table)
 30144                                  ;
 30145                                  ;
 30146                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 30147                                  ;      example /A and /B, the format will be;
 30148                                  ;
 30149                                  ;		DB    2 	; number of following synonyms
 30150                                  ;		DB    '/A',0
 30151                                  ;		DB    '/B',0
 30152                                  ;----------------------------------------------------------------------------
 30153                                  
 30154                                  ;**** Match_Flags
 30155                                  
 30156                                  $P_Num_Val	   equ	8000h		;AN000; Numeric Value
 30157                                  $P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 30158                                  $P_Simple_S	   equ	2000h		;AN000; Simple string
 30159                                  $P_Date_S	   equ	1000h		;AN000; Date string
 30160                                  $P_Time_S	   equ	0800h		;AN000; Time string
 30161                                  $P_Cmpx_S	   equ	0400h		;AN000; Complex string
 30162                                  $P_File_Spc	   equ	0200h		;AN000; File Spec
 30163                                  $P_Drv_Only	   equ	0100h		;AN000; Drive Only
 30164                                  $P_Qu_String	   equ	0080h		;AN000; Quoted string
 30165                                  $P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 30166                                  $P_Repeat	   equ	0002h		;AN000; Repeat allowed
 30167                                  $P_Optional	   equ	0001h		;AN000; Optional
 30168                                  
 30169                                  ;**** Function flags
 30170                                  
 30171                                  $P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 30172                                  $P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 30173                                  $P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 30174                                  $P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 30175                                  
 30176                                  ;-------------------------------- Control block structure
 30177                                  struc $P_CONTROL_BLK
 30178 00000000 ????                    .$P_Match_Flag:	   resw 1		;AN000; Controls type matched
 30179 00000002 ????                    .$P_Function_Flag: resw 1		;AN000; Function should be taken
 30180 00000004 ????                    .$P_Result_Buf:	   resw 1		;AN000; Result buffer address
 30181 00000006 ????                    .$P_Value_List:	   resw 1		;AN000; Value list address
 30182 00000008 ??                      .$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
 30183 00000009 ??                      .$P_KEYorSW:	   resb 1		;AN000; keyword or sw
 30184                                  endstruc
 30185                                  
 30186                                  ; 31/03/2023
 30187                                  ;----------------------------------------------------------------------------
 30188                                  ;
 30189                                  ;VALUES LABEL	BYTE
 30190                                  ;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
 30191                                  ;	+-
 30192                                  ;	| DB	nrng		; NUMBER OF RANGES
 30193                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
 30194                                  ;	| +DD	X,Y		; RANGE OF VALUES
 30195                                  ;	|	:
 30196                                  ;	| DB	nnval		; NUMBER OF CHOICES
 30197                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
 30198                                  ;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
 30199                                  ;	|	:
 30200                                  ;	| DB	nstrval 	; NUMBER OF CHOICES
 30201                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
 30202                                  ;	| +DW	STRING		; SPECIFIC CHOICE IF STING
 30203                                  ;	+-	:
 30204                                  ;
 30205                                  ;STRING DB	"...",0		; ASCIIZ STRING IMAGE
 30206                                  ;
 30207                                  ;Note:
 30208                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 30209                                  ;      when no choice lists are provided.
 30210                                  ;
 30211                                  ;    - STRING must consist of upper case characters only because the parser
 30212                                  ;      performs pattern matching after converting input to upper case (by
 30213                                  ;      using the current country upper case table)
 30214                                  ;----------------------------------------------------------------------------
 30215                                  
 30216                                  $P_nval_None	equ 0		;AN000; no value list ID
 30217                                  $P_nval_Range	equ 1		;AN000; range list ID
 30218                                  $P_nval_Value	equ 2		;AN000; value list ID
 30219                                  $P_nval_String	equ 3		;AN000; string list ID
 30220                                  $P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
 30221                                  $P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
 30222                                  $P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
 30223                                  $P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.
 30224                                  
 30225                                  struc $P_VAL_LIST
 30226 00000000 ??                      .$P_NumofList:	resb 1		;AN000; number of following choice
 30227 00000001 ????                    .$P_Val_XL:	resw 1		;AN000; lower word of value
 30228 00000003 ????                    .$P_Val_XH:	resw 1		;AN000; higher word of value
 30229 00000005 ????                    .$P_Val_YL:	resw 1		;AN000; lower word of another value
 30230 00000007 ????                    .$P_Val_YH:	resw 1		;AN000; higher word of another value
 30231                                  endstruc
 30232                                  
 30233                                  ; 31/03/2023
 30234                                  ;----------------------------------------------------------------------------
 30235                                  ;
 30236                                  ;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 30237                                  ;	DB	type			; TYPE RETURNED: 0=RESERVED,
 30238                                  ;					;	1=NUMBER, 2=LIST INDEX,
 30239                                  ;					;	3=STRING, 4=COMPLEX,
 30240                                  ;					;	5=FILESPEC, 6=DRIVE
 30241                                  ;					;	7=DATE, 8=TIME
 30242                                  ;					;	9=QUOTED STRING
 30243                                  ;	DB	ITEM_TAG		; MATCHED ITEM TAG
 30244                                  ;
 30245                                  ;	dw	synonym@		; es:@ points to found SYNONYM if provided.
 30246                                  ;
 30247                                  ;       +-
 30248                                  ;       | DD	n			; VALUE IF NUMBER
 30249                                  ;       | or
 30250                                  ;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
 30251                                  ;       |				; (ES presents Segment address)
 30252                                  ;       | or
 30253                                  ;       |	DD STRING		; OFFSET OF STRING VALUE
 30254                                  ;       | or
 30255                                  ;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 30256                                  ;       | or
 30257                                  ;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
 30258                                  ;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
 30259                                  ;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
 30260                                  ;       | or
 30261                                  ;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
 30262                                  ;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
 30263                                  ;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
 30264                                  ;       |	DB HUNDREDTHS ;(0-99)
 30265                                  ;       +-
 30266                                  ;
 30267                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 30268                                  ;      list.
 30269                                  ;
 30270                                  ;      YEAR: If the input value for the year is less than 100, parser
 30271                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
 30272                                  ;	     the year value, he returns 1987.
 30273                                  ;----------------------------------------------------------------------------
 30274                                  
 30275                                  ;-------------------------------- Result block structure
 30276                                  struc $P_RESULT_BLK;
 30277 00000000 ??                      .$P_Type:	 resb 1		;AN000; Type returned
 30278 00000001 ??                      .$P_Item_Tag:	 resb 1		;AN000; Matched item tag
 30279 00000002 ????                    .$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 30280 00000004 ????????                .$P_Picked_Val:	 resb 4		;AN000; value
 30281                                  endstruc
 30282                                  
 30283                                  ;**** values for the type field in the result block
 30284                                  
 30285                                  $P_EOL		 equ 0		;AN000; End of line
 30286                                  $P_Number	 equ 1		;AN000; Number
 30287                                  $P_List_Idx	 equ 2		;AN000; List Index
 30288                                  $P_String	 equ 3		;AN000; String
 30289                                  $P_Complex	 equ 4		;AN000; Complex
 30290                                  $P_File_Spec	 equ 5		;AN000; File Spec
 30291                                  $P_Drive	 equ 6		;AN000; Drive
 30292                                  $P_Date_F	 equ 7		;AN000; Date
 30293                                  $P_Time_F	 equ 8		;AN000; Time
 30294                                  $P_Quoted_String equ 9		;AN000; Quoted String
 30295                                  
 30296                                  $P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found
 30297                                  
 30298                                  ;**** Return code
 30299                                  ;
 30300                                  ; following return code will be returned in the AX register.
 30301                                  
 30302                                  $P_No_Error	 equ 0		;AN000; No error
 30303                                  $P_Too_Many	 equ 1		;AN000; Too many operands
 30304                                  $P_Op_Missing	 equ 2		;AN000; Required operand missing
 30305                                  $P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
 30306                                  $P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
 30307                                  $P_Out_Of_Range  equ 6		;AN000; Out of range specified
 30308                                  $P_Not_In_Val	 equ 7		;AN000; Not in value list provided
 30309                                  $P_Not_In_Str	 equ 8		;AN000; Not in string list provided
 30310                                  $P_Syntax	 equ 9		;AN000; Syntax error
 30311                                  $P_RC_EOL	 equ -1		;AN000; End of command line
 30312                                  
 30313                                  ;in second byte of $P_Flags, referenced as $P_Flags2:
 30314                                  $P_equ		 equ 01h	;AN000; "=" packed in string buffet
 30315                                  $P_Neg		 equ 02h	;AN000; Negative value
 30316                                  $P_Time12	 equ 04h	;AN000; set when PM is specified
 30317                                  $P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
 30318                                  $P_SW_Cmp	 equ 10h	;AN000; set when switch compare
 30319                                  $P_Extra	 equ 20h	;AN000; set when extra delimiter found
 30320                                  $P_SW		 equ 40h	;AN000; set when switch found (tm08)
 30321                                  $P_Signed	 equ 80h	;AN000; signed numeric specified
 30322                                  
 30323                                  ;-------- Masks
 30324                                  $P_Make_Lower	 equ 20h	;AN000; make lower case character
 30325                                  $P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character
 30326                                  
 30327                                  ;-------------
 30328                                  
 30329                                  struc $P_DOS_TBL
 30330 00000000 ??                      .$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
 30331 00000001 ????                    .$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
 30332 00000003 ????                    .$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
 30333                                  endstruc
 30334                                  
 30335                                  $P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
 30336                                  				;AN000; following parameters are set
 30337                                  				;AN000; to get casemap table.
 30338                                  $P_DOSTBL_Def	 equ -1		;AN000; get default
 30339                                  $P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
 30340                                  $P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
 30341                                  $P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
 30342                                  				; By this call following information
 30343                                  				; is returned.
 30344                                  
 30345                                  ; 03/04/2023
 30346                                  ;-------------------------------- country dependent information
 30347                                  
 30348                                  $P_DOS_Get_CDI	equ 3800h
 30349                                  
 30350                                  struc $P_CDI
 30351 00000000 ????                    .$P_CDI_DateF:	resw 1		;AN000;
 30352 00000002 ????????                .$P_CDI_Money:	resb 4		;AN000;
 30353 00000006 ????                    .$P_CDI_1000:	resb 2		;AN000;
 30354 00000008 ????                    .$P_CDI_Dec:	resb 2		;AN000;
 30355 0000000A ????                    .$P_CDI_DateS:	resb 2		;AN000;
 30356 0000000C ????                    .$P_CDI_TimeS:	resb 2		;AN000;
 30357 0000000E ??                      		resb 1		;AN000;
 30358 0000000F ??                      		resb 1		;AN000;
 30359 00000010 ??                      .$P_CDI_TimeF:	resb 1		;AN000;
 30360 00000011 ????????                		resw 2		;AN000;
 30361 00000015 ????                    		resb 2		;AN000;
 30362 00000017 <res Ah>                		resw 5		;AN000;
 30363                                  endstruc
 30364                                  
 30365                                  $P_Date_MDY	equ 0		;AN000;
 30366                                  $P_Date_DMY	equ 1		;AN000;
 30367                                  $P_Date_YMD	equ 2		;AN000;
 30368                                  
 30369                                  ; ----------------------------
 30370                                  ; (PARSE.ASM, MSDOS 6.0, 1991)
 30371                                  ; ----------------------------
 30372                                  
 30373                                  ;***********************************************************************
 30374                                  ; SysParse;
 30375                                  ;
 30376                                  ;  Function : Parser Entry
 30377                                  ;
 30378                                  ;  Input: DS:SI -> command line
 30379                                  ;	  ES:DI -> parameter block
 30380                                  ;	  psdata_seg -> psdata.inc
 30381                                  ;	  CX = operand ordinal
 30382                                  ;
 30383                                  ;	  Note:  ES is the segment containing all the control blocks defined
 30384                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 30385                                  ;		 is in DS.
 30386                                  ;
 30387                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 30388                                  ;		    invalid value list. But this parser does NOT implement
 30389                                  ;		    this feature. Therefore CY always zero.
 30390                                  ;
 30391                                  ;	   CY = 0   AX = return code
 30392                                  ;		    BL = terminated delimiter code
 30393                                  ;		    CX = new operand ordinal
 30394                                  ;		    SI = set past scaned operand
 30395                                  ;		    DX = selected result buffer
 30396                                  ;
 30397                                  ; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
 30398                                  ;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
 30399                                  ;	$P_Chk_Sw_Control, $P_Fill_Result
 30400                                  ;
 30401                                  ; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
 30402                                  ;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
 30403                                  ;
 30404                                  ;-------- Modification History -----------------------------------------
 30405                                  ;
 30406                                  ;  4/04/87 : Created by K. K,
 30407                                  ;  4/28/87 : $P_Val_YH assemble error (tm01)
 30408                                  ;	   : JMP SHORT assemble error (tm02)
 30409                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 30410                                  ;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 30411                                  ;	     DateSW equ 1)	      (tm04)
 30412                                  ;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 30413                                  ;				      (tm05) in PSDATA.INC
 30414                                  ;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
 30415                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 30416                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 30417                                  ;	     value-list block	      (tm07)
 30418                                  ;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
 30419                                  ;	     switch (keyword) or not. If there is, backup si for next call
 30420                                  ;	     (tm08)
 30421                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 30422                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 30423                                  ;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
 30424                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 30425                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 30426                                  ;	     in user's routines. $P_Chk_DBCS (tm11)
 30427                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 30428                                  ;					  (tm12)
 30429                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 30430                                  ;					  (tm13)
 30431                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 30432                                  ;					  (tm14)
 30433                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 30434                                  ;					  (tm15)
 30435                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 30436                                  ;
 30437                                  ;  7/24/87 : Quoted strings being returned with quotes.
 30438                                  ;
 30439                                  ;  7/28/87 : Kerry S (;AN018;)
 30440                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 30441                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 30442                                  ;	     affected: $P_Chk_SW_Control.
 30443                                  ;
 30444                                  ;  7/29/87 : Kerry S (;AN019;)
 30445                                  ;	     Now allow the optional bit in match flags for switches.  This
 30446                                  ;	     allows the switch to be encountered with a value or without a
 30447                                  ;	     value and no error is returned.
 30448                                  ;
 30449                                  ;
 30450                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 30451                                  ;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
 30452                                  ;	     within a date response, instead of checking just for the one
 30453                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 30454                                  ;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
 30455                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 30456                                  ;
 30457                                  ;  9/1/87  : Kerry S (;AN021)
 30458                                  ;	     In PROC $P_String_Comp, when comparing the switch or keyword on
 30459                                  ;	     the command line with the string in the control block the
 30460                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 30461                                  ;	     on the command line and assuming a match.	This allowed a shorter
 30462                                  ;	     string on the command line than in the synonym list in the control
 30463                                  ;	     block.  I put in a test for a null in the control block so the
 30464                                  ;	     string in the control block must be the same length as the string
 30465                                  ;	     preceeding the colon or equal on the command line.
 30466                                  ;
 30467                                  ;  8/28/87 : Kerry S (;AN022;)
 30468                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 30469                                  ;	     problems for people who included it themselves in a segment other
 30470                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 30471                                  ;	     segment.
 30472                                  ;
 30473                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 30474                                  ;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 30475                                  ;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
 30476                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 30477                                  ;	     Created FLag, in $P_time_Format PROC, to request the delim in
 30478                                  ;	     BL be used if TIME is being parsed.
 30479                                  ;
 30480                                  ;  9/24/87 : Ed K
 30481                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 30482                                  ;	     invocations with their normally expanded code; made comments
 30483                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 30484                                  ;
 30485                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 30486                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 30487                                  ;	     pointed to by non-existant CONTROL.
 30488                                  ;
 30489                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 30490                                  ;	     A quoted text string can be framed only by double quote.  Remove
 30491                                  ;	     support to frame quoted text string with single quote.
 30492                                  ;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
 30493                                  ;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
 30494                                  ;	     single quote in PROC prologues are left as is for history reasons.
 30495                                  ;
 30496                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 30497                                  ;	     quote chars within a quoted string is supposed to be reported as
 30498                                  ;	     one quote character, but is reported as two quotes.  This changed
 30499                                  ;	     two instructions in PROC $P_Quoted_Str.
 30500                                  ;
 30501                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 30502                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 30503                                  ;
 30504                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 30505                                  ;
 30506                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 30507                                  ;	     psdata buffer should have psdata_seg.
 30508                                  ;
 30509                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 30510                                  ;	     positional missing.
 30511                                  ;
 30512                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 30513                                  ;	     as a line delimiter, should use carriage return.
 30514                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 30515                                  ;
 30516                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 30517                                  ;
 30518                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 30519                                  ;	     endless loop since SI is returned still pointing to start
 30520                                  ;	     of that parm.
 30521                                  ;
 30522                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 30523                                  ;	     Vector to returned string has CS instead of Psdata_Seg, but
 30524                                  ;	     when tried to fix it on previous version, changed similar
 30525                                  ;	     but wrong place.
 30526                                  ;
 30527                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 30528                                  ;	     delimiters between hours, minutes, seconds for time. And period
 30529                                  ;	     and comma are valid delimiters between seconds and 100th second.
 30530                                  ;
 30531                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 30532                                  ;	     in a filespec, then flag an error.
 30533                                  ;
 30534                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 30535                                  ;	     indexed off of the psdata_seg equate instead of the DS register.
 30536                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 30537                                  ;  -->	     local parser data. Why were some references to local data changed
 30538                                  ;	     to do this before, but not all ?????
 30539                                  ;
 30540                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 30541                                  ;
 30542                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
 30543                                  ;
 30544                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 30545                                  ;
 30546                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 30547                                  ;
 30548                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 30549                                  ;	     separator in TIME before hundredths field.
 30550                                  ;
 30551                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 30552                                  ;			strings as keywords.
 30553                                  ;
 30554                                  ;***********************************************************************
 30555                                  
 30556                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30557                                  cmd_parse:
 30558                                  	;call	sysparse
 30559                                  	;retn
 30560                                  
 30561                                  ; -----------------------------------
 30562                                  
 30563                                  	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30564                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h
 30565                                  
 30566                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30567                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4CABh
 30568                                  sysparse:
 30569 00004A59 2EC706[4E99]0000        	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
 30570 00004A60 2E890E[D899]            	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
 30571 00004A65 2E8926[DA99]            	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
 30572 00004A6A 2E8936[DC99]            	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
 30573                                  $P_Redo_Time:				;AN039; try to parse time again
 30574 00004A6F FC                      	cld				;AN000; confirm forward direction
 30575 00004A70 2E890E[4199]            	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
 30576                                  	;mov	word [cs:$P_RC],$P_No_Error
 30577 00004A75 2EC706[4399]0000        	mov	word [cs:$P_RC],0	;AC034; Assume no error
 30578 00004A7C 2EC706[5699]0000        	mov	word [cs:$P_Found_SYNONYM],0
 30579                                  					;AC034; initalize synonym pointer
 30580 00004A83 2EC706[4799]0000        	mov	word [cs:$P_DX],0	;AC034; (tm15)
 30581                                  
 30582                                  ;M029 -- Begin changes
 30583                                  ; The table of special chars $P_FileSp_Char should be initialized on every
 30584                                  ;entry to SysParse. This is in the non-checksum region and any program that
 30585                                  ;corrupts this table but does not corrupt the checksum region will leave
 30586                                  ;command.com parsing in an inconsistent state.
 30587                                  ; NB: The special characters string has been hardcoded here. If any change
 30588                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 30589                                  
 30590 00004A8A 2EC706[139A]5B5D        	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
 30591 00004A91 2EC706[159A]7C3C        	mov	word [cs:$P_FileSp_Char+2], '|<'
 30592 00004A98 2EC706[179A]3E2B        	mov	word [cs:$P_FileSp_Char+4], '>+'
 30593 00004A9F 2EC706[199A]3D3B        	mov 	word [cs:$P_FileSp_Char+6], '=;'
 30594                                  
 30595                                  ;M029 -- End of changes
 30596                                  
 30597 00004AA6 E82209                  	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
 30598 00004AA9 7312                    	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse
 30599                                  
 30600                                  ;--------------------------- End of Line
 30601                                  	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
 30602 00004AAB B8FFFF                  	mov	ax,0FFFFh
 30603 00004AAE 53                      	push	bx			;AN000;
 30604                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 30605 00004AAF 268B1D                  	mov	bx,[es:di]		;AN000; Get the PARMSX address to
 30606                                  	
 30607                                  	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
 30608 00004AB2 263A0F                  	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
 30609 00004AB5 7304                    	jae	short $P_Fin		;AN000; positional found.
 30610                                  
 30611                                  	;mov	ax,2
 30612 00004AB7 B80200                  	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
 30613                                  	; 27/04/2023
 30614 00004ABA F8                      	clc
 30615                                  $P_Fin: 				;AN000;
 30616 00004ABB 5B                      	pop	bx			;AN000;
 30617                                  	;jmp	$P_Single_Exit		;AN000; return to the caller
 30618                                  	; 27/04/2023
 30619                                  	; cf = 0
 30620                                  	;clc
 30621 00004ABC C3                      	retn
 30622                                  
 30623                                  ;---------------------------
 30624                                  $P_Start:				;AN000;
 30625 00004ABD 2E8936[5099]            	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034; save ptr to command line for later use by complex,
 30626 00004AC2 53                      	push	bx			;AN000; quoted string or file spec.
 30627 00004AC3 57                      	push	di			;AN000;
 30628 00004AC4 55                      	push	bp			;AN000;
 30629 00004AC5 8D1E[5899]              	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
 30630 00004AC9 2EF606[4F99]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 30631                                  	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
 30632 00004ACF 7543                    	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
 30633                                  $P_Pack_Loop:				;AN000;
 30634 00004AD1 AC                      	lodsb				;AN000; Pick a operand from buffer
 30635 00004AD2 E8A909                  	call	$P_Chk_Switch		;AN000; Check switch character
 30636 00004AD5 723C                    	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 30637                                  
 30638 00004AD7 E81309                  	call	$P_Chk_EOL		;AN000; Check EOL character
 30639 00004ADA 7437                    	je	short $P_Pack_End_BY_EOL ;AN000; need backup si
 30640                                  
 30641 00004ADC E84009                  	call	$P_Chk_Delim		;AN000; Check delimiter
 30642 00004ADF 7518                    	jne	short $P_PL01 		;AN000; If no, process next byte
 30643                                  
 30644 00004AE1 2EF606[4F99]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 30645                                  	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
 30646 00004AE7 7505                    	jnz	short $P_Pack_End_backup_si
 30647                                  					;AN000; (tm08)
 30648 00004AE9 E8DF08                  	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
 30649 00004AEC EB26                    	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end
 30650                                  
 30651                                  $P_Pack_End_backup_si:			;AN000; (tm08)
 30652 00004AEE 2EF606[4F99]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
 30653                                  	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
 30654 00004AF4 741E                    	jz	short $P_Pack_End	;AN000; (tm08)
 30655                                  
 30656 00004AF6 4E                      	dec	si			;AN000; (tm08)
 30657 00004AF7 EB1B                    	jmp	short $P_Pack_End	;AN025; (tm08)
 30658                                  $P_PL01:				;AN000;
 30659 00004AF9 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 30660                                  	;cmp	al,'='
 30661 00004AFC 3C3D                    	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
 30662 00004AFE 7506                    	jne	short $P_PL00 		;AN000; then
 30663                                  
 30664 00004B00 2E800E[4F99]01          	or	byte [cs:$P_Flags2],$P_equ
 30665                                  	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
 30666                                  $P_PL00:				;AN000;
 30667 00004B06 43                      	inc	bx			;AN000; ready to see next byte
 30668 00004B07 E89F09                  	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 30669 00004B0A 73C5                    	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte
 30670                                  
 30671 00004B0C AC                      	lodsb				;AN000; if yes, store
 30672 00004B0D 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 30673 00004B10 43                      	inc	bx			;AN000; update pointer
 30674 00004B11 EBBE                    	jmp	short $P_Pack_Loop	;AN000; process to next byte
 30675                                  
 30676                                  $P_Pack_End_BY_EOL:			;AN000;
 30677 00004B13 4E                      	dec	si			;AN000; backup si pointer
 30678                                  $P_Pack_End:				;AN000;
 30679 00004B14 2E8936[4599]            	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
 30680                                  	;mov	byte [cs:bx],0
 30681 00004B19 2EC60700                	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
 30682 00004B1D 2E891E[5499]            	mov	[cs:$P_Save_EOB],bx
 30683                                  					;AC034; 3/17/87 keep the address for later use of complex
 30684                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 30685 00004B22 268B1D                  	mov	bx,[es:di]		;AN000; get PARMSX address
 30686 00004B25 8D36[5899]              	lea	si,$P_STRING_BUF	;AC034;
 30687                                  	;cmp	byte [cs:si],'/'
 30688 00004B29 2E803C2F                	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
 30689 00004B2D 7442                    	je	short $P_SW_Manager	;AN000; if yes, process as switch
 30690                                  
 30691 00004B2F 2E803C22                	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
 30692 00004B33 7408                    	je	short $P_Positional_Manager
 30693                                  					;M005;if so, process as one!
 30694 00004B35 2EF606[4F99]01          	test	byte [cs:$P_Flags2],$P_equ
 30695                                  	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
 30696 00004B3B 7556                    	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword
 30697                                  
 30698                                  $P_Positional_Manager:			;AN000; else process as positional
 30699                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 30700 00004B3D 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30701 00004B41 30E4                    	xor	ah,ah			;AN000; ax = maxp
 30702 00004B43 2E3906[4199]            	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
 30703 00004B48 7312                    	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many
 30704                                  
 30705 00004B4A 2EA1[4199]              	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
 30706 00004B4E D1E0                    	shl	ax,1			;AN000; ax = ax*2
 30707 00004B50 43                      	inc	bx			;AC035; add '2' to
 30708 00004B51 43                      	inc	bx			;AC035;  BX reg
 30709                                  					;AN000; now bx points to 1st CONTROL
 30710 00004B52 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 30711 00004B54 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 30712 00004B57 E88000                  	call	$P_Chk_Pos_Control	;AN000; Do process for positional
 30713 00004B5A EB61                    	jmp	short $P_Return_to_Caller
 30714                                  					;AN000; and return to the caller
 30715                                  $P_Too_Many_Error:			;AN000;
 30716                                  	;mov	word [cs:$P_RC],1
 30717 00004B5C 2EC706[4399]0100        	mov	word [cs:$P_RC],$P_Too_Many
 30718                                  					;AC034; set exit code
 30719 00004B63 EB58                    	jmp	short $P_Return_to_Caller
 30720                                  					;AN000; and return to the caller
 30721                                  ; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 30722                                  %if 0
 30723                                  $P_SW_Manager:				;AN000;
 30724                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 30725                                  	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30726                                  	xor	ah,ah			;AN000; ax = maxp
 30727                                  	inc	ax			;AN000;
 30728                                  	shl	ax,1			;AN000; ax = (ax+1)*2
 30729                                  	add	bx,ax			;AN000; now bx points to maxs
 30730                                  	mov	cl,[es:bx]		;AN000;
 30731                                  	xor	ch,ch			;AN000; cx = maxs
 30732                                  	or	cx,cx			;AN000; at least one switch ?
 30733                                  	jz	short $P_SW_Not_Found 	;AN000;
 30734                                  	inc	bx			;AN000; now bx points to 1st CONTROL address
 30735                                  %else
 30736                                  $P_get_max_ptr:
 30737                                  	;mov	al,[es:bx+1]		; get maxp
 30738 00004B65 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30739 00004B69 30E4                    	xor	ah,ah			; ax = maxp
 30740 00004B6B 40                      	inc	ax
 30741 00004B6C D1E0                    	shl	ax,1			; ax = (ax+1)*2
 30742 00004B6E 01C3                    	add	bx,ax			; now bx points to maxs
 30743 00004B70 C3                      	retn
 30744                                  
 30745                                  $P_SW_Manager:
 30746 00004B71 E8F1FF                  	call	$P_get_max_ptr
 30747 00004B74 268A0F                  	mov	cl,[es:bx]
 30748 00004B77 30ED                    	xor	ch,ch			; cx = maxs
 30749                                  					; at least one switch ?
 30750 00004B79 E30F                    	jcxz	$P_SW_Not_Found 	; no
 30751 00004B7B 43                      	inc	bx			; now bx points to 1st CONTROL address
 30752                                  %endif
 30753                                  
 30754                                  $P_SW_Mgr_Loop: 			;AN000;
 30755 00004B7C 53                      	push	bx			;AN000;
 30756 00004B7D 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 30757 00004B80 E8B700                  	call	$P_Chk_SW_Control	;AN000; do process for switch
 30758 00004B83 5B                      	pop	bx			;AN000;
 30759 00004B84 7337                    	jnc	short $P_Return_to_Caller
 30760                                  					;AN000; if the CONTROL is for the switch, exit
 30761 00004B86 43                      	inc	bx			;AC035; add '2' to
 30762 00004B87 43                      	inc	bx			;AC035;  BX reg
 30763                                  					;AN000; else bx points to the next CONTROL
 30764 00004B88 E2F2                    	loop	$P_SW_Mgr_Loop		;AN000; and loop
 30765                                  $P_SW_Not_Found:			;AN000;
 30766                                  	;mov	word [cs:$P_RC],3
 30767 00004B8A 2EC706[4399]0300        	mov	word [cs:$P_RC],$P_Not_In_SW
 30768                                  					;AC034; here no CONTROL for the switch has
 30769 00004B91 EB2A                    	jmp	short $P_Return_to_Caller0
 30770                                  					;AN000; not been found, means error.
 30771                                  ; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 30772                                  %if 0
 30773                                  $P_Key_Manager: 			;AN000;
 30774                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 30775                                  	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 30776                                  	xor	ah,ah			;AN000; ax = maxp
 30777                                  	inc	ax			;AN000;
 30778                                  	shl	ax,1			;AN000; ax = (ax+1)*2
 30779                                  	add	bx,ax			;AN000; now bx points to maxs
 30780                                  	mov	al,[es:bx]		;AN000;
 30781                                  	xor	ah,ah			;AN000; ax = maxs
 30782                                  	shl	ax,1			;AN000;
 30783                                  	inc	ax			;AN000; ax = ax*2+1
 30784                                  	add	bx,ax			;AN000; now bx points to maxk
 30785                                  	mov	cl,[es:bx]		;AN000;
 30786                                  	xor	ch,ch			;AN000; cx = maxk
 30787                                  	or	cx,cx			;AN000; at least one keyword ?
 30788                                  	jz	short $P_Key_Not_Found	;AN000;
 30789                                  	inc	bx			;AN000; now bx points to 1st CONTROL
 30790                                  %else
 30791                                  $P_Key_Manager:
 30792 00004B93 E8CFFF                  	call	$P_get_max_ptr
 30793 00004B96 268A07                  	mov	al,[es:bx]
 30794 00004B99 30E4                    	xor	ah,ah			; ax = maxs
 30795 00004B9B D1E0                    	shl	ax,1
 30796 00004B9D 40                      	inc	ax			; ax = ax*2+1
 30797 00004B9E 01C3                    	add	bx,ax			; now bx points to maxk
 30798 00004BA0 268A0F                  	mov	cl,[es:bx]
 30799 00004BA3 30ED                    	xor	ch,ch			; cx = maxk
 30800                                  					; at least one keyword ?
 30801 00004BA5 E30F                    	jcxz	$P_Key_Not_Found
 30802 00004BA7 43                      	inc	bx			; now bx points to 1st CONTROL
 30803                                  %endif
 30804                                  
 30805                                  $P_Key_Mgr_Loop:			;AN000;
 30806 00004BA8 53                      	push	bx			;AN000;
 30807 00004BA9 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 30808 00004BAC E85A00                  	call	$P_Chk_Key_Control	;AN000; do process for keyword
 30809 00004BAF 5B                      	pop	bx			;AN000;
 30810 00004BB0 730B                    	jnc	short $P_Return_to_Caller
 30811                                  					;AN000; if the CONTROL is for the keyword, exit
 30812 00004BB2 43                      	inc	bx			;AC035; add '2' to
 30813 00004BB3 43                      	inc	bx			;AC035;  BX reg
 30814                                  					;AN000; else bx points to the next CONTROL
 30815 00004BB4 E2F2                    	loop	$P_Key_Mgr_Loop 	;AN000; and loop
 30816                                  $P_Key_Not_Found:			;AN000;
 30817                                  	;mov	word [cs:$P_RC],4
 30818 00004BB6 2EC706[4399]0400        	mov	word [cs:$P_RC],$P_Not_In_Key
 30819                                  					;AC034; here no CONTROL for the keyword has
 30820                                  $P_Return_to_Caller0:
 30821                                  $P_Return_to_Caller:			;AN000; not been found, means error.
 30822 00004BBD 5D                      	pop	bp			;AN000;
 30823 00004BBE 5F                      	pop	di			;AN000;
 30824 00004BBF 5B                      	pop	bx			;AN000;
 30825 00004BC0 2E8B0E[4199]            	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
 30826 00004BC5 2EA1[4399]              	mov	ax,[cs:$P_RC]		;AC034; return exit code
 30827 00004BC9 2E8B36[4599]            	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
 30828 00004BCE 2E8B16[4799]            	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
 30829 00004BD3 2E8A1E[4999]            	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
 30830                                  $P_Single_Exit: 			;AN000;
 30831 00004BD8 F8                      	clc				;AN000;
 30832 00004BD9 C3                      	retn				;AN000;
 30833                                  
 30834                                  ;***********************************************************************
 30835                                  ; $P_Chk_Pos_Control
 30836                                  ;
 30837                                  ; Function: Parse CONTROL block for a positional
 30838                                  ;
 30839                                  ; Input:     ES:BX -> CONTROL block
 30840                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30841                                  ;
 30842                                  ; Output:    None
 30843                                  ;
 30844                                  ; Use:	 $P_Fill_Result, $P_Check_Match_Flags
 30845                                  ;
 30846                                  ; Vars: $P_Ordinal(W), $P_RC(W)
 30847                                  ;***********************************************************************
 30848                                  
 30849                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30850                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h
 30851                                  
 30852                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30853                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4E35h
 30854                                  $P_Chk_Pos_Control:
 30855 00004BDA 50                      	push	ax			;AN000;
 30856                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 30857 00004BDB 268B07                  	mov	ax,[es:bx]		;AN000;
 30858                                  	;test	ax,2
 30859 00004BDE A90200                  	test	ax,$P_Repeat		;AN000; repeat allowed ?
 30860 00004BE1 7505                    	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL
 30861                                  
 30862 00004BE3 2EFF06[4199]            	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
 30863                                  $P_CPC00:				;AN000;
 30864                                  	;cmp	byte [cs:si],0
 30865 00004BE8 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
 30866 00004BEC 7516                    	jne	short $P_CPC01		;AN000;
 30867                                  
 30868                                  	;test	ax,1
 30869 00004BEE A90100                  	test	ax,$P_Optional		;AN000; yes, then is it optional ?
 30870 00004BF1 7509                    	jnz	short $P_CPC02		;AN000;
 30871                                  
 30872 00004BF3 2EC706[4399]0200        	mov	word [cs:$P_RC],$P_Op_Missing ; 2
 30873                                  					;AC034; no, then error	 3/17/87
 30874 00004BFA EB0B                    	jmp	short $P_CPC_Exit	;AN000;
 30875                                  $P_CPC02:				;AN000;
 30876                                  	; 27/04/2023
 30877                                  	;push	ax ; *			;AN000;
 30878                                  	;
 30879                                  	;;mov	al,3
 30880                                  	;mov	al,$P_String		;AN000; if it is optional return NULL
 30881                                  	;;mov	ah,0FFh
 30882                                  	;mov	ah,$P_No_Tag		;AN000; no item tag indication
 30883                                  	; 31/03/2023
 30884 00004BFC B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30885 00004BFF E89500                  	call	$P_Fill_Result		;AN000;
 30886                                  	; 27/04/2023
 30887                                  	;pop	ax ; *			;AN000;
 30888 00004C02 EB03                    	jmp	short $P_CPC_Exit	;AN000;
 30889                                  $P_CPC01:				;AN000;
 30890 00004C04 E81101                  	call	$P_Check_Match_Flags	;AN000;
 30891                                  $P_CPC_Exit:				;AN000;
 30892 00004C07 58                      	pop	ax			;AN000;
 30893 00004C08 C3                      	retn				;AN000;
 30894                                  
 30895                                  ;***********************************************************************
 30896                                  ; $P_Chk_Key_Control
 30897                                  ;
 30898                                  ; Function: Parse CONTROL block for a keyword
 30899                                  ;
 30900                                  ; Input:     ES:BX -> CONTROL block
 30901                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30902                                  ;
 30903                                  ; Output:    CY = 1 : not match
 30904                                  ;
 30905                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30906                                  ;
 30907                                  ; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30908                                  ;***********************************************************************
 30909                                  
 30910                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30911                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30912                                  $P_Chk_Key_Control:			;AN000;
 30913 00004C09 F9                      	stc				;AN000;this logic works when the KeySW
 30914 00004C0A C3                      	retn				;AN000;is reset.
 30915                                  
 30916                                  ;***********************************************************************
 30917                                  ; $P_Search_KEYorSW:
 30918                                  ;
 30919                                  ; Function: Seach specified keyword or switch from CONTROL
 30920                                  ;
 30921                                  ; Input:     ES:BX -> CONTROL block
 30922                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30923                                  ;
 30924                                  ; Output:    CY = 1 : not match
 30925                                  ;
 30926                                  ; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
 30927                                  ;***********************************************************************
 30928                                  
 30929                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30930                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30931                                  $P_Search_KEYorSW:
 30932 00004C0B 55                      	push	bp			;AN000;
 30933 00004C0C 51                      	push	cx			;AN000;
 30934 00004C0D 268A4F08                	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
 30935                                  	;mov	cl,[es:bx+8]		;AN000; Get synonym count
 30936                                  	; 14/06/2023
 30937                                  	;xor	ch,ch			;AN000; and set it to cx
 30938                                  	;or	cx,cx			;AN000; No synonyms specified ?
 30939 00004C11 08C9                    	or	cl,cl
 30940 00004C13 740E                    	jz	short $P_KEYorSW_Not_Found
 30941                                  					;AN000; then indicate not found by CY
 30942 00004C15 268D6F09                	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
 30943                                  	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
 30944                                  $P_KEYorSW_Loop:			;AN000;
 30945 00004C19 E8E703                  	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 30946 00004C1C 7308                    	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 30947 00004C1E E80D00                  	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
 30948 00004C21 E2F6                    	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
 30949                                  $P_KEYorSW_Not_Found:			;AN000;
 30950 00004C23 F9                      	stc				;AN000; indicate not found in synonym list
 30951 00004C24 EB05                    	jmp	short $P_KEYorSW_Exit	;AN000; and exit
 30952                                  $P_KEYorSW_Found:			;AN000;
 30953 00004C26 2E892E[5699]            	mov	[cs:$P_Found_SYNONYM],bp
 30954                                  					;AC034; set synonym pointer
 30955                                  	; 27/04/2023
 30956                                  	; cf = 0
 30957                                  	;clc				;AN000; indicate found
 30958                                  $P_KEYorSW_Exit:			;AN000;
 30959 00004C2B 59                      	pop	cx			;AN000;
 30960 00004C2C 5D                      	pop	bp			;AN000;
 30961 00004C2D C3                      	retn				;AN000;
 30962                                  
 30963                                  ;***********************************************************************
 30964                                  ; $P_MoveBP_NUL
 30965                                  ;***********************************************************************
 30966                                  
 30967                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30968                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30969                                  $P_MoveBP_NUL:
 30970                                  $P_MBP_Loop:				;AN000;
 30971                                  	;cmp	byte [es:bp+0],0
 30972 00004C2E 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
 30973 00004C33 7403                    	je	short $P_MBP_Exit	;AN000; to the synomym list
 30974 00004C35 45                      	inc	bp			;AN000; until
 30975 00004C36 EBF6                    	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
 30976                                  $P_MBP_Exit:				;AN000;
 30977 00004C38 45                      	inc	bp			;AN000; bp points to next to NULL
 30978 00004C39 C3                      	retn				;AN000;
 30979                                  
 30980                                  ;***********************************************************************
 30981                                  ; $P_Chk_SW_Control
 30982                                  ;
 30983                                  ; Function: Parse CONTROL block for a switch
 30984                                  ;
 30985                                  ; Input:     ES:BX -> CONTROL block
 30986                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 30987                                  ;
 30988                                  ; Output:    CY = 1 : not match
 30989                                  ;
 30990                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 30991                                  ;
 30992                                  ; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 30993                                  ;***********************************************************************
 30994                                  
 30995                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30996                                  	;
 30997                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 30998                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:4E9Ah
 30999                                  $P_Chk_SW_Control:
 31000 00004C3A 2E800E[4F99]10          	or	byte [cs:$P_Flags2],$P_SW_Cmp
 31001                                  	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
 31002 00004C40 E8C8FF                  	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 31003 00004C43 7251                    	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 31004                                  
 31005 00004C45 2E8026[4F99]EF          	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
 31006                                  	;and	byte [cs:$P_Flags2],0EFh
 31007                                  					;AC034; reset the indicator previously set
 31008 00004C4B 50                      	push	ax			;AN000;       /switch:
 31009 00004C4C 2EA1[5299]              	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
 31010 00004C50 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 31011 00004C52 2E0106[5099]            	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 31012 00004C57 58                      	pop	ax			;AN000;
 31013                                  
 31014 00004C58 2E8B36[5299]            	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
 31015                                  	;cmp	byte [cs:si],0
 31016 00004C5D 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
 31017 00004C61 7525                    	jne	short $P_CSW00		;AN000; if yes, process match flags
 31018                                  
 31019                                  	;cmp	byte [cs:si],':'
 31020 00004C63 2E807CFF3A              	cmp	byte [cs:si-1],$P_Colon
 31021                                  					;AN000; if no, the switch terminated by colon ?
 31022 00004C68 7509                    	jne	short $P_Chk_if_data_required
 31023                                  					;AN000; if yes,
 31024                                  
 31025 00004C6A 2EC706[4399]0900        	mov	word [cs:$P_RC],$P_Syntax
 31026                                  	;mov	word [cs:$P_RC],9	;AC034; return syntax error
 31027 00004C71 EB1A                    	jmp	short $P_Chk_SW_Exit	;AN000;
 31028                                  
 31029                                  $P_Chk_if_data_required:		;AN018; no data, no colon
 31030                                  	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
 31031                                  	; 27/04/2023
 31032 00004C73 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 31033 00004C77 7414                    	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 31034                                  
 31035                                  	;;test	word [es:bx],1 ; $P_Optional
 31036                                  	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 31037 00004C79 26F60701                	test	byte [es:bx],$P_Optional
 31038                                  					;AN019; see if no value is valid
 31039 00004C7D 750E                    	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 31040                                  
 31041 00004C7F 2EC706[4399]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 31042                                  	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
 31043 00004C86 EB05                    	jmp	short $P_Chk_SW_Exit	;AN018;
 31044                                  
 31045                                  $P_CSW00:				;AN000;
 31046 00004C88 E88D00                  	call	$P_Check_Match_Flags	;AN000; process match flag
 31047 00004C8B F8                      	clc				;AN000; indicate match
 31048                                  	;jmp	short $P_Chk_SW_Single_Exit
 31049 00004C8C C3                      	retn	; 31/03/2023		;AN000;
 31050                                  	; 31/03/2023
 31051                                  ;$P_Chk_SW_Err0: 			;AN000;
 31052                                  ;	stc				;AN000; not found in switch synonym list
 31053                                  ;	;jmp	short $P_Chk_SW_Single_Exit
 31054                                  ;	retn	; 31/03/2023		;AN000;
 31055                                  	
 31056                                  $P_Chk_SW_Exit: 			;AN000;
 31057 00004C8D 50                      	push	ax			;AN000;
 31058                                  	; 31/03/2023
 31059 00004C8E B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31060                                  	;;mov	al,3
 31061                                  	;;mov	ah,0FFh
 31062                                  	;mov	al,$P_String		;AN000; set
 31063                                  	;mov	ah,$P_No_Tag		;AN000;    result
 31064 00004C91 E80300                  	call	$P_Fill_Result		;AN000; 	 buffer
 31065 00004C94 58                      	pop	ax			;AN000;
 31066 00004C95 F8                      	clc				;AN000;
 31067                                  	; 31/03/2023
 31068                                  $P_Chk_SW_Err0:
 31069                                  $P_Chk_SW_Single_Exit:			;AN000;
 31070 00004C96 C3                      	retn				;AN000;
 31071                                  
 31072                                  ;***********************************************************************
 31073                                  ; $P_Fill_Result
 31074                                  ;
 31075                                  ; Function: Fill the result buffer
 31076                                  ;
 31077                                  ; Input:    AH = Item tag
 31078                                  ;	    AL = type
 31079                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 31080                                  ;		  AL = 2: DX has index(offset) into value list
 31081                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 31082                                  ;		  AL = 7: DX has year, CL has month and CH has date
 31083                                  ;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
 31084                                  ;			  amd CH has hundredths
 31085                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
 31086                                  ;	    ES:BX -> CONTROL block
 31087                                  ;
 31088                                  ; Output:   None
 31089                                  ;
 31090                                  ; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
 31091                                  ;
 31092                                  ; Vars: $P_DX(W)
 31093                                  ;***********************************************************************
 31094                                  
 31095                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31096                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31097                                  $P_Fill_Result:
 31098 00004C97 57                      	push	di			;AN000;
 31099 00004C98 268B7F04                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
 31100                                  	;mov	di,[es:bx+4]		;AN000; di points to result buffer
 31101 00004C9C 2E893E[4799]            	mov	[cs:$P_DX],di		;AC034; set returned result address
 31102                                  	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
 31103                                  	;;mov	[es:di],al		;AN000; store type
 31104                                  	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
 31105                                  	;;mov	[es:di+1],ah		;AN000; store item tag
 31106                                  	; 31/03/2023
 31107 00004CA1 268905                  	mov	[es:di],ax
 31108 00004CA4 50                      	push	ax			;AN000;
 31109 00004CA5 2EA1[5699]              	mov	ax,[cs:$P_Found_SYNONYM]
 31110                                  					;AC034; if yes,
 31111 00004CA9 26894502                	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
 31112                                  	;mov	[es:di+2],ax		;AN000;   then set it to the result
 31113 00004CAD 58                      	pop	ax			;AN000;
 31114                                  $P_RLT04:				;AN000;
 31115                                  	;cmp	al,1
 31116 00004CAE 3C01                    	cmp	al,$P_Number		;AN000; if number
 31117 00004CB0 750A                    	jne	short $P_RLT00		;AN000;
 31118                                  $P_RLT02:				;AN000;
 31119 00004CB2 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 31120                                  	;mov	[es:di+4],dx		;AN000; then store 32bit
 31121 00004CB6 26894D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
 31122                                  	;mov	[es:di+6],cx		;AN000;	number
 31123 00004CBA EB5A                    	jmp	short $P_RLT_Exit	;AN000;
 31124                                  $P_RLT00:				;AN000;
 31125                                  	;cmp	al,2
 31126 00004CBC 3C02                    	cmp	al,$P_List_Idx		;AN000; if list index
 31127 00004CBE 7506                    	jne	short $P_RLT01		;AN000;
 31128 00004CC0 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 31129                                  	;mov	[es:di+4],dx		;AN000; then store list index
 31130 00004CC4 EB50                    	jmp	short $P_RLT_Exit	;AN000;
 31131                                  $P_RLT01:				;AN000;
 31132                                  	;cmp	al,7
 31133 00004CC6 3C07                    	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
 31134 00004CC8 74E8                    	je	short $P_RLT02		;AN000;
 31135                                  	;cmp	al,8
 31136 00004CCA 3C08                    	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
 31137 00004CCC 74E4                    	je	short $P_RLT02		;AN000;
 31138                                  	;cmp	al,6
 31139 00004CCE 3C06                    	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
 31140 00004CD0 7506                    	jne	short $P_RLT03		;AN000;
 31141                                  
 31142 00004CD2 26885504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
 31143                                  	;mov	[es:di+4],dl		;AN000; store drive number
 31144 00004CD6 EB3E                    	jmp	short $P_RLT_Exit	;AN000;
 31145                                  
 31146                                  $P_RLT03:				;AN000;
 31147                                  	;cmp	al,4
 31148 00004CD8 3C04                    	cmp	al,$P_Complex		;AN000; complex format ?
 31149 00004CDA 750F                    	jne	short $P_RLT05		;AN000;
 31150                                  
 31151 00004CDC 2EA1[5099]              	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
 31152 00004CE0 40                      	inc	ax			;AN000; skip left Parentheses
 31153 00004CE1 26894504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
 31154                                  	;mov	[es:di+4],ax		;AN000; store offset
 31155 00004CE5 268C5D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
 31156                                  	;mov	[es:di+6],ds		;AN000; store segment
 31157 00004CE9 EB2B                    	jmp	short $P_RLT_Exit	;AN000;
 31158                                  
 31159                                  $P_RLT05:				;AN000;
 31160                                  ;------------------------  AL = 3, 5, or 9
 31161 00004CEB 26897504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
 31162                                  	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
 31163 00004CEF 268C4D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
 31164                                  	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF
 31165                                  
 31166 00004CF3 50                      	push	ax			;AN000;
 31167 00004CF4 26F6470201              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
 31168                                  	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
 31169 00004CF9 7404                    	jz	short $P_RLT_CAP00	;AN000;
 31170                                  
 31171                                  	;mov	al,4
 31172 00004CFB B004                    	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
 31173 00004CFD EB09                    	jmp	short $P_RLT_CAP02	;AN000;
 31174                                  
 31175                                  $P_RLT_CAP00:				;AN000;
 31176 00004CFF 26F6470202              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
 31177                                  	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
 31178 00004D04 7405                    	jz	short $P_RLT_CAP01	;AN000;
 31179                                  
 31180                                  	;mov	al,2
 31181 00004D06 B002                    	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
 31182                                  $P_RLT_CAP02:				;AN000;
 31183 00004D08 E80C01                  	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
 31184                                  $P_RLT_CAP01:				;AN000;
 31185 00004D0B 58                      	pop	ax			;AN000;
 31186 00004D0C 26F6470210              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
 31187                                  	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
 31188 00004D11 7403                    	jz	short $P_RLT_Exit	;AN000;
 31189                                  
 31190 00004D13 E8DD00                  	call	$P_Remove_Colon 	;AN000; then process it.
 31191                                  $P_RLT_Exit:				;AN000;
 31192 00004D16 5F                      	pop	di			;AN000;
 31193 00004D17 C3                      	retn				;AN000;
 31194                                  
 31195                                  ;***********************************************************************
 31196                                  ; $P_Check_Match_Flags
 31197                                  ;
 31198                                  ; Function:  Check the mutch_flags and make the exit code and set the
 31199                                  ;	     result buffer
 31200                                  ;
 31201                                  ;	    Check for types in this order:
 31202                                  ;		Complex
 31203                                  ;		Date
 31204                                  ;		Time
 31205                                  ;		Drive
 31206                                  ;		Filespec
 31207                                  ;		Quoted String
 31208                                  ;		Simple String
 31209                                  ;
 31210                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31211                                  ;	     ES:BX -> CONTROL block
 31212                                  ;
 31213                                  ; Output:    None
 31214                                  ;
 31215                                  ; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
 31216                                  ;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
 31217                                  ;	     $P_Drive_Format
 31218                                  ;***********************************************************************
 31219                                  
 31220                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31221                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31222                                  $P_Check_Match_Flags:
 31223 00004D18 2EC606[1C9A]00          	mov	byte [cs:$P_err_flag],$P_NULL ; 0
 31224                                  					;AN033;AC034;; clear filespec error flag.
 31225 00004D1E 50                      	push	ax			;AN000;
 31226                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 31227 00004D1F 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 31228 00004D22 09C0                    	or	ax,ax			;AC035; test ax for zero
 31229 00004D24 7518                    	jnz	short $P_Mat		;AN000; (tm12)
 31230 00004D26 50                      	push	ax			;AN000; (tm12)
 31231 00004D27 53                      	push	bx			;AN000; (tm12)
 31232 00004D28 52                      	push	dx			;AN000; (tm12)
 31233 00004D29 57                      	push	di			;AN000; (tm12)
 31234 00004D2A 2EC706[4399]0900        	mov	word [cs:$P_RC],$P_Syntax
 31235                                  	;mov	word [cs:$P_RC],9	;AC034; (tm12)
 31236                                  	; 31/03/2023
 31237 00004D31 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31238                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
 31239                                  	;mov	al,$P_String ; 3	;AN000; (tm12)
 31240 00004D34 E860FF                  	call	$P_Fill_Result		;AN000; (tm12)
 31241 00004D37 5F                      	pop	di			;AN000; (tm12)
 31242 00004D38 5A                      	pop	dx			;AN000; (tm12)
 31243 00004D39 5B                      	pop	bx			;AN000; (tm12)
 31244 00004D3A 58                      	pop	ax			;AN000; (tm12)
 31245                                  	;jmp	short $P_Bridge 	;AC035; (tm12)
 31246                                  	; 31/03/2023
 31247                                  $P_Bridge:	; 18/04/2023		;AN000;
 31248 00004D3B E99C00                  	jmp	$P_Match_Exit		;AN000; (tm02)
 31249                                  $P_Mat: 				;AN000; (tm12)
 31250                                  $P_Match01:				;AN000;
 31251                                  	;test	ax,1000h
 31252 00004D3E A90010                  	test	ax,$P_Date_S		;AN000; Date string
 31253 00004D41 7412                    	jz	short $P_Match02	;AN000;
 31254 00004D43 2EC706[4399]0000        	mov	word [cs:$P_RC],$P_No_Error
 31255                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 31256 00004D4A E85403                  	call	$P_Date_Format		;AN000; do process
 31257 00004D4D 2E833E[4399]09          	cmp	word [cs:$P_RC],$P_Syntax
 31258                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 31259                                  	; 18/04/2023
 31260 00004D53 75E6                    	jne	short $P_Bridge		;AN000;
 31261                                  $P_Match02:				;AN000;
 31262                                  	;test	ax,800h
 31263 00004D55 A90008                  	test	ax,$P_Time_S		;AN000; Time string
 31264 00004D58 7412                    	jz	short $P_Match03	;AN000;
 31265 00004D5A 2EC706[4399]0000        	mov	word [cs:$P_RC],$P_No_Error
 31266                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 31267 00004D61 E85404                  	call	$P_Time_Format		;AN000; do process
 31268 00004D64 2E833E[4399]09          	cmp	word [cs:$P_RC],$P_Syntax
 31269                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 31270                                  	;jne	short $P_Bridge		;AN000; (tm09)
 31271                                  	;jmp	short $P_Match03	;AN025; (tm09)
 31272                                  	; 31/03/2023
 31273 00004D6A 756E                    	jne	short $P_Match_Exit
 31274                                  ;$P_Bridge:				;AN000;
 31275                                  	;jmp	short $P_Match_Exit	;AN000; (tm02)
 31276                                  $P_Match03:				;AN000;
 31277                                  	;test	ax,8000h
 31278 00004D6C A90080                  	test	ax,$P_Num_Val		;AN000; Numeric value
 31279 00004D6F 7412                    	jz	short $P_Match04	;AN000;
 31280 00004D71 2EC706[4399]0000        	mov	word [cs:$P_RC],$P_No_Error
 31281                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 31282 00004D78 E82701                  	call	$P_Value		;AN000; do process
 31283 00004D7B 2E833E[4399]09          	cmp	word [cs:$P_RC],$P_Syntax
 31284                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 31285 00004D81 7557                    	jne	short $P_Match_Exit	;AN000;
 31286                                  $P_Match04:				;AN000;
 31287                                  	;test	ax,4000h
 31288 00004D83 A90040                  	test	ax,$P_SNum_Val		;AN000; Signed numeric value
 31289 00004D86 7412                    	jz	short $P_Match05	;AN000;
 31290 00004D88 2EC706[4399]0000        	mov	word [cs:$P_RC],$P_No_Error
 31291                                  					;AC034; assume no error
 31292 00004D8F E8EC00                  	call	$P_SValue		;AN000; do process
 31293 00004D92 2E833E[4399]09          	cmp	word [cs:$P_RC],$P_Syntax
 31294                                  					;AC034; if error, examine the next type
 31295 00004D98 7540                    	jne	short $P_Match_Exit	;AN000;
 31296                                  $P_Match05:				;AN000;
 31297                                  	;test	ax,100h
 31298 00004D9A A90001                  	test	ax,$P_Drv_Only		;AN000; Drive only
 31299 00004D9D 7415                    	jz	short $P_Match06	;AN000;
 31300 00004D9F 2EC706[4399]0000        	mov	word [cs:$P_RC],$P_No_Error
 31301                                  					;AC034; assume no error
 31302 00004DA6 E85C05                  	call	$P_File_Format		;AN000; 1st, call file format
 31303 00004DA9 E8DD05                  	call	$P_Drive_Format 	;AN000; check drive format, next
 31304 00004DAC 2E833E[4399]09          	cmp	word [cs:$P_RC],$P_Syntax
 31305                                  					;AC034; if error, examinee the next type
 31306 00004DB2 7526                    	jne	short $P_Match_Exit	;AN000;
 31307                                  $P_Match06:				;AN000;
 31308                                  	;test	ax,200h
 31309 00004DB4 A90002                  	test	ax,$P_File_Spc		;AN000; File spec
 31310 00004DB7 7412                    	jz	short $P_Match07	;AN000;
 31311 00004DB9 2EC706[4399]0000        	mov	word [cs:$P_RC],$P_No_Error
 31312                                  					;AC034; assume no error
 31313 00004DC0 E84205                  	call	$P_File_Format		;AN000; do process
 31314 00004DC3 2E833E[4399]09          	cmp	word [cs:$P_RC],$P_Syntax
 31315                                  					;AC034; if error, examine the next type
 31316 00004DC9 750F                    	jne	short $P_Match_Exit	;AN000;
 31317                                  $P_Match07:				;AN000;
 31318                                  $P_Match08:				;AN000;
 31319                                  	;test	ax,2000h
 31320 00004DCB A90020                  	test	ax,$P_Simple_S		;AN000; Simple string
 31321 00004DCE 740A                    	jz	short $P_Match09	;AN000;
 31322 00004DD0 2EC706[4399]0000        	mov	word [cs:$P_RC],$P_No_Error
 31323                                  					;AC034; assume no error
 31324 00004DD7 E8C501                  	call	$P_Simple_String	;AN000; do process
 31325                                  $P_Match09:				;AN000;
 31326                                  $P_Match_Exit:				;AN000;
 31327 00004DDA 2E833E[1C9A]01          	cmp	word [cs:$P_err_flag],$P_error_filespec
 31328                                  	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
 31329 00004DE0 750F                    	jne	short $P_Match2_Exit	;AN033; no, continue
 31330 00004DE2 2E833E[4399]00          	cmp	word [cs:$P_RC],$P_No_Error
 31331                                  	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
 31332 00004DE8 7507                    	jne	short $P_Match2_Exit	;AN033; no, continue
 31333 00004DEA 2EC706[4399]0900        	mov	word [cs:$P_RC],$P_Syntax
 31334                                  	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
 31335                                  $P_Match2_Exit: 			;AN033;
 31336 00004DF1 58                      	pop	ax			;AN000;
 31337 00004DF2 C3                      	retn
 31338                                  
 31339                                  ;***********************************************************************
 31340                                  ; $P_Remove_Colon;
 31341                                  ;
 31342                                  ; Function: Remove colon at end
 31343                                  ;
 31344                                  ; Input:    psdata_seg:SI points to string buffer to be examineed
 31345                                  ;
 31346                                  ; Output:   None
 31347                                  ;
 31348                                  ; Use:	$P_Chk_DBCS
 31349                                  ;***********************************************************************
 31350                                  
 31351                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31352                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31353                                  $P_Remove_Colon:
 31354 00004DF3 50                      	push	ax			;AN000;
 31355 00004DF4 56                      	push	si			;AN000;
 31356                                  $P_RCOL_Loop:				;AN000;
 31357 00004DF5 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 31358 00004DF8 08C0                    	or	al,al			;AN000; end of string ?
 31359 00004DFA 740F                    	jz	short $P_RCOL_Exit	;AN000; if yes, just exit
 31360                                  
 31361 00004DFC 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
 31362 00004DFE 750E                    	jne	short $P_RCOL00		;AN000;
 31363                                  
 31364                                  	;cmp	byte [cs:si+1],0
 31365 00004E00 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
 31366 00004E05 7507                    	jne	short $P_RCOL00		;AN000; no, then next char
 31367                                  
 31368 00004E07 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
 31369                                  	; 31/03/2023
 31370                                  	;jmp	short $P_RCOL_Exit	;AN000; and exit.
 31371                                  $P_RCOL_Exit:
 31372 00004E0B 5E                      	pop	si
 31373 00004E0C 58                      	pop	ax
 31374 00004E0D C3                      	retn
 31375                                  
 31376                                  $P_RCOL00:				;AN000;
 31377 00004E0E E89806                  	call	$P_Chk_DBCS		;AN000; if not colon, then check if
 31378 00004E11 7301                    	jnc	short $P_RCOL01		;AN000; DBCS leading byte.
 31379                                  
 31380 00004E13 46                      	inc	si			;AN000; if yes, skip trailing byte
 31381                                  $P_RCOL01:				;AN000;
 31382 00004E14 46                      	inc	si			;AN000; si points to next byte
 31383 00004E15 EBDE                    	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered
 31384                                  
 31385                                  	; 31/03/2023
 31386                                  ;$P_RCOL_Exit:				;AN000;
 31387                                  	;pop	si			;AN000;
 31388                                  	;pop	ax			;AN000;
 31389                                  	;retn
 31390                                  
 31391                                  ;***********************************************************************
 31392                                  ; $P_Do_CAPS_String;
 31393                                  ;
 31394                                  ; Function: Perform capitalization along with the file case map table
 31395                                  ;	    or character case map table.
 31396                                  ;
 31397                                  ; Input:    AL = 2 : Use character table
 31398                                  ;	    AL = 4 : Use file table
 31399                                  ;	    psdata_seg:SI points to string buffer to be capitalized
 31400                                  ;
 31401                                  ; Output:   None
 31402                                  ;
 31403                                  ; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
 31404                                  ;***********************************************************************
 31405                                  
 31406                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31407                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31408                                  $P_Do_CAPS_String:
 31409 00004E17 56                      	push	si			;AN000;
 31410 00004E18 52                      	push	dx			;AN000;
 31411 00004E19 88C2                    	mov	dl,al			;AN000; save info id
 31412                                  $P_DCS_Loop:				;AN000;
 31413 00004E1B 2E8A04                  	mov	al,[cs:si]		;AN000; load character and
 31414 00004E1E E88806                  	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
 31415 00004E21 720C                    	jc	short $P_DCS00		;AN000; if yes, do not need CAPS
 31416                                  
 31417 00004E23 08C0                    	or	al,al			;AN000; end of string ?
 31418 00004E25 740C                    	jz	short $P_DCS_Exit	;AN000; then exit.
 31419                                  
 31420 00004E27 E80C00                  	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 31421 00004E2A 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 31422 00004E2D EB01                    	jmp	short $P_DCS01		;AN000; process nexit
 31423                                  $P_DCS00:				;AN000;
 31424 00004E2F 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 31425                                  $P_DCS01:				;AN000;
 31426 00004E30 46                      	inc	si			;AN000; si point to next byte
 31427 00004E31 EBE8                    	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
 31428                                  $P_DCS_Exit:				;AN000;
 31429 00004E33 5A                      	pop	dx			;AN000;
 31430 00004E34 5E                      	pop	si			;AN000;
 31431 00004E35 C3                      	retn
 31432                                  
 31433                                  ;***********************************************************************
 31434                                  ; $P_Do_CAPS_Char;
 31435                                  ;
 31436                                  ; Function: Perform capitalization along with the file case map table
 31437                                  ;	    or character case map table.
 31438                                  ;
 31439                                  ; Input:    DL = 2 : Use character table
 31440                                  ;	    DL = 4 : Use file table
 31441                                  ;	    AL = character to be capitalized
 31442                                  ;
 31443                                  ; Output:   None
 31444                                  ;
 31445                                  ; Use:	INT 21h /w AH=65h
 31446                                  ;***********************************************************************
 31447                                  
 31448                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31449                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31450                                  $P_Do_CAPS_Char:
 31451 00004E36 3C80                    	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
 31452 00004E38 730B                    	jae	short $P_DCC_Go		;AN000;
 31453                                  
 31454 00004E3A 3C61                    	cmp	al,"a"  ; 61h		;AN000; if no,
 31455 00004E3C 723F                    	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 31456                                  
 31457 00004E3E 3C7A                    	cmp	al,"z"  ; 7Ah		;AN000;
 31458 00004E40 773B                    	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS
 31459                                  
 31460 00004E42 24DF                    	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
 31461                                  	;jmp	short $P_CAPS_Ret	;AN000;
 31462                                  	; 18/04/2023
 31463 00004E44 C3                      	retn
 31464                                  
 31465                                  $P_DCC_Go:				;AN000;
 31466 00004E45 53                      	push	bx			;AN000;
 31467 00004E46 06                      	push	es			;AN000;
 31468 00004E47 57                      	push	di			;AN000;
 31469                                  	; 18/04/2023
 31470 00004E48 8D3E[0E9A]              	lea	di,$P_File_CAP_Ptr	;AC034;
 31471 00004E4C 80FA04                  	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
 31472 00004E4F 7404                    	je	short $P_DCC00		;AN000;
 31473                                  	; 27/04/2023
 31474 00004E51 8D3E[099A]              	lea	di,$P_Char_CAP_Ptr	;AC034; or use char CAPS table ?
 31475                                  $P_DCC00:				;AN000;
 31476 00004E55 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 31477 00004E58 7416                    	je	short $P_DCC01		;AN000; if no,
 31478                                  
 31479                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 31480                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 31481                                  ; call, regardless of what base register is currently be defined as PSDATA_SEG.
 31482                                  
 31483 00004E5A 50                      	push	ax			;AN000; get CAPS table thru DOS call
 31484 00004E5B 51                      	push	cx			;AN000;
 31485 00004E5C 52                      	push	dx			;AN000;
 31486 00004E5D 0E                      	push	cs			;AC036; pass current base seg into
 31487                                  					;(Note: this used to push CS. BUG...
 31488 00004E5E 07                      	pop	es			;AN000;   ES reg, required for
 31489                                  					;get extended country information
 31490                                  	; 31/03/2023
 31491 00004E5F B465                    	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
 31492                                  	;mov	ah,65h
 31493 00004E61 88D0                    	mov	al,dl			;AN000; upper case table
 31494                                  	;mov	bx,-1 ; 0FFFFh
 31495                                  	;mov	cx,5
 31496                                  	;mov	dx,-1
 31497 00004E63 BBFFFF                  	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
 31498 00004E66 B90500                  	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
 31499                                  	; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 31500 00004E69 89DA                    	mov	dx,bx
 31501                                  	;mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
 31502                                  					;DI already set to point to buffer
 31503 00004E6B CD21                    	int	21h			;AN000; es:di point to buffer that
 31504                                  					;now has been filled in with info
 31505 00004E6D 5A                      	pop	dx			;AN000;
 31506 00004E6E 59                      	pop	cx			;AN000;
 31507 00004E6F 58                      	pop	ax			;AN000;
 31508                                  
 31509                                  $P_DCC01:				;AN000;
 31510                                  
 31511                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 31512                                  ; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
 31513                                  ; regardless of which base reg is currently the PSDATA_SEG reg.
 31514                                  
 31515                                  	;mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 31516                                  	;;mov	bx,[cs:di+1]		;AN000; get offset of table
 31517                                  	;mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
 31518                                  	;;mov	es,[cs:di+3]		;AN000; get segment of table
 31519                                  	; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 31520                                  	;les	bx,[cs:di+1]
 31521 00004E70 2EC45D01                	les	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 31522                                  	;
 31523 00004E74 43                      	inc	bx			;AC035; add '2' to
 31524 00004E75 43                      	inc	bx			;AC035;  BX reg
 31525                                  					;AN000; skip length field
 31526 00004E76 2C80                    	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
 31527                                  	;xlat	es:[bx] 		;AN000; perform case map
 31528                                  	; 31/03/2023
 31529 00004E78 26D7                    	es	xlat
 31530                                  
 31531 00004E7A 5F                      	pop	di			;AN000;
 31532 00004E7B 07                      	pop	es			;AN000;
 31533 00004E7C 5B                      	pop	bx			;AN000;
 31534                                  $P_CAPS_Ret:				;AN000;
 31535 00004E7D C3                      	retn
 31536                                  
 31537                                  ;***********************************************************************
 31538                                  ; $P_Value / $P_SValue
 31539                                  ;
 31540                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
 31541                                  ;	     and make result buffer.
 31542                                  ;	     $P_SValue is an entry point for the signed value
 31543                                  ;	     and this will simply call $P_Value after the handling
 31544                                  ;	     of the sign character, "+" or "-"
 31545                                  ;
 31546                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31547                                  ;	     ES:BX -> CONTROL block
 31548                                  ;
 31549                                  ; Output:    None
 31550                                  ;
 31551                                  ; Use:	$P_Fill_Result, $P_Check_OVF
 31552                                  ;
 31553                                  ; Vars: $P_RC(W), $P_Flags(RW)
 31554                                  ;***********************************************************************
 31555                                  
 31556                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31557                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31558                                  $P_SValue:
 31559 00004E7E 50                      	push	ax			;AN000;
 31560                                  	;or	byte [cs:$P_Flags2],80h
 31561 00004E7F 2E800E[4F99]80          	or	byte [cs:$P_Flags2],$P_Signed
 31562                                  					;AC034; indicate a signed numeric
 31563                                  	;and	byte [cs:$P_Flags2],0FDh
 31564 00004E85 2E8026[4F99]FD          	and	byte [cs:$P_Flags2],0FFh-$P_Neg
 31565                                  					;AC034; assume positive value
 31566 00004E8B 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 31567 00004E8E 3C2B                    	cmp	al,'+' ; 2Bh
 31568                                  	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
 31569 00004E90 740A                    	je	short $P_SVal00		;AN000;
 31570                                  
 31571 00004E92 3C2D                    	cmp	al,'-' ; 2Dh
 31572                                  	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
 31573 00004E94 7507                    	jne	short $P_Sval01		;AN000; else
 31574                                  
 31575 00004E96 2E800E[4F99]02          	or	byte [cs:$P_Flags2],$P_Neg ; 2
 31576                                  					;AC034; set this is negative value
 31577                                  $P_SVal00:				;AN000;
 31578 00004E9C 46                      	inc	si			;AN000; skip sign char
 31579                                  $P_Sval01:				;AN000;
 31580 00004E9D E80200                  	call	$P_Value		;AN000; and process value
 31581 00004EA0 58                      	pop	ax			;AN000;
 31582                                  $P_Check_OVF_ok: ; 11/08/2024
 31583 00004EA1 C3                      	retn				;AN000;
 31584                                  
 31585                                  ;***********************************************************************
 31586                                  
 31587                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31588                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h
 31589                                  
 31590                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31591                                  	; MSDOS 6.2 COMMAND.COM - TRANGROUP:5119h
 31592                                  
 31593                                  	; 11/08/2024
 31594                                  $P_Value:
 31595 00004EA2 50                      	push	ax			;AN000;
 31596 00004EA3 51                      	push	cx			;AN000;
 31597 00004EA4 52                      	push	dx			;AN000;
 31598 00004EA5 56                      	push	si			;AN000;
 31599 00004EA6 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 31600 00004EA8 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 31601 00004EAA 53                      	push	bx			;AN000; save control pointer
 31602                                  $P_Value_Loop:				;AN000;
 31603 00004EAB 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 31604 00004EAE 08C0                    	or	al,al			;AN000; end of line ?
 31605 00004EB0 7436                    	jz	short $P_Value00	;AN000;
 31606                                  
 31607 00004EB2 E8DF00                  	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 31608 00004EB5 722D                    	jc	short $P_Value_Err0	;AN000;
 31609                                  
 31610                                  ; 11/08/2024 - PCDOS 7.1 COMMAND.COM
 31611                                  %if 0
 31612                                  	xor	ah,ah			;AN000;
 31613                                  	mov	bp,ax			;AN000; save binary number
 31614                                  	shl	dx,1			;AN000; to have 2*x
 31615                                  	rcl	cx,1			;AN000; shift left w/ carry
 31616                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31617                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 31618                                  
 31619                                  	mov	bx,dx			;AN000; save low(2*x)
 31620                                  	mov	ax,cx			;AN000; save high(2*x)
 31621                                  	shl	dx,1			;AN000; to have 4*x
 31622                                  	rcl	cx,1			;AN000; shift left w/ carry
 31623                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31624                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 31625                                  
 31626                                  	shl	dx,1			;AN000; to have 8*x
 31627                                  	rcl	cx,1			;AN000; shift left w/ carry
 31628                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31629                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 31630                                  
 31631                                  	add	dx,bx			;AN000; now have 10*x
 31632                                  	adc	cx,ax			;AN000; 32bit ADD
 31633                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31634                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 31635                                  
 31636                                  	add	dx,bp			;AN000; Add the current one degree decimal
 31637                                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 31638                                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 31639                                  	jc	short $P_Value_Err0	;AN000; then error, exit
 31640                                  
 31641                                  	inc	si			;AN000; update pointer
 31642                                  	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
 31643                                  %else
 31644 00004EB7 30E4                    	xor	ah,ah
 31645 00004EB9 89C5                    	mov	bp,ax			; save binary number
 31646 00004EBB E81C00                  	call	$P_Check_OVF_shl32	; check Overflow (after shl32)
 31647 00004EBE 89D3                    	mov	bx,dx			; save low(2*x)
 31648 00004EC0 89C8                    	mov	ax,cx			; save high(2*x)
 31649 00004EC2 E81500                  	call	$P_Check_OVF_shl32	; check OverFlow (after shl32)
 31650 00004EC5 E81200                  	call	$P_Check_OVF_shl32	; check OverFlow (after shl32)
 31651 00004EC8 01DA                    	add	dx,bx			; now have 10*x
 31652 00004ECA 11C1                    	adc	cx,ax			; 32bit ADD
 31653 00004ECC E80F00                  	call	$P_Check_OVF_@		; check OverFlow
 31654 00004ECF 01EA                    	add	dx,bp			; Add the current one degree decimal
 31655 00004ED1 83D100                  	adc	cx,0			; if carry, add 1 to high 16bit
 31656 00004ED4 E80700                  	call	$P_Check_OVF_@		; check Overflow
 31657 00004ED7 46                      	inc	si			; update pointer
 31658 00004ED8 EBD1                    	jmp	short $P_Value_Loop	; loop until NULL encountered
 31659                                  
 31660                                  $P_Check_OVF_shl32:
 31661 00004EDA D1E2                    	shl	dx,1
 31662 00004EDC D1D1                    	rcl	cx,1
 31663                                  $P_Check_OVF_@:
 31664 00004EDE E8A100                  	call	$P_Check_OVF
 31665                                  	;jc	short $P_Value_Err0_@
 31666                                  	;retn
 31667                                  	; 11/08/2024
 31668 00004EE1 73BE                    	jnc	short $P_Check_OVF_ok
 31669                                  
 31670                                  $P_Value_Err0_@:
 31671                                  	;inc	sp
 31672                                  	;inc	sp
 31673                                  	; 11/08/2024
 31674 00004EE3 5B                      	pop	bx
 31675                                  %endif
 31676                                  
 31677                                  $P_Value_Err0:				;AN000;
 31678 00004EE4 5B                      	pop	bx			;AN000;
 31679 00004EE5 E98800                  	jmp	$P_Value_Err		;AN000; Bridge
 31680                                  
 31681                                  $P_Value00:				;AN000;
 31682 00004EE8 5B                      	pop	bx			;AN000; restore control pointer
 31683 00004EE9 2EF606[4F99]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2 
 31684                                  					;AC034; here cx,dx = 32bit value
 31685 00004EEF 740A                    	jz	short $P_Value01	;AN000; was it negative ?
 31686                                  
 31687 00004EF1 F7D1                    	not	cx			;AN000; +
 31688 00004EF3 F7D2                    	not	dx			;AN000; |- Make 2's complement
 31689 00004EF5 83C201                  	add	dx,1			;AN000; |
 31690 00004EF8 83D100                  	adc	cx,0			;AN000; +
 31691                                  $P_Value01:				;AN000; / nval =0
 31692 00004EFB 268B7706                	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 31693                                  	;mov	si,[es:bx+6]		;AN000; si points to value list
 31694 00004EFF 268A04                  	mov	al,[es:si]		;AN000; get nval
 31695 00004F02 3C00                    	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
 31696 00004F04 7505                    	jne	short $P_Value02	;AN000;
 31697                                  
 31698                                  	;mov	al,$P_Number	; 1	;AN000; Set type
 31699                                  	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
 31700                                  	; 31/03/2023
 31701 00004F06 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 31702 00004F09 EB6F                    	jmp	short $P_Value_Exit	;AN000;
 31703                                  
 31704                                  $P_Value02:				;AN000; / nval = 1
 31705 00004F0B 46                      	inc	si			;AN000;
 31706 00004F0C 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 31707 00004F0F 3C00                    	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
 31708 00004F11 745D                    	je	short $P_Value03	;AN000; (tm07)
 31709                                  
 31710 00004F13 46                      	inc	si			;AN000; si points to 1st item_tag
 31711                                  $P_Val02_Loop:				;AN000;
 31712 00004F14 2EF606[4F99]80          	test	byte [cs:$P_Flags2],$P_Signed ; 80h
 31713                                  	;test	byte [cs:$P_Flags2],80h	;AC034;
 31714 00004F1A 751E                    	jnz	short $P_Val02_Sign	;AN000;
 31715                                  
 31716 00004F1C 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 31717                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 31718 00004F20 723B                    	jb	short $P_Val02_Next	;AN000;
 31719 00004F22 7706                    	ja	short $P_Val_In		;AN000;
 31720                                  
 31721 00004F24 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 31722                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 31723 00004F28 7233                    	jb	short $P_Val02_Next	;AN000;
 31724                                  
 31725                                  $P_Val_In:				;AN000;
 31726 00004F2A 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 31727                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
 31728 00004F2E 772D                    	ja	short $P_Val02_Next	;AN000;
 31729 00004F30 7224                    	jb	short $P_Val_Found	;AN000;
 31730                                  
 31731 00004F32 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 31732                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 31733 00004F36 7725                    	ja	short $P_Val02_Next	;AN000;
 31734                                  
 31735 00004F38 EB1C                    	jmp	short $P_Val_Found	;AN000;
 31736                                  
 31737                                  $P_Val02_Sign:				;AN000;
 31738 00004F3A 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 31739                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 31740 00004F3E 7C1D                    	jl	short $P_Val02_Next	;AN000;
 31741 00004F40 7F06                    	jg	short $P_SVal_In	;AN000;
 31742                                  
 31743 00004F42 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 31744                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 31745 00004F46 7C15                    	jl	short $P_Val02_Next	;AN000;
 31746                                  
 31747                                  $P_SVal_In:				;AN000;
 31748 00004F48 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 31749                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
 31750 00004F4C 7F0F                    	jg	short $P_Val02_Next	;AN000;
 31751 00004F4E 7C06                    	jl	short $P_Val_Found	;AN000;
 31752                                  
 31753 00004F50 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 31754                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 31755 00004F54 7F07                    	jg	short $P_Val02_Next	;AN000;
 31756                                  
 31757                                  	;jmp	short $P_Val_Found	;AN000;
 31758                                  	; 27/04/2023
 31759                                  $P_Val_Found:				;AN000;
 31760 00004F56 B001                    	mov	al,$P_Number ; 1	;AN000;
 31761 00004F58 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 31762 00004F5B EB1D                    	jmp	short $P_Value_Exit	;AN000;
 31763                                  
 31764                                  $P_Val02_Next:				;AN000;
 31765 00004F5D 83C609                  	add	si,$P_Len_Range ; 9 	;AN000;
 31766 00004F60 FEC8                    	dec	al			;AN000; loop nrng times in AL
 31767 00004F62 75B0                    	jnz	short $P_Val02_Loop	;AN000;
 31768                                  					; / Not found
 31769 00004F64 2EC706[4399]0600        	mov	word [cs:$P_RC],$P_Out_Of_Range
 31770                                  	;mov	word [cs:$P_RC],6	;AC034;
 31771                                  	
 31772                                  	;mov	al,$P_Number ; 1	;AN000;
 31773                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 31774                                  	; 31/03/2023
 31775 00004F6B B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 31776 00004F6E EB0A                    	jmp	short $P_Value_Exit	;AN000;
 31777                                  
 31778                                  	; 27/04/2023
 31779                                  ;$P_Val_Found:				;AN000;
 31780                                  	;mov	al,$P_Number ; 1	;AN000;
 31781                                  	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
 31782                                  	;jmp	short $P_Value_Exit	;AN000;
 31783                                  
 31784                                  $P_Value03:				;AN000; / nval = 2
 31785                                  $P_Value04:				;AN000; / nval = 3 or else
 31786                                  $P_Value_Err:				;AN000;
 31787 00004F70 2EC706[4399]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 31788                                  					;AC034;
 31789                                  	;mov	al,$P_String ; 3	;AN000; Set type
 31790                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31791                                  	; 31/03/2023
 31792 00004F77 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31793                                  $P_Value_Exit:				;AN000;
 31794 00004F7A E81AFD                  	call	$P_Fill_Result		;AN000;
 31795 00004F7D 5E                      	pop	si			;AN000;
 31796 00004F7E 5A                      	pop	dx			;AN000;
 31797 00004F7F 59                      	pop	cx			;AN000;
 31798 00004F80 58                      	pop	ax			;AN000;
 31799 00004F81 C3                      	retn				;AN000;
 31800                                  
 31801                                  ;***********************************************************************
 31802                                  ; $P_Check_OVF
 31803                                  ;
 31804                                  ; Function:  Check if overflow is occurred with consideration of
 31805                                  ;	     signed or un-signed numeric value
 31806                                  ;
 31807                                  ; Input:     Flag register
 31808                                  ;
 31809                                  ; Output:    CY = 1  :	Overflow
 31810                                  ;
 31811                                  ; Vars:     $P_Flags(R)
 31812                                  ;***********************************************************************
 31813                                  
 31814                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31815                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31816                                  $P_Check_OVF:
 31817 00004F82 9C                      	pushf				;AN000;
 31818 00004F83 2EF606[4F99]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2
 31819                                  					;AC034; is it negative value ?
 31820 00004F89 7502                    	jnz	short $P_COVF		;AN000; if no, check overflow
 31821 00004F8B 9D                      	popf				;AN000; by the CY bit
 31822 00004F8C C3                      	retn				;AN000;
 31823                                  $P_COVF:				;AN000;
 31824 00004F8D 9D                      	popf				;AN000; else,
 31825 00004F8E 7002                    	jo	short $P_COVF00		;AN000; check overflow by the OF
 31826 00004F90 F8                      	clc				;AN000; indicate it with CY bit
 31827 00004F91 C3                      	retn				;AN000; CY=0 means no overflow
 31828                                  $P_0099Err:	; 31/03/2023
 31829                                  $P_COVF00:				;AN000;
 31830 00004F92 F9                      	stc				;AN000; and CY=1 means overflow
 31831                                  $P_0099Err2:	; 31/03/2023
 31832 00004F93 C3                      	retn				;AN000;
 31833                                  
 31834                                  ;***********************************************************************
 31835                                  ; $P_0099;
 31836                                  ;
 31837                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 31838                                  ;
 31839                                  ; Input:     AL = character code
 31840                                  ;
 31841                                  ; Output:    CY = 1 : AL is not number
 31842                                  ;	     CY = 0 : AL contains binary value
 31843                                  ;***********************************************************************
 31844                                  
 31845                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31846                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31847                                  $P_0099:
 31848 00004F94 3C30                    	cmp	al,"0"                  ;AN000;
 31849                                  	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 31850                                  	; 31/03/2023
 31851 00004F96 72FB                    	jb	short $P_0099Err2
 31852                                  
 31853 00004F98 3C39                    	cmp	al,"9"                  ;AN000;
 31854 00004F9A 77F6                    	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 31855                                  
 31856 00004F9C 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 31857                                  	; 31/03/2023
 31858                                  	;clc				;AN000; indicate no error
 31859 00004F9E C3                      	retn				;AN000;
 31860                                  	 ;31/03/2023
 31861                                  ;$P_0099Err:				;AN000;
 31862                                  ;	stc				;AN000; indicate error
 31863                                  ;	retn				;AN000;
 31864                                  
 31865                                  ;***********************************************************************
 31866                                  ; $P_Simple_String
 31867                                  ;
 31868                                  ; Function:  See value list for the simple string
 31869                                  ;	     and make result buffer.
 31870                                  ;
 31871                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31872                                  ;	     ES:BX -> CONTROL block
 31873                                  ;
 31874                                  ; Output:    None
 31875                                  ;
 31876                                  ; Use:	$P_Fill_Result, $P_String_Comp
 31877                                  ;
 31878                                  ; Vars: $P_RC(W)
 31879                                  ;***********************************************************************
 31880                                  
 31881                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31882                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31883                                  $P_Simple_String:
 31884 00004F9F 50                      	push	ax			;AN000;
 31885 00004FA0 53                      	push	bx			;AN000;
 31886 00004FA1 52                      	push	dx			;AN000;
 31887 00004FA2 57                      	push	di			;AN000;
 31888 00004FA3 268B7F06                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 31889                                  	;mov	di,[es:bx+6]		;AN000; di points to value list
 31890 00004FA7 268A05                  	mov	al,[es:di]		;AN000; get nval
 31891 00004FAA 08C0                    	or	al,al			;AN000; no value list ?
 31892 00004FAC 7502                    	jnz	short $P_Sim00		;AN000; then
 31893                                  	; 31/03/2023
 31894                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31895 00004FAE EB48                    	jmp	short $P_Sim_Exit	;AN000; and set result buffer
 31896                                  $P_Sim00:				;AN000;
 31897 00004FB0 3C03                    	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
 31898 00004FB2 753D                    	jne	short $P_Sim01		;AN000; if no, syntax error
 31899                                  
 31900 00004FB4 47                      	inc	di			;AN000;
 31901 00004FB5 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 31902 00004FB8 B409                    	mov	ah,$P_Len_Range ; 9	;AN000;
 31903 00004FBA F6E4                    	mul	ah			;AN000;  Skip nrng field
 31904 00004FBC 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 31905 00004FBD 01C7                    	add	di,ax			;AN000; di points to nnval
 31906 00004FBF 268A05                  	mov	al,[es:di]		;AN000; get nnval
 31907 00004FC2 B405                    	mov	ah,$P_Len_Value ; 5	;AN000;
 31908 00004FC4 F6E4                    	mul	ah			;AN000; Skip nnval field
 31909 00004FC6 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 31910 00004FC7 01C7                    	add	di,ax			;AN000; di points to nstrval
 31911 00004FC9 268A05                  	mov	al,[es:di]		;AN000; get nstrval
 31912 00004FCC 47                      	inc	di			;AC035; add '2' to
 31913 00004FCD 47                      	inc	di			;AC035;  DI reg
 31914                                  					;AN000; di points to 1st string in list
 31915                                  $P_Sim_Loop:				;AN000;
 31916 00004FCE 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 31917 00004FD1 E82F00                  	call	$P_String_Comp		;AN000; compare it with operand
 31918 00004FD4 7310                    	jnc	short $P_Sim_Found	;AN000; found on list ?
 31919                                  
 31920 00004FD6 83C703                  	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
 31921 00004FD9 FEC8                    	dec	al			;AN000; loop nstval times in AL
 31922 00004FDB 75F1                    	jnz	short $P_Sim_Loop	;AN000;
 31923                                  					;AN000; / Not found
 31924 00004FDD 2EC706[4399]0800        	mov	word [cs:$P_RC],$P_Not_In_Str
 31925                                  	;mov	[cs:$P_RC],8		;AC034;
 31926                                  	; 31/03/2023
 31927                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 31928 00004FE4 EB12                    	jmp	short $P_Sim_Exit	;AN000;
 31929                                  $P_Sim_Found:				;AN000;
 31930 00004FE6 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 31931 00004FEA B002                    	mov	al,$P_List_Idx	; 2	;AN000;
 31932 00004FEC 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 31933 00004FEF EB0A                    	jmp	short $P_Sim_Exit0	;AN000;
 31934                                  $P_Sim01:				;AN000;
 31935 00004FF1 2EC706[4399]0900        	mov	word [cs:$P_RC],$P_Syntax
 31936                                  	;mov	word [cs:$P_RC],9	;AC034;
 31937                                  $P_Sim_Exit:
 31938                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 31939                                  ;$P_Sim_Exit:				;AN000;
 31940                                  	;mov	al,$P_String ; 3	;AN000; Set type
 31941                                  	; 31/03/2023
 31942 00004FF8 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31943                                  $P_Sim_Exit0:				;AN000;
 31944 00004FFB E899FC                  	call	$P_Fill_Result		;AN000;
 31945 00004FFE 5F                      	pop	di			;AN000;
 31946 00004FFF 5A                      	pop	dx			;AN000;
 31947 00005000 5B                      	pop	bx			;AN000;
 31948 00005001 58                      	pop	ax			;AN000;
 31949 00005002 C3                      	retn				;AN000;
 31950                                  
 31951                                  ;***********************************************************************
 31952                                  ; $P_String_Comp:
 31953                                  ;
 31954                                  ; Function:  Compare two string
 31955                                  ;
 31956                                  ; Input:     psdata_seg:SI -> 1st string
 31957                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 31958                                  ;	     ES:BX -> CONTROL block
 31959                                  ;
 31960                                  ; Output:    CY = 1 if not match
 31961                                  ;
 31962                                  ; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
 31963                                  ;
 31964                                  ; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
 31965                                  ;***********************************************************************
 31966                                  
 31967                                  	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31968                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 31969                                  $P_String_Comp:
 31970 00005003 50                      	push	ax			;AN000;
 31971 00005004 55                      	push	bp			;AN000;
 31972 00005005 52                      	push	dx			;AN000;
 31973 00005006 56                      	push	si			;AN000;
 31974 00005007 B202                    	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
 31975                                  $P_SCOM_Loop:				;AN000;
 31976 00005009 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 31977 0000500C E89A04                  	call	$P_Chk_DBCS		;AN000; DBCS ?
 31978 0000500F 723C                    	jc	short $P_SCOM00		;AN000; yes,DBCS
 31979                                  
 31980 00005011 E822FE                  	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 31981                                  	
 31982 00005014 2EF606[4F99]08          	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
 31983                                  					;AC034; keyword search ?
 31984 0000501A 740D                    	jz	short $P_SCOM04		;AN000;
 31985                                  
 31986                                  	;cmp	al,'=' ; 3Dh
 31987 0000501C 3C3D                    	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
 31988 0000501E 751F                    	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 31989                                  
 31990 00005020 26807E0100              	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
 31991 00005025 7562                    	jne	short $P_SCOM_Differ	;AN021;
 31992                                  
 31993 00005027 EB13                    	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list
 31994                                  
 31995                                  $P_SCOM04:				;AN000;
 31996 00005029 2EF606[4F99]10          	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
 31997                                  					;AC034; switch search ?
 31998 0000502F 740E                    	jz	short $P_SCOM03		;AN000;
 31999                                  
 32000 00005031 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
 32001 00005033 750A                    	jne	short $P_SCOM03		;AN000; continue compares
 32002                                  
 32003 00005035 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
 32004 0000503A 754D                    	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 32005                                  
 32006                                  $P_SCOM05:				;AN000;   found a match
 32007 0000503C 46                      	inc	si			;AN000; si points to just after "=" or ":"
 32008 0000503D EB58                    	jmp	short $P_SCOM_Same	;AN000; exit
 32009                                  
 32010                                  $P_SCOM03:				;AN000;
 32011 0000503F 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 32012 00005043 751D                    	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 32013                                  
 32014 00005045 08C0                    	or	al,al			;AN000; end of line
 32015 00005047 744E                    	jz	short $P_SCOM_Same	;AN000; if so, exit
 32016                                  
 32017 00005049 46                      	inc	si			;AN000; update operand pointer
 32018 0000504A 45                      	inc	bp			;AN000;    and synonym pointer
 32019 0000504B EB13                    	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 32020                                  
 32021                                  $P_SCOM00:				;AN000; Here al is DBCS leading byte
 32022 0000504D 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 32023 00005051 7536                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different
 32024                                  
 32025 00005053 46                      	inc	si			;AN000; else, load next byte
 32026 00005054 2E8A04                  	mov	al,[cs:si]		;AN000; and
 32027 00005057 45                      	inc	bp			;AN000;
 32028 00005058 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 32029 0000505C 752B                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too
 32030                                  
 32031 0000505E 46                      	inc	si			;AN000; else update operand pointer
 32032 0000505F 45                      	inc	bp			;AN000; 	and synonym pointer
 32033                                  $P_SCOM01:				;AN000;
 32034 00005060 EBA7                    	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 32035                                  
 32036                                  $P_SCOM_Differ0:			;AN000;
 32037 00005062 2EF606[4F99]40          	test	byte [cs:$P_Flags2],$P_SW ; 40h
 32038                                  	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
 32039 00005068 740E                    	jz	short $P_not_applicable	;AN000;(tm10)
 32040                                  
 32041                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 32042                                  	;;test	word [es:bx+2],20h	;AN000;(tm10)
 32043                                  	; 03/04/2023
 32044 0000506A 26F6470220              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 32045 0000506F 7407                    	jz	short $P_not_applicable	;AN000;(tm10)
 32046                                  
 32047 00005071 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
 32048 00005076 741F                    	je	short $P_SCOM_Same	;AN025;(tm10)
 32049                                  
 32050                                  $P_not_applicable:			;AN000;(tm10)
 32051                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 32052                                  	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
 32053                                  	; 03/04/2023
 32054 00005078 26F60710                	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 32055 0000507C 740B                    	jz	short $P_SCOM_Differ	;AN000; if no, say different.
 32056                                  
 32057 0000507E 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
 32058 00005080 750A                    	jne	short $P_SCOM02		;AN000;    subseqently
 32059                                  
 32060 00005082 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
 32061                                  	;jne	short $P_SCOM_Differ	;AN000; if no, say different
 32062                                  	;jmp	short $P_SCOM_Same	;AN000; else, say same
 32063                                  	; 01/04/2023
 32064 00005087 740E                    	je	short $P_SCOM_Same
 32065                                  $P_SCOM_Differ:
 32066 00005089 F9                      	stc
 32067 0000508A EB10                    	jmp	short $P_SCOM_Exit
 32068                                  
 32069                                  $P_SCOM02:				;AN000;
 32070 0000508C 3C00                    	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
 32071 0000508E 75F9                    	jne	short $P_SCOM_Differ	;AN000;
 32072                                  
 32073                                  	;cmp	byte [es:bp],':'
 32074 00005090 26807E003A              	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
 32075                                  	;je	short $p_SCOM_Same	;AN000; else, say same
 32076                                  	; 01/04/2023
 32077 00005095 75F2                    	jne	short $P_SCOM_Differ
 32078                                  ;$P_SCOM_Differ: 			;AN000;
 32079                                  	;stc				;AN000; indicate not found
 32080                                  	;jmp	short $P_SCOM_Exit	;AN000;
 32081                                  
 32082                                  $P_SCOM_Same:				;AN000;
 32083 00005097 2E8936[5299]            	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
 32084                                  	; 01/04/2023
 32085                                  	;clc
 32086                                  	; cf = 0			;AN000; indicate found
 32087                                  $P_SCOM_Exit:				;AN000;
 32088 0000509C 5E                      	pop	si			;AN000;
 32089 0000509D 5A                      	pop	dx			;AN000;
 32090 0000509E 5D                      	pop	bp			;AN000;
 32091 0000509F 58                      	pop	ax			;AN000;
 32092 000050A0 C3                      	retn				;AN000;
 32093                                  
 32094                                  ;***********************************************************************
 32095                                  ; $P_Date_Format
 32096                                  ;
 32097                                  ; Function:  Convert a date string to DOS date format for int 21h
 32098                                  ;	     with format validation.
 32099                                  ;
 32100                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32101                                  ;	     ES:BX -> CONTROL block
 32102                                  ;
 32103                                  ; Output:    None
 32104                                  ;
 32105                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
 32106                                  ;
 32107                                  ; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
 32108                                  ;***********************************************************************
 32109                                  
 32110                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32111                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32112                                  	; 11/08/2024
 32113                                  $P_Date_Format:
 32114 000050A1 50                      	push	ax			;AN000;
 32115 000050A2 51                      	push	cx			;AN000;
 32116 000050A3 52                      	push	dx			;AN000;
 32117 000050A4 56                      	push	si			;AN000;
 32118 000050A5 53                      	push	bx			;AN000;
 32119 000050A6 56                      	push	si			;AN000;
 32120 000050A7 E8A400                  	call	$P_Set_CDI		;AN000; set country dependent information before process
 32121                                  	; 03/04/2023
 32122                                  	;pop	si			;AN000;
 32123                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 32124                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 32125                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 32126 000050AA 31F6                    	xor	si,si
 32127 000050AC 2E8936[019A]            	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
 32128 000050B1 2E8936[039A]            	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
 32129                                  	; 11/08/2024
 32130 000050B6 2E8936[059A]            	mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
 32131 000050BB 5E                      	pop	si
 32132 000050BC E8A900                  	call	$P_Get_DecNum		;AN000; get 1st number
 32133                                  	;jc	short $P_DateF_Err0	;AN000;-----------------------+
 32134                                  	; 11/08/2024
 32135 000050BF 727A                    	jc	short $P_DateF_Error
 32136 000050C1 2EA3[019A]              	mov	[cs:$P_1st_Val],ax	;AC034;			      |
 32137 000050C5 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 32138 000050C7 741A                    	jz	short $P_DateF_YMD	;AN000; 		      |
 32139 000050C9 E89C00                  	call	$P_Get_DecNum		;AN000; get 2nd number	      |
 32140 000050CC 726D                    	jc	short $P_DateF_Error	;AN000; 		      |
 32141 000050CE 2EA3[039A]              	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
 32142 000050D2 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 32143 000050D4 740D                    	jz	short $P_DateF_YMD	;AN000; 		      |
 32144 000050D6 E88F00                  	call	$P_Get_DecNum		;AN000; get 3rd number	      |
 32145                                  $P_DateF_Err0:				;AN000; Bridge	  <-----------+
 32146 000050D9 7260                    	jc	short $P_DateF_Error	;AN000;
 32147 000050DB 2EA3[059A]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 32148 000050DF 08DB                    	or	bl,bl			;AN000; end of line ?
 32149 000050E1 7558                    	jnz	short $P_DateF_Error	;AN000;
 32150                                  $P_DateF_YMD:				;AN000;
 32151 000050E3 2E8B1E[DF99]            	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
 32152                                  	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
 32153 000050E8 83FB02                  	cmp	bx,$P_Date_YMD ; 2	;AN000;
 32154 000050EB 7422                    	je	short $P_DateF00	;AN000;
 32155 000050ED 2EA1[019A]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 32156 000050F1 08E4                    	or	ah,ah			;AN000;
 32157 000050F3 7546                    	jnz	short $P_DateF_Error	;AN000;
 32158 000050F5 88C1                    	mov	cl,al			;AN000; set month
 32159 000050F7 2EA1[039A]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 32160 000050FB 08E4                    	or	ah,ah			;AN000; if overflow, error.
 32161 000050FD 753C                    	jnz	short $P_DateF_Error	;AN000;
 32162 000050FF 88C5                    	mov	ch,al			;AN000; set date
 32163 00005101 2E8B16[059A]            	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
 32164 00005106 83FB01                  	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
 32165 00005109 7502                    	jne	short $P_DateF01	;AN000; if it is DMY
 32166 0000510B 86E9                    	xchg	ch,cl			;AN000;  then swap M <-> D
 32167                                  $P_DateF01:				;AN000;
 32168 0000510D EB19                    	jmp	short $P_DateF02	;AN000;
 32169                                  $P_DateF00:				;AN000; / here format = YMD
 32170 0000510F 2E8B16[019A]            	mov	dx,[cs:$P_1st_Val]	;AC034; set year
 32171 00005114 2EA1[039A]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 32172 00005118 08E4                    	or	ah,ah			;AN000; if overflow, error
 32173 0000511A 751F                    	jnz	short $P_DateF_Error	;AN000;
 32174                                  
 32175 0000511C 88C1                    	mov	cl,al			;AN000; set month
 32176 0000511E 2EA1[059A]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 32177 00005122 08E4                    	or	ah,ah			;AN000; if overflow, error
 32178 00005124 7515                    	jnz	short $P_DateF_Error	;AN000;
 32179 00005126 88C5                    	mov	ch,al			;AN000; set date
 32180                                  $P_DateF02:				;AN000;
 32181 00005128 83FA64                  	cmp	dx,100			;AN000; year is less that 100 ?
 32182 0000512B 7304                    	jae	short $P_DateF03	;AN000;
 32183 0000512D 81C26C07                	add	dx,1900 		;AN000; set year 19xx
 32184                                  $P_DateF03:				;AN000;
 32185 00005131 5B                      	pop	bx			;AN000; recover CONTROL block
 32186 00005132 5E                      	pop	si			;AN000; recover string pointer
 32187                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32188                                  	;mov	al,$P_Date_F ; 7	;AN000;   result
 32189                                  	; 03/04/2023
 32190 00005133 B807FF                  	mov	ax,($P_No_Tag<<8)+$P_Date_F
 32191 00005136 E85EFB                  	call	$P_Fill_Result		;AN000;        buffer
 32192 00005139 EB0F                    	jmp	short $P_Date_Format_Exit
 32193                                  					;AN000;	to Date
 32194                                  $P_DateF_Error: 			;AN000;
 32195 0000513B 5B                      	pop	bx			;AN000; recover CONTROL block
 32196 0000513C 5E                      	pop	si			;AN000; recover string pointer
 32197                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32198                                  	;mov	al,$P_String ; 3	;AN000;   result
 32199                                  	; 03/04/2023
 32200 0000513D B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 32201 00005140 E854FB                  	call	$P_Fill_Result		;AN000; 	buffer
 32202                                  					;AN000; to string
 32203 00005143 2EC706[4399]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 32204                                  					;AC034; indicate syntax error
 32205                                  $P_Date_Format_Exit:			;AN000;
 32206 0000514A 5A                      	pop	dx			;AN000;
 32207 0000514B 59                      	pop	cx			;AN000;
 32208 0000514C 58                      	pop	ax			;AN000;
 32209 0000514D C3                      	retn				;AN000;
 32210                                  
 32211                                  ;***********************************************************************
 32212                                  ; $P_Set_CDI:
 32213                                  ;
 32214                                  ; Function: Read CDI from DOS if it has not been read yet
 32215                                  ;
 32216                                  ; Input:    None
 32217                                  ;
 32218                                  ; Output:   psdata_seg:SI -> CDI
 32219                                  ;
 32220                                  ; Use:	INT 21h w/ AH = 38h
 32221                                  ;***********************************************************************
 32222                                  
 32223                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32224                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32225                                  $P_Set_CDI:
 32226                                  	; 18/04/2023
 32227 0000514E 8D36[DF99]              	lea	si,$P_Country_Info	;AC034;
 32228                                  	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
 32229 00005152 2E833CFF                	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
 32230                                  					;AN000; already read ?
 32231                                  	;je	short $P_Read_CDI	;AN000;
 32232                                  	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
 32233                                  	; 03/04/2023
 32234 00005156 750F                    	jne	short $P_Set_CDI_Exit
 32235                                  $P_Read_CDI:				;AN000; else read CDI thru DOS
 32236 00005158 1E                      	push	ds			;AN000;
 32237 00005159 52                      	push	dx			;AN000;
 32238 0000515A 50                      	push	ax			;AN000;
 32239 0000515B 0E                      	push	cs			;AC023;
 32240 0000515C 1F                      	pop	ds			;AN000; set segment register
 32241                                  	;mov	ax,3800h
 32242 0000515D B80038                  	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
 32243 00005160 89F2                    	mov	dx,si			;AN000; set offset of CDI in local data area
 32244 00005162 CD21                    	int	21h			;AN000;
 32245 00005164 58                      	pop	ax			;AN000;
 32246 00005165 5A                      	pop	dx			;AN000;
 32247 00005166 1F                      	pop	ds			;AN000;
 32248                                  $P_Set_CDI_Exit:			;AN000;
 32249 00005167 C3                      	retn				;AN000;
 32250                                  
 32251                                  ;***********************************************************************
 32252                                  ; $P_Get_DecNum:
 32253                                  ;
 32254                                  ; Function:  Read a character code from psdata_seg:SI until specified delimiter
 32255                                  ;	     or NULL encountered. And make a decimal number.
 32256                                  ;
 32257                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32258                                  ;
 32259                                  ; Output:    BL = delimiter code or NULL
 32260                                  ;	     AX = Decimal number
 32261                                  ;	     SI advanced to the next number
 32262                                  ;	     CY = 1 : Syntax error, AL = Latest examineed number
 32263                                  ;
 32264                                  ; Use:	$P_0099
 32265                                  ;***********************************************************************
 32266                                  
 32267                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32268                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32269                                  $P_Get_DecNum:
 32270 00005168 51                      	push	cx			;AN000;
 32271 00005169 52                      	push	dx			;AN000;
 32272 0000516A 31C9                    	xor	cx,cx			;AN000; cx will have final value
 32273                                  $P_GetNum_Loop: 			;AN000;
 32274 0000516C 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 32275 0000516F 08C0                    	or	al,al			;AN000; end of line ?
 32276 00005171 7438                    	jz	short $P_GetNum00	;AN000; if yes, exit
 32277 00005173 2E803E[DE99]00          	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
 32278 00005179 740B                    	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023
 32279                                  
 32280                                  ; Determine which delimiter(s) to check for. Colon & period  or period only
 32281                                  	;cmp	bl,$P_colon_period
 32282 0000517B 80FB01                  	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
 32283 0000517E 750E                    	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period
 32284                                  
 32285 00005180 3C3A                    	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
 32286 00005182 742B                    	je	short $P_GetNum01	;AN032; ;yes, exit
 32287                                  
 32288                                  	; 03/04/2023
 32289 00005184 EB08                    	jmp	short $P_Do_Time_Delim1
 32290                                  ;$P_Do_Time_Delim1:			;AN000;
 32291                                  	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
 32292                                  	;je	short $P_GetNum01	;AC023; yes, exit
 32293                                  	;
 32294                                  	;jmp	short $P_Neither_Delims ;AN023;
 32295                                  
 32296                                  $P_Do_Date_Delims:			;AN000;
 32297                                  ;Regardless of the date delimiter character specified in the country
 32298                                  ;dependent information, check for the presence of any one of these
 32299                                  ;three field delimiters: "-", "/", or ".".
 32300 00005186 3C2D                    	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
 32301 00005188 7425                    	je	short $P_GetNum01	;AN020;if yes, exit
 32302                                  
 32303 0000518A 3C2F                    	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
 32304 0000518C 7421                    	je	short $P_GetNum01	;AN020;if yes, exit
 32305                                  
 32306                                  $P_Do_Time_Delim1:  ; 03/04/2023
 32307 0000518E 3C2E                    	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
 32308 00005190 741D                    	je	short $P_GetNum01	;AN000; if yes, exit
 32309                                  
 32310                                  $P_Neither_Delims:			;AN023;
 32311 00005192 E8FFFD                  	call	$P_0099 		;AN000; convert it to binary
 32312 00005195 721C                    	jc	short $P_GetNum_Exit	;AN000; if error exit
 32313                                  
 32314 00005197 B400                    	mov	ah,0			;AN000;
 32315 00005199 91                      	xchg	ax,cx			;AN000;
 32316 0000519A BA0A00                  	mov	dx,10			;AN000;
 32317 0000519D F7E2                    	mul	dx			;AN000; ax = ax * 10
 32318 0000519F 09D2                    	or	dx,dx			;AN000; overflow
 32319 000051A1 750F                    	jnz	short $P_GetNum02	;AN000; then exit
 32320                                  
 32321 000051A3 01C8                    	add	ax,cx			;AN000;
 32322 000051A5 720C                    	jc	short $P_GetNum_Exit	;AN000;
 32323                                  
 32324 000051A7 91                      	xchg	ax,cx			;AN000;
 32325 000051A8 46                      	inc	si			;AN000;
 32326 000051A9 EBC1                    	jmp	short $P_GetNum_Loop	;AN000;
 32327                                  
 32328                                  $P_GetNum00:				;AN000;
 32329 000051AB 88C3                    	mov	bl,al			;AN000; set bl to NULL
 32330                                  	;03/04/2023
 32331                                  	; cf=0
 32332                                  	;clc				;AN000; indicate no error
 32333 000051AD EB04                    	jmp	short $P_GetNum_Exit	;AN000;
 32334                                  
 32335                                  $P_GetNum01:				;AN000;
 32336 000051AF 46                      	inc	si			;AN000; si points to next number
 32337                                  	;03/04/2023
 32338                                  	; cf=0
 32339                                  	;clc				;AN000; indicate no error
 32340 000051B0 EB01                    	jmp	short $P_GetNum_Exit	;AN000;
 32341                                  
 32342                                  $P_GetNum02:				;AN000;
 32343 000051B2 F9                      	stc				;AN000; indicate error
 32344                                  $P_GetNum_Exit: 			;AN000;
 32345 000051B3 89C8                    	mov	ax,cx			;AN000;return value
 32346 000051B5 5A                      	pop	dx			;AN000;
 32347 000051B6 59                      	pop	cx			;AN000;
 32348 000051B7 C3                      	retn				;AN000;
 32349                                  
 32350                                  ;***********************************************************************
 32351                                  ; $P_Time_Format
 32352                                  ;
 32353                                  ; Function:  Convert a time string to DOS time format for int 21h
 32354                                  ;	     with format validation.
 32355                                  ;
 32356                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32357                                  ;	     ES:BX -> CONTROL block
 32358                                  ;
 32359                                  ; Output:    None
 32360                                  ;
 32361                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
 32362                                  ;
 32363                                  ; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
 32364                                  ;	$P_3rd_Val(RW), $P_4th_Val(RW)
 32365                                  ;***********************************************************************
 32366                                  
 32367                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32368                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32369                                  	; 12/08/2024
 32370                                  $P_Time_Format:				;AN000;
 32371 000051B8 50                      	push	ax			;AN000;
 32372 000051B9 51                      	push	cx			;AN000;
 32373 000051BA 52                      	push	dx			;AN000;
 32374 000051BB 56                      	push	si			;AN000;
 32375 000051BC 53                      	push	bx			;AN000;
 32376 000051BD 56                      	push	si			;AN000;
 32377 000051BE E88DFF                  	call	$P_Set_CDI		;AN000; Set country independent
 32378                                  					; information before process
 32379                                  	;test	byte [cs:si+11h], 1
 32380 000051C1 2EF6441001              	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
 32381                                  					;AN000; 24 hour system
 32382 000051C6 5E                      	pop	si			;AN000;
 32383 000051C7 7503                    	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
 32384 000051C9 E8F800                  	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
 32385                                  $P_TimeF00:				;AN000;
 32386                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 32387                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 32388                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 32389                                  	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
 32390                                  	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
 32391                                  	; 03/04/2023
 32392 000051CC 31DB                    	xor	bx,bx
 32393 000051CE 2E891E[019A]            	mov	[cs:$P_1st_Val],bx ; 0
 32394 000051D3 2E891E[039A]            	mov	[cs:$P_2nd_Val],bx ; 0
 32395 000051D8 2E891E[059A]            	mov	[cs:$P_3rd_Val],bx ; 0
 32396 000051DD 2E891E[079A]            	mov	[cs:$P_4th_Val],bx ; 0
 32397                                  	;inc	bl
 32398                                  	;mov	[cs:$P_Got_Time],bl ; 1
 32399                                  
 32400                                  	;mov	bl,$P_colon_period
 32401                                  	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
 32402                                  					; delimiters between hours,
 32403                                  					;  minutes,seconds
 32404                                  	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
 32405 000051E2 FEC3                    	inc	bl ; bl = 1
 32406 000051E4 2E881E[DE99]            	mov	[cs:$P_Got_Time],bl ; 1
 32407                                  	;
 32408 000051E9 E87CFF                  	call	$P_Get_DecNum		;AN000; get 1st number
 32409                                  	;jc	short $P_TimeF_Err0	;AN000;
 32410                                  	; 12/08/2024
 32411 000051EC 725A                    	jc	short $P_TimeF_Error
 32412 000051EE 2EA3[019A]              	mov	[cs:$P_1st_Val],ax	;AC034;
 32413 000051F2 08DB                    	or	bl,bl			;AN000; end of line ?
 32414 000051F4 7478                    	jz	short $P_TimeF_Rlt	;AN000;
 32415 000051F6 E86FFF                  	call	$P_Get_DecNum		;AN000; get 2nd number
 32416                                  	;jc	short $P_TimeF_Err0	;AC038; if OK
 32417                                  	; 12/08/2024
 32418 000051F9 724D                    	jc	short $P_TimeF_Error
 32419 000051FB 2EA3[039A]              	mov	[cs:$P_2nd_Val],ax	;AC034;
 32420 000051FF 08DB                    	or	bl,bl			;AN000; end of line ?
 32421 00005201 746B                    	jz	short $P_TimeF_Rlt	;AN000;
 32422 00005203 B302                    	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
 32423 00005205 E860FF                  	call	$P_Get_DecNum		;AN000; get 3rd number
 32424                                  	;jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
 32425                                  	; 12/08/2024
 32426 00005208 723E                    	jc	short $P_TimeF_Error
 32427 0000520A 2EA3[059A]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 32428 0000520E 08DB                    	or	bl,bl			;AN000; end of line ?
 32429 00005210 754F                    	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
 32430                                  					;AN039;   GO TO 4TH NUMBER
 32431                                  	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
 32432 00005212 2EF606[4E99]02          	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
 32433                                  					;AN039;    BEEN REPEATED?
 32434 00005218 7554                    	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
 32435                                  					;AN039;   the end of line
 32436                                  					;AN039; no, time has not been repeated
 32437 0000521A 2E8B36[4599]            	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
 32438                                  					;AN039;   in command line
 32439 0000521F 807CFF2C                	cmp	byte [si-1],$P_Comma ; ','
 32440                                  					;AN039; look at delimiter
 32441                                  					;AN039;   from command line
 32442 00005223 7549                    	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
 32443                                  					;AN039;  really end of line
 32444                                  					;AN039; is comma before hundredths,
 32445                                  					;AN039;   redo TIME
 32446 00005225 C644FF2E                	mov	byte [si-1],$P_Period ; '.' 
 32447                                  					;AN039; change that ambiguous
 32448                                  					;AN039;    comma to a decimal point
 32449                                  					;AN039;     parse can understand
 32450 00005229 2EC706[4E99]0000        	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
 32451                                  	;or	byte [cs:$P_Flags1],$P_Time_Again
 32452 00005230 2E800E[4E99]02          	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
 32453                                  					;AN039; is being repeated
 32454 00005236 2E8B0E[D899]            	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
 32455 0000523B 2E8B26[DA99]            	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
 32456                                  					;AN039;   OF STACK FROM SP
 32457 00005240 2E8B36[DC99]            	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
 32458                                  					;AN039;   PARSE POINTER FROM SI
 32459 00005245 E927F8                  	jmp	$P_Redo_Time		;AN039; go try TIME again
 32460                                  
 32461                                  	; 12/08/2024
 32462                                  $P_TimeF_Error: 			;AN000;
 32463                                  $P_TimeF_Err:				;AN000;
 32464 00005248 5B                      	pop	bx			;AN000; recover CONTROL block
 32465 00005249 5E                      	pop	si			;AN000; recover string pointer
 32466                                  	;mov	ah,$P_No_Tag		;AN000; set
 32467                                  	;mov	al,$P_String		;AN000;     result
 32468                                  	; 03/04/2023
 32469 0000524A B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 32470 0000524D E847FA                  	call	$P_Fill_Result		;AN000; 	  buffer
 32471                                  					;AN000; to string
 32472 00005250 2EC706[4399]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9	
 32473                                  					;AC034; return syntax error
 32474                                  $P_Time_Format_Exit:			;AN000;
 32475 00005257 2EC606[DE99]00          	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
 32476 0000525D 5A                      	pop	dx			;AN000;
 32477 0000525E 59                      	pop	cx			;AN000;
 32478 0000525F 58                      	pop	ax			;AN000;
 32479 00005260 C3                      	retn
 32480                                  
 32481                                  $P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
 32482 00005261 E804FF                  	call	$P_Get_DecNum		;AN000; get 4th number
 32483                                  $P_TimeF_Err0:				;AN000; Bridge
 32484 00005264 72E2                    	jc	short $P_TimeF_Error	;AN000;
 32485                                  	;
 32486 00005266 2EA3[079A]              	mov	[cs:$P_4th_Val],ax	;AC034;
 32487 0000526A 08DB                    	or	bl,bl			;AN000; After hundredth, no data allowed
 32488 0000526C 75DA                    	jnz	short $P_TimeF_Error	;AN000; if some, then error
 32489                                  $P_TimeF_Rlt:				;AN000;
 32490 0000526E 2EA1[019A]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 32491 00005272 08E4                    	or	ah,ah			;AN000; if overflow then error
 32492 00005274 75D2                    	jnz	short $P_TimeF_Err	;AN000;
 32493                                  	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
 32494 00005276 2EF606[4E99]01          	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
 32495 0000527C 7408                    	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
 32496                                  					;since "AM" was specified,
 32497 0000527E 3C0C                    	cmp	al,12			;AN038: if hour specified as later than noon
 32498 00005280 77C6                    	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
 32499 00005282 7502                    	jne	short $P_Time_notAM	;AN038; for noon exactly,
 32500 00005284 30C0                    	xor	al,al			;AN038; set hour = zero
 32501                                  $P_Time_notAM:				;AN038;
 32502                                  	;test	byte [cs:$P_Flags2],$P_Time12
 32503 00005286 2EF606[4F99]04          	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
 32504 0000528C 740C                    	jz	short $P_TimeSkip00	;AN000; then
 32505 0000528E 3C0C                    	cmp	al,12			;AN038; if 12:00 o'clock already
 32506 00005290 7408                    	je	short $P_TimeSkip00	;AN038; it is PM already
 32507 00005292 040C                    	add	al,12			;AN000; add 12 hours to make it afternoon
 32508 00005294 72B2                    	jc	short $P_TimeF_Err	;AN000; if overflow then error
 32509 00005296 3C18                    	cmp	al,24			;AN038; after adding 12, now cannot be >24
 32510 00005298 77AE                    	ja	short $P_TimeF_Err	;AN038; if too big, error
 32511                                  $P_TimeSkip00:				;AN000;
 32512 0000529A 88C2                    	mov	dl,al			;AN000; set hour
 32513 0000529C 2EA1[039A]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 32514 000052A0 08E4                    	or	ah,ah			;AN000; if overflow then error
 32515 000052A2 75A4                    	jnz	short $P_TimeF_Err	;AN000;
 32516 000052A4 88C6                    	mov	dh,al			;AN000; set minute
 32517 000052A6 2EA1[059A]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 32518 000052AA 08E4                    	or	ah,ah			;AN000; if overflow then error
 32519 000052AC 759A                    	jnz	short $P_TimeF_Err	;AN000;
 32520 000052AE 88C1                    	mov	cl,al			;AN000; set second
 32521 000052B0 2EA1[079A]              	mov	ax,[cs:$P_4th_Val]	;AC034;
 32522 000052B4 08E4                    	or	ah,ah			;AN000; if overflow then error
 32523 000052B6 7590                    	jnz	short $P_TimeF_Err	;AN000;
 32524 000052B8 88C5                    	mov	ch,al			;AN000; set hundredth
 32525 000052BA 5B                      	pop	bx			;AN000; recover CONTROL block
 32526 000052BB 5E                      	pop	si			;AN000; recover string pointer
 32527                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32528                                  	;mov	al,$P_Time_F ; 8 	;AN000;   result
 32529                                  	; 03/04/2023
 32530 000052BC B808FF                  	mov	ax,($P_No_Tag<<8)+$P_Time_F
 32531 000052BF E8D5F9                  	call	$P_Fill_Result		;AN000;        buffer
 32532 000052C2 EB93                    	jmp	short $P_Time_Format_Exit
 32533                                  					;AN000; to time
 32534                                  
 32535                                  ;***********************************************************************
 32536                                  ; $P_Time_2412:
 32537                                  ;
 32538                                  ; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
 32539                                  ;
 32540                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32541                                  ;
 32542                                  ; Output:    Set $P_Time12 flag when the string is terminated by "p"
 32543                                  ;	     or "pm"
 32544                                  ;
 32545                                  ; Vars:  $P_Flags(W)
 32546                                  ;***********************************************************************
 32547                                  
 32548                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32549                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32550                                  $P_Time_2412:				;AN000;
 32551 000052C4 50                      	push	ax			;AN000;
 32552 000052C5 56                      	push	si			;AN000;
 32553                                  $P_T12_Loop:				;AN000;
 32554 000052C6 2E8A04                  	mov	al,[cs:si]		;AN000; Move
 32555 000052C9 46                      	inc	si			;AN000;     si
 32556 000052CA 08C0                    	or	al,al			;AN000;       to
 32557 000052CC 75F8                    	jnz	short $P_T12_Loop	;AN000; 	end of string
 32558                                  
 32559 000052CE 2E8A44FE                	mov	al,[cs:si-2]		;AN000; get char just before NULL
 32560                                  	;or	al,20h
 32561 000052D2 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 32562 000052D4 3C70                    	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
 32563 000052D6 7425                    	je	short $P_T1200		;AN000;
 32564                                  
 32565 000052D8 3C61                    	cmp	al,"a"                  ;AN000; only "a" of "am" ?
 32566 000052DA 7413                    	je	short $P_T1201		;AN000;
 32567                                  
 32568 000052DC 3C6D                    	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
 32569 000052DE 751A                    	jne	short $P_T12_Exit	;AN000;
 32570                                  
 32571 000052E0 4E                      	dec	si			;AN000;
 32572 000052E1 2E8A44FE                	mov	al,[cs:si-2]		;AN000;
 32573                                  	;or	al,20h
 32574 000052E5 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 32575 000052E7 3C70                    	cmp	al,"p"                  ;AN000; "p" of "pm" ?
 32576 000052E9 7412                    	je	short $P_T1200		;AN000;
 32577                                  
 32578 000052EB 3C61                    	cmp	al,"a"                  ;AN000; "a" of "am" ?
 32579                                  	;je	short $P_T1201		;AN000; go process "a"
 32580                                  	;jmp	short $P_T12_Exit	;AN000; no special chars found
 32581                                  	; 05/04/2023
 32582 000052ED 750B                    	jne	short $P_T12_Exit
 32583                                  
 32584                                  ;$P_T1200:				;AN000; "P" found
 32585                                  	;;or	byte [cs:$P_Flags2],$P_Time12
 32586                                  	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 32587                                  	;jmp	short $P_Tclr_chr	;AN038; go clear the special char
 32588                                  
 32589                                  $P_T1201:				;AN000; "A" found
 32590                                  	;or	byte [cs:$P_Flags1],$P_Time12AM
 32591 000052EF 2E800E[4E99]01          	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
 32592                                  $P_Tclr_chr:				;AN038;
 32593 000052F5 2EC644FE00              	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
 32594                                  $P_T12_Exit:				;AN000;
 32595 000052FA 5E                      	pop	si			;AN000;
 32596 000052FB 58                      	pop	ax			;AN000;
 32597 000052FC C3                      	retn				;AN000;
 32598                                  
 32599                                  	; 05/04/2023
 32600                                  $P_T1200:				;AN000; "P" found
 32601                                  	;or	byte [cs:$P_Flags2],$P_Time12
 32602 000052FD 2E800E[4F99]04          	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 32603 00005303 EBF0                    	jmp	short $P_Tclr_chr	;AN038; go clear the special char
 32604                                  
 32605                                  ;***********************************************************************
 32606                                  ; $P_File_Format;
 32607                                  ;
 32608                                  ; Function:  Check if the input string is valid file spec format.
 32609                                  ;	     And set the result buffer.
 32610                                  ;
 32611                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32612                                  ;	     ES:BX -> CONTROL block
 32613                                  ;
 32614                                  ; Output:    None
 32615                                  ;
 32616                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
 32617                                  ;
 32618                                  ; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
 32619                                  ;	$P_SaveSI_Cmpx(R)
 32620                                  ;***********************************************************************
 32621                                  
 32622                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32623                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
 32624                                  
 32625                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32626                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:55B4h
 32627                                  $P_File_Format:
 32628 00005305 50                      	push	ax			;AN000;
 32629 00005306 57                      	push	di			;AN000;
 32630 00005307 56                      	push	si			;AN000;
 32631 00005308 2E8B3E[5099]            	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
 32632 0000530D 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 32633 00005310 08C0                    	or	al,al			;AN000; end of line ?
 32634 00005312 7413                    	je	short $P_FileF_Err	;AN000; if yes, error exit
 32635 00005314 E85D00                  	call	$P_FileSp_Chk		;AN000; else, check if file special character
 32636 00005317 7523                    	jne	short $P_FileF03	;AN000; if yes,
 32637 00005319 2EC606[1C9A]01          	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
 32638                                  					;AN033;AC034;; set error flag- bad char.
 32639 0000531F 5E                      	pop	si			;AN033;
 32640 00005320 2EC60400                	mov	byte [cs:si],$P_NULL	;AN033;
 32641 00005324 5F                      	pop	di			;AN033;
 32642 00005325 EB3E                    	jmp	short $P_FileF02	;AN033;
 32643                                  $P_FileF_Err:				;AN000;
 32644 00005327 5E                      	pop	si			;AN000;
 32645 00005328 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000;
 32646 0000532C 5F                      	pop	di			;AN000;
 32647                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 32648                                  	;test	word [es:bx],1		;AN000; is it optional ?
 32649 0000532D 26F60701                	test	byte [es:bx],$P_Optional ; 1
 32650 00005331 7532                    	jnz	short $P_FileF02	;AN000;
 32651 00005333 2EC706[4399]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 32652                                  	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
 32653 0000533A EB29                    	jmp	short $P_FileF02	;AN000;
 32654                                  $P_FileF03:				;AN000;
 32655 0000533C 58                      	pop	ax			;AN000; discard save si
 32656 0000533D 56                      	push	si			;AN000; save new si
 32657                                  $P_FileF_Loop1: 			;AN000;
 32658 0000533E 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 32659 00005341 08C0                    	or	al,al			;AN000; end of line ?
 32660 00005343 741E                    	jz	short $P_FileF_RLT	;AN000;
 32661 00005345 E82C00                  	call	$P_FileSp_Chk		;AN000; File special character ?
 32662 00005348 740B                    	jz	short $P_FileF00	;AN000;
 32663 0000534A E85C01                  	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
 32664 0000534D 7302                    	jnc	short $P_FileF01	;AN000;
 32665 0000534F 47                      	inc	di			;AN000; if yes, skip next byte
 32666 00005350 46                      	inc	si			;AN000;
 32667                                  $P_FileF01:				;AN000;
 32668 00005351 47                      	inc	di			;AN000;
 32669 00005352 46                      	inc	si			;AN000;
 32670 00005353 EBE9                    	jmp	short $P_FileF_Loop1	;AN000;
 32671                                  $P_FileF00:				;AN000;
 32672 00005355 2EA2[4999]              	mov	[cs:$P_Terminator],al	;AC034;
 32673 00005359 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; update end of string
 32674 0000535D 47                      	inc	di			;AN000;
 32675 0000535E 2E893E[4599]            	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
 32676                                  $P_FileF_RLT:				;AN000;
 32677 00005363 5E                      	pop	si			;AN000;
 32678 00005364 5F                      	pop	di			;AN000;
 32679                                  $P_FileF02:				;AN000;
 32680 00005365 58                      	pop	ax			;AN000; (tm14)
 32681                                  	;;test	ax,200h
 32682                                  	;test	ax,$P_File_Spc		;AN000; (tm14)
 32683                                  	; 05/04/2023
 32684 00005366 F6C402                  	test	ah,($P_File_Spc>>8)
 32685 00005369 7408                    	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
 32686 0000536B 50                      	push	ax			;AN000; (tm14)
 32687                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 32688                                  	;mov	al,$P_File_Spec ; 5 	;AN000;    result
 32689                                  	; 05/04/2023
 32690 0000536C B805FF                  	mov	ax,($P_No_Tag<<8)+$P_File_Spec
 32691 0000536F E825F9                  	call	$P_Fill_Result		;AN000; 	buffer to file spec
 32692 00005372 58                      	pop	ax			;AN000;
 32693                                  $P_Drv_Only_Exit:			;AN000; (tm14)
 32694 00005373 C3                      	retn				;AN000;
 32695                                  
 32696                                  ;***********************************************************************
 32697                                  ; $P_FileSp_Chk
 32698                                  ;
 32699                                  ; Function:  Check if the input byte is one of file special characters
 32700                                  ;
 32701                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32702                                  ;	     AL = character code to be examineed
 32703                                  ;
 32704                                  ; Output:    ZF = 1 , AL is one of special characters
 32705                                  ;***********************************************************************
 32706                                  
 32707                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32708                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32709                                  $P_FileSp_Chk:
 32710 00005374 53                      	push	bx			;AN000;
 32711 00005375 51                      	push	cx			;AN000;
 32712                                  	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
 32713 00005376 8D1E[139A]              	lea	bx,$P_FileSp_Char ; '[]|<>+=;"'
 32714 0000537A B90900                  	mov	cx,$P_FileSp_Len ; 9
 32715                                  	;mov	cx,9			;AN000; load length of it
 32716                                  $P_FileSp_Loop: 			;AN000;
 32717 0000537D 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 32718 00005380 7404                    	je	short $P_FileSp_Exit	;AN000;
 32719 00005382 43                      	inc	bx			;AN000;
 32720 00005383 E2F8                    	loop	$P_FileSp_Loop		;AN000;
 32721 00005385 41                      	inc	cx			;AN000; reset ZF
 32722                                  $P_FileSp_Exit: 			;AN000;
 32723 00005386 59                      	pop	cx			;AN000;
 32724 00005387 5B                      	pop	bx			;AN000;
 32725 00005388 C3                      	retn				;AN000;
 32726                                  
 32727                                  ;***********************************************************************
 32728                                  ; $P_Drive_Format;
 32729                                  ;
 32730                                  ; Function:  Check if the input string is valid drive only format.
 32731                                  ;	     And set the result buffer.
 32732                                  ;
 32733                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 32734                                  ;	     ES:BX -> CONTROL block
 32735                                  ;
 32736                                  ; Output:    None
 32737                                  ;
 32738                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS
 32739                                  ;
 32740                                  ; Vars: $P_RC(W)
 32741                                  ;***********************************************************************
 32742                                  
 32743                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32744                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32745                                  $P_Drive_Format:
 32746 00005389 50                      	push	ax			;AN000;
 32747 0000538A 52                      	push	dx			;AN000;
 32748 0000538B 2E8A04                  	mov	al,[cs:si]		;AN000;
 32749 0000538E 08C0                    	or	al,al			;AN000; if null string
 32750 00005390 7436                    	jz	short $P_Drv_Exit	;AN000; do nothing
 32751 00005392 E81401                  	call	$P_Chk_DBCS		;AN000; is it leading byte ?
 32752 00005395 722A                    	jc	short $P_Drv_Err	;AN000;
 32753                                  	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
 32754 00005397 2E837C013A              	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
 32755 0000539C 740D                    	je	short $P_DrvF00		;AN000;
 32756                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 32757                                  	;test	word [es:bx],10h	;AN000; colon can be ignored?
 32758 0000539E 26F60710                	test	byte [es:bx],$P_Ig_Colon ; 10h
 32759 000053A2 741D                    	jz	short $P_Drv_Err	;AN000;
 32760 000053A4 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
 32761 000053A9 7516                    	jne	short $P_Drv_Err	;AN000;
 32762                                  $P_DrvF00:				;AN000;
 32763 000053AB 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case
 32764 000053AD 3C61                    	cmp	al,"a" ; 61h            ;AN000; drive letter must
 32765 000053AF 7210                    	jb	short $P_Drv_Err	;AN000; in range of
 32766 000053B1 3C7A                    	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
 32767 000053B3 770C                    	ja	short $P_Drv_Err	;AN000; if no, error
 32768 000053B5 2C60                    	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
 32769 000053B7 88C2                    	mov	dl,al			;AN000; set
 32770                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
 32771                                  	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
 32772                                  	; 05/04/2023
 32773 000053B9 B806FF                  	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
 32774 000053BC E8D8F8                  	call	$P_Fill_Result		;AN000; 	       to drive
 32775 000053BF EB07                    	jmp	short $P_Drv_Exit	;AN000;
 32776                                  $P_Drv_Err:				;AN000;
 32777 000053C1 2EC706[4399]0900        	mov	word [cs:$P_RC],$P_Syntax
 32778                                  	;mov	word [cs:$P_RC],9	;AC034;
 32779                                  $P_Drv_Exit:				;AN000;
 32780 000053C8 5A                      	pop	dx			;AN000;
 32781 000053C9 58                      	pop	ax			;AN000;
 32782 000053CA C3                      	retn				;AN000;
 32783                                  
 32784                                  ;***********************************************************************
 32785                                  ; $P_Skip_Delim;
 32786                                  ;
 32787                                  ; Function: Skip delimiters specified in the PARMS list, white space
 32788                                  ;	    and comma.
 32789                                  ;
 32790                                  ; Input:    DS:SI -> Command String
 32791                                  ;	    ES:DI -> Parameter List
 32792                                  ;
 32793                                  ; Output:   CY = 1 if the end of line encounterd
 32794                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 32795                                  ;	    AL = Last examineed character
 32796                                  ;
 32797                                  ; Use:	    $P_Chk_EOL, $P_Chk_Delim,
 32798                                  ;
 32799                                  ; Vars:     $P_Flags(R)
 32800                                  ;***********************************************************************
 32801                                  
 32802                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32803                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32804                                  $P_Skip_Delim:				;AN000;
 32805                                  $P_Skip_Delim_Loop:			;AN000;
 32806 000053CB AC                      	lodsb				;AN000;
 32807 000053CC E81E00                  	call	$P_Chk_EOL		;AN000; is it EOL character ?
 32808 000053CF 7416                    	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 32809                                  
 32810 000053D1 E84B00                  	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
 32811 000053D4 7514                    	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off
 32812                                  
 32813 000053D6 2EF606[4F99]20          	test	byte [cs:$P_Flags2],$P_Extra
 32814                                  	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
 32815 000053DC 74ED                    	jz	short $P_Skip_Delim_Loop
 32816                                  					;AN000; if no, loop
 32817 000053DE 2EF606[4F99]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ
 32818                                  	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
 32819                                  	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 32820                                  	;dec	si ; *			;AN000; backup si for next call (tm08)
 32821                                  	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
 32822                                  	; 05/04/2023
 32823 000053E4 7505                    	jnz	short $P_Skip_Delim_Exit ; cf = 0
 32824                                  $P_Exit_At_Extra:			;AN000;
 32825                                  	; cf = 0
 32826                                  	;clc				;AN000; indicate extra delim
 32827 000053E6 C3                      	retn				;AN000;
 32828                                  
 32829                                  $P_Skip_Delim_CY:			;AN000;
 32830 000053E7 F9                      	stc				;AN000; indicate EOL
 32831 000053E8 EB01                    	jmp	short $P_Skip_Delim_Exit
 32832                                  					;AN000;
 32833                                  $P_Skip_Delim_NCY:			;AN000;
 32834 000053EA F8                      	clc				;AN000; indicate non delim
 32835                                  $P_Skip_Delim_Exit:			;AN000; in this case, need
 32836 000053EB 4E                      	dec	si ; *			;AN000;  backup index pointer
 32837 000053EC C3                      	retn				;AN000;
 32838                                  	; 05/04/2023
 32839                                  ;$P_Exit_At_Extra:			;AN000;
 32840                                  	;clc				;AN000; indicate extra delim
 32841                                  	;retn				;AN000;
 32842                                  
 32843                                  ;***********************************************************************
 32844                                  ; $P_Chk_EOL;
 32845                                  ;
 32846                                  ; Function: Check if AL is one of End of Line characters.
 32847                                  ;
 32848                                  ; Input:    AL = character code
 32849                                  ;	    ES:DI -> Parameter List
 32850                                  ;
 32851                                  ; Output:   ZF = 1 if one of End of Line characters
 32852                                  ;***********************************************************************
 32853                                  
 32854                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32855                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32856                                  $P_Chk_EOL:
 32857 000053ED 53                      	push	bx			;AN000;
 32858 000053EE 51                      	push	cx			;AN000;
 32859 000053EF 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
 32860 000053F1 7429                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32861 000053F3 3C00                    	cmp	al,$P_NULL ; 0		;AN000; zero ?
 32862 000053F5 7425                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32863 000053F7 26807D0202              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
 32864                                  	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
 32865 000053FC 721E                    	jb	short $P_Chk_EOL_Exit 	;AN000;
 32866 000053FE 31DB                    	xor	bx,bx			;AN000;
 32867 00005400 268A5D03                	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 32868                                  	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
 32869 00005404 83C304                  	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
 32870 00005407 26803900                	cmp	byte [es:bx+di],$P_I_Use_Default
 32871                                  	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
 32872 0000540B 740D                    	je	short $P_Chk_EOL_NZ	;AN000;
 32873 0000540D 31C9                    	xor	cx,cx			;AN000; Get number of extra chcracter
 32874 0000540F 268A09                  	mov	cl,[es:bx+di]		;AN000;
 32875                                  $P_Chk_EOL_Loop:			;AN000;
 32876 00005412 43                      	inc	bx			;AN000;
 32877 00005413 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 32878 00005416 7404                    	je	short $P_Chk_EOL_Exit 	;AN000;
 32879 00005418 E2F8                    	loop	$P_Chk_EOL_Loop 	;AN000;
 32880                                  $P_Chk_EOL_NZ:				;AN000;
 32881 0000541A 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
 32882                                  $P_Chk_EOL_Exit:			;AN000;
 32883 0000541C 59                      	pop	cx			;AN000;
 32884 0000541D 5B                      	pop	bx			;AN000;
 32885 0000541E C3                      	retn				;AN000;
 32886                                  
 32887                                  ;***********************************************************************
 32888                                  ; $P_Chk_Delim;
 32889                                  ;
 32890                                  ; Function: Check if AL is one of delimiter characters.
 32891                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 32892                                  ;	    blanks.
 32893                                  ;
 32894                                  ; Input:    AL = character code
 32895                                  ;	    DS:SI -> Next Character
 32896                                  ;	    ES:DI -> Parameter List
 32897                                  ;
 32898                                  ; Output:   ZF = 1 if one of delimiter characters
 32899                                  ;	    SI points to the next character
 32900                                  ; Vars:  $P_Terminator(W), $P_Flags(W)
 32901                                  ;***********************************************************************
 32902                                  
 32903                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32904                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32905                                  	; 12/08/2024
 32906                                  $P_Chk_Delim:
 32907 0000541F 53                      	push	bx			;AN000;
 32908 00005420 51                      	push	cx			;AN000;
 32909 00005421 2EC606[4999]20          	mov	byte [cs:$P_Terminator],$P_Space ; 20h
 32910                                  					;AC034; Assume terminated by space
 32911 00005427 2E8026[4F99]DF          	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
 32912                                  					;AC034;
 32913 0000542D 3C20                    	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
 32914 0000542F 7434                    	je	short $P_Chk_Delim_Exit	;AN000;
 32915                                  
 32916 00005431 3C09                    	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
 32917 00005433 7430                    	je	short $P_Chk_Delim_Exit	;AN000;
 32918                                  
 32919 00005435 3C2C                    	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
 32920 00005437 742F                    	je	short $P_Chk_Delim_Exit0
 32921                                  					;AN000;
 32922                                  $P_Chk_Delim00: 			;AN000;
 32923 00005439 3C20                    	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
 32924 0000543B 750C                    	jne	short $P_Chk_Delim01	;AN000;
 32925 0000543D 803C20                  	cmp	byte [si],20h ; $P_DBSP2
 32926                                  					;AN000; 2nd byte of DBCS Space ?
 32927 00005440 7507                    	jne	short $P_Chk_Delim01	;AN000;
 32928 00005442 B020                    	mov	al,$P_Space ; 20h	;AN000;
 32929 00005444 46                      	inc	si			;AN000; make si point to next character
 32930 00005445 38C0                    	cmp	al,al			;AN000; Set ZF
 32931 00005447 EB1C                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32932                                  
 32933                                  $P_Chk_Delim01: 			;AN000;
 32934                                  	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
 32935 00005449 26807D0201              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
 32936                                  	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
 32937 0000544E 7215                    	jb	short $P_Chk_Delim_Exit	;AN000;
 32938                                  
 32939 00005450 31C9                    	xor	cx,cx			;AN000;
 32940 00005452 268A4D03                	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 32941                                  	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
 32942                                  	;or	cx,cx			;AN000; No extra Delim character ?
 32943                                  	;jz	short $P_Chk_Delim_NZ	;AN000;
 32944                                  	; 12/08/2024 - PCDOS 7.1 COMMAND.COM
 32945 00005456 E30B                    	jcxz	$P_Chk_Delim_NZ
 32946                                  
 32947 00005458 BB0300                  	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 32948                                  $P_Chk_Delim_Loop:			;AN000;
 32949 0000545B 43                      	inc	bx			;AN000;
 32950 0000545C 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 32951 0000545F 7407                    	je	short $P_Chk_Delim_Exit0
 32952                                  					;AN000;
 32953 00005461 E2F8                    	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 32954                                  
 32955                                  $P_Chk_Delim_NZ:			;AN000;
 32956 00005463 3C20                    	cmp	al,$P_Space ; 20h	;AN000; reset ZF
 32957                                  $P_Chk_Delim_Exit:			;AN000;
 32958 00005465 59                      	pop	cx			;AN000;
 32959 00005466 5B                      	pop	bx			;AN000;
 32960 00005467 C3                      	retn				;AN000;
 32961                                  
 32962                                  $P_Chk_Delim_Exit0:			;AN000;
 32963 00005468 2EA2[4999]              	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
 32964 0000546C 2EF606[4F99]01          	test	byte [cs:$P_Flags2],$P_equ
 32965                                  	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
 32966 00005472 7506                    	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 32967                                  
 32968 00005474 2E800E[4F99]20          	or	byte [cs:$P_Flags2],$P_Extra ; 20h
 32969                                  	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
 32970                                  $P_No_Set_Extra:			;AN027;
 32971 0000547A 38C0                    	cmp	al,al			;AN000; set ZF
 32972 0000547C EBE7                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 32973                                  
 32974                                  ;***********************************************************************
 32975                                  ; $P_Chk_Switch;
 32976                                  ;
 32977                                  ; Function: Check if AL is the switch character not in first position of
 32978                                  ;	    $P_STRING_BUF
 32979                                  ;
 32980                                  ; Input:    AL = character code
 32981                                  ;	    BX = current pointer within $P_String_Buf
 32982                                  ;	    SI =>next char on command line (following the one in AL)
 32983                                  ;
 32984                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 32985                                  ;		 position, and has no chance of being part of a date string,
 32986                                  ;		 i.e. should be treated as a delimiter.
 32987                                  ;
 32988                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 32989                                  ;		 position, or is a slash but may be part of a date string, i.e.
 32990                                  ;		 should not be treated as a delimiter.
 32991                                  ;
 32992                                  ; Vars:  $P_Terminator(W)
 32993                                  ;
 32994                                  ; Use:	 $P_0099
 32995                                  ;***********************************************************************
 32996                                  
 32997                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32998                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 32999                                  $P_Chk_Switch:
 33000                                  	; 18/04/2023
 33001 0000547E 8D2E[5899]              	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
 33002                                  
 33003 00005482 39EB                    	cmp	bx,bp			;AN000;
 33004 00005484 7418                    	je	short $P_STRUC_L2	;AN000;
 33005                                  
 33006 00005486 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 33007 00005488 7512                    	jne	short $P_STRUC_L5	;AN000;
 33008                                  
 33009 0000548A F9                      	stc				;AN020;not in first position and is slash, now see if might be in date string
 33010 0000548B 50                      	push	ax			;AN020;save input char
 33011 0000548C 2E8A47FF                	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
 33012 00005490 E801FB                  	call	$P_0099 		;AN020;return carry set if not numeric
 33013 00005493 7205                    	jc	short $P_STRUC_L7	;AN000;
 33014                                  
 33015 00005495 8A04                    	mov	al,[si]			;AN020;AL=char after the current char
 33016 00005497 E8FAFA                  	call	$P_0099			;AN020;return carry set if not numeric
 33017                                  $P_STRUC_L7:				;AN000;
 33018 0000549A 58                      	pop	ax			;AN020;restore AL to input char
 33019                                  	;jmp	short $P_STRUC_L1	;AN000;
 33020                                  	; 18/04/2023
 33021 0000549B C3                      	retn
 33022                                  
 33023                                  $P_STRUC_L5:				;AN000;
 33024 0000549C F8                      	clc				;AN020;not a slash
 33025                                  	;jmp	short $P_STRUC_L1	;AN000;
 33026                                  	 ;18/04/2023
 33027 0000549D C3                      	retn
 33028                                  
 33029                                  $P_STRUC_L2:				;AN000;
 33030 0000549E 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 33031                                  	;jne	short $P_STRUC_L12	;AN000;
 33032                                  	; 18/04/2023
 33033 000054A0 75FA                    	jne	short $P_STRUC_L5
 33034                                  
 33035 000054A2 2E800E[4F99]40          	or	byte [cs:$P_Flags2],$P_SW
 33036                                  	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
 33037                                  	; 18/04/2023
 33038                                  ;$P_STRUC_L12:				;AN000;
 33039                                  	;clc				;AN020;CF=0 indicating first char
 33040                                  $P_STRUC_L1:				;AN000;
 33041 000054A8 C3                      	retn				;AN000;
 33042                                  
 33043                                  ;**************************************************************************
 33044                                  ; $P_Chk_DBCS:
 33045                                  ;
 33046                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 33047                                  ;
 33048                                  ;  Input:
 33049                                  ;	  AL	= Code to be examineed
 33050                                  ;
 33051                                  ;  Output:
 33052                                  ;	  If CF is on then a lead byte of DBCS
 33053                                  ;
 33054                                  ; Use: INT 21h w/AH=63
 33055                                  ;
 33056                                  ; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
 33057                                  ;***************************************************************************
 33058                                  
 33059                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33060                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 33061                                  	; 12/08/2024
 33062                                  $P_Chk_DBCS:
 33063 000054A9 1E                      	push	ds			;AN000;
 33064 000054AA 56                      	push	si			;AN000;
 33065 000054AB 53                      	push	bx			;AN000; (tm11)
 33066 000054AC 2E833E[4C99]00          	cmp	word [cs:$P_DBCSEV_SEG],0
 33067                                  					;AC034; ALREADY SET ?
 33068 000054B2 7527                    	jne	short $P_DBCS00		;AN000;
 33069 000054B4 50                      	push	ax			;AN000;
 33070 000054B5 1E                      	push	ds			;AN000; (tm11)
 33071 000054B6 51                      	push	cx			;AN000;
 33072 000054B7 52                      	push	dx			;AN000;
 33073 000054B8 57                      	push	di			;AN000;
 33074 000054B9 55                      	push	bp			;AN000;
 33075 000054BA 06                      	push	es			;AN000;
 33076 000054BB 31F6                    	xor	si,si			;AN000;
 33077 000054BD 8EDE                    	mov	ds,si			;AN000;
 33078                                  	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
 33079 000054BF B80063                  	mov	ax,6300h
 33080 000054C2 CD21                    	int	21h			;AN000;
 33081 000054C4 8CDB                    	mov	bx,ds			;AN000; (tm11)
 33082 000054C6 09DB                    	or	bx,bx			;AN000; (tm11)
 33083 000054C8 07                      	pop	es			;AN000;
 33084 000054C9 5D                      	pop	bp			;AN000;
 33085 000054CA 5F                      	pop	di			;AN000;
 33086 000054CB 5A                      	pop	dx			;AN000;
 33087 000054CC 59                      	pop	cx			;AN000;
 33088 000054CD 1F                      	pop	ds			;AN000; (tm11)
 33089 000054CE 58                      	pop	ax			;AN000;
 33090 000054CF 7424                    	jz	short $P_NON_DBCS	;AN000;
 33091                                  $P_DBCS02:				;AN000;
 33092 000054D1 2E8936[4A99]            	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
 33093 000054D6 2E891E[4C99]            	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 33094                                  $P_DBCS00:				;AN000;
 33095                                  	;mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
 33096                                  	;mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
 33097                                  	; 12/08/2024 - PCDOS 7.1 COMMAND.COM
 33098 000054DB 2EC536[4A99]            	lds	si,[cs:$P_DBCSEV_OFF]
 33099                                  $P_DBCS_LOOP:				;AN000;
 33100 000054E0 833C00                  	cmp	word [si],0 		;AN000; zero vector ?
 33101 000054E3 7410                    	je	short $P_NON_DBCS	;AN000; then exit
 33102 000054E5 3A04                    	cmp	al,[si] 		;AN000;
 33103 000054E7 7208                    	jb	short $P_DBCS01		;AN000; Check if AL is in
 33104 000054E9 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 33105 000054EC 7703                    	ja	short $P_DBCS01		;AN000;      the vector
 33106 000054EE F9                      	stc				;AN000; if yes, indicate DBCS and exit
 33107 000054EF EB04                    	jmp	short $P_DBCS_EXIT	;AN000;
 33108                                  $P_DBCS01:				;AN000;
 33109 000054F1 46                      	inc	si			;AC035; add '2' to
 33110 000054F2 46                      	inc	si			;AC035;  SI reg
 33111                                  					;AN000; get next vector
 33112 000054F3 EBEB                    	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found
 33113                                  
 33114                                  $P_NON_DBCS:				;AN000;
 33115                                  	; 18/04/2023
 33116                                  	; cf=0
 33117                                  	;clc				;AN000; indicate SBCS
 33118                                  $P_DBCS_EXIT:				;AN000;
 33119 000054F5 5B                      	pop	bx			;AN000; (tm11)
 33120 000054F6 5E                      	pop	si			;AN000;
 33121 000054F7 1F                      	pop	ds			;AN000;
 33122 000054F8 C3                      	retn				;AN000;
 33123                                  
 33124                                  ;============================================================================
 33125                                  ; TPARSE.ASM, MSDOS 6.0, 1991
 33126                                  ;============================================================================
 33127                                  ; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33128                                  
 33129                                  ; ****************************************************************
 33130                                  ; *
 33131                                  ; * ROUTINE:	 CMD_PARSE
 33132                                  ; *
 33133                                  ; * FUNCTION:	 Interface for transient COMMAND to invoke
 33134                                  ; *		 SYSPARSE.
 33135                                  ; *
 33136                                  ; * INPUT:	 inputs to SYSPARSE
 33137                                  ; *
 33138                                  ; * OUTPUT:	 outputs from SYSPARSE
 33139                                  ; *
 33140                                  ; ****************************************************************
 33141                                  
 33142                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33143                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
 33144                                  	; 14/06/2023 - Retro DOS v4.2 COMMAND.COM
 33145                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:57BBh
 33146                                  ;cmd_parse:
 33147                                  	;call	sysparse		;AN000;
 33148                                  	;retn				;AN000;
 33149                                  	; 06/04/2023
 33150                                  	;jmp	sysparse
 33151                                  
 33152                                  append_parse:
 33153 000054F9 E85DF5                  	call	sysparse		;AN010;
 33154 000054FC CB                      	retf				;AN010;
 33155                                  
 33156                                  ;============================================================================
 33157                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 33158                                  ;============================================================================
 33159                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33160                                  ; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33161                                  
 33162                                  ; ----------------------------
 33163                                  ; MSDOS 6.0, MSGSERV.ASM, 1991
 33164                                  ; ----------------------------
 33165                                  
 33166                                  ;; Replacable parameters are described by a sublist structure
 33167                                  
 33168                                  struc $M_SUBLIST_STRUC		;;AN000;;
 33169 00000000 ??                       .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 33170 00000001 ??                       .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 33171 00000002 ????????                 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 33172 00000006 ??                       .$M_S_ID:	resb 1		;;AN000;; n of %n
 33173 00000007 ??                       .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 33174 00000008 ??                       .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 33175 00000009 ??                       .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 33176 0000000A ??                       .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 33177                                  endstruc
 33178                                  
 33179                                  ; ---------------------------------------------------------------------------
 33180                                  ; ---------------------------------------------------------------------------
 33181                                  
 33182                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33183                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh
 33184                                  
 33185                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33186                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 57C3h
 33187                                  
 33188                                  Printf_Init:
 33189 000054FD E80F00                  	call	std_printf
 33190 00005500 CB                      	retf
 33191                                  
 33192                                  Printf_Crlf:
 33193 00005501 E80B00                  	call	std_printf
 33194                                  	;call	CRLF2
 33195                                  	;retn
 33196                                  	; 07/04/2023
 33197 00005504 E91AD6                  	jmp	CRLF2
 33198                                  
 33199                                  ;****************************************************************
 33200                                  ;*
 33201                                  ;* ROUTINE:	STD_PRINTF/STD_EPRINTF
 33202                                  ;*
 33203                                  ;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
 33204                                  ;*		Set up substitutions if utility message.  Make
 33205                                  ;*		sure any changes to message variables in TDATA
 33206                                  ;*		are reset to avoid reloading the transient.
 33207                                  ;*
 33208                                  ;* INPUT:	Msg_Disp_Class	-  set to message class
 33209                                  ;*		Msg_Cont_Flag	-  set to control flags
 33210                                  ;*		DS	points to transient segment
 33211                                  ;*
 33212                                  ;*		if utility message:
 33213                                  ;*		DX	points to a block with message number
 33214                                  ;*			(word), number of substitutions (byte),
 33215                                  ;*			followed by substitution list if there
 33216                                  ;*			are substitutions.  If substitutions
 33217                                  ;*			are not in transient segment they must
 33218                                  ;*			be set.
 33219                                  ;*		else
 33220                                  ;*		AX	set to message number
 33221                                  ;*
 33222                                  ;* OUTPUT:	none
 33223                                  ;*
 33224                                  ;****************************************************************
 33225                                  
 33226                                  std_eprintf:
 33227 00005507 C706[1F9B]0200          	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
 33228 0000550D EB06                    	jmp	short new_printf		;AC000;
 33229                                  
 33230                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33231                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h
 33232                                  
 33233                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33234                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 57D6h
 33235                                  	; 12/08/2024
 33236                                  std_printf:
 33237 0000550F C706[1F9B]0100          	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT
 33238                                  
 33239                                  new_printf:
 33240 00005515 50                      	push	ax				;AN000;save registers
 33241 00005516 53                      	push	bx				;AN000;
 33242 00005517 51                      	push	cx				;AN000;
 33243 00005518 06                      	push	es				;AN000;get local ES
 33244 00005519 1E                      	push	ds				;AN000;
 33245 0000551A 07                      	pop	es				;AN000;
 33246 0000551B 57                      	push	di				;AN000;
 33247 0000551C 56                      	push	si				;AN000;
 33248 0000551D 52                      	push	dx				;AN000;
 33249                                  
 33250                                  	; 07/04/2023
 33251                                  	;mov	word [print_err_flag],0		;AN000;
 33252 0000551E 31C9                    	xor	cx,cx
 33253 00005520 890E[28A2]              	mov	[print_err_flag],cx ; 0
 33254                                  
 33255 00005524 89D6                    	mov	si,dx				;AN000;Get offset of message number
 33256 00005526 AD                      	lodsw					;AN000;load message number
 33257                                  	; 15/06/2023
 33258                                  	;push	ax				;AN000;save it
 33259                                  	;lodsb					;AN000;get number of substitutions
 33260                                  	;mov	cl,al				;AN000;set up CX as # of subst
 33261                                  	;; 07/04/2023
 33262                                  	;;xor	ch,ch				;AN000;SI now points to subst list
 33263                                  	;pop	ax				;AN000;get message number back
 33264                                  	; 15/06/2023
 33265 00005527 8A0C                    	mov	cl,[si]
 33266 00005529 46                      	inc	si
 33267                                  
 33268                                  	;cmp	cx,0				;AN000;Any substitutions?
 33269                                  	; 07/04/2023
 33270                                  	;and	cx,cx
 33271                                  	;jz	short ready_to_print		;AN000;No - continue
 33272                                  	; 12/08/2024
 33273 0000552A E35C                    	jcxz	ready_to_print
 33274                                  
 33275 0000552C BF[2AA2]                	mov	di,subst_buffer			;AN061; Get address of message subst buffer
 33276 0000552F 57                      	push	di				;AN061; save it
 33277 00005530 51                      	push	cx				;AN061; save number of subst
 33278                                  
 33279                                  move_subst:
 33280 00005531 51                      	push	cx				;AN061;save number of subst
 33281 00005532 89F3                    	mov	bx,si				;AN061;save start of sublist
 33282                                  	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
 33283                                  	; 07/04/2023
 33284 00005534 B10B                    	mov	cl,parm_block_size ; 11
 33285 00005536 F3A4                    	rep	movsb				;AN061;move sublist
 33286                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 33287 00005538 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 33288                                  	;test	byte [bx+7],4			;AN061;are we doing date/time?
 33289 0000553C 7406                    	jz	short move_subst_cont 		;AN061;no - no need to reset
 33290                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
 33291                                  	;mov	word [bx+2],0			;AN061;reset original date or time to 0
 33292 0000553E 894F02                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
 33293                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 33294                                  	;mov	word [bx+4],0			;AN061;
 33295 00005541 894F04                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0
 33296                                  
 33297                                  move_subst_cont:				;AN061;
 33298 00005544 59                      	pop	cx				;AN061;get number of subst back
 33299 00005545 E2EA                    	loop	move_subst			;AN061;move cx sublists
 33300                                  
 33301 00005547 59                      	pop	cx				;AN061;get number of subst
 33302 00005548 50                      	push	ax				;AN061;save message number
 33303 00005549 803E[CE91]FF            	cmp	byte [msg_disp_class],util_msg_class
 33304                                  	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
 33305 0000554E 740C                    	je	short check_fix			;AN061;YES - go see if substitutions
 33306                                  	;mov	byte [msg_flag],1 ; ext_msg_class
 33307 00005550 C606[24A2]01            	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
 33308 00005555 BF[D091]                	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
 33309 00005558 31C0                    	xor	ax,ax				;AN061;clear ax register
 33310 0000555A AB                      	stosw					;AN061;clear out message number
 33311 0000555B AA                      	stosb					;AN061;clear out subst count
 33312                                  
 33313                                  check_fix:					;AN061;
 33314 0000555C 58                      	pop	ax				;AN061;get message number back
 33315 0000555D 5F                      	pop	di				;AN061;get start of sublists
 33316 0000555E 89FE                    	mov	si,di				;AN061;get into SI for msgserv
 33317 00005560 89F3                    	mov	bx,si				;AN061;get into BX for addressing
 33318 00005562 51                      	push	cx				;AN061;save number of subst
 33319                                  
 33320                                  set_subst:					;AN061;store the segment of the subst
 33321 00005563 837F0400                	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 33322                                  	;cmp	word [bx+4],0			;AN061;was it set already?
 33323 00005567 7509                    	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
 33324 00005569 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 33325                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 33326                                  	;test	byte [bx+7],4			;AN061;don't replace if date or time
 33327 0000556D 7503                    	jnz	short subst_seg_set		;AN061;yes - skip it
 33328 0000556F 8C4F04                  	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
 33329                                  	;mov	word [bx+4],cs			;AN061;set segment value
 33330                                  
 33331                                  subst_seg_set:					;AN061;
 33332 00005572 83C30B                  	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
 33333 00005575 E2EC                    	loop	set_subst			;AN061;loop CX times
 33334 00005577 59                      	pop	cx				;AN061;get number of subst back
 33335                                  
 33336 00005578 89F3                    	mov	bx,si				;AN061;get start of sublist to BX
 33337 0000557A 817F02[91A0]            	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
 33338                                  	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
 33339 0000557F 7507                    	jne	short ready_to_print		;AN061;no - we already have address
 33340                                  	; 01/05/2023
 33341 00005581 8B16[91A0]              	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
 33342 00005585 895702                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
 33343                                  						;AN061;put it into the subst block
 33344                                  	;mov	[bx+2],dx
 33345                                  
 33346                                  ready_to_print:
 33347 00005588 8B1E[1F9B]              	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
 33348 0000558C 8A16[CF91]              	mov	dl,[msg_cont_flag]		;AN000;set up control flag
 33349 00005590 8A36[CE91]              	mov	dh,[msg_disp_class]		;AN000;set up display class
 33350 00005594 C606[CF91]00            	mov	byte [msg_cont_flag],0 ; no_cont_flag
 33351                                  						;AN061;reset flags to avoid
 33352 00005599 C606[CE91]FF            	mov	byte [msg_disp_class],util_msg_class
 33353                                  	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload
 33354                                  
 33355 0000559E 1E                      	push	ds				;AN026;
 33356 0000559F 06                      	push	es				;AN026;
 33357                                  
 33358 000055A0 E83702                  	call	SYSDISPMSG			;AN000;call Rod
 33359                                  
 33360 000055A3 07                      	pop	es				;AN026; restore registers
 33361 000055A4 1F                      	pop	ds				;AN026;
 33362                                  
 33363 000055A5 7303                    	jnc	short print_success		;AN000; everything went okay
 33364 000055A7 A3[28A2]                	mov	[print_err_flag],ax		;AN000;
 33365                                  
 33366                                  print_success:
 33367 000055AA 5A                      	pop	dx				;AN061;restore dx
 33368 000055AB 5E                      	pop	si				;AN000;restore registers
 33369 000055AC 5F                      	pop	di				;AN000;
 33370 000055AD 07                      	pop	es				;AN000;restore registers
 33371 000055AE 59                      	pop	cx				;AN000;
 33372 000055AF 5B                      	pop	bx				;AN000;
 33373 000055B0 58                      	pop	ax				;AN000;
 33374 000055B1 833E[28A2]00            	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
 33375 000055B6 7501                    	jnz	short print_err			;AN000;
 33376                                  
 33377 000055B8 C3                      	retn					;AC000;
 33378                                  
 33379                                  print_err:
 33380 000055B9 0E                      	push	cs
 33381 000055BA 07                      	pop	es
 33382 000055BB 833E[1F9B]02            	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
 33383 000055C0 7503                    	jne	short not_stderr		;AN026;no - continue
 33384 000055C2 E93FAB                  	jmp	TCOMMAND			;AN026;Yes - hopless - just exit
 33385                                  
 33386                                  not_stderr:
 33387 000055C5 A1[28A2]                	mov	ax,[print_err_flag]		;AN026;get extended error number back
 33388 000055C8 8E06[F39D]              	mov	es,[RESSEG]			; No, set up for error, load the
 33389                                  						;  right error msg, and jmp to cerror.
 33390 000055CC 26F606[B502]FF          	test	byte [es:PipeFlag],-1 ; 0FFh
 33391 000055D2 7408                    	jz	short _go_to_error
 33392 000055D4 E8E1DE                  	call	PipeOff
 33393 000055D7 BA[3193]                	mov	dx,PIPEEMES_PTR
 33394 000055DA EB0B                    	jmp	short print_err_exit		;AC000;
 33395                                  
 33396                                  _go_to_error:
 33397 000055DC C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class
 33398                                  	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
 33399 000055E1 BA[D091]                	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
 33400 000055E4 A3[D091]                	mov	[extend_buf_ptr],ax		;AN000; get message number in control block
 33401                                  
 33402                                  print_err_exit: 				;AC000;
 33403 000055E7 0E                      	push	cs
 33404 000055E8 07                      	pop	es
 33405 000055E9 E9B6D8                  	jmp	cerror
 33406                                  
 33407                                  ;****************************************************************
 33408                                  ;*
 33409                                  ;* ROUTINE:	TSYSLOADMSG
 33410                                  ;*
 33411                                  ;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
 33412                                  ;*		names since these routines are also used in the
 33413                                  ;*		resident.
 33414                                  ;*
 33415                                  ;* INPUT:	Inputs to SYSLOADMSG
 33416                                  ;*
 33417                                  ;* OUTPUT:	Outputs from SYSLOADMSG
 33418                                  ;*
 33419                                  ;****************************************************************
 33420                                  
 33421                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33422                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33423                                  TSYSLOADMSG:
 33424 000055EC 53                      	push	bx				;AN000;
 33425 000055ED E80800                  	call	SYSLOADMSG			;AN000; call routine
 33426 000055F0 5B                      	pop	bx				;AN000;
 33427 000055F1 C3                      	retn					;AN000; exit
 33428                                  
 33429                                  ;****************************************************************
 33430                                  ;*
 33431                                  ;* ROUTINE:	TSYSGETMSG
 33432                                  ;*
 33433                                  ;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
 33434                                  ;*		names since these routines are also used in the
 33435                                  ;*		resident.
 33436                                  ;*
 33437                                  ;* INPUT:	Inputs to SYSGETMSG
 33438                                  ;*
 33439                                  ;* OUTPUT:	Outputs from SYSGETMSG
 33440                                  ;*
 33441                                  ;****************************************************************
 33442                                  
 33443                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33444                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33445                                  TSYSGETMSG:
 33446 000055F2 51                      	push	cx				;AN000;
 33447 000055F3 E8B500                  	call	SYSGETMSG			;AN000; call routine
 33448 000055F6 59                      	pop	cx				;AN000;
 33449 000055F7 C3                      	retn					;AN000; exit
 33450                                  
 33451                                  ;============================================================================
 33452                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 33453                                  ;============================================================================
 33454                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33455                                  ; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33456                                  
 33457                                  ; ---------------------------------------------------------------------------
 33458                                  ; MODULE NAME: MSGSERV.SAL
 33459                                  ;
 33460                                  ; DESCRIPTIVE NAME: Message Services SALUT file
 33461                                  ;
 33462                                  ; FUNCTION: This module incorporates all the messages services and
 33463                                  ;	    is called upon at build time to INCLUDE the code requested
 33464                                  ;	    by a utility. Code is requested using the macro MSG_SERVICES.
 33465                                  ;
 33466                                  ; ENTRY POINT: Since this a collection of subroutines, entry point is at
 33467                                  ;	    requested procedure.
 33468                                  ;
 33469                                  ; INPUT: Since this a collection of subroutines, input is dependent on
 33470                                  ;	    function requested.
 33471                                  ;
 33472                                  ; EXIT-NORMAL: In all cases, CARRY FLAG = 0
 33473                                  ;
 33474                                  ; EXIT-ERROR: In all cases, CARRY FLAG = 1
 33475                                  ;
 33476                                  ; INTERNAL REFERENCES: (list of included subroutines)
 33477                                  ;
 33478                                  ;	- SYSLOADMSG
 33479                                  ;	- SYSDISPMSG
 33480                                  ;	- SYSGETMSG
 33481                                  ;
 33482                                  ; EXTERNAL REFERENCES: None
 33483                                  ;
 33484                                  ; NOTES: At build time, some modules must be included. These are only included
 33485                                  ;	 once using assembler switches. Other logic is included at the request
 33486                                  ;	 of the utility.
 33487                                  ;
 33488                                  ;	 COMR and COMT are assembler switches to conditionally assemble code
 33489                                  ;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
 33490                                  ;	 storage and multiple EQUates.
 33491                                  ;
 33492                                  ; REVISION HISTORY: Created MAY 1987
 33493                                  ;
 33494                                  ;     Label: DOS - - Message Retriever
 33495                                  ;	     (c) Copyright 1988 Microsoft
 33496                                  ; ---------------------------------------------------------------------------
 33497                                  
 33498                                  ;	Revision History
 33499                                  ;	================
 33500                                  ;
 33501                                  ;	M007	SR	08/24/90	Fixed bug #1818 -- changed
 33502                                  ;				$M_DISPLAY_H_STRING to properly
 33503                                  ;				handle Ctrl-Z being passed
 33504                                  ;
 33505                                  ;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
 33506                                  ;				these routines are no longer assembled.
 33507                                  ;
 33508                                  ;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
 33509                                  ;				CR-LF string also gets reinitialized
 33510                                  ;				on every cycle.
 33511                                  ;
 33512                                  ;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
 33513                                  ;				& $_MSG_NUM also in SYSLOADMSG.
 33514                                  
 33515                                  ; ---------------------------------------------------------------------------
 33516                                  
 33517                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33518                                  
 33519                                  ;;; Replacable parameters are described by a sublist structure
 33520                                  ;
 33521                                  ;struc $M_SUBLIST_STRUC		;;AN000;;
 33522                                  ; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 33523                                  ; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 33524                                  ; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 33525                                  ; .$M_S_ID:	resb 1		;;AN000;; n of %n
 33526                                  ; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 33527                                  ; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 33528                                  ; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 33529                                  ; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 33530                                  ;endstruc
 33531                                  
 33532                                  ;; Each class will be defined by this structure.
 33533                                  
 33534                                  struc $M_CLASS_ID		;;AN000;;
 33535 00000000 ??                       .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 33536 00000001 ????                     .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 33537 00000003 ??                       .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 33538                                   .size:
 33539                                  endstruc
 33540                                  
 33541                                  $M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;
 33542                                  
 33543                                  ;; Each message will be defined by this structure.
 33544                                  
 33545                                  struc $M_ID			;;AN000;;
 33546 00000000 ????                     .$M_NUM:	resw 1		;;AN000;; Message Number
 33547 00000002 ????                     .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 33548                                   .size:	
 33549                                  endstruc
 33550                                  
 33551                                  $M_ID_SZ	EQU  $M_ID.size	;;AN000;;
 33552                                  
 33553                                  ; ---------------------------
 33554                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33555                                  ; ---------------------------
 33556                                  $M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;
 33557                                  
 33558                                  ; --------------------------- 
 33559                                  
 33560                                  ; 07/04/2023
 33561                                  $M_NUM_CLS equ 3
 33562                                  
 33563                                  ;; Resident data area definition of variables
 33564                                  
 33565                                  struc $M_RES_ADDRS			;;AN000;;
 33566 00000000 ????????                 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 33567 00000004 ????????                 .$M_EXT_FILE:	    resd 1		;;AN001;;
 33568 00000008 ????????                 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 33569 0000000C ????????                 .$M_EXT_TERM:	    resd 1		;;AN000;;
 33570 00000010 ????????                 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 33571 00000014 ????????                 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 33572 00000018 ????????                 .$M_PARSE_TERM:    resd 1		;;AN000;;
 33573 0000001C ????????                 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 33574 00000020 ????????                 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 33575 00000024 ????????                 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 33576 00000028 ????????                 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 33577 0000002C <res Ch>                 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 33578 00000038 ????????                 .$M_CLS_TERM:	    resd 1		;;AN000;;
 33579 0000003C ????????                 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 33580 00000040 ????                     .$M_HANDLE:	    resw 1 		;;AN000;;
 33581 00000042 ??                       .$M_SIZE:	    resb 1		;;AN000;;
 33582 00000043 ????                     .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 33583 00000045 ??                       .$M_CLASS:	    resb 1		;;AN004;; Saved class
 33584 00000046 ????                     .$M_RETURN_ADDR:   resw 1		;;AN000;;
 33585 00000048 ????                     .$M_MSG_NUM:	    resw 1		;;AN000;;
 33586 0000004A ????                     .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 33587 0000004C <res 40h>                .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 33588 0000008C ??                       .$M_BUF_TERM:	    resb 1		;;AN000;;
 33589                                   .size:
 33590                                  endstruc				;;AN000;;
 33591                                  
 33592                                  $M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;
 33593                                  
 33594                                  ;; Important fields of the Get Country Information call
 33595                                  
 33596                                  struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 33597 00000000 <res 4Ch>                .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
 33598                                  					;;AN000;; Go past first part of struc
 33599 0000004C ????                     .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 33600 0000004E ??????????               .$M_CURR_SEPARA:   resb 5		;;AN000;;
 33601 00000053 ????                     .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 33602 00000055 ????                     .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 33603 00000057 ????                     .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 33604 00000059 ????                     .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 33605 0000005B ??                       .$M_CURR_FORMAT:   resb 1		;;AN000;;
 33606 0000005C ??                       .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 33607 0000005D ??                       .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
 33608                                  endstruc				;;AN000;;
 33609                                  
 33610                                  ; ---------------------------------------------------------------------------
 33611                                  
 33612                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33613                                  ;;
 33614                                  ;;	PROC NAME: SYSLOADMSG
 33615                                  ;;
 33616                                  ;;	FUNCTION:
 33617                                  ;;	INPUTS:
 33618                                  ;;
 33619                                  ;;	OUTPUTS:
 33620                                  ;;
 33621                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33622                                  
 33623                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33624                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h
 33625                                  
 33626                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33627                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:58CBh
 33628                                  
 33629                                  SYSLOADMSG:
 33630 000055F8 50                      	push	ax				;;AN000;
 33631 000055F9 53                      	push	bx				;;AN000;
 33632 000055FA 52                      	push	dx				;;AN000;
 33633 000055FB 06                      	push	es				;;AN000;
 33634 000055FC 57                      	push	di				;;AN000;
 33635 000055FD 31C9                    	xor	cx,cx				;;AN000;  Reset to zero
 33636 000055FF 8EC1                    	mov	es,cx				;;AN000;
 33637 00005601 31FF                    	xor	di,di				;;AN000;
 33638 00005603 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33639 00005606 B200                    	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
 33640 00005608 CD2F                    	int	2Fh				;;AN000;; Private interface
 33641                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33642                                  		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
 33643                                  		; Return: ES:DI -> error table
 33644                                  	
 33645 0000560A 8C06[279A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
 33646                                  	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
 33647 0000560E 893E[259A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
 33648                                  	;mov	[$M_RT+8],di			;;AN000;;
 33649                                  
 33650 00005612 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33651 00005615 B202                    	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
 33652 00005617 CD2F                    	int	2Fh				;;AN000;; Private interface
 33653                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33654                                  		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
 33655                                  		; ES:DI -> error table
 33656                                  
 33657 00005619 8C06[2F9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
 33658                                  	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
 33659 0000561D 893E[2D9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
 33660                                  	;mov	[$M_RT+16],di			;;AN000;;
 33661                                  
 33662 00005621 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 33663 00005624 B204                    	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
 33664 00005626 CD2F                    	int	2Fh				;;AN000;; Private interface
 33665                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33666                                  		; DL = subfunction - get ??? error table
 33667                                  		; ES:DI -> error table
 33668                                  
 33669 00005628 8C06[3F9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
 33670                                  	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
 33671 0000562C 893E[3D9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
 33672                                  	;mov	[$M_RT+32],di			;;AN000;;
 33673                                  
 33674 00005630 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33675 00005633 B206                    	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
 33676 00005635 CD2F                    	int	2Fh					     ;;AN001;; Private interface
 33677                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33678                                  		; DL = subfunction - get ??? error table
 33679                                  		; ES:DI -> error table
 33680                                  
 33681 00005637 8C06[239A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
 33682                                  	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
 33683 0000563B 893E[219A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
 33684                                  	;mov	[$M_RT+4],di			;;AN001;;
 33685                                  
 33686 0000563F E8673B                  	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
 33687                                  						;;AN000;;
 33688 00005642 8C06[1F9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
 33689                                  	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
 33690 00005646 893E[1D9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
 33691                                  	;mov	[$M_RT+0],di			;;AN000;;
 33692 0000564A 8C06[3B9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
 33693                                  	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
 33694 0000564E 893E[399A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
 33695                                  	;mov	[$M_RT+28],di			;;AN000;;
 33696                                  
 33697 00005652 E8723B                  	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)
 33698                                  
 33699 00005655 8C06[339A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
 33700                                  	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
 33701 00005659 893E[319A]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
 33702                                  	;mov	[$M_RT+20],di			;;AN000;;
 33703                                  
 33704 0000565D B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 33705 00005660 B208                    	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
 33706 00005662 CD2F                    	int	2Fh				;;AN001;; Private interface
 33707                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 33708                                  		; DL = subfunction - get ??? error table
 33709                                  		; ES:DI -> error table
 33710                                  
 33711 00005664 8C06[479A]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
 33712                                  	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
 33713 00005668 893E[459A]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
 33714                                  	;mov	[$M_RT+40],di			;;AN001;;
 33715                                  
 33716                                  ;M016; M020
 33717                                  ; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
 33718                                  ;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.
 33719                                  
 33720 0000566C C706[609A]0D0A          	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
 33721                                  	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
 33722 00005672 C606[A99A]24            	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
 33723                                  	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
 33724 00005677 C706[659A]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 33725                                  	;mov	word [$M_RT+72],0		; M020
 33726 0000567D C706[679A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 33727                                  	;mov	word [$M_RT+74],10		; M020
 33728                                  
 33729                                  	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
 33730                                  	; --------------------------
 33731                                  	; MSDOS 6.0 SYSMSG.INC, 1991
 33732                                  	; --------------------------
 33733                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h
 33734                                  
 33735                                  	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
 33736 00005683 E8C03A                  	call    $M_CLS_3			; Get addressibility to class F
 33737 00005686 893E[499A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
 33738                                  	;mov	[$M_RT+44],di
 33739                                  	
 33740 0000568A E80600                  	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector
 33741                                  
 33742                                  	; 15/04/2023
 33743                                  	;clc					;;AN000;; Make sure carry is clear
 33744                                  	;jc	short $MIF20
 33745                                  	
 33746 0000568D 5F                      	pop	di				;;AN000;; Restore REGS
 33747 0000568E 07                      	pop	es				;;AN000;;
 33748 0000568F 5A                      	pop	dx				;;AN000;;
 33749 00005690 5B                      	pop	bx				;;AN000;;
 33750 00005691 58                      	pop	ax				;;AN000;;
 33751                                  	;jmp	short $MEN20
 33752                                  	; 15/04/2023
 33753 00005692 C3                      	retn
 33754                                  
 33755                                  	; 15/04/2023
 33756                                  ;$MIF20:
 33757                                  	;add	sp,10				;;AN000;;
 33758                                  	;stc					;;AN000;; Reset carry flag
 33759                                  ;$MEN20:
 33760                                  	;retn					;;AN000;;
 33761                                  
 33762                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33763                                  ;;
 33764                                  ;;  Proc Name:	$M_GET_DBCS_VEC
 33765                                  ;;
 33766                                  ;;  Function:	Get the DBCS vector and save it for later use
 33767                                  ;;
 33768                                  ;;  Inputs:	None
 33769                                  ;;
 33770                                  ;;  Outputs:	None
 33771                                  ;;
 33772                                  ;;  Regs Changed:
 33773                                  ;;
 33774                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33775                                  
 33776                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33777                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33778                                  $M_GET_DBCS_VEC:
 33779 00005693 50                      	push	ax				;;AN000;; Save character to check
 33780 00005694 56                      	push	si				;;AN000;;
 33781 00005695 1E                      	push	ds				;;AN000;;
 33782 00005696 B80063                  	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
 33783 00005699 CD21                    	int	21h				;;AN000;; Get environment pointer
 33784 0000569B 1E                      	push	ds				;;AN000;; Get environment pointer
 33785 0000569C 07                      	pop	es				;;AN000;; Get environment pointer
 33786 0000569D 1F                      	pop	ds				;;AN000;; Get environment pointer
 33787 0000569E 7208                    	jc	short $MIF23
 33788                                  	
 33789 000056A0 8936[599A]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
 33790                                  	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
 33791 000056A4 8C06[5B9A]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
 33792                                  	;mov	word [$M_RT+62],es		;;AN000;;
 33793                                  $MIF23:
 33794 000056A8 5E                      	pop	si				;;AN000;;
 33795 000056A9 58                      	pop	ax				;;AN000;; Retrieve character to check
 33796 000056AA C3                      	retn					;;AN000;; Return
 33797                                  
 33798                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33799                                  ;;
 33800                                  ;;  Proc Name:	SYSGETMSG
 33801                                  ;;
 33802                                  ;;  Function:	The GET service returns the segment, offset and size of the
 33803                                  ;;		message text to the caller based on a message number.
 33804                                  ;;		The GET function will not display the message thus assumes
 33805                                  ;;		caller will handle replaceable parameters.
 33806                                  ;;
 33807                                  ;;  Inputs:
 33808                                  ;;
 33809                                  ;;  Outputs:
 33810                                  ;;
 33811                                  ;;  Psuedocode:
 33812                                  ;;		Call $M_GET_MSG_ADDRESS
 33813                                  ;;		IF MSG_NUM exists THEN
 33814                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
 33815                                  ;;		   CARRY_FLAG = 0
 33816                                  ;;		ELSE
 33817                                  ;;		   CARRY_FLAG = 1
 33818                                  ;;		ENDIF
 33819                                  ;;
 33820                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33821                                  
 33822                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33823                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33824                                  
 33825                                  	utility_msg_class equ 0FFh ; 18/04/2023
 33826                                  
 33827                                  SYSGETMSG:
 33828                                  	;; Save registers needed later
 33829 000056AB 50                      	push	ax				;;AN000;; Save changed regs
 33830 000056AC 06                      	push	es				;;AN000;;
 33831 000056AD 57                      	push	di				;;AN000;;
 33832 000056AE 55                      	push	bp				;;AN000;;
 33833                                  
 33834 000056AF E81400                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33835 000056B2 720D                    	jc	short $MIF31
 33836                                  	
 33837 000056B4 80FEFF                  	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
 33838                                  	;clc					;;AN000;;
 33839 000056B7 7404                    	je	short $MIF32			;;AN000;;
 33840                                  	; 15/06/2023
 33841 000056B9 F8                      	clc	
 33842                                  
 33843 000056BA 06                      	push	es				;;AN000;;
 33844                                  	;pop	ds				;;AN000;;
 33845 000056BB EB01                    	jmp	short $MEN32
 33846                                  $MIF32:
 33847 000056BD 0E                      	push	cs				;;AN000;;			
 33848                                  	;pop	ds				;;AN000;;
 33849                                  $MEN32:
 33850                                  	; 07/04/2023
 33851 000056BE 1F                      	pop	ds
 33852 000056BF 89FE                    	mov	si,di				;;AN000;; Return message in DS:SI
 33853                                  $MIF31:
 33854 000056C1 5D                      	pop	bp				;;AN000;; Restore changed regs
 33855 000056C2 5F                      	pop	di				;;AN000;;
 33856 000056C3 07                      	pop	es				;;AN000;;
 33857 000056C4 58                      	pop	ax				;;AN000;;
 33858 000056C5 C3                      	retn					;;AN000;; Return
 33859                                  
 33860                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33861                                  ;;
 33862                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
 33863                                  ;;
 33864                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
 33865                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
 33866                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
 33867                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
 33868                                  ;;	REGS CHANGED: ES,DI,CX
 33869                                  ;;
 33870                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33871                                  
 33872                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33873                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 33874                                  $M_GET_MSG_ADDRESS:
 33875 000056C6 56                      	push	si				;;AN000;;
 33876 000056C7 53                      	push	bx				;;AN000;;
 33877 000056C8 31F6                    	xor	si,si				;;AN000;; Use SI as an index
 33878 000056CA 31C9                    	xor	cx,cx				;;AN000;; Use CX as an size
 33879                                  $MDO36:
 33880 000056CC 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
 33881 000056CF 7508                    	jne	short $MIF37			;;AN000;; No
 33882                                  
 33883                                  	; 07/04/2023
 33884                                  	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33885 000056D1 8BBC[499A]              	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
 33886                                  	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
 33887 000056D5 89FB                    	mov	bx,di				;;AN000;;
 33888 000056D7 EB21                    	jmp	short $MEN37
 33889                                  $MIF37:
 33890 000056D9 F6C602                  	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
 33891 000056DC 7406                    	jz	short $MIF39
 33892                                  	
 33893                                  	; 07/04/2023
 33894                                  	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33895 000056DE C4BC[2D9A]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
 33896                                  	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
 33897                                  
 33898                                  	; 07/04/2023
 33899                                  	;mov	bx,es ; *			;;AN000;;
 33900 000056E2 EB14                    	jmp	short $MEN39
 33901                                  $MIF39:
 33902 000056E4 83F813                  	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
 33903 000056E7 720B                    	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;
 33904                                  
 33905 000056E9 83F827                  	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
 33906 000056EC 7706                    	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;
 33907                                  
 33908                                  	; 07/04/2023
 33909                                  	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33910 000056EE C4BC[399A]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
 33911                                  	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
 33912                                  	
 33913                                  	; 07/04/2023
 33914                                  	;mov	bx,es ; *			;;AN000;;
 33915 000056F2 EB04                    	jmp	short $MEN41
 33916                                  $MIF41:
 33917                                  	; 07/04/2023
 33918                                  	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33919 000056F4 C4BC[1D9A]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
 33920                                  	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
 33921                                  	
 33922                                  	; 07/04/2023
 33923                                  	;mov	bx,es ; *			;;AN000;;
 33924                                  $MEN41:
 33925                                  $MEN39:
 33926                                  	; 07/04/2023
 33927 000056F8 8CC3                    	mov	bx,es ; *
 33928                                  $MEN37:						;;AN000;;
 33929 000056FA 83FBFF                  	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
 33930 000056FD 7515                    	jne	short $MIF46			;;AN000;; No
 33931                                  
 33932 000056FF 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
 33933 00005702 7503                    	jne	short $MIF47			;;AN000;; No
 33934 00005704 F9                      	stc		     ; **-		;;AN000;; Set the carry flag
 33935                                  	; 07/04/2023
 33936                                  	;jmp	short $MEN47 ; **-
 33937 00005705 EB1B                    	jmp	short $MEN36 ; **-
 33938                                  $MIF47:
 33939 00005707 A3[659A]                	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],ax
 33940                                  	;mov	[$M_RT+72],ax			;;AN000;; Save message number
 33941 0000570A B8FFFF                  	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
 33942 0000570D BD0100                  	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
 33943 00005710 31F6                    	xor	si,si				;;AN000;; Reset the SI index to start again
 33944                                  	; 28/04/2023
 33945                                  	; 07/04/2023
 33946                                  	;clc	; **+				;;AN000;;
 33947                                  ;$MEN47:
 33948                                  	;jmp	short $MEN46 ; ***
 33949 00005712 EB0A                    	jmp	short $MEN47 ; ***
 33950                                  $MIF46:
 33951                                  	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
 33952 00005714 21DB                    	and	bx,bx ; 0 ?
 33953 00005716 7403                    	jz	short $MIF51			;;AN000;; No
 33954                                  	
 33955 00005718 E84D00                  	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
 33956                                  $MIF51:
 33957 0000571B 83C604                  	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
 33958                                  	; 07/04/2023
 33959                                  	;clc					;;AN000;;
 33960                                  ;$MEN46:
 33961                                  	;jc	short $MEN36 ; **- ; **+	;;AN000;;
 33962                                  $MEN47:	; 07/04/2023	; **+
 33963 0000571E 09C9                    	or	cx,cx				;;AN000;; Was the message found?
 33964                                  	;jnz	short $MXL2			;;AN000;; Yes
 33965                                  	;jmp	short $MDO36
 33966                                  	; 07/04/2023
 33967 00005720 74AA                    	jz	short $MDO36	
 33968                                  $MXL2:
 33969                                  $MEN36:
 33970 00005722 9C                      	pushf 					;;AN006;; Save the flag state
 33971                                  	
 33972 00005723 80FE01                  	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
 33973                                  	;jne	short $MIF56			;;AN006;; No
 33974                                  	; 28/04/2023
 33975 00005726 752A                    	jne	short $M_MYRET	
 33976                                  
 33977 00005728 52                      	push	dx				;;AN006;; Save all needed registers
 33978 00005729 55                      	push	bp				;;AN006;;
 33979 0000572A 51                      	push	cx				;;AN006;;
 33980 0000572B 06                      	push	es				;;AN006;;
 33981 0000572C 57                      	push	di				;;AN006;;
 33982 0000572D 50                      	push	ax				;;AN006;;
 33983                                  
 33984 0000572E B80005                  	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
 33985 00005731 CD2F                    	int	2Fh				;;AN006;;
 33986                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
 33987                                  		; Return: AL = 00h not installed, OK to install
 33988                                  		; 01h not installed, can't install
 33989                                  		; FFh installed
 33990                                  
 33991 00005733 3CFF                    	cmp	al,0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
 33992 00005735 58                      	pop	ax				;;AN006;; Restore msg number
 33993 00005736 7513                    	jne	short $MIF57			;;AN006;; No (not installed)
 33994                                  
 33995 00005738 89C3                    	mov	bx,ax				;;AN006;; BX is the extended error number
 33996 0000573A B80205                  	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
 33997 0000573D CD2F                    	int	2Fh				;;AN006;; Call IFSFUNC
 33998                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER
 33999                                  
 34000                                  	;jmp	short $MEN57			;;AN006;;
 34001                                  	; 28/04/2023
 34002 0000573F 720B                    	jc	short $MEN57
 34003                                  $MIF60:
 34004 00005741 83C406                  	add	sp,6				;;AN006;; Throw away old pointer
 34005 00005744 E81200                  	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 34006                                  $MEN60:
 34007 00005747 5D                      	pop	bp				;;AN006;; Restore other Regs
 34008 00005748 5A                      	pop	dx				;;AN006;;
 34009                                  $MIF56:
 34010                                  	; 07/04/2023
 34011                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 34012 00005749 EB07                    	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 34013                                  
 34014                                  $MIF57:
 34015 0000574B F9                      	stc					;;AN006;; Carry conditon
 34016                                  $MEN57:
 34017                                  	; 28/04/2023
 34018                                  	;jnc	short $MIF60			;;AN006;;
 34019                                  
 34020 0000574C 5F                      	pop	di				;;AN006;;
 34021 0000574D 07                      	pop	es				;;AN006;; Restore old pointer
 34022 0000574E 59                      	pop	cx				;;AN006;;
 34023 0000574F EBF6                    	jmp	short $MEN60
 34024                                  
 34025                                  ;$MIF60:
 34026                                  ;	add	sp,6				;;AN006;; Throw away old pointer
 34027                                  ;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 34028                                  ;$MEN60:
 34029                                  ;	pop	bp				;;AN006;; Restore other Regs
 34030                                  ;	pop	dx				;;AN006;;
 34031                                  ;$MIF56:
 34032                                  ;	; 07/04/2023
 34033                                  ;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 34034                                  ;	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 34035                                  
 34036                                  ; 07/04/2023
 34037                                  ; ---------------------------
 34038                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 34039                                  ; ---------------------------
 34040                                  	; $M_POPF macro
 34041                                  	;jmp	short $+3
 34042                                  m_popf_iret:
 34043 00005751 CF                      	iret
 34044                                  $M_MYRET:
 34045 00005752 0E                      	push	cs
 34046 00005753 E8FBFF                  	call	m_popf_iret
 34047                                  	;;; end macro	
 34048                                  ; ---------------------------
 34049                                  
 34050 00005756 5B                      	pop	bx				;;AN000;;
 34051 00005757 5E                      	pop	si				;;AN000;;
 34052 00005758 C3                      	retn					;;AN000;; Return ES:DI pointing to the message
 34053                                  
 34054                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34055                                  
 34056                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34057                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34058                                  $M_SET_LEN_IN_CX:			
 34059 00005759 57                      	push	di				;;AN006;; Save position
 34060 0000575A 50                      	push	ax				;;AN006;;
 34061 0000575B B9FFFF                  	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
 34062 0000575E 30C0                    	xor	al,al				;;AN006;; Prepare compare register
 34063 00005760 F2AE                    	repne	scasb				;;AN006;; Scan for zero
 34064 00005762 F7D1                    	not	cx				;;AN006;; Change decrement into number
 34065 00005764 49                      	dec	cx				;;AN006;; Don't include the zero
 34066 00005765 58                      	pop	ax				;;AN006;;
 34067 00005766 5F                      	pop	di				;;AN006;; Restore position
 34068 00005767 C3                      	retn					;;AN006;;
 34069                                  
 34070                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34071                                  ;;
 34072                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
 34073                                  ;;
 34074                                  ;;	FUNCTION:  To scan thru message headers until message is found
 34075                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
 34076                                  ;;		   CX contains the number of messages in class
 34077                                  ;;		   DH contains the message class
 34078                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
 34079                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
 34080                                  ;;
 34081                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34082                                  
 34083                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34084                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34085                                  $M_FIND_SPECIFIED_MSG:
 34086 00005768 83FB01                  	cmp	bx,1				;;AN004;; Do we have an address to CALL?
 34087 0000576B 751F                    	jne	short $MIF64
 34088 0000576D 833E[459A]FF            	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
 34089                                  	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
 34090                                  	; 15/06/2023
 34091 00005772 7418                    	je	short $MIF64
 34092                                  
 34093 00005774 83F8FF                  	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
 34094 00005777 750B                    	jne	short $MIF65
 34095                                  	
 34096 00005779 50                      	push	ax				;;AN004;; Reset the special message number
 34097 0000577A A1[659A]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 34098                                  	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
 34099 0000577D FF1E[459A]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 34100                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 34101 00005781 58                      	pop	ax				;;AN004;; Reset the special message number
 34102                                  	; 28/04/2023
 34103 00005782 EB04                    	jmp	short $MEN65
 34104                                  	; 18/04/2023
 34105                                  	;jmp	short $MEN64
 34106                                  $MIF65:
 34107 00005784 FF1E[459A]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 34108                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 34109                                  $MEN65:
 34110                                  	; 28/04/2023
 34111 00005788 7344                    	jnc	short $MIF75
 34112                                  	;
 34113 0000578A EB19                    	jmp	short $MEN64 ; $MDO76		;;AN004;;
 34114                                  $MIF64:
 34115 0000578C 31C9                    	xor	cx,cx				;;AN002;; CX = 0 will allow us to
 34116 0000578E 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 34117 00005791 7406                    	je	short $MIF69
 34118                                  	
 34119 00005793 268A4D03                	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 34120                                  	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
 34121 00005797 EB09                    	jmp	short $MEN69
 34122                                  $MIF69:
 34123                                  	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
 34124                                  	;cmp	[cs:di+0],dh
 34125 00005799 2E3835                  	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
 34126 0000579C 7504                    	jne	short $MIF71
 34127                                  
 34128 0000579E 2E8A4D03                	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 34129                                  	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
 34130                                  $MIF71:						;;AN001;;
 34131                                  $MEN69:
 34132 000057A2 83C704                  	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
 34133                                  	; 02/05/2023
 34134                                  	;stc					;;AN004;; Flag that we haven't found anything yet
 34135                                  $MEN64:
 34136                                  	;jnc	short $MIF75
 34137                                  	; 28/04/2023
 34138                                  	; (or instruction clears carry flag)
 34139                                  	;clc					;;AN004;; No, reset carry
 34140                                  $MDO76:
 34141 000057A5 09C9                    	or	cx,cx				;;AN000;; Do we have any to check?
 34142 000057A7 7417                    	jz	short $MEN76
 34143                                  
 34144 000057A9 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 34145 000057AC 7405                    	je	short $MIF78
 34146                                  
 34147                                  	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
 34148 000057AE 263B05                  	cmp	ax,[es:di]
 34149 000057B1 EB03                    	jmp	short $MEN78
 34150                                  $MIF78:
 34151                                  	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
 34152 000057B3 2E3B05                  	cmp	ax,[cs:di]
 34153                                  $MEN78:
 34154                                  	;jne	short $MIF76
 34155                                  	;jmp	short $MSR76
 34156                                  	; 07/04/2023
 34157 000057B6 740B                    	je	short $MSR76 ; *
 34158                                  $MIF76:
 34159 000057B8 49                      	dec	cx				;;AN000;; No, well do we have more to check?
 34160 000057B9 7405                    	jz	short $MEN76
 34161                                  
 34162 000057BB 83C704                  	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
 34163 000057BE EBE5                    	jmp	short $MDO76			;;AN000;;
 34164                                  $MEN76:
 34165 000057C0 F9                      	stc					;;AN000;;
 34166                                  ;$MSR76:	; 07/04/2023
 34167                                  	;jc	short $MIF86			;;AN000;;
 34168                                  	; 07/04/2023
 34169                                  	;jc	short $MIF91
 34170 000057C1 EB11                    	jmp	short $MIF91 ;*
 34171                                  $MSR76:	; 07/04/2023 ; *	
 34172 000057C3 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
 34173                                  	; 07/04/2023
 34174                                  	;clc					;;AN001;;
 34175 000057C6 7502                    	jne	short $MIF87
 34176                                  
 34177 000057C8 0E                      	push	cs				;;AN000;;
 34178 000057C9 07                      	pop	es				;;AN000;; Return ES:DI pointing to the message
 34179                                  $MIF87:
 34180                                  	;add	di,[es:di+2]
 34181 000057CA 26037D02                	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
 34182                                  $MIF86:
 34183                                  ;$MIF75:
 34184                                  	; 02/05/2023
 34185                                  	;jc	short $MIF91
 34186                                  $MIF75:	; 28/04/2023
 34187 000057CE 30ED                    	xor	ch,ch				;;AN000;;
 34188 000057D0 268A0D                  	mov	cl,[es:di]			;;AN000;; Move size into CX
 34189 000057D3 47                      	inc	di				;;AN000;; Increment past length
 34190                                  $MIF91:
 34191 000057D4 C606[5F9A]00            	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
 34192                                  	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
 34193 000057D9 C3                      	retn					;;AN000;; Return
 34194                                  
 34195                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34196                                  ;;
 34197                                  ;;  Proc Name:	SYSDISPMSG
 34198                                  ;;
 34199                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
 34200                                  ;;		requested by the caller. It also provides function to display
 34201                                  ;;		messages when handles are not applicable (ie. DOS function calls
 34202                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
 34203                                  ;;		defined previous to entry.
 34204                                  ;;
 34205                                  ;;		It is assumes that a PRELOAD function has already determined
 34206                                  ;;		the addressibilty internally to the message retriever services.
 34207                                  ;;  Inputs:
 34208                                  ;;
 34209                                  ;;  Outputs:
 34210                                  ;;
 34211                                  ;;  Psuedocode:
 34212                                  ;;		Save registers needed later
 34213                                  ;;		Get address of the message requested
 34214                                  ;;		IF Message number exists THEN
 34215                                  ;;		  IF replacable parameters were specified THEN
 34216                                  ;;		     Display message with replacable parms
 34217                                  ;;		  ELSE
 34218                                  ;;		     Display string without replacable parms
 34219                                  ;;		  ENDIF
 34220                                  ;;		  IF character input was requested THEN
 34221                                  ;;		     Wait for character input
 34222                                  ;;		  ENDIF
 34223                                  ;;		  Clear CARRY FLAG
 34224                                  ;;		ELSE
 34225                                  ;;		   Set CARRY FLAG
 34226                                  ;;		ENDIF
 34227                                  ;;		Return
 34228                                  ;;
 34229                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34230                                  
 34231                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34232                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h
 34233                                  	;
 34234                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34235                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5ACBh
 34236                                  SYSDISPMSG:
 34237                                  	;; Save registers and values needed later
 34238 000057DA 50                      	push	ax				;;AN000;; Save changed REGs
 34239 000057DB 53                      	push	bx				;;AN000;;
 34240 000057DC 51                      	push	cx				;;AN000;;
 34241 000057DD 55                      	push	bp				;;AN000;;
 34242 000057DE 57                      	push	di				;;AN000;; Save pointer to input buffer (offset)
 34243 000057DF 06                      	push	es				;;AN000;; Save pointer to input buffer (segment)
 34244 000057E0 52                      	push	dx				;;AN000;; Save Input/Class request
 34245                                  
 34246 000057E1 89CD                    	mov	bp,cx				;;AN000;; Use BP to hold replace count
 34247 000057E3 891E[5D9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
 34248                                  	;mov	[$M_RT+64],bx			;;AN000;; Save handle
 34249 000057E7 8836[629A]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
 34250                                  	;mov	[$M_RT+69],dh			;;AN004;; Save class
 34251                                  
 34252                                  	;; Get address of the message requested
 34253 000057EB E8D8FE                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 34254                                  
 34255 000057EE 09C9                    	or	cx,cx				;;AN000;; Was message found?
 34256 000057F0 7427                    	jz	short $MIF93
 34257                                  						;;AN000;; Yes, Message address in ES:DI
 34258                                  	
 34259                                  	;; Test if replacable parameters were specified
 34260 000057F2 09ED                    	or	bp,bp				;;AN000;; Were replacable parameters requested
 34261 000057F4 7505                    	jnz	short $MIF94
 34262                                  
 34263                                  	;; Display string without replacable parms
 34264 000057F6 E82800                  	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
 34265 000057F9 EB03                    	jmp	short $MEN94
 34266                                  $MIF94:
 34267                                  	;; Display message with replacable parms
 34268 000057FB E88B01                  	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
 34269                                  $MEN94:
 34270 000057FE 7214                    	jc	short $MIF97
 34271 00005800 5A                      	pop	dx				;;AN000;; Get Input/Class request
 34272 00005801 E8FC00                  	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
 34273 00005804 07                      	pop	es				;;AN000;; Get location of input buffer (if specified)
 34274 00005805 5F                      	pop	di				;;AN000;;
 34275                                  	
 34276                                  ; 15/06/2023 - MSDOS 5.0
 34277                                  ;	;jmp	short $MEN97 ; ***
 34278                                  ;	; 08/04/2023
 34279                                  ;	;jmp	short $MEN93 ; **
 34280                                  ;
 34281                                  ;	; 08/04/2023
 34282                                  ;;$MEN93:
 34283                                  ;	jc	short $MIF104
 34284                                  
 34285                                  	; 15/06/2023 Retro DOS v4.2 COMMAND.COM
 34286                                   	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5AF7h
 34287                                  
 34288                                  	; MSDOS 6.0 (MSDOS 6.22)
 34289                                  	; Test if character input was requested	;;AN000;;
 34290 00005806 08D2                    	or	dl,dl
 34291 00005808 7403                    	jz	short $MIF98
 34292                                  	;jz	short $MEN98 ; *
 34293                                  
 34294 0000580A E88B05                  	call	$M_WAIT_FOR_INPUT	; MSDOS 6.0 (to 6.22)
 34295                                  	; cf = 0 ; *
 34296                                  $MIF98:
 34297                                  	;jmp	short $MEN97
 34298                                  	;;jc	short $MIF104 ; *
 34299                                  $MEN98:
 34300                                  ;$MEN97:
 34301 0000580D 5D                      	pop	bp				;;AN000;;
 34302 0000580E 59                      	pop	cx				;;AN000;;
 34303 0000580F 5B                      	pop	bx				;;AN000;;
 34304                                  	; 15/06/2023
 34305                                  	;pop	ax	; MSDOS 5.0		;;AN000;;
 34306 00005810 83C402                  	add	sp,2	; MSDOS 6.0 (to 6.22)
 34307 00005813 C3                      	retn
 34308                                   
 34309                                  $MIF97:
 34310                                  	; 08/04/2023
 34311                                  	;add	sp,6				;;AN000;;
 34312                                  	;stc					;;AN000;; Reset carry flag
 34313                                  ;$MEN97: ; ***
 34314                                  	;jmp	short $MEN93
 34315                                  	; 08/04/2023
 34316                                  	;jmp	short $MIF104
 34317                                  	; 08/04/2023
 34318 00005814 83C40E                  	add	sp,14 ; 6+8
 34319 00005817 F9                      	stc
 34320 00005818 C3                      	retn
 34321                                  $MIF93:
 34322                                  	; 08/04/2023 - 15/06/2023
 34323                                  	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
 34324                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
 34325                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5B06h
 34326 00005819 07                      	pop	es				;;AN000;; Get pointer to input buffer (segment)
 34327 0000581A 5F                      	pop	di				;;AN000;; Get base pointer to first sublist (offset)
 34328 0000581B 5A                      	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
 34329                                  	;stc	; * 				;;AN000;; Set carry flag
 34330                                  	; 08/04/2023
 34331                                  	;jmp	short $MIF104 ; *
 34332                                  
 34333                                  ;$MEN93: ; **
 34334                                  ;	jc	short $MIF104
 34335                                  ;$MEN97: ; 08/04/2023
 34336                                  ;	pop	bp				;;AN000;;
 34337                                  ;	pop	cx				;;AN000;;
 34338                                  ;	pop	bx				;;AN000;;
 34339                                  ;	pop	ax				;;AN000;;
 34340                                  ;	;jmp	short $MEN104
 34341                                  ;	; 08/04/2023
 34342                                  ;	retn
 34343                                  
 34344                                  $MIF104: ; *
 34345 0000581C 83C408                  	add	sp,8				;;AN000;; Eliminate from stack
 34346 0000581F F9                      	stc					;;AN000;;
 34347                                  $MEN104:
 34348 00005820 C3                      	retn					;;AN000;; Return
 34349                                  
 34350                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34351                                  ;;
 34352                                  ;;	PROC NAME: $M_DISPLAY_STRING
 34353                                  ;;
 34354                                  ;;	FUNCTION:  Will display or write string
 34355                                  ;;	INPUTS:    ES:DI points to beginning of message
 34356                                  ;;		   CX contains the length of string to write (if applicable)
 34357                                  ;;	OUTPUTS:   None
 34358                                  ;;	REGS Revised: None
 34359                                  ;;
 34360                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34361                                  
 34362                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34363                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34364                                  $M_DISPLAY_STRING:
 34365 00005821 50                      	push	ax				;;AN000;;
 34366 00005822 53                      	push	bx				;;AN000;;
 34367 00005823 52                      	push	dx				;;AN000;;
 34368 00005824 8B1E[5D9A]              	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
 34369                                  	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
 34370                                  	
 34371 00005828 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
 34372 0000582B 7505                    	jne	short $MIF107
 34373                                  
 34374 0000582D E82600                  	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
 34375 00005830 EB03                    	jmp	short $MEN107
 34376                                  $MIF107:
 34377 00005832 E86E00                  	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
 34378                                  $MEN107:
 34379 00005835 730D                    	jnc	short $MIF110
 34380                                  	
 34381 00005837 B459                    	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
 34382                                  	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
 34383                                  	; 08/04/2023
 34384 00005839 31DB                    	xor	bx,bx
 34385 0000583B CD21                    	int	21h				;;AN000;;
 34386                                  		; DOS - 3+ - GET EXTENDED ERROR CODE
 34387                                  		; BX = version code (0000h for DOS 3.x)
 34388 0000583D 30E4                    	xor	ah,ah				;;AN000;; Clear AH
 34389                                  $MEN110: ; 08/04/2023 ; ***
 34390 0000583F 83C406                  	add	sp,6				;;AN000;; Clean up stack
 34391 00005842 F9                      	stc					;;AN000;; Flag that there was an error
 34392                                  	;jmp	short $MEN110 ; ****
 34393                                  	; 08/04/2023
 34394 00005843 C3                      	retn
 34395                                  $MIF110:
 34396                                  	;cmp	bx,$M_NO_HANDLE
 34397 00005844 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
 34398 00005847 7409                    	je	short $MIF112 ; *  ; cf = 0
 34399 00005849 39C8                    	cmp	ax,cx				;;AN001;; Was it ALL written?
 34400 0000584B 7405                    	je	short $MIF113 ; ** ; cf = 0
 34401 0000584D E8A700                  	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
 34402                                  	;add	sp,6				;;AN001;; Clean up stack
 34403                                  	;stc					;;AN001;; Flag that there was an error
 34404                                  	; 08/04/2023
 34405 00005850 EBED                    	jmp	short $MEN110 ; ***
 34406                                  	; 08/04/2023
 34407                                  ;$MIF112:
 34408                                  ;$MEN110: ; ****
 34409                                  	;jc	short $MIF117
 34410                                  $MIF112: ; 08/04/2023	; *
 34411                                  $MIF113:	; **
 34412 00005852 5A                      	pop	dx				;;AN000;; Restore regs
 34413 00005853 5B                      	pop	bx				;;AN000;;
 34414 00005854 58                      	pop	ax				;;AN000;;
 34415                                  $MIF117:
 34416 00005855 C3                      	retn
 34417                                  
 34418                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34419                                  ;;
 34420                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
 34421                                  ;;
 34422                                  ;;	FUNCTION:  Will display a $ terminated string
 34423                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
 34424                                  ;;	OUTPUTS:   None
 34425                                  ;;	REGS USED: AX,DX
 34426                                  ;;
 34427                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34428                                  
 34429                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34430                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34431                                  $M_DISPLAY_$_STRING:
 34432 00005856 1E                      	push	ds				;;AN000;;
 34433 00005857 06                      	push	es				;;AN000;;
 34434 00005858 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 34435                                  
 34436                                  	; 08/04/2023
 34437 00005859 B402                    	mov	ah,2 ; DOS_DISP_CHAR
 34438                                  
 34439                                  	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
 34440 0000585B 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR
 34441 0000585E 7518                    	jne	short $MIF119			;;AN000;; No
 34442                                  	
 34443                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 34444 00005860 268A15                  	mov	dl,[es:di]			;;AN000;; Get the character
 34445 00005863 CD21                    	int	21h				;;AN000;; Write character
 34446                                  		; DOS - DISPLAY OUTPUT
 34447                                  		; DL = character to send to standard output
 34448 00005865 1F                      	pop	ds				;;AN000;;
 34449 00005866 88D0                    	mov	al,dl				;;AN000;; Get the character in AL
 34450 00005868 E8AC00                  	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
 34451 0000586B 1E                      	push	ds				;;AN000;;
 34452 0000586C 06                      	push	es				;;AN000;;
 34453 0000586D 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 34454 0000586E 7316                    	jnc	short $MIF120 ; *
 34455                                  
 34456 00005870 268A5501                	mov	dl,[es:di+1]			;;AN000;; Get the next character
 34457 00005874 CD21                    	int	21h				;;AN000;; Write character
 34458                                  		; DOS - DISPLAY OUTPUT
 34459                                  		; DL = character to send to standard output
 34460                                  	; 08/04/2023
 34461                                  	;clc					;;AN000;; Clear the DBCS indicator
 34462                                  ;$MIF120:
 34463 00005876 EB0D                    	jmp	short $MEN119
 34464                                  $MIF119:
 34465                                  	; 08/04/2023
 34466                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 34467                                  ;$MDO123:
 34468 00005878 09C9                    	or	cx,cx				;;AN002;; Are there any left to display?
 34469                                  	;jz	short $MEN123
 34470                                  	; 18/04/2023
 34471 0000587A 740A                    	jz	short $MIF120 ; cf = 0
 34472                                  $MDO123: ; 08/04/2023
 34473 0000587C 268A15                  	mov	dl,[es:di]			;;AN002;; Get the character
 34474 0000587F CD21                    	int	21h				;;AN002;; Display the character
 34475                                  		; DOS - DISPLAY OUTPUT
 34476                                  		; DL = character to send to standard output
 34477 00005881 47                      	inc	di				;;AN002;; Set pointer to next character
 34478 00005882 49                      	dec	cx				;;AN002;; Count this character
 34479 00005883 75F7                    	jnz	short $MDO123
 34480                                  ;$MEN123:
 34481                                  $MEN119:
 34482 00005885 F8                      	clc					;;AN000;;Char functions used don't return carry as error
 34483                                  $MIF120: ; 08/04/2023 ; *
 34484 00005886 1F                      	pop	ds				;;AN000;;
 34485 00005887 C3                      	retn
 34486                                  
 34487                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34488                                  ;;
 34489                                  ;; Scan_ctrlZ: This routine looks through the string to be printed and 
 34490                                  ;; truncates it at the Ctrl-Z if any present.
 34491                                  ;;
 34492                                  ;;	ENTRY:	ds:dx = String to be displayed
 34493                                  ;;		cx = number of chars to be displayed
 34494                                  ;;
 34495                                  ;;	EXIT:	cx = number of chars to be displayed
 34496                                  ;;
 34497                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34498                                  
 34499                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34500                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34501                                  scan_ctrlz:
 34502 00005888 57                      	push	di
 34503 00005889 50                      	push	ax
 34504 0000588A 06                      	push	es
 34505 0000588B 53                      	push	bx
 34506                                  
 34507 0000588C 89D7                    	mov	di,dx
 34508 0000588E 1E                      	push	ds
 34509 0000588F 07                      	pop	es   			;es:di points at string
 34510                                  
 34511 00005890 89CB                    	mov	bx,cx			;save current count
 34512                                  
 34513 00005892 B01A                    	mov	al,1Ah	; Ctrl-Z
 34514 00005894 FC                      	cld
 34515 00005895 F2AE                    	repne	scasb			;find first Ctrl-Z
 34516 00005897 7503                    	jnz	short noCtrlZ		;no CtrlZ found in string
 34517                                  
 34518 00005899 29CB                    	sub	bx,cx
 34519 0000589B 4B                      	dec	bx			;bx = new count to display
 34520                                  noCtrlZ:
 34521 0000589C 89D9                    	mov	cx,bx			;cx = actual display count
 34522                                  
 34523 0000589E 5B                      	pop	bx
 34524 0000589F 07                      	pop	es
 34525 000058A0 58                      	pop	ax
 34526 000058A1 5F                      	pop	di
 34527                                  $MIF127:	; 08/04/2023
 34528 000058A2 C3                      	retn
 34529                                  
 34530                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34531                                  ;;
 34532                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
 34533                                  ;;
 34534                                  ;;	FUNCTION:  Will display a string to a specified handle
 34535                                  ;;	INPUTS:    ES:DI points to beginning of message
 34536                                  ;;		   CX contains the number of bytes to write
 34537                                  ;;		   BX contains the handle to write to
 34538                                  ;;	OUPUTS:    None
 34539                                  ;;	REGS USED: AX,DX
 34540                                  ;;
 34541                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34542                                  
 34543                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34544                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34545                                  $M_DISPLAY_H_STRING:
 34546 000058A3 31C0                    	xor	ax,ax			;;AN002;; Set number of bytes written to 0
 34547 000058A5 09C9                    	or	cx,cx			;;AN002;; For performance, don't write if not necessary
 34548 000058A7 74F9                    	jz	short $MIF127
 34549                                  	
 34550 000058A9 1E                      	push	ds			;;AN000;;
 34551 000058AA 06                      	push	es			;;AN000;;
 34552 000058AB 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34553                                  	
 34554 000058AC B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34555 000058AE 89FA                    	mov	dx,di			;;AN000;; Pointer to data to write
 34556                                  
 34557 000058B0 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
 34558 000058B3 7528                    	jne	short $MIF128		;;AN000;; No
 34559                                  
 34560 000058B5 CD21                    	int	21h			;;AN000;; Write character
 34561                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34562                                  		; BX = file handle, CX = number of bytes to writ
 34563                                  
 34564 000058B7 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34565 000058B8 50                      	push	ax			;;AN000;;
 34566 000058B9 268A05                  	mov	al,[es:di] 		;;AN000;; Get the character
 34567 000058BC E85800                  	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
 34568 000058BF 58                      	pop	ax			;;AN000;;
 34569 000058C0 1E                      	push	ds			;;AN000;;
 34570 000058C1 06                      	push	es			;;AN000;;
 34571 000058C2 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 34572 000058C3 7306                    	jnc	short $MIF129
 34573                                  	
 34574 000058C5 F8                      	clc				;;AN000;; Clear the DBCS indicator
 34575 000058C6 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 34576 000058C8 42                      	inc	dx			;;AN000;; Point to next character
 34577 000058C9 CD21                    	int	21h			;;AN000;; Write character
 34578                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 34579                                  		; BX = file handle, CX = number of bytes to write, 
 34580                                  $MIF129:
 34581                                  ;SR;
 34582                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
 34583                                  ;0 chars written making the caller think there was an error writing. To 
 34584                                  ;avoid this, we check if the single char was a Ctrl-Z and if so, return that
 34585                                  ;the char was written, thus fooling the caller.
 34586                                  
 34587 000058CB 9C                      	pushf				;save flags
 34588 000058CC 26803D1A                	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
 34589 000058D0 7502                    	jne	short m_popf_j		;no, continue
 34590                                  
 34591 000058D2 89C8                    	mov	ax,cx			;yes, fake as if it was written
 34592                                  m_popf_j:
 34593                                  	; 08/04/2023
 34594                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 34595 000058D4 EB01                    	jmp	short m_popf		;restore flags
 34596                                  
 34597                                  ; 07/04/2023
 34598                                  ; ---------------------------
 34599                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 34600                                  ; ---------------------------
 34601                                  	; $M_POPF macro
 34602                                  	;jmp	short $+3
 34603                                  intret:
 34604 000058D6 CF                      	iret
 34605                                  m_popf:
 34606 000058D7 0E                      	push	cs
 34607 000058D8 E8FBFF                  	call	intret
 34608                                  	;;; end macro	
 34609                                  ; ---------------------------
 34610                                  
 34611 000058DB EB18                    	jmp	short $MEN128
 34612                                  
 34613                                  $MIF128:
 34614                                  ;SR;
 34615                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
 34616                                  ;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
 34617                                  
 34618 000058DD 55                      	push	bp			; M007
 34619 000058DE 51                      	push	cx
 34620 000058DF E8A6FF                  	call	scan_ctrlz		;cx = count without Ctrl-Z
 34621 000058E2 89CD                    	mov	bp,cx			;store no ^Z count in bp ;M007
 34622 000058E4 59                      	pop	cx			;get old count back ;M007
 34623                                  	
 34624 000058E5 CD21                    	int	21h			;;AN000;; Write String at DS:SI to handle
 34625                                  	;jnc	short chk_count		;no error, adjust return count
 34626                                  	;jmp	short m_cnt_ok		;error, return with carry set;M007
 34627                                  	; 08/04/2023
 34628 000058E7 720B                    	jc	short m_cnt_ok
 34629                                  ;M007
 34630                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
 34631                                  ;return count will be much less and if this returns to the caller we can get
 34632                                  ;spurious error messages. We check here if the count returned is same as
 34633                                  ;original count or same as the count if we stop at Ctrl-Z. In the second
 34634                                  ;case, we fake it as if all bytes have been written. If the return count
 34635                                  ;does not match either count, then we had some other disk error (such as
 34636                                  ;insufficient disk space) and we pass it through
 34637                                  
 34638                                  chk_count:
 34639 000058E9 39C1                    	cmp	cx,ax			;have all bytes been written?;M007
 34640 000058EB 7407                    	je	short m_cnt_ok		;there was an error writing ;M007
 34641 000058ED 39C5                    	cmp	bp,ax			;count = Ctrl-Z count? ;M007
 34642 000058EF F8                      	clc				;no error either way ;M007
 34643 000058F0 7502                    	jne	short m_cnt_ok		;no, pass it through ;M007
 34644 000058F2 89C8                    	mov	ax,cx			;return old count ;M007
 34645                                  m_cnt_ok:				; M007
 34646 000058F4 5D                      	pop	bp			; M007
 34647                                  $MEN128:
 34648 000058F5 1F                      	pop	ds			;;AN000;;
 34649                                  ;$MIF127: ; 08/04/2023
 34650 000058F6 C3                      	retn
 34651                                  
 34652                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34653                                  ;;
 34654                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
 34655                                  ;;
 34656                                  ;;	FUNCTION:  Will set registers for extended error #39
 34657                                  ;;	INPUTS:    None
 34658                                  ;;	OUPUTS:    AX,BX,CX set
 34659                                  ;;	REGS USED:
 34660                                  ;;
 34661                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34662                                  
 34663                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34664                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
 34665                                  
 34666                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34667                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5BFAh
 34668                                  
 34669                                  $M_GET_EXT_ERR_39:
 34670 000058F7 B82700                  	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
 34671                                  	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
 34672 000058FA BB0400                  	mov	bx,4			;AN001; Set BH=1 BL=4
 34673                                  	;mov	ch,LOCUS_39		;AN001; Set CH=1
 34674 000058FD B501                    	mov	ch,1			;AN001;
 34675 000058FF C3                      	retn				;AN001;
 34676                                  
 34677                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34678                                  ;;
 34679                                  ;;	PROC NAME: $M_ADD_CRLF
 34680                                  ;;
 34681                                  ;;	FUNCTION:  Will decide whether to display a CRLF
 34682                                  ;;	INPUTS:    DX contains the Input/Class requested
 34683                                  ;;	OUTPUTS:   None
 34684                                  ;;	REGS Revised: CX,ES,DI
 34685                                  ;;
 34686                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34687                                  
 34688                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34689                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34690                                  $M_ADD_CRLF:
 34691                                  	;cmp	dh,0FFh
 34692 00005900 80FEFF                  	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
 34693 00005903 7411                    	je	short $MIF134		;;AN004;; Yes
 34694 00005905 F6C680                  	test	dh,80h ; $M_NO_CRLF_MASK ;;AN004;; Are we to supress the CR LF?
 34695 00005908 750C                    	jnz	short $MIF135
 34696                                  					;;AN004;; No	
 34697 0000590A 1E                      	push	ds			;;AN004;;
 34698 0000590B 07                      	pop	es			;;AN004;; Set ES to data segment
 34699 0000590C 8D3E[609A]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
 34700                                  	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
 34701 00005910 B90200                  	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
 34702 00005913 E80BFF                  	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
 34703                                  $MIF135:
 34704                                  $MIF134:
 34705 00005916 C3                      	retn				;;AN004;; Return
 34706                                  
 34707                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34708                                  ;;
 34709                                  ;;	PROC NAME: $M_IS_IT_DBCS
 34710                                  ;;
 34711                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
 34712                                  ;;	INPUTS:    AL contains the byte to be checked
 34713                                  ;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
 34714                                  ;;		   Carry flag = 1 if byte IS in DBCS range
 34715                                  ;;	REGS USED: All restored
 34716                                  ;;
 34717                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34718                                  
 34719                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34720                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34721                                  $M_IS_IT_DBCS:
 34722 00005917 06                      	push	es			;;AN000;; Save Extra Segment register
 34723 00005918 57                      	push	di			;;AN000;; Save DI register
 34724                                  
 34725 00005919 C43E[599A]              	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
 34726                                  	;les	di,[$M_RT+60]		;;AN000;;
 34727 0000591D 09FF                    	or	di,di			;;AN000;; Was the DBCS vector set?
 34728 0000591F 7417                    	jz	short $MIF138		;;AN000;; No
 34729                                  $MDO139:
 34730 00005921 26833D00                	cmp	word [es:di],0 ; $M_DBCS_TERM
 34731                                  					;;AN000;; Is this the terminating flag?
 34732 00005925 F8                      	clc				;;AN000;;
 34733 00005926 7410                    	jz	short $MEN139
 34734                                  					;;AN000;; No
 34735 00005928 263A05                  	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
 34736 0000592B 7207                    	jnae	short $MIF141 ; jb	;;AN000;; No		
 34737 0000592D 263A4501                	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
 34738 00005931 7701                    	jnbe	short $MIF141 ; ja	;;AN000;; No
 34739                                  					;;AN000;; Yes
 34740 00005933 F9                      	stc				;;AN000;; Set carry flag
 34741                                  $MIF141:
 34742 00005934 47                      	inc	di			;;AN000;;
 34743 00005935 47                      	inc	di			;;AN000;;
 34744 00005936 EBE9                    	jmp	short $MDO139		;;AN000;; Go to next vector
 34745                                  $MEN139:
 34746                                  $MIF138:
 34747 00005938 5F                      	pop	di			;;AN000;; Restore DI register
 34748 00005939 07                      	pop	es			;;AN000;; Restore Extra Segment register
 34749 0000593A C3                      	retn				;;AN000;; Return
 34750                                  
 34751                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34752                                  ;;
 34753                                  ;;	PROC NAME: $M_CONVERT2ASC
 34754                                  ;;
 34755                                  ;;	FUNCTION: Convert a binary number to a ASCII string
 34756                                  ;;	INPUTS: DX:AX contains the number to be converted
 34757                                  ;;		$M_RT_DIVISOR contains the divisor
 34758                                  ;;	OUTPUTS: CX contains the number of characters
 34759                                  ;;		Top of stack  --> Last character
 34760                                  ;;				     . . .
 34761                                  ;;		Bot of stack  --> First character
 34762                                  ;;	REGS USED:
 34763                                  ;;
 34764                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34765                                  
 34766                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34767                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34768                                  $M_CONVERT2ASC:
 34769 0000593B 8F06[639A]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34770                                  	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
 34771                                  	
 34772 0000593F 31DB                    	xor	bx,bx				;;AN000;; Use BX as a swapping register
 34773 00005941 93                      	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
 34774 00005942 92                      	xchg	ax,dx				;;AN000;;	  - High Word in AX
 34775                                  $MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
 34776 00005943 F736[679A]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34777                                  	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
 34778 00005947 93                      	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
 34779                                  						;;AN000;;  and save reduced High Word in BX
 34780 00005948 F736[679A]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 34781                                  	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor
 34782                                  
 34783 0000594C 83FA09                  	cmp	dx,9				;;AN000;; Make a digit of the remainder
 34784 0000594F 7605                    	jna	short $MIF146			;;AN000;; 0-9
 34785 00005951 80C237                  	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
 34786 00005954 EB03                    	jmp	short $MEN146
 34787                                  $MIF146:
 34788 00005956 80C230                  	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
 34789                                  $MEN146:
 34790 00005959 52                      	push	dx				;;AN000;; Save the digit on the stack
 34791 0000595A 41                      	inc	cx				;;AN000;; Count that digit
 34792 0000595B 09C0                    	or	ax,ax				;;AN000;; Are we done?
 34793 0000595D 7504                    	jnz	short $MLL149			;;AN000;; No
 34794 0000595F 09DB                    	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
 34795 00005961 741F                    	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
 34796                                  $MLL149:
 34797 00005963 83F903                  	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
 34798                                  ; 28/04/2023
 34799 00005966 740A                    	je	short $MIF153
 34800                                  ;	jne	short $MIF150			;;AN000;; No
 34801                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34802                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','
 34803                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34804                                  ;	;jne	short $MIF151
 34805                                  ;	; 09/04/2023
 34806                                  ;	jne	short $MEN150
 34807                                  ;						;;AN000;; Yes
 34808                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34809                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34810                                  ;	inc	cx				;;AN000;;
 34811                                  ;$MIF151:
 34812                                  ;	jmp	short $MEN150
 34813                                  
 34814                                  $MIF150:
 34815                                  	; 15/06/2023 (6)
 34816                                  	; MSDOS 6.0
 34817                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54ABh 
 34818                                  	;cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 34819                                  	; 15/06/2023 (7)
 34820                                  	; MSDOS 6.22
 34821                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C78h 
 34822 00005968 83F907                  	cmp	cx,7 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 34823                                  
 34824                                  ; 28/04/2023
 34825 0000596B 7405                    	je	short $MIF153
 34826                                  ;	jne	short $MIF154			;;AN000;; No
 34827                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34828                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 34829                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34830                                  ;	;jne	short $MIF155			;;AN000;; No
 34831                                  ;	; 09/04/2023
 34832                                  ;	jne	short $MEN154
 34833                                  ;						;;AN000;; Yes
 34834                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34835                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34836                                  ;	inc	cx				;;AN000;;
 34837                                  ;$MIF155:
 34838                                  ;	jmp	short $MEN154
 34839                                  
 34840                                  $MIF154:
 34841                                  	; 15/06/2023 (9)
 34842                                  	; MSDOS 6.0
 34843                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54BDh
 34844                                  	;cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34845                                  	; 15/06/2023 (11)
 34846                                  	; MSDOS 6.22
 34847                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5C8Ah
 34848 0000596D 83F90B                  	cmp	cx,11 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 34849 00005970 750B                    	jne	short $MIF158			;;AN000;; No
 34850                                  ; 28/04/2023
 34851                                  $MIF153:
 34852                                  	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 34853 00005972 807C0A2C                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','
 34854                                  	;cmp	byte [si+0Ah],',' ; $M_COMMA
 34855 00005976 7505                    	jne	short $MIF159			;;AN000;; No
 34856                                  						;;AN000;; Yes
 34857 00005978 FF36[709A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34858                                  	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34859 0000597C 41                      	inc	cx				;;AN000;;
 34860                                  $MIF159:
 34861                                  $MIF158:
 34862                                  $MEN154:
 34863                                  $MEN150:					;;AN000;;
 34864 0000597D 93                      	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
 34865                                  						;;AN000;;  and Revised Low Word
 34866 0000597E 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34867                                  	; 28/04/2023
 34868 00005980 EBC1                    	jmp	short $MDO145
 34869                                  ;$MEN145:
 34870                                  	; 28/04/2023
 34871                                  	;xor	ax,ax				;;AN000;; Reset remainder
 34872                                  $MEN145: ; 09/04/2023 ; * ; ax = 0
 34873 00005982 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34874 00005984 FF36[639A]              	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34875                                  	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
 34876 00005988 C3                      	retn					;;AN000;; Return
 34877                                  
 34878                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34879                                  ;;
 34880                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
 34881                                  ;;
 34882                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
 34883                                  ;;	INPUTS:    ES:DI points to beginning of message
 34884                                  ;;		   DS:SI points to first sublist structure in chain
 34885                                  ;;		   BX contains the handle to write to (if applicable)
 34886                                  ;;		   CX contains the length of string to write (before substitutions)
 34887                                  ;;		   BP contains the count of replacables
 34888                                  ;;
 34889                                  ;;	OUTPUTS:
 34890                                  ;;	REGS USED: All
 34891                                  ;;
 34892                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34893                                  
 34894                                  	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34895                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh
 34896                                  
 34897                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 34898                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:54DBh
 34899                                  
 34900                                  $M_DISPLAY_MESSAGE:
 34901                                  ; $DO						;;AN000;; Note: DS:SI -> message
 34902                                  $MDO165:
 34903 00005989 31D2                    	xor	dx,dx				;;AN000;; Set size = 0
 34904 0000598B 09C9                    	or	cx,cx				;;AN000;; Are we finished the message yet?
 34905                                  ;; $IF NZ					;;AN000;; No
 34906 0000598D 741F                    	jz	short $MIF166			;;AN000;; Yes
 34907                                  	;mov	ah,"%"				;;AN000;; Prepare to scan for %
 34908                                  	;mov	al,0				;;AN004;;
 34909                                  	; 12/08/2024
 34910 0000598F B80025                  	mov	ax,2500h
 34911                                  ;; $DO						;;AN000;; Scan through string until %
 34912                                  $MDO167:
 34913 00005992 263825                  	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
 34914                                  ;; $LEAVE E,AND					;;AN000;; No
 34915 00005995 750A                    	jne	short $MLL168
 34916 00005997 26386501                	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
 34917                                  ;; $LEAVE NE,AND				;;AN000;; No
 34918 0000599B 7404                    	je	short $MLL168
 34919                                  
 34920 0000599D 38E0                    	cmp	al,ah				;;AN000;; Was the character before a %
 34921                                  ;; $LEAVE NE					;;AN000;; No, GREAT found it
 34922 0000599F 750D                    	jne	short $MEN167 ; 12/08/2024
 34923                                  $MLL168:
 34924 000059A1 268A05                  	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
 34925 000059A4 E870FF                  	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
 34926                                  ;;; $IF C					;;AN004;; Yes
 34927 000059A7 7301                    	jnc	short $MIF169
 34928 000059A9 47                      	inc	di				;;AN004;; Increment past second part
 34929                                  ;;; $ENDIF					;;AN004;;
 34930                                  $MIF169:
 34931 000059AA 47                      	inc	di				;;AN000;; Next character in string
 34932 000059AB 42                      	inc	dx				;;AN000;; Size = Size + 1
 34933                                  	;dec	cx				;;AN000;; Decrement total size
 34934                                  ;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
 34935                                  	;jnz	short $MDO167
 34936                                  	; 12/08/2024
 34937 000059AC E2E4                    	loop	$MDO167
 34938                                  $MEN167:
 34939                                  ;; $ENDIF					;;AN000;;
 34940                                  $MIF166:
 34941 000059AE 56                      	push	si				;;AN000;; Save beginning of sublists
 34942 000059AF 87CA                    	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
 34943 000059B1 09ED                    	or	bp,bp				;;AN000;; Do we have any replacables to do?
 34944                                  ;; $IF NZ					;;AN000;; Yes
 34945 000059B3 7431                    	jz	short $MIF173
 34946 000059B5 4D                      	dec	bp				;;AN000;; Decrement number of replacables
 34947                                  
 34948                                  ;; Search through sublists to find applicable one
 34949                                  
 34950 000059B6 833E[659A]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34951                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34952                                  ;;; $IF E					;;AN000;; No
 34953 000059BB 7529                    	jne	short $MIF174
 34954                                  ;;; $SEARCH					;;AN000;;
 34955                                  $MDO175:
 34956                                  	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
 34957 000059BD 8A4406                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
 34958                                  	;mov	al,[si+6]
 34959 000059C0 0430                    	add	al,30h				;;AN000;; Convert to ASCII
 34960                                  	; 28/04/2023					
 34961 000059C2 263A4501                	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
 34962                                  ;;; $EXITIF E					;;AN000;;
 34963                                  	;jne	short $MIF175
 34964                                  ;;; $ORELSE					;;AN000;; No
 34965                                  	;jmp	short $MSR175
 34966                                  	; 28/04/2023
 34967 000059C6 741E                    	je	short $MSR175
 34968                                  $MIF175:
 34969 000059C8 3C30                    	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
 34970                                  ;;; $LEAVE E,AND				;;AN000;; Yes
 34971 000059CA 7504                    	jne	short $MLL178
 34972 000059CC 09D2                    	or	dx,dx				;;AN000;; Are we at the end of the message?
 34973                                  ;;; $LEAVE Z					;;AN000;; No
 34974 000059CE 7404                    	jz	short $MEN175
 34975                                  $MLL178:
 34976                                  	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
 34977                                  	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
 34978                                  	;;add	si,[si+0]
 34979 000059D0 0334                    	add	si,[si]
 34980                                  ;;; ENDLOOP					;;AN000;; Yes
 34981 000059D2 EBE9                    	jmp	short $MDO175
 34982                                  $MEN175:
 34983 000059D4 803E[629A]FF            	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
 34984                                  	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
 34985                                  ;;;; $IF E					;;AN004;; Yes
 34986 000059D9 7508                    	jne	short $MIF180
 34987 000059DB 42                      	inc	dx				;;AN000;; Remember to display CR,LF
 34988 000059DC 42                      	inc	dx				;;AN000;;  at the end of the message
 34989 000059DD 49                      	dec	cx				;;AN000;; Adjust message length
 34990 000059DE 49                      	dec	cx				;;AN000;;
 34991 000059DF 4F                      	dec	di				;;AN000;; Adjust ending address of message
 34992 000059E0 4F                      	dec	di				;;AN000;;
 34993                                  ;;;; $ELSE					;;AN004;; No
 34994 000059E1 EB03                    	jmp	short $MEN180
 34995                                  $MIF180:
 34996 000059E3 BAFFFF                  	mov	dx,-1 				;;AN004;; Set special case
 34997                                  ;;;; $ENDIF					;;AN004;;
 34998                                  $MEN180:
 34999                                  ;;; $ENDSRCH					;;AN000;;
 35000                                  $MSR175:
 35001                                  ;; $ENDIF					;;AN000;;
 35002                                  $MIF174:
 35003                                  ; $ENDIF					;;AN000;;
 35004                                  $MIF173:
 35005                                  ;; Prepare and display this part of message
 35006                                  
 35007 000059E6 57                      	push	di				;;AN000;; Save pointer to replace number
 35008 000059E7 29CF                    	sub	di,cx				;;AN000;; Determine beginning of string
 35009 000059E9 E835FE                  	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
 35010 000059EC 5F                      	pop	di				;;AN000;; Get back pointer to replace number
 35011 000059ED 59                      	pop	cx				;;AN000;; Clean up stack in case error
 35012                                  ; $LEAVE C,LONG					;;AN000;; Fail if carry was set
 35013                                  	;jnc	short $MXL3
 35014                                  	;jmp	$MEN165
 35015                                  	; 02/05/2023
 35016 000059EE 7214                    	jc	short $MEN165
 35017                                  $MXL3:
 35018 000059F0 51                      	push	cx				;;AN000;;
 35019                                  
 35020                                  ;; Save and reset pointer registers
 35021                                  
 35022 000059F1 89D1                    	mov	cx,dx				;;AN000;; Get the size of the rest of the message
 35023                                  	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
 35024 000059F3 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
 35025                                  	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
 35026                                  ; $IF NE					;;AN000;; No
 35027 000059F7 7412                    	je	short $MIF187			;;AN000;; Yes			
 35028 000059F9 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 35029                                  ;; $IF NZ					;;AN000;; No
 35030 000059FB 7406                    	jz	short $MIF188			;;AN000;; Yes
 35031 000059FD 49                      	dec	cx				;;AN000;; Decrement total size (%)
 35032 000059FE 49                      	dec	cx				;;AN000;; Decrement total size (#)
 35033 000059FF 47                      	inc	di				;;AN000;; Go past %
 35034 00005A00 47                      	inc	di				;;AN000;; Go past replace number
 35035                                  ;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
 35036                                  	;jmp	short $MEN188
 35037                                  	; 28/04/2023
 35038 00005A01 EB15                    	jmp	short $MEN187
 35039                                  $MIF188:
 35040 00005A03 5E                      	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 35041                                  ;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
 35042                                  $MEN188:
 35043                                  ; $ELSE 					;;AN000;;
 35044                                  	;jmp	short $MEN187
 35045                                  	; 28/04/2023
 35046                                  	; zf = 1
 35047                                  	;jmp	short $MEN165 
 35048                                  
 35049                                  ; 28/04/2023
 35050                                  $MXL4:
 35051                                  $MLL214:
 35052                                  $MEN165:
 35053 00005A04 C706[659A]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 35054                                  	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 35055                                  						;;AN000;; Reset message number to null
 35056 00005A0A C3                      	retn					;;AN000;; Return
 35057                                  
 35058                                  $MIF187:
 35059 00005A0B 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 35060                                  ;; $IF Z					;;AN004;; No
 35061                                  	;jnz	short $MIF192
 35062                                  	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 35063                                  ;; $ELSE					;;AN000;; No
 35064                                  	;jmp	short $MEN192
 35065                                  	; 28/04/2023
 35066 00005A0D 74F4                    	jz	short $MIF188
 35067                                  $MIF192:
 35068 00005A0F 83F9FF                  	cmp	cx,-1				;;AN004;; Are we at the end of the message?
 35069                                  ;;; $IF Z					;;AN004;; No
 35070 00005A12 7502                    	jnz	short $MIF194
 35071 00005A14 31C9                    	xor	cx,cx				;;AN004;;
 35072                                  ;;; $ENDIF					;;AN000;;
 35073                                  $MIF194:
 35074 00005A16 09FF                    	or	di,di				;;AN004;; Turn ZF off
 35075                                  ;; $ENDIF					;;AN000;;
 35076                                  $MEN192:
 35077                                  ; $ENDIF					;;AN000;; Note this will not leave because INC
 35078                                  $MEN187:
 35079                                  ; $LEAVE Z					;;AN000;;
 35080 00005A18 74EA                    	jz	short $MEN165
 35081                                  	;
 35082 00005A1A 55                      	push	bp				;;AN000;; Save the replace count
 35083 00005A1B 57                      	push	di				;;AN000;; Save location to complete message
 35084 00005A1C 06                      	push	es				;;AN000;;
 35085 00005A1D 51                      	push	cx				;;AN000;; Save size of the rest of the message
 35086 00005A1E 31C9                    	xor	cx,cx				;;AN000;; Reset CX used for character count
 35087                                  
 35088                                  ;; Determine what action is required on parameter
 35089                                  
 35090 00005A20 833E[659A]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 35091                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 35092                                  ; $IF E						;;AN000;;
 35093 00005A25 753B                    	jne	short $MIF199
 35094                                  
 35095                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 35096 00005A27 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 35097                                  	;test	byte [si+7],0Fh			;;AN000;;
 35098                                  ;; $IF Z					;;AN000;;
 35099 00005A2B 7508                    	jnz	short $MIF200
 35100                                  
 35101                                  ;; Character type requested
 35102                                  
 35103                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 35104 00005A2D C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35105                                  	;les	di,[si+2]
 35106 00005A30 E84801                  	call	$M_CHAR_REPLACE			;;AN000;;
 35107                                  ;; $ELSE					;;AN000;; Get the rest of the message to display
 35108 00005A33 EB28                    	jmp	short $MEN200
 35109                                  $MIF200:
 35110                                  ;; ENDIF					;;AN000;;
 35111                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35112 00005A35 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35113                                  	;test	byte [si+7],0Dh			;;AN000;;
 35114                                  ;; $IF Z,OR					;;AN000;;
 35115 00005A39 740C                    	jz	short $MLL202
 35116                                  	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
 35117 00005A3B F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35118                                  	;test	byte [si+7],0Eh			;;AN000;;
 35119                                  ;;; $IF Z,OR					;;AN000;;
 35120 00005A3F 7406                    	jz	short $MLL202
 35121                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
 35122 00005A41 F644070C                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
 35123                                  	;test	byte [si+7],0Ch			;;AN000;;
 35124                                  ;;;; $IF Z 					;;AN000;;
 35125 00005A45 7508                    	jnz	short $MIF202
 35126                                  $MLL202:
 35127                                  
 35128                                  ;; Numeric type requested
 35129                                  
 35130                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 35131 00005A47 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35132                                  	;les	di,[si+2]
 35133 00005A4A E85601                  	call	$M_BIN2ASC_REPLACE		;;AN000;;
 35134                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 35135 00005A4D EB0E                    	jmp	short $MEN202
 35136                                  $MIF202:
 35137                                  ;;;; ENDIF					;;AN000;;
 35138                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
 35139 00005A4F F644070B                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
 35140                                  	;test	byte [si+7],0Bh			;;AN000;;
 35141                                  ;;;; $IF E					;;AN000;;
 35142 00005A53 7505                    	jnz	short $MIF204
 35143                                  
 35144                                  ;; Date type requested
 35145                                  
 35146 00005A55 E8EC01                  	call	$M_DATE_REPLACE			;;AN000;;
 35147                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 35148 00005A58 EB03                    	jmp	short $MEN204
 35149                                  $MIF204:					;;AN000;;
 35150                                  
 35151                                  ;; Time type requested (Default if we have not matched until here)
 35152                                  
 35153 00005A5A E89E02                  	call	$M_TIME_REPLACE			;;AN000;;
 35154                                  
 35155                                  ;;;; $ENDIF					;;AN000;;
 35156                                  $MEN204:
 35157                                  ;;; $ENDIF					;;AN000;;
 35158                                  $MEN202:
 35159                                  ;; $ENDIF					;;AN000;;
 35160                                  $MEN200:
 35161                                  
 35162                                  ;; With the replace information of the Stack, display the replaceable field
 35163                                  
 35164 00005A5D E85F00                  	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace
 35165                                  
 35166                                  ;; None of the above - Extended/Parse replace
 35167                                  ; $ELSE 					;;AN000;;
 35168 00005A60 EB03                    	jmp	short $MEN199
 35169                                  $MIF199:
 35170 00005A62 E81600                  	call	$M_EXT_PAR_REPLACE		;;AN000;;
 35171                                  ; $ENDIF					;;AN000;;
 35172                                  $MEN199:
 35173                                  
 35174                                  ;; We must go back and complete the message after the replacable parameter if there is any left
 35175                                  
 35176                                  ; $IF NC					;;AN000;; IF there was an error displaying then EXIT
 35177 00005A65 7207                    	jc	short $MIF211
 35178                                  	;
 35179 00005A67 59                      	pop	cx				;;AN000;; Get size of the rest of the message
 35180 00005A68 07                      	pop	es				;;AN000;; Get address of the rest of the message
 35181 00005A69 5F                      	pop	di				;;AN000;;
 35182 00005A6A 5D                      	pop	bp				;;AN000;; Get replacment count
 35183 00005A6B 5E                      	pop	si				;;AN000;; ELSE get address of first sublist structure
 35184                                  ; $ELSE						;;AN000;;
 35185 00005A6C EB03                    	jmp	short $MEN211
 35186                                  $MIF211:
 35187 00005A6E 83C40A                  	add	sp,10				;;AN000;; Clean up stack if error
 35188                                  	; 28/04/2023
 35189                                  	;stc					;;AN000;;
 35190                                  ; $ENDIF					;;AN000;;
 35191                                  $MEN211:
 35192 00005A71 833E[659A]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 35193                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 35194                                  ; $ENDDO NE,OR					;;AN000;;
 35195 00005A76 758C                    	jne	short $MLL214
 35196                                  ; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
 35197                                  	; 10/04/2023
 35198                                  	;jc	short $MXL4
 35199 00005A78 E90EFF                  	jmp	$MDO165
 35200                                  
 35201                                  ; 28/04/2023
 35202                                  ;$MXL4:
 35203                                  ;$MLL214:
 35204                                  ;$MEN165:
 35205                                  ;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 35206                                  ;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 35207                                  ;						;;AN000;; Reset message number to null
 35208                                  ;	retn					;;AN000;; Return
 35209                                  
 35210                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35211                                  ;;
 35212                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
 35213                                  ;;
 35214                                  ;;	FUNCTION:
 35215                                  ;;	INPUTS:
 35216                                  ;;	OUPUTS:
 35217                                  ;;
 35218                                  ;;	REGS USED:
 35219                                  ;;
 35220                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35221                                  
 35222                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35223                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35224                                  
 35225                                  $M_EXT_PAR_REPLACE:
 35226 00005A7B 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 35227 00005A7D A1[659A]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 35228                                  	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
 35229 00005A80 C706[679A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35230                                  	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
 35231 00005A86 E8B2FE                  	call	$M_CONVERT2ASC			;;AN000;;
 35232                                  $MDO215:
 35233 00005A89 58                      	pop	ax				;;AN000;; Get character in register
 35234 00005A8A 8887[699A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35235                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 35236 00005A8E 43                      	inc	bx				;;AN000;; Increase buffer count
 35237 00005A8F 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 35238 00005A92 7503                    	jne	short $MIF216			;;AN000;; No
 35239 00005A94 E80D00                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35240                                  $MIF216:
 35241 00005A97 FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 35242 00005A99 75EE                    	jnz	short $MDO215
 35243                                  
 35244 00005A9B B80D0A                  	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
 35245 00005A9E 8987[699A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
 35246                                  	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
 35247 00005AA2 43                      	inc	bx				;;AN000;; Increase buffer count
 35248 00005AA3 43                      	inc	bx				;;AN000;; Increase buffer count
 35249                                  	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35250                                  	;retn					;;AN000::
 35251                                  	; 11/04/2023
 35252                                  	;jmp	$M_FLUSH_BUF
 35253                                  
 35254                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35255                                  ;;
 35256                                  ;;	PROC NAME: $M_FLUSH_BUFFER
 35257                                  ;;
 35258                                  ;;	FUNCTION: Display the contents of the temporary buffer
 35259                                  ;;	INPUTS: DI contains the number of bytes to display
 35260                                  ;;	OUTPUTS: BX reset to zero
 35261                                  ;;
 35262                                  ;;	REGS USED:
 35263                                  ;;
 35264                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35265                                  	
 35266                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35267                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h
 35268                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35269                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5E95h
 35270                                  $M_FLUSH_BUF:
 35271 00005AA4 51                      	push	cx				;;AN000;; Save changed regs
 35272 00005AA5 06                      	push	es				;;AN000;;
 35273 00005AA6 57                      	push	di				;;AN000;;
 35274 00005AA7 1E                      	push	ds				;;AN000;; Set ES pointing to buffer
 35275 00005AA8 07                      	pop	es				;;AN000;;
 35276 00005AA9 89D9                    	mov	cx,bx				;;AN000;; Set number of bytes to display
 35277 00005AAB 31DB                    	xor	bx,bx				;;AN000;; Reset buffer counter
 35278 00005AAD 8D3E[699A]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35279                                  	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
 35280 00005AB1 E86DFD                  	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
 35281 00005AB4 7204                    	jc	short $MIF314
 35282 00005AB6 5F                      	pop	di				;;AN000;; No, Restore changed regs
 35283 00005AB7 07                      	pop	es				;;AN000;;
 35284 00005AB8 59                      	pop	cx				;;AN000;;
 35285                                  	;jmp	short $MEN314
 35286                                  	; 11/04/2023
 35287 00005AB9 C3                      	retn
 35288                                  $MIF314:
 35289 00005ABA 83C406                  	add	sp,6				;;AN000;; Fix stack
 35290 00005ABD F9                      	stc					;;AN000;;
 35291                                  $MEN314:
 35292 00005ABE C3                      	retn					;;AN000;; Return
 35293                                  
 35294                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35295                                  ;;
 35296                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35297                                  
 35298                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35299                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h
 35300                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35301                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5DD6h
 35302                                  $M_DISPLAY_REPLACE:
 35303 00005ABF 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 35304                                  	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
 35305 00005AC1 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
 35306                                  	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
 35307 00005AC5 7511                    	jne	short $MIF276
 35308                                  	
 35309 00005AC7 C787[699A]202D          	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
 35310                                  	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
 35311                                  	
 35312 00005ACD 43                      	inc	bx				;;AN000;; Increment count
 35313 00005ACE 43                      	inc	bx				;;AN000;; Increment count
 35314                                  	
 35315 00005ACF C687[699A]20            	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h ; $M_SPACE
 35316                                  	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
 35317                                  	
 35318 00005AD4 43                      	inc	bx				;;AN000;; Increment count
 35319 00005AD5 E8CCFF                  	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
 35320                                  $MIF276:
 35321 00005AD8 5D                      	pop	bp				;;AN000;; Remember the return address
 35322 00005AD9 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 35323 00005ADB 31D2                    	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack
 35324                                  
 35325 00005ADD 880E[5F9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
 35326                                  	;mov	[$M_RT+66],cl
 35327                                  	
 35328                                  	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
 35329 00005AE1 8A4409                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
 35330                                  	;mov	al,[si+9]
 35331                                  	
 35332 00005AE4 38C8                    	cmp	al,cl				;;AN000;; Do we need pad chars added?
 35333 00005AE6 761E                    	jna	short $MIF278
 35334 00005AE8 28C8                    	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
 35335 00005AEA 88C6                    	mov	dh,al				;;AN000;; Save the number of pad characters
 35336                                  	
 35337                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 35338 00005AEC F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 35339                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
 35340 00005AF0 7414                    	jz	short $MIF279			;;AN000;; No
 35341                                  $MDO280:
 35342                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 35343 00005AF2 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 35344                                  	;mov	al,[si+0Ah]
 35345 00005AF5 8887[699A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35346                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 35347                                  	
 35348 00005AF9 43                      	inc	bx				;;AN000;;
 35349 00005AFA 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
 35350 00005AFD 7503                    	jne	short $MIF281
 35351 00005AFF E8A2FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35352                                  $MIF281:
 35353 00005B02 FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 35354 00005B04 75EC                    	jnz	short $MDO280
 35355                                  $MIF279:
 35356                                  $MIF278:
 35357                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
 35358 00005B06 807C0800                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
 35359                                  	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
 35360 00005B0A 740C                    	je	short $MIF286
 35361                                  	
 35362                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
 35363 00005B0C 384C08                  	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
 35364                                  	;;cmp	byte [si+8],cl
 35365 00005B0F 7307                    	jnb	short $MIF287
 35366                                  
 35367                                  	; 03/05/2023
 35368                                  	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
 35369                                  	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 35370                                  	;;sub	cl,[si+8]
 35371 00005B11 88CA                    	mov	dl,cl				;;AN000;; Remember how many chars to pop off
 35372                                  	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
 35373                                  	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 35374                                  	;;mov	cl,[si+8]
 35375                                  	; 03/05/2023
 35376 00005B13 8A4C08                  	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 35377 00005B16 28CA                    	sub	dl,cl
 35378                                  $MIF287:
 35379                                  $MIF286:
 35380 00005B18 09C9                    	or	cx,cx				;;AN000;;
 35381 00005B1A 7424                    	jz	short $MIF290			;;AN000;;
 35382                                  $MDO291:
 35383                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
 35384 00005B1C F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 35385                                  	;test	byte [si+7],0Fh			;;AN000;;
 35386 00005B20 750C                    	jnz	short $MIF292
 35387                                  
 35388                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 35389 00005B22 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35390                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
 35391 00005B26 7406                    	jz	short $MIF292			;;AN000;; No
 35392                                  
 35393 00005B28 268A05                  	mov	al,[es:di]			;;AN000;; Get first character from string
 35394 00005B2B 47                      	inc	di				;;AN000;; Next character in string
 35395 00005B2C EB01                    	jmp	short $MEN292
 35396                                  $MIF292:
 35397 00005B2E 58                      	pop	ax				;;AN000;; Get character in register
 35398                                  $MEN292:
 35399                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 35400 00005B2F 8887[699A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35401                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 35402                                  	; 03/05/2023
 35403 00005B33 43                      	inc	bx				;;AN000;; Increase buffer count
 35404 00005B34 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 35405 00005B37 7503                    	jne	short $MIF295			;;AN000;;
 35406 00005B39 E868FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35407                                  $MIF295:
 35408 00005B3C FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 35409 00005B3E 75DC                    	jnz	short $MDO291
 35410                                  $MIF290:
 35411                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 35412 00005B40 F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 35413                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
 35414 00005B44 7518                    	jnz	short $MIF299			;;AN000;; Yes
 35415 00005B46 08F6                    	or	dh,dh				;;AN000;; Do we need pad chars added?
 35416 00005B48 7414                    	jz	short $MIF300
 35417                                  $MDO301:
 35418                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 35419 00005B4A 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 35420                                  	;mov	al,[si+0Ah]
 35421                                  
 35422                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 35423 00005B4D 8887[699A]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 35424                                  	; 03/05/2023
 35425                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 35426                                  
 35427 00005B51 43                      	inc	bx				;;AN000;;
 35428 00005B52 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
 35429 00005B55 7503                    	jne	short $MIF302			;;AN000;; No
 35430                                  						;;AN000;; Yes
 35431 00005B57 E84AFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 35432                                  $MIF302:
 35433 00005B5A FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 35434 00005B5C 75EC                    	jnz	short $MDO301			;;AN000;;
 35435                                  $MIF300:
 35436                                  $MIF299:
 35437                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 35438 00005B5E F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 35439                                  	;test	byte [si+7],0Fh			;;AN000;;
 35440 00005B62 7506                    	jnz	short $MIF307
 35441                                  	
 35442                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 35443 00005B64 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35444                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
 35445                                  	; 11/04/2023
 35446                                  	;jz	short $MIF307			;;AN000;;
 35447                                  	;jmp	short $MEN307			;;AN000;;
 35448 00005B68 750C                    	jnz	short $MEN307
 35449                                  $MIF307:
 35450 00005B6A 08D2                    	or	dl,dl				;;AN000;;
 35451 00005B6C 7408                    	jz	short $MIF309			;;AN000;;
 35452                                  $MDO310:
 35453 00005B6E 8F06[639A]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 35454                                  	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
 35455 00005B72 FECA                    	dec	dl				;;AN000;; Are we done?
 35456 00005B74 75F8                    	jnz	short $MDO310
 35457                                  $MIF309:
 35458                                  $MEN307:
 35459 00005B76 E82BFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
 35460 00005B79 55                      	push	bp				;;AN000;; Restore the return address
 35461 00005B7A C3                      	retn					;;AN000;;
 35462                                  
 35463                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35464                                  ;;
 35465                                  ;;	PROC NAME: $M_CHAR_REPLACE
 35466                                  ;;
 35467                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
 35468                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35469                                  ;;		ES:DI contains the VALUE from SUBLIST
 35470                                  ;;	OUTPUTS: CX contains number of characters on stack
 35471                                  ;;		 Top of stack  --> Last character
 35472                                  ;;					. . .
 35473                                  ;;		 Bot of stack  --> First character
 35474                                  ;;
 35475                                  ;;	OTHER REGS Revised: AX
 35476                                  ;;
 35477                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35478                                  
 35479                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35480                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35481                                  $M_CHAR_REPLACE:
 35482 00005B7B 5D                      	pop	bp				;;AN000;; Save return address
 35483                                  	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
 35484 00005B7C F6440730                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
 35485                                  	;test	byte [si+7],30h			;;AN000;; Was Character specified?
 35486 00005B80 7512                    	jnz	short $MIF317			;;AN000;; No
 35487 00005B82 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 35488 00005B85 50                      	push	ax				;;AN000;; Put it on the stack
 35489 00005B86 41                      	inc	cx				;;AN000;; Increase the count
 35490 00005B87 E88DFD                  	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
 35491 00005B8A 7306                    	jnc	short $MIF318
 35492 00005B8C 268A4501                	mov	al,[es:di+1]			;;AN000;; Get the next character
 35493 00005B90 50                      	push	ax				;;AN000;; Put it on the stack
 35494 00005B91 F8                      	clc					;;AN000;; Clear the carry
 35495                                  $MIF318:
 35496 00005B92 EB0D                    	jmp	short $MEN317
 35497                                  $MIF317:
 35498                                  $MDO321:
 35499 00005B94 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 35500 00005B97 08C0                    	or	al,al				;;AN000;; Is it the NULL?
 35501 00005B99 7404                    	jz	short $MEN321			;;AN000;; Yes
 35502 00005B9B 47                      	inc	di				;;AN000;; Next character
 35503 00005B9C 41                      	inc	cx				;;AN000;; Increment the count
 35504 00005B9D EBF5                    	jmp	short $MDO321
 35505                                  $MEN321:
 35506 00005B9F 29CF                    	sub	di,cx				;;AN000;; Set DI at the beginning of the string
 35507                                  $MEN317:
 35508 00005BA1 55                      	push	bp				;;AN000;; Restore return address
 35509 00005BA2 C3                      	retn					;;AN000;;	
 35510                                  
 35511                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35512                                  ;;
 35513                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
 35514                                  ;;
 35515                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
 35516                                  ;;		  and prepare to display
 35517                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35518                                  ;;		ES:DI contains the VALUE from SUBLIST
 35519                                  ;;	OUTPUTS: CX contains number of characters on stack
 35520                                  ;;		 Top of stack  --> Last character
 35521                                  ;;					. . .
 35522                                  ;;		 Bot of stack  --> First character
 35523                                  ;;	OTHER REGS Revised: BX,DX,AX
 35524                                  ;;
 35525                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35526                                  
 35527                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35528                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35529                                  $M_BIN2ASC_REPLACE:
 35530 00005BA3 5D                      	pop	bp				;;AN000;; Save return address
 35531 00005BA4 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 35532 00005BA6 31C0                    	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
 35533 00005BA8 C706[679A]1000          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
 35534                                  	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor
 35535                                  
 35536 00005BAE 31DB                    	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)
 35537                                  
 35538                                  	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
 35539 00005BB0 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35540                                  	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
 35541 00005BB4 7511                    	jnz	short $MIF325			;;AN000;; No
 35542                                  	
 35543 00005BB6 268A05                  	mov	al,[es:di]			;;AN000;; Setup byte in AL
 35544                                  
 35545                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35546 00005BB9 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35547                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
 35548 00005BBD 753D                    	jnz	short $MIF326			;;AN000;; No
 35549                                  			 
 35550 00005BBF A880                    	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
 35551 00005BC1 7433                    	jz	short $MIF327			;;AN000;; No
 35552                                  						;;AN000;; Yes				
 35553                                  	; 12/04/2023
 35554                                  	;inc	bx				;;AN000;; Remember that it was negative
 35555 00005BC3 247F                    	and	al,01111111b			;;AN000;; Make it positive
 35556                                  
 35557                                  	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
 35558                                  	;jmp	short $MIF327
 35559 00005BC5 EB2E                    	jmp	short $MIF350 ; inc bx
 35560                                  
 35561                                  ; 12/04/2023
 35562                                  %if 0
 35563                                  
 35564                                  $MIF327:
 35565                                  $MIF335:	; 12/04/2023
 35566                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35567                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35568                                  $MIF326:
 35569                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35570                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35571                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35572                                  	jnz	short $MIF330			;;AN000;; No
 35573                                  						;;AN000;; Yes
 35574                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35575                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35576                                  $MIF330:
 35577                                  	jmp	short $MEN325
 35578                                  
 35579                                  %endif
 35580                                  
 35581                                  $MIF325:
 35582                                  	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
 35583 00005BC7 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35584                                  	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
 35585 00005BCB 7513                    	jnz	short $MIF333			;;AN000;; No
 35586                                  						;;AN000;; Yes
 35587 00005BCD 268B05                  	mov	ax,[es:di]			;;AN000;; Setup byte in AL
 35588                                  
 35589                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35590 00005BD0 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35591                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35592 00005BD4 7526                    	jnz	short $MIF334			;;AN000;; No
 35593                                  						;;AN000;; Yes
 35594 00005BD6 F6C480                  	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
 35595 00005BD9 741B                    	jz	short $MIF335			;;AN000;; No
 35596                                  						;;AN000;; Yes
 35597                                  	; 12/04/2023
 35598                                  	;inc	bx				;;AN000;; Remember that it was negative
 35599 00005BDB 80E47F                  	and	ah,01111111b			;;AN000;; Make it positive
 35600                                  
 35601                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35602                                  	;jmp	short $MIF335
 35603 00005BDE EB15                    	jmp	short $MIF350 ; inc bx
 35604                                  
 35605                                  ; 12/04/2023
 35606                                  %if 0
 35607                                  
 35608                                  $MIF335:
 35609                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35610                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35611                                  $MIF334:
 35612                                  	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
 35613                                  	jnz	short $MIF338
 35614                                  
 35615                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35616                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35617                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35618                                  	jnz	short $MIF338			;;AN000;; No
 35619                                  						;;AN000;; Yes
 35620                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35621                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35622                                  $MIF338:
 35623                                  	jmp	short $MEN333			;;AN000;;
 35624                                  %endif
 35625                                  
 35626                                  $MIF333:
 35627 00005BE0 268B05                  	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
 35628 00005BE3 268B5502                	mov	dx,[es:di+2]			;;AN000;;
 35629                                  
 35630                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 35631 00005BE7 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 35632                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 35633 00005BEB 750F                    	jnz	short $MIF341			;;AN000;; No
 35634                                  						;;AN000;; Yes
 35635 00005BED F6C680                  	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
 35636 00005BF0 7404                    	jz	short $MIF342			;;AN000;; No
 35637                                  						;;AN000;; Yes
 35638                                  	; 12/04/2023
 35639                                  	;inc	bx				;;AN000;; Remember that it was negative
 35640 00005BF2 80E67F                  	and	dh,01111111b			;;AN000;; Make it positive
 35641                                  	
 35642                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 35643                                  $MIF350:
 35644 00005BF5 43                      	inc	bx
 35645                                  $MIF342:
 35646                                  	; 12/04/2023
 35647                                  $MIF327:
 35648                                  $MIF335:
 35649 00005BF6 C706[679A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35650                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35651                                  $MIF341:
 35652                                  $MIF326:
 35653                                  	; 18/04/2023
 35654                                  $MIF334:
 35655                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 35656 00005BFC F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 35657                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 35658 00005C00 7506                    	jnz	short $MIF345			;;AN000;; No
 35659                                  						;;AN000;; Yes
 35660 00005C02 C706[679A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35661                                  	;mov	word [$M_RT+74],10		;;AN000;;
 35662                                  
 35663                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35664                                  	; ****************************************
 35665                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:5F64h
 35666                                  $MIF345:
 35667                                  	; *** (Disassembled MSDOS 6.22 COMMAND.COM source code.)
 35668                                  $MEN333:
 35669 00005C08 F6440740                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],40h
 35670                                  	;test	byte [si+7],40h		; MSDOS 6.22
 35671                                  				; (Custom/International flag for thousand separator)
 35672 00005C0C 7428                    	jz	short $MEN325
 35673 00005C0E 50                      	push	ax			; MSDOS 6.22
 35674 00005C0F 52                      	push	dx
 35675 00005C10 B438                    	mov	ah,38h	 ; International
 35676 00005C12 30C0                    	xor	al,al
 35677 00005C14 8D16[699A]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35678 00005C18 CD21                    	int	21h		; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 35679                                  				; get current-country info
 35680                                  				; DS:DX -> buffer for returned info
 35681 00005C1A 7305                    	jnb	short $MEN341		; (use country depended thousand separator)
 35682 00005C1C C606[709A]2C            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA],','
 35683                                  $MEN341:
 35684 00005C21 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 35685                                  	;mov	al,[si+0Ah]		; (save pad character)
 35686 00005C24 89C7                    	mov	di,ax
 35687 00005C26 5A                      	pop	dx
 35688 00005C27 58                      	pop	ax
 35689 00005C28 C6440A2C                	mov	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','  ; $M_COMMA
 35690                                  	;mov	byte [si+0Ah],','	; (comma is needed for converting procedure)
 35691 00005C2C E80CFD                  	call	$M_CONVERT2ASC
 35692 00005C2F 89F8                    	mov	ax,di
 35693 00005C31 88440A                  	mov	[si+$M_SUBLIST_STRUC.$M_S_PAD],al
 35694                                  	;mov	[si+0Ah],al		; (restore pad character)
 35695 00005C34 EB03                    	jmp	short $MEN345		; MSDOS 6.22
 35696                                  	; *** (end of disassembled MSDOS 6.22 COMMAND.COM source code porehion) 
 35697                                  	; ****************************************
 35698                                  ;$MIF345:
 35699                                  ;$MEN333:
 35700                                  $MEN325:
 35701 00005C36 E802FD                  	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string
 35702                                  $MEN345: 	; 15/06/2023 - MSDOS 6.22
 35703 00005C39 09DB                    	or	bx,bx				;;AN000;; Was number negative?
 35704 00005C3B 7405                    	jz	short $MIF349			;;AN000;; No
 35705                                  						;;AN000;; Yes
 35706 00005C3D 31D2                    	xor	dx,dx				;;AN000;;
 35707 00005C3F B22D                    	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
 35708 00005C41 52                      	push	dx				;;AN000;;
 35709                                  $MIF349:
 35710 00005C42 55                      	push	bp				;;AN000;; Restore return address
 35711 00005C43 C3                      	retn					;;AN000;; Return
 35712                                  
 35713                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35714                                  ;;
 35715                                  ;;	PROC NAME: $M_DATE_REPLACE
 35716                                  ;;
 35717                                  ;;	FUNCTION: Convert a date to a decimal ASCII string using current
 35718                                  ;;		  country format and prepare to display
 35719                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35720                                  ;;		ES:DI points at VALUE from SUBLIST
 35721                                  ;;	OUTPUTS: CX contains number of characters on stack
 35722                                  ;;		 Top of stack  --> Last character
 35723                                  ;;					. . .
 35724                                  ;;		 Bot of stack  --> First character
 35725                                  ;;	OTHER REGS Revised: DX,AX
 35726                                  ;;
 35727                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35728                                  
 35729                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35730                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35731                                  $M_DATE_REPLACE:
 35732 00005C44 5D                      	pop	bp				;;AN000;; Save return address
 35733                                  
 35734 00005C45 C706[679A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35735                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35736                                  	
 35737 00005C4B E86700                  	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
 35738                                  						;;AN000;; All O.K.?
 35739 00005C4E 31D2                    	xor	dx,dx				;;AN000;; Reset DX value
 35740                                  	; 12/04/2023
 35741                                  	;xor	ax,ax				;;AN000;; Reset AX value
 35742                                  	
 35743                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
 35744                                  	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
 35745                                  	;jne	short $MIF351
 35746                                  	; 12/04/2023
 35747 00005C50 A1[699A]                	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35748 00005C53 09C0                    	or	ax,ax
 35749 00005C55 751D                    	jnz	short $MIF351
 35750                                  
 35751 00005C57 E87200                  	call	$M_YEAR				;;AN000;; Get Year
 35752 00005C5A E88100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35753                                  
 35754 00005C5D FF36[749A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35755                                  	;push	word [$M_RT+87]			;;AN000;;
 35756                                  	
 35757 00005C61 41                      	inc	cx				;;AN000;; Increment count
 35758 00005C62 31C0                    	xor	ax,ax				;;AN000;; Reset AX value
 35759                                  
 35760 00005C64 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35761                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35762 00005C67 E87400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35763                                  	
 35764 00005C6A FF36[749A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35765                                  	;push	word [$M_RT+87]			;;AN000;;
 35766                                  
 35767 00005C6E 41                      	inc	cx				;;AN000;; Increment count
 35768 00005C6F 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35769                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35770                                  	; 12/04/2023
 35771                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35772 00005C72 EB3C                    	jmp	short $MIF354 ; **
 35773                                  $MIF351:
 35774                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
 35775                                  	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
 35776                                  	;jne	short $MIF353
 35777                                  	; 12/04/2023
 35778                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 35779 00005C74 48                      	dec	ax 
 35780 00005C75 751D                    	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1
 35781                                  
 35782 00005C77 E85200                  	call	$M_YEAR				;;AN000;; Get Year
 35783 00005C7A E86100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35784                                  
 35785 00005C7D FF36[749A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35786                                  	;push	word [$M_RT+87]			;;AN000;;
 35787                                  	
 35788 00005C81 41                      	inc	cx				;;AN000;; Increment count
 35789 00005C82 31C0                    	xor	ax,ax				;;AN000;; Reset AX
 35790                                  
 35791 00005C84 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35792                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35793 00005C87 E85400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35794                                  
 35795 00005C8A FF36[749A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35796                                  	;push	word [$M_RT+87]			;;AN000;;
 35797                                  
 35798 00005C8E 41                      	inc	cx				;;AN000;;
 35799                                  	      
 35800 00005C8F 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35801                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35802                                  
 35803                                  	; 12/04/2023
 35804                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35805 00005C92 EB1C                    	jmp	short $MIF354 ; **
 35806                                  	; 12/04/2023
 35807                                  $MIF352:
 35808                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
 35809 00005C94 48                      	dec	ax
 35810                                  	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
 35811                                  	;xor	ax,ax
 35812                                  	;jmp	short $MIF355
 35813                                  	; 12/04/2023
 35814 00005C95 751C                    	jnz	short $MIF355
 35815                                  $MIF353:
 35816                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
 35817                                  	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
 35818                                  	;jne	short $MIF355
 35819                                  
 35820 00005C97 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35821                                  	;mov	al,[si+5]			;;AN000;; Get Day
 35822 00005C9A E84100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35823                                  	
 35824 00005C9D FF36[749A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35825                                  	;push	word [$M_RT+87]			;;AN000;;
 35826                                  
 35827 00005CA1 41                      	inc	cx				;;AN000;;
 35828                                  
 35829 00005CA2 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35830                                  	;mov	al,[si+4]			;;AN000;; Get Month
 35831 00005CA5 E83600                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 35832                                  	
 35833 00005CA8 FF36[749A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 35834                                  	;push	word [$M_RT+87]			;;AN000;;
 35835                                  	
 35836 00005CAC 41                      	inc	cx				;;AN000;;
 35837                                  
 35838 00005CAD E81C00                  	call	$M_YEAR				;;AN000;; Get Year
 35839                                  	; 12/04/2023
 35840                                  $MIF354:
 35841 00005CB0 E82B00                  	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
 35842                                  $MIF355:
 35843 00005CB3 55                      	push	bp				;;AN000;; Restore return address
 35844 00005CB4 C3                      	retn					;;AN000;; Return
 35845                                  
 35846                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35847                                  ;;
 35848                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35849                                  
 35850                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35851                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35852                                  $M_GET_DATE:
 35853                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35854                                  	;mov	al,0 				;;AN000;; Get current country info
 35855                                  	; 12/04/2023
 35856 00005CB5 B80038                  	mov	ax,3800h
 35857                                  	;
 35858 00005CB8 8D16[699A]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35859                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35860 00005CBC CD21                    	int	21h				;;AN000;;
 35861 00005CBE 730B                    	jnc	short $MIF357
 35862                                  	;
 35863 00005CC0 C706[699A]0000          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
 35864                                  	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
 35865 00005CC6 C606[749A]2D            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
 35866                                  	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
 35867                                  $MIF357:
 35868 00005CCB C3                      	retn					;;AN000;;
 35869                                  
 35870                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35871                                  ;;
 35872                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35873                                  
 35874                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35875                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35876                                  $M_YEAR:
 35877 00005CCC 8B4402                  	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35878                                  	;mov	ax,[si+2]			;;AN000;; Get Year
 35879                                  
 35880                                  	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
 35881 00005CCF F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35882                                  	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
 35883 00005CD3 7508                    	jnz	short $MIF359			;;AN000;; No
 35884                                  						;;AN000;; Yes
 35885 00005CD5 83F863                  	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35886 00005CD8 7603                    	jna	short $MIF360			;;AN000;;
 35887 00005CDA B86300                  	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 35888                                  $MIF360:
 35889                                  $MIF359:
 35890 00005CDD C3                      	retn					;;AN000;;
 35891                                  
 35892                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35893                                  ;;
 35894                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35895                                  
 35896                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35897                                  $M_CONVERTDATE:
 35898                                  $M_CONVERTTIME: ; *!*!  ; 12/04/2023
 35899 00005CDE 8F06[699A]              	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35900                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35901 00005CE2 880E[5F9A]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35902                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35903 00005CE6 E852FC                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35904 00005CE9 49                      	dec	cx				;;AN000;; Test if size only grew by 1
 35905 00005CEA 3A0E[5F9A]              	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35906 00005CEE 7505                    	jne	short $MIF363			;;AN000;; No
 35907 00005CF0 B83000                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35908 00005CF3 50                      	push	ax				;;AN000;; Save it
 35909 00005CF4 41                      	inc	cx				;;AN000;; Count it
 35910                                  $MIF363:
 35911 00005CF5 41                      	inc	cx				;;AN000;; Restore CX
 35912 00005CF6 FF36[699A]              	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35913                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35914 00005CFA C3                      	retn
 35915                                  
 35916                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35917                                  ;;
 35918                                  ;;	PROC NAME: $M_TIME_REPLACE
 35919                                  ;;
 35920                                  ;;	FUNCTION: Convert a time to a decimal ASCII string
 35921                                  ;;		  and prepare to display
 35922                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35923                                  ;;		ES:DI points at VALUE from SUBLIST
 35924                                  ;;	OUTPUTS: CX contains number of characters on stack
 35925                                  ;;		 Top of stack  --> Last character
 35926                                  ;;					. . .
 35927                                  ;;		 Bot of stack  --> First character
 35928                                  ;;	REGS USED: BP,CX,AX
 35929                                  ;;
 35930                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35931                                  
 35932                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35933                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 35934                                  	; 13/08/2024							     ;;
 35935                                  $M_TIME_REPLACE:
 35936 00005CFB 5D                      	pop	bp				;;AN000;; Save return address
 35937                                  
 35938 00005CFC C706[679A]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35939                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35940                                  
 35941 00005D02 E87700                  	call	$M_GET_TIME			;;AN000;; All O.K.?
 35942                                  
 35943                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35944 00005D05 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
 35945                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35946 00005D09 741A                    	jz	short $MIF365			;;AN000;; No
 35947                                  						;;AN000;; Yes
 35948 00005D0B 803E[7A9A]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35949                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35950 00005D10 7513                    	jne	short $MIF366			;;AN000;; No
 35951                                  						;;AN000;; Yes
 35952 00005D12 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35953                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35954 00005D15 3C0C                    	cmp	al,12				;;AN000;; Is hour 12 or less?
 35955 00005D17 7C04                    	jl	short $MLL367 ; jnge		;;AN000;; Yes	
 35956 00005D19 3C17                    	cmp	al,23				;;AN000;; Is hour 24 or greater?
 35957 00005D1B 7E04                    	jng	short $MIF367 ; jle		;;AN000;; No
 35958                                  $MLL367:
 35959 00005D1D B061                    	mov	al,'a'	; $M_AM			;;AN000;;
 35960                                  	;push	ax				;;AN000;; Push an "a" to represent AM.
 35961                                  	;inc	cx				;;AN000;;
 35962                                  	;jmp	short $MEN367			;;AN000;;
 35963                                  	; 12/04/2023
 35964 00005D1F EB02                    	jmp	short $MEN367 ; *
 35965                                  $MIF367:
 35966 00005D21 B070                    	mov	al,'p'	; $M_PM			;;AN000;;
 35967                                  $MEN367:	; * ; 12/04/2023
 35968 00005D23 50                      	push	ax				;;AN000;; Push an "p" to represent PM.
 35969 00005D24 41                      	inc	cx				;;AN000;;
 35970                                  ;$MEN367:
 35971                                  $MIF366:
 35972                                  $MIF365:					;;AN000;;
 35973 00005D25 31C0                    	xor	ax,ax				;;AN000;;
 35974                                  	;xor	dx,dx				;;AN000;;
 35975                                  	; 13/08/2024
 35976 00005D27 99                      	cwd	; PCDOS 7.1 COMMAND.COM
 35977                                  	
 35978                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35979 00005D28 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35980                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35981 00005D2C 740B                    	jz	short $MIF372			;;AN000;;
 35982                                  
 35983 00005D2E 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35984                                  	;mov	al,[si+5]			;;AN000;; Get Hundreds
 35985 00005D31 E8AAFF                  	call	$M_CONVERTTIME			;;AN000;;
 35986                                  
 35987 00005D34 FF36[729A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
 35988                                  	;push	word [$M_RT+85]			;;AN000;;
 35989 00005D38 41                      	inc	cx				;;AN000;;
 35990                                  $MIF372:
 35991                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35992 00005D39 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35993                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35994 00005D3D 7506                    	jnz	short $MLL374			;;AN000;; No
 35995                                  
 35996                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
 35997 00005D3F F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35998                                  	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
 35999 00005D43 740B                    	jz	short $MIF374			;;AN000;; No
 36000                                  $MLL374:
 36001 00005D45 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 36002                                  	;mov	al,[si+4]			;;AN000;; Get Seconds
 36003 00005D48 E893FF                  	call	$M_CONVERTTIME			;;AN000;;
 36004                                  
 36005 00005D4B FF36[769A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 36006                                  	;push	word [$M_RT+89]			;;AN000;;
 36007 00005D4F 41                      	inc	cx				;;AN000;;
 36008                                  $MIF374:	;;  Do Hour/Min (12 Hour)
 36009 00005D50 8A4403                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
 36010                                  	;mov	al,[si+3]			;;AN000;; Get Minutes
 36011 00005D53 E888FF                  	call	$M_CONVERTTIME			;;AN000;;
 36012                                  
 36013 00005D56 FF36[769A]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 36014                                  	;push	word [$M_RT+89]			;;AN000;;
 36015 00005D5A 41                      	inc	cx				;;AN000;;
 36016                                  
 36017 00005D5B 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 36018                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 36019                                  
 36020                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 36021 00005D5E F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
 36022                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 36023 00005D62 7413                    	jz	short $MIF376			;;AN000;; No
 36024                                  
 36025 00005D64 803E[7A9A]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 36026                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 36027 00005D69 750C                    	jne	short $MIF377			;;AN000;; No
 36028                                  
 36029 00005D6B 3C0D                    	cmp	al,13				;;AN000;; Is hour less than 12?
 36030 00005D6D 7C02                    	jnge	short $MIF378 ; jl
 36031 00005D6F 2C0C                    	sub	al,12				;;AN000;; Set to a 12 hour value
 36032                                  $MIF378:
 36033                                  	;cmp	al,0				;;AN000;; Is hour less than 12?
 36034                                  	;jne	short $MIF380			;;AN000;; No
 36035                                  	; 12/04/2023
 36036 00005D71 20C0                    	and	al,al
 36037 00005D73 7502                    	jnz	short $MIF380	
 36038 00005D75 B00C                    	mov	al,12				;;AN000;; Set to a 12 hour value
 36039                                  $MIF380:
 36040                                  $MIF377:
 36041                                  $MIF376:
 36042 00005D77 E8C1FB                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
 36043 00005D7A 55                      	push	bp				;;AN000;; Restore return address
 36044 00005D7B C3                      	retn					;;AN000;; Return
 36045                                  
 36046                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 36047                                  ;;
 36048                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 36049                                  
 36050                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36051                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 36052                                  $M_GET_TIME:
 36053                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 36054                                  	;mov	al,0 				;;AN000;; Get current country info
 36055                                  	; 12/04/2023
 36056 00005D7C B80038                  	mov	ax,3800h
 36057                                  	;
 36058 00005D7F 8D16[699A]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 36059                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 36060 00005D83 CD21                    	int	21h				;;AN000;;
 36061 00005D85 7310                    	jnc	short $MIF384
 36062                                  
 36063 00005D87 C706[7A9A]0100          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
 36064                                  	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
 36065 00005D8D C606[769A]3A            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
 36066                                  	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
 36067 00005D92 C606[729A]2E            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
 36068                                  	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
 36069                                  $MIF384:
 36070 00005D97 C3                      	retn					;;AN000;;
 36071                                  
 36072                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 36073                                  ;;
 36074                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 36075                                  
 36076                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36077                                  
 36078                                  ; 12/04/2023 
 36079                                  ;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
 36080                                  %if 0
 36081                                  $M_CONVERTTIME:
 36082                                  $M_CONVERTDATE: ; *!*!  ; 12/04/2023
 36083                                  	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 36084                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 36085                                  	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 36086                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 36087                                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 36088                                  	dec	cx				;;AN000;; Test if size only grew by 1
 36089                                  	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 36090                                  	jne	short $MIF386			;;AN000;; No
 36091                                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 36092                                  	push	ax				;;AN000;; Save it
 36093                                  	inc	cx				;;AN000;; Count itount it
 36094                                  $MIF386:
 36095                                  	inc	cx				;;AN000;; Restore CX
 36096                                  	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 36097                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 36098                                  	retn
 36099                                  %endif
 36100                                  
 36101                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 36102                                  ;;
 36103                                  ;;	PROC NAME: $M_WAIT_FOR_INPUT
 36104                                  ;;
 36105                                  ;;	FUNCTION:  To accept keyed input and return extended key value
 36106                                  ;;		   in AX register
 36107                                  ;;	INPUTS:    DL contains the DOS function requested for input
 36108                                  ;;	OUTPUTS:   AX contains the extended key value that was read
 36109                                  ;;	REGS USED:
 36110                                  ;;
 36111                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 36112                                  
 36113                                  	; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 36114                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6123h
 36115                                  $M_WAIT_FOR_INPUT:
 36116 00005D98 51                      	push	cx				;;AN000;; Save CX
 36117 00005D99 52                      	push	dx				;;AN000;; Save DX
 36118 00005D9A 1E                      	push	ds				;;AN000;; Save Data segment
 36119                                  
 36120 00005D9B 80FAC0                  	cmp	dl,0C0h ; DOS_CLR_KEYB_BUF_MASK	;;AN001;; Are we to clear the keyboard buffer?
 36121 00005D9E 7608                    	jna	short $MIF388	; jbe		;;AN001;; No,
 36122                                  						;;AN001;; Yes,
 36123 00005DA0 88D0                    	mov	al,dl				;;AN001;; Mov function into AL
 36124 00005DA2 240F                    	and	al,0Fh	; LOW_NIB_MASK		;;AN001;; Mask out the C in high nibble
 36125 00005DA4 B40C                    	mov	ah,0Ch	; DOS_CLR_KEYB_BUF 	;;AN001;; Set input function
 36126 00005DA6 EB02                    	jmp	short $MEN388
 36127                                  $MIF388:
 36128 00005DA8 88D4                    	mov	ah,dl				;;AN000;; Put DOS function in AH
 36129                                  $MEN388:
 36130 00005DAA 06                      	push	es				;;AN000;; Get output buffer segment
 36131 00005DAB 1F                      	pop	ds				;;AN000;;
 36132 00005DAC 89FA                    	mov	dx,di				;;AN000;; Get output buffer offset in case needed
 36133 00005DAE CD21                    	int	21h				;;AN000;; Get keyboard input
 36134 00005DB0 1F                      	pop	ds				;;AN000;;
 36135 00005DB1 80FA0A                  	cmp	dl,0Ah	; DOS_BUF_KEYB_INP	;;AN000;;
 36136                                  	;clc					;;AN000;;
 36137 00005DB4 7412                    	je	short $MIF391
 36138 00005DB6 E85EFB                  	call	$M_IS_IT_DBCS			;;AN000;; Is this character DBCS?
 36139 00005DB9 730B                    	jnc	short $MIF392
 36140 00005DBB 88C1                    	mov	cl,al				;;AN000;; Save first character
 36141 00005DBD 88D4                    	mov	ah,dl				;;AN001;; Get back function
 36142 00005DBF CD21                    	int	21h				;;AN000;; Get keyboard input
 36143 00005DC1 88CC                    	mov	ah,cl				;;AN000;; Retrieve first character AX = xxxx
 36144 00005DC3 F8                      	clc					;;AN000;; Clear carry condition
 36145 00005DC4 EB02                    	jmp	short $MEN392
 36146                                  $MIF392:
 36147 00005DC6 B400                    	mov	ah,0				;;AN000;; AX = 00xx where xx is SBCS
 36148                                  $MEN392:
 36149                                  $MIF391:
 36150                                  	;jc	short $MIF396 ; 15/06/2023
 36151 00005DC8 5A                      	pop	dx				;;AN000;;
 36152 00005DC9 59                      	pop	cx				;;AN000;;
 36153                                  	;jmp	short $MEN396
 36154 00005DCA C3                      	retn
 36155                                  
 36156                                  	; 15/06/2023
 36157                                  ;$MIF396:
 36158                                  	;add	sp,4				;;AN000;;
 36159                                  	;stc					;;AN000;; Reset carry flag
 36160                                  ;$MEN396:
 36161                                  	;retn					;;AN000;; Return
 36162                                  
 36163                                  ; ----------------------------
 36164                                  ; MSDOS 6.0, TPRINTF.ASM, 1991
 36165                                  ; ----------------------------
 36166                                  ; include msgdcl.inc
 36167                                  ; ----------------------------
 36168                                  
 36169                                  ;============================================================================
 36170                                  ; HIGHLOAD.INC, MSDOS 6.0, 1992
 36171                                  ;============================================================================
 36172                                  ; 15/06/2023 - Retro DOS v4.2 COMMAND.COM
 36173                                  
 36174                                  ;****************************************************************************
 36175                                  ;
 36176                                  ; This file contains routines needed to parse and implement user-given
 36177                                  ; command-line options of the form "/S/L:3,0x500;2;7,127;0x0BE4". InitVar()
 36178                                  ; and Parsevar() are used to parse this data and place it in encoded form into
 36179                                  ; the variables in highvar.inc, for use by the rest of the routines.
 36180                                  ;
 36181                                  ; DeviceHigh accepts this command-line (handled in sysconf.asm, not here):
 36182                                  ;    DEVICEHIGH SIZE=hhhhhh module opts
 36183                                  ; Or, DeviceHigh and LoadHigh accept any of the following:
 36184                                  ;    DH/LH module opts
 36185                                  ;    DH/LH [/S][/L:umb[,size][;umb[,size]]*] module opts
 36186                                  ;    DH/LH [/L:umb[,size][;umb[,size]]*][/S] module opts
 36187                                  ; The initial UMB,SIZE pair designates the module's load address; the remainder
 36188                                  ; of the UMB and SIZE pairs are used to indicate specific UMBs to be left
 36189                                  ; available during the load.
 36190                                  ;
 36191                                  ; When an actual load is ready to be performed, a call to HideUMBs() will
 36192                                  ; temporarily allocate (as owner 8+"HIDDEN  ") all free elements in any
 36193                                  ; upper-memory block which was not specified by the user... in addition, if
 36194                                  ; UMBs were marked to shrink (/S option) to a certain size ("umb,size"), any
 36195                                  ; elements in that umb SAVE the lower-half of the newly-shrunken one are also
 36196                                  ; allocated.  After the load, the function UnHideUMBs() (in highexit.inc) will
 36197                                  ; free any UMBs so allocated.
 36198                                  ;
 36199                                  ; When a device driver loads, there is the additional problem of allocating its
 36200                                  ; initial load site; this should be restricted to the first UMB specified on
 36201                                  ; the command-line.  The function FreezeUM temporarily allocates all remaining
 36202                                  ; free upper-memory elements (as owner 8+"FROZEN  "), except those in the load
 36203                                  ; UMB.  Then the initial allocation may be made, and a call to UnFreeze will
 36204                                  ; return any so-allocated memory elements to FREE, for the true load.  Note
 36205                                  ; that UnFreeze leaves HIDDEN elements allocated; it only frees FROZEN ones.
 36206                                  ;
 36207                                  ;****************************************************************************
 36208                                  
 36209                                  ;___PROCEDURES_______________________________________________________________
 36210                                  ;
 36211                                  ;   AddrToUmb   - converts a segment address in AX to its appropriate UMB #
 36212                                  ;   BigFree     - makes ES:0 point to the largest free MCB in UMB given as AL
 36213                                  ;   FixMem      - scans the UM chain and concatenates adjacent free MCBs
 36214                                  ;   FreezeUM    - Marks FROZEN all UM elements now FREE, save those in load UMB
 36215                                  ;   GetLoadSize - Returns the load UMB minimum size (0 if not specified)
 36216                                  ;   GetLoadUMB  - Returns the load UMB number in AL (-1 if not specified)
 36217                                  ;   GetSize     - Returns the UMB in AL's minimum size (0 if not specified)
 36218                                  ;   GetXNum     - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
 36219                                  ;   HideUMBs    - links UMBs and hides upper-memory as appropriate
 36220                                  ;   InitVar     - initializes all the variables used in ParseVar and HideUMBs
 36221                                  ;   NextMCB     - moves an MCB pointer forward to the next MCB
 36222                                  ;   ParseVar    - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
 36223                                  ;   PrTable     - produces a printout of the variables in highvar.inc
 36224                                  ;   StoLoadSize - Overrides the load UMB minimum size with what's in AX
 36225                                  ;   StoLoadUMB  - Overrides the load UMB number with what's in AL
 36226                                  ;   UmbHead     - returns in AX the address of the first UMB block (0x9FFF)
 36227                                  ;   UnFreeze    - Marks FROZEN elements as FREE
 36228                                  ;
 36229                                  ;___VARIABLES________________________________________________________________
 36230                                  ;
 36231                                  ;   gnradix     - After a call to GetXNum, is 16 or 10, depending on the # read
 36232                                  ;
 36233                                  ;   Internal:
 36234                                  ;___PROCEDURES_______________________________________________________________
 36235                                  ;
 36236                                  ;   convUMB     - checks after GetXNum to convert an address to a UMB number
 36237                                  ;   findUMB     - makes ES:0 point to the first MCB in UMB given as AL
 36238                                  ;   fm_link     - links UMBs not already linked in
 36239                                  ;   fm_unlink   - unlinks UMBs if fm_umb is set to 0
 36240                                  ;   frezMCB     - marks as 8+FROZEN the MCB at ES:0
 36241                                  ;   hideMCB     - marks as HIDDEN the MCB at ES:0
 36242                                  ;   hideUMB     - marks as HIDDEN all FREE elements in UMB passed as AL
 36243                                  ;   hideUMB?    - hides as appropriate the UMB in CL
 36244                                  ;   hl_unlink   - unlinks UMBs if fm_umb is set to 0; restores strategy too
 36245                                  ;   incArgc     - increments fm_argc, for use with LH command-line parsing
 36246                                  ;   isEOL       - returns with ZF set iff AL contains CR or LF, or 0
 36247                                  ;   isFreeMCB   - returns with ZF set if current MCB (ES:0) is FREE
 36248                                  ;   isFrozMCB   - returns with ZF set if current MCB (ES:0) is FROZEN
 36249                                  ;   isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
 36250                                  ;   isSysMCB    - sets ZF iff ES points to an MCB owned by "SC" + (8 or 9)
 36251                                  ;   isTiny      - returns with ZF set if user didn't specify /S
 36252                                  ;   isWhite     - returns with ZF set iff AL contains whitespace (or "=")
 36253                                  ;   loadLow     - returns AL==0 if UMB0 == 0, else AL==1
 36254                                  ;   mul32       - multiplies the number in DX:AX by gnradix
 36255                                  ;   parseL      - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
 36256                                  ;   setUMBs     - links umbs and sets allocation strategy for a load
 36257                                  ;   shrinkMCB   - breaks an MCB into two pieces, the lowest one's size==AX
 36258                                  ;   stowSiz     - marks a given UMB as having a given minimum size
 36259                                  ;   stowUMB     - marks a given UMB as used, if it hasn't been so marked before
 36260                                  ;   toDigit     - converts a character-digit to its binary counterpart
 36261                                  ;   toPara      - divides DX:AX by 16; result in AX only
 36262                                  ;   toUpper     - accepts one argument (probly a register), and upper-cases it.
 36263                                  ;   unHideMCB   - marks as FREE the MCB at ES:0
 36264                                  ;   unMarkUMB   - marks a given UMB as unused, even if previously marked used
 36265                                  ;
 36266                                  ;****************************************************************************
 36267                                  
 36268                                  ;DOS_CHECK_STRATEGY equ 5800h ; Int 21h, Func 58h, Svc 0 = check alloc strat
 36269                                  ;DOS_SET_STRATEGY   equ 5801h ; Int 21h, Func 58h, Svc 1 = set alloc strategy
 36270                                  ;DOS_CHECK_UMBLINK  equ 5802h ; Int 21h, Func 58h, Svc 2 = check link state
 36271                                  ;DOS_SET_UMBLINK    equ 5803h ; Int 21h, Func 58h, Svc 3 = set link state
 36272                                  ;DOS_GET_DOS_LISTS  equ   52h ; Int 21h, Func 52h = return list of lists
 36273                                  ;DOS_UMB_HEAD       equ   8Ch ; Offset from ES (after func52h) to get UMBHead
 36274                                  
 36275                                  ; -----------------------------------------------------------------------------
 36276                                  ;*** InitVar - initializes all the variables used in ParseVar and HideUMBs
 36277                                  ; -----------------------------------------------------------------------------
 36278                                  ; ENTRY:       None
 36279                                  ; EXIT:        Variables listed in highvar.inc are initialized
 36280                                  ; ERROR EXIT:  None
 36281                                  ; USES:        Flags, variables in highvar.inc
 36282                                  ; -----------------------------------------------------------------------------
 36283                                  ; Note that element 0 references UMB 0 (conventional), not UMB 1.  Its contents
 36284                                  ; are largely ignored, but it is initialized nonetheless.
 36285                                  ; -----------------------------------------------------------------------------
 36286                                  
 36287                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36288                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:615Fh
 36289                                  InitVar:	; proc	near
 36290                                  	;push	ax
 36291                                  	;push	cx
 36292                                  	;push	di
 36293 00005DCB 06                      	push	es ; * es = ds
 36294 00005DCC 8E06[F39D]              	mov	es,[RESSEG]		;Point ES into appropriate data segment
 36295 00005DD0 31C0                    	xor	ax,ax
 36296                                  	;mov	[es:fUmbTiny],al	;Shrink UMBs? (made 1 if /S given)
 36297                                  	;mov	[es:fInHigh],al		;Set to 1 when DH/LH has been called
 36298 00005DD2 26A3[D604]              	mov	[es:fInHigh],ax ; 16/06/2023
 36299 00005DD6 26A3[D804]              	mov	[es:SegLoad],ax		;Load Address (seg), used for DH only
 36300 00005DDA 26C606[DA04]FF          	mov	byte [es:UmbLoad],0FFh	;UNSPECIFIED
 36301                                  					;Later is the # of the 1st spec'd UMB
 36302 00005DE0 26A2[DD04]              	mov	[es:fm_argc],al		;Start with zero args having been read
 36303                                  
 36304 00005DE4 FC                      	cld
 36305                                  
 36306 00005DE5 B91000                  	mov	cx,16 ; MAXUMB		;For each entry
 36307 00005DE8 BF[0004]                	mov	di,UmbUsed		;on the UmbUsed array,
 36308 00005DEB F3AA                    	rep	stosb			;	Store 0
 36309                                  
 36310                                  	;mov	cx,16 ; MAXUMB		;Okay... for each entry
 36311 00005DED B110                    	mov	cl,16
 36312 00005DEF BF[1004]                	mov	di,UmbSize		;on the UmbSize array,
 36313 00005DF2 F3AB                    	rep	stosw			;	Store 0
 36314                                  
 36315 00005DF4 07                      	pop	es ; * es = ds
 36316                                  	;pop	di
 36317                                  	;pop	cx
 36318                                  	;pop	ax
 36319 00005DF5 C3                       	retn
 36320                                  
 36321                                  ;InitVar endp
 36322                                  
 36323                                  ; -----------------------------------------------------------------------------
 36324                                  ;*** FixMem - scans the upper memory chain and concatenates adjacent free MCBs
 36325                                  ; -----------------------------------------------------------------------------
 36326                                  ; ENTRY   : None
 36327                                  ; EXIT    : None
 36328                                  ; ERROR   : None
 36329                                  ; USES    : Flags, fm_umb, fm_strat
 36330                                  ; -----------------------------------------------------------------------------
 36331                                  
 36332                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36333                                  FixMem:
 36334                                  	;push	ax
 36335                                  	;push	bx
 36336                                  	;push	cx
 36337                                  	;push	dx
 36338 00005DF6 06                      	push	es
 36339                                  
 36340 00005DF7 E84900                  	call	fm_link			; Link in UMBs
 36341                                  
 36342 00005DFA E82302                  	call	UmbHead			; Get first upper-memory MCB address (0x9FFF)
 36343 00005DFD 723F                    	jc	short fmX		; (if couldn't get it, leave now).
 36344                                  
 36345 00005DFF 8EC0                    	mov	es,ax			; It returns in AX, so move it to ES.
 36346                                  
 36347                                  ; - Walk MCB Chain ------------------------------------------------------------
 36348                                  
 36349 00005E01 31D2                    	xor	dx,dx			; We're keeping the address of the last MCB
 36350 00005E03 89D1                    	mov 	cx,dx			; in CX... and the last owner
 36351 00005E05 42                      	inc	dx			; in dx as we go through the loop:
 36352                                  
 36353                                  ; ------------------------------------------
 36354                                  ; FM10--DX  = last MCB's owner's PSP address
 36355                                  ;       CX  = last MCB's address (segment)
 36356                                  ; ------------------------------------------
 36357                                  
 36358                                  fm10:	
 36359 00005E06 26A00000                	mov	al,[es:arena_signature]	; if 'Z', don't repeat loop
 36360                                  	;mov	al,[es:0]
 36361 00005E0A 268B1E0100              	mov	bx,[es:arena_owner]	; if not zero, do nothing
 36362                                  	;mov	bx,[es:1]
 36363 00005E0F 09D3                    	or	bx,dx			; dx was owner of previous MCB
 36364 00005E11 7516                    	jnz	short fm30		; If not both zero, don't cat.
 36365                                  
 36366                                  ; - Coalesce memory blocks at ES:00 and CX:00 ---------------------------------
 36367                                  
 36368                                  fm20:	
 36369 00005E13 268B1E0300              	mov	bx,[es:arena_size]	; Grab this block's Size,
 36370                                  	;mov	bx,[es:3]
 36371 00005E18 8EC1                    	mov	es,cx			; Go back to prev MCB's address
 36372 00005E1A 26A20000                	mov	[es:arena_signature], al ; & move the SECOND sig here
 36373                                  	;mov	[es:0],al
 36374                                  
 36375 00005E1E 26031E0300              	add	bx,[es:arena_size]	; Size += first MCB's size
 36376                                  	;add	bx,1			; And add one for the header
 36377 00005E23 43                      	inc	bx
 36378 00005E24 26891E0300              	mov	[es:arena_size],bx	; Write the size
 36379                                  
 36380                                  	; ---------------------------------------------------------------------
 36381                                  fm30:	
 36382 00005E29 8CC1                    	mov	cx,es			; Put this address on the stack
 36383 00005E2B 268B160100              	mov	dx,[es:arena_owner]	; And remember its owner
 36384                                  	;mov	dx,[es:1]
 36385                                  
 36386                                  	;NextMCB es,bx			; Move to the next MCB
 36387                                  	
 36388 00005E30 8CC3                    	mov	bx,es
 36389                                  	;add	bx,[es:3]
 36390 00005E32 26031E0300              	add	bx,[es:arena_size]
 36391 00005E37 43                      	inc	bx
 36392 00005E38 8EC3                    	mov	es,bx
 36393                                  
 36394                                  	;cmp	al,'Z'	; cmp al,5Ah
 36395 00005E3A 3C5A                    	cmp	al,arena_signature_end
 36396 00005E3C 75C8                    	jnz	short fm10		; If signature != 'Z', there are more.
 36397                                  fmX:	
 36398 00005E3E E81900                  	call	fm_unlink		; Unlink UMBs
 36399                                  
 36400 00005E41 07                      	pop	es
 36401                                  	;pop	dx
 36402                                  	;pop	cx
 36403                                  	;pop	bx
 36404                                  	;pop	ax
 36405 00005E42 C3                      	retn
 36406                                  
 36407                                  ; -----------------------------------------------------------------------------
 36408                                  ; 16/06/2023
 36409                                  
 36410                                  ;INT 21h - DOS 5+ - GET OR SET UMB LINK STATE
 36411                                  ; .......................................................
 36412                                  ;     AH = 58h
 36413                                  ;     AL = subfunction
 36414                                  ;	02h get UMB link state
 36415                                  ;	    Return:
 36416                                  ;		AL = current link state
 36417                                  ;		  00h - UMBs not part of DOS memory chain
 36418                                  ;		  01h - UMBs in DOS memory chain
 36419                                  ;	03h set UMB link state
 36420                                  ;	    BX = new link state
 36421                                  ;		0000h - remove UMBs from DOS memory chain
 36422                                  ;		0001h - add UMBs to DOS memory chain
 36423                                  ;
 36424                                  ;Return: CF clear if successful
 36425                                  ;	CF set on error
 36426                                  ;	AX = error code (01h) (see #01680)
 36427                                  ; .......................................................
 36428                                  
 36429                                  ; -----------------------------------------------------------------------------
 36430                                  ;*** fm_link - links UMBs not already linked in
 36431                                  ; -----------------------------------------------------------------------------
 36432                                  ; ENTRY:    None
 36433                                  ; EXIT:     fm_umb == 0 if not linked in previously, 1 if already linked in
 36434                                  ; ERROR:    None
 36435                                  ; USES:     AX, BX, fm_umb
 36436                                  ; -----------------------------------------------------------------------------
 36437                                  
 36438                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36439                                  fm_link:
 36440 00005E43 B80258                  	mov	ax,5802h ; DOS_CHECK_UMBLINK
 36441 00005E46 CD21                    	int	21h			; Current link-state is now in al
 36442                                  
 36443                                  	;putdata fm_umb,al		; So store it in fm_umb for later
 36444                                  
 36445                                  	;push	es
 36446                                  	;mov	es,[RESSEG]
 36447                                  	;mov	[es:fm_umb],al
 36448                                  	;pop	es
 36449 00005E48 1E                      	push	ds
 36450 00005E49 8E1E[F39D]              	mov	ds,[RESSEG]
 36451 00005E4D A2[DB04]                	mov	[fm_umb],al
 36452 00005E50 1F                      	pop	ds
 36453                                  
 36454 00005E51 B80358                  	mov	ax,5803h ; DOS_SET_UMBLINK
 36455 00005E54 BB0100                  	mov	bx,1
 36456 00005E57 CD21                    	int	21h
 36457 00005E59 C3                      	retn
 36458                                  
 36459                                  ; -----------------------------------------------------------------------------
 36460                                  ;*** fm_unlink - unlinks UMBs if fm_umb is set to 0
 36461                                  ; -----------------------------------------------------------------------------
 36462                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 36463                                  ; EXIT:     None
 36464                                  ; ERROR:    None
 36465                                  ; USES:     AX, BX
 36466                                  ; -----------------------------------------------------------------------------
 36467                                  
 36468                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36469                                  fm_unlink:
 36470 00005E5A 31DB                    	xor	bx,bx
 36471                                  	
 36472                                  	;getdata bl,fm_umb		; fm_umb already has the old link-state
 36473                                  
 36474 00005E5C 1E                      	push    ds
 36475 00005E5D 8E1E[F39D]              	mov     ds,[RESSEG]
 36476 00005E61 8A1E[DB04]              	mov     bl,[fm_umb]
 36477 00005E65 1F                      	pop     ds
 36478                                  	
 36479 00005E66 B80358                  	mov	ax,5803h ; DOS_SET_UMBLINK
 36480 00005E69 CD21                    	int	21h			; so just use that, and call int 21h
 36481 00005E6B C3                      	retn
 36482                                  
 36483                                  ; -----------------------------------------------------------------------------
 36484                                  ;*** ParseVar - parses [/S][/L:umb[,size][;umb[,size]]*] and builds the table
 36485                                  ; laid out in highvar.inc
 36486                                  ; -----------------------------------------------------------------------------
 36487                                  ; ENTRY:    ES:SI points to command tail of LoadHigh/DeviceHigh (whitespace ok)
 36488                                  ; EXIT:     ES:SI points to first character in child program name
 36489                                  ; ERROR:    ES:SI points to character which caused error, carry set, AX == code
 36490                                  ; USES:     ES:SI, AX, flags, variables in highvar.inc
 36491                                  ; -----------------------------------------------------------------------------
 36492                                  ; Error codes (in AX if carry set on return):
 36493                                  ;
 36494                                  
 36495                                  ;PV_InvArg	equ	1	; Invalid argument passed
 36496                                  ;PV_BadUMB	equ	2	; Bad UMB number passed (duplicate?)
 36497                                  ;PV_InvSwt	equ	3	; Unrecognized switch passed
 36498                                  
 36499                                  ;
 36500                                  ; This routine exects ES:SI to point to a string much like the following:
 36501                                  ;    "/S/L:1,200;2 module options"
 36502                                  ; Optionally, the string can begin with whitespace; neither /S nor /L is
 36503                                  ; required, though that's what this routine is supposed to parse.
 36504                                  ;
 36505                                  
 36506                                  ;optS		equ	'S'	; /S
 36507                                  ;optL		equ	'L'	; /L:...
 36508                                  
 36509                                  ;
 36510                                  ; -----------------------------------------------------------------------------
 36511                                  ; LoadHigh has a list of arguments, returned by cparse, which is used to create
 36512                                  ; a command-line for spawning a child process. For a typical LH command, say,
 36513                                  ;     lh /l:1,1000;2 print/d:lpt2
 36514                                  ; the arguments would look like (one per line):
 36515                                  ;     lh
 36516                                  ;     /l
 36517                                  ;     1
 36518                                  ;     1000
 36519                                  ;     2
 36520                                  ;     print
 36521                                  ;     /d
 36522                                  ;     :lpt2
 36523                                  ; In short, if "print" were, say, "43", there'd be no way to determine which
 36524                                  ; arg was the filename. So, inside this routine, we keep a running counter
 36525                                  ; of the number of arguments LH will need to skip in order to get to the
 36526                                  ; program name. The "lh" is implicit--it'll always have to skip that. So if
 36527                                  ; there's no "/l" or "/s", fm_argc will be 0 ... other than that, 1 is added
 36528                                  ; for:
 36529                                  ;    Each /L
 36530                                  ;    Each /S (there should be only one)
 36531                                  ;    Each UMB number (they follow ":" or ";")
 36532                                  ;    Each UMB size   (they follow ",")
 36533                                  ; So, in the above example, fm_argc would be 4-- and LH would skip right to
 36534                                  ; "print". Note that InitVar initializes fm_argc to zero.
 36535                                  ; -----------------------------------------------------------------------------
 36536                                  
 36537                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36538                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6216h
 36539                                  ParseVar:	; proc	near
 36540                                  	;push	di
 36541                                  	;push	ds ; *
 36542                                  	;push	es
 36543                                  	;
 36544                                  	; 16/06/2023
 36545                                  	; es = ds (from 'ParseLhCmd')
 36546                                  	;push	es		; Make DS:SI point to it, as well as ES:SI
 36547                                  	;pop	ds		; (regardless if we're in devhigh or loadhigh)
 36548                                  	
 36549 00005E6C FC                      	cld
 36550                                  
 36551                                  ; ------------------------------------------------
 36552                                  ; PV10--ES:SI = any whitespace on the command-line
 36553                                  ; ------------------------------------------------
 36554                                  
 36555                                  pv10:	
 36556 00005E6D AC                      	lodsb			; here, ES:SI=="  /L..."--must eat whitespace
 36557 00005E6E E8A800                  	call	isWhite
 36558 00005E71 74FA                    	jz	short pv10	;       ES:SI==" /L..."--keep eating.
 36559 00005E73 3C2F                    	cmp	al,'/' ; SWTCH
 36560 00005E75 7404                    	je	short pv20	;       ES:SI=="/L..."--go process a switch
 36561                                  
 36562 00005E77 4E                      	dec	si		; Backup--it's now "odule options", and we need
 36563 00005E78 F8                      	clc			; that "m" we just read (or whatever it is).
 36564 00005E79 EB2C                    	jmp	short pvX	; Then return with carry clear == we're done.
 36565                                  pv20:
 36566 00005E7B AC                      	lodsb			; Just read 'S' or 'L', hopefully
 36567                                  
 36568                                  	;toUpper al		; So we make it upper-case, and...
 36569 00005E7C 24DF                    	and	al,0DFh
 36570                                  
 36571 00005E7E 3C53                    	cmp	al,'S' ; optS	; just read 'S'?
 36572 00005E80 7510                    	jne	short pv30
 36573                                  
 36574 00005E82 E87E00                  	call	incArgc		; If it's /S, it's another arg for LH to skip.
 36575                                  
 36576                                  	;putdata fUmbTiny,1	; /S, so ES:SI=="  /L..." or " module opts", or
 36577                                  
 36578                                  	;push	es
 36579                                  	;mov	es,[RESSEG]
 36580                                  	;mov	byte [es:fUmbTiny],1
 36581                                  	;pop	es
 36582 00005E85 1E                      	push	ds
 36583 00005E86 8E1E[F39D]              	mov	ds,[RESSEG]
 36584 00005E8A C606[D704]01            	mov	byte [fUmbTiny],1
 36585 00005E8F 1F                      	pop	ds
 36586                                  
 36587 00005E90 EBDB                    	jmp	short pv10	; possibly even "/L...".
 36588                                  pv30:	
 36589 00005E92 3C4C                    	cmp	al,'L' ; optL	; If it's not 'L' either, then it's a bad
 36590 00005E94 750B                    	jne	short pvE1	; switch!
 36591                                  
 36592 00005E96 E86A00                  	call	incArgc		; If it's /L, it's another arg for LH to skip.
 36593                                  
 36594 00005E99 E80C00                  	call	parseL
 36595 00005E9C 73CF                    	jnc	short pv10	; If no carry, go back and look for more
 36596                                  
 36597 00005E9E 4E                      	dec	si		; Else, back up and exit.
 36598 00005E9F EB03                    	jmp	short pvErr	; AX has already been set by parseL
 36599                                  pvE1:	
 36600 00005EA1 B80300                  	mov	ax,3 ; PV_InvSwt
 36601                                  				; Unrecognized switch passed
 36602                                  pvErr:
 36603 00005EA4 4E                      	dec	si
 36604 00005EA5 4E                      	dec	si
 36605 00005EA6 F9                      	stc
 36606                                  pvX:	
 36607                                  	;pop	es
 36608                                  	;pop	ds ; *
 36609                                  	;pop	di
 36610 00005EA7 C3                      	retn
 36611                                  
 36612                                  ;ParseVar endp
 36613                                  
 36614                                  ; -----------------------------------------------------------------------------
 36615                                  ;*** parseL - parses ":nnnn[,nnnn][;nnnn[,nnnn]]*" for ParseVar
 36616                                  ; -----------------------------------------------------------------------------
 36617                                  ; ENTRY:    ES:SI points to colon
 36618                                  ; EXIT:     ES:SI points to first character not parsed
 36619                                  ; ERROR:    Carry set; rewind three characters and return (see ParseVar)
 36620                                  ; USES:     ES:SI, flags, AX, CX, DX, variables in highvar.inc
 36621                                  ; -----------------------------------------------------------------------------
 36622                                  ; If the string here is terminated with anything other than whitespace or a
 36623                                  ; switchchar (perhaps it's /S or another /L:... ), then we return with carry
 36624                                  ; set, indicating that they've screwed up the syntax.  The 3-character rewind
 36625                                  ; makes sure the app /L: is reported as being the culprit.
 36626                                  ; -----------------------------------------------------------------------------
 36627                                  
 36628                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36629                                  parseL:
 36630 00005EA8 AC                      	lodsb
 36631 00005EA9 3C3A                    	cmp	al,':'		; Make sure they did /L:
 36632 00005EAB 754A                    	jne	short plE1	; If they didn't, return with carry set.
 36633                                  
 36634                                  ; ------------------------------------------
 36635                                  ; PL10--ES:SI = a UMB number, after /L: or ;
 36636                                  ; ------------------------------------------
 36637                                  
 36638                                  pl10:
 36639 00005EAD E8FD00                  	call	GetXNum		; After this, 'tis ",size" or ";umb" or " mod"
 36640 00005EB0 724B                    	jc	short plE2	; And error if it's a bad number.
 36641 00005EB2 E8C801                  	call	convUMB		; Convert any address to a UMB number
 36642                                  
 36643 00005EB5 88C1                    	mov	cl,al	; !*	; Remember the UMB number
 36644 00005EB7 E88300                  	call	stowUMB		; Mark this UMB # as used;
 36645 00005EBA 7241                    	jc	short plE2	; If it was already marked, it'll error
 36646                                  
 36647 00005EBC E84400                  	call	incArgc		; Each UMB number is another arg for LH to skip
 36648                                  
 36649 00005EBF AC                      	lodsb
 36650 00005EC0 3C3B                    	cmp	al,';'		; Did "umb;" ?
 36651 00005EC2 74E9                    	je	short pl10	; Yep: go back and get another UMB.
 36652                                  
 36653 00005EC4 E85200                  	call	isWhite		; Did "umb " ?
 36654 00005EC7 7439                    	jz	short plX	; Yep: return (it'll go back to whitespace)
 36655                                  
 36656 00005EC9 E84200                  	call	isEOL		; Did "umb" ?
 36657 00005ECC 7433                    	jz	short plSwX	; If so, backup and exit like everything's ok
 36658                                  
 36659 00005ECE 3C2F                    	cmp	al,'/' ; SWTCH	; Did "umb/" ? (as in, "/L:1,100;2/S")
 36660 00005ED0 742F                    	je	short plSwX	; If so, back up ES:SI one character and return
 36661                                  
 36662 00005ED2 3C2C                    	cmp	al,','		; Did "umb," ?
 36663 00005ED4 7521                    	jne	short plE1	; Just what the heck DID they do? Return error.
 36664                                  
 36665                                  ; --- Read a size -------------------------------------------------------------
 36666                                  
 36667 00005ED6 E8D400                  	call	GetXNum		; Stop on "size;" or "size " or anything else
 36668 00005ED9 721C                    	jc	short plE1	; And error if it's a bad size.
 36669                                  
 36670 00005EDB E83401                  	call	toPara		; Convert from bytes to paragraphs
 36671                                  
 36672 00005EDE E88600                  	call	stowSiz		; CL still has the UMB number for this routine
 36673                                  
 36674 00005EE1 E81F00                  	call	incArgc		; Each UMB size is another arg for LH to skip
 36675                                  
 36676 00005EE4 AC                      	lodsb
 36677 00005EE5 3C3B                    	cmp	al,';'		; They did "umb,size;", so get another UMB.
 36678 00005EE7 74C4                    	je	short pl10		;
 36679                                  
 36680 00005EE9 E82D00                  	call	isWhite		; Did it end with whitespace?
 36681 00005EEC 7414                    	jz	short plX	; If so, we're done here--go back.
 36682                                  
 36683 00005EEE E81D00                  	call	isEOL		; Did they do "umb,size" and end??? (stupid)
 36684 00005EF1 740E                    	jz	short plSwX	; If so, backup and exit like everything's ok
 36685                                  
 36686 00005EF3 3C2F                    	cmp	al,'/' ; SWTCH	; Did they do "umb,size/" ?
 36687 00005EF5 740A                    	je	short plSwX	; If so, again, we're done here.
 36688                                  plE1:	
 36689 00005EF7 B80100                  	mov	ax,1 ; PV_InvArg
 36690                                  				; If not, we don't know WHAT they did...
 36691 00005EFA 4E                      	dec	si
 36692 00005EFB F9                      	stc
 36693 00005EFC C3                      	retn
 36694                                  plE2:
 36695                                  	; cf = 1 
 36696 00005EFD B80200                  	mov	ax,2 ; PV_BadUMB
 36697                                  				; In this case, they've specified a UMB twice
 36698                                  	;stc
 36699 00005F00 C3                      	retn
 36700                                  plSwX:
 36701 00005F01 4E                      	dec	si		; If we hit a '/' character, back up one char
 36702                                  				; so the whitespace checker will see it too.
 36703                                  plX:
 36704                                  	; cf = 0
 36705                                  	;clc			; Then just return with carry clear, so
 36706 00005F02 C3                      	retn			; ParseVar will go about its business.
 36707                                  
 36708                                  ; -----------------------------------------------------------------------------
 36709                                  ;*** incArgc - increments fm_argc, for use with LoadHigh command-line parsing
 36710                                  ; -----------------------------------------------------------------------------
 36711                                  ; ENTRY:    None
 36712                                  ; EXIT:     None
 36713                                  ; ERROR:    None
 36714                                  ; USES:     fm_argc, flags
 36715                                  ; -----------------------------------------------------------------------------
 36716                                  
 36717                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36718                                  incArgc:
 36719                                  	;push	ax
 36720                                  
 36721                                  	;;getdata al,fm_argc	; Obtain previous value of fm_argc,
 36722                                  	;
 36723                                  	;push	ds		; getdata (macro)
 36724                                  	;			; getdata al, fm_argc
 36725                                  	;mov	ds,[RESSEG]
 36726                                  	;mov	al,[fm_argc]	; Obtain previous value of fm_argc,
 36727                                  	;pop	ds
 36728                                  	;
 36729                                  	;inc	al		; Increment it,
 36730                                  	;
 36731                                  	;;putdata fm_argc,al	; And store it right back.
 36732                                  	;
 36733                                  	;push	es		; putdata (macro)
 36734                                  	;			; putdata fm_argc, al
 36735                                  	;mov	es,[RESSEG]
 36736                                  	;mov	[es:fm_argc],al	; and store it right back.
 36737                                  	;pop	es
 36738                                  
 36739                                  	; 16/06/2023
 36740 00005F03 1E                      	push	ds
 36741 00005F04 8E1E[F39D]              	mov	ds,[RESSEG]
 36742 00005F08 FE06[DD04]              	inc	byte [fm_argc]	; increment fm_argc
 36743 00005F0C 1F                      	pop	ds
 36744                                  
 36745                                  	;pop	ax
 36746 00005F0D C3                      	retn
 36747                                  
 36748                                  ; -----------------------------------------------------------------------------
 36749                                  ;*** isEOL - returns with ZF set iff AL contains CR or LF, or 0
 36750                                  ; -----------------------------------------------------------------------------
 36751                                  ; ENTRY:    AL contains character to test
 36752                                  ; EXIT:     ZF set if AL contains CR or LF, or 0
 36753                                  ; ERROR:    None
 36754                                  ; USES:     ZF
 36755                                  ; -----------------------------------------------------------------------------
 36756                                  
 36757                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36758                                  isEOL:
 36759                                  	;cmp	al,0		; Null-terminator
 36760 00005F0E 20C0                    	and	al,al
 36761 00005F10 7406                    	jz	short ieX
 36762 00005F12 3C0D                    	cmp	al,0Dh ; CR	; Carriage Return
 36763 00005F14 7402                    	je	short ieX
 36764 00005F16 3C0A                    	cmp	al,0Ah ; LF	; LineFeed
 36765                                  ieX:
 36766 00005F18 C3                      	retn
 36767                                  
 36768                                  
 36769                                  ; -----------------------------------------------------------------------------
 36770                                  ;*** isWhite - returns with ZF set iff AL contains whitespace (or "=")
 36771                                  ; -----------------------------------------------------------------------------
 36772                                  ; ENTRY:    AL contains character to test
 36773                                  ; EXIT:     ZF set if AL contains space, tab, or equals
 36774                                  ; ERROR:    None
 36775                                  ; USES:     ZF
 36776                                  ; -----------------------------------------------------------------------------
 36777                                  
 36778                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36779                                  isWhite:
 36780 00005F19 3C20                    	cmp	al,' '		; Space
 36781 00005F1B 7406                    	je	short iwX
 36782 00005F1D 3C3D                    	cmp	al,'='		; Equals (treat as whitespace)
 36783 00005F1F 7402                    	je	short iwX
 36784 00005F21 3C09                    	cmp	al,09h ; TAB	; Tab
 36785                                  iwX:
 36786 00005F23 C3                      	retn
 36787                                  
 36788                                  ; -----------------------------------------------------------------------------
 36789                                  ;*** unMarkUMB - marks a given UMB as unused, even if previously marked used
 36790                                  ; -----------------------------------------------------------------------------
 36791                                  ; ENTRY:    AL contains UMB number
 36792                                  ; EXIT:     None
 36793                                  ; ERROR:    None
 36794                                  ; USES:     Flags, variables in highvar.inc
 36795                                  ; -----------------------------------------------------------------------------
 36796                                  
 36797                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36798                                  unMarkUMB:
 36799                                  	;;pushreg <ax,bx,di,es>
 36800                                  	;push	ax ; ***
 36801                                  	
 36802                                  	;push	bx ; **
 36803                                  	
 36804                                  	;push	di
 36805                                  	;push	es
 36806 00005F24 1E                      	push	ds ; *	
 36807                                  
 36808                                  	;;dataseg es
 36809                                  	;mov	es,[RESSEG]
 36810                                  
 36811 00005F25 8E1E[F39D]              	mov	ds,[RESSEG] ; *
 36812                                  	
 36813                                  	;xor	ah,ah ; 0
 36814                                  	;mov	bx,ax
 36815                                  	;mov	byte [es:bx+UmbUsed],0
 36816                                  	;mov	[bx+UmbUsed],ah ; marks the UMB as unused
 36817 00005F29 88C3                    	mov	bl,al
 36818 00005F2B 30FF                    	xor	bh,bh ; 0	
 36819 00005F2D 88BF[0004]              	mov	[bx+UmbUsed],bh ; 0 ; **
 36820                                  
 36821                                  	;cmp	[es:UmbLoad],al
 36822                                  	;jnz	short umu10
 36823 00005F31 3806[DA04]              	cmp	[UmbLoad],al
 36824 00005F35 7504                    	jne	short umu10
 36825                                  
 36826                                  	;mov	byte [es:UmbLoad],0
 36827                                  	;mov	[UmbLoad],ah	; If unmarked the load UMB, load into convent.
 36828 00005F37 883E[DA04]              	mov	[UmbLoad],bh ; 0 ; **
 36829                                  umu10:	
 36830 00005F3B 1F                      	pop	ds ; *
 36831                                  	;;popreg <es,di,bx,ax>
 36832                                  	;pop	es
 36833                                  	;pop	di
 36834                                  	
 36835                                  	;pop	bx ; **
 36836                                  	
 36837                                  	;pop	ax ; ***
 36838                                  
 36839                                  	;;normseg es
 36840                                  	
 36841 00005F3C C3                      	retn
 36842                                  
 36843                                  ; -----------------------------------------------------------------------------
 36844                                  ;*** stowUMB - marks a given UMB as used, if it hasn't been so marked before
 36845                                  ;            -- accepts a UMB # in AL, and makes sure it hasn't yet been
 36846                                  ; listed in the /L:... chain.  If it's the first one specified, it sets UmbLoad
 36847                                  ; to that UMB #... and in any case, it marks the UMB as specified.
 36848                                  ; -----------------------------------------------------------------------------
 36849                                  ; ENTRY:    AL contains UMB number, as specified by the user
 36850                                  ; EXIT:     None
 36851                                  ; ERROR:    Carry set if UMB # is less than 0 or >= MAXUMB (see highvar.inc)
 36852                                  ; USES:     AX, Flags, variables in highvar.inc
 36853                                  ; -----------------------------------------------------------------------------
 36854                                  
 36855                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36856                                  stowUMB:
 36857 00005F3D 3C10                    	cmp	al,16 ; MAXUMB
 36858 00005F3F 7202                    	jb	short su10
 36859 00005F41 F9                      	stc
 36860 00005F42 C3                      	retn			; Ooops-- UMB>=MAXUMB
 36861                                  su10:
 36862                                  	;pushreg <bx,di,si,ds,es>
 36863                                  	;dataseg es		; Point ES into appropriate data segment
 36864                                  	;dataseg ds		; Point DS into appropriate data segment
 36865                                  
 36866                                  	;push	bx ; **
 36867                                  	
 36868                                  	;push	di
 36869                                  	;push	si
 36870                                  
 36871 00005F43 1E                      	push	ds ; *
 36872                                  
 36873                                  	;push	es
 36874                                  	;mov	es,[RESSEG]
 36875 00005F44 8E1E[F39D]              	mov	ds,[RESSEG]
 36876                                  
 36877 00005F48 803E[DA04]FF            	cmp	byte [UmbLoad],0FFh ; UNSPECIFIED
 36878                                  				; If this, we haven't been here before
 36879 00005F4D 7503                    	jne	short su20
 36880 00005F4F A2[DA04]                	mov	[UmbLoad],al	; So remember this UMB as the load UMB slot.
 36881                                  su20:	
 36882 00005F52 08C0                    	or	al,al		; If they gave UMB 0, there's really nothing
 36883 00005F54 740F                    	jz	short su30	; that we should do here.
 36884                                  
 36885                                  	;mov	bl,al
 36886                                  	;xor	bh,bh
 36887                                  	;mov	ax,1		; Now, AX = 1, and BX = UMB Number
 36888 00005F56 30E4                    	xor	ah,ah
 36889 00005F58 89C3                    	mov	bx,ax
 36890 00005F5A B001                    	mov	al,1
 36891                                  
 36892                                  	;xchg	[es:bx+UmbUsed],al
 36893 00005F5C 8687[0004]              	xchg	[bx+UmbUsed],al
 36894                                  
 36895 00005F60 08C0                    	or	al,al		; If it was already 1, then al==1... and that
 36896 00005F62 7401                    	jz	short su30	; means an error.
 36897                                  
 36898 00005F64 F9                      	stc			; OOOPS! This one's been used before. :(
 36899                                  su30:	
 36900                                  	;popreg	<es,ds,si,di,bx>
 36901                                  	;normseg ds
 36902                                  	;normseg es
 36903                                  	;retn
 36904                                  
 36905                                  	;pop	es
 36906                                  	
 36907 00005F65 1F                      	pop	ds ; *
 36908                                  	
 36909                                  	;pop	si
 36910                                  	;pop	di
 36911                                  	
 36912                                  	;pop	bx ; **
 36913                                  
 36914 00005F66 C3                      	retn
 36915                                  
 36916                                  ; -----------------------------------------------------------------------------
 36917                                  ;*** stowSiz - marks a given UMB as having a given minimum size
 36918                                  ; -----------------------------------------------------------------------------
 36919                                  ; ENTRY:    CL contains UMB number, AX contains size
 36920                                  ; EXIT:     None
 36921                                  ; ERROR:    None
 36922                                  ; USES:     AX, DX, Flags, variables in highvar.inc
 36923                                  ; -----------------------------------------------------------------------------
 36924                                  	
 36925                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36926                                  stowSiz:
 36927                                  	;pushreg <bx,di,es>
 36928                                  	;dataseg es		; Point ES into appropriate data seg
 36929                                  
 36930                                  	;push	bx ; **
 36931                                  	
 36932                                  	;push	di
 36933                                  	;push	es
 36934                                  	;mov	es,[RESSEG]
 36935 00005F67 1E                      	push	ds ; *
 36936 00005F68 8E1E[F39D]              	mov	ds,[RESSEG]
 36937                                  
 36938 00005F6C 88CB                    	mov	bl,cl		; Now bl==UMB number, AX==size
 36939 00005F6E B700                    	mov	bh,0		;     bx==UMB number, AX==size
 36940 00005F70 D0E3                    	shl	bl,1		;     bx==offset into array, AX=size
 36941                                  	;mov	[es:bx+UmbSize],ax
 36942 00005F72 8987[1004]              	mov	[bx+UmbSize],ax	; Store the size
 36943                                  
 36944 00005F76 1F                      	pop	ds ; *
 36945                                  
 36946                                  	;popreg	<es,di,bx>
 36947                                  	;normseg es		; Return ES to where it was
 36948                                  
 36949                                  	;pop	es
 36950                                  	;pop	di
 36951                                  	
 36952                                  	;pop	bx ; **
 36953                                  
 36954 00005F77 C3                      	retn
 36955                                  
 36956                                  ; -----------------------------------------------------------------------------
 36957                                  ;*** toDigit - converts a character-digit to its binary counterpart
 36958                                  ;            -- verifies that CL contains a valid character-digit; if so, it
 36959                                  ; changes CL to its counterpart binary digit ((CL-'0') or (CL-'A'+10)).  A-F
 36960                                  ; are considered valid iff gnradix is 16.
 36961                                  ; -----------------------------------------------------------------------------
 36962                                  ; ENTRY:    CL contains a digit ('0' to '9' or, if gnradix==16, 'A' to 'F')
 36963                                  ; EXIT:     CL contains digit in binary (0 to 9 or, if gnradix==16, 0 to 15)
 36964                                  ; ERROR:    Carry set indicates invalid digit; carry clear indicates good digit
 36965                                  ; USES:     CL, Flags
 36966                                  ; -----------------------------------------------------------------------------
 36967                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 36968                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 36969                                  ; will be 10 or 16.
 36970                                  ; -----------------------------------------------------------------------------
 36971                                  
 36972                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36973                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6358h
 36974                                  gnradix:
 36975 00005F78 0000                    	dw	0		; Must be a word--16x16 multiplication
 36976                                  
 36977                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 36978                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:635Ah
 36979                                  toDigit:
 36980                                  	;cmp	word [gnradix],16
 36981 00005F7A 803E[785F]10            	cmp	byte [gnradix],16
 36982 00005F7F 751C                    	jne	short td20	; Don't check hex digits if radix isn't 16
 36983                                  
 36984 00005F81 80F961                  	cmp	cl,'a'
 36985 00005F84 7209                    	jb	short td10
 36986 00005F86 80F966                  	cmp	cl,'f'
 36987 00005F89 7720                    	ja	short tdE	; Nothing valid above 'z' at all...
 36988 00005F8B 80E957                  	sub	cl,'a'-10 ; 57h	; Make 'a'==10 and return.
 36989                                  ;	clc			; <- CLC is implicit from last SUB
 36990 00005F8E C3                      	retn
 36991                                  td10:
 36992 00005F8F 80F941                  	cmp	cl,'A'
 36993 00005F92 7209                    	jb	short td20	; Below 'A'?  Not a letter...
 36994 00005F94 80F946                  	cmp	cl,'F'
 36995 00005F97 7712                    	ja	short tdE	; Above 'F'?  Not a digit.
 36996 00005F99 80E937                  	sub	cl,'A'-10 ; 37h	; Make 'A'==10 and return.
 36997                                  ;	clc			; <- CLC is implicit from last SUB
 36998                                  tdErr:
 36999 00005F9C C3                      	retn
 37000                                  td20:
 37001 00005F9D 80F930                  	cmp	cl,'0'		; If less than zero,
 37002                                  	;jb	short tdE	; Done.
 37003 00005FA0 72FA                    	jb	short tdErr ; cf = 1
 37004 00005FA2 80F939                  	cmp	cl,'9'		; Or, if greater than nine,
 37005 00005FA5 7704                    	ja	short tdE	; Done.
 37006 00005FA7 80E930                  	sub	cl,'0'	  ; 30h	; Okay--make '0'==0 and return.
 37007                                  ;	clc			; <- CLC is implicit from last SUB
 37008 00005FAA C3                      	retn
 37009                                  tdE:
 37010 00005FAB F9                      	stc
 37011 00005FAC C3                      	retn
 37012                                  
 37013                                  ; -----------------------------------------------------------------------------
 37014                                  ;*** GetXNum - reads a 32-bit ASCII number at ES:SI and returns it in DX:AX
 37015                                  ; -----------------------------------------------------------------------------
 37016                                  ; ENTRY:    ES:SI points to an ascii string to scan
 37017                                  ; EXIT:     ES:SI moved to first invalid digit, DX:AX contains value read
 37018                                  ; ERROR:    Carry set if # is too big, or has no digits (EOL possibly)
 37019                                  ; USES:     ES:SI, DX, AX, Flags, gnradix
 37020                                  ; -----------------------------------------------------------------------------
 37021                                  ; If the string is preceeded with "0x", the value is read as hexadecimal; else,
 37022                                  ; as decimal. After a read, you may check the radix by examining gnradix--it
 37023                                  ; will be 10 or 16.
 37024                                  ; -----------------------------------------------------------------------------
 37025                                  
 37026                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 37027                                  GetXNum:
 37028                                  	;pushreg <bx,cx,ds>
 37029                                  	
 37030                                  	;push	bx ; **
 37031 00005FAD 51                      	push	cx ; *
 37032                                  	
 37033                                  	;push	ds
 37034                                  
 37035 00005FAE FC                      	cld
 37036 00005FAF 31C0                    	xor	ax,ax
 37037 00005FB1 31DB                    	xor	bx,bx
 37038 00005FB3 31C9                    	xor	cx,cx
 37039 00005FB5 31D2                    	xor	dx,dx		; Start with 0 (makes sense)
 37040                                  
 37041                                  	;mov	word [gnradix],10 ; And default to a radix of 10 (dec)
 37042 00005FB7 C606[785F]0A            	mov	byte [gnradix],10
 37043                                  
 37044 00005FBC 268A0C                  	mov	cl,[es:si]	; Now AX=0, BX=0, CH=0/CL=char, DX=0
 37045 00005FBF E8B8FF                  	call	toDigit
 37046 00005FC2 722D                    	jc	short gxnE	; If it's not a digit, leave now.
 37047                                  
 37048 00005FC4 08C9                    	or	cl,cl
 37049 00005FC6 7515                    	jnz	short gxn20	; Doesn't have '0x'
 37050 00005FC8 268A4C01                	mov	cl,[es:si+1]
 37051 00005FCC 80F978                  	cmp	cl,'x'		; Either 'x'...
 37052 00005FCF 7405                    	je	short gxn10
 37053 00005FD1 80F958                  	cmp	cl,'X'		; ...or 'X' means it's hexadecimal
 37054 00005FD4 7507                    	jne	short gxn20
 37055                                  
 37056                                  gxn10:
 37057                                  	;mov	word [gnradix],16
 37058 00005FD6 C606[785F]10            	mov	byte [gnradix],16
 37059 00005FDB 46                      	inc	si		; Since we read "0x", march over it.
 37060 00005FDC 46                      	inc	si
 37061                                  
 37062                                  ; ------------------------------------------------------
 37063                                  ; GXN20--ES:SI = a digit in a number; if not, we're done
 37064                                  ;        DX:AX = current total
 37065                                  ;        BX    = 0
 37066                                  ;        CH    = 0
 37067                                  ; ------------------------------------------------------
 37068                                  
 37069                                  gxn20:
 37070 00005FDD 268A0C                  	mov	cl,[es:si]	; Now DX:AX=current total, CH=0/CL=char
 37071 00005FE0 46                      	inc	si
 37072                                  
 37073 00005FE1 E896FF                  	call	toDigit		; Accepts only valid digits, A-F -> 10-16
 37074 00005FE4 720D                    	jc	short gxnQ	; <- Ah... wasn't a digit. Stop.
 37075                                  
 37076 00005FE6 E80E00                  	call	mul32		; Multiply DX:AX by gnradix
 37077 00005FE9 7206                    	jc	short gxnX	; (if it's too big, error out)
 37078                                  
 37079 00005FEB 01C8                    	add	ax,cx		; Add the digit
 37080 00005FED 11DA                    	adc	dx,bx		; (BX is 0!)--Adds 1 if last add wrapped
 37081                                  	;jc	short gxnX	; If _that_ wrapped, it's too big.
 37082                                  	;jmp	short gxn20
 37083 00005FEF 73EC                    	jnc	short gxn20
 37084                                  gxnE:
 37085                                  	; cf = 1
 37086                                  	;stc			; In this case, we need to set the carry
 37087                                  	;jmp	short gxnX	; and leave--there were no digits given.
 37088                                  ;gxnQ:
 37089                                  	;dec	si		; Don't read in the offensive character.
 37090                                  	;clc			; And clear carry, so they know it's okay.
 37091                                  gxnX:
 37092                                  	;popreg	<ds,cx,bx>
 37093                                  
 37094                                  	;pop	ds
 37095                                  
 37096 00005FF1 59                      	pop	cx ; *
 37097                                  	;pop	bx ; **
 37098                                  
 37099 00005FF2 C3                      	retn
 37100                                  gxnQ:
 37101 00005FF3 4E                      	dec	si
 37102 00005FF4 F8                      	clc
 37103 00005FF5 EBFA                    	jmp	short gxnX
 37104                                  
 37105                                  ; -----------------------------------------------------------------------------
 37106                                  ;*** mul32 - multiplies the number in DX:AX by gnradix
 37107                                  ; -----------------------------------------------------------------------------
 37108                                  ; ENTRY:   DX:AX = the number to be multiplied, BX = 0, gnradix = multiplier
 37109                                  ; EXIT:    DX:AX has been multiplied by gnradix if carry clear; BX still 0
 37110                                  ; ERROR:   Carry set if number was too large
 37111                                  ; USES:    Flags, AX, DX
 37112                                  ; -----------------------------------------------------------------------------
 37113                                  
 37114                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37115                                  mul32:
 37116 00005FF7 50                      	push	ax		; DX=old:hi, AX=old:lo, TOS=old:lo, BX=0
 37117 00005FF8 89D0                    	mov	ax,dx		; DX=old:hi, AX=old:hi, TOS=old:lo, BX=0
 37118 00005FFA F726[785F]              	mul	word [gnradix]	; DX=?,      AX=new:hi, TOS=old:lo, BX=0
 37119 00005FFE 7210                    	jc	short m32E	; Too big?
 37120                                  
 37121 00006000 89C2                    	mov	dx,ax		; DX=new:hi, AX=new:hi, TOS=old:lo, BX=0
 37122 00006002 58                      	pop	ax		; DX=new:hi, AX=old:lo, TOS=orig,   BX=0
 37123                                  
 37124 00006003 87D3                    	xchg	dx,bx		; DX=0,      AX=old:lo, TOS=orig,   BX=new:hi
 37125 00006005 F726[785F]              	mul	word [gnradix]	; DX=carry,  AX=new:lo, TOS=orig,   BX=new:hi
 37126 00006009 87D3                    	xchg	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=carry
 37127 0000600B 01DA                    	add	dx,bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=carry
 37128 0000600D 31DB                    	xor	bx,bx		; DX=new:hi, AX=new:lo, TOS=orig,   BX=0
 37129 0000600F C3                      	retn
 37130                                  m32E:
 37131 00006010 58                      	pop	ax
 37132 00006011 C3                      	retn
 37133                                  
 37134                                  ; -----------------------------------------------------------------------------
 37135                                  ;*** toPara - divides DX:AX by 16; result in AX only (discards extra DX data)
 37136                                  ; -----------------------------------------------------------------------------
 37137                                  ; ENTRY:   DX:AX = the number to be divided
 37138                                  ; EXIT:    Interpereting DX:AX as bytes, AX=paragraph equivalent, 0xFFFF max
 37139                                  ; ERROR:   None
 37140                                  ; USES:    Flags, AX, DX
 37141                                  ; -----------------------------------------------------------------------------
 37142                                  ; Note: The 386 has a 32-bit SHR, which would work perfectly for this... but we
 37143                                  ;       can't ensure a 386 host machine. Sorry.
 37144                                  ; -----------------------------------------------------------------------------
 37145                                  
 37146                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37147                                  toPara:
 37148 00006012 51                      	push	cx		; DX:AX=HHHH hhhh hhhh hhhh:LLLL llll llll llll
 37149                                  
 37150 00006013 B104                    	mov	cl,4		;
 37151 00006015 D3E8                    	shr	ax,cl		; DX:AX=HHHH hhhh hhhh hhhh:0000 LLLL llll llll
 37152 00006017 92                      	xchg	ax,dx		; DX:AX=0000 LLLL llll llll:HHHH hhhh hhhh hhhh
 37153 00006018 B10C                    	mov	cl,12
 37154 0000601A D3E0                    	shl	ax,cl		; DX:AX=0000 LLLL llll llll:hhhh 0000 0000 0000
 37155 0000601C 09D0                    	or	ax,dx		;    AX=hhhh LLLL llll llll
 37156                                  
 37157 0000601E 59                      	pop	cx
 37158 0000601F C3                      	retn
 37159                                  
 37160                                  ; -----------------------------------------------------------------------------
 37161                                  ;*** UmbHead - returns in AX the address of the first UMB block (0x9FFF)
 37162                                  ; -----------------------------------------------------------------------------
 37163                                  ; ENTRY:  Nothing
 37164                                  ; EXIT:   AX contains 0x9FFF for most systems
 37165                                  ; ERROR:  Carry set if pointer is 0xFFFF (if not set up yet--DH runs into this)
 37166                                  ; USES:   Flags, AX
 37167                                  ; -----------------------------------------------------------------------------
 37168                                  ; Early in the boot-cycle, the pointer used to obtain this value isn't set up;
 37169                                  ; to be precise, before a UMB provider is around.  In this event, the pointer
 37170                                  ; is always set to 0xFFFF; it changes once a provider is around.  On most
 37171                                  ; machines (all of 'em I've seen), it changes to 0x9FFF at that point.
 37172                                  ; -----------------------------------------------------------------------------
 37173                                  
 37174                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37175                                  UmbHead:
 37176                                  	;pushreg <si,ds,es>
 37177                                  	
 37178                                  	;push	si
 37179                                  	;push	ds
 37180                                  	;push	es
 37181                                  
 37182 00006020 B452                    	mov	ah,52h	; DOS_GET_DOS_LISTS
 37183                                  					; Call int 21h, function 52h...
 37184 00006022 CD21                    	int	21h
 37185                                  			; DOS - 2+ internal - GET LIST OF LISTS
 37186                                  			; Return: ES:BX -> DOS list of lists
 37187                                  
 37188                                  	;mov	ax,[es:DOS_UMB_HEAD]	; And read what's in ES:[008C]
 37189 00006024 26A18C00                	mov	ax,[es:8Ch]
 37190 00006028 83F8FF                  	cmp	ax,0FFFFh
 37191                                  	;je	short uhE		; If it's 0xFFFF, it's an error...
 37192                                  
 37193                                  	;clc				; Else, it isn't (CLC done by prev cmp)
 37194                                  	;jmp	short uhX
 37195                                  	; 17/06/2023
 37196 0000602B F5                      	cmc	; cf = 0 <--> cf = 1
 37197                                  uhE:
 37198                                  	;stc
 37199                                  uhX:	
 37200                                  	;popreg	<es,ds,si>
 37201                                  	
 37202                                  	;pop	es
 37203                                  	;pop	ds
 37204                                  	;pop	si
 37205                                  
 37206 0000602C C3                      	retn
 37207                                  
 37208                                  ; -----------------------------------------------------------------------------
 37209                                  ;*** isSysMCB - sets ZF iff ES points to an MCB owned by "SC" + (8 or 9)
 37210                                  ; -----------------------------------------------------------------------------
 37211                                  ; ENTRY:  ES:0 should point to a valid MCB
 37212                                  ; EXIT:   ZF set if owned by SC+8 or SC+9 (for japan)
 37213                                  ; USES:   Flags
 37214                                  ; -----------------------------------------------------------------------------
 37215                                  
 37216                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37217                                  isSysMCB:
 37218                                  	;push	ax
 37219                                  	
 37220                                  	;mov	ax,[es:1]
 37221 0000602D 26A10100                	mov	ax,[es:arena_owner]	; Check the owner...
 37222 00006031 83F808                  	cmp	ax,8 ; SystemPSPOwner	; 8 (for US OR Japan) is valid
 37223 00006034 7405                    	jz	short ism10
 37224 00006036 83F809                  	cmp	ax,9 ; JapanPSPOwner	; 9 (for Japan) is valid
 37225                                  	;jz	short ism10
 37226                                  	;jmp	short ismX		; Anything else isn't.
 37227 00006039 7507                    	jnz	short ismX
 37228                                  ism10:
 37229                                  	;mov	ax,[es:8]
 37230 0000603B 26A10800                	mov	ax,[es:arena_name]	; Check the name...
 37231 0000603F 3D5343                  	cmp	ax,'SC' ; cmp ax,4353h
 37232                                  ismX:
 37233                                  	;pop	ax
 37234 00006042 C3                      	retn
 37235                                  
 37236                                  ; -----------------------------------------------------------------------------
 37237                                  ;*** AddrToUmb - converts a segment address in AX to its appropriate UMB number
 37238                                  ; -----------------------------------------------------------------------------
 37239                                  ; ENTRY:  AX contains a segment address
 37240                                  ; EXIT:   AX will contain the UMB number which contains the address (0==conv)
 37241                                  ; ERROR:  If the address is above UM Range, AX will return as FFFF.
 37242                                  ; USES:   Flags, AX
 37243                                  ; -----------------------------------------------------------------------------
 37244                                  ; An address in the following areas is treated as:
 37245                                  ;    0      <-> umbhead (0x9FFF)          = Conventional memory
 37246                                  ;    0x9FFF <-> addr of first UM sys MCB  = UMB #1
 37247                                  ;      ...
 37248                                  ;    addr of last UM sys MCB <-> TOM      = invalid; returns #0xFFFF
 37249                                  ; -----------------------------------------------------------------------------
 37250                                  
 37251                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37252                                  AddrToUmb:
 37253                                  	;pushreg <cx,dx,es>
 37254                                  	
 37255                                  	;push	cx
 37256                                  	;push	dx
 37257 00006043 06                      	push	es
 37258                                  
 37259 00006044 89C2                    	mov	dx,ax		; DX = address to search for
 37260                                  
 37261 00006046 E8D7FF                  	call	UmbHead		; AX = first segment
 37262 00006049 722B                    	jc	short atuE	; If it couldn't get it, error out.
 37263                                  
 37264                                  	;mov	es,ax ; *	; ES = first UMB segment
 37265 0000604B 31C9                    	xor	cx,cx		; Pretend we're on UMB 0 for now... (cx = UMB#)
 37266                                  
 37267                                  ; ----------------------------------------
 37268                                  ; ATU10--ES - Current MCB address
 37269                                  ;        DX - Address given for conversion
 37270                                  ;        CX - Current UMB #
 37271                                  ; ----------------------------------------
 37272                                  
 37273                                  	; 17/06/2023
 37274                                  atu10:
 37275 0000604D 8EC0                    	mov	es,ax ; *
 37276                                  ;atu10:
 37277                                  	;mov	ax,es
 37278 0000604F 39D0                            cmp	ax,dx		; Present segment >= given segment?
 37279 00006051 7326                    	jae	short atuX	; Yep--done.
 37280                                  
 37281 00006053 E8D7FF                  	call	isSysMCB	; Returns with ZF set if this is a system MCB
 37282 00006056 7501                    	jnz	short atu20
 37283                                  
 37284 00006058 41                      	inc	cx		; If it _was_ a system MCB, we're in a new UMB.
 37285                                  atu20:
 37286                                  	;mov	al,[es:0]
 37287 00006059 26A00000                	mov	al,[es:arena_signature]
 37288                                  	;cmp	al,'Z' ; 5Ah
 37289 0000605D 3C5A                    	cmp	al,arena_signature_end
 37290 0000605F 740A                    	je	short atu30	; 'Z' means this was the last MCB... that's it.
 37291                                  
 37292                                  	;NextMCB es,ax
 37293 00006061 8CC0                    	mov	ax,es
 37294                                  	;add	ax,[es:3]	; NextMCB (macro)
 37295 00006063 2603060300              	add	ax,[es:arena_size]
 37296 00006068 40                      	inc	ax
 37297                                  	;mov	es,ax ; * ; 17/06/2023
 37298 00006069 EBE2                    	jmp	short atu10
 37299                                  
 37300                                  ; -----------------------------------------------------------------------------
 37301                                  ; if we get to atu30, they specified a number that was past the last MCB.
 37302                                  ; make sure it's not _inside_ that MCB before we return an error condition.
 37303                                  ; -----------------------------------------------------------------------------
 37304                                  
 37305                                  atu30:
 37306 0000606B 8CC0                    	mov	ax,es
 37307                                  	;add	ax,[es:3]
 37308 0000606D 2603060300              	add	ax,[es:arena_size]
 37309 00006072 39D0                    	cmp	ax,dx		; Present >= given?
 37310 00006074 7303                    	jae	short atuX	; Yep! It _was_ inside.
 37311                                  atuE:
 37312 00006076 31C9                    	xor	cx,cx		; Else, fall through with UMB # == -1
 37313 00006078 49                      	dec	cx		; (that makes it return 0xFFFF and sets CF)
 37314                                  atuX:	
 37315 00006079 89C8                    	mov	ax,cx		; Return the UMB number in AX
 37316                                  	
 37317                                  	;popreg	<es,dx,cx>
 37318                                  
 37319 0000607B 07                      	pop	es
 37320                                  	;pop	dx
 37321                                  	;pop	cx
 37322                                  	
 37323 0000607C C3                      	retn
 37324                                  
 37325                                  ; -----------------------------------------------------------------------------
 37326                                  ;*** convUMB - checks after GetXNum to convert an address to a UMB number
 37327                                  ;            -- if GetXNum read a hex number, we interperete that as a segment
 37328                                  ; address rather than a UMB number... and use that address to look up a UMB.
 37329                                  ; This routine checks for that condition and calls AddrToUmb if necessary.
 37330                                  ; -----------------------------------------------------------------------------
 37331                                  ; ENTRY:  AX contains a UMB number or segment, gnradix has been set by GetXNum
 37332                                  ; EXIT:   AX will contain a UMB number
 37333                                  ; ERROR:  None
 37334                                  ; USES:   Flags, AX
 37335                                  ; -----------------------------------------------------------------------------
 37336                                  
 37337                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37338                                  convUMB:
 37339                                  	;cmp	word [gnradix],16
 37340 0000607D 803E[785F]10            	cmp	byte [gnradix],16
 37341 00006082 7509                    	jne	short cu10	; If it didn't read in hex, it's not an address
 37342 00006084 E8BCFF                  	call	AddrToUmb	; Else, convert the address to a UMB number
 37343 00006087 83F8FF                  	cmp	ax,0FFFFh
 37344 0000608A 7501                    	jne	short cu10
 37345 0000608C 40                      	inc	ax ; ax = 0	; If too high, ignore it (make it conventional)
 37346                                  cu10:
 37347 0000608D C3                      	retn
 37348                                  
 37349                                  ; -----------------------------------------------------------------------------
 37350                                  ;*** setUMBs - links umbs and sets allocation strategy for a load
 37351                                  ;            -- if LoadHigh, the allocation strategy MAY be LOW_FIRST instead
 37352                                  ; of the usual HIGH_FIRST.  See the code.
 37353                                  ; -----------------------------------------------------------------------------
 37354                                  ; ENTRY:  None
 37355                                  ; EXIT:   None
 37356                                  ; ERROR:  None
 37357                                  ; USES:   Flags, fm_umb, fm_strat
 37358                                  ; -----------------------------------------------------------------------------
 37359                                  
 37360                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37361                                  setUMBs:
 37362                                  	;pushreg <ax,bx>
 37363                                  	
 37364                                  	;push	ax
 37365                                  	;push	bx
 37366                                  
 37367 0000608E E8B2FD                  	call	fm_link
 37368                                  
 37369 00006091 B80058                  	mov	ax,5800h ; DOS_CHECK_STRATEGY
 37370 00006094 CD21                    	int	21h
 37371                                  
 37372                                  	;putdata fm_strat,al	; Store the current strategy for later restore
 37373                                  
 37374                                  	;push	es
 37375                                  	;mov	es,[RESSEG]
 37376                                  	;mov	[es:fm_strat],al ; store the current strategy
 37377                                  	;pop	es
 37378 00006096 1E                      	push	ds ; *
 37379 00006097 8E1E[F39D]              	mov	ds,[RESSEG]
 37380 0000609B A2[DC04]                	mov	[fm_strat],al
 37381                                  	;pop	ds ; *
 37382                                  
 37383 0000609E 83E07F                  	and	ax,007Fh	; 0000.0000.0111.1111 == All that other stuff
 37384 000060A1 50                      	push	ax ; **		; Watch this carefully...
 37385                                  
 37386 000060A2 E80C00                  	call	loadLow		; returns al==0 if load low, al==1 if loadhigh
 37387 000060A5 D0C8                    	ror	al,1		; Shift that to al==0 or al==0x80
 37388                                  
 37389 000060A7 5B                      	pop	bx ; **		; ...pushed as AX above
 37390                                  	
 37391 000060A8 1F                      	pop	ds ; *
 37392                                  	
 37393 000060A9 08C3                    	or	bl,al		; Now we have 0000.0000.?111.1111 in BX;
 37394                                  
 37395 000060AB B80158                  	mov	ax,5801h ; DOS_SET_STRATEGY
 37396                                  				; with ? ==1 if load highfirst. Perfect!
 37397 000060AE CD21                    	int	21h
 37398                                  
 37399                                  	;popreg	<bx,ax>
 37400                                  
 37401                                  	;pop	bx
 37402                                  	;pop	ax
 37403                                  
 37404 000060B0 C3                      	retn
 37405                                  
 37406                                  ; -----------------------------------------------------------------------------
 37407                                  ;*** loadLow - returns AL==0 if UMB0 == 0, else AL==1
 37408                                  ; -----------------------------------------------------------------------------
 37409                                  ; ENTRY:  None
 37410                                  ; EXIT:   AL==0 if mem strategy should be set to LOW_FIRST, else AL==1
 37411                                  ;         Carry set if UMB0 not specified (_NOT_ an error)
 37412                                  ; ERROR:  None
 37413                                  ; USES:   Flags, fm_strat, fm_umb
 37414                                  ; -----------------------------------------------------------------------------
 37415                                  ; We want to set the memory strategy to LOW_FIRST if the user specified a
 37416                                  ; load UMB, and it is 0.  That 0 can be either from the user having _specified_
 37417                                  ; zero (/L:0;...), or from having specified a too-big min size (/L:1,99999999)
 37418                                  ; such that the load UMB is too small, and shouldn't be used.
 37419                                  ; -----------------------------------------------------------------------------
 37420                                  
 37421                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37422                                  loadLow:
 37423                                  	;push	ds ; *	
 37424                                  	
 37425                                  	;dataseg ds		; Point DS into appropriate data segment
 37426                                  	;mov	ds,[RESSEG]
 37427                                  
 37428                                  	; * ; ds = [RESSEG] from 'setUMBs') ; 17/06/2023
 37429                                  
 37430 000060B1 A0[DA04]                	mov	al,[UmbLoad]
 37431 000060B4 3CFF                    	cmp	al,0FFh ; UNSPECIFIED
 37432 000060B6 7503                    	jne	short ll10
 37433                                  
 37434                                  	;mov	al,1		; Return with AL==1 && STC if no UMBs specified
 37435 000060B8 F9                      	stc
 37436                                  	;jmp	short llX
 37437 000060B9 EB04                    	jmp	short lly ; 17/06/2023
 37438                                  ll10:
 37439 000060BB 08C0                    	or	al,al		; AL=the load UMB: Is it == 0?
 37440 000060BD 7402                    	jz	short llX	; Yep... CF==0 (from OR) && AL=0, so just exit
 37441                                  	; cf= 0
 37442                                  
 37443                                  	;mov	al,1
 37444                                  	;clc	
 37445                                  lly:		; 17/06/2023
 37446 000060BF B001                    	mov	al,1
 37447                                  llX:
 37448                                  	;pop	ds ; *		; Return DS to where it was
 37449                                  	
 37450                                  	;normseg ds		;
 37451                                  	
 37452 000060C1 C3                      	retn
 37453                                  
 37454                                  ; -----------------------------------------------------------------------------
 37455                                  ;*** HideUMBs - links UMBs and hides upper-memory as appropriate
 37456                                  ; -----------------------------------------------------------------------------
 37457                                  ; ENTRY:  None
 37458                                  ; EXIT:   None
 37459                                  ; ERROR:  None
 37460                                  ; USES:   Flags, fm_strat, fm_umb
 37461                                  ; -----------------------------------------------------------------------------
 37462                                  
 37463                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37464                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:64D0h
 37465                                  HideUMBs:
 37466                                  	;pushreg <ax,cx,ds,es>
 37467                                  	
 37468                                  	;push	ax
 37469                                  	;push	cx
 37470                                  	;push	ds
 37471                                  	;push	es
 37472                                  
 37473 000060C2 E8EF01                  	call	UmbTest		; See if we REALLY linked in anything...
 37474 000060C5 7236                    	jc	short husX	; ...if not, there's nothing for us to do.
 37475                                  
 37476 000060C7 E82CFD                  	call	FixMem		; Concatenate adjacent free MCBs in upper mem
 37477 000060CA E8C1FF                  	call	setUMBs		; Link UMBs and set memory-allocation strategy
 37478                                  
 37479                                  	;putdata fInHigh,1	; Remember that we're now running high
 37480                                  	;push	es
 37481                                  	;mov	es,[RESSEG]
 37482                                  	;mov	byte [es:fInHigh], 1
 37483                                  	;			; remember that we're now running high
 37484                                  	;pop	es
 37485 000060CD 1E                      	push	ds
 37486 000060CE 8E1E[F39D]              	mov	ds,[RESSEG]
 37487 000060D2 C606[D604]01            	mov	byte [fInHigh], 1
 37488 000060D7 1F                      	pop	ds
 37489                                  
 37490 000060D8 E82300                  	call	GetLoadUMB	; See if they gave us a list to leave free
 37491 000060DB 3CFF                    	cmp	al,0FFh	; UNSPECIFIED
 37492                                  				; If they didn't,
 37493 000060DD 741E                    	je	short husX	; then we shouldn't do this loop:
 37494                                  
 37495 000060DF 31C9                    	xor	cx,cx
 37496                                  
 37497                                  ; -----------------------------------------------
 37498                                  ; HUS10-CX - UMB number (after inc, 1==first UMB)
 37499                                  ; -----------------------------------------------
 37500                                  
 37501                                  hus10:
 37502 000060E1 41                      	inc	cx		; For each UMB:
 37503 000060E2 83F910                  	cmp	cx,16 ; MAXUMB
 37504 000060E5 730C                    	jae	short hus20
 37505                                  
 37506 000060E7 88C8                    	mov	al,cl		; (stopping as soon as we're outside of the
 37507                                  	; 17/06/2023
 37508                                  	;push	es
 37509 000060E9 E8A900                  	call	findumb		; valid range of UMBs)
 37510                                  	;pop	es		; push/pop: trash what findumb finds.  :-)
 37511 000060EC 7205                    	jc	short hus20
 37512                                  
 37513 000060EE E87901                  	call	hideUMB?	; hide what we need to hide.
 37514                                  
 37515 000060F1 EBEE                    	jmp	short hus10
 37516                                  hus20:
 37517 000060F3 E80800                  	call	GetLoadUMB	; Now check if they offered /L:0
 37518 000060F6 08C0                    	or	al,al		; --Is the load UMB 0? (-1==unspecified)
 37519 000060F8 7503                    	jnz	short husX	; If not, we're done.
 37520                                  
 37521 000060FA E8E701                  	call	hl_unlink	; If so, however, fix UMBs and strategy.
 37522                                  husX:
 37523                                  	;popreg	<es,ds,cx,ax>
 37524                                  	
 37525                                  	;pop	es
 37526                                  	;pop	ds
 37527                                  	;pop	cx
 37528                                  	;pop	ax
 37529                                  
 37530 000060FD C3                      	retn
 37531                                  
 37532                                  ; -----------------------------------------------------------------------------
 37533                                  ;*** GetLoadUMB - Returns the load UMB number in AL (-1 if not specified)
 37534                                  ; -----------------------------------------------------------------------------
 37535                                  ; ENTRY:  None
 37536                                  ; EXIT:   AL == load UMB
 37537                                  ; ERROR:  None
 37538                                  ; USES:   Flags, AX
 37539                                  ; -----------------------------------------------------------------------------
 37540                                  
 37541                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37542                                  GetLoadUMB:
 37543                                  	;getdata al,UmbLoad
 37544                                  
 37545 000060FE 1E                      	push    ds
 37546 000060FF 8E1E[F39D]              	mov     ds,[RESSEG]   ; getdata (macro)
 37547 00006103 A0[DA04]                	mov     al,[UmbLoad]
 37548 00006106 1F                      	pop     ds
 37549                                  
 37550 00006107 C3                      	retn
 37551                                  
 37552                                  ; -----------------------------------------------------------------------------
 37553                                  ;*** GetSize - Returns the UMB in AL's minimum size (0 if not specified)
 37554                                  ; -----------------------------------------------------------------------------
 37555                                  ; ENTRY:  AL == a UMB number
 37556                                  ; EXIT:   AX == UMB minimum size, as specified by the user
 37557                                  ; ERROR:  None
 37558                                  ; USES:   Flags, AX
 37559                                  ; -----------------------------------------------------------------------------
 37560                                  
 37561                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37562                                  GetSize:
 37563                                  	;pushreg <bx,si,ds>
 37564                                  	;push	bx
 37565                                  	;push	si
 37566 00006108 1E                      	push	ds
 37567                                  	
 37568                                  	;dataseg ds
 37569 00006109 8E1E[F39D]              	mov	ds,[RESSEG]
 37570                                  
 37571 0000610D 30E4                    	xor	ah,ah			;    ax==UMB
 37572                                  	;mov	bx,offset UmbSize
 37573 0000610F BB[1004]                	mov	bx,UmbSize		;    bx==array
 37574 00006112 D0E0                    	shl	al,1	                ;    ax==offset
 37575                                  	;add	ax,bx			;    ax==element index
 37576                                  	;mov	si,ax			; ds:si==element index
 37577                                  	;lodsw				;    ax==size
 37578 00006114 01C3                    	add	bx,ax
 37579 00006116 8B07                    	mov	ax,[bx]
 37580                                  
 37581                                  	;popreg	<ds,si,bx>
 37582 00006118 1F                      	pop	ds
 37583                                  	;pop	si
 37584                                  	;pop	bx
 37585                                  
 37586                                  	;normseg ds
 37587 00006119 C3                      	retn
 37588                                  
 37589                                  ; -----------------------------------------------------------------------------
 37590                                  ;*** hideUMB - marks as HIDDEN all FREE elements in UMB passed as AL
 37591                                  ; -----------------------------------------------------------------------------
 37592                                  ; ENTRY:    AL must indicate a valid UMB; 0==conv && is invalid.
 37593                                  ; EXIT:     None; free elements in UMB marked as hidden
 37594                                  ; ERROR:    None
 37595                                  ; USES:     Flags
 37596                                  ; -----------------------------------------------------------------------------
 37597                                  
 37598                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37599                                  hideUMB:
 37600                                  	;pushreg <ax,es>
 37601                                  	
 37602                                  	;push	ax
 37603                                  	;push	es
 37604                                  
 37605 0000611A E87800                  	call	findumb		; Returns with carry if err, else ES == MCB
 37606 0000611D 7221                    	jc	short huX
 37607                                  
 37608                                  ; ------------------------------------------------
 37609                                  ; HU10--ES - MCB inside UMB; if it's a system MCB,
 37610                                  ;            we're not in the same UMB, so exit.
 37611                                  ; ------------------------------------------------
 37612                                  
 37613                                  hu10:
 37614 0000611F E80BFF                  	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 37615 00006122 741C                    	jz	short huX	; If it is, we've finished the UMB.
 37616 00006124 E82800                  	call	isFreeMCB	; Returns with ZF set if owner is 0
 37617 00006127 7503                    	jnz	short hu20
 37618                                  
 37619 00006129 E82A00                  	call	hideMCB
 37620                                  hu20:
 37621                                  	;mov	al,[es:0]
 37622 0000612C 26A00000                	mov	al,[es:arena_signature]
 37623                                  	;cmp	al,'Z'
 37624 00006130 3C5A                    	cmp	al,arena_signature_end
 37625 00006132 740C                    	je	short huX	; 'Z' means this was the last MCB... that's it.
 37626                                  
 37627                                  	;NextMCB es,ax		; Go on forward.
 37628                                  
 37629 00006134 8CC0                     	mov	ax,es		; NextMCB (macro)
 37630                                  	;add	ax,[es:3]
 37631 00006136 2603060300              	add	ax,[es:arena_size]
 37632 0000613B 40                      	inc	ax
 37633 0000613C 8EC0                    	mov	es,ax
 37634                                  
 37635 0000613E EBDF                    	jmp	short hu10
 37636                                  huX:
 37637                                  	;popreg	<es,ax>
 37638                                  	
 37639                                  	;pop	es
 37640                                  	;pop	ax
 37641                                  
 37642 00006140 C3                      	retn
 37643                                  
 37644                                  ; -----------------------------------------------------------------------------
 37645                                  ;*** isTiny - returns with ZF set if user didn't specify /S
 37646                                  ; -----------------------------------------------------------------------------
 37647                                  ; ENTRY:    None
 37648                                  ; EXIT:     ZF set if user DIDN'T specify /S
 37649                                  ; ERROR:    None
 37650                                  ; USES:     Flags
 37651                                  ; -----------------------------------------------------------------------------
 37652                                  
 37653                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37654                                  isTiny:
 37655 00006141 50                      	push	ax
 37656                                  
 37657                                  	;getdata al,fUmbTiny
 37658 00006142 1E                      	push    ds
 37659 00006143 8E1E[F39D]              	mov     ds,[RESSEG]   ; getdata (macro)
 37660 00006147 A0[D704]                	mov     al,[fUmbTiny]
 37661 0000614A 1F                      	pop     ds
 37662                                  
 37663 0000614B 08C0                    	or	al,al
 37664 0000614D 58                      	pop	ax
 37665 0000614E C3                      	retn
 37666                                  
 37667                                  ; -----------------------------------------------------------------------------
 37668                                  ;*** isFreeMCB - returns with ZF set if current MCB (ES:0) is FREE
 37669                                  ; -----------------------------------------------------------------------------
 37670                                  ; ENTRY:    ES:0 should point to an MCB
 37671                                  ; EXIT:     ZF set if MCB is free, else !ZF
 37672                                  ; ERROR:    None
 37673                                  ; USES:     Flags
 37674                                  ; -----------------------------------------------------------------------------
 37675                                  
 37676                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37677                                  isFreeMCB:
 37678                                  	;or	word [es:1],0
 37679 0000614F 26830E010000            	or	word [es:arena_owner],0
 37680 00006155 C3                      	retn
 37681                                  
 37682                                  ; -----------------------------------------------------------------------------
 37683                                  ;*** hideMCB - marks as HIDDEN the MCB at ES:0
 37684                                  ; -----------------------------------------------------------------------------
 37685                                  ; ENTRY:    ES:0 should point to an MCB
 37686                                  ; EXIT:     None; MCB marked as HIDDEN
 37687                                  ; ERROR:    None
 37688                                  ; USES:     None
 37689                                  ; -----------------------------------------------------------------------------
 37690                                  
 37691                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37692                                  hideMCB:
 37693                                  	;mov	word [es:1],8
 37694 00006156 26C70601000800          	mov	word [es:arena_owner],8 ; SystemPSPOwner
 37695                                  	;mov	word [es:8],4948h     ; 'HIDDEN  ' 
 37696 0000615D 26C70608004849          	mov	word [es:arena_name+0], 'HI' ; 4948h
 37697 00006164 26C7060A004444          	mov	word [es:arena_name+2], 'DD' ; 4444h
 37698 0000616B 26C7060C00454E          	mov	word [es:arena_name+4], 'EN' ; 4E45h
 37699                                  	;mov	word [es:14],2020h
 37700 00006172 26C7060E002020          	mov	word [es:arena_name+6], '  ' ; 2020h 
 37701 00006179 C3                      	retn
 37702                                  
 37703                                  ; -----------------------------------------------------------------------------
 37704                                  ;*** unHideMCB - marks as FREE the MCB at ES:0
 37705                                  ; -----------------------------------------------------------------------------
 37706                                  ; ENTRY:    ES:0 should point to an MCB
 37707                                  ; EXIT:     None; MCB marked as FREE
 37708                                  ; ERROR:    None
 37709                                  ; USES:     None
 37710                                  ; -----------------------------------------------------------------------------
 37711                                  
 37712                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37713                                  unHideMCB:
 37714                                  	;push	ax
 37715                                  	;mov	word [es:1],0
 37716 0000617A 26C70601000000          	mov	word [es:arena_owner],0 ; FreePSPOwner
 37717 00006181 B82020                  	mov	ax, '  '  ; mov ax,2020h
 37718                                  	;mov	[es:8],ax
 37719 00006184 26A30800                	mov	[es:arena_name+0],ax
 37720 00006188 26A30A00                	mov	[es:arena_name+2],ax
 37721 0000618C 26A30C00                	mov	[es:arena_name+4],ax
 37722                                  	;mov	[es:14],ax
 37723 00006190 26A30E00                	mov	[es:arena_name+6],ax
 37724                                  	;pop	ax
 37725 00006194 C3                      	retn
 37726                                  
 37727                                  ; -----------------------------------------------------------------------------
 37728                                  ;*** findUMB - makes ES:0 point to the first MCB in UMB given as AL
 37729                                  ;            -- returns UmbHEAD pointer (0x9FFF) if passed AL==0
 37730                                  ; -----------------------------------------------------------------------------
 37731                                  ; ENTRY:    AL should be to a valid UMB number
 37732                                  ; EXIT:     ES:0 points to first MCB in UMB (_not_ the 8+SC MCB that heads it)
 37733                                  ; ERROR:    Carry set if couldn't reach UMB (too high)
 37734                                  ; USES:     Flags, ES
 37735                                  ; -----------------------------------------------------------------------------
 37736                                  
 37737                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37738                                  findumb:
 37739                                  	;pushreg <ax,cx,dx>
 37740                                  	
 37741                                  	;push	ax
 37742 00006195 51                      	push	cx
 37743 00006196 52                      	push	dx
 37744                                  
 37745 00006197 30E4                    	xor	ah,ah		; Zap ah, so al==ax
 37746                                  
 37747 00006199 89C2                    	mov	dx,ax		; Store the to-be-found UMB number in DX
 37748                                  
 37749 0000619B E882FE                  	call	UmbHead		; Returns first UMB segment in AX
 37750                                  
 37751 0000619E 8EC0                    	mov	es,ax
 37752 000061A0 31C9                    	xor	cx,cx		; Pretend we're on UMB 0 for now...
 37753                                  
 37754                                  ; ---------------------------------------------
 37755                                  ; FU10--CX - This UMB number; 0 == conventional
 37756                                  ;       DX - The UMB number they're looking for
 37757                                  ;       ES - The current MCB address
 37758                                  ; ---------------------------------------------
 37759                                  
 37760                                  fu10:	
 37761 000061A2 39D1                    	cmp	cx,dx		; If CX==DX, we've found the UMB we're
 37762 000061A4 741B                    	je	short fuX	; searching for--so exit.
 37763                                  
 37764 000061A6 E884FE                  	call	isSysMCB	; Returns with ZF set if owner is SYSTEM
 37765 000061A9 7501                    	jnz	short fu20
 37766                                  
 37767 000061AB 41                      	inc	cx		; If it _was_ SYSTEM, we're in a new UMB.
 37768                                  fu20:
 37769                                  	;mov	al,[es:0]
 37770 000061AC 26A00000                	mov	al,[es:arena_signature]
 37771                                  	;cmp	al,'Z'
 37772 000061B0 3C5A                    	cmp	al,arena_signature_end
 37773 000061B2 740C                    	je	short fuE	; 'Z' means this was the last MCB... that's it.
 37774                                  
 37775                                  	;NextMCB es,ax		; Go on forward.
 37776                                  
 37777 000061B4 8CC0                     	mov	ax,es		; NextMCB (macro)
 37778                                  	;add	ax,[es:3]
 37779 000061B6 2603060300              	add	ax,[es:arena_size]
 37780 000061BB 40                      	inc	ax
 37781 000061BC 8EC0                    	mov	es,ax
 37782                                  
 37783 000061BE EBE2                    	jmp	short fu10
 37784                                  fuE:
 37785 000061C0 F9                      	stc
 37786                                  fuX:
 37787                                  	;popreg	<dx,cx,ax>	; The address is already in ES.
 37788                                  	
 37789 000061C1 5A                      	pop	dx
 37790 000061C2 59                      	pop	cx
 37791                                  	
 37792                                  	;pop	ax
 37793 000061C3 C3                      	retn
 37794                                  
 37795                                  ; -----------------------------------------------------------------------------
 37796                                  ;*** BigFree - makes ES:0 point to the largest free MCB in UMB given as AL
 37797                                  ; -----------------------------------------------------------------------------
 37798                                  ; ENTRY:    AL should be to a valid UMB number
 37799                                  ; EXIT:     ES:0 points to largest free MCB in UMB, AX returns its size
 37800                                  ; ERROR:    Carry set if couldn't reach UMB (0 or too high)
 37801                                  ; USES:     Flags, ES
 37802                                  ; -----------------------------------------------------------------------------
 37803                                  
 37804                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37805                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6624h
 37806                                  BigFree:
 37807                                  	;pushreg <bx,cx>
 37808                                  	
 37809                                  	;push	bx
 37810 000061C4 51                      	push	cx
 37811                                  
 37812 000061C5 E8CDFF                  	call	findumb			; Returns with CF if err, else ES==MCB
 37813 000061C8 7239                    	jc	short bfX		; (would be "jc bfE"; it just does stc)
 37814                                  
 37815 000061CA 31DB                    	xor	bx,bx			; Segment address of largest free MCB
 37816 000061CC 31C9                    	xor	cx,cx			; Size of largest free MCB
 37817                                  
 37818                                  ; ---------------------------------------------
 37819                                  ; BF10--ES - Current MCB address
 37820                                  ;       BX - Address of largest free MCB so far
 37821                                  ;       CX - Size of largest free MCB so far
 37822                                  ; ---------------------------------------------
 37823                                  
 37824                                  bf10:
 37825 000061CE E85CFE                  	call	isSysMCB		; If we've left the MCB, we're done.
 37826 000061D1 7427                    	jz	short bf30
 37827                                  
 37828 000061D3 E879FF                  	call	isFreeMCB		; Returns with ZF set if owner is 0
 37829 000061D6 750E                    	jnz	short bf20
 37830                                  
 37831                                  	;cmp	cx,[es:3]
 37832 000061D8 263B0E0300              	cmp	cx,[es:arena_size]	; Compare sizes...
 37833 000061DD 7F07                    	jg	short bf20		; Unless we're bigger,
 37834                                  
 37835 000061DF 8CC3                    	mov	bx,es			; Store this new element's address,
 37836                                  	;mov	cx,[es:3]
 37837 000061E1 268B0E0300              	mov	cx,[es:arena_size]	; and its size.
 37838                                  bf20:
 37839                                  	;mov	al,[es:0]
 37840 000061E6 26A00000                	mov	al,[es:arena_signature]
 37841                                  	;cmp	al,'Z'  ; 5Ah
 37842 000061EA 3C5A                    	cmp	al,arena_signature_end
 37843 000061EC 740C                    	je	short bf30		; 'Z' means this was the last MCB.
 37844                                  
 37845                                  	;NextMCB es,ax			; Go on forward.
 37846                                  
 37847 000061EE 8CC0                    	mov	ax,es 
 37848                                  	;add	ax,[es:3]
 37849 000061F0 2603060300              	add	ax,[es:arena_size]
 37850 000061F5 40                      	inc	ax
 37851 000061F6 8EC0                    	mov	es,ax
 37852                                  
 37853 000061F8 EBD4                    	jmp	short bf10
 37854                                  bf30:
 37855 000061FA 8EC3                    	mov	es,bx			; Return the address
 37856 000061FC 89C8                    	mov	ax,cx			; Return the size
 37857 000061FE 09DB                    	or	bx,bx
 37858 00006200 7501                    	jnz	short bfX		; (if size==0, there's nothing free)
 37859                                  bfE:
 37860 00006202 F9                      	stc
 37861                                  bfX:
 37862                                  	;popreg	<cx,bx>
 37863                                  
 37864 00006203 59                      	pop	cx
 37865                                  	;pop	bx
 37866                                  
 37867 00006204 C3                      	retn
 37868                                  
 37869                                  ; -----------------------------------------------------------------------------
 37870                                  ;*** isSpecified - sets ZF if UMB in AL wasn't specified in DH/LH line.
 37871                                  ; -----------------------------------------------------------------------------
 37872                                  ; ENTRY:    AL should be to a valid UMB number
 37873                                  ; EXIT:     ZF set if UMB wasn't specified, ZF clear if it was
 37874                                  ; ERROR:    None
 37875                                  ; USES:     Flags
 37876                                  ; -----------------------------------------------------------------------------
 37877                                  
 37878                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37879                                  isSpecified:
 37880                                  	;push	ax
 37881                                  
 37882 00006205 30FF                    	xor	bh,bh
 37883 00006207 88C3                    	mov	bl,al
 37884                                  
 37885                                  	;getdata al,DS:UmbUsed[bx]
 37886                                  
 37887 00006209 1E                      	push	ds
 37888 0000620A 8E1E[F39D]              	mov	ds,[RESSEG]
 37889 0000620E 8A87[0004]              	mov	al,[bx+UmbUsed]
 37890 00006212 1F                      	pop     ds
 37891                                  
 37892 00006213 08C0                    	or	al,al		; Sets ZF if al==0 (ie, if unspecified)
 37893                                  
 37894                                  	;pop	ax
 37895 00006215 C3                      	retn
 37896                                  
 37897                                  ; -----------------------------------------------------------------------------
 37898                                  ;*** shrinkMCB - breaks an MCB into two pieces, the lowest one's size==AX
 37899                                  ; -----------------------------------------------------------------------------
 37900                                  ; ENTRY:    AX == new size, ES:0 == current MCB
 37901                                  ; EXIT:     None; MCB broken if carry clear
 37902                                  ; ERROR:    Carry set if MCB isn't as large as AX+0x20 (not a useful split)
 37903                                  ; USES:     Flags
 37904                                  ; -----------------------------------------------------------------------------
 37905                                  ; If the size of the to-be-split MCB isn't at least 0x20 bytes greater than
 37906                                  ; the specified new size, the split is useless; if it's onnly 0x10 bytes, that
 37907                                  ; 0x10 will be used to make a header that mentions a 0-byte free space, and
 37908                                  ; that just sucks up 0x10 bytes for nothing. So we make 0x20 bytes the
 37909                                  ; minimum for performing a split.
 37910                                  ; -----------------------------------------------------------------------------
 37911                                  
 37912                                  ;MIN_SPLIT_SIZE	equ 20h
 37913                                  
 37914                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 37915                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:667Ah
 37916                                  shrinkMCB:
 37917                                  	;pushreg <bx,cx,es>
 37918                                  
 37919                                  	;push	bx
 37920 00006216 51                      	push	cx ; *
 37921 00006217 26                      	psuh	es ; **
 37922                                  
 37923 00006218 89C3                    	mov	bx,ax			; Move things around... and
 37924 0000621A 8CC0                    	mov	ax,es			; save this one for later.
 37925                                  
 37926 0000621C 268B0E0300              	mov	cx,[es:arena_size]
 37927 00006221 83E920                  	sub	cx,32 ; sub cx,MIN_SPLIT_SIZE
 37928                                  	;cmp	bx,cx			; {New size} vs {Current Size-20h}
 37929                                  	;ja	short smE		; if wanted_size > cur-20h, abort.
 37930 00006224 39D9                    	cmp	cx,bx
 37931 00006226 723E                    	jb	short smE ; cf = 1 (***)
 37932                                  
 37933                                  	;mov	dl,[es:0]
 37934 00006228 268A160000              	mov	dl,[es:arena_signature]
 37935                                  
 37936                                  	;;mov	cx,[es:3]
 37937                                  	;mov	cx,[es:arena_size] ; *!
 37938                                  
 37939 0000622D 26891E0300              	mov	[es:arena_size],bx
 37940                                  	;mov	byte [es:0],'M' ; 4Dh
 37941 00006232 26C60600004D            	mov	byte [es:arena_signature],'M'
 37942                                  
 37943 00006238 01D8                    	add	ax,bx
 37944 0000623A 40                      	inc	ax
 37945 0000623B 8EC0                    	mov	es,ax			; Move to new arena area
 37946                                  
 37947                                  	;mov	ax,cx ; !*
 37948 0000623D 26A10300                	mov	ax,[es:arena_size] ; *!
 37949 00006241 29D8                    	sub	ax,bx
 37950 00006243 48                      	dec	ax			; And prepare the new size
 37951                                  
 37952                                  	;mov	[es:0],dl
 37953 00006244 2688160000              	mov	[es:arena_signature],dl
 37954                                  	;;mov	word [es:1],0
 37955                                  	;mov	word [es:arena_owner],0
 37956                                  	;mov	[es:3],ax
 37957 00006249 26A30300                	mov	[es:arena_size],ax
 37958 0000624D B82020                  	mov	ax,'  ' ; mov ax,2020h
 37959                                  	;mov	[es:8],ax
 37960 00006250 26A30800                	mov	[es:arena_name+0],ax
 37961 00006254 26A30A00                	mov	[es:arena_name+2],ax
 37962 00006258 26A30C00                	mov	[es:arena_name+4],ax
 37963                                  	;mov	[es:14],ax
 37964 0000625C 26A30E00                	mov	[es:arena_name+6],ax
 37965                                  
 37966                                  	;clc
 37967 00006260 31C0                    	xor	ax,ax
 37968 00006262 26A30100                	mov	[es:arena_owner],ax ; 0
 37969                                  	; cf = 0
 37970                                  	;jmp	short smX
 37971                                  smE:
 37972                                  	;stc	 ; cf = 1 (***)
 37973                                  smX:
 37974                                  	;popreg	<es,cx,bx>
 37975 00006266 07                      	pop	es ; **
 37976 00006267 59                      	pop	cx ; *
 37977 00006268 5B                      	pop	bx
 37978                                  
 37979 00006269 C3                      	retn
 37980                                  
 37981                                  ; -----------------------------------------------------------------------------
 37982                                  ;*** hideUMB? - hides as appropriate the UMB in CL
 37983                                  ; -----------------------------------------------------------------------------
 37984                                  ; ENTRY:    CL should be to a valid UMB number, and AX to its address (findUMB)
 37985                                  ; EXIT:     None; UMB is hidden as necessary
 37986                                  ; ERROR:    None
 37987                                  ; USES:     Flags, AX, CX
 37988                                  ; -----------------------------------------------------------------------------
 37989                                  ; PRIMARY LOGIC:
 37990                                  ;
 37991                                  ; If the UMB is specified in the DH/LH statement, then:
 37992                                  ;    If the largest free segment is too small (check specified size), then:
 37993                                  ;       Pretend it wasn't ever specified, and fall out of this IF.
 37994                                  ;    Else, if largest free segment is LARGER than specified size, then:
 37995                                  ;       If /S was given on the command-line, then:
 37996                                  ;          Break that element into two pieces
 37997                                  ;          Set a flag that we're shrinking
 37998                                  ;       Endif
 37999                                  ;    Endif
 38000                                  ; Endif
 38001                                  ; If the UMB is NOT specified (or was removed by the above):
 38002                                  ;    Hide all free elements in the UMB
 38003                                  ;    If the flag that we're shrinking was set, then:
 38004                                  ;       UN-hide the lower portion of the shrunken UMB
 38005                                  ;    ENDIF
 38006                                  ; ENDIF
 38007                                  ; -----------------------------------------------------------------------------
 38008                                  
 38009                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38010                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:66D7h
 38011                                  hideUMB?:
 38012                                  	;pushreg <bx,dx,es>
 38013                                  
 38014                                  	;push	bx
 38015                                  	;push	dx
 38016                                  	;push	es
 38017                                  
 38018 0000626A 88C8                    	mov	al,cl
 38019 0000626C E896FF                  	call	isSpecified	; Returns ZF set if al's umb was NOT specified
 38020                                  	;jz	short hu?20
 38021                                  	; 17/06/2023
 38022 0000626F 7432                    	jz	short hu?25 ; *
 38023                                  
 38024 00006271 88C8                    	mov	al,cl		; Retrieve the size of the largest
 38025 00006273 E84EFF                  	call	BigFree		; free element in AX; put its address in ES
 38026                                  	;jc	short hu?20	; Oops. Errors mean skip this part.
 38027                                  	; 17/06/2023
 38028 00006276 723B                    	jc	short hu?X ; **
 38029                                  
 38030 00006278 50                      	push	ax		; TOS==size of BigFree in UMB (popped as BX)
 38031 00006279 88C8                    	mov	al,cl		; Retrieve the user's specified
 38032 0000627B E88AFE                  	call	GetSize		; minimum size for this umb (into AX)
 38033 0000627E 5B                      	pop	bx		; Now BX==BigFree, AX==Specified Size
 38034                                  
 38035 0000627F 09C0                    	or	ax,ax		; If they didn't specify one,
 38036                                  	;jz	short hu?20	; Skip over all this.
 38037                                  	; 17/06/2023
 38038 00006281 7530                    	jnz	short hu?X ; **
 38039                                  
 38040 00006283 39D8                    	cmp	ax,bx		; Ah... if (specified > max free)
 38041 00006285 7607                    	jbe	short hu?10
 38042                                  
 38043 00006287 88C8                    	mov	al,cl		;  Then mark that UMB as unused. Nya nya.
 38044 00006289 E898FC                  	call	unMarkUMB
 38045                                  	;jmp	short hu?20 ; ***
 38046                                  	; 17/06/2023
 38047                                  	; ('isSpecified' would return with ZF=1) ; ***
 38048 0000628C EB15                    	jmp	short hu?25
 38049                                  hu?10:
 38050 0000628E E8B0FE                  	call	isTiny		; Returns ZF clear if user specified /S
 38051                                  	;jz	short hu?20
 38052                                  	; 17/06/2023
 38053                                  	; ('isSpecified' would return with ZF=0) ; **
 38054 00006291 7420                    	jz	short hu?X
 38055                                  
 38056 00006293 E880FF                  	call	shrinkMCB	; They specified /S, so shrink the MCB to AX
 38057                                  	;jc	short hu?20	; Ah... if didn't shrink after all, skip this:
 38058                                  	; 17/06/2023
 38059                                  	; ('isSpecified' would return with ZF=0) ; **
 38060 00006296 721B                    	jc	short hu?X
 38061                                  
 38062 00006298 8CC2                    	mov	dx,es
 38063 0000629A EB09                    	jmp	short hu?30	; Skip the spec check.. we wanna hide this one.
 38064                                  hu?20:
 38065                                  	;mov	al,cl
 38066 0000629C 89C8                    	mov	ax,cx
 38067 0000629E E864FF                  	call	isSpecified	; If they specified this UMB, we're done...
 38068 000062A1 7510                    	jnz	short hu?X ; **	; so leave.
 38069                                  hu?25:	; 17/06/2023 ; *
 38070 000062A3 31D2                    	xor	dx,dx
 38071                                  hu?30:
 38072 000062A5 88C8                    	mov	al,cl
 38073                                  
 38074 000062A7 E870FE                  	call	hideUMB		; Hides everything in UMB #al
 38075                                  
 38076 000062AA 09D2                    	or	dx,dx		; Did we shrink a UMB? If not, DX==0,
 38077 000062AC 7405                    	jz	short hu?X	; So we should leave.
 38078                                  
 38079 000062AE 8EC2                    	mov	es,dx		; Ah, but if it isn't, DX==the MCB's address;
 38080 000062B0 E8C7FE                  	call	unHideMCB	; Un-hides the lower portion of that MCB.
 38081                                  hu?X:
 38082                                  	;popreg	<es,dx,bx>
 38083                                  
 38084                                  	;pop	es
 38085                                  	;pop	dx
 38086                                  	;pop	bx
 38087                                  
 38088 000062B3 C3                      	retn
 38089                                  
 38090                                  ; -----------------------------------------------------------------------------
 38091                                  ;*** UmbTest - returns with carry set if UMBs are not available, else CF==false
 38092                                  ; -----------------------------------------------------------------------------
 38093                                  ; ENTRY:    None
 38094                                  ; EXIT:     Carry is clear if UMBs are available, or set if they are not
 38095                                  ; ERROR:    None
 38096                                  ; USES:     CF (AX,BX,DS,ES pushed 'cause they're used by others)
 38097                                  ; -----------------------------------------------------------------------------
 38098                                  
 38099                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38100                                  UmbTest:
 38101                                  	;pushreg <ax,bx,ds,es>
 38102                                  	
 38103                                  	;push	ax
 38104                                  	;push	bx
 38105                                  	;push	ds
 38106                                  	;push	es
 38107                                  
 38108 000062B4 E88CFB                  	call	fm_link		; Link in UMBs (if not already linked)
 38109 000062B7 E80600                  	call	WalkMem		; Check to see if they're really linked
 38110 000062BA 9C                      	pushf			; And remember what we found out
 38111 000062BB E89CFB                  	call	fm_unlink	; Unlink UMBs (if WE have linked 'em)
 38112 000062BE 9D                      	popf			; And restore what we found out.
 38113                                  
 38114                                  	;popreg	<es,ds,bx,ax>
 38115                                  	
 38116                                  	;pop	es
 38117                                  	;pop	ds
 38118                                  	;pop	bx
 38119                                  	;pop	ax
 38120                                  	
 38121 000062BF C3                      	retn
 38122                                  
 38123                                  ; -----------------------------------------------------------------------------
 38124                                  ;*** WalkMem - travels memory chain and returns carry clear iff UMBs are linked
 38125                                  ; -----------------------------------------------------------------------------
 38126                                  ; ENTRY:    None
 38127                                  ; EXIT:     Carry SET if MCB chain stops before 9FFF, CLEAR if stops >= 9FFF.
 38128                                  ; ERROR:    None
 38129                                  ; USES:     Flags
 38130                                  ; -----------------------------------------------------------------------------
 38131                                  
 38132                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38133                                  WalkMem:
 38134                                  	;pushreg <ax,bx,es>
 38135                                  	
 38136                                  	;push	ax
 38137                                  	;push	bx
 38138 000062C0 06                      	push	es
 38139                                  
 38140 000062C1 B452                    	mov	ah,52h ; DOS_GET_DOS_LISTS
 38141                                  				; Call int 21h, function 52h...
 38142 000062C3 CD21                    	int	21h
 38143                                  
 38144 000062C5 268B47FE                	mov	ax,[es:bx-2]
 38145                                  	;mov	es,ax ; *
 38146                                  
 38147                                  ; ------------------------------
 38148                                  ; UM10: ES = Current MCB pointer
 38149                                  ; ------------------------------
 38150                                  
 38151                                  um10:	
 38152 000062C9 8EC0                    	mov	es,ax ; *
 38153                                  
 38154                                  	;mov	al,[es:0]
 38155 000062CB 26A00000                	mov	al,[es:arena_signature]
 38156                                  	;cmp	al,'Z' ; 5Ah
 38157 000062CF 3C5A                    	cmp	al,arena_signature_end
 38158 000062D1 740A                    	je	short um20	; If signature == 'Z', hay no more.
 38159                                  
 38160                                  	;NextMCB es,bx		; Move to the next MCB
 38161                                  	
 38162                                  	;mov	bx,es
 38163                                  	;;add	bx,[es:3]
 38164                                  	;add	bx,[es:arena_size]
 38165                                  	;inc	bx
 38166                                  	;mov	es,bx
 38167 000062D3 8CC0                    	mov	ax,es
 38168 000062D5 2603060300              	add	ax,[es:arena_size]
 38169 000062DA 40                      	inc	ax
 38170                                  	;mov	es,ax ; *
 38171                                  
 38172 000062DB EBEC                    	jmp	short um10	; And restart the loop.
 38173                                  um20:
 38174 000062DD 8CC0                    	mov	ax,es
 38175 000062DF 3DFF9F                  	cmp	ax,9FFFh	; This sets CF if ax < 9FFF.
 38176                                  
 38177                                  	;popreg	<es,bx,ax>
 38178 000062E2 07                      	pop	es
 38179                                  	;pop	bx
 38180                                  	;pop	ax
 38181                                  
 38182 000062E3 C3                      	retn
 38183                                  
 38184                                  ; -----------------------------------------------------------------------------
 38185                                  ;*** hl_unlink - unlinks UMBs if fm_umb is set to 0; restores strategy too
 38186                                  ; -----------------------------------------------------------------------------
 38187                                  ; ENTRY:    fm_umb == 1 : leave linked, else unlink
 38188                                  ; EXIT:     None
 38189                                  ; ERROR:    None
 38190                                  ; USES:     AX, BX
 38191                                  ; -----------------------------------------------------------------------------
 38192                                  
 38193                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38194                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:681Ch
 38195                                  hl_unlink:
 38196 000062E4 1E                      	push	ds ; *
 38197                                  
 38198 000062E5 30FF                    	xor	bh,bh
 38199                                  	;getdata bl,fm_umb	; Restore original link-state
 38200                                  
 38201                                  	;push	ds
 38202 000062E7 8E1E[F39D]              	mov	ds,[RESSEG]
 38203 000062EB 8A1E[DB04]              	mov	bl,[fm_umb]	; Restore original link-state
 38204                                  	;pop	ds
 38205                                  	
 38206 000062EF B80358                  	mov	ax,5803h ; DOS_SET_UMBLINK
 38207 000062F2 CD21                    	int	21h
 38208                                  
 38209 000062F4 30FF                    	xor	bh,bh
 38210                                  
 38211                                  	;getdata bl,fm_strat	; Restore original mem-alloc strategy
 38212                                  
 38213                                  	;push	ds
 38214                                  	;mov	ds,[RESSEG]
 38215 000062F6 8A1E[DC04]              	mov	bl,[fm_strat]	;Restore original mem-alloc strategy
 38216                                  	;pop	ds
 38217                                  
 38218 000062FA B80158                  	mov	ax,5801h ; DOS_SET_STRATEGY
 38219 000062FD CD21                    	int	21h
 38220                                  
 38221 000062FF 1F                      	pop	ds ; *
 38222                                  
 38223 00006300 C3                      	retn
 38224                                  
 38225                                  ;============================================================================
 38226                                  ; LOADHIGH.ASM, MSDOS 6.0, 1991
 38227                                  ;============================================================================
 38228                                  ; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38229                                  
 38230                                  ; This is a new module added to support loading programs into UMBs provided
 38231                                  ; by DOS 5.0. 
 38232                                  ; ---------------------------------------------------------------------------
 38233                                  ; Usage:
 38234                                  ;
 38235                                  ; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
 38236                                  ;
 38237                                  ; <filespec> has to be a filename that is not wildcarded.
 38238                                  
 38239                                  ; ---------------------------------------------------------------------------
 38240                                  ;
 38241                                  ;	Revision History
 38242                                  ;	================
 38243                                  ;
 38244                                  ;	M009	SR	08/01/90	Set flags to indicate that we are
 38245                                  ;				loading and high and also remember
 38246                                  ;				current UMB state.
 38247                                  ;
 38248                                  ;	M016	SR	08/09/90	Give special error message on attempt
 38249                                  ;				to loadhigh batch files and invalid
 38250                                  ;				filename on Loadhigh command line.
 38251                                  ;
 38252                                  ;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
 38253                                  ;				after the program name also as part
 38254                                  ;				of the command line being passed to
 38255                                  ;				the program to be invoked.
 38256                                  ;
 38257                                  ; ---------------------------------------------------------------------------
 38258                                  
 38259                                  ; ---------------------------------------------------------------------------
 38260                                  ;
 38261                                  ;	include highload.inc		; Grab code for ParseVar and such
 38262                                  
 38263                                  iCmdLine	equ	81h		; PSP:81h points to command-line
 38264                                  
 38265                                  ;
 38266                                  ; ---------------------------------------------------------------------------
 38267                                  
 38268                                  ;****	LoadHigh -- Main routine for Loadhigh command
 38269                                  ;
 38270                                  ;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
 38271                                  ;		CS = DS = SS = TRANGROUP
 38272                                  ;
 38273                                  ;	EXIT	None
 38274                                  ;
 38275                                  ;	USED	ax, bx, cx, dx, si, di, es
 38276                                  ;
 38277                                  ;	ERROR EXITS
 38278                                  ;		Message pointers are setup at the error locations and then
 38279                                  ;	we jump back to CERROR which is the transient error recycle point.
 38280                                  ;	Apart from parse errors, the other errors handled are too many
 38281                                  ;	switches anf invalid filenames.
 38282                                  ;
 38283                                  ;	EFFECTS
 38284                                  ;		The allocation strategy and the state of the arena chain are
 38285                                  ;	put in the requested state according to the given options. If a 
 38286                                  ;	filename is also given, it is executed as well.
 38287                                  ; ---------------------------------------------------------------------------
 38288                                  
 38289                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38290                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
 38291                                  
 38292                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38293                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:683Fh
 38294                                  LoadHigh:
 38295 00006301 1E                      	push	ds
 38296 00006302 07                      	pop	es
 38297                                  	
 38298                                  	; 16/06/2023
 38299                                  	;call	SkipLhDelims	; MSDOS 5.0 !
 38300                                  
 38301                                  ;Get command tail to be passed to the program. This includes any whitespace
 38302                                  ;chars between the program name and its parameters as well.
 38303                                  ;On return, ds:si points at the start of the command tail.
 38304                                  
 38305                                  	; 16/06/2023
 38306                                  	;push	si		; MSDOS 5.0 !
 38307 00006303 E81300                  	call	ParseLhCmd
 38308                                  	;pop	si		; MSDOS 5.0 !	
 38309 00006306 720E                    	jc	short LhErr
 38310                                  	
 38311 00006308 E86500                  	call	SetupCmdLine		;setup pgm's command line
 38312                                  
 38313 0000630B E88700                  	call	SetupPath		;setup path for file
 38314 0000630E 7206                    	jc	short LhErr		;file not found
 38315                                  
 38316                                  ;Set allocation strategy to HighFirst and link in UMBs for exec. This will
 38317                                  ;be reset after return from the Exec
 38318                                  ;We will also set a resident flag to indicate that UMBs were activated for
 38319                                  ;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
 38320                                  
 38321 00006310 E8AFFD                  	call	HideUMBs		;prepare upper-memory for load
 38322                                  
 38323 00006313 E939CB                  	jmp	LH_EXECUTE		;go and exec file ;M051
 38324                                  
 38325                                  LhErr:
 38326                                  ;The error message has been setup at this stage
 38327                                  
 38328 00006316 E989CB                  	jmp	cerror			;print error message and recycle 
 38329                                  
 38330                                  ; ---------------------------------------------------------------------------
 38331                                  					
 38332                                  ;*** 	ParseLhCmd - parses any command-line options
 38333                                  ;
 38334                                  ;	ENTRY	None
 38335                                  ;
 38336                                  ;	EXIT	Carry clear -- command line parsed successfully
 38337                                  ;		Carry set -- appropriate error message setup
 38338                                  ;
 38339                                  ;	USED	ax, si
 38340                                  ;
 38341                                  ;	EFFECTS
 38342                                  ;		Options set up (see highvar.inc)
 38343                                  ;		Filename to be executed setup
 38344                                  ;
 38345                                  ;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
 38346                                  ;	then calls ParseVar itself to actually parse the commmand-line.  On
 38347                                  ;	return from ParseVar, DS:SI will point to the beginning of the child
 38348                                  ;	module's name on the command-line; thus it calls LhCopyFilename to
 38349                                  ;	prepare the command-line for that program.
 38350                                  ; ---------------------------------------------------------------------------
 38351                                  
 38352                                  ; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38353                                  %if 0
 38354                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38355                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
 38356                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 38357                                  	; 11/06/2023
 38358                                  ParseLhCmd:
 38359                                  	;mov	si,81h
 38360                                  	mov	si,iCmdLine	;ds:si points at command line
 38361                                  
 38362                                  	mov	word [COMSW],0
 38363                                  	mov	di,Parse_LoadHi
 38364                                  	xor	cx,cx
 38365                                  	call	Parse_With_Msg
 38366                                  
 38367                                  	; 11/06/2023
 38368                                  	;cmp	ax,0FFFFh ; -1
 38369                                  	;jz	short PLhCmd2
 38370                                  	;cmp	ax,0
 38371                                  	;jnz	short PLhCmd1
 38372                                  	; 11/06/2023
 38373                                  	inc	ax ; cmp ax,-1
 38374                                  	jz	short PLhCmd2 ; 0FFFFh -> 0
 38375                                  	dec	ax ; cmp ax,0
 38376                                  	jnz	short PLhCmd1 ; 1 -> 0
 38377                                  	; ax = 0
 38378                                  
 38379                                  	mov	bx,dx
 38380                                  	; 14/04/2023
 38381                                  	;call	LhCopyFilename
 38382                                  	;; 13/04/2023
 38383                                  	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
 38384                                  	;;jmp	short PLhCmd2
 38385                                  	;retn
 38386                                  	; 14/04/2023
 38387                                  	jmp	short LhCopyFilename
 38388                                  PLhCmd1:
 38389                                  	stc
 38390                                  PLhCmd2:
 38391                                  	retn
 38392                                  %endif
 38393                                  
 38394                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38395                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6857h
 38396                                  	; MSDOS 6.0
 38397                                  ParseLhCmd:
 38398                                  	;assume	ds:TRANGROUP, es:TRANGROUP
 38399                                  	
 38400                                  	;mov	si,81h
 38401 00006319 BE8100                  	mov	si,iCmdLine	;ds:si points at command line
 38402                                  
 38403                                  	; es = ds (from 'LoadHigh') 
 38404                                  	;push	es		;Store ES 'cause we're gonna change it:
 38405                                  
 38406                                  	;push	ds
 38407                                  	;pop	es		;Make sure es:si points to cmd line as well
 38408                                  
 38409 0000631C E8ACFA                  	call	InitVar		;Initialize data for ParseVar
 38410                                  
 38411 0000631F E84AFB                  	call	ParseVar	;And parse the command line
 38412                                  
 38413                                  	;pop	es		;Restore ES now; we're done with it.
 38414                                  
 38415 00006322 7317                    	jnc	short plcC	;If no error, continue on our way.
 38416                                  
 38417 00006324 83F802                  	cmp	ax,2 ; PV_BadUMB
 38418                                  				;Bad UMB passed?
 38419 00006327 7505                    	jne	short plc10
 38420                                  	;mov	dx,offset TRANGROUP:LhBadUMB_Ptr
 38421 00006329 BA[5294]                	mov	dx,LhBadUMB_Ptr
 38422 0000632C F9                      	stc
 38423 0000632D C3                      	retn
 38424                                  plc10:	
 38425                                  	;mov	dx,offset TRANGROUP:LhInvSwt_Ptr
 38426 0000632E BA[4F94]                	mov	dx,LhInvSwt_Ptr
 38427 00006331 83F803                  	cmp	ax,3 ; PV_InvSwt
 38428                                  				;Unrecognized switch passed?
 38429 00006334 7403                    	je	short plc20
 38430                                  	;mov	dx,offset TRANGROUP:LhInvArg_Ptr
 38431 00006336 BA[4994]                	mov	dx,LhInvArg_Ptr
 38432                                  plc20:
 38433 00006339 F9                      	stc
 38434 0000633A C3                      	retn
 38435                                  plcC:
 38436                                  	;call	LhCopyFilename	;copy filename into our buffer
 38437                                  	;retn			;Return-- carry=status
 38438                                  	; 16/06/2023
 38439                                  	;jmp	short LhCopyFilename
 38440                                  
 38441                                  ; ---------------------------------------------------------------------------
 38442                                  
 38443                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38444                                  
 38445                                  ; ---------------------------------------------------------------------------
 38446                                  ; HIGHLOAD.INC, MSDOS 6.0, 1992
 38447                                  ; ---------------------------------------------------------------------------
 38448                                  
 38449                                  	; 13/04/2023
 38450                                  	; MSDOS 5.0 COMMAND.COM only !
 38451                                  	; (Procedure names are not from original Microsoft source code!)
 38452                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 38453                                  ;set_strategy:
 38454                                  	;mov	ax,5800h	; DOS_CHECK_STRATEGY
 38455                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38456                                  	;		; AL = function code: get allocation strategy
 38457                                  	;mov	bx,ax
 38458                                  	;or	bx,80h
 38459                                  	;mov	ax,5801h	; DOS_SET_STRATEGY
 38460                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38461                                  	;		; AL = function code: set allocation strategy
 38462                                  	;retn
 38463                                  
 38464                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 38465                                  ;set_umblink:
 38466                                  	;mov	ax,5803h	; DOS_SET_UMBLINK
 38467                                  	;mov	bx,1
 38468                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38469                                  	;		; AL = function code: (DOS 5beta) set UMB link state
 38470                                  	;retn
 38471                                  
 38472                                  ; ---------------------------------------------------------------------------
 38473                                  
 38474                                  ;***	LhCopyFilename -- copy filename from command line to buffer
 38475                                  ;
 38476                                  ;	ENTRY	ds:si points at primary argument (filename)
 38477                                  ;
 38478                                  ;	EXIT	Carry set -- filename has wildcards. In this event, DX will
 38479                                  ;				already contain an appropriate error number.
 38480                                  ;		Carry clear -- filename has been copied as needed; DS:SI
 38481                                  ;				points to first character (most likely space)
 38482                                  ;				after filename.
 38483                                  ;
 38484                                  ;	USED	ax, si
 38485                                  ;
 38486                                  ;	EFFECTS
 38487                                  ;		ExecPath contains the filename
 38488                                  ;
 38489                                  ; If there are any wildcards in the filename, then we have an error
 38490                                  ; ---------------------------------------------------------------------------
 38491                                  
 38492                                  ; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38493                                  %if 0
 38494                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38495                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
 38496                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 38497                                  LhCopyFilename:
 38498                                  	push	ds
 38499                                  	push	si
 38500                                  	push	di
 38501                                  	lds	si,[bx+4]
 38502                                  	mov	di,EXECPATH
 38503                                  lhcpfn1:
 38504                                  	lodsb
 38505                                  	cmp	al,2Ah ; '*'
 38506                                  	jz	short lhfilerr
 38507                                  	cmp	al,3Fh ; '?'
 38508                                  	jz	short lhfilerr
 38509                                  	stosb
 38510                                  	or	al,al
 38511                                  	jnz	short lhcpfn1
 38512                                  	; 14/04/2023
 38513                                  	; cf = 0
 38514                                  	;clc
 38515                                  lhfilerr2:
 38516                                  	pop	di
 38517                                  	pop	si
 38518                                  	pop	ds
 38519                                  	retn
 38520                                  lhfilerr:
 38521                                  	mov	dx,LhInvFil_Ptr
 38522                                  	stc
 38523                                  	jmp	short lhfilerr2
 38524                                  
 38525                                  %endif
 38526                                  
 38527                                  	; 16/06/2023 - Retro DOS v4.2 COMMAND.COM
 38528                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6881h
 38529                                  	; MSDOS 6.0
 38530                                  LhCopyFilename:
 38531                                  	;assume	ds:TRANGROUP, es:TRANGROUP
 38532                                  
 38533                                  	;mov	di,offset TRANGROUP:ExecPath
 38534 0000633B BF[1B9D]                	mov	di,EXECPATH
 38535                                  
 38536                                  	;mov	cx,0	; Copied zero characters
 38537 0000633E 29C9                    	sub	cx,cx
 38538                                  ;@@:
 38539                                  lhcpfn1:
 38540 00006340 AC                      	lodsb
 38541 00006341 3C2A                    	cmp	al,'*'			;wildcard?
 38542 00006343 7421                    	je	short lhfilerr		;yes, error
 38543 00006345 3C3F                    	cmp	al,'?'			;wildcard?
 38544 00006347 741D                    	je	short lhfilerr		;yes, error
 38545                                  
 38546 00006349 3C0D                    	cmp	al,0Dh			;carriage return?
 38547                                  	;jz	@f
 38548 0000634B 7410                    	je	short lhcpfn2
 38549 0000634D 3C2F                    	cmp	al,'/' ; SwitChar	;'/'?
 38550                                  	;jz	@f
 38551 0000634F 740C                    	je	short lhcpfn2
 38552 00006351 08C0                    	or	al,al			;EOS?
 38553                                  	;jz	@f
 38554 00006353 7408                    	jz	short lhcpfn2
 38555 00006355 3C20                    	cmp	al,' '			;Space?
 38556                                  	;jz	@f
 38557 00006357 7404                    	je	short lhcpfn2
 38558                                  	
 38559                                  	;or	al,al
 38560                                  	;;jz	@f
 38561                                  	;je	short lhcpfn2	
 38562                                  
 38563 00006359 AA                      	stosb				;store char
 38564 0000635A 41                      	inc	cx			;And remember that we did one more
 38565                                  	;jmp	short @b
 38566 0000635B EBE3                    	jmp	short lhcpfn1
 38567                                  ;@@:
 38568                                  lhcpfn2:
 38569 0000635D 30C0                    	xor	al,al			;Indicate EOS reached
 38570 0000635F AA                      	stosb				;store char
 38571                                  
 38572 00006360 09C9                    	or	cx,cx			;If we didn't copy any characters,
 38573 00006362 7407                    	jz	short lhmissing	; they didn't give a filename.
 38574                                  
 38575 00006364 4E                      	dec	si			;Move back to the delimiting character
 38576                                  	; cf = 0
 38577                                  	;clc				;And indicate no error occurred
 38578 00006365 C3                      	retn
 38579                                  lhfilerr:
 38580                                  	;mov	dx,offset TRANGROUP:LhInvFil_Ptr
 38581 00006366 BA[4394]                	mov	dx,LhInvFil_Ptr		;"Invalid Filename" ; M016
 38582 00006369 F9                      	stc
 38583 0000636A C3                      	retn
 38584                                  lhmissing:
 38585                                  	;mov	dx,offset TRANGROUP:ReqParmMiss
 38586 0000636B BA[4C94]                	mov	dx,ReqParmMiss		;"Required parm missing"
 38587 0000636E F9                      	stc
 38588 0000636F C3                      	retn
 38589                                  
 38590                                  ; ---------------------------------------------------------------------------
 38591                                  	
 38592                                  ; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 38593                                  %if 0
 38594                                  	; 14/04/2023
 38595                                  	; 13/04/2023
 38596                                  	; MSDOS 5.0 COMMAND.COM only !
 38597                                  	; (Procedure name is not from original Microsoft source code!)
 38598                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 38599                                  set_strategy:
 38600                                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 38601                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38602                                  			; AL = function code: get allocation strategy
 38603                                  	mov	bx,ax
 38604                                  	or	bx,80h
 38605                                  	mov	ax,5801h	; DOS_SET_STRATEGY
 38606                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38607                                  			; AL = function code: set allocation strategy
 38608                                  	retn
 38609                                  
 38610                                  ; ---------------------------------------------------------------------------
 38611                                  
 38612                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38613                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
 38614                                  	; MSDOS 5.0 COMMAND.COM only !
 38615                                  	; (Procedure name is not from original Microsoft source code!)
 38616                                  SkipLhDelims:
 38617                                  	mov	si,81h
 38618                                  	call	scanoff
 38619                                  stfn1:
 38620                                  	lodsb
 38621                                  	call	DELIM
 38622                                  	jz	short stfn2
 38623                                  	cmp	al,0Dh
 38624                                  	jz	short stfn2
 38625                                  	cmp	al,[SWITCHAR]
 38626                                  	jnz	short stfn1
 38627                                  stfn2:
 38628                                  	dec	si
 38629                                  	retn
 38630                                  
 38631                                  %endif
 38632                                  
 38633                                  ; ---------------------------------------------------------------------------
 38634                                  
 38635                                  ;***	SetupCmdLine -- prepare command line for the program
 38636                                  ;
 38637                                  ;	ENTRY	{es/ds}:si = points just after the end of the child program
 38638                                  ;
 38639                                  ;	EXIT	None
 38640                                  ;
 38641                                  ;	USED
 38642                                  ;
 38643                                  ;	EFFECTS		
 38644                                  ;		The rest of the command line following the pgm name is 
 38645                                  ;	moved to the top of the command line buffer (at TRANGROUP:81h)
 38646                                  ;	and a new command line length is put in
 38647                                  ; ---------------------------------------------------------------------------
 38648                                  
 38649                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38650                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
 38651                                  
 38652                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38653                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:68BEh
 38654                                  SetupCmdLine:
 38655                                  	;mov	di,81h
 38656 00006370 BF8100                  	mov	di,iCmdLine
 38657 00006373 30C9                    	xor	cl,cl
 38658 00006375 FEC9                    	dec	cl			;just CR means count = 0
 38659                                  SetCmdL1:
 38660 00006377 AC                      	lodsb
 38661 00006378 AA                      	stosb
 38662 00006379 FEC1                    	inc	cl			;update count
 38663                                  	
 38664                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38665                                  	; MSDOS 6.0
 38666                                  	; 14/04/2023
 38667                                  	; * ; MSDOS 6.0 only !
 38668 0000637B 08C0                    	or	al,al	; *
 38669 0000637D 7404                    	jz	short SetCmdL2 ; *
 38670                                  	
 38671 0000637F 3C0D                    	cmp	al,0Dh			;carriage return?
 38672 00006381 75F4                    	jnz	short SetCmdL1		;no, continue storing
 38673                                  SetCmdL2:
 38674 00006383 26880E8000              	mov	[es:80h],cl		;store new cmd line length
 38675 00006388 C3                      	retn
 38676                                  
 38677                                  ; ---------------------------------------------------------------------------
 38678                                  
 38679                                  ;***	LhSetupErrMsg -- Sets up error messages
 38680                                  ;
 38681                                  ;	ENTRY	ax = error message number
 38682                                  ;
 38683                                  ;	EXIT	None
 38684                                  ;
 38685                                  ;	USED	dx
 38686                                  ;
 38687                                  ;	EFFECTS
 38688                                  ;		Everything setup to display error message
 38689                                  ; ---------------------------------------------------------------------------
 38690                                  	
 38691                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38692                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38693                                  LhSetupErrMsg:
 38694 00006389 C606[CE91]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 38695 0000638E BA[D091]                	mov	dx,extend_buf_ptr
 38696 00006391 A3[D091]                	mov	[extend_buf_ptr],ax
 38697 00006394 C3                      	retn
 38698                                  
 38699                                  ; ---------------------------------------------------------------------------
 38700                                  
 38701                                  ; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 38702                                  %if 0
 38703                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38704                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
 38705                                  	; MSDOS 5.0 COMMAND.COM only !
 38706                                  	; (Procedure name is not from original Microsoft source code!)
 38707                                  check_umblink:
 38708                                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 38709                                  	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38710                                  			 ; AL = function code: get allocation strategy
 38711                                  	mov	bl,al
 38712                                  	mov	ax,5802h	; DOS_CHECK_UMBLINK
 38713                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38714                                  			; AL = function code: (DOS 5beta) get UMB link state
 38715                                  	mov	bh,al
 38716                                  	xchg	ax,bx
 38717                                  	rol	al,1
 38718                                  	and	al,1
 38719                                  	shl	ah,1
 38720                                  	or	al,ah
 38721                                  	retn
 38722                                  
 38723                                  ; ---------------------------------------------------------------------------
 38724                                  
 38725                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38726                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
 38727                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 38728                                  HideUMBs:
 38729                                  	push	ds
 38730                                  	call	check_umblink
 38731                                  	mov	ds,[RESSEG]
 38732                                  	mov	[fInHigh],al
 38733                                  	or	byte [fInHigh],80h
 38734                                  	pop	ds
 38735                                  	call	set_strategy
 38736                                  	;call	set_umblink
 38737                                  	;retn
 38738                                  	; 14/04/023
 38739                                  	;jmp	short set_umblink
 38740                                  
 38741                                  ; ---------------------------------------------------------------------------
 38742                                  
 38743                                  	; 14/04/2023
 38744                                  	; 13/04/2023
 38745                                  	; MSDOS 5.0 COMMAND.COM only !
 38746                                  	; (Procedure name is not from original Microsoft source code!)
 38747                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 38748                                  set_umblink:
 38749                                  	mov	ax,5803h	; DOS_SET_UMBLINK
 38750                                  	mov	bx,1
 38751                                  	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 38752                                  			; AL = function code: (DOS 5beta) set UMB link state
 38753                                  	retn
 38754                                  %endif
 38755                                  
 38756                                  ; ---------------------------------------------------------------------------
 38757                                  
 38758                                  ;***	SetupPath -- Do path search for the file to be executed
 38759                                  ;
 38760                                  ;	ENTRY	None
 38761                                  ;
 38762                                  ;	EXIT	Carry set if file not found or not executable file
 38763                                  ;
 38764                                  ;	EFFECTS
 38765                                  ;		ExecPath contains the full path of the file to be executed
 38766                                  ; ---------------------------------------------------------------------------
 38767                                  
 38768                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38769                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
 38770                                  
 38771                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38772                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:68E3h
 38773                                  SetupPath:
 38774                                  
 38775                                  ;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
 38776                                  ;because the path search routine that we are about to invoke expects the
 38777                                  ;filename to search for to be argv[0].
 38778                                  ;
 38779                                  ;If our new argv[0] starts with a switcharacter, it's an option... skip right
 38780                                  ;over it by doing the whole move again (smaller, of course, this time).
 38781                                  
 38782                                  	;mov	ax,arg.argvcnt		;total number of arguments
 38783                                  	; 14/04/2023
 38784                                  	;mov	ax,[ARG_ARGVCNT]
 38785 00006395 A1[01A5]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 38786                                  
 38787 00006398 48                      	dec	ax			;less one - skip "LoadHigh"
 38788                                  	;mov	bx,SIZE Argv_ele
 38789 00006399 BB0B00                  	mov	bx,ARGV_ELE.SIZE ; 11
 38790                                  	;mov	bx,11
 38791 0000639C F7E3                    	mul	bx			;dx:ax = size of argument lists
 38792                                  
 38793                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 38794                                  	; --------------------------------------
 38795                                  	; MSDOS 6.0
 38796                                  
 38797                                  	;getdata cl,fm_argc		;CL = number of arguments to skip
 38798 0000639E 1E                      	push	ds			; getdata (macro)
 38799 0000639F 8E1E[F39D]              	mov	ds,[RESSEG]
 38800 000063A3 8A0E[DD04]              	mov	cl,[fm_argc]
 38801 000063A7 1F                      	pop	ds
 38802                                  	
 38803 000063A8 FEC1                    	inc	cl			;Skip one arg, to get over "lh"
 38804                                  
 38805                                  ;Move argv[1]..argv[n] to argv[0]..argv[n-1]. Here, AX == the overall size
 38806                                  ;of the argument lists.
 38807                                  
 38808                                  argloop:
 38809 000063AA E31B                    	jcxz	argdone			;If we've finished copying args, leave.
 38810                                  
 38811 000063AC 49                      	dec	cx			;One less time we'll go through this.
 38812                                  
 38813 000063AD 50                      	push	ax			;Copy ( size of remaining list ) bytes
 38814 000063AE 51                      	push	cx			;And remember how many args there were
 38815                                  
 38816                                  	; --------------------------------------
 38817                                  
 38818                                  	; 14/04/2023
 38819 000063AF 89C1                    	mov	cx,ax			;size to move
 38820                                  
 38821                                  	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
 38822                                  	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
 38823 000063B1 BF[41A2]                	mov	di,ARG	
 38824 000063B4 89FE                    	mov	si,di			;
 38825                                  	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
 38826 000063B6 83C60B                  	add	si,ARGV_ELE.SIZE ; 11
 38827                                  	
 38828                                  	; 14/04/2023
 38829                                  	;mov	cx,ax
 38830                                  
 38831 000063B9 FC                      	cld
 38832 000063BA F3A4                    	rep	movsb			;Move the argument list
 38833                                  	
 38834                                  	;dec	arg.argvcnt		;Fake one less argument, and
 38835                                  	;dec	word [ARG_ARGVCNT]
 38836 000063BC FF0E[01A5]              	dec	word [ARG+ARG_UNIT.argvcnt]
 38837                                  
 38838                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 38839                                  	; --------------------------------------
 38840                                  	; MSDOS 6.0
 38841                                  	
 38842                                  	;sub	ax,ARGV_ELE.SIZE ; 11	;there's one argument we don't copy.
 38843                                  
 38844 000063C0 59                      	pop	cx
 38845 000063C1 58                      	pop	ax			;Restore the size of the arg list
 38846                                  	; 17/06/2023
 38847                                  	;jmp	short argloop
 38848                                  	
 38849                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38850 000063C2 83E80B                  	sub	ax,ARGV_ELE.SIZE ; 11
 38851 000063C5 77E3                    	ja	short argloop
 38852                                  	; --------------------------------------
 38853                                  	
 38854                                  ; Done moving... argv[0] is now the child program's name, and [1] its first arg
 38855                                  
 38856                                  	; 17/06/2023
 38857                                  argdone:
 38858 000063C7 E8E6D2                  	call	path_search		;look in the path
 38859                                  
 38860                                  ;ax = 0, no file found
 38861                                  ;ax < 4, batch file found -- cant be executed
 38862                                  ;ax = 4,8 => .com or .exe file found
 38863                                  
 38864 000063CA 09C0                    	or	ax,ax			;any file found?
 38865 000063CC 740B                    	jz	short no_exec_file	;no, error
 38866                                  
 38867 000063CE 83F804                  	cmp	ax,4			;executable file?
 38868                                  	;jl	short no_exec_bat	;no, indicate fail ; M016
 38869                                  	;clc
 38870                                  	;retn
 38871                                  	; 14/04/2023
 38872 000063D1 7201                    	jb	short no_exec_bat
 38873 000063D3 C3                      	retn 
 38874                                  
 38875                                  no_exec_bat:
 38876 000063D4 BA[4094]                	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
 38877 000063D7 EB06                    	jmp	short lhsp_errret	;return error; M016
 38878                                  
 38879                                  no_exec_file:
 38880 000063D9 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 38881 000063DC E8AAFF                  	call	LhSetupErrMsg		;setup error message
 38882                                  lhsp_errret:				; M016
 38883 000063DF F9                      	stc
 38884 000063E0 C3                      	retn
 38885                                  
 38886                                  ;============================================================================
 38887                                  ; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
 38888                                  ;============================================================================
 38889                                  ; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38890                                  
 38891                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h
 38892                                  
 38893                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 38894                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6930h
 38895                                  
 38896                                  ; ---------------------------------------------------------------------------
 38897                                  ; Class 3 message table/structure
 38898                                  ; ---------------------------------------------------------------------------
 38899                                  
 38900                                  $M_CLASS_3_STRUC:
 38901 000063E1 FF                      	db 0FFh			; $M_CLASS_ID (Class identifer)
 38902                                  	;dw 5			; $M_COMMAND_VER (COMMAND.COM version)
 38903                                  	;db 162			; Total number of messages
 38904                                  	; 17/06/2023
 38905 000063E2 0616                    	dw 1606h		; MSDOS 6.22 COMMAND.COM (hb=22,lb=6)	
 38906 000063E4 BB                      	db 187			; Total number of messages
 38907                                  $M_ID_3_1:
 38908                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
 38909 000063E5 FC03                    	dw 1020			; Message Number = 1020
 38910                                  	;dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
 38911                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38912 000063E7 EC02                    	dw MSG_1020-$+2 ; 2ECh	; Message offset from message number (6934h+02ECh=6C20h)
 38913                                  $M_ID_3_2:
 38914 000063E9 F703                    	dw 1015			; Message Number = 1015
 38915                                  	;dw MSG_1015-$+2 ; 294h ; Message offset from message number (5A4Ch+0294h=5CE0h)
 38916                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38917 000063EB F802                    	dw MSG_1015-$+2 ; 2F8h	; Message offset from message number (6938h+02F8h=6C30h)
 38918                                  $M_ID_3_3:	; 26/04/2023
 38919                                  			; 17/06/2023
 38920 000063ED EC031803                	dw 1004,MSG_1004-$ ; 792
 38921 000063F1 02042E03                	dw 1026,MSG_1026-$ ; 814
 38922 000063F5 07043E03                	dw 1031,MSG_1031-$ ; 830
 38923 000063F9 0B044903                	dw 1035,MSG_1035-$ ; 841
 38924 000063FD 26045403                	dw 1062,MSG_1062-$ ; 852
 38925 00006401 04045F03                	dw 1028,MSG_1028-$ ; 863
 38926 00006405 15047D03                	dw 1045,MSG_1045-$ ; 893
 38927 00006409 11049603                	dw 1041,MSG_1041-$ ; 918
 38928 0000640D 1204B403                	dw 1042,MSG_1042-$ ; 948
 38929                                  $M_ID_3_12:
 38930 00006411 1304CB03                	dw 1043,MSG_1043-$ ; 971
 38931 00006415 EA03E703                	dw 1002,MSG_1002-$ ; 999
 38932 00006419 EB030B04                	dw 1003,MSG_1003-$ ; 1035
 38933 0000641D EF032304                	dw 1007,MSG_1007-$ ; 1059
 38934 00006421 F0033A04                	dw 1008,MSG_1008-$ ; 1082
 38935 00006425 F1034C04                	dw 1009,MSG_1009-$ ; 1100
 38936 00006429 F2035D04                	dw 1010,MSG_1010-$ ; 1117
 38937 0000642D F3037904                	dw 1011,MSG_1011-$ ; 1145
 38938 00006431 F6039004                	dw 1014,MSG_1014-$ ; 1168
 38939 00006435 F8039D04                	dw 1016,MSG_1016-$ ; 1181
 38940 00006439 F903C304                	dw 1017,MSG_1017-$ ; 1219
 38941 0000643D FA03E404                	dw 1018,MSG_1018-$ ; 1252
 38942                                  $M_ID_3_24:
 38943 00006441 FB03F404                	dw 1019,MSG_1019-$ ; 1268
 38944 00006445 FD03FC04                	dw 1021,MSG_1021-$ ; 1276
 38945 00006449 FE031605                	dw 1022,MSG_1022-$ ; 1302
 38946 0000644D FF033905                	dw 1023,MSG_1023-$ ; 1337
 38947 00006451 00046105                	dw 1024,MSG_1024-$ ; 1377
 38948 00006455 01047405                	dw 1025,MSG_1025-$ ; 1396
 38949 00006459 03048805                	dw 1027,MSG_1027-$ ; 1416
 38950 0000645D 0504A505                	dw 1029,MSG_1029-$ ; 1445
 38951 00006461 0604B305                	dw 1030,MSG_1030-$ ; 1459
 38952 00006465 0804BE05                	dw 1032,MSG_1032-$ ; 1470
 38953 00006469 0904D205                	dw 1033,MSG_1033-$ ; 1490
 38954 0000646D 0A04E405                	dw 1034,MSG_1034-$ ; 1508
 38955 00006471 0C04F605                	dw 1036,MSG_1036-$ ; 1526
 38956 00006475 0D040706                	dw 1037,MSG_1037-$ ; 1543
 38957 00006479 0E041406                	dw 1038,MSG_1038-$ ; 1556
 38958 0000647D 0F042306                	dw 1039,MSG_1039-$ ; 1571
 38959                                  $M_ID_3_40:
 38960 00006481 10045C06                	dw 1040,MSG_1040-$ ; 1628
 38961 00006485 14046D06                	dw 1044,MSG_1044-$ ; 1645
 38962 00006489 16047D06                	dw 1046,MSG_1046-$ ; 1661
 38963 0000648D 1704B006                	dw 1047,MSG_1047-$ ; 1712
 38964 00006491 1804C506                	dw 1048,MSG_1048-$ ; 1733
 38965 00006495 1904D306                	dw 1049,MSG_1049-$ ; 1747
 38966 00006499 1A04D906                	dw 1050,MSG_1050-$ ; 1753
 38967 0000649D 1B04F406                	dw 1051,MSG_1051-$ ; 1780
 38968 000064A1 1C040107                	dw 1052,MSG_1052-$ ; 1793
 38969 000064A5 1D041407                	dw 1053,MSG_1053-$ ; 1812
 38970 000064A9 1E043607                	dw 1054,MSG_1054-$ ; 1846
 38971                                  $M_ID_3_51:
 38972 000064AD 1F045907                	dw 1055,MSG_1055-$ ; 1881
 38973 000064B1 20046307                	dw 1056,MSG_1056-$ ; 1891
 38974 000064B5 21046E07                	dw 1057,MSG_1057-$ ; 1902
 38975 000064B9 23047707                	dw 1059,MSG_1059-$ ; 1911
 38976 000064BD 24047807                	dw 1060,MSG_1060-$ ; 1912
 38977 000064C1 25047807                	dw 1061,MSG_1061-$ ; 1912
 38978 000064C5 27048E07                	dw 1063,MSG_1063-$ ; 1934
 38979 000064C9 28048D07                	dw 1064,MSG_1064-$ ; 1933
 38980 000064CD 29048C07                	dw 1065,MSG_1065-$ ; 1932
 38981 000064D1 2A048B07                	dw 1066,MSG_1066-$ ; 1931
 38982 000064D5 2B048A07                	dw 1067,MSG_1067-$ ; 1930
 38983 000064D9 2C048807                	dw 1068,MSG_1068-$ ; 1928
 38984 000064DD 2D048F07                	dw 1069,MSG_1069-$ ; 1935
 38985 000064E1 2E048F07                	dw 1070,MSG_1070-$ ; 1935
 38986 000064E5 2F048E07                	dw 1071,MSG_1071-$ ; 1934
 38987 000064E9 30048D07                	dw 1072,MSG_1072-$ ; 1933
 38988                                  $M_ID_3_67:
 38989 000064ED 31049307                	dw 1073,MSG_1073-$ ; 1939
 38990 000064F1 32049907                	dw 1074,MSG_1074-$ ; 1945
 38991 000064F5 33049F07                	dw 1075,MSG_1075-$ ; 1951
 38992 000064F9 3404A107                	dw 1076,MSG_1076-$ ; 1953
 38993 000064FD 3504A007                	dw 1077,MSG_1077-$ ; 1952
 38994 00006501 3604A407                	dw 1078,MSG_1078-$ ; 1956
 38995 00006505 3704BB07                	dw 1079,MSG_1079-$ ; 1979
 38996 00006509 3804C207                	dw 1080,MSG_1080-$ ; 1986
 38997 0000650D 3904D407                	dw 1081,MSG_1081-$ ; 2004
 38998                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 38999 00006511 3A04FB07                	dw 1082,MSG_1082-$ ; 2043	
 39000 00006515 3B04FF07                	dw 1083,MSG_1083-$ ; 2047	
 39001                                  	;
 39002 00006519 3C04FE07                	dw 1084,MSG_1084-$ ; 2046
 39003 0000651D 42040A08                	dw 1090,MSG_1090-$ ; 2058
 39004 00006521 43041408                	dw 1091,MSG_1091-$ ; 2068
 39005 00006525 44041E08                	dw 1092,MSG_1092-$ ; 2078
 39006 00006529 45042808                	dw 1093,MSG_1093-$ ; 2088
 39007 0000652D 46043908                	dw 1094,MSG_1094-$ ; 2105
 39008 00006531 47045208                	dw 1095,MSG_1095-$ ; 2130
 39009 00006535 48046B08                	dw 1096,MSG_1096-$ ; 2155
 39010                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 39011 00006539 49049808                	dw 1097,MSG_1097-$ ; 2200
 39012 0000653D 4A04B108                	dw 1098,MSG_1098-$ ; 2225
 39013 00006541 4B04CA08                	dw 1099,MSG_1099-$ ; 2250
 39014 00006545 4C04DC08                	dw 1100,MSG_1100-$ ; 2268
 39015 00006549 4D04FE08                	dw 1101,MSG_1101-$ ; 2302
 39016 0000654D 4E040909                	dw 1102,MSG_1102-$ ; 2313
 39017 00006551 4F043F09                	dw 1103,MSG_1103-$ ; 2367
 39018 00006555 50045609                	dw 1104,MSG_1104-$ ; 2390
 39019 00006559 51045609                	dw 1105,MSG_1105-$ ; 2390 ; TRANGROUP:6AA8h 
 39020                                  ;$M_ID_3_84:
 39021                                  $M_ID_3_95: ; 17/06/2023	
 39022 0000655D B0045709                	dw 1200,MSG_1200-$ ; 2391
 39023 00006561 14055409                	dw 1300,MSG_1300-$ ; 2388
 39024 00006565 2805D709                	dw 1320,MSG_1320-$ ; 2519
 39025 00006569 2905130A                	dw 1321,MSG_1321-$ ; 2579
 39026 0000656D 3C05800A                	dw 1340,MSG_1340-$ ; 2688
 39027 00006571 3D05D80A                	dw 1341,MSG_1341-$ ; 2776
 39028 00006575 3E05370B                	dw 1342,MSG_1342-$ ; 2871
 39029 00006579 5005C50B                	dw 1360,MSG_1360-$ ; 3013
 39030 0000657D 7805DD0B                	dw 1400,MSG_1400-$ ; 3037
 39031 00006581 7905760C                	dw 1401,MSG_1401-$ ; 3190
 39032 00006585 7A05DB0C                	dw 1402,MSG_1402-$ ; 3291
 39033 00006589 7B054E0D                	dw 1403,MSG_1403-$ ; 3406
 39034 0000658D 7C058A0D                	dw 1404,MSG_1404-$ ; 3466 ; TRANGROUP:6ADCh 
 39035                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 39036 00006591 7D05FB0D                	dw 1405,MSG_1405-$ ; 3579 ; TRANGROUP:6AE0h 
 39037 00006595 7E056A0E                	dw 1406,MSG_1406-$ ; 3690
 39038 00006599 7F05A90E                	dw 1407,MSG_1407-$ ; 3753 ; (MSG_1404 for MSDOS 5.0 COMMAND.COM)
 39039                                  	;
 39040 0000659D 8C052D0F                	dw 1420,MSG_1420-$ ; 3885
 39041 000065A1 A005B40F                	dw 1440,MSG_1440-$ ; 4020
 39042 000065A5 A1050E10                	dw 1441,MSG_1441-$ ; 4110
 39043                                  ;$M_ID_3_100:
 39044                                  $M_ID_3_114: ; 17/06/2023
 39045 000065A9 B4058E10                	dw 1460,MSG_1460-$ ; 4238
 39046 000065AD B505EF10                	dw 1461,MSG_1461-$ ; 4335
 39047 000065B1 B6056F11                	dw 1462,MSG_1462-$ ; 4463
 39048 000065B5 C805BB11                	dw 1480,MSG_1480-$ ; 4539
 39049 000065B9 C9054112                	dw 1481,MSG_1481-$ ; 4673
 39050 000065BD CA055C12                	dw 1482,MSG_1482-$ ; 4700
 39051 000065C1 CB05A912                	dw 1483,MSG_1483-$ ; 4777
 39052 000065C5 CC05FF12                	dw 1484,MSG_1484-$ ; 4863
 39053 000065C9 CD057A13                	dw 1485,MSG_1485-$ ; 4986
 39054 000065CD CE05F213                	dw 1486,MSG_1486-$ ; 5106
 39055 000065D1 CF058414                	dw 1487,MSG_1487-$ ; 5252
 39056 000065D5 D005C714                	dw 1488,MSG_1488-$ ; 5319
 39057                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 39058 000065D9 D1054315                	dw 1489,MSG_1489-$ ; 5443
 39059 000065DD D2058115                	dw 1490,MSG_1490-$ ; 5505
 39060 000065E1 D3059915                	dw 1491,MSG_1491-$ ; 5529
 39061 000065E5 D405E815                	dw 1492,MSG_1492-$ ; 5608
 39062 000065E9 D5057716                	dw 1493,MSG_1493-$ ; 5751
 39063 000065ED D6058A16                	dw 1494,MSG_1494-$ ; 5770
 39064                                  ;$M_ID_3_112:
 39065                                  $M_ID_3_132: ; 17/06/2023
 39066 000065F1 DC05A416                	dw 1500,MSG_1500-$ ; 5796
 39067 000065F5 F005DF16                	dw 1520,MSG_1520-$ ; 5855
 39068 000065F9 04061917                	dw 1540,MSG_1540-$ ; 5913
 39069 000065FD 05067317                	dw 1541,MSG_1541-$ ; 6003
 39070 00006601 0606DB17                	dw 1542,MSG_1542-$ ; 6107
 39071 00006605 18061318                	dw 1560,MSG_1560-$ ; 6163
 39072 00006609 19064718                	dw 1561,MSG_1561-$ ; 6215
 39073 0000660D 1A06C018                	dw 1562,MSG_1562-$ ; 6336
 39074 00006611 1B06EC18                	dw 1563,MSG_1563-$ ; 6380
 39075 00006615 1C061319                	dw 1564,MSG_1564-$ ; 6419
 39076 00006619 1D064D19                	dw 1565,MSG_1565-$ ; 6477
 39077 0000661D 1E067E19                	dw 1566,MSG_1566-$ ; 6526
 39078 00006621 1F06A719                	dw 1567,MSG_1567-$ ; 6567
 39079 00006625 20061D1A                	dw 1568,MSG_1568-$ ; 6685
 39080 00006629 2C06661A                	dw 1580,MSG_1580-$ ; 6758
 39081                                  ;$M_ID_3_127:
 39082                                  $M_ID_3_147: ; 17/06/2023
 39083 0000662D 4006AA1A                	dw 1600,MSG_1600-$ ; 6826
 39084 00006631 4106C31A                	dw 1601,MSG_1601-$ ; 6851
 39085 00006635 4206131B                	dw 1602,MSG_1602-$ ; 6931
 39086 00006639 5406B01B                	dw 1620,MSG_1620-$ ; 7088
 39087 0000663D 5506041C                	dw 1621,MSG_1621-$ ; 7172
 39088 00006641 5606821C                	dw 1622,MSG_1622-$ ; 7298
 39089 00006645 6806CA1C                	dw 1640,MSG_1640-$ ; 7370
 39090 00006649 6906F41C                	dw 1641,MSG_1641-$ ; 7412
 39091 0000664D 7C06741D                	dw 1660,MSG_1660-$ ; 7540
 39092 00006651 9006B71D                	dw 1680,MSG_1680-$ ; 7607
 39093 00006655 A406D91D                	dw 1700,MSG_1700-$ ; 7641
 39094 00006659 B806871E                	dw 1720,MSG_1720-$ ; 7815
 39095 0000665D CC06D61E                	dw 1740,MSG_1740-$ ; 7894
 39096 00006661 CD062E1F                	dw 1741,MSG_1741-$ ; 7982
 39097 00006665 E0069D1F                	dw 1760,MSG_1760-$ ; 8093
 39098 00006669 F406E61F                	dw 1780,MSG_1780-$ ; 8166
 39099                                  ;$M_ID_3_143:
 39100                                  $M_ID_3_163: ; 17/06/2023
 39101 0000666D 08074E20                	dw 1800,MSG_1800-$ ; 8270
 39102 00006671 09079820                	dw 1801,MSG_1801-$ ; 8344
 39103 00006675 1C07EC20                	dw 1820,MSG_1820-$ ; 8428
 39104 00006679 1D073021                	dw 1821,MSG_1821-$ ; 8496
 39105 0000667D 3007B721                	dw 1840,MSG_1840-$ ; 8631
 39106 00006681 4407FE21                	dw 1860,MSG_1860-$ ; 8702
 39107 00006685 45075522                	dw 1861,MSG_1861-$ ; 8789
 39108 00006689 46079822                	dw 1862,MSG_1862-$ ; 8856
 39109 0000668D 47071223                	dw 1863,MSG_1863-$ ; 8978
 39110 00006691 4807B123                	dw 1864,MSG_1864-$ ; 9137
 39111 00006695 49071424                	dw 1865,MSG_1865-$ ; 9236
 39112 00006699 4A077B24                	dw 1866,MSG_1866-$ ; 9339
 39113 0000669D 5807DF24                	dw 1880,MSG_1880-$ ; 9439
 39114 000066A1 59075325                	dw 1881,MSG_1881-$ ; 9555
 39115 000066A5 5A07CD25                	dw 1882,MSG_1882-$ ; 9677
 39116 000066A9 5B072026                	dw 1883,MSG_1883-$ ; 9760
 39117 000066AD 6C07BF26                	dw 1900,MSG_1900-$ ; 9919
 39118 000066B1 8007D326                	dw 1920,MSG_1920-$ ; 9939
 39119 000066B5 8107FF26                	dw 1921,MSG_1921-$ ; 9983
 39120                                  ;$M_ID_3_162:
 39121                                  $M_ID_3_182: ; 17/06/2023
 39122 000066B9 82079927                	dw 1922,MSG_1922-$ ; 9285
 39123                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 39124 000066BD 83074C28                	dw 1923,MSG_1923-$ ; 10316
 39125 000066C1 8407CE28                	dw 1924,MSG_1924-$ ; 10446
 39126 000066C5 85074A29                	dw 1925,MSG_1925-$ ; 10570
 39127 000066C9 8607CA29                	dw 1926,MSG_1926-$ ; 10698
 39128                                  $M_ID_3_187:	; 17/06/2023
 39129 000066CD 8707                    	dw 1927	; 19/06/2023	; Message Number = 1927
 39130 000066CF 1E2A                    	dw MSG_1927-$+2	; 10782	; Message offset from message number
 39131                                  				; (Msg addr: 6C1Ch+2A1Eh = TRANGROUP:963Ah)
 39132                                  
 39133                                  ; ---------------------------------------------------------------------------
 39134                                  ; Class 3 messages
 39135                                  ; ---------------------------------------------------------------------------
 39136                                  	
 39137                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39138                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h
 39139                                  
 39140                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39141                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:6C20h
 39142                                  
 39143                                  MSG_1020:	; COMMON4
 39144 000066D1 0F                      	db 15	; (MSG_1015-MSG_1020)-1
 39145 000066D2 253120627974657320-     	db '%1 bytes free',0Dh,0Ah
 39145 000066DB 667265650D0A       
 39146                                  MSG_1015:	; COMMON18
 39147 000066E1 23                      	db 35
 39148 000066E2 46696C652063616E6E-     	db 'File cannot be copied onto itself',0Dh,0Ah
 39148 000066EB 6F7420626520636F70-
 39148 000066F4 696564206F6E746F20-
 39148 000066FD 697473656C660D0A   
 39149                                  MSG_1004:	; COMMON20
 39150 00006705 19                      	db 25
 39151 00006706 496E73756666696369-     	db 'Insufficient disk space',0Dh,0Ah
 39151 0000670F 656E74206469736B20-
 39151 00006718 73706163650D0A     
 39152                                  MSG_1026:	; COMMON22
 39153 0000671F 13                      	db 19
 39154 00006720 496E76616C69642063-     	db 'Invalid code page',0Dh,0Ah
 39154 00006729 6F646520706167650D-
 39154 00006732 0A                 
 39155                                  MSG_1031:	; COMMON23
 39156 00006733 0E                      	db 14
 39157 00006734 496E76616C69642064-     	db 'Invalid date',0Dh,0Ah
 39157 0000673D 6174650D0A         
 39158                                  MSG_1035:	; COMMON24
 39159 00006742 0E                      	db 14
 39160 00006743 496E76616C69642074-     	db 'Invalid time',0Dh,0Ah
 39160 0000674C 696D650D0A         
 39161                                  MSG_1062:	; COMMON25
 39162 00006751 0E                      	db 14
 39163 00006752 496E76616C69642070-     	db 'Invalid path',0Dh,0Ah
 39163 0000675B 6174680D0A         
 39164                                  MSG_1028:	; COMMON28
 39165 00006760 21                      	db 33
 39166 00006761 507265737320616E79-     	db 'Press any key to continue . . .',0Dh,0Ah
 39166 0000676A 206B657920746F2063-
 39166 00006773 6F6E74696E7565202E-
 39166 0000677C 202E202E0D0A       
 39167                                  MSG_1045:	; COMMON32
 39168 00006782 1C                      	db 28
 39169 00006783 556E61626C6520746F-     	db 'Unable to create directory',0Dh,0Ah
 39169 0000678C 206372656174652064-
 39169 00006795 69726563746F72790D-
 39169 0000679E 0A                 
 39170                                  MSG_1041:	; COMMON33
 39171 0000679F 21                      	db 33
 39172 000067A0 566F6C756D6520696E-     	db 'Volume in drive %1 has no label',0Dh,0Ah
 39172 000067A9 206472697665202531-
 39172 000067B2 20686173206E6F206C-
 39172 000067BB 6162656C0D0A       
 39173                                  MSG_1042:	; COMMON34
 39174 000067C1 1A                      	db 26
 39175 000067C2 566F6C756D6520696E-     	db 'Volume in drive %1 is %2',0Dh,0Ah
 39175 000067CB 206472697665202531-
 39175 000067D4 2069732025320D0A   
 39176                                  MSG_1043:	; COMMON36
 39177 000067DC 1F                      	db 31  ; (MSG_1002-MSG_1043)-1
 39178 000067DD 566F6C756D65205365-     	db 'Volume Serial Number is %1-%2',0Dh,0Ah
 39178 000067E6 7269616C204E756D62-
 39178 000067EF 65722069732025312D-
 39178 000067F8 25320D0A           
 39179                                  MSG_1002:
 39180 000067FC 27                              db 39
 39181 000067FD 4475706C6963617465-     	db 'Duplicate file name or file not found',0Dh,0Ah
 39181 00006806 2066696C65206E616D-
 39181 0000680F 65206F722066696C65-
 39181 00006818 206E6F7420666F756E-
 39181 00006821 640D0A             
 39182                                  MSG_1003:
 39183 00006824 1B                      	db 27
 39184 00006825 496E76616C69642070-     	db 'Invalid path or file name',0Dh,0Ah
 39184 0000682E 617468206F72206669-
 39184 00006837 6C65206E616D650D0A 
 39185                                  MSG_1007:
 39186 00006840 1A                      	db 26
 39187 00006841 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
 39187 0000684A 7669726F6E6D656E74-
 39187 00006853 2073706163650D0A   
 39188                                  MSG_1008:
 39189 0000685B 15                      	db 21
 39190 0000685C 46696C652063726561-     	db 'File creation error',0Dh,0Ah
 39190 00006865 74696F6E206572726F-
 39190 0000686E 720D0A             
 39191                                  MSG_1009:
 39192 00006871 14                      	db 20  ; (MSG_1010-MSG_1009)-1
 39193 00006872 42617463682066696C-     	db 'Batch file missing',0Dh,0Ah
 39193 0000687B 65206D697373696E67-
 39193 00006884 0D0A               
 39194                                  MSG_1010:
 39195 00006886 1F                      	db 31
 39196 00006887 0D0A                    	db 0Dh,0Ah
 39197 00006889 496E73657274206469-     	db 'Insert disk with batch file',0Dh,0Ah
 39197 00006892 736B20776974682062-
 39197 0000689B 617463682066696C65-
 39197 000068A4 0D0A               
 39198                                  MSG_1011:
 39199 000068A6 1A                      	db 26
 39200 000068A7 42616420636F6D6D61-     	db 'Bad command or file name',0Dh,0Ah
 39200 000068B0 6E64206F722066696C-
 39200 000068B9 65206E616D650D0A   
 39201                                  MSG_1014:	; EXTEND5
 39202 000068C1 10                      	db 16
 39203 000068C2 416363657373206465-     	db 'Access denied ',0Dh,0Ah
 39203 000068CB 6E696564200D0A     
 39204                                  MSG_1016:
 39205 000068D2 29                      	db 41
 39206 000068D3 436F6E74656E74206F-     	db 'Content of destination lost before copy',0Dh,0Ah
 39206 000068DC 662064657374696E61-
 39206 000068E5 74696F6E206C6F7374-
 39206 000068EE 206265666F72652063-
 39206 000068F7 6F70790D0A         
 39207                                  MSG_1017:
 39208 000068FC 24                      	db 36
 39209 000068FD 496E76616C69642066-     	db 'Invalid filename or file not found',0Dh,0Ah
 39209 00006906 696C656E616D65206F-
 39209 0000690F 722066696C65206E6F-
 39209 00006918 7420666F756E640D0A 
 39210                                  MSG_1018:
 39211 00006921 13                      	db 19
 39212 00006922 25312066696C652873-     	db '%1 file(s) copied',0Dh,0Ah
 39212 0000692B 2920636F706965640D-
 39212 00006934 0A                 
 39213                                  MSG_1019:
 39214 00006935 0B                      	db 11
 39215 00006936 25312066696C652873-     	db '%1 file(s) '
 39215 0000693F 2920               
 39216                                  MSG_1021:	; EXTEND15
 39217 00006941 1D                      	db 29
 39218 00006942 496E76616C69642064-     	db 'Invalid drive specification',0Dh,0Ah
 39218 0000694B 726976652073706563-
 39218 00006954 696669636174696F6E-
 39218 0000695D 0D0A               
 39219                                  MSG_1022:
 39220 0000695F 26                      	db 38
 39221 00006960 436F64652070616765-     	db 'Code page %1 not prepared for system',0Dh,0Ah
 39221 00006969 202531206E6F742070-
 39221 00006972 726570617265642066-
 39221 0000697B 6F722073797374656D-
 39221 00006984 0D0A               
 39222                                  MSG_1023:
 39223 00006986 2B                      	db 43
 39224 00006987 436F64652070616765-     	db 'Code page %1 not prepared for all devices',0Dh,0Ah
 39224 00006990 202531206E6F742070-
 39224 00006999 726570617265642066-
 39224 000069A2 6F7220616C6C206465-
 39224 000069AB 76696365730D0A     
 39225                                  MSG_1024:
 39226 000069B2 16                      	db 22
 39227 000069B3 41637469766520636F-     	db 'Active code page: %1',0Dh,0Ah
 39227 000069BC 646520706167653A20-
 39227 000069C5 25310D0A           
 39228                                  MSG_1025:
 39229 000069C9 17                      	db 23
 39230 000069CA 4E4C5346554E43206E-     	db 'NLSFUNC not installed',0Dh,0Ah
 39230 000069D3 6F7420696E7374616C-
 39230 000069DC 6C65640D0A         
 39231                                  MSG_1027:
 39232 000069E1 20                      	db 32
 39233 000069E2 43757272656E742064-     	db 'Current drive is no longer valid'
 39233 000069EB 72697665206973206E-
 39233 000069F4 6F206C6F6E67657220-
 39233 000069FD 76616C6964         
 39234                                  MSG_1029:
 39235 00006A02 11                      	db 17
 39236 00006A03 4C6162656C206E6F74-     	db 'Label not found',0Dh,0Ah
 39236 00006A0C 20666F756E640D0A   
 39237                                  MSG_1030:
 39238 00006A14 0E                      	db 14
 39239 00006A15 53796E746178206572-     	db 'Syntax error',0Dh,0Ah
 39239 00006A1E 726F720D0A         
 39240                                  MSG_1032:
 39241 00006A23 17                      	db 23
 39242 00006A24 43757272656E742064-     	db 'Current date is %1 %2',0Dh,0Ah
 39242 00006A2D 617465206973202531-
 39242 00006A36 2025320D0A         
 39243                                  MSG_1033:
 39244 00006A3B 15                      	db 21
 39245 00006A3C 53756E4D6F6E547565-     	db 'SunMonTueWedThuFriSat'
 39245 00006A45 576564546875467269-
 39245 00006A4E 536174             
 39246                                  MSG_1034:
 39247 00006A51 15                      	db 21
 39248 00006A52 456E746572206E6577-     	db 'Enter new date (%1): '
 39248 00006A5B 206461746520282531-
 39248 00006A64 293A20             
 39249                                  MSG_1036:
 39250 00006A67 14                      	db 20
 39251 00006A68 43757272656E742074-     	db 'Current time is %1',0Dh,0Ah
 39251 00006A71 696D65206973202531-
 39251 00006A7A 0D0A               
 39252                                  MSG_1037:
 39253 00006A7C 10                      	db 16
 39254 00006A7D 456E746572206E6577-     	db 'Enter new time: '
 39254 00006A86 2074696D653A20     
 39255                                  MSG_1038:
 39256 00006A8D 12                              db 18
 39257 00006A8E 2C2020202044656C65-     	db ',    Delete (Y/N)?'
 39257 00006A97 74652028592F4E293F 
 39258                                  MSG_1039:
 39259 00006AA0 3C                              db 60
 39260 00006AA1 416C6C2066696C6573-     	db 'All files in directory will be deleted!',0Dh,0Ah
 39260 00006AAA 20696E206469726563-
 39260 00006AB3 746F72792077696C6C-
 39260 00006ABC 2062652064656C6574-
 39260 00006AC5 6564210D0A         
 39261 00006ACA 41726520796F752073-     	db 'Are you sure (Y/N)?'
 39261 00006AD3 7572652028592F4E29-
 39261 00006ADC 3F                 
 39262                                  MSG_1040:
 39263 00006ADD 14                      	db 20
 39264 00006ADE 4D532D444F53205665-     	db 'MS-DOS Version %1.%2'
 39264 00006AE7 7273696F6E2025312E-
 39264 00006AF0 2532               
 39265                                  MSG_1044:
 39266 00006AF2 13                      	db 19
 39267 00006AF3 496E76616C69642064-     	db 'Invalid directory',0Dh,0Ah
 39267 00006AFC 69726563746F72790D-
 39267 00006B05 0A                 
 39268                                  MSG_1046:
 39269 00006B06 36                      	db 54
 39270 00006B07 496E76616C69642070-     	db 'Invalid path, not directory,',0Dh,0Ah
 39270 00006B10 6174682C206E6F7420-
 39270 00006B19 6469726563746F7279-
 39270 00006B22 2C0D0A             
 39271 00006B25 6F7220646972656374-     	db 'or directory not empty',0Dh,0Ah
 39271 00006B2E 6F7279206E6F742065-
 39271 00006B37 6D7074790D0A       
 39272                                  MSG_1047:
 39273 00006B3D 18                      	db 24
 39274 00006B3E 4D7573742073706563-     	db 'Must specify ON or OFF',0Dh,0Ah
 39274 00006B47 696679204F4E206F72-
 39274 00006B50 204F46460D0A       
 39275                                  MSG_1048:
 39276 00006B56 11                      	db 17
 39277 00006B57 4469726563746F7279-     	db 'Directory of %1',0Dh,0Ah
 39277 00006B60 206F662025310D0A   
 39278                                  MSG_1049:
 39279 00006B68 09                      	db 9
 39280 00006B69 4E6F20506174680D0A      	db 'No Path',0Dh,0Ah
 39281                                  MSG_1050:
 39282 00006B72 1E                      	db 30
 39283 00006B73 496E76616C69642064-     	db 'Invalid drive in search path',0Dh,0Ah
 39283 00006B7C 7269766520696E2073-
 39283 00006B85 656172636820706174-
 39283 00006B8E 680D0A             
 39284                                  MSG_1051:
 39285 00006B91 10                      	db 16
 39286 00006B92 496E76616C69642064-     	db 'Invalid device',0Dh,0Ah
 39286 00006B9B 65766963650D0A     
 39287                                  MSG_1052:
 39288 00006BA2 16                      	db 22
 39289 00006BA3 464F522063616E6E6F-     	db 'FOR cannot be nested',0Dh,0Ah
 39289 00006BAC 74206265206E657374-
 39289 00006BB5 65640D0A           
 39290                                  MSG_1053:
 39291 00006BB9 25                      	db 37
 39292 00006BBA 496E7465726D656469-     	db 'Intermediate file error during pipe',0Dh,0Ah
 39292 00006BC3 6174652066696C6520-
 39292 00006BCC 6572726F7220647572-
 39292 00006BD5 696E6720706970650D-
 39292 00006BDE 0A                 
 39293                                  MSG_1054:
 39294 00006BDF 26                      	db 38
 39295 00006BE0 43616E6E6F7420646F-     	db 'Cannot do binary reads from a device',0Dh,0Ah
 39295 00006BE9 2062696E6172792072-
 39295 00006BF2 656164732066726F6D-
 39295 00006BFB 206120646576696365-
 39295 00006C04 0D0A               
 39296                                  
 39297                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
 39298                                  	; 17/06/2023
 39299                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:7155h)
 39300                                  MSG_1055:
 39301 00006C06 0D                      	db 13
 39302 00006C07 425245414B20697320-     	db 'BREAK is %1',0Dh,0Ah
 39302 00006C10 25310D0A           
 39303                                  MSG_1056:
 39304 00006C14 0E                      	db 14
 39305 00006C15 564552494659206973-     	db 'VERIFY is %1',0Dh,0Ah
 39305 00006C1E 2025310D0A         
 39306                                  MSG_1057:
 39307 00006C23 0C                      	db 12
 39308 00006C24 4543484F2069732025-     	db 'ECHO is %1',0Dh,0Ah
 39308 00006C2D 310D0A             
 39309                                  MSG_1059:
 39310 00006C30 04                      	db 4
 39311 00006C31 6F666600                	db 'off',0
 39312                                  MSG_1060:
 39313 00006C35 03                      	db 3
 39314 00006C36 6F6E00                  	db 'on',0
 39315                                  MSG_1061:
 39316 00006C39 19                      	db 25
 39317 00006C3A 4572726F7220777269-     	db 'Error writing to device',0Dh,0Ah
 39317 00006C43 74696E6720746F2064-
 39317 00006C4C 65766963650D0A     
 39318                                  MSG_1063:
 39319 00006C53 02                      	db 2
 39320 00006C54 2531                    	db '%1'
 39321                                  MSG_1064:
 39322 00006C56 02                      	db 2
 39323 00006C57 2531                    	db '%1'
 39324                                  MSG_1065:
 39325 00006C59 02                      	db 2
 39326 00006C5A 2531                    	db '%1'
 39327                                  MSG_1066:
 39328 00006C5C 02                      	db 2
 39329 00006C5D 2531                    	db '%1'
 39330                                  MSG_1067:
 39331 00006C5F 01                      	db 1
 39332 00006C60 09                      	db 9
 39333                                  MSG_1068:
 39334 00006C61 0A                      	db 10
 39335 00006C62 203C4449523E202020-     	db ' <DIR>    '
 39335 00006C6B 20                 
 39336                                  MSG_1069:
 39337 00006C6C 03                      	db 3
 39338 00006C6D 082008                  	db 8, 20h, 8
 39339                                  MSG_1070:	; CRLF
 39340 00006C70 02                      	db 2
 39341 00006C71 0D                      	db 0Dh
 39342 00006C72 0A                      	db 0Ah
 39343                                  MSG_1071:
 39344 00006C73 02                      	db 2
 39345 00006C74 2531                    	db '%1'
 39346                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 39347                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:71C5h
 39348                                  MSG_1072:
 39349                                  	;db 8
 39350                                  	;db 'mm-dd-yy'
 39351 00006C76 09                      	db 9
 39352 00006C77 6D6D2D64642D797900      	db 'mm-dd-yy',0
 39353                                  MSG_1073:
 39354                                  	;db 8
 39355                                  	;db 'dd-mm-yy'
 39356 00006C80 09                      	db 9
 39357 00006C81 64642D6D6D2D797900      	db 'dd-mm-yy',0
 39358                                  MSG_1074:
 39359                                  	;db 8
 39360                                  	;db 'yy-mm-dd'
 39361 00006C8A 09                      	db 9
 39362 00006C8B 79792D6D6D2D646400      	db 'yy-mm-dd',0
 39363                                  MSG_1075:
 39364 00006C94 05                      	db 5
 39365 00006C95 2531202532              	db '%1 %2'
 39366                                  MSG_1076:
 39367 00006C9A 02                      	db 2
 39368 00006C9B 2531                    	db '%1'
 39369                                  MSG_1077:
 39370 00006C9D 07                      	db 7
 39371 00006C9E 20253120202532          	db ' %1  %2'
 39372                                  MSG_1078:
 39373 00006CA5 1A                      	db 26
 39374 00006CA6 4469726563746F7279-     	db 'Directory already exists',0Dh,0Ah
 39374 00006CAF 20616C726561647920-
 39374 00006CB8 6578697374730D0A   
 39375                                  MSG_1079:
 39376 00006CC0 0A                      	db 10
 39377 00006CC1 25312062797465730D-     	db '%1 bytes',0Dh,0Ah
 39377 00006CCA 0A                 
 39378                                  MSG_1080:
 39379 00006CCB 15                      	db 21
 39380 00006CCC 546F74616C2066696C-     	db 'Total files listed:',0Dh,0Ah
 39380 00006CD5 6573206C6973746564-
 39380 00006CDE 3A0D0A             
 39381                                  MSG_1081:
 39382 00006CE1 2A                      	db 42
 39383 00006CE2 284572726F72206F63-     	db '(Error occurred in environment variable)',0Dh,0Ah
 39383 00006CEB 63757272656420696E-
 39383 00006CF4 20656E7669726F6E6D-
 39383 00006CFD 656E74207661726961-
 39383 00006D06 626C65290D0A       
 39384                                  	;
 39385                                  	; 17/06/2023 - Retro DOS 4.2 COMMAND.COM
 39386                                  MSG_1082:
 39387 00006D0C 07                              db 7
 39388 00006D0D 205B592F4E5D3F          	db ' [Y/N]?'
 39389                                  MSG_1083:
 39390 00006D14 02                      	db 2
 39391 00006D15 594E                    	db 'YN'
 39392                                  	;
 39393                                  MSG_1084:
 39394 00006D17 0F                      	db 15
 39395 00006D18 28636F6E74696E7569-     	db '(continuing %1)'
 39395 00006D21 6E6720253129       
 39396                                  MSG_1090:
 39397 00006D27 0D                      	db 13
 39398 00006D28 5265766973696F6E20-     	db 'Revision %1',0Dh,0Ah
 39398 00006D31 25310D0A           
 39399                                  MSG_1091:
 39400 00006D35 0D                      	db 13
 39401 00006D36 444F5320697320696E-     	db 'DOS is in ROM'
 39401 00006D3F 20524F4D           
 39402                                  MSG_1092:
 39403 00006D43 0D                      	db 13
 39404 00006D44 444F5320697320696E-     	db 'DOS is in HMA'
 39404 00006D4D 20484D41           
 39405                                  MSG_1093:
 39406 00006D51 14                      	db 20
 39407 00006D52 444F5320697320696E-     	db 'DOS is in low memory'
 39407 00006D5B 206C6F77206D656D6F-
 39407 00006D64 7279               
 39408                                  MSG_1094:
 39409 00006D66 1C                      	db 28
 39410 00006D67 43616E6E6F74204C6F-     	db 'Cannot Loadhigh batch file',0Dh,0Ah
 39410 00006D70 616468696768206261-
 39410 00006D79 7463682066696C650D-
 39410 00006D82 0A                 
 39411                                  MSG_1095:
 39412 00006D83 1C                      	db 28
 39413 00006D84 4C6F6164486967683A-     	db 'LoadHigh: Invalid filename',0Dh,0Ah
 39413 00006D8D 20496E76616C696420-
 39413 00006D96 66696C656E616D650D-
 39413 00006D9F 0A                 
 39414                                  MSG_1096:
 39415 00006DA0 30                      	db 48
 39416 00006DA1 43616E6E6F74206F70-     	db 'Cannot open specified country information file',0Dh,0Ah
 39416 00006DAA 656E20737065636966-
 39416 00006DB3 69656420636F756E74-
 39416 00006DBC 727920696E666F726D-
 39416 00006DC5 6174696F6E2066696C-
 39416 00006DCE 650D0A             
 39417                                  
 39418                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39419                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7320h
 39420                                  MSG_1097:
 39421 00006DD1 1C                      	db 28
 39422 00006DD2 4C6F6164486967683A-     	db 'LoadHigh: Invalid argument',0Dh,0Ah
 39422 00006DDB 20496E76616C696420-
 39422 00006DE4 617267756D656E740D-
 39422 00006DED 0A                 
 39423                                  MSG_1098:
 39424 00006DEE 1C                      	db 28
 39425 00006DEF 526571756972656420-     	db 'Required parameter missing',0Dh,0Ah
 39425 00006DF8 706172616D65746572-
 39425 00006E01 206D697373696E670D-
 39425 00006E0A 0A                 
 39426                                  MSG_1099:
 39427 00006E0B 15                      	db 21
 39428 00006E0C 556E7265636F676E69-     	db 'Unrecognized switch',0Dh,0Ah
 39428 00006E15 7A6564207377697463-
 39428 00006E1E 680D0A             
 39429                                  MSG_1100:
 39430 00006E21 25                      	db 37
 39431 00006E22 412062616420554D42-     	db 'A bad UMB number has been specified',0Dh,0Ah
 39431 00006E2B 206E756D6265722068-
 39431 00006E34 6173206265656E2073-
 39431 00006E3D 70656369666965640D-
 39431 00006E46 0A                 
 39432                                  MSG_1101:
 39433 00006E47 0E                      	db 14
 39434 00006E48 202025312E25322074-     	db '  %1.%2 to 1.0'
 39434 00006E51 6F20312E30         
 39435                                  MSG_1102:
 39436 00006E56 39                      	db 57
 39437 00006E57 202020202020202020-     	db '                 %1.%2 to 1.0 average compression ratio',0Dh,0Ah
 39437 00006E60 202020202020202025-
 39437 00006E69 312E253220746F2031-
 39437 00006E72 2E3020617665726167-
 39437 00006E7B 6520636F6D70726573-
 39437 00006E84 73696F6E2072617469-
 39437 00006E8D 6F0D0A             
 39438                                  MSG_1103:
 39439 00006E90 1A                      	db 26
 39440 00006E91 4F7665727772697465-     	db 'Overwrite %1 (Yes/No/All)?'
 39440 00006E9A 20253120285965732F-
 39440 00006EA3 4E6F2F416C6C293F   
 39441                                  MSG_1104:
 39442 00006EAB 03                      	db 3
 39443 00006EAC 59                      _Y_es:	db 'Y'
 39444 00006EAD 4E                      _N_o:	db 'N'
 39445 00006EAE 41                      _A_ll:	db 'A'
 39446                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:73FEh)
 39447                                  MSG_1105:
 39448 00006EAF 04                      	db 4
 39449 00006EB0 20202020                	db '    '
 39450                                  	
 39451                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
 39452                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7403h
 39453                                  MSG_1200:
 39454 00006EB4 00                      	db 0	; /? unimplemented
 39455                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:7404h)
 39456                                  MSG_1300:
 39457 00006EB5 86                      	db 134
 39458 00006EB6 53657473206F722063-     	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
 39458 00006EBF 6C6561727320657874-
 39458 00006EC8 656E64656420435452-
 39458 00006ED1 4C2B4320636865636B-
 39458 00006EDA 696E672E0D0A       
 39459 00006EE0 0D0A                    	db 0Dh,0Ah
 39460 00006EE2 425245414B205B4F4E-     	db 'BREAK [ON | OFF]',0Dh,0Ah
 39460 00006EEB 207C204F46465D0D0A 
 39461 00006EF4 0D0A                    	db 0Dh,0Ah
 39462 00006EF6 547970652042524541-     	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
 39462 00006EFF 4B20776974686F7574-
 39462 00006F08 206120706172616D65-
 39462 00006F11 74657220746F206469-
 39462 00006F1A 73706C617920746865-
 39462 00006F23 2063757272656E7420-
 39462 00006F2C 425245414B20736574-
 39462 00006F35 74696E672E0D0A     
 39463                                  MSG_1320:
 39464 00006F3C 3F                      	db 63
 39465 00006F3D 446973706C61797320-     	db 'Displays or sets the active code page number.',0Dh,0Ah
 39465 00006F46 6F7220736574732074-
 39465 00006F4F 686520616374697665-
 39465 00006F58 20636F646520706167-
 39465 00006F61 65206E756D6265722E-
 39465 00006F6A 0D0A               
 39466 00006F6C 0D0A                    	db 0Dh,0Ah
 39467 00006F6E 43484350205B6E6E6E-     	db 'CHCP [nnn]',0Dh,0Ah
 39467 00006F77 5D0D0A             
 39468 00006F7A 0D0A                    	db 0Dh,0Ah
 39469                                  MSG_1321:
 39470 00006F7C 70                      	db 112
 39471 00006F7D 20206E6E6E20202053-     	db '  nnn   Specifies a code page number.',0Dh,0Ah
 39471 00006F86 706563696669657320-
 39471 00006F8F 6120636F6465207061-
 39471 00006F98 6765206E756D626572-
 39471 00006FA1 2E0D0A             
 39472 00006FA4 0D0A                    	db 0Dh,0Ah
 39473 00006FA6 547970652043484350-     	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
 39473 00006FAF 20776974686F757420-
 39473 00006FB8 6120706172616D6574-
 39473 00006FC1 657220746F20646973-
 39473 00006FCA 706C61792074686520-
 39473 00006FD3 61637469766520636F-
 39473 00006FDC 64652070616765206E-
 39473 00006FE5 756D6265722E0D0A   
 39474                                  MSG_1340:
 39475 00006FED 5B                      	db 91
 39476 00006FEE 446973706C61797320-     	db 'Displays the name of or changes the current directory.',0Dh,0Ah
 39476 00006FF7 746865206E616D6520-
 39476 00007000 6F66206F7220636861-
 39476 00007009 6E6765732074686520-
 39476 00007012 63757272656E742064-
 39476 0000701B 69726563746F72792E-
 39476 00007024 0D0A               
 39477 00007026 0D0A                    	db 0Dh,0Ah
 39478 00007028 4348444952205B6472-     	db 'CHDIR [drive:][path]',0Dh,0Ah
 39478 00007031 6976653A5D5B706174-
 39478 0000703A 685D0D0A           
 39479 0000703E 43484449525B2E2E5D-     	db 'CHDIR[..]',0Dh,0Ah
 39479 00007047 0D0A               
 39480                                  MSG_1341:
 39481 00007049 62                      	db 98
 39482 0000704A 4344205B6472697665-     	db 'CD [drive:][path]',0Dh,0Ah
 39482 00007053 3A5D5B706174685D0D-
 39482 0000705C 0A                 
 39483 0000705D 43445B2E2E5D0D0A        	db 'CD[..]',0Dh,0Ah
 39484 00007065 0D0A                    	db 0Dh,0Ah
 39485 00007067 20202E2E2020205370-     	db '  ..   Specifies that you want to change to the parent directory.'
 39485 00007070 656369666965732074-
 39485 00007079 68617420796F752077-
 39485 00007082 616E7420746F206368-
 39485 0000708B 616E676520746F2074-
 39485 00007094 686520706172656E74-
 39485 0000709D 206469726563746F72-
 39485 000070A6 792E               
 39486 000070A8 0D0A                    	db 0Dh,0Ah
 39487 000070AA 0D0A                    	db 0Dh,0Ah
 39488                                  MSG_1342:
 39489 000070AC 91                      	db 145
 39490 000070AD 547970652043442064-     	db 'Type CD drive: to display the current directory in the specified '
 39490 000070B6 726976653A20746F20-
 39490 000070BF 646973706C61792074-
 39490 000070C8 68652063757272656E-
 39490 000070D1 74206469726563746F-
 39490 000070DA 727920696E20746865-
 39490 000070E3 207370656369666965-
 39490 000070EC 6420               
 39491 000070EE 64726976652E0D0A        	db 'drive.',0Dh,0Ah
 39492 000070F6 547970652043442077-     	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
 39492 000070FF 6974686F7574207061-
 39492 00007108 72616D657465727320-
 39492 00007111 746F20646973706C61-
 39492 0000711A 792074686520637572-
 39492 00007123 72656E742064726976-
 39492 0000712C 6520616E6420646972-
 39492 00007135 6563746F72792E0D0A 
 39493                                  MSG_1360:
 39494 0000713E 1B                      	db 27
 39495 0000713F 436C65617273207468-     	db 'Clears the screen.',0Dh,0Ah
 39495 00007148 652073637265656E2E-
 39495 00007151 0D0A               
 39496 00007153 0D0A                    	db 0Dh,0Ah
 39497 00007155 434C530D0A              	db 'CLS',0Dh,0Ah
 39498                                  MSG_1400:
 39499                                  	;db 145
 39500                                  	;db 'Copies one or more files to another location.',0Dh,0Ah
 39501                                  	;db 0Dh,0Ah
 39502                                  	;db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 39503                                  	;db '  [/A | /B]] [/V]',0Dh,0Ah
 39504                                  	;db 0Dh,0Ah
 39505                                  	
 39506                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39507                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:76A9h)
 39508 0000715A 9C                      	db 156 ; 19/06/2023	
 39509 0000715B 436F70696573206F6E-     	db 'Copies one or more files to another location.',0Dh,0Ah
 39509 00007164 65206F72206D6F7265-
 39509 0000716D 2066696C657320746F-
 39509 00007176 20616E6F7468657220-
 39509 0000717F 6C6F636174696F6E2E-
 39509 00007188 0D0A               
 39510 0000718A 0D0A                    	db 0Dh,0Ah
 39511 0000718C 434F5059205B2F4120-     	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 39511 00007195 7C202F425D20736F75-
 39511 0000719E 726365205B2F41207C-
 39511 000071A7 202F425D205B2B2073-
 39511 000071B0 6F75726365205B2F41-
 39511 000071B9 207C202F425D205B2B-
 39511 000071C2 202E2E2E5D5D205B64-
 39511 000071CB 657374696E6174696F-
 39511 000071D4 6E0D0A             
 39512 000071D7 20205B2F41207C202F-     	db '  [/A | /B]] [/V] [/Y | /-Y]',0Dh,0Ah
 39512 000071E0 425D5D205B2F565D20-
 39512 000071E9 5B2F59207C202F2D59-
 39512 000071F2 5D0D0A             
 39513 000071F5 0D0A                    	db 0Dh,0Ah
 39514                                  MSG_1401:
 39515 000071F7 68                      	db 104
 39516 000071F8 2020736F7572636520-     	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
 39516 00007201 202020202020537065-
 39516 0000720A 636966696573207468-
 39516 00007213 652066696C65206F72-
 39516 0000721C 2066696C657320746F-
 39516 00007225 20626520636F706965-
 39516 0000722E 642E0D0A           
 39517 00007232 20202F412020202020-     	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
 39517 0000723B 202020202020496E64-
 39517 00007244 69636174657320616E-
 39517 0000724D 204153434949207465-
 39517 00007256 78742066696C652E0D-
 39517 0000725F 0A                 
 39518                                  MSG_1402:
 39519 00007260 76                      	db 118
 39520 00007261 20202F422020202020-     	db '  /B           Indicates a binary file.',0Dh,0Ah
 39520 0000726A 202020202020496E64-
 39520 00007273 696361746573206120-
 39520 0000727C 62696E617279206669-
 39520 00007285 6C652E0D0A         
 39521 0000728A 202064657374696E61-     	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
 39521 00007293 74696F6E2020537065-
 39521 0000729C 636966696573207468-
 39521 000072A5 65206469726563746F-
 39521 000072AE 727920616E642F6F72-
 39521 000072B7 2066696C656E616D65-
 39521 000072C0 20666F722074686520-
 39521 000072C9 6E65772066696C6528-
 39521 000072D2 73292E0D0A         
 39522                                  MSG_1403:	
 39523                                  	;db 65  ;  MSDOS 5.0
 39524                                  	; 17/06/2023
 39525 000072D7 3F                      	db 63 ; MSDOS 6.22
 39526 000072D8 20202F562020202020-     	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
 39526 000072E1 202020202020566572-
 39526 000072EA 696669657320746861-
 39526 000072F3 74206E65772066696C-
 39526 000072FC 657320617265207772-
 39526 00007305 697474656E20636F72-
 39526 0000730E 726563746C792E0D0A 
 39527                                  	;db 0Dh,0Ah ; MSDOS 5.0
 39528                                  
 39529                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39530                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7866h
 39531                                  MSG_1404:
 39532 00007317 74                              db 116
 39533 00007318 20202F592020202020-     	db '  /Y           Suppresses prompting to confirm you want to overwrite an',0Dh,0Ah
 39533 00007321 202020202020537570-
 39533 0000732A 707265737365732070-
 39533 00007333 726F6D7074696E6720-
 39533 0000733C 746F20636F6E666972-
 39533 00007345 6D20796F752077616E-
 39533 0000734E 7420746F206F766572-
 39533 00007357 777269746520616E0D-
 39533 00007360 0A                 
 39534 00007361 202020202020202020-     	db '               existing destination file.',0Dh,0Ah
 39534 0000736A 202020202020657869-
 39534 00007373 7374696E6720646573-
 39534 0000737C 74696E6174696F6E20-
 39534 00007385 66696C652E0D0A     
 39535                                  MSG_1405:
 39536 0000738C 72                      	db 114
 39537 0000738D 20202F2D5920202020-     	db '  /-Y          Causes prompting to confirm you want to overwrite an',0Dh,0Ah
 39537 00007396 202020202020436175-
 39537 0000739F 7365732070726F6D70-
 39537 000073A8 74696E6720746F2063-
 39537 000073B1 6F6E6669726D20796F-
 39537 000073BA 752077616E7420746F-
 39537 000073C3 206F76657277726974-
 39537 000073CC 6520616E0D0A       
 39538 000073D2 202020202020202020-     	db '               existing destination file.',0Dh,0Ah
 39538 000073DB 202020202020657869-
 39538 000073E4 7374696E6720646573-
 39538 000073ED 74696E6174696F6E20-
 39538 000073F6 66696C652E0D0A     
 39539 000073FD 0D0A                    	db 0Dh,0Ah
 39540                                  MSG_1406:
 39541 000073FF 42                      	db 66
 39542 00007400 546865207377697463-     	db 'The switch /Y may be preset in the COPYCMD environment variable.',0Dh,0Ah
 39542 00007409 68202F59206D617920-
 39542 00007412 626520707265736574-
 39542 0000741B 20696E207468652043-
 39542 00007424 4F5059434D4420656E-
 39542 0000742D 7669726F6E6D656E74-
 39542 00007436 207661726961626C65-
 39542 0000743F 2E0D0A             
 39543                                  
 39544                                  ;MSG_1404: ; MSDOS 5.0 (TRANGROUP:681Ch)
 39545                                  MSG_1407:  ; MSDOS 6.22	(TRANGROUP:7991h)
 39546 00007442 87                      	db 135
 39547 00007443 546F20617070656E64-     	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
 39547 0000744C 2066696C65732C2073-
 39547 00007455 706563696679206120-
 39547 0000745E 73696E676C65206669-
 39547 00007467 6C6520666F72206465-
 39547 00007470 7374696E6174696F6E-
 39547 00007479 2C20627574206D756C-
 39547 00007482 7469706C652066696C-
 39547 0000748B 65730D0A           
 39548 0000748F 666F7220736F757263-     	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
 39548 00007498 6520287573696E6720-
 39548 000074A1 77696C646361726473-
 39548 000074AA 206F722066696C6531-
 39548 000074B3 2B66696C65322B6669-
 39548 000074BC 6C653320666F726D61-
 39548 000074C5 74292E0D0A         
 39549                                  MSG_1420:
 39550 000074CA 8A                      	db 138
 39551 000074CB 4368616E6765732074-     	db 'Changes the terminal device used to control your system.',0Dh,0Ah
 39551 000074D4 6865207465726D696E-
 39551 000074DD 616C20646576696365-
 39551 000074E6 207573656420746F20-
 39551 000074EF 636F6E74726F6C2079-
 39551 000074F8 6F7572207379737465-
 39551 00007501 6D2E0D0A           
 39552 00007505 0D0A                    	db 0Dh,0Ah
 39553 00007507 435454592064657669-     	db 'CTTY device',0Dh,0Ah
 39553 00007510 63650D0A           
 39554 00007514 0D0A                    	db 0Dh,0Ah
 39555 00007516 202064657669636520-     	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
 39555 0000751F 202054686520746572-
 39555 00007528 6D696E616C20646576-
 39555 00007531 69636520796F752077-
 39555 0000753A 616E7420746F207573-
 39555 00007543 652C20737563682061-
 39555 0000754C 7320434F4D312E0D0A 
 39556                                  MSG_1440:
 39557                                  	;db 45
 39558                                  	;db 'Displays or sets the date.',0Dh,0Ah
 39559                                  	;db 0Dh,0Ah
 39560                                  	;db 'DATE [date]',0Dh,0Ah
 39561                                  	;db 0Dh,0Ah
 39562                                  
 39563                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39564                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:7AA4h)
 39565 00007555 5D                      	db 93
 39566 00007556 446973706C61797320-     	db 'Displays or sets the date.',0Dh,0Ah
 39566 0000755F 6F7220736574732074-
 39566 00007568 686520646174652E0D-
 39566 00007571 0A                 
 39567 00007572 0D0A                    	db 0Dh,0Ah
 39568 00007574 44415445205B6D6D2D-     	db 'DATE [mm-dd-yy]',0Dh,0Ah
 39568 0000757D 64642D79795D0D0A   
 39569 00007585 0D0A                    	db 0Dh,0Ah
 39570 00007587 20206D6D2D64642D79-     	db '  mm-dd-yy    Sets the date you specify.',0Dh,0Ah
 39570 00007590 792020202053657473-
 39570 00007599 207468652064617465-
 39570 000075A2 20796F752073706563-
 39570 000075AB 6966792E0D0A       
 39571 000075B1 0D0A                    	db 0Dh,0Ah
 39572                                  MSG_1441:
 39573 000075B3 83                      	db 131
 39574 000075B4 547970652044415445-     	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
 39574 000075BD 20776974686F757420-
 39574 000075C6 706172616D65746572-
 39574 000075CF 7320746F2064697370-
 39574 000075D8 6C6179207468652063-
 39574 000075E1 757272656E74206461-
 39574 000075EA 74652073657474696E-
 39574 000075F3 6720616E640D0A     
 39575 000075FA 612070726F6D707420-     	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
 39575 00007603 666F722061206E6577-
 39575 0000760C 206F6E652E20205072-
 39575 00007615 65737320454E544552-
 39575 0000761E 20746F206B65657020-
 39575 00007627 7468652073616D6520-
 39575 00007630 646174652E0D0A     
 39576                                  MSG_1460:	
 39577 00007637 64                      	db 100
 39578 00007638 44656C65746573206F-     	db 'Deletes one or more files.',0Dh,0Ah
 39578 00007641 6E65206F72206D6F72-
 39578 0000764A 652066696C65732E0D-
 39578 00007653 0A                 
 39579 00007654 0D0A                    	db 0Dh,0Ah
 39580 00007656 44454C205B64726976-     	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
 39580 0000765F 653A5D5B706174685D-
 39580 00007668 66696C656E616D6520-
 39580 00007671 5B2F505D0D0A       
 39581 00007677 4552415345205B6472-     	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
 39581 00007680 6976653A5D5B706174-
 39581 00007689 685D66696C656E616D-
 39581 00007692 65205B2F505D0D0A   
 39582 0000769A 0D0A                    	db 0Dh,0Ah
 39583                                  MSG_1461:
 39584 0000769C 83                      	db 131
 39585 0000769D 20205B64726976653A-     	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
 39585 000076A6 5D5B706174685D6669-
 39585 000076AF 6C656E616D65202053-
 39585 000076B8 706563696669657320-
 39585 000076C1 7468652066696C6528-
 39585 000076CA 732920746F2064656C-
 39585 000076D3 6574652E2020537065-
 39585 000076DC 63696679206D756C74-
 39585 000076E5 69706C650D0A       
 39586 000076EB 202020202020202020-     	db '                          files by using wildcards.',0Dh,0Ah
 39586 000076F4 202020202020202020-
 39586 000076FD 202020202020202066-
 39586 00007706 696C65732062792075-
 39586 0000770F 73696E672077696C64-
 39586 00007718 63617264732E0D0A   
 39587                                  MSG_1462:
 39588 00007720 4F                      	db 79
 39589 00007721 20202F502020202020-     	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
 39589 0000772A 202020202020202020-
 39589 00007733 202020202020202050-
 39589 0000773C 726F6D70747320666F-
 39589 00007745 7220636F6E6669726D-
 39589 0000774E 6174696F6E20626566-
 39589 00007757 6F72652064656C6574-
 39589 00007760 696E67206561636820-
 39589 00007769 66696C652E0D0A     
 39590                                  
 39591                                  ; 17/06/2023
 39592                                  %if 0	; MSDOS 5.0 DIR Help messages
 39593                                  
 39594                                  MSG_1480:
 39595                                  	db 162
 39596                                  	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 39597                                  	db 0Dh,0Ah
 39598                                  	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
 39599                                  	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
 39600                                  	db 0Dh,0Ah
 39601                                  MSG_1481:
 39602                                  	db 93
 39603                                  	db '  [drive:][path][filename]',0Dh,0Ah
 39604                                  	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
 39605                                  MSG_1482:
 39606                                  	db 97
 39607                                  	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
 39608                                  	db '  /W          Uses wide list format.',0Dh,0Ah
 39609                                  MSG_1483:	
 39610                                  	db 122
 39611                                  	db '  /A          Displays files with specified attributes.',0Dh,0Ah
 39612                                  	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
 39613                                  MSG_1484:
 39614                                  	db 191
 39615                                  	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
 39616                                  	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
 39617                                  	db '  /O          List by files in sorted order.',0Dh,0Ah
 39618                                  MSG_1485:
 39619                                  	db 155
 39620                                  	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 39621                                  	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 39622                                  MSG_1486:
 39623                                  	db 150
 39624                                  	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 39625                                  	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
 39626                                  MSG_1487:
 39627                                  	db 102
 39628                                  	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
 39629                                  	db '  /L          Uses lowercase.',0Dh,0Ah
 39630                                  	db 0Dh,0Ah
 39631                                  MSG_1488:
 39632                                  	db 146
 39633                                  	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 39634                                  	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 39635                                  %endif
 39636                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39637                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:7CBFh
 39638                                  MSG_1480:
 39639 00007770 89                      	db 137
 39640 00007771 446973706C61797320-     	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 39640 0000777A 61206C697374206F66-
 39640 00007783 2066696C657320616E-
 39640 0000778C 642073756264697265-
 39640 00007795 63746F726965732069-
 39640 0000779E 6E2061206469726563-
 39640 000077A7 746F72792E0D0A     
 39641 000077AE 0D0A                    	db 0Dh,0Ah
 39642 000077B0 444952205B64726976-     	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attribs]] [/O[[:]sortord]]',0Dh,0Ah
 39642 000077B9 653A5D5B706174685D-
 39642 000077C2 5B66696C656E616D65-
 39642 000077CB 5D205B2F505D205B2F-
 39642 000077D4 575D205B2F415B5B3A-
 39642 000077DD 5D617474726962735D-
 39642 000077E6 5D205B2F4F5B5B3A5D-
 39642 000077EF 736F72746F72645D5D-
 39642 000077F8 0D0A               
 39643                                  MSG_1481:
 39644 000077FA 1E                      	db 30
 39645 000077FB 202020205B2F535D20-     	db '    [/S] [/B] [/L] [/C[H]]',0Dh,0Ah
 39645 00007804 5B2F425D205B2F4C5D-
 39645 0000780D 205B2F435B485D5D0D-
 39645 00007816 0A                 
 39646 00007817 0D0A                    	db 0Dh,0Ah
 39647                                  MSG_1482:
 39648 00007819 50                      	db 80
 39649 0000781A 20205B64726976653A-     	db '  [drive:][path][filename]   Specifies drive, directory, and/or files to list.',0Dh,0Ah
 39649 00007823 5D5B706174685D5B66-
 39649 0000782C 696C656E616D655D20-
 39649 00007835 202053706563696669-
 39649 0000783E 65732064726976652C-
 39649 00007847 206469726563746F72-
 39649 00007850 792C20616E642F6F72-
 39649 00007859 2066696C657320746F-
 39649 00007862 206C6973742E0D0A   
 39650                                  MSG_1483:
 39651 0000786A 59                      	db 89
 39652 0000786B 20202F502020202020-     	db '  /P      Pauses after each screenful of information.',0Dh,0Ah
 39652 00007874 205061757365732061-
 39652 0000787D 667465722065616368-
 39652 00007886 2073637265656E6675-
 39652 0000788F 6C206F6620696E666F-
 39652 00007898 726D6174696F6E2E0D-
 39652 000078A1 0A                 
 39653 000078A2 20202F572020202020-     	db '  /W      Uses wide list format.',0Dh,0Ah
 39653 000078AB 205573657320776964-
 39653 000078B4 65206C69737420666F-
 39653 000078BD 726D61742E0D0A     
 39654                                  MSG_1484:
 39655 000078C4 7E                      	db 126
 39656 000078C5 20202F412020202020-     	db '  /A      Displays files with specified attributes.',0Dh,0Ah
 39656 000078CE 20446973706C617973-
 39656 000078D7 2066696C6573207769-
 39656 000078E0 746820737065636966-
 39656 000078E9 696564206174747269-
 39656 000078F2 62757465732E0D0A   
 39657 000078FA 202061747472696273-     	db '  attribs   D  Directories   R  Read-only files         H  Hidden files',0Dh,0Ah
 39657 00007903 202020442020446972-
 39657 0000790C 6563746F7269657320-
 39657 00007915 202052202052656164-
 39657 0000791E 2D6F6E6C792066696C-
 39657 00007927 657320202020202020-
 39657 00007930 202048202048696464-
 39657 00007939 656E2066696C65730D-
 39657 00007942 0A                 
 39658                                  MSG_1485:
 39659 00007943 7B                      	db 123
 39660 00007944 202020202020202020-     	db '            S  System files  A  Files ready to archive  -  Prefix meaning "not"',0Dh,0Ah
 39660 0000794D 202020532020537973-
 39660 00007956 74656D2066696C6573-
 39660 0000795F 202041202046696C65-
 39660 00007968 732072656164792074-
 39660 00007971 6F2061726368697665-
 39660 0000797A 20202D202050726566-
 39660 00007983 6978206D65616E696E-
 39660 0000798C 6720226E6F74220D0A 
 39661 00007995 20202F4F2020202020-     	db '  /O      List by files in sorted order.',0Dh,0Ah
 39661 0000799E 204C69737420627920-
 39661 000079A7 66696C657320696E20-
 39661 000079B0 736F72746564206F72-
 39661 000079B9 6465722E0D0A       
 39662                                  MSG_1486:
 39663 000079BF 95                      	db 149
 39664 000079C0 2020736F72746F7264-     	db '  sortord   N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 39664 000079C9 2020204E2020427920-
 39664 000079D2 6E616D652028616C70-
 39664 000079DB 686162657469632920-
 39664 000079E4 202020202020532020-
 39664 000079ED 42792073697A652028-
 39664 000079F6 736D616C6C65737420-
 39664 000079FF 6669727374290D0A   
 39665 00007A07 202020202020202020-     	db '            E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 39665 00007A10 202020452020427920-
 39665 00007A19 657874656E73696F6E-
 39665 00007A22 2028616C7068616265-
 39665 00007A2B 746963292020442020-
 39665 00007A34 427920646174652026-
 39665 00007A3D 2074696D6520286561-
 39665 00007A46 726C69657374206669-
 39665 00007A4F 727374290D0A       
 39666                                  MSG_1487:
 39667 00007A55 46                      	db 70
 39668 00007A56 202020202020202020-     	db '            G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 39668 00007A5F 20202047202047726F-
 39668 00007A68 757020646972656374-
 39668 00007A71 6F7269657320666972-
 39668 00007A7A 7374202020202D2020-
 39668 00007A83 50726566697820746F-
 39668 00007A8C 207265766572736520-
 39668 00007A95 6F726465720D0A     
 39669                                  MSG_1488:
 39670 00007A9C 7F                      	db 127
 39671 00007A9D 202020202020202020-     	db '            C  By compression ratio (smallest first)',0Dh,0Ah
 39671 00007AA6 202020432020427920-
 39671 00007AAF 636F6D707265737369-
 39671 00007AB8 6F6E20726174696F20-
 39671 00007AC1 28736D616C6C657374-
 39671 00007ACA 206669727374290D0A 
 39672 00007AD3 20202F532020202020-     	db '  /S      Displays files in specified directory and all subdirectories.',0Dh,0Ah
 39672 00007ADC 20446973706C617973-
 39672 00007AE5 2066696C657320696E-
 39672 00007AEE 207370656369666965-
 39672 00007AF7 64206469726563746F-
 39672 00007B00 727920616E6420616C-
 39672 00007B09 6C2073756264697265-
 39672 00007B12 63746F726965732E0D-
 39672 00007B1B 0A                 
 39673                                  MSG_1489:
 39674 00007B1C 41                      	db 65
 39675 00007B1D 20202F422020202020-     	db '  /B      Uses bare format (no heading information or summary).',0Dh,0Ah
 39675 00007B26 205573657320626172-
 39675 00007B2F 6520666F726D617420-
 39675 00007B38 286E6F206865616469-
 39675 00007B41 6E6720696E666F726D-
 39675 00007B4A 6174696F6E206F7220-
 39675 00007B53 73756D6D617279292E-
 39675 00007B5C 0D0A               
 39676                                  MSG_1490:
 39677 00007B5E 1B                      	db 27
 39678 00007B5F 20202F4C2020202020-     	db '  /L      Uses lowercase.',0Dh,0Ah
 39678 00007B68 2055736573206C6F77-
 39678 00007B71 6572636173652E0D0A 
 39679                                  MSG_1491:
 39680 00007B7A 52                      	db 82
 39681 00007B7B 20202F435B485D2020-     	db '  /C[H]   Displays file compression ratio; /CH uses host allocation unit size.',0Dh,0Ah
 39681 00007B84 20446973706C617973-
 39681 00007B8D 2066696C6520636F6D-
 39681 00007B96 7072657373696F6E20-
 39681 00007B9F 726174696F3B202F43-
 39681 00007BA8 48207573657320686F-
 39681 00007BB1 737420616C6C6F6361-
 39681 00007BBA 74696F6E20756E6974-
 39681 00007BC3 2073697A652E0D0A   
 39682 00007BCB 0D0A                    	db 0Dh,0Ah
 39683                                  MSG_1492:
 39684 00007BCD 92                      	db 146
 39685 00007BCE 537769746368657320-     	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 39685 00007BD7 6D6179206265207072-
 39685 00007BE0 6573657420696E2074-
 39685 00007BE9 686520444952434D44-
 39685 00007BF2 20656E7669726F6E6D-
 39685 00007BFB 656E74207661726961-
 39685 00007C04 626C652E20204F7665-
 39685 00007C0D 72726964650D0A     
 39686 00007C14 707265736574207377-     	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 39686 00007C1D 697463686573206279-
 39686 00007C26 20707265666978696E-
 39686 00007C2F 6720616E7920737769-
 39686 00007C38 746368207769746820-
 39686 00007C41 2D202868797068656E-
 39686 00007C4A 292D2D666F72206578-
 39686 00007C53 616D706C652C202F2D-
 39686 00007C5C 572E0D0A           
 39687                                  MSG_1493:
 39688 00007C60 16                      	db 22
 39689 00007C61 202020205B2F535D20-     	db '    [/S] [/B] [/L]',0Dh,0Ah
 39689 00007C6A 5B2F425D205B2F4C5D-
 39689 00007C73 0D0A               
 39690 00007C75 0D0A                    	db 0Dh,0Ah
 39691                                  MSG_1494:
 39692 00007C77 1D                      	db 29
 39693 00007C78 20202F4C2020202020-     	db '  /L      Uses lowercase.',0Dh,0Ah
 39693 00007C81 2055736573206C6F77-
 39693 00007C8A 6572636173652E0D0A 
 39694 00007C93 0D0A                    	db 0Dh,0Ah
 39695                                  
 39696                                  MSG_1500:
 39697 00007C95 3E                      	db 62
 39698 00007C96 517569747320746865-     	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
 39698 00007C9F 20434F4D4D414E442E-
 39698 00007CA8 434F4D2070726F6772-
 39698 00007CB1 616D2028636F6D6D61-
 39698 00007CBA 6E6420696E74657270-
 39698 00007CC3 7265746572292E0D0A 
 39699 00007CCC 0D0A                    	db 0Dh,0Ah
 39700 00007CCE 455849540D0A            	db 'EXIT',0Dh,0Ah
 39701                                  MSG_1520:
 39702 00007CD4 3D                      	db 61
 39703 00007CD5 437265617465732061-     	db 'Creates a directory.',0Dh,0Ah
 39703 00007CDE 206469726563746F72-
 39703 00007CE7 792E0D0A           
 39704 00007CEB 0D0A                    	db 0Dh,0Ah
 39705 00007CED 4D4B444952205B6472-     	db 'MKDIR [drive:]path',0Dh,0Ah
 39705 00007CF6 6976653A5D70617468-
 39705 00007CFF 0D0A               
 39706 00007D01 4D44205B6472697665-     	db 'MD [drive:]path',0Dh,0Ah
 39706 00007D0A 3A5D706174680D0A   
 39707                                  MSG_1540:
 39708 00007D12 5D                      	db 93
 39709 00007D13 446973706C61797320-     	db 'Displays or sets a search path for executable files.',0Dh,0Ah
 39709 00007D1C 6F7220736574732061-
 39709 00007D25 207365617263682070-
 39709 00007D2E 61746820666F722065-
 39709 00007D37 786563757461626C65-
 39709 00007D40 2066696C65732E0D0A 
 39710 00007D49 0D0A                    	db 0Dh,0Ah
 39711 00007D4B 50415448205B5B6472-     	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
 39711 00007D54 6976653A5D70617468-
 39711 00007D5D 5B3B2E2E2E5D5D0D0A 
 39712 00007D66 50415448203B0D0A        	db 'PATH ;',0Dh,0Ah
 39713 00007D6E 0D0A                    	db 0Dh,0Ah
 39714                                  MSG_1541:
 39715 00007D70 6B                      	db 107
 39716 00007D71 547970652050415448-     	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
 39716 00007D7A 203B20746F20636C65-
 39716 00007D83 617220616C6C207365-
 39716 00007D8C 617263682D70617468-
 39716 00007D95 2073657474696E6773-
 39716 00007D9E 20616E642064697265-
 39716 00007DA7 6374204D532D444F53-
 39716 00007DB0 20746F207365617263-
 39716 00007DB9 680D0A             
 39717 00007DBC 6F6E6C7920696E2074-     	db 'only in the current directory.',0Dh,0Ah
 39717 00007DC5 68652063757272656E-
 39717 00007DCE 74206469726563746F-
 39717 00007DD7 72792E0D0A         
 39718                                  MSG_1542:
 39719 00007DDC 3B                      	db 59
 39720 00007DDD 547970652050415448-     	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
 39720 00007DE6 20776974686F757420-
 39720 00007DEF 706172616D65746572-
 39720 00007DF8 7320746F2064697370-
 39720 00007E01 6C6179207468652063-
 39720 00007E0A 757272656E74207061-
 39720 00007E13 74682E0D0A         
 39721                                  MSG_1560:
 39722 00007E18 37                      	db 55
 39723 00007E19 4368616E6765732074-     	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
 39723 00007E22 6865204D532D444F53-
 39723 00007E2B 20636F6D6D616E6420-
 39723 00007E34 70726F6D70742E0D0A 
 39724 00007E3D 0D0A                    	db 0Dh,0Ah
 39725 00007E3F 50524F4D5054205B74-     	db 'PROMPT [text]',0Dh,0Ah
 39725 00007E48 6578745D0D0A       
 39726 00007E4E 0D0A                    	db 0Dh,0Ah
 39727                                  MSG_1561:
 39728 00007E50 7C                      	db 124
 39729 00007E51 202074657874202020-     	db '  text    Specifies a new command prompt.',0Dh,0Ah
 39729 00007E5A 205370656369666965-
 39729 00007E63 732061206E65772063-
 39729 00007E6C 6F6D6D616E64207072-
 39729 00007E75 6F6D70742E0D0A     
 39730 00007E7C 0D0A                    	db 0Dh,0Ah
 39731 00007E7E 50726F6D7074206361-     	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
 39731 00007E87 6E206265206D616465-
 39731 00007E90 207570206F66206E6F-
 39731 00007E99 726D616C2063686172-
 39731 00007EA2 61637465727320616E-
 39731 00007EAB 642074686520666F6C-
 39731 00007EB4 6C6F77696E67207370-
 39731 00007EBD 656369616C20636F64-
 39731 00007EC6 65733A0D0A         
 39732 00007ECB 0D0A                    	db 0Dh,0Ah
 39733                                  MSG_1562:
 39734 00007ECD 2F                      	db 47
 39735 00007ECE 202024512020203D20-     	db '  $Q   = (equal sign)',0Dh,0Ah
 39735 00007ED7 28657175616C207369-
 39735 00007EE0 676E290D0A         
 39736 00007EE5 202024242020202420-     	db '  $$   $ (dollar sign)',0Dh,0Ah
 39736 00007EEE 28646F6C6C61722073-
 39736 00007EF7 69676E290D0A       
 39737                                  MSG_1563:
 39738 00007EFD 2A                      	db 42
 39739 00007EFE 202024542020204375-     	db '  $T   Current time',0Dh,0Ah
 39739 00007F07 7272656E742074696D-
 39739 00007F10 650D0A             
 39740 00007F13 202024442020204375-     	db '  $D   Current date',0Dh,0Ah
 39740 00007F1C 7272656E7420646174-
 39740 00007F25 650D0A             
 39741                                  MSG_1564:
 39742 00007F28 3D                      	db 61
 39743 00007F29 202024502020204375-     	db '  $P   Current drive and path',0Dh,0Ah
 39743 00007F32 7272656E7420647269-
 39743 00007F3B 766520616E64207061-
 39743 00007F44 74680D0A           
 39744 00007F48 202024562020204D53-     	db '  $V   MS-DOS version number',0Dh,0Ah
 39744 00007F51 2D444F532076657273-
 39744 00007F5A 696F6E206E756D6265-
 39744 00007F63 720D0A             
 39745                                  MSG_1565:
 39746 00007F66 34                      	db 52
 39747 00007F67 2020244E2020204375-     	db '  $N   Current drive',0Dh,0Ah
 39747 00007F70 7272656E7420647269-
 39747 00007F79 76650D0A           
 39748 00007F7D 202024472020203E20-     	db '  $G   > (greater-than sign)',0Dh,0Ah
 39748 00007F86 28677265617465722D-
 39748 00007F8F 7468616E207369676E-
 39748 00007F98 290D0A             
 39749                                  MSG_1566:
 39750 00007F9B 2C                      	db 44
 39751 00007F9C 2020244C2020203C20-     	db '  $L   < (less-than sign)',0Dh,0Ah
 39751 00007FA5 286C6573732D746861-
 39751 00007FAE 6E207369676E290D0A 
 39752 00007FB7 202024422020207C20-     	db '  $B   | (pipe)',0Dh,0Ah
 39752 00007FC0 2870697065290D0A   
 39753                                  MSG_1567:
 39754 00007FC8 79                      	db 121
 39755 00007FC9 202024482020204261-     	db '  $H   Backspace (erases previous character)',0Dh,0Ah
 39755 00007FD2 636B73706163652028-
 39755 00007FDB 657261736573207072-
 39755 00007FE4 6576696F7573206368-
 39755 00007FED 61726163746572290D-
 39755 00007FF6 0A                 
 39756 00007FF7 202024452020204573-     	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
 39756 00008000 6361706520636F6465-
 39756 00008009 202841534349492063-
 39756 00008012 6F6465203237290D0A 
 39757 0000801B 2020245F2020204361-     	db '  $_   Carriage return and linefeed',0Dh,0Ah
 39757 00008024 727269616765207265-
 39757 0000802D 7475726E20616E6420-
 39757 00008036 6C696E65666565640D-
 39757 0000803F 0A                 
 39758 00008040 0D0A                    	db 0Dh,0Ah
 39759                                  MSG_1568:
 39760 00008042 4C                      	db 76
 39761 00008043 547970652050524F4D-     	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
 39761 0000804C 505420776974686F75-
 39761 00008055 7420706172616D6574-
 39761 0000805E 65727320746F207265-
 39761 00008067 736574207468652070-
 39761 00008070 726F6D707420746F20-
 39761 00008079 746865206465666175-
 39761 00008082 6C742073657474696E-
 39761 0000808B 672E0D0A           
 39762                                  MSG_1580:
 39763 0000808F 47                      	db 71
 39764 00008090 52656D6F7665732028-     	db 'Removes (deletes) a directory.',0Dh,0Ah
 39764 00008099 64656C657465732920-
 39764 000080A2 61206469726563746F-
 39764 000080AB 72792E0D0A         
 39765 000080B0 0D0A                    	db 0Dh,0Ah
 39766 000080B2 524D444952205B6472-     	db 'RMDIR [drive:]path',0Dh,0Ah
 39766 000080BB 6976653A5D70617468-
 39766 000080C4 0D0A               
 39767 000080C6 5244205B6472697665-     	db 'RD [drive:]path',0Dh,0Ah
 39767 000080CF 3A5D706174680D0A   
 39768                                  MSG_1600:
 39769 000080D7 1C                      	db 28
 39770 000080D8 52656E616D65732061-     	db 'Renames a file or files.',0Dh,0Ah
 39770 000080E1 2066696C65206F7220-
 39770 000080EA 66696C65732E0D0A   
 39771 000080F2 0D0A                    	db 0Dh,0Ah
 39772                                  MSG_1601:
 39773 000080F4 53                      	db 83
 39774 000080F5 52454E414D45205B64-     	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
 39774 000080FE 726976653A5D5B7061-
 39774 00008107 74685D66696C656E61-
 39774 00008110 6D65312066696C656E-
 39774 00008119 616D65320D0A       
 39775 0000811F 52454E205B64726976-     	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
 39775 00008128 653A5D5B706174685D-
 39775 00008131 66696C656E616D6531-
 39775 0000813A 2066696C656E616D65-
 39775 00008143 320D0A             
 39776 00008146 0D0A                    	db 0Dh,0Ah
 39777                                  MSG_1602:
 39778                                  	;db 77
 39779                                  	;db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 39780                                  
 39781                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39782                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:8697h
 39783                                  MSG_1602:
 39784 00008148 A0                      	db 160
 39785 00008149 4E6F74652074686174-     	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 39785 00008152 20796F752063616E6E-
 39785 0000815B 6F7420737065636966-
 39785 00008164 792061206E65772064-
 39785 0000816D 72697665206F722070-
 39785 00008176 61746820666F722079-
 39785 0000817F 6F7572206465737469-
 39785 00008188 6E6174696F6E206669-
 39785 00008191 6C652E0D0A         
 39786 00008196 0D0A                    	db 0Dh,0Ah
 39787 00008198 557365204D4F564520-     	db 'Use MOVE to rename a directory, or to move files from one directory to another.',0Dh,0Ah
 39787 000081A1 746F2072656E616D65-
 39787 000081AA 206120646972656374-
 39787 000081B3 6F72792C206F722074-
 39787 000081BC 6F206D6F7665206669-
 39787 000081C5 6C65732066726F6D20-
 39787 000081CE 6F6E65206469726563-
 39787 000081D7 746F727920746F2061-
 39787 000081E0 6E6F746865722E0D0A 
 39788                                  MSG_1620:
 39789 000081E9 57                      	db 87
 39790 000081EA 446973706C6179732C-     	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
 39790 000081F3 20736574732C206F72-
 39790 000081FC 2072656D6F76657320-
 39790 00008205 4D532D444F5320656E-
 39790 0000820E 7669726F6E6D656E74-
 39790 00008217 207661726961626C65-
 39790 00008220 732E0D0A           
 39791 00008224 0D0A                    	db 0Dh,0Ah
 39792 00008226 534554205B76617269-     	db 'SET [variable=[string]]',0Dh,0Ah
 39792 0000822F 61626C653D5B737472-
 39792 00008238 696E675D5D0D0A     
 39793 0000823F 0D0A                    	db 0Dh,0Ah
 39794                                  MSG_1621:
 39795 00008241 81                      	db 129
 39796 00008242 20207661726961626C-     	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
 39796 0000824B 652020537065636966-
 39796 00008254 696573207468652065-
 39796 0000825D 6E7669726F6E6D656E-
 39796 00008266 742D7661726961626C-
 39796 0000826F 65206E616D652E0D0A 
 39797 00008278 2020737472696E6720-     	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
 39797 00008281 202020537065636966-
 39797 0000828A 696573206120736572-
 39797 00008293 696573206F66206368-
 39797 0000829C 617261637465727320-
 39797 000082A5 746F2061737369676E-
 39797 000082AE 20746F207468652076-
 39797 000082B7 61726961626C652E0D-
 39797 000082C0 0A                 
 39798 000082C1 0D0A                    	db 0Dh,0Ah
 39799                                  MSG_1622:
 39800 000082C3 4B                      	db 75
 39801 000082C4 547970652053455420-     	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
 39801 000082CD 776974686F75742070-
 39801 000082D6 6172616D6574657273-
 39801 000082DF 20746F20646973706C-
 39801 000082E8 617920746865206375-
 39801 000082F1 7272656E7420656E76-
 39801 000082FA 69726F6E6D656E7420-
 39801 00008303 7661726961626C6573-
 39801 0000830C 2E0D0A             
 39802                                  MSG_1640:
 39803                                  	;db 52
 39804                                  	;db 'Displays or sets the system time.',0Dh,0Ah
 39805                                  	;db 0Dh,0Ah
 39806                                  	;db 'TIME [time]',0Dh,0Ah
 39807                                  	;db 0Dh,0Ah
 39808                                  
 39809                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39810                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:885Eh)
 39811 0000830F 2D                      	db 45
 39812 00008310 446973706C61797320-     	db 'Displays or sets the time.',0Dh,0Ah
 39812 00008319 6F7220736574732074-
 39812 00008322 68652074696D652E0D-
 39812 0000832B 0A                 
 39813 0000832C 0D0A                    	db 0Dh,0Ah
 39814 0000832E 54494D45205B74696D-     	db 'TIME [time]',0Dh,0Ah
 39814 00008337 655D0D0A           
 39815 0000833B 0D0A                    	db 0Dh,0Ah
 39816                                  MSG_1641:
 39817 0000833D 83                      	db 131
 39818 0000833E 547970652054494D45-     	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
 39818 00008347 2077697468206E6F20-
 39818 00008350 706172616D65746572-
 39818 00008359 7320746F2064697370-
 39818 00008362 6C6179207468652063-
 39818 0000836B 757272656E74207469-
 39818 00008374 6D652073657474696E-
 39818 0000837D 6720616E6420612070-
 39818 00008386 726F6D70740D0A     
 39819 0000838D 666F722061206E6577-     	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
 39819 00008396 206F6E652E20205072-
 39819 0000839F 65737320454E544552-
 39819 000083A8 20746F206B65657020-
 39819 000083B1 7468652073616D6520-
 39819 000083BA 74696D652E0D0A     
 39820                                  MSG_1660:
 39821 000083C1 46                      	db 70
 39822 000083C2 446973706C61797320-     	db 'Displays the contents of a text file.',0Dh,0Ah
 39822 000083CB 74686520636F6E7465-
 39822 000083D4 6E7473206F66206120-
 39822 000083DD 746578742066696C65-
 39822 000083E6 2E0D0A             
 39823 000083E9 0D0A                    	db 0Dh,0Ah
 39824 000083EB 54595045205B647269-     	db 'TYPE [drive:][path]filename',0Dh,0Ah
 39824 000083F4 76653A5D5B70617468-
 39824 000083FD 5D66696C656E616D65-
 39824 00008406 0D0A               
 39825                                  MSG_1680:
 39826 00008408 25                      	db 37
 39827 00008409 446973706C61797320-     	db 'Displays the MS-DOS version.',0Dh,0Ah
 39827 00008412 746865204D532D444F-
 39827 0000841B 532076657273696F6E-
 39827 00008424 2E0D0A             
 39828 00008427 0D0A                    	db 0Dh,0Ah
 39829 00008429 5645520D0A              	db 'VER',0Dh,0Ah
 39830                                  MSG_1700:
 39831 0000842E B1                      	db 177
 39832 0000842F 54656C6C73204D532D-     	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
 39832 00008438 444F53207768657468-
 39832 00008441 657220746F20766572-
 39832 0000844A 696679207468617420-
 39832 00008453 796F75722066696C65-
 39832 0000845C 732061726520777269-
 39832 00008465 7474656E20636F7272-
 39832 0000846E 6563746C7920746F20-
 39832 00008477 610D0A             
 39833 0000847A 6469736B2E0D0A          	db 'disk.',0Dh,0Ah
 39834 00008481 0D0A                    	db 0Dh,0Ah
 39835 00008483 564552494659205B4F-     	db 'VERIFY [ON | OFF]',0Dh,0Ah
 39835 0000848C 4E207C204F46465D0D-
 39835 00008495 0A                 
 39836 00008496 0D0A                    	db 0Dh,0Ah
 39837 00008498 547970652056455249-     	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
 39837 000084A1 465920776974686F75-
 39837 000084AA 74206120706172616D-
 39837 000084B3 6574657220746F2064-
 39837 000084BC 6973706C6179207468-
 39837 000084C5 652063757272656E74-
 39837 000084CE 205645524946592073-
 39837 000084D7 657474696E672E0D0A 
 39838                                  MSG_1720:
 39839 000084E0 52                      	db 82
 39840 000084E1 446973706C61797320-     	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
 39840 000084EA 746865206469736B20-
 39840 000084F3 766F6C756D65206C61-
 39840 000084FC 62656C20616E642073-
 39840 00008505 657269616C206E756D-
 39840 0000850E 6265722C2069662074-
 39840 00008517 686579206578697374-
 39840 00008520 2E0D0A             
 39841 00008523 0D0A                    	db 0Dh,0Ah
 39842 00008525 564F4C205B64726976-     	db 'VOL [drive:]',0Dh,0Ah
 39842 0000852E 653A5D0D0A         
 39843                                  MSG_1740:
 39844 00008533 5B                      	db 91
 39845 00008534 43616C6C73206F6E65-     	db 'Calls one batch program from another.',0Dh,0Ah
 39845 0000853D 206261746368207072-
 39845 00008546 6F6772616D2066726F-
 39845 0000854F 6D20616E6F74686572-
 39845 00008558 2E0D0A             
 39846 0000855B 0D0A                    	db 0Dh,0Ah
 39847 0000855D 43414C4C205B647269-     	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
 39847 00008566 76653A5D5B70617468-
 39847 0000856F 5D66696C656E616D65-
 39847 00008578 205B62617463682D70-
 39847 00008581 6172616D6574657273-
 39847 0000858A 5D0D0A             
 39848 0000858D 0D0A                    	db 0Dh,0Ah
 39849                                  MSG_1741:
 39850 0000858F 72                      	db 114
 39851 00008590 202062617463682D70-     	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
 39851 00008599 6172616D6574657273-
 39851 000085A2 202020537065636966-
 39851 000085AB 69657320616E792063-
 39851 000085B4 6F6D6D616E642D6C69-
 39851 000085BD 6E6520696E666F726D-
 39851 000085C6 6174696F6E20726571-
 39851 000085CF 756972656420627920-
 39851 000085D8 7468650D0A         
 39852 000085DD 202020202020202020-     	db '                     batch program.',0Dh,0Ah
 39852 000085E6 202020202020202020-
 39852 000085EF 202020626174636820-
 39852 000085F8 70726F6772616D2E0D-
 39852 00008601 0A                 
 39853                                  MSG_1760:
 39854 00008602 4C                      	db 76
 39855 00008603 5265636F7264732063-     	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
 39855 0000860C 6F6D6D656E74732028-
 39855 00008615 72656D61726B732920-
 39855 0000861E 696E20612062617463-
 39855 00008627 682066696C65206F72-
 39855 00008630 20434F4E4649472E53-
 39855 00008639 59532E0D0A         
 39856 0000863E 0D0A                    	db 0Dh,0Ah
 39857 00008640 52454D205B636F6D6D-     	db 'REM [comment]',0Dh,0Ah
 39857 00008649 656E745D0D0A       
 39858                                  MSG_1780:
 39859 0000864F 6B                      	db 107
 39860 00008650 53757370656E647320-     	db 'Suspends processing of a batch program and displays the message "'
 39860 00008659 70726F63657373696E-
 39860 00008662 67206F662061206261-
 39860 0000866B 7463682070726F6772-
 39860 00008674 616D20616E64206469-
 39860 0000867D 73706C617973207468-
 39860 00008686 65206D657373616765-
 39860 0000868F 2022               
 39861 00008691 507265737320616E79-     	db 'Press any',0Dh,0Ah
 39861 0000869A 0D0A               
 39862 0000869C 6B657920746F20636F-     	db 'key to continue...."',0Dh,0Ah
 39862 000086A5 6E74696E75652E2E2E-
 39862 000086AE 2E220D0A           
 39863 000086B2 0D0A                    	db 0Dh,0Ah
 39864 000086B4 50415553450D0A          	db 'PAUSE',0Dh,0Ah
 39865                                  MSG_1800:
 39866 000086BB 4D                      	db 77
 39867 000086BC 446973706C61797320-     	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
 39867 000086C5 6D657373616765732C-
 39867 000086CE 206F72207475726E73-
 39867 000086D7 20636F6D6D616E642D-
 39867 000086E0 6563686F696E67206F-
 39867 000086E9 6E206F72206F66662E-
 39867 000086F2 0D0A               
 39868 000086F4 0D0A                    	db 0Dh,0Ah
 39869 000086F6 20204543484F205B4F-     	db '  ECHO [ON | OFF]',0Dh,0Ah
 39869 000086FF 4E207C204F46465D0D-
 39869 00008708 0A                 
 39870                                  MSG_1801:
 39871 00008709 57                      	db 87
 39872 0000870A 20204543484F205B6D-     	db '  ECHO [message]',0Dh,0Ah
 39872 00008713 6573736167655D0D0A 
 39873 0000871C 0D0A                    	db 0Dh,0Ah
 39874 0000871E 54797065204543484F-     	db 'Type ECHO without parameters to display the current echo setting.'
 39874 00008727 20776974686F757420-
 39874 00008730 706172616D65746572-
 39874 00008739 7320746F2064697370-
 39874 00008742 6C6179207468652063-
 39874 0000874B 757272656E74206563-
 39874 00008754 686F2073657474696E-
 39874 0000875D 672E               
 39875 0000875F 0D0A                    	db 0Dh,0Ah
 39876                                  MSG_1820:
 39877 00008761 47                      	db 71
 39878 00008762 44697265637473204D-     	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
 39878 0000876B 532D444F5320746F20-
 39878 00008774 61206C6162656C6C65-
 39878 0000877D 64206C696E6520696E-
 39878 00008786 206120626174636820-
 39878 0000878F 70726F6772616D2E0D-
 39878 00008798 0A                 
 39879 00008799 0D0A                    	db 0Dh,0Ah
 39880 0000879B 474F544F206C616265-     	db 'GOTO label',0Dh,0Ah
 39880 000087A4 6C0D0A             
 39881 000087A7 0D0A                    	db 0Dh,0Ah
 39882                                  MSG_1821:
 39883 000087A9 8A                      	db 138
 39884 000087AA 20206C6162656C2020-     	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
 39884 000087B3 205370656369666965-
 39884 000087BC 732061207465787420-
 39884 000087C5 737472696E67207573-
 39884 000087CE 656420696E20746865-
 39884 000087D7 206261746368207072-
 39884 000087E0 6F6772616D20617320-
 39884 000087E9 61206C6162656C2E0D-
 39884 000087F2 0A                 
 39885 000087F3 0D0A                    	db 0Dh,0Ah
 39886 000087F5 596F75207479706520-     	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
 39886 000087FE 61206C6162656C206F-
 39886 00008807 6E2061206C696E6520-
 39886 00008810 627920697473656C66-
 39886 00008819 2C20626567696E6E69-
 39886 00008822 6E6720776974682061-
 39886 0000882B 20636F6C6F6E2E0D0A 
 39887                                  MSG_1840:
 39888 00008834 4A                      	db 74
 39889 00008835 4368616E6765732074-     	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
 39889 0000883E 686520706F73697469-
 39889 00008847 6F6E206F6620726570-
 39889 00008850 6C61636561626C6520-
 39889 00008859 706172616D65746572-
 39889 00008862 7320696E2061206261-
 39889 0000886B 7463682066696C652E-
 39889 00008874 0D0A               
 39890 00008876 0D0A                    	db 0Dh,0Ah
 39891 00008878 53484946540D0A          	db 'SHIFT',0Dh,0Ah
 39892                                  MSG_1860:
 39893 0000887F 5A                      	db 90
 39894 00008880 506572666F726D7320-     	db 'Performs conditional processing in batch programs.',0Dh,0Ah
 39894 00008889 636F6E646974696F6E-
 39894 00008892 616C2070726F636573-
 39894 0000889B 73696E6720696E2062-
 39894 000088A4 617463682070726F67-
 39894 000088AD 72616D732E0D0A     
 39895 000088B4 0D0A                    	db 0Dh,0Ah
 39896 000088B6 4946205B4E4F545D20-     	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
 39896 000088BF 4552524F524C455645-
 39896 000088C8 4C206E756D62657220-
 39896 000088D1 636F6D6D616E640D0A 
 39897                                  MSG_1861:
 39898 000088DA 46                      	db 70
 39899 000088DB 4946205B4E4F545D20-     	db 'IF [NOT] string1==string2 command',0Dh,0Ah
 39899 000088E4 737472696E67313D3D-
 39899 000088ED 737472696E67322063-
 39899 000088F6 6F6D6D616E640D0A   
 39900 000088FE 4946205B4E4F545D20-     	db 'IF [NOT] EXIST filename command',0Dh,0Ah
 39900 00008907 45584953542066696C-
 39900 00008910 656E616D6520636F6D-
 39900 00008919 6D616E640D0A       
 39901 0000891F 0D0A                    	db 0Dh,0Ah
 39902                                  MSG_1862:
 39903 00008921 7D                      	db 125
 39904 00008922 20204E4F5420202020-     	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
 39904 0000892B 202020202020202020-
 39904 00008934 202053706563696669-
 39904 0000893D 65732074686174204D-
 39904 00008946 532D444F532073686F-
 39904 0000894F 756C64206361727279-
 39904 00008958 206F75742074686520-
 39904 00008961 636F6D6D616E64206F-
 39904 0000896A 6E6C790D0A         
 39905 0000896F 202020202020202020-     	db '                    if the condition is false.',0Dh,0Ah
 39905 00008978 202020202020202020-
 39905 00008981 202069662074686520-
 39905 0000898A 636F6E646974696F6E-
 39905 00008993 2069732066616C7365-
 39905 0000899C 2E0D0A             
 39906                                  MSG_1863:
 39907 0000899F A2                      	db 162
 39908 000089A0 20204552524F524C45-     	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
 39908 000089A9 56454C206E756D6265-
 39908 000089B2 722053706563696669-
 39908 000089BB 657320612074727565-
 39908 000089C4 20636F6E646974696F-
 39908 000089CD 6E2069662074686520-
 39908 000089D6 6C6173742070726F67-
 39908 000089DF 72616D2072756E2072-
 39908 000089E8 657475726E65640D0A 
 39909 000089F1 202020202020202020-     	db '                    '
 39909 000089FA 202020202020202020-
 39909 00008A03 2020               
 39910 00008A05 616E20657869742063-     	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
 39910 00008A0E 6F646520657175616C-
 39910 00008A17 20746F206F72206772-
 39910 00008A20 656174657220746861-
 39910 00008A29 6E20746865206E756D-
 39910 00008A32 626572207370656369-
 39910 00008A3B 666965642E0D0A     
 39911                                  MSG_1864:
 39912 00008A42 66                      	db 102
 39913 00008A43 2020636F6D6D616E64-     	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
 39913 00008A4C 202020202020202020-
 39913 00008A55 202053706563696669-
 39913 00008A5E 65732074686520636F-
 39913 00008A67 6D6D616E6420746F20-
 39913 00008A70 6361727279206F7574-
 39913 00008A79 206966207468652063-
 39913 00008A82 6F6E646974696F6E20-
 39913 00008A8B 69730D0A           
 39914 00008A8F 202020202020202020-     	db '                    met.',0Dh,0Ah
 39914 00008A98 202020202020202020-
 39914 00008AA1 20206D65742E0D0A   
 39915                                  MSG_1865:
 39916 00008AA9 6A                      	db 106
 39917 00008AAA 2020737472696E6731-     	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
 39917 00008AB3 3D3D737472696E6732-
 39917 00008ABC 202053706563696669-
 39917 00008AC5 657320612074727565-
 39917 00008ACE 20636F6E646974696F-
 39917 00008AD7 6E2069662074686520-
 39917 00008AE0 737065636966696564-
 39917 00008AE9 207465787420737472-
 39917 00008AF2 696E67730D0A       
 39918 00008AF8 202020202020202020-     	db '                    match.',0Dh,0Ah
 39918 00008B01 202020202020202020-
 39918 00008B0A 20206D617463682E0D-
 39918 00008B13 0A                 
 39919                                  MSG_1866:
 39920 00008B14 67                      	db 103
 39921 00008B15 202045584953542066-     	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
 39921 00008B1E 696C656E616D652020-
 39921 00008B27 202053706563696669-
 39921 00008B30 657320612074727565-
 39921 00008B39 20636F6E646974696F-
 39921 00008B42 6E2069662074686520-
 39921 00008B4B 737065636966696564-
 39921 00008B54 2066696C656E616D65-
 39921 00008B5D 0D0A               
 39922 00008B5F 202020202020202020-     	db '                    exists.',0Dh,0Ah
 39922 00008B68 202020202020202020-
 39922 00008B71 20206578697374732E-
 39922 00008B7A 0D0A               
 39923                                  MSG_1880:
 39924 00008B7C 77                      	db 119
 39925 00008B7D 52756E732061207370-     	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
 39925 00008B86 656369666965642063-
 39925 00008B8F 6F6D6D616E6420666F-
 39925 00008B98 722065616368206669-
 39925 00008BA1 6C6520696E20612073-
 39925 00008BAA 6574206F662066696C-
 39925 00008BB3 65732E0D0A         
 39926 00008BB8 0D0A                    	db 0Dh,0Ah
 39927 00008BBA 464F52202576617269-     	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
 39927 00008BC3 61626C6520494E2028-
 39927 00008BCC 7365742920444F2063-
 39927 00008BD5 6F6D6D616E64205B63-
 39927 00008BDE 6F6D6D616E642D7061-
 39927 00008BE7 72616D65746572735D-
 39927 00008BF0 0D0A               
 39928 00008BF2 0D0A                    	db 0Dh,0Ah
 39929                                  MSG_1881:
 39930 00008BF4 7D                      	db 125
 39931 00008BF5 202025766172696162-     	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
 39931 00008BFE 6C6520205370656369-
 39931 00008C07 666965732061207265-
 39931 00008C10 706C61636561626C65-
 39931 00008C19 20706172616D657465-
 39931 00008C22 722E0D0A           
 39932 00008C26 202028736574292020-     	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
 39932 00008C2F 202020205370656369-
 39932 00008C38 666965732061207365-
 39932 00008C41 74206F66206F6E6520-
 39932 00008C4A 6F72206D6F72652066-
 39932 00008C53 696C65732E20205769-
 39932 00008C5C 6C646361726473206D-
 39932 00008C65 617920626520757365-
 39932 00008C6E 642E0D0A           
 39933                                  MSG_1882:
 39934 00008C72 56                      	db 86
 39935 00008C73 2020636F6D6D616E64-     	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
 39935 00008C7C 202020205370656369-
 39935 00008C85 666965732074686520-
 39935 00008C8E 636F6D6D616E642074-
 39935 00008C97 6F206361727279206F-
 39935 00008CA0 757420666F72206561-
 39935 00008CA9 63682066696C652E0D-
 39935 00008CB2 0A                 
 39936 00008CB3 2020636F6D6D616E64-     	db '  command-parameters',0Dh,0Ah
 39936 00008CBC 2D706172616D657465-
 39936 00008CC5 72730D0A           
 39937                                  MSG_1883:
 39938 00008CC9 A2                      	db 162
 39939 00008CCA 202020202020202020-     	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
 39939 00008CD3 202020205370656369-
 39939 00008CDC 666965732070617261-
 39939 00008CE5 6D6574657273206F72-
 39939 00008CEE 207377697463686573-
 39939 00008CF7 20666F722074686520-
 39939 00008D00 737065636966696564-
 39939 00008D09 20636F6D6D616E642E-
 39939 00008D12 0D0A               
 39940 00008D14 0D0A                    	db 0Dh,0Ah
 39941 00008D16 546F20757365207468-     	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
 39941 00008D1F 6520464F5220636F6D-
 39941 00008D28 6D616E6420696E2061-
 39941 00008D31 206261746368207072-
 39941 00008D3A 6F6772616D2C207370-
 39941 00008D43 656369667920252576-
 39941 00008D4C 61726961626C652069-
 39941 00008D55 6E7374656164206F66-
 39941 00008D5E 0D0A               
 39942 00008D60 257661726961626C65-     	db '%variable.',0Dh,0Ah
 39942 00008D69 2E0D0A             
 39943                                  MSG_1900:
 39944 00008D6C 17                      	db 23
 39945 00008D6D 526573657276656420-     	db 'Reserved command name',0Dh,0Ah
 39945 00008D76 636F6D6D616E64206E-
 39945 00008D7F 616D650D0A         
 39946                                  MSG_1920:
 39947 00008D84 2F                      	db 47
 39948 00008D85 4C6F61647320612070-     	db 'Loads a program into the upper memory area.',0Dh,0Ah
 39948 00008D8E 726F6772616D20696E-
 39948 00008D97 746F20746865207570-
 39948 00008DA0 706572206D656D6F72-
 39948 00008DA9 7920617265612E0D0A 
 39949 00008DB2 0D0A                    	db 0Dh,0Ah
 39950                                  MSG_1921:
 39951                                  	;db 88
 39952                                  	;db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 39953                                  	;db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
 39954                                  	;db 0Dh,0Ah
 39955                                  
 39956                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39957                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9303h
 39958 00008DB4 9D                      	db 157
 39959 00008DB5 4C4F41444849474820-     	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 39959 00008DBE 5B64726976653A5D5B-
 39959 00008DC7 706174685D66696C65-
 39959 00008DD0 6E616D65205B706172-
 39959 00008DD9 616D65746572735D0D-
 39959 00008DE2 0A                 
 39960 00008DE3 4C4F41444849474820-     	db 'LOADHIGH [/L:region1[,minsize1][;region2[,minsize2]...] [/S]]',0Dh,0Ah
 39960 00008DEC 5B2F4C3A726567696F-
 39960 00008DF5 6E315B2C6D696E7369-
 39960 00008DFE 7A65315D5B3B726567-
 39960 00008E07 696F6E325B2C6D696E-
 39960 00008E10 73697A65325D2E2E2E-
 39960 00008E19 5D205B2F535D5D0D0A 
 39961 00008E22 202020202020202020-     	db '         [drive:][path]filename [parameters]',0Dh,0Ah
 39961 00008E2B 5B64726976653A5D5B-
 39961 00008E34 706174685D66696C65-
 39961 00008E3D 6E616D65205B706172-
 39961 00008E46 616D65746572735D0D-
 39961 00008E4F 0A                 
 39962 00008E50 0D0A                    	db 0Dh,0Ah
 39963                                  	
 39964                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:8111h)
 39965                                  ;MSG_1922: 	; MSDOS 5.0 COMMAND.COM
 39966                                  	;db 113
 39967                                  	;db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
 39968                                  	;db '               program you want to load.',0Dh,0Ah
 39969                                  
 39970                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39971                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:93A1h
 39972                                  MSG_1922:
 39973 00008E52 B6                      	db 182
 39974 00008E53 2F4C3A726567696F6E-     	db '/L:region1[,minsize1][;region2[,minsize2]]...',0Dh,0Ah
 39974 00008E5C 315B2C6D696E73697A-
 39974 00008E65 65315D5B3B72656769-
 39974 00008E6E 6F6E325B2C6D696E73-
 39974 00008E77 697A65325D5D2E2E2E-
 39974 00008E80 0D0A               
 39975 00008E82 202020202020202020-     	db '            Specifies the region(s) of memory into which to load',0Dh,0Ah
 39975 00008E8B 202020537065636966-
 39975 00008E94 696573207468652072-
 39975 00008E9D 6567696F6E28732920-
 39975 00008EA6 6F66206D656D6F7279-
 39975 00008EAF 20696E746F20776869-
 39975 00008EB8 636820746F206C6F61-
 39975 00008EC1 640D0A             
 39976 00008EC4 202020202020202020-     	db '            the program.  Region1 specifies the number of the first',0Dh,0Ah
 39976 00008ECD 202020746865207072-
 39976 00008ED6 6F6772616D2E202052-
 39976 00008EDF 6567696F6E31207370-
 39976 00008EE8 656369666965732074-
 39976 00008EF1 6865206E756D626572-
 39976 00008EFA 206F66207468652066-
 39976 00008F03 697273740D0A       
 39977                                  MSG_1923:
 39978 00008F09 85                      	db 133
 39979 00008F0A 202020202020202020-     	db '            memory region; minsize1 specifies the minimum size, if',0Dh,0Ah
 39979 00008F13 2020206D656D6F7279-
 39979 00008F1C 20726567696F6E3B20-
 39979 00008F25 6D696E73697A653120-
 39979 00008F2E 737065636966696573-
 39979 00008F37 20746865206D696E69-
 39979 00008F40 6D756D2073697A652C-
 39979 00008F49 2069660D0A         
 39980 00008F4E 202020202020202020-     	db '            any, for region1.  Region2 and minsize2 specify the',0Dh
 39980 00008F57 202020616E792C2066-
 39980 00008F60 6F7220726567696F6E-
 39980 00008F69 312E2020526567696F-
 39980 00008F72 6E3220616E64206D69-
 39980 00008F7B 6E73697A6532207370-
 39980 00008F84 656369667920746865-
 39980 00008F8D 0D                 
 39981 00008F8E 0A                      	db 0Ah
 39982                                  MSG_1924:
 39983 00008F8F 7F                      	db 127
 39984 00008F90 202020202020202020-     	db '            number and minimum size of the second region, if any.',0Dh,0Ah
 39984 00008F99 2020206E756D626572-
 39984 00008FA2 20616E64206D696E69-
 39984 00008FAB 6D756D2073697A6520-
 39984 00008FB4 6F6620746865207365-
 39984 00008FBD 636F6E642072656769-
 39984 00008FC6 6F6E2C20696620616E-
 39984 00008FCF 792E0D0A           
 39985 00008FD3 202020202020202020-     	db '            You can specify as many regions as you want.',0Dh,0Ah
 39985 00008FDC 202020596F75206361-
 39985 00008FE5 6E2073706563696679-
 39985 00008FEE 206173206D616E7920-
 39985 00008FF7 726567696F6E732061-
 39985 00009000 7320796F752077616E-
 39985 00009009 742E0D0A           
 39986 0000900D 0D0A                    	db 0Dh,0Ah
 39987                                  MSG_1925:
 39988 0000900F 83                      	db 131
 39989 00009010 2F5320202020202020-     	db '/S          Shrinks a UMB to its minimum size while the program',0Dh,0Ah
 39989 00009019 202020536872696E6B-
 39989 00009022 73206120554D422074-
 39989 0000902B 6F20697473206D696E-
 39989 00009034 696D756D2073697A65-
 39989 0000903D 207768696C65207468-
 39989 00009046 652070726F6772616D-
 39989 0000904F 0D0A               
 39990 00009051 202020202020202020-     	db '            is loading.  /S is normally used only by MemMaker.',0Dh,0Ah
 39990 0000905A 2020206973206C6F61-
 39990 00009063 64696E672E20202F53-
 39990 0000906C 206973206E6F726D61-
 39990 00009075 6C6C79207573656420-
 39990 0000907E 6F6E6C79206279204D-
 39990 00009087 656D4D616B65722E0D-
 39990 00009090 0A                 
 39991 00009091 0D0A                    	db 0Dh,0Ah
 39992                                  MSG_1926:
 39993 00009093 57                      	db 87
 39994 00009094 5B64726976653A5D5B-     	db '[drive:][path]filename',0Dh,0Ah
 39994 0000909D 706174685D66696C65-
 39994 000090A6 6E616D650D0A       
 39995 000090AC 202020202020202020-     	db '            Specifies the location and name of the program.',0Dh,0Ah
 39995 000090B5 202020537065636966-
 39995 000090BE 69657320746865206C-
 39995 000090C7 6F636174696F6E2061-
 39995 000090D0 6E64206E616D65206F-
 39995 000090D9 66207468652070726F-
 39995 000090E2 6772616D2E0D0A     
 39996 000090E9 0D0A                    	db 0Dh,0Ah
 39997                                  
 39998                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 39999                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:963Ah
 40000                                  MSG_1927:
 40001 000090EB 5A                      	db 90
 40002 000090EC 706172616D65746572-     	db 'parameters  Specifies any command-line information required by',0Dh,0Ah
 40002 000090F5 732020537065636966-
 40002 000090FE 69657320616E792063-
 40002 00009107 6F6D6D616E642D6C69-
 40002 00009110 6E6520696E666F726D-
 40002 00009119 6174696F6E20726571-
 40002 00009122 75697265642062790D-
 40002 0000912B 0A                 
 40003 0000912C 202020202020202020-     	db '            the program.',0Dh,0Ah
 40003 00009135 202020746865207072-
 40003 0000913E 6F6772616D2E0D0A   
 40004                                  
 40005                                  ; ---------------------------------------------------------------------------
 40006                                  
 40007                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40008                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h
 40009                                  
 40010                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 40011                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9695h
 40012                                  
 40013                                  ; --------------- S U B R O U T I N E ---------------------------------------
 40014                                  
 40015                                  $M_CLS_3:
 40016 00009146 0E                      	push	cs		; CLASS_F
 40017 00009147 07                      	pop	es
 40018 00009148 8D3E[E163]              	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
 40019                                  	; 15/04/2023
 40020                                  	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
 40021                                  	; 17/06/2023
 40022                                  	;add	cx,11627	; ADD CX,$-$M_CLASS_3_STRUC ; 969Bh-6930h
 40023                                  	; 06/08/2024
 40024 0000914C 81C16B2D                	add	cx,$-$M_CLASS_3_STRUC
 40025 00009150 C3                      	retn
 40026                                  
 40027                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40028                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh
 40029                                  
 40030                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 40031                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:96A0h
 40032                                  
 40033                                  ; ---------------------------------------------------------------------------
 40034                                  ; Class 1 messages
 40035                                  ; ---------------------------------------------------------------------------
 40036                                  	
 40037                                  $M_CLASS_1_STRUC:
 40038 00009151 01                      	db 1			; $M_CLASS_ID
 40039                                  	;dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 40040                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 40041 00009152 0616                    	dw 1606h  ; MSDOS 6.22 COMMAND.COM
 40042 00009154 04                      	db 4			; Class_1_MessageCount
 40043                                  $M_ID_1_1:
 40044 00009155 0200                    	dw 2			; Message Number = 2
 40045 00009157 1000                    	dw EXTEND2-$+2 ; 10h	; Message offset from message number
 40046                                  $M_ID_1_2:
 40047 00009159 0300                    	dw 3			; Message Number = 3
 40048 0000915B 1B00                    	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
 40049                                  $M_ID_1_3:
 40050 0000915D 0800                    	dw 8			; Message Number = 8
 40051 0000915F 2600                    	dw EXTEND8-$+2 ; 26h	; Message offset from message number
 40052                                  $M_ID_1_4:
 40053 00009161 FFFF                    	dw 0FFFFh		; Message Number = -1
 40054 00009163 3600                    	dw EXTEND999-$+2 ; 36h	; Message offset from message number
 40055                                  
 40056                                  ; ---------------------------------------------------------------------------
 40057                                  
 40058                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
 40059                                  EXTEND2:
 40060 00009165 0E                      	db 14
 40061 00009166 46696C65206E6F7420-     	db 'File not found'
 40061 0000916F 666F756E64         
 40062                                  EXTEND3:
 40063 00009174 0E                      	db 14
 40064 00009175 50617468206E6F7420-     	db 'Path not found'
 40064 0000917E 666F756E64         
 40065                                  EXTEND8:
 40066 00009183 13                      	db 19
 40067 00009184 496E73756666696369-     	db 'Insufficient memory'
 40067 0000918D 656E74206D656D6F72-
 40067 00009196 79                 
 40068                                  EXTEND999:
 40069 00009197 11                      	db 17
 40070 00009198 457874656E64656420-     	db 'Extended Error %1'
 40070 000091A1 4572726F72202531   
 40071                                  
 40072                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40073                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h
 40074                                  
 40075                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 40076                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:96F8h
 40077                                  
 40078                                  ; --------------- S U B R O U T I N E ---------------------------------------
 40079                                  $M_MSGSERV_1:
 40080 000091A9 0E                      	push	cs
 40081 000091AA 07                      	pop	es
 40082 000091AB 8D3E[5191]              	lea	di,$M_CLASS_1_STRUC
 40083                                  	; 15/04/2023
 40084                                  	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
 40085                                  			; 17/06/2023 MSDOS 6.22 COMMAND.COM
 40086                                  				; 96FEh-96A0h = 5Eh = 94
 40087 000091AF C3                      	retn
 40088                                  
 40089                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40090                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h
 40091                                  
 40092                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 40093                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9702h
 40094                                  
 40095                                  ; ---------------------------------------------------------------------------
 40096                                  ; Class 2 messages
 40097                                  ; ---------------------------------------------------------------------------
 40098                                  	
 40099                                  $M_CLASS_2_STRUC:
 40100 000091B0 02                      	db 2			; $M_CLASS_ID
 40101                                  	;dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 40102                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 40103 000091B1 0616                    	dw 1606h  ; MSDOS 6.22 COMMAND.COM
 40104 000091B3 01                      	db 1			; Class_2_MessageCount
 40105                                  $M_ID_2_1:
 40106 000091B4 FFFF                    	dw 0FFFFh		; Message Number = -1
 40107 000091B6 0400                    	dw PARSE999-$+2 ; 4	; Message offset from message number
 40108                                  ; ---------------------------------------------------------------------------
 40109                                  
 40110                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
 40111                                  PARSE999:
 40112 000091B8 0E                      	db 14
 40113 000091B9 506172736520457272-     	db 'Parse Error %1'
 40113 000091C2 6F72202531         
 40114                                  
 40115                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40116                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h
 40117                                  
 40118                                  	; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 40119                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9719h
 40120                                  
 40121                                  ; --------------- S U B R O U T I N E ---------------------------------------
 40122                                  $M_MSGSERV_2:
 40123 000091C7 0E                      	push	cs
 40124 000091C8 07                      	pop	es
 40125 000091C9 8D3E[B091]              	lea	di,$M_CLASS_2_STRUC
 40126                                  	; 15/04/2023
 40127                                  	;add	cx,29		; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
 40128                                  			; 17/06/2023 MSDOS 6.22 COMMAND.COM
 40129                                  				; 971Fh-9702h = 1Dh = 29
 40130 000091CD C3                      	retn
 40131                                  
 40132                                  ;============================================================================
 40133                                  ; TRANMSG.ASM, MSDOS 6.0, 1991
 40134                                  ;============================================================================
 40135                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 40136                                  ; 17/06/2023 - Retro DOS v4.2 COMMAND.COM
 40137                                  
 40138                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h
 40139                                  	
 40140                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9723h
 40141                                  
 40142                                  ;****************************************************
 40143                                  ;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
 40144                                  ;****************************************************
 40145                                  
 40146                                  msg_disp_class:
 40147 000091CE FF                      	db	util_msg_class ; 0FFh
 40148                                  msg_cont_flag:
 40149 000091CF 00                      	db	no_cont_flag ; 0
 40150                                  
 40151                                  ;  extended error string output
 40152                                  extend_buf_ptr:
 40153 000091D0 0000                    	dw	0			;AN000;set to no message
 40154                                  extend_buf_sub:
 40155 000091D2 00                      	db	0			;AN000;set to no substitutions
 40156 000091D3 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40157 000091D4 00                      	db	0			;AN000;reserved
 40158                                  extend_buf_off:
 40159 000091D5 [91A0]                  	dw	string_ptr_2		;AN000;offset of arg
 40160                                  extend_buf_seg:
 40161 000091D7 0000                    	dw	0			;AN000;segment of arg
 40162 000091D9 00                      	db	0			;AN000;first subst
 40163 000091DA 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40164 000091DB 80                      	db	128			;AN000;maximum width
 40165 000091DC 00                      	db	0			;AN000;minimum width
 40166 000091DD 20                      	db	blank ; 20h		;AN000;pad character
 40167                                  
 40168                                  ;  "Duplicate file name or file not found"
 40169                                  RENERR_PTR:
 40170 000091DE EA03                    	dw	1002			;AN000;message number
 40171 000091E0 00                      	db	no_subst ; 0		;AN000;number of subst
 40172                                  
 40173                                  ;  "Invalid path or file name"
 40174                                  BADCPMES_PTR:
 40175 000091E1 EB03                    	dw	1003			;AN000;message number
 40176 000091E3 00                      	db	no_subst ; 0		;AN000;number of subst
 40177                                  
 40178                                  ;  "Insufficient disk space"
 40179                                  NOSPACE_PTR:
 40180 000091E4 EC03                    	dw	1004			;AN000;message number
 40181 000091E6 00                      	db	no_subst ; 0		;AN000;number of subst
 40182                                  
 40183                                  ;  "Out of environment space"
 40184                                  ENVERR_PTR:
 40185 000091E7 EF03                    	dw	1007			;AN000;message number
 40186 000091E9 00                      	db	no_subst ; 0		;AN000;number of subst
 40187                                  
 40188                                  ;  "File creation error"
 40189                                  FULLDIR_PTR:
 40190 000091EA F003                    	dw	1008			;AN000;message number
 40191 000091EC 00                      	db	no_subst ; 0		;AN000;number of subst
 40192                                  
 40193                                  ;  "Batch file missing",13,10
 40194                                  BADBAT_PTR:
 40195 000091ED F103                    	dw	1009			;AN000;message number
 40196 000091EF 00                      	db	no_subst ; 0		;AN000;number of subst
 40197                                  
 40198                                  ;  "Insert disk with batch file",13,10
 40199                                  NEEDBAT_PTR:
 40200 000091F0 F203                    	dw	1010			;AN000;message number
 40201 000091F2 00                      	db	no_subst ; 0		;AN000;number of subst
 40202                                  
 40203                                  ;  "Bad command or file name",13,10
 40204                                  BADNAM_PTR:
 40205 000091F3 F303                    	dw	1011			;AN000;message number
 40206 000091F5 00                      	db	no_subst ; 0		;AN000;number of subst
 40207                                  
 40208                                  ;  "Access denied",13,10
 40209                                  ACCDEN_PTR:
 40210 000091F6 F603                    	dw	1014			;AN000;message number
 40211 000091F8 00                      	db	no_subst ; 0		;AN000;number of subst
 40212                                  
 40213                                  ;  "File cannot be copied onto itself",13,10
 40214                                  OVERWR_PTR:
 40215 000091F9 F703                    	dw	1015			;AN000;message number
 40216 000091FB 00                      	db	no_subst ; 0		;AN000;number of subst
 40217                                  
 40218                                  ;  "Content of destination lost before copy",13,10
 40219                                  LOSTERR_PTR:
 40220 000091FC F803                    	dw	1016			;AN000;message number
 40221 000091FE 00                      	db	no_subst ; 0		;AN000;number of subst
 40222                                  
 40223                                  ;  "Invalid filename or file not found",13,10
 40224                                  INORNOT_PTR:
 40225 000091FF F903                    	dw	1017			;AN000;message number
 40226 00009201 00                      	db	no_subst		;AN000;number of subst
 40227                                  
 40228                                  ;  "%1 File(s) copied",13,10
 40229                                  copied_ptr:
 40230 00009202 FA03                    	dw	1018			;AN000;message number
 40231 00009204 01                      	db	1			;AN000;number of subst
 40232 00009205 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40233 00009206 00                      	db	0			;AN000;reserved
 40234 00009207 [93A0]                  	dw	Copy_num		;AN000;offset of arg
 40235 00009209 0000                    	dw	0			;AN000;segment of arg
 40236 0000920B 01                      	db	1			;AN000;first subst
 40237 0000920C A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40238                                  					;AN000;binary to decimal
 40239 0000920D 09                      	db	9			;AN000;maximum width
 40240 0000920E 09                      	db	9			;AN000;minimum width
 40241 0000920F 20                      	db	blank ; 20h		;AN000;pad character
 40242                                  
 40243                                  ;  "%1 File(s) "
 40244                                  dirmes_ptr:
 40245 00009210 FB03                    	dw	1019			;AN000;message number
 40246 00009212 01                      	db	1			;AN000;number of subst
 40247 00009213 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40248 00009214 00                      	db	0			;AN000;reserved
 40249 00009215 [96A0]                  	dw	Dir_Num			;AN000;offset of arg
 40250 00009217 0000                    	dw	0			;AN000;segment of arg
 40251 00009219 01                      	db	1			;AN000;first subst
 40252                                  	; MSDOS 5.0 COMMAND.COM
 40253                                  	;db	0A1h ; Right_Align+Unsgn_Bin_Word
 40254                                  	; 17/06/2023
 40255                                  screen_f_3:
 40256 0000921A E1                      	db	0E1h ; MSDOS 6.22 COMMAND.COM
 40257                                  					;AN000;binary to decimal
 40258 0000921B 09                      	db	9			;AN000;maximum width
 40259 0000921C 09                      	db	9			;AN000;minimum width
 40260 0000921D 20                      	db	blank ; 20h		;AN000;pad character
 40261                                  
 40262                                  ;  "%1 bytes free",13,10
 40263                                  bytmes_ptr:
 40264 0000921E FC03                    	dw	1020			;AN000;message number
 40265 00009220 01                      	db	1			;AN000;number of subst
 40266 00009221 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40267 00009222 00                      	db	0			;AN000;reserved
 40268 00009223 [9AA0]                  	dw	Bytes_Free		;AN000;offset of arg
 40269 00009225 0000                    	dw	0			;AN000;segment of arg
 40270 00009227 01                      	db	1			;AN000;first subst
 40271                                  	; MSDOS 5.0 COMMAND.COM
 40272                                  	;db	0B1h ; Right_Align+Unsgn_Bin_DWord
 40273                                  	; 17/06/2023
 40274                                  screen_f_6:
 40275 00009228 F1                      	db	0F1h
 40276                                  					;AN000;long binary to decimal
 40277                                  	; MSDOS 5.0 COMMAND.COM
 40278                                  	;db	28			;AN000;maximum width
 40279                                  	;db	28			;AN000;minimum width
 40280                                  	; 17/06/2023
 40281                                  screen_f_7:
 40282 00009229 20                      	db	32 ; MSDOS 6.22 COMMAND.COM
 40283 0000922A 20                      	db	32
 40284                                  
 40285 0000922B 20                      	db	blank ; 20h		;AN000;pad character
 40286                                  
 40287                                  ;  "Invalid drive specification",13,10
 40288                                  baddrv_ptr:
 40289 0000922C FD03                    	dw	1021			;AN000;message number
 40290 0000922E 00                      	db	no_subst ; 0		;AN000;number of subst
 40291                                  
 40292                                  ;  "Code page %1 not prepared for system",13,10
 40293                                  cp_not_set_ptr:
 40294 0000922F FE03                    	dw	1022			;AN000;message number
 40295 00009231 01                      	db	1			;AN000;number of subst
 40296 00009232 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40297 00009233 00                      	db	0			;AN000;reserved
 40298 00009234 [8BA0]                  	dw	system_cpage		;AN000;offset of arg
 40299 00009236 0000                    	dw	0			;AN000;segment of arg
 40300 00009238 01                      	db	1			;AN000;first subst
 40301 00009239 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40302                                  					;AN000;binary to decimal
 40303 0000923A 05                      	db	5			;AN000;maximum width
 40304 0000923B 01                      	db	1			;AN000;minimum width
 40305 0000923C 20                      	db	blank ; 20h		;AN000;pad character
 40306                                  
 40307                                  ;  "Code page %1 not prepared for all devices",13,10
 40308                                  cp_not_all_ptr:
 40309 0000923D FF03                    	dw	1023			;AN000;message number
 40310 0000923F 01                      	db	1			;AN000;number of subst
 40311 00009240 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40312 00009241 00                      	db	0			;AN000;reserved
 40313 00009242 [8BA0]                  	dw	system_cpage		;AN000;offset of arg
 40314 00009244 0000                    	dw	0			;AN000;segment of arg
 40315 00009246 01                      	db	1			;AN000;first subst
 40316 00009247 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40317                                  					;AN000;binary to decimal
 40318 00009248 05                      	db	5			;AN000;maximum width
 40319 00009249 01                      	db	1			;AN000;minimum width
 40320 0000924A 20                      	db	blank ; 20h		;AN000;pad character
 40321                                  
 40322                                  ;  "Active code page: %1",13,10
 40323                                  cp_active_ptr:
 40324 0000924B 0004                    	dw	1024			;AN000;message number
 40325 0000924D 01                      	db	1			;AN000;number of subst
 40326 0000924E 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40327 0000924F 00                      	db	0			;AN000;reserved
 40328 00009250 [8BA0]                  	dw	system_cpage		;AN000;offset of arg
 40329 00009252 0000                    	dw	0			;AN000;segment of arg
 40330 00009254 01                      	db	1			;AN000;first subst
 40331 00009255 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40332                                  					;AN000;binary to decimal
 40333 00009256 05                      	db	5			;AN000;maximum width
 40334 00009257 01                      	db	1			;AN000;minimum width
 40335 00009258 20                      	db	blank ; 20h		;AN000;pad character
 40336                                  
 40337                                  ;  "NLSFUNC not installed",13,10
 40338                                  NLSFUNC_PTR:
 40339 00009259 0104                    	dw	1025			;AN000;message number
 40340 0000925B 00                      	db	no_subst ; 0		;AN000;number of subst
 40341                                  
 40342                                  ;  "Invalid code page",13,10
 40343                                  INV_CODE_PAGE:
 40344 0000925C 0204                    	dw	1026			;AN000;message number
 40345 0000925E 00                      	db	no_subst ; 0		;AN000;number of subst
 40346                                  
 40347                                  ;  "Current drive is no longer valid"
 40348                                  BADCURDRV:
 40349 0000925F 0304                    	dw	1027			;AN000;message number
 40350 00009261 00                      	db	no_subst ; 0		;AN000;number of subst
 40351                                  
 40352                                  ;  "Press any key to continue"
 40353                                  PAUSEMES_PTR:
 40354 00009262 0404                    	dw	1028			;AN000;message number
 40355 00009264 00                      	db	no_subst ; 0		;AN000;number of subst
 40356                                  
 40357                                  ;  "Label not found",13,10
 40358                                  BADLAB_PTR:
 40359 00009265 0504                    	dw	1029			;AN000;message number
 40360 00009267 00                      	db	no_subst ; 0		;AN000;number of subst
 40361                                  
 40362                                  ;  "Syntax error",13,10
 40363                                  SYNTMES_PTR:
 40364 00009268 0604                    	dw	1030			;AN000;message number
 40365 0000926A 00                      	db	no_subst ; 0		;AN000;number of subst
 40366                                  
 40367                                  ;  "Invalid date",13,10
 40368                                  BADDAT_PTR:
 40369 0000926B 0704                    	dw	1031			;AN000;message number
 40370 0000926D 00                      	db	no_subst ; 0		;AN000;number of subst
 40371                                  
 40372                                  ;  "Current date is %1 %2",13,10
 40373                                  CurDat_Ptr:
 40374 0000926E 0804                    	dw	1032			;AN000;message number
 40375 00009270 02                      	db	2			;AN000;number of subst
 40376 00009271 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40377 00009272 00                      	db	0			;AN000;reserved
 40378 00009273 [87A7]                  	dw	Arg_Buf			;AN000;offset of arg
 40379 00009275 0000                    	dw	0			;AN000;segment of arg
 40380 00009277 01                      	db	1			;AN000;first subst
 40381 00009278 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40382 00009279 03                      	db	3			;AN000;maximum width
 40383 0000927A 03                      	db	3			;AN000;minimum width
 40384 0000927B 20                       	db	blank ; 20h		;AN000;pad character
 40385 0000927C 0B                      	db	parm_block_size 	;AN000;size of sublist
 40386 0000927D 00                      	db	0			;AN000;reserved
 40387                                  CurDat_yr:
 40388 0000927E 0000                    	dw	0			;AN000;year
 40389                                  CurDat_mo_day:
 40390 00009280 0000                    	dw	0			;AN000;month,day
 40391 00009282 02                      	db	2			;AN000;second subst
 40392 00009283 34                      	db	34h ; DATE_MDY_4	;AN000;date
 40393 00009284 0A                      	db	10			;AN000;maximum width
 40394 00009285 0A                      	db	10			;AN000;minimum width
 40395 00009286 20                      	db	blank ; 20h		;AN000;pad character
 40396                                  
 40397                                  ;  "SunMonTueWedThuFriSat"
 40398                                  WeekTab:
 40399 00009287 0904                    	dw	1033			;AN000;message number
 40400 00009289 00                      	db	no_subst ; 0		;AN000;number of subst
 40401                                  
 40402                                  ;  "Enter new date (%1):"
 40403                                  
 40404                                  NewDat_Ptr:
 40405 0000928A 0A04                    	dw	1034			;AN000;message number
 40406 0000928C 01                      	db	1			;AN000;number of subst
 40407 0000928D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40408 0000928E 00                      	db	0			;AN000;reserved
 40409                                  NewDat_Format:
 40410 0000928F 0000                    	dw	0			;AN000;offset of replacement
 40411 00009291 0000                    	dw	0			;AN000;segment of arg
 40412 00009293 01                      	db	1			;AN000;first subst
 40413 00009294 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40414 00009295 08                      	db	8			;AN000;maximum width
 40415 00009296 08                      	db	8			;AN000;minimum width
 40416 00009297 20                      	db	blank ; 20h		;AN000;pad character
 40417                                  
 40418                                  ;  "Invalid time",13,10
 40419                                  
 40420                                  BadTim_Ptr:
 40421 00009298 0B04                    	dw	1035			;AN000;message number
 40422 0000929A 00                      	db	no_subst ; 0		;AN000;number of subst
 40423                                  
 40424                                  ;  "Current time is %1",13,10
 40425                                  CurTim_Ptr:
 40426 0000929B 0C04                    	dw	1036			;AN000;message number
 40427 0000929D 01                      	db	1			;AN000;number of subst
 40428 0000929E 0B                      	db	parm_block_size 	;AN000;size of sublist
 40429 0000929F 00                      	db	0			;AN000;reserved
 40430                                  CurTim_hr_min:
 40431 000092A0 0000                    	dw	0			;AN000;hours,minutes
 40432                                  CurTim_Sec_hn:
 40433 000092A2 0000                    	dw	0			;AN000;seconds,hundredths
 40434 000092A4 01                      	db	1			;AN000;first subst
 40435 000092A5 A5                      	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
 40436                                  					;AC059;time
 40437 000092A6 0C                      	db	12			;AC059;maximum width
 40438 000092A7 0C                      	db	12			;AC059;minimum width
 40439 000092A8 20                      	db	blank ; 20h		;AN000;pad character
 40440                                  
 40441                                  ;  "Enter new time:"
 40442                                  NewTim_Ptr:
 40443 000092A9 0D04                    	dw	1037			;AN000;message number
 40444 000092AB 00                      	db	no_subst ; 0		;AN000;number of subst
 40445                                  
 40446                                  ;  ",    Delete (Y/N)?",13,10
 40447                                  Del_Y_N_Ptr:
 40448 000092AC 0E04                    	dw	1038			;AN000;message number
 40449 000092AE 00                      	db	no_subst ; 0		;AN000;number of subst
 40450                                  
 40451                                  ;  "All files in directory will be deleted!",13,10
 40452                                  ;  "Are you sure (Y/N)?",13,10
 40453                                  SureMes_Ptr:
 40454 000092AF 0F04                    	dw	1039			;AN000;message number
 40455 000092B1 00                      	db	no_subst ; 0		;AN000;number of subst
 40456                                  
 40457                                  ;  "Microsoft DOS Version %1.%2",13,10
 40458                                  VerMes_Ptr:
 40459 000092B2 1004                    	dw	1040			;AN000;message number
 40460 000092B4 02                      	db	2			;AN000;number of subst
 40461 000092B5 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40462 000092B6 00                      	db	0			;AN000;reserved
 40463 000092B7 [9EA0]                  	dw	Major_Ver_Num		;AN000;offset of arg
 40464 000092B9 0000                    	dw	0			;AN000;segment of arg
 40465 000092BB 01                      	db	1			;AN000;first subst
 40466 000092BC A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40467                                  					;AN000;binary to decimal
 40468 000092BD 01                      	db	1			;AN000;maximum width
 40469 000092BE 01                      	db	1			;AN000;minimum width
 40470 000092BF 20                      	db	blank ; 20h		;AN000;pad character
 40471 000092C0 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40472 000092C1 00                      	db	0			;AN000;reserved
 40473 000092C2 [A0A0]                  	dw	Minor_Ver_Num	;AN000;offset of arg
 40474 000092C4 0000                    	dw	0			;AN000;segment of arg
 40475 000092C6 02                      	db	2			;AN000;second subst
 40476 000092C7 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 40477                                  					;AN000;binary to decimal
 40478 000092C8 02                      	db	2			;AN000;maximum width
 40479 000092C9 02                      	db	2			;AN000;minimum width
 40480 000092CA 30                      	db	'0' ; 30h		;AN000;pad character
 40481                                  
 40482                                  ;  "Volume in drive %1 has no label",13,10
 40483                                  VolMes_Ptr_2:
 40484 000092CB 1104                    	dw	1041			;AN000;message number
 40485 000092CD 01                      	db	1			;AN000;number of subst
 40486 000092CE 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 40487 000092CF 00                      	db	0			;AN000;reserved
 40488 000092D0 [A4A0]                  	dw	vol_drv			;AN000;offset of drive
 40489 000092D2 0000                    	dw	0			;AN000;segment of arg
 40490 000092D4 01                      	db	1			;AN000;first subst
 40491 000092D5 00                      	db	0 ; Char_field_Char 	;AN000;character
 40492 000092D6 80                      	db	128			;AN000;maximum width
 40493 000092D7 01                      	db	1			;AN000;minimum width
 40494 000092D8 20                      	db	blank ; 20h		;AN000;pad character
 40495                                  
 40496                                  ;  "Volume in drive %1 is %2",13,10
 40497                                  VolMes_Ptr:
 40498 000092D9 1204                    	dw	1042			;AN000;message number
 40499 000092DB 02                      	db	2			;AN000;number of subst
 40500 000092DC 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40501 000092DD 00                      	db	0			;AN000;reserved
 40502 000092DE [A4A0]                  	dw	vol_drv			;AN000;offset of drive
 40503 000092E0 0000                    	dw	0			;AN000;segment of arg
 40504 000092E2 01                      	db	1			;AN000;first subst
 40505 000092E3 00                      	db	00000000b		;AN000;character
 40506 000092E4 80                      	db	128			;AN000;maximum width
 40507 000092E5 01                      	db	1			;AN000;minimum width
 40508 000092E6 20                      	db	blank ; 20h		;AN000;pad character
 40509 000092E7 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40510 000092E8 00                      	db	0			;AN000;reserved
 40511 000092E9 [5B9F]                  	dw	CHARBUF			;AN000;offset of string
 40512 000092EB 0000                    	dw	0			;AN000;segment of arg
 40513 000092ED 02                      	db	2			;AN000;second subst
 40514 000092EE 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40515 000092EF 80                      	db	128			;AN000;maximum width
 40516 000092F0 01                      	db	1			;AN000;minimum width
 40517 000092F1 20                      	db	blank ; 20h		;AN000;pad character
 40518                                  
 40519                                  ;  "Volume Serial Number is %1-%2",13,10
 40520                                  VolSerMes_Ptr:
 40521 000092F2 1304                    	dw	1043			;AN000;message number
 40522 000092F4 02                      	db	2			;AN000;number of subst
 40523 000092F5 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 40524 000092F6 00                      	db	0			;AN000;reserved
 40525 000092F7 [0EA2]                  	dw	vol_serial+2		;AN000;offset of serial
 40526 000092F9 0000                    	dw	0			;AN000;segment of arg
 40527 000092FB 01                      	db	1			;AN000;first subst
 40528 000092FC A3                      	db	0A3h ; Right_Align+Bin_Hex_Word 
 40529                                  					;AN000;binary to hex
 40530 000092FD 04                      	db	4			;AN000;maximum width
 40531 000092FE 04                      	db	4			;AN000;minimum width
 40532 000092FF 30                      	db	'0' ; 30h		;AN000;pad character
 40533 00009300 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40534 00009301 00                      	db	0			;AN000;reserved
 40535 00009302 [0CA2]                  	dw	vol_serial		;AN000;offset of serial
 40536 00009304 0000                    	dw	0			;AN000;segment of arg
 40537 00009306 02                      	db	2			;AN000;second subst
 40538 00009307 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word
 40539                                  					;AN000;binary to hex
 40540 00009308 04                      	db	4			;AN000;maximum width
 40541 00009309 04                      	db	4			;AN000;minimum width
 40542 0000930A 30                      	db	'0' ; 30h		;AN000;pad character
 40543                                  
 40544                                  ;  "Invalid directory",13,10
 40545                                  badcd_ptr:
 40546 0000930B 1404                    	dw	1044			;AN000;message number
 40547 0000930D 00                      	db	no_subst ; 0		;AN000;number of subst
 40548                                  
 40549                                  ;  "Unable to create directory",13,10
 40550                                  badmkd_ptr:
 40551 0000930E 1504                    	dw	1045			;AN000;message number
 40552 00009310 00                      	db	no_subst ; 0		;AN000;number of subst
 40553                                  
 40554                                  ;  "Invalid path, not directory,",13,10
 40555                                  ;  "or directory not empty",13,10
 40556                                  badrmd_ptr:
 40557 00009311 1604                    	dw	1046			;AN000;message number
 40558 00009313 00                      	db	no_subst ; 0		;AN000;number of subst
 40559                                  
 40560                                  ;  "Must specify ON or OFF",13,10
 40561                                  bad_on_off_ptr:
 40562 00009314 1704                    	dw	1047			;AN000;message number
 40563 00009316 00                      	db	no_subst ; 0		;AN000;number of subst
 40564                                  
 40565                                  ;  "Directory of %1",13,10
 40566                                  dirhead_ptr:
 40567 00009317 1804                    	dw	1048			;AN000;message number
 40568 00009319 01                      	db	1			;AN000;number of subst
 40569 0000931A 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40570 0000931B 00                      	db	0			;AN000;reserved
 40571 0000931C [2AA0]                  	dw	BWDBUF			;AN000;offset of arg
 40572 0000931E 0000                    	dw	0			;AN000;segment of arg
 40573 00009320 01                      	db	1			;AN000;first subst
 40574 00009321 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40575 00009322 80                      	db	128			;AN000;maximum width
 40576 00009323 00                      	db	0			;AN000;minimum width
 40577 00009324 20                      	db	blank ; 20h		;AN000;pad character
 40578                                  
 40579                                  ;  "No Path",13,10
 40580                                  NULLPATH_PTR:
 40581 00009325 1904                    	dw	1049			;AN000;message number
 40582 00009327 00                      	db	no_subst ; 0		;AN000;number of subst
 40583                                  
 40584                                  ;  "Invalid drive in search path",13,10
 40585                                  BADPMES_PTR:
 40586 00009328 1A04                    	dw	1050			;AN000;message number
 40587 0000932A 00                      	db	no_subst ; 0		;AN000;number of subst
 40588                                  
 40589                                  ;  "Invalid device",13,10
 40590                                  BADDEV_PTR:
 40591 0000932B 1B04                    	dw	1051			;AN000;message number
 40592 0000932D 00                      	db	no_subst ; 0		;AN000;number of subst
 40593                                  
 40594                                  ;  "FOR cannot be nested",13,10
 40595                                  FORNESTMES_PTR:
 40596 0000932E 1C04                    	dw	1052			;AN000;message number
 40597 00009330 00                      	db	no_subst ; 0		;AN000;number of subst
 40598                                  
 40599                                  ;  "Intermediate file error during pipe",13,10
 40600                                  PIPEEMES_PTR:
 40601 00009331 1D04                    	dw	1053			;AN000;message number
 40602 00009333 00                      	db	no_subst ; 0		;AN000;number of subst
 40603                                  
 40604                                  ;  "Cannot do binary reads from a device",13,10
 40605                                  INBDEV_PTR:
 40606 00009334 1E04                    	dw	1054			;AN000;message number
 40607 00009336 00                      	db	no_subst ; 0		;AN000;number of subst
 40608                                  
 40609                                  ;  "BREAK is %1",13,10
 40610                                  CtrlcMes_Ptr:
 40611 00009337 1F04                    	dw	1055			;AN000;message number
 40612 00009339 01                      	db	1			;AN000;number of subst
 40613 0000933A 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40614 0000933B 00                      	db	0			;AN000;reserved
 40615 0000933C 0000                    	dw	0			;AN000;offset of on/off (new)
 40616 0000933E 0000                    	dw	0			;AN000;segment of arg
 40617 00009340 01                      	db	1			;AN000;first subst
 40618 00009341 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40619 00009342 80                      	db	128			;AN000;maximum width
 40620 00009343 01                      	db	1			;AN000;minimum width
 40621 00009344 20                      	db	blank ; 20h		;AN000;pad character
 40622                                  
 40623                                  ;  "VERIFY is %1",13,10
 40624                                  VeriMes_Ptr:
 40625 00009345 2004                    	dw	1056			;AN000;message number
 40626 00009347 01                      	db	1			;AN000;number of subst
 40627 00009348 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40628 00009349 00                      	db	0			;AN000;reserved
 40629 0000934A 0000                    	dw	0			;AN000;offset of on/off (new)
 40630 0000934C 0000                    	dw	0			;AN000;segment of arg
 40631 0000934E 01                      	db	1			;AN000;first subst
 40632 0000934F 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40633 00009350 80                      	db	128			;AN000;maximum width
 40634 00009351 01                      	db	1			;AN000;minimum width
 40635 00009352 20                      	db	blank ; 20h		;AN000;pad character
 40636                                  
 40637                                  ;  "ECHO is %1",13,10
 40638                                  EchoMes_Ptr:
 40639 00009353 2104                    	dw	1057			;AN000;message number
 40640 00009355 01                      	db	1			;AN000;number of subst
 40641 00009356 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40642 00009357 00                      	db	0			;AN000;reserved
 40643 00009358 0000                    	dw	0			;AN000;offset of on/off (new)
 40644 0000935A 0000                    	dw	0			;AN000;segment of arg
 40645 0000935C 01                      	db	1			;AN000;first subst
 40646 0000935D 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40647 0000935E 80                      	db	128			;AN000;maximum width
 40648 0000935F 01                      	db	1			;AN000;minimum width
 40649 00009360 20                      	db	blank ; 20h		;AN000;pad character
 40650                                  
 40651                                  ;  "off"
 40652                                  OFFMES_PTR:
 40653 00009361 2304                    	dw	1059			;AN000;message number
 40654 00009363 00                      	db	no_subst		;AN000;number of subst
 40655                                  
 40656                                  ;  "on"
 40657                                  ONMES_PTR:
 40658 00009364 2404                    	dw	1060			;AN000;message number
 40659 00009366 00                      	db	no_subst ; 0		;AN000;number of subst
 40660                                  
 40661                                  ;  "Error writing to device",13,10
 40662                                  DEVWMES_PTR:
 40663 00009367 2504                    	dw	1061			;AN000;message number
 40664 00009369 00                      	db	no_subst ; 0		;AN000;number of subst
 40665                                  
 40666                                  ;  "Invalid path",13,10
 40667                                  INVAL_PATH_PTR:
 40668 0000936A 2604                    	dw	1062			;AN000;message number
 40669 0000936C 00                      	db	no_subst ; 0		;AN000;number of subst
 40670                                  
 40671                                  ;  unformatted string output
 40672                                  arg_buf_ptr:
 40673 0000936D 2704                    	dw	1063			;AN000;message number
 40674 0000936F 01                      	db	1			;AN000;number of subst
 40675 00009370 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40676 00009371 00                      	db	0			;AN000;reserved
 40677 00009372 [87A7]                  	dw	Arg_Buf 		;AN000;offset of arg
 40678 00009374 0000                    	dw	0			;AN000;segment of arg
 40679 00009376 01                      	db	1			;AN000;first subst
 40680 00009377 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40681 00009378 80                      	db	128			;AN000;maximum width
 40682 00009379 00                      	db	0			;AN000;minimum width
 40683 0000937A 20                      	db	blank ; 20h		;AN000;pad character
 40684                                  
 40685                                  ;  file name output
 40686                                  file_name_ptr:
 40687 0000937B 2804                    	dw	1064			;AN000;message number
 40688 0000937D 01                      	db	1			;AN000;number of subst
 40689 0000937E 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40690 0000937F 00                      	db	0			;AN000;reserved
 40691 00009380 [12A1]                  	dw	SrcBuf			;AN000;offset of arg
 40692 00009382 0000                    	dw	0			;AN000;segment of arg
 40693 00009384 01                      	db	1			;AN000;first subst
 40694 00009385 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40695 00009386 80                      	db	128			;AN000;maximum width
 40696 00009387 00                      	db	0			;AN000;minimum width
 40697 00009388 20                      	db	blank ; 20h		;AN000;pad character
 40698                                  
 40699                                  ;  file size output for dir
 40700                                  disp_file_size_ptr:
 40701 00009389 2904                    	dw	1065			;AN000;message number
 40702 0000938B 01                      	db	1			;AN000;number of subst
 40703 0000938C 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 40704 0000938D 00                      	db	0			;AN000;reserved
 40705 0000938E [8DA0]                  	dw	File_Size_Low		;AN000;offset of arg
 40706 00009390 0000                    	dw	0			;AN000;segment of arg
 40707 00009392 01                      	db	1			;AN000;first subst
 40708                                  	; MSDOS 5.0 COMMAND.COM
 40709                                  	;db	0B1h ; Right_Align+Unsgn_Bin_DWord
 40710                                  	; 17/06/2023
 40711                                  screen_f_1:
 40712 00009393 F1                      	db	0F1h ; MSDOS 6.22 COMMAND.COM
 40713                                  					;AN000;long binary to decimal
 40714                                  	; MSDOS 5.0 COMMAND.COM
 40715                                  	;db	10			;AN000;maximum width
 40716                                  	;db	10			;AN000;minimum width
 40717                                  screen_f_2:
 40718 00009394 0E                      	db	14 ; MSDOS 6.22 COMMAND.COM		
 40719 00009395 0E                      	db	14
 40720                                  	
 40721 00009396 20                      	db	blank ; 20h		;AN000;pad character
 40722                                  
 40723                                  ;  unformatted string output
 40724                                  ; %s
 40725                                  string_buf_ptr:
 40726 00009397 2A04                    	dw	1066			;AN000;message number
 40727 00009399 01                      	db	1			;AN000;number of subst
 40728 0000939A 0B                      	db	parm_block_size 	;AN000;size of sublist
 40729 0000939B 00                      	db	0			;AN000;reserved
 40730 0000939C [91A0]                  	dw	string_ptr_2		;AN000;offset of arg
 40731 0000939E 0000                    	dw	0			;AN000;segment of arg
 40732 000093A0 01                      	db	1			;AN000;first subst
 40733 000093A1 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40734 000093A2 80                      	db	128			;AN000;maximum width
 40735 000093A3 00                      	db	0			;AN000;minimum width
 40736 000093A4 20                      	db	blank ; 20h		;AN000;pad character
 40737 000093A5 00                      	db	0			;AN000;
 40738                                  
 40739                                  ;  tab character
 40740                                  tab_ptr:
 40741 000093A6 2B04                    	dw	1067			;AN000;message number
 40742 000093A8 00                      	db	no_subst ; 0		;AN000;number of subst
 40743                                  
 40744                                  ;  " <DIR>   "
 40745                                  dmes_ptr:
 40746 000093A9 2C04                    	dw	1068			;AN000;message number
 40747 000093AB 00                      	db	no_subst ; 0		;AN000;number of subst
 40748                                  
 40749                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40750                                  space_4_ptr :
 40751 000093AC 5104                    	dw	1105 
 40752 000093AE 00                      	db	no_subst ; 0
 40753                                  
 40754                                  ;  destructive back space
 40755                                  dback_ptr:
 40756 000093AF 2D04                    	dw	1069			;AN000;message number
 40757 000093B1 00                      	db	no_subst ; 0		;AN000;number of subst
 40758                                  
 40759                                  ;  carriage return / line feed
 40760                                  acrlf_ptr:
 40761 000093B2 2E04                    	dw	1070			;AN000;message number
 40762 000093B4 00                      	db	no_subst ; 0		;AN000;number of subst
 40763                                  
 40764                                  ;  "mm-dd-yy"
 40765                                  usadat_ptr:
 40766 000093B5 3004                    	dw	1072			;AN000;message number
 40767 000093B7 00                      	db	no_subst ; 0		;AN000;number of subst
 40768                                  
 40769                                  ;  "dd-mm-yy"
 40770                                  eurdat_ptr:
 40771 000093B8 3104                    	dw	1073			;AN000;message number
 40772 000093BA 00                      	db	no_subst ; 0		;AN000;number of subst
 40773                                  
 40774                                  ;  "yy-mm-dd"
 40775                                  japdat_ptr:
 40776 000093BB 3204                    	dw	1074			;AN000;message number
 40777 000093BD 00                      	db	no_subst ; 0		;AN000;number of subst
 40778                                  
 40779                                  ;  date string for prompt
 40780                                  promptdat_ptr:
 40781 000093BE 3304                    	dw	1075			;AN000;message number
 40782 000093C0 02                      	db	2			;AN000;number of subst
 40783 000093C1 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40784 000093C2 00                      	db	0			;AN000;reserved
 40785 000093C3 [87A7]                  	dw	Arg_Buf			;AN000;offset of arg
 40786 000093C5 0000                    	dw	0			;AN000;segment of arg
 40787 000093C7 01                      	db	1			;AN000;first subst
 40788 000093C8 10                      	db	10h ; Char_field_ASCIIZ ;AN000;character string
 40789 000093C9 03                      	db	3			;AN000;maximum width
 40790 000093CA 03                      	db	3			;AN000;minimum width
 40791 000093CB 20                       	db	blank ; 20h		;AN000;pad character
 40792 000093CC 0B                      	db	parm_block_size  ; 11	;AN000;size of sublist
 40793 000093CD 00                      	db	0			;AN000;reserved
 40794                                  promptDat_yr:
 40795 000093CE 0000                    	dw	0			;AN000;year
 40796                                  promptDat_moday:
 40797 000093D0 0000                    	dw	0			;AN000;month,day
 40798 000093D2 02                      	db	2			;AN000;second subst
 40799 000093D3 34                       	db	34h ; DATE_MDY_4	;AN000;date
 40800 000093D4 0A                      	db	10			;AN000;maximum width
 40801 000093D5 08                      	db	8			;AN000;minimum width
 40802 000093D6 20                      	db	blank ; 20h		;AN000;pad character
 40803                                  
 40804                                  ;  Time for prompt
 40805                                  promtim_ptr:
 40806 000093D7 3404                    	dw	1076			;AN000;message number
 40807 000093D9 01                      	db	1			;AN000;number of subst
 40808 000093DA 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40809 000093DB 00                      	db	0			;AN000;reserved
 40810                                  PromTim_hr_min:
 40811 000093DC 0000                    	dw	0			;AN000;hours,minutes
 40812                                  PromTim_Sec_hn:
 40813 000093DE 0000                    	dw	0			;AN000;seconds,hundredths
 40814 000093E0 01                      	db	1			;AN000;first subst
 40815 000093E1 A6                      	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
 40816                                  					;AC013;time
 40817 000093E2 0B                      	db	11			;AN000;maximum width
 40818 000093E3 0B                      	db	11			;AC013;minimum width
 40819 000093E4 20                      	db	blank ; 20h		;AN000;pad character
 40820                                  
 40821                                  ;  Date and time for DIR
 40822                                  dirdattim_ptr:
 40823 000093E5 3504                    	dw	1077			;AN000;message number
 40824 000093E7 02                      	db	2			;AN000;number of subst
 40825 000093E8 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40826 000093E9 00                      	db	0			;AN000;reserved
 40827                                  DirDat_Yr:
 40828 000093EA 0000                    	dw	0			;AN000;year
 40829                                  DirDat_Mo_Day:
 40830 000093EC 0000                    	dw	0			;AN000;month,day
 40831 000093EE 01                      	db	1			;AN000;first subst
 40832 000093EF A4                      	db	0A4h ; Right_Align+DATE_MDY_2
 40833                                  					;AN000;date
 40834 000093F0 0A                      	db	10			;AN000;maximum width
 40835 000093F1 08                      	db	8			;AN000;minimum width
 40836 000093F2 20                      	db	blank ; 20h		;AN000;pad character
 40837 000093F3 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40838 000093F4 00                      	db	0			;AN000;reserved
 40839                                  DirTim_Hr_Min:
 40840 000093F5 0000                    	dw	0			;AN000;hours,minutes
 40841                                  DirTim_Sec_hn:
 40842 000093F7 0000                    	dw	0			;AN000;seconds,hundredths
 40843 000093F9 02                      	db	2			;AN000;second subst
 40844 000093FA 85                      	db	85h ; Right_align+TIME_HHMM_Cty
 40845                                  					;AN000;time
 40846 000093FB 06                      	db	6			;AN000;maximum width
 40847 000093FC 06                      	db	6			;AN000;minimum width
 40848 000093FD 20                      	db	blank ; 20h		;AN000;pad character
 40849                                  
 40850                                  ;  "Directory already exists"
 40851                                  MD_EXISTS_PTR:
 40852 000093FE 3604                    	dw	1078			;AN000;message number
 40853 00009400 00                      	db	no_subst		;AN000;number of subst
 40854                                  
 40855                                  ;  "%1 bytes",13,10
 40856                                  bytes_ptr:
 40857 00009401 3704                    	dw	1079			; message number
 40858 00009403 01                      	db	1			; number of subst
 40859 00009404 0B                      	db	parm_block_size ; 11	; size of sublist
 40860 00009405 00                      	db	0			; reserved
 40861 00009406 [1F9E]                  	dw	FileSiz			; offset of arg
 40862 00009408 0000                    	dw	0			; segment of arg
 40863 0000940A 01                      	db	1			; first subst
 40864                                  	; MSDOS 5.0 COMMAND.COM
 40865                                  	;db	0B1h ; Right_Align+Unsgn_Bin_DWord
 40866                                  	; 17/06/2023
 40867                                  screen_f_4:
 40868 0000940B F1                      	db	0F1h ; MSDOS 6.22 COMMAND.COM
 40869                                  					; long binary to decimal
 40870                                  	; MSDOS 5.0 COMMAND.COM
 40871                                  	;db	10			; maximum width
 40872                                  	;db	10			; minimum width
 40873                                  screen_f_5:
 40874 0000940C 0E                      	db	14 ; MSDOS 6.22 COMMAND.COM
 40875 0000940D 0E                      	db	14	
 40876                                  
 40877 0000940E 20                      	db	blank ; 20h		; pad character
 40878                                  
 40879                                  ;  "Total:",13,10
 40880                                  total_ptr:
 40881 0000940F 3804                    	dw	1080			; message number
 40882 00009411 00                      	db	no_subst ; 0		; number of subst
 40883                                  
 40884                                  ;  "Error parsing environment variable:",13,10
 40885                                  errparsenv_ptr:
 40886 00009412 3904                    	dw	1081			; message number
 40887 00009414 00                      	db	no_subst ; 0		; number of subst
 40888                                  
 40889                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40890                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:996Ah)
 40891                                  cox_Y_quest_ptr:
 40892 00009415 3A04                    	dw	1082
 40893 00009417 00                      	db	no_subst ; 0
 40894                                  cox_Y_answ_ptr:
 40895 00009418 3B04                    	dw	1083
 40896 0000941A 00                      	db	no_subst ; 0
 40897                                  
 40898                                  ;  "(continuing %1)",13,10
 40899                                  dircont_ptr:
 40900 0000941B 3C04                    	dw	1084			;AN000;message number
 40901 0000941D 01                      	db	1			;AN000;number of subst
 40902 0000941E 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 40903 0000941F 00                      	db	0			;AN000;reserved
 40904 00009420 [2AA0]                  	dw	BWDBUF			;AN000;offset of arg
 40905 00009422 0000                    	dw	0			;AN000;segment of arg
 40906 00009424 01                      	db	1			;AN000;first subst
 40907 00009425 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 40908 00009426 80                      	db	128			;AN000;maximum width
 40909 00009427 00                      	db	0			;AN000;minimum width
 40910 00009428 20                      	db	blank ; 20h		;AN000;pad character
 40911                                  
 40912                                  ;  "Revision %1",CR,LF
 40913                                  dosrev_ptr:
 40914 00009429 4204                    	dw	1090
 40915 0000942B 01                      	db	1			; one substitution
 40916 0000942C 0B                      	db	parm_block_size ; 11
 40917 0000942D 00                      	db	0
 40918 0000942E [A2A0]                  	dw	One_Char_Val		; ptr to char
 40919 00009430 0000                    	dw	0			; segment addr?
 40920 00009432 01                      	db	1			; 1st substitution
 40921 00009433 00                      	db	0 ; CHAR_FIELD_CHAR	; character
 40922 00009434 01                      	db	1			; max width
 40923 00009435 01                      	db	1			; min width
 40924 00009436 20                      	db	blank ; 20h		; pad char
 40925                                  
 40926                                  ;  "DOS is in ROM"
 40927                                  DosRom_Ptr:
 40928 00009437 4304                    	dw	1091
 40929 00009439 00                      	db	no_subst ; 0		
 40930                                  
 40931                                  ;  "DOS is in HMA"
 40932                                  DosHma_Ptr:
 40933 0000943A 4404                    	dw	1092
 40934 0000943C 00                      	db	no_subst ; 0		
 40935                                  
 40936                                  ;  "DOS is in low memory"
 40937                                  DosLow_Ptr:
 40938 0000943D 4504                    	dw	1093
 40939 0000943F 00                      	db	no_subst ; 0		
 40940                                  
 40941                                  ;  "Cannot Loadhigh batch file" ;M016
 40942                                  NoExecBat_Ptr:
 40943 00009440 4604                    	dw	1094			; M016
 40944 00009442 00                      	db	no_subst ; 0		; M016
 40945                                  
 40946                                  ;  "LoadHigh: Invalid filename" ; M016
 40947                                  LhInvFil_Ptr:
 40948 00009443 4704                    	dw	1095			; M016
 40949 00009445 00                      	db	no_subst ; 0		; M016
 40950                                  
 40951                                  ;  "Could not open specified country information file" ; M045
 40952                                  NoCntry_Ptr:
 40953 00009446 4804                    	dw	1096			; M045
 40954 00009448 00                      	db	no_subst ; 0		; M045
 40955                                  
 40956                                  ; 15/04/2023
 40957                                  ; MSDOS 6.0 COMMAND.COM only !
 40958                                  ; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 40959                                  ;%if 0
 40960                                  
 40961                                  ;* The next four errors emulate those reported by the normal parse
 40962                                  ;  mechanism, with a little more accurate wording; that parser has been
 40963                                  ;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
 40964                                  ;  These errors aren't normally generated by LoadHigh except by the normal
 40965                                  ;  parser, so they've been added here.
 40966                                  
 40967                                  ;  "LoadHigh: Invalid argument"
 40968                                  LhInvArg_Ptr:
 40969 00009449 4904                    	dw	1097
 40970 0000944B 00                      	db	no_subst ; 0		
 40971                                  
 40972                                  ;  "Required parameter missing"
 40973                                  ReqParmMiss:
 40974 0000944C 4A04                    	dw	1098
 40975 0000944E 00                      	db	no_subst ; 0		
 40976                                  
 40977                                  ;  "Unrecognized switch"
 40978                                  LhInvSwt_Ptr:
 40979 0000944F 4B04                    	dw	1099
 40980 00009451 00                      	db	no_subst ; 0		
 40981                                  
 40982                                  ;  "A bad UMB number has been specified"
 40983                                  LhBadUMB_Ptr:
 40984 00009452 4C04                    	dw	1100
 40985 00009454 00                      	db	no_subst ; 0
 40986                                  ;%endif	
 40987                                  
 40988                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 40989                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:99AAh
 40990                                  
 40991                                  DirCompRatio_Ptr:
 40992 00009455 4D04                    	dw	1101			;message number
 40993 00009457 02                      	db	2			;number of subst
 40994 00009458 0B                      	db	parm_block_size ; 11	;size of sublist
 40995 00009459 00                      	db	0			;reserved
 40996 0000945A [98A0]                  	dw	Dir_CRatio_1		;offset of arg
 40997 0000945C 0000                    	dw	0			;segment of arg
 40998 0000945E 01                      	db	1			;first subst
 40999 0000945F 91                      	db	91h			;format
 41000 00009460 02                      	db	2			;maximum width
 41001 00009461 02                      	db	2			;minimum width
 41002 00009462 20                      	db	blank ; 20h		;pad character
 41003 00009463 0B                      	db	parm_block_size  ; 11	;size of sublist
 41004 00009464 00                      	db	0			; reserved
 41005 00009465 [99A0]                  	dw	Dir_CRatio_2		;offset of arg
 41006 00009467 0000                    	dw	0			;segment of arg
 41007 00009469 02                      	db	2			;second subst
 41008 0000946A 11                      	db	11h			;format
 41009 0000946B 01                      	db	1			;maximum width
 41010 0000946C 01                      	db	1			;minimum width
 41011 0000946D 20                      	db	blank ; 20h		;pad character
 41012                                  
 41013                                  AveCompRatio_Ptr:
 41014 0000946E 4E04                    	dw	1102			;message number
 41015 00009470 02                      	db	2			;number of subst
 41016 00009471 0B                      	db	parm_block_size ; 11	;size of sublist
 41017 00009472 00                      	db	0			;reserved
 41018 00009473 [98A0]                  	dw	Dir_CRatio_1		;offset of arg
 41019 00009475 0000                    	dw	0			;segment of arg
 41020 00009477 01                      	db	1			;first subst
 41021 00009478 91                      	db	91h			;format
 41022 00009479 02                      	db	2			;maximum width
 41023 0000947A 02                      	db	2			;minimum width
 41024 0000947B 20                      	db	blank ; 20h		;pad character
 41025 0000947C 0B                      	db	parm_block_size  ; 11	;size of sublist
 41026 0000947D 00                      	db	0			; reserved
 41027 0000947E [99A0]                  	dw	Dir_CRatio_2		;offset of arg
 41028 00009480 0000                    	dw	0			;segment of arg
 41029 00009482 02                      	db	2			;second subst
 41030 00009483 11                      	db	11h			;format
 41031 00009484 01                      	db	1			;maximum width
 41032 00009485 01                      	db	1			;minimum width
 41033 00009486 20                      	db	blank ; 20h		;pad character
 41034                                  
 41035                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41036                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
 41037                                  
 41038                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41039                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:99DCh
 41040                                  
 41041                                  ; ---------------------------------------------------------------------------
 41042                                  
 41043                                  PATH_TEXT:
 41044 00009487 504154483D              	db	"PATH="
 41045                                  PROMPT_TEXT:
 41046 0000948C 50524F4D50543D          	db	"PROMPT="
 41047                                  COMSPECSTR:
 41048 00009493 434F4D535045433D        	db	"COMSPEC="
 41049                                  DirEnvVar:
 41050 0000949B 444952434D443D          	db	"DIRCMD="		; DIR's environment variable
 41051                                  
 41052                                  ;============================================================================
 41053                                  ; TDATA.ASM, MSDOS 6.0, 1991
 41054                                  ;============================================================================
 41055                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41056                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41057                                  
 41058                                  	; 15/04/2023
 41059 000094A2 00                      	db	0
 41060 000094A3 90                      align 2
 41061                                  
 41062                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
 41063                                  ; ---------------------------------------------------------------------------
 41064                                  	; 18/06/2023
 41065                                  	;db	0
 41066                                  
 41067                                  ; Lists of help message numbers for internal commands and /?
 41068                                  
 41069                                  	; 18/06/2023
 41070                                  ;;NoHelpMsgs:
 41071                                  	;dw	1200,0		;M014
 41072                                  
 41073                                  	; 18/06/2023
 41074                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:99F7h
 41075                                  
 41076                                  BreakHelpMsgs:
 41077 000094A4 14050000                	dw	1300,0
 41078                                  ChcpHelpMsgs:
 41079 000094A8 280529050000            	dw	1320,1321,0
 41080                                  CdHelpMsgs:
 41081 000094AE 3C053D053E050000        	dw	1340,1341,1342,0
 41082                                  ClsHelpMsgs:
 41083 000094B6 50050000                	dw	1360,0
 41084                                  CopyHelpMsgs:
 41085                                  	;dw	1400,1401,1402,1403,1404,0
 41086                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 41087 000094BA 780579057A057B057C-     	dw	1400,1401,1402,1403,1404,1405,1406,1407,0
 41087 000094C3 057D057E057F050000 
 41088                                  CttyHelpMsgs:
 41089 000094CC 8C050000                	dw	1420,0
 41090                                  DateHelpMsgs:
 41091 000094D0 A005A1050000            	dw	1440,1441,0
 41092                                  DelHelpMsgs:
 41093 000094D6 B405B505B6050000        	dw	1460,1461,1462,0
 41094                                  DirHelpMsgs:
 41095 000094DE C805C905CA05CB05CC-     	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
 41095 000094E7 05CD05CE05CF05D005 
 41096                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 41097                                  	; MSDOS 6.0 COMMAND.COM
 41098 000094F0 D105D205D305D405        	dw	1489,1490,1491,1492
 41099 000094F8 0000                    	dw	0
 41100                                  ExitHelpMsgs:
 41101 000094FA DC050000                	dw	1500,0
 41102                                  MdHelpMsgs:
 41103 000094FE F0050000                	dw	1520,0
 41104                                  PathHelpMsgs:
 41105 00009502 0406050606060000        	dw	1540,1541,1542,0
 41106                                  PromptHelpMsgs:
 41107 0000950A 180619061A061B061C-     	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
 41107 00009513 061D061E061F062006-
 41107 0000951C 0000               
 41108                                  RdHelpMsgs:
 41109 0000951E 2C060000                	dw	1580,0
 41110                                  RenHelpMsgs:
 41111 00009522 4006410642060000        	dw	1600,1601,1602,0
 41112                                  SetHelpMsgs:
 41113 0000952A 5406550656060000        	dw	1620,1621,1622,0
 41114                                  TimeHelpMsgs:
 41115 00009532 680669060000            	dw	1640,1641,0
 41116                                  TypeHelpMsgs:
 41117 00009538 7C060000                	dw	1660,0
 41118                                  VerHelpMsgs:
 41119 0000953C 90060000                	dw	1680,0
 41120                                  VerifyHelpMsgs:
 41121 00009540 A4060000                	dw	1700,0
 41122                                  VolHelpMsgs:
 41123 00009544 B8060000                	dw	1720,0
 41124                                  CallHelpMsgs:
 41125 00009548 CC06CD060000            	dw	1740,1741,0	;M014
 41126                                  RemHelpMsgs:
 41127 0000954E E0060000                	dw	1760,0		;M014
 41128                                  PauseHelpMsgs:
 41129 00009552 F4060000                	dw	1780,0		;M014
 41130                                  EchoHelpMsgs:
 41131 00009556 080709070000            	dw	1800,1801,0	;M014
 41132                                  GotoHelpMsgs:
 41133 0000955C 1C071D070000            	dw	1820,1821,0	;M014
 41134                                  ShiftHelpMsgs:
 41135 00009562 30070000                	dw	1840,0		;M014
 41136                                  IfHelpMsgs:
 41137 00009566 440745074607470748-     	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
 41137 0000956F 0749074A070000     
 41138                                  ForHelpMsgs:
 41139 00009576 580759075A075B0700-     	dw	1880,1881,1882,1883,0 ;M014
 41139 0000957F 00                 
 41140                                  TruenameHelpMsgs:
 41141 00009580 6C070000                	 dw	1900,0		;M014
 41142                                  LoadhighHelpMsgs:
 41143 00009584 800781078207            	dw	1920,1921,1922
 41144                                  	; 17/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM 
 41145                                  	; MSDOS 6.0 COMMAND.COM
 41146 0000958A 830784078507860787-     	dw	1923,1924,1925,1926,1927 ;M014
 41146 00009593 07                 
 41147 00009594 0000                    	dw	0
 41148                                  
 41149                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
 41150                                  CLSSTRING:
 41151 00009596 041B5B324A              	db	4,1Bh,"[2J"		; ANSI Clear screen
 41152                                  
 41153                                  PROMPT_TABLE:
 41154 0000959B 42                      	db	"B"
 41155 0000959C [4B23]                  	dw	Print_B
 41156 0000959E 44                      	db	"D"
 41157 0000959F [193C]                  	dw	PRINT_DATE
 41158 000095A1 45                      	db	"E"
 41159 000095A2 [3F23]                  	dw	PRINT_ESC
 41160 000095A4 47                      	db	"G"
 41161 000095A5 [4323]                  	dw	PRINT_G
 41162 000095A7 48                      	db	"H"
 41163 000095A8 [3523]                  	dw	PRINT_BACK
 41164 000095AA 4C                      	db	"L"
 41165 000095AB [4723]                  	dw	PRINT_L
 41166 000095AD 4E                      	db	"N"
 41167 000095AE [5C23]                  	dw	PRINT_DRIVE
 41168 000095B0 50                      	db	"P"
 41169 000095B1 [6423]                  	dw	build_dir_for_prompt
 41170 000095B3 51                      	db	"Q"
 41171 000095B4 [3B23]                  	dw	PRINT_EQ
 41172 000095B6 54                      	db	"T"
 41173 000095B7 [D034]                  	dw	PRINT_TIME
 41174 000095B9 56                      	db	"V"
 41175 000095BA [CB22]                  	dw	PRINT_VERSION
 41176 000095BC 5F                      	db	"_"
 41177 000095BD [212B]                  	dw	CRLF2
 41178 000095BF 24                      	db	"$"
 41179 000095C0 [4D23]                  	dw	PRINT_CHAR
 41180 000095C2 00                      	db	0			; NUL TERMINATED
 41181                                  
 41182                                  ; Table of IF conditionals
 41183                                  IFTAB:
 41184 000095C3 034E4F54                	db	3,"NOT"			; First byte is count
 41185 000095C7 [B30B]                  	dw	IFNOT
 41186 000095C9 0A4552524F524C4556-     	db	10,"ERRORLEVEL"
 41186 000095D2 454C               
 41187 000095D4 [720C]                  	dw	IFERLEV
 41188 000095D6 054558495354            	db	5,"EXIST"
 41189 000095DC [070C]                  	dw	IFEXISTS
 41190 000095DE 00                      	db	0
 41191                                  
 41192                                  ; Table for internal command names
 41193                                  COMTAB:
 41194 000095DF 0344495203              	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
 41195 000095E4 [3711]                  	dw	CATALOG			; In TCMD1.ASM
 41196 000095E6 [DE94]                  	dw	DirHelpMsgs
 41197                                  
 41198 000095E8 0443414C4C02            	db	4,"CALL",fSwitchAllowed	; 2
 41199 000095EE [E70C]                  	dw	_$CALL			; In TBATCH2.ASM
 41200 000095F0 [4895]                  	dw	CallHelpMsgs
 41201                                  
 41202 000095F2 044348435002            	db	4,"CHCP",fSwitchAllowed ; 2
 41203 000095F8 [A725]                  	dw	CHCP			; In TCMD2B.ASM
 41204 000095FA [A894]                  	dw	ChcpHelpMsgs
 41205                                  
 41206 000095FC 0652454E414D4503        	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 41207 00009604 [931F]                  	dw	CRENAME			; In TCMD1.ASM
 41208 00009606 [2295]                  	dw	RenHelpMsgs
 41209                                  
 41210 00009608 0352454E03              	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 41211 0000960D [931F]                  	dw	CRENAME			; In TCMD1.ASM
 41212 0000960F [2295]                  	dw	RenHelpMsgs
 41213                                  	
 41214 00009611 05455241534503          	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
 41215 00009618 [111F]                  	dw	ERASE			; In TCMD1.ASM
 41216 0000961A [D694]                  	dw	DelHelpMsgs
 41217                                  	
 41218 0000961C 0344454C03              	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
 41219 00009621 [111F]                  	dw	ERASE			; In TCMD1.ASM
 41220 00009623 [D694]                  	dw	DelHelpMsgs
 41221                                  	
 41222 00009625 045459504503            	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 41223 0000962B [3A20]                  	dw	TYPEFIL			; In TCMD1.ASM
 41224 0000962D [3895]                  	dw	TypeHelpMsgs
 41225                                  	
 41226 0000962F 0352454D06              	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
 41227 00009634 [0401]                  	dw	TCOMMAND		; In TCODE.ASM
 41228 00009636 [4E95]                  	dw	RemHelpMsgs
 41229                                  	
 41230 00009638 04434F505903            	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
 41231 0000963E [663C]                  	dw	COPY			; In COPY.ASM
 41232 00009640 [BA94]                  	dw	CopyHelpMsgs
 41233                                  	
 41234 00009642 05504155534506          	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
 41235 00009649 [051F]                  	dw	PAUSE			; In TCMD1.ASM
 41236 0000964B [5295]                  	dw	PauseHelpMsgs
 41237                                  	
 41238 0000964D 044441544502            	db	4,"DATE",fSwitchAllowed	; 2
 41239 00009653 [E333]                  	dw	DATE			; In TPIPE.ASM
 41240 00009655 [D094]                  	dw	DateHelpMsgs
 41241                                  	
 41242 00009657 0454494D4502            	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
 41243 0000965D [4234]                  	dw	CTIME			; In TPIPE.ASM
 41244 0000965F [3295]                  	dw	TimeHelpMsgs
 41245                                  	
 41246 00009661 0356455202              	db	3,"VER",fSwitchAllowed ; 2
 41247 00009666 [5922]                  	dw	VERSION			; In TCMD2.ASM
 41248 00009668 [3C95]                  	dw	VerHelpMsgs
 41249                                  	
 41250 0000966A 03564F4C03              	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 41251 0000966F [6121]                  	dw	VOLUME			; In TCMD1.ASM
 41252 00009671 [4495]                  	dw	VolHelpMsgs
 41253                                  	
 41254 00009673 02434403                	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 41255 00009677 [EA29]                  	dw	_$CHDIR			; In TENV.ASM
 41256 00009679 [AE94]                  	dw	CdHelpMsgs
 41257                                  	
 41258 0000967B 05434844495203          	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 41259 00009682 [EA29]                  	dw	_$CHDIR			; In TENV.ASM
 41260 00009684 [AE94]                  	dw	CdHelpMsgs
 41261                                  	
 41262 00009686 024D4403                	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 41263 0000968A [4F2A]                  	dw	_$MKDIR			; In TENV.ASM
 41264 0000968C [FE94]                  	dw	MdHelpMsgs
 41265                                  	
 41266 0000968E 054D4B44495203          	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 41267 00009695 [4F2A]                  	dw	_$MKDIR			; In TENV.ASM
 41268 00009697 [FE94]                  	dw	MdHelpMsgs
 41269                                  	
 41270 00009699 02524403                	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 41271 0000969D [912A]                  	dw	_$RMDIR			; In TENV.ASM
 41272 0000969F [1E95]                  	dw	RdHelpMsgs
 41273                                  	
 41274 000096A1 05524D44495203          	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 41275 000096A8 [912A]                  	dw	_$RMDIR			; In TENV.ASM
 41276 000096AA [1E95]                  	dw	RdHelpMsgs
 41277                                  	
 41278 000096AC 05425245414B02          	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
 41279 000096B3 [633B]                  	dw	CNTRLC			; In TUCODE.ASM
 41280 000096B5 [A494]                  	dw	BreakHelpMsgs
 41281                                  	
 41282 000096B7 0656455249465902        	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
 41283 000096BF [A53B]                  	dw	VERIFY			; In TUCODE.ASM
 41284 000096C1 [4095]                  	dw	VerifyHelpMsgs
 41285                                  	
 41286 000096C3 0353455406              	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
 41287 000096C8 [5427]                  	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
 41288 000096CA [2A95]                  	dw	SetHelpMsgs
 41289                                  	
 41290 000096CC 0650524F4D505406        	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
 41291 000096D4 [3A27]                  	dw	ADD_PROMPT		; In TENV.ASM
 41292 000096D6 [0A95]                  	dw	PromptHelpMsgs
 41293                                  	
 41294 000096D8 045041544802            	db	4,"PATH",fSwitchAllowed ; 2
 41295 000096DE [CB23]                  	dw	PATH			; In TCMD2.ASM
 41296 000096E0 [0295]                  	dw	PathHelpMsgs
 41297                                  	
 41298 000096E2 044558495400            	db	4,"EXIT",0
 41299 000096E8 [9C26]                  	dw	_$EXIT			; In TCMD2.ASM
 41300 000096EA [FA94]                  	dw	ExitHelpMsgs
 41301                                  	
 41302 000096EC 044354545903            	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
 41303 000096F2 [0925]                  	dw	CTTY			; In TCMD2.ASM
 41304 000096F4 [CC94]                  	dw	CttyHelpMsgs
 41305                                  	
 41306 000096F6 044543484F06            	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
 41307 000096FC [2A3B]                  	dw	_ECHO			; In TUCODE.ASM
 41308 000096FE [5695]                  	dw	EchoHelpMsgs
 41309                                  	
 41310 00009700 04474F544F06            	db	4,"GOTO",fSwitchAllowed+fLimitHelp
 41311 00009706 [1B0D]                  	dw	_GOTO			; In TBATCH.ASM
 41312 00009708 [5C95]                  	dw	GotoHelpMsgs
 41313                                  	
 41314 0000970A 05534849465402          	db	5,"SHIFT",fSwitchAllowed ; 2
 41315 00009711 [A00C]                  	dw	_SHIFT			; In TBATCH.ASM
 41316 00009713 [6295]                  	dw	ShiftHelpMsgs
 41317                                  	
 41318 00009715 02494606                	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
 41319 00009719 [4C0B]                  	dw	_$IF			; In TBATCH.ASM
 41320 0000971B [6695]                  	dw	IfHelpMsgs
 41321                                  	
 41322 0000971D 03464F5206              	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
 41323 00009722 [D00F]                  	dw	_$FOR			; In TBATCH.ASM
 41324 00009724 [7695]                  	dw	ForHelpMsgs
 41325                                  	
 41326 00009726 03434C5300              	db	3,"CLS",0
 41327 0000972B [7024]                  	dw	CLS			; In TCMD2.ASM
 41328 0000972D [B694]                  	dw	ClsHelpMsgs
 41329                                  	
 41330 0000972F 08545255454E414D45-     	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
 41330 00009738 03                 
 41331 00009739 [2526]                  	dw	TRUENAME		;AN000;
 41332 0000973B [8095]                  	dw	TruenameHelpMsgs
 41333                                  	
 41334 0000973D 084C4F414448494748-     	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
 41334 00009746 02                 
 41335 00009747 [0163]                  	dw	LoadHigh		; In loadhi.asm ; M003
 41336 00009749 [8495]                  	dw	LoadhighHelpMsgs	; M003
 41337                                  	
 41338 0000974B 024C4802                	db	2,"LH",fSwitchAllowed ; 2 ; Short form; M003
 41339 0000974F [0163]                  	dw	LoadHigh		; In loadhi.asm ; M003
 41340 00009751 [8495]                  	dw	LoadhighHelpMsgs	; M003
 41341                                  	
 41342 00009753 00                      	db	0			; Terminate command table
 41343                                  
 41344                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h
 41345                                  
 41346 00009754 2E434F4D                comext:	db	".COM"
 41347 00009758 2E455845                exeext:	db	".EXE"
 41348 0000975C 2E424154                batext:	db	".BAT"
 41349                                  
 41350                                  switch_list:
 41351                                  	; MSDOS 5.0 (& 6.0) COMMAND.COM
 41352                                  	;db	"?VBAPW"		; flags we can recognize
 41353                                  	; 18/06/2023
 41354                                  	; MSDOS 6.22 COMMAND.COM
 41355 00009760 2D593F5642415057        	db	"-Y?VBAPW"
 41356                                  
 41357                                  AttrLtrs:
 41358 00009768 524853764441            	db	"RHSvDA"		; attribute letters for DIR
 41359                                  
 41360                                  ;	Attribute letters in AttrLtrs must appear in the order that
 41361                                  ;	attribute bits occur in the attribute byte returned by
 41362                                  ;	directory searches, starting with bit 0.
 41363                                  ;	The volume label attribute is lowercased to keep it from
 41364                                  ;	being matched (by an uppercase comparison).
 41365                                  
 41366                                  OrderLtrs:
 41367                                  	; MSDOS 5.0
 41368                                  	;db	"NEDSG"			; sort order letters for DIR
 41369                                  	; 18/06/2023
 41370                                  	; MSDOS 6.0 COMMAND.COM
 41371 0000976E 4E4544534743            	db	"NEDSGC"		; sort order letters for DIR
 41372                                  
 41373                                  ;	Sort order letters stand for file name, extension,
 41374                                  ;	date/time, size, grouped (directory files before others),
 41375                                  ;	and compression ratio. DIR routines rely on the specific
 41376                                  ;	order of the letters in this list.
 41377                                  
 41378                                  comspec_flag:
 41379 00009774 00                      	db	0                       ;AN071;
 41380                                  
 41381                                  BATBUFLEN:
 41382 00009775 2000                    	dw	BatLen ; 32
 41383                                  
 41384                                  ; *****************************************************
 41385                                  ; EMG 4.00
 41386                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 41387                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 41388                                  ; *****************************************************
 41389                                  
 41390                                  ; COMMON PARSE BLOCKS
 41391                                  
 41392                                  ; Indicates no value list for PARSE.
 41393                                  
 41394                                  NO_VALUES:
 41395 00009777 0000                    	dw	0			;AN000;  no values
 41396                                  
 41397                                  NULL_VALUE_LIST:  ; for unvalidated value
 41398 00009779 00                       	db	0                       ; no value lists
 41399                                  
 41400                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41401                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h
 41402                                  
 41403                                  ; PARSE control block for a required file specification (upper cased)
 41404                                  
 41405                                  FILE_REQUIRED:
 41406 0000977A 0002                    	dw	0200h			;AN000;  filespec - required
 41407 0000977C 0100                    	dw	1			;AN000;  capitalize - file table
 41408 0000977E [E1A9]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41409 00009780 [7797]                  	dw	NO_VALUES		;AN000;
 41410 00009782 00                      	db	0			;AN000;  no keywords
 41411                                  
 41412                                  ; PARSE control block for an optional file specification (upper cased)
 41413                                  ; or drive number
 41414                                  
 41415                                  FILE_OPTIONAL:
 41416 00009783 0103                    	dw	0301h			;AN000;  filespec or drive number
 41417                                  					;	 optional
 41418 00009785 0100                    	dw	1			;AN000;  capitalize - file table
 41419 00009787 [E1A9]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41420 00009789 [7797]                  	dw	NO_VALUES		;AN000;
 41421 0000978B 00                      	db	0			;AN000;  no keywords
 41422                                  
 41423                                  ; PARSE control block for an optional file specification (upper cased)
 41424                                  
 41425                                  FILE_OPTIONAL2:
 41426 0000978C 0102                    	dw	0201h                   ;AN000;  filespec optional
 41427 0000978E 0100                    	dw	1                       ;AN000;  capitalize - file table
 41428 00009790 [E1A9]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41429 00009792 [7797]                  	dw	NO_VALUES		;AN000;
 41430 00009794 00                      	db	0			;AN000;  no keywords
 41431                                  
 41432                                  ; PARSE control block for an optional /P switch
 41433                                  
 41434                                  SLASH_P_SWITCH:
 41435 00009795 0000                    	dw	0			;AN000;  no match flags
 41436 00009797 0200                    	dw	2			;AN000;  capitalize - char table
 41437 00009799 [E1A9]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41438 0000979B [7797]                  	dw	NO_VALUES		;AN000;
 41439 0000979D 01                      	db	1			;AN000;  1 keyword
 41440                                  SLASH_P_SYN:
 41441 0000979E 2F5000                  	db	"/P",0                  ;AN000;  /P switch
 41442                                  
 41443                                  ; PARSE BLOCK FOR BREAK, VERIFY, ECHO
 41444                                  
 41445                                  ; The following parse control block can be used for any command which
 41446                                  ; needs only the optional "ON" and "OFF" keywords as operands. Allows
 41447                                  ; the equal sign as an additional delimiter. Returns verified result
 41448                                  ; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
 41449                                  ; internal commands.
 41450                                  
 41451                                  PARSE_BREAK:
 41452 000097A1 [A497]                  	dw	BREAK_PARMS		;AN000;
 41453 000097A3 00                      	db	0			;AN032; no extra delimiter
 41454                                  
 41455                                  BREAK_PARMS:
 41456 000097A4 0001                    	db	0,1			;AN000;  1 positional parm
 41457 000097A6 [AA97]                  	dw	BREAK_CONTROL1		;AN000;
 41458 000097A8 00                      	db	0			;AN000;  no switches
 41459 000097A9 00                      	db	0			;AN000;  no keywords
 41460                                  
 41461                                  BREAK_CONTROL1:
 41462 000097AA 0120                    	dw	2001h			;AN000;  string value - optional
 41463 000097AC 0200                    	dw	2			;AN000;  capitalize - char table
 41464 000097AE [E1A9]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41465 000097B0 [B397]                  	dw	BREAK_VALUES		;AN000;
 41466 000097B2 00                      	db	0			;AN000;  no keywords
 41467                                  
 41468                                  BREAK_VALUES:
 41469 000097B3 03                      	db	3			;AN000;
 41470 000097B4 00                      	db	0			;AN000;  no ranges
 41471 000097B5 00                      	db	0			;AN000;  no numeric values
 41472 000097B6 02                      	db	2			;AN000;  2 string values
 41473 000097B7 00                      	db	0			;AN000;  returned if ON
 41474 000097B8 [BD97]                  	dw	BREAK_ON		;AN000;  point to ON string
 41475 000097BA 66                      	db	'f'                     ;AN000;  returned if OFF
 41476 000097BB [C097]                  	dw	BREAK_OFF		;AN000;  point to OFF string
 41477                                  
 41478                                  BREAK_ON:
 41479 000097BD 4F4E00                  	db	"ON",0                  ;AN000;
 41480                                  BREAK_OFF:
 41481 000097C0 4F464600                	db	"OFF",0                 ;AN000;
 41482                                  
 41483                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41484                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h
 41485                                  
 41486                                  ; PARSE BLOCK FOR CHCP
 41487                                  
 41488                                  ; The following parse control block can be used for any command which
 41489                                  ; needs only one optional three digit decimal parameter for operands.
 41490                                  ; Returns verified result in PARSE1_OUTPUT. Currently used for the
 41491                                  ; CHCP internal command.
 41492                                  
 41493                                  CHCP_MINVAL	EQU	100			;AN000;
 41494                                  CHCP_MAXVAL	EQU	999			;AN000;
 41495                                  
 41496                                  PARSE_CHCP:
 41497 000097C4 [C797]                  	dw	CHCP_PARMS			;AN000;
 41498 000097C6 00                      	db	0				;AN000;  no extra delimiter
 41499                                  CHCP_PARMS:
 41500 000097C7 0001                    	db	0,1				;AN000;  1 positional parm
 41501 000097C9 [CD97]                  	dw	CHCP_CONTROL1			;AN000;
 41502 000097CB 00                      	db	0				;AN000;  no switches
 41503 000097CC 00                      	db	0				;AN000;  no keywords
 41504                                  
 41505                                  CHCP_CONTROL1:
 41506 000097CD 0180                    	dw	8001h				;AN000;  numeric value - optional
 41507 000097CF 0000                    	dw	0				;AN000;  no function flags
 41508 000097D1 [E1A9]                  	dw	PARSE1_OUTPUT			;AN000;  result buffer
 41509 000097D3 [D697]                  	dw	CHCP_VALUES			;AN000;
 41510 000097D5 00                      	db	0				;AN000;  no keywords
 41511                                  
 41512                                  CHCP_VALUES:
 41513 000097D6 01                      	db	1				;AN000;
 41514 000097D7 01                      	db	1				;AN000;  1 range
 41515 000097D8 01                      	db	1				;AN000;  returned if result
 41516 000097D9 64000000E7030000        	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
 41517 000097E1 00                      	db	0				;AN000;  no numeric values
 41518 000097E2 00                      	db	0				;AN000;  no string values
 41519                                  
 41520                                  ; PARSE BLOCK FOR DATE
 41521                                  
 41522                                  ; The following parse control block can be used for any command which
 41523                                  ; needs only an optional date string as an operand. Returns unverified
 41524                                  ; result in DATE_OUTPUT. Currently used for the DATE internal command.
 41525                                  
 41526                                  PARSE_DATE:
 41527 000097E3 [E697]                  	dw	DATE_PARMS			;AN000;
 41528 000097E5 00                      	db	0				;AN000;  no extra delimiter
 41529                                  DATE_PARMS:
 41530 000097E6 0001                    	db	0,1				;AN000;  1 positional parm
 41531 000097E8 [EC97]                  	dw	DATE_CONTROL1			;AN000;
 41532 000097EA 00                      	db	0				;AN000;  no switches
 41533 000097EB 00                      	db	0				;AN000;  no keywords
 41534                                  
 41535                                  DATE_CONTROL1:
 41536 000097EC 0110                    	dw	1001h				;AN000;  date - optional
 41537 000097EE 0000                    	dw	0				;AN000;  no function flags
 41538 000097F0 [E9A9]                  	dw	DATE_OUTPUT			;AN000;  result buffer
 41539 000097F2 [7797]                  	dw	NO_VALUES			;AN000;
 41540 000097F4 00                      	db	0				;AN000;  no keywords
 41541                                  
 41542                                  ; PARSE BLOCK FOR TIME
 41543                                  
 41544                                  ; The following parse control block can be used for any command which
 41545                                  ; needs only an optional time string as an operand. Returns unverified
 41546                                  ; result in TIME_OUTPUT. Currently used for the TIME internal command.
 41547                                  
 41548                                  PARSE_TIME:
 41549 000097F5 [F897]                  	dw	TIME_PARMS			;AN000;
 41550 000097F7 00                      	db	0				;AN000;  no extra delimiter
 41551                                  TIME_PARMS:
 41552 000097F8 0001                    	db	0,1				;AN000;  1 positional parm
 41553 000097FA [FE97]                  	dw	TIME_CONTROL1			;AN000;
 41554 000097FC 00                      	db	0				;AN000;  no switches
 41555 000097FD 00                      	db	0				;AN000;  no keywords
 41556                                  
 41557                                  TIME_CONTROL1:
 41558 000097FE 0108                    	dw	0801h				;AN000;  TIME - optional
 41559 00009800 0000                    	dw	0				;AN000;  no function flags
 41560 00009802 [F1A9]                  	dw	TIME_OUTPUT			;AN000;  result buffer
 41561 00009804 [7797]                  	dw	NO_VALUES			;AN000;
 41562 00009806 00                      	db	0				;AN000;  no keywords
 41563                                  
 41564                                  ; PARSE BLOCK FOR VOL
 41565                                  
 41566                                  ; The following parse control block can be used for any command which
 41567                                  ; needs only an optional drive letter as an operand.  Returns unverified
 41568                                  ; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
 41569                                  ; internal command.
 41570                                  
 41571                                  PARSE_VOL:
 41572 00009807 [0A98]                  	dw	VOL_PARMS			;AN000;
 41573 00009809 00                      	db	0				;AN000;  no extra delimiter
 41574                                  VOL_PARMS:
 41575 0000980A 0001                    	db	0,1				;AN000;  1 positional parm
 41576 0000980C [1098]                  	dw	DRIVE_CONTROL1			;AN000;
 41577 0000980E 00                      	db	0				;AN000;  no switches
 41578 0000980F 00                      	db	0				;AN000;  no keywords
 41579                                  
 41580                                  DRIVE_CONTROL1:
 41581 00009810 0101                    	dw	0101h				;AN000;  DRIVE - optional
 41582 00009812 0100                    	dw	1				;AN000;  capitalize - file table
 41583 00009814 [F9A9]                  	dw	DRIVE_OUTPUT			;AN000;  result buffer
 41584 00009816 [7797]                  	dw	NO_VALUES			;AN000;
 41585 00009818 00                      	db	0				;AN000;  no keywords
 41586                                  
 41587                                  ; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
 41588                                  
 41589                                  ; The following parse control block can be used for any command which
 41590                                  ; needs only one required file specification as an operand. Returns a
 41591                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 41592                                  ; for the MKDIR, RMDIR, and TYPE internal commands.
 41593                                  
 41594                                  PARSE_MRDIR:
 41595 00009819 [1C98]                  	dw	MRDIR_PARMS			;AN000;
 41596 0000981B 00                      	db	0				;AN000;  no extra delimiter
 41597                                  MRDIR_PARMS:
 41598 0000981C 0101                    	db	1,1				;AN000;  1 positional parm
 41599 0000981E [7A97]                  	dw	FILE_REQUIRED			;AN000;
 41600 00009820 00                      	db	0				;AN000;  no switches
 41601 00009821 00                      	db	0				;AN000;  no keywords
 41602                                  
 41603                                  ; PARSE BLOCK FOR CHDIR, TRUENAME
 41604                                  
 41605                                  ; The following parse control block can be used for any command which
 41606                                  ; needs only one optional file specification an operand. Returns a
 41607                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 41608                                  ; for the CHDIR and TRUENAME internal commands.
 41609                                  
 41610                                  PARSE_CHDIR:
 41611 00009822 [2598]                  	dw	CHDIR_PARMS			;AN000;
 41612 00009824 00                      	db	0				;AN000;  no extra delimiter
 41613                                  CHDIR_PARMS:
 41614 00009825 0001                    	db	0,1				;AN000;  1 positional parm
 41615 00009827 [8397]                  	dw	FILE_OPTIONAL			;AN000;
 41616 00009829 00                      	db	0				;AN000;  no switches
 41617 0000982A 00                      	db	0				;AN000;  no keywords
 41618                                  
 41619                                  ; PARSE BLOCK FOR ERASE
 41620                                  
 41621                                  ; The following parse control block is used for the DEL/ERASE internal
 41622                                  ; commands. This command has one required file specification and an
 41623                                  ; optional switch (/p) as operands. The verified switch or unverified
 41624                                  ; file specification is returned in PARSE1_OUTPUT.
 41625                                  
 41626                                  PARSE_ERASE:
 41627 0000982B [2E98]                  	dw	ERASE_PARMS			;AN000;
 41628 0000982D 00                      	db	0				;AN000;  no extra delimiter
 41629                                  
 41630                                  ERASE_PARMS:
 41631 0000982E 0101                    	db	1,1				;AN000;  1 positional parm
 41632 00009830 [7A97]                  	dw	FILE_REQUIRED			;AN000;
 41633 00009832 01                      	db	1				;AN000;  1 switch
 41634 00009833 [9597]                  	dw	SLASH_P_SWITCH			;AN000;
 41635 00009835 00                      	db	0				;AN000;  no keywords
 41636                                  
 41637                                  ; PARSE BLOCK FOR DIR
 41638                                  
 41639                                  ; The following parse control block is used for the DIR internal command.
 41640                                  ; This command has one optional file specification and several optional
 41641                                  ; switches. Switches, switch values, and the filespec are returned in 
 41642                                  ; PARSE1_OUTPUT.
 41643                                  ;
 41644                                  ; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
 41645                                  ; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
 41646                                  ; do not require colons, and are not checked against a value list.
 41647                                  ;
 41648                                  ; Switch /h has been removed from the DIR command	;M008
 41649                                  ; Switch /? is no longer handled internally		;M008
 41650                                  ;
 41651                                  ; A list of pointers to all the switch synonyms is provided here to
 41652                                  ; help identify which switch has been matched.
 41653                                  
 41654                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 41655                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h
 41656                                  
 41657                                  PARSE_DIR:
 41658 00009836 [3998]                  	dw	DIR_PARMS
 41659 00009838 00                      	db	0			; no extra delimiters
 41660                                  DIR_PARMS:
 41661 00009839 0001                    	db	0,1			; 1 optional positional param
 41662 0000983B [8C97]                  	dw	FILE_OPTIONAL2
 41663 0000983D 02                      	db	2			; 2 kinds of switches
 41664 0000983E [4398]                  	dw	DIR_SW_VALUED
 41665 00009840 [5598]                  	dw	DIR_SW_UNVALUED
 41666 00009842 00                      	db	0			; no keywords
 41667                                  
 41668                                  DIR_SW_VALUED:
 41669 00009843 0120                    	dw	2001h			; optional string value
 41670 00009845 2100                    	dw	21h			; optional colon; capitalize 
 41671 00009847 [E1A9]                  	dw	PARSE1_OUTPUT		; result buffer
 41672 00009849 [7997]                  	dw	NULL_VALUE_LIST		; don't validate value
 41673                                  
 41674                                  	; 18/06/2023
 41675                                  	;db	2
 41676                                  
 41677                                  ; MSDOS 6.0 COMMAND.COM
 41678                                  ;ifdef DBLSPACE_HOOKS
 41679                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41680 0000984B 03                      	db	3		; 3 'synonyms'
 41681                                  ;else
 41682                                  ;	db	2		; 2 'synonyms'
 41683                                  ;endif
 41684                                  
 41685                                  DIR_SW_A:
 41686 0000984C 2F4100                  	db	"/A",0
 41687                                  DIR_SW_O:
 41688 0000984F 2F4F00                  	db	"/O",0
 41689                                  
 41690                                  ; MSDOS 6.0 COMMAND.COM
 41691                                  ;ifdef DBLSPACE_HOOKS
 41692                                  	; 18/06/2023
 41693                                  DIR_SW_C:
 41694 00009852 2F4300                  	db	"/C",0
 41695                                  ;endif
 41696                                  
 41697                                  DIR_SW_UNVALUED:
 41698 00009855 0000                    	dw	0			; no value
 41699 00009857 0000                    	dw	0			; no format functions
 41700 00009859 [E1A9]                  	dw	PARSE1_OUTPUT		; result buffer
 41701 0000985B [7797]                  	dw	NO_VALUES
 41702                                  
 41703                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 41704                                  	;;db	12
 41705                                  	
 41706                                  	; 18/06/2023
 41707                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
 41708                                  	;db	14		; 14 'synonyms' !?
 41709                                  
 41710                                  ; MSDOS 6.0 COMMAND.COM
 41711                                  ;ifdef DBLSPACE_HOOKS
 41712                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41713                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9DB0h
 41714 0000985D 0D                      	db	13		; 13 'synonyms'
 41715                                  ;else
 41716                                  ;	db	12		; 12 'synonyms'
 41717                                  ;endif
 41718                                  
 41719                                  DIR_SW_NEG_A:
 41720 0000985E 2F2D4100                	db	"/-A",0
 41721                                  DIR_SW_NEG_O:
 41722 00009862 2F2D4F00                	db	"/-O",0
 41723                                  DIR_SW_S:
 41724 00009866 2F5300                  	db	"/S",0
 41725                                  DIR_SW_NEG_S:
 41726 00009869 2F2D5300                	db	"/-S",0
 41727                                  DIR_SW_B:
 41728 0000986D 2F4200                  	db	"/B",0
 41729                                  DIR_SW_NEG_B:
 41730 00009870 2F2D4200                	db	"/-B",0
 41731                                  DIR_SW_W:
 41732 00009874 2F5700                  	db	"/W",0
 41733                                  DIR_SW_NEG_W:
 41734 00009877 2F2D5700                	db	"/-W",0
 41735                                  DIR_SW_P:
 41736 0000987B 2F5000                  	db	"/P",0
 41737                                  DIR_SW_NEG_P:
 41738 0000987E 2F2D5000                	db	"/-P",0
 41739                                  DIR_SW_L:
 41740 00009882 2F4C00                  	db	"/L",0		;M010
 41741                                  DIR_SW_NEG_L:
 41742 00009885 2F2D4C00                	db	"/-L",0 	;M010
 41743                                  
 41744                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41745                                  ; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
 41746                                  DIR_SW_NEG_C:
 41747 00009889 2F2D4300                	db	"/-C",0
 41748                                  
 41749                                  ; Here's a list of pointers to DIR's switch synonyms, for easier
 41750                                  ; identification. Order is critical - DIR routines rely on the
 41751                                  ; specific order in this list. Negated options appear at odd 
 41752                                  ; positions in the list, and simple on/off options appear first.
 41753                                  
 41754                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41755                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9DE0h
 41756                                  Dir_Sw_Ptrs:			; list of ptrs to switch synonyms
 41757                                  	; 18/06/2023
 41758                                  	; MSDOS 6.0 COMMAND.COM ; *
 41759 0000988D [8998]                  	dw	DIR_SW_NEG_C	; * 
 41760                                  Dir_Sw_Ptrs_2:
 41761 0000988F [5298]                  	dw	DIR_SW_C	; *
 41762                                  	; MSDOS 5.0 COMMAND.COM	
 41763                                  ;Dir_Sw_Ptrs:
 41764 00009891 [7798]                  	dw	DIR_SW_NEG_W
 41765                                  ;Dir_Sw_Ptrs_2:
 41766 00009893 [7498]                  	dw	DIR_SW_W
 41767 00009895 [7E98]                  	dw	DIR_SW_NEG_P
 41768 00009897 [7B98]                  	dw	DIR_SW_P
 41769 00009899 [6998]                  	dw	DIR_SW_NEG_S
 41770 0000989B [6698]                  	dw	DIR_SW_S
 41771 0000989D [7098]                  	dw	DIR_SW_NEG_B
 41772 0000989F [6D98]                  	dw	DIR_SW_B
 41773 000098A1 [8598]                  	dw	DIR_SW_NEG_L	;M010
 41774 000098A3 [8298]                  	dw	DIR_SW_L	;M010
 41775 000098A5 [6298]                  	dw	DIR_SW_NEG_O
 41776 000098A7 [4F98]                  	dw	DIR_SW_O
 41777 000098A9 [5E98]                  	dw	DIR_SW_NEG_A
 41778 000098AB [4C98]                  	dw	DIR_SW_A
 41779                                  
 41780                                  ; PARSE BLOCK FOR RENAME
 41781                                  
 41782                                  ; The following parse control block can be used for any command which
 41783                                  ; needs only two required file specifications as operands. Returns
 41784                                  ; pointers to the unverified string in PARSE1_OUTPUT.
 41785                                  ; Currently used for the RENAME internal command.
 41786                                  
 41787                                  PARSE_RENAME:
 41788 000098AD [B098]                  	dw	RENAME_PARMS		;AN000;
 41789 000098AF 00                      	db	0			;AN000;  no extra delimiter
 41790                                  RENAME_PARMS:
 41791 000098B0 0202                    	db	2,2			;AN000;  2 positional parms
 41792 000098B2 [7A97]                  	dw	FILE_REQUIRED		;AN000;
 41793 000098B4 [7A97]                  	dw	FILE_REQUIRED		;AN000;
 41794 000098B6 00                      	db	0			;AN000;  no switches
 41795 000098B7 00                      	db	0			;AN000;  no keywords
 41796                                  
 41797                                  ; PARSE BLOCK FOR CTTY
 41798                                  
 41799                                  ; The following parse control block can be used for any command which
 41800                                  ; needs one required device name as an operand. Returns a pointer to
 41801                                  ; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
 41802                                  ; internal command.
 41803                                  
 41804                                  PARSE_CTTY:
 41805 000098B8 [BB98]                  	dw	CTTY_PARMS		;AN000;
 41806 000098BA 00                      	db	0			;AN000;  no extra delimiter
 41807                                  CTTY_PARMS:
 41808 000098BB 0101                    	db	1,1			;AN000;  1 positional parm
 41809 000098BD [C198]                  	dw	CTTY_CONTROL1		;AN000;
 41810 000098BF 00                      	db	0			;AN000;  no switches
 41811 000098C0 00                      	db	0			;AN000;  no keywords
 41812                                  CTTY_CONTROL1:
 41813 000098C1 0020                    	dw	2000h			;AN000;  string value - required
 41814 000098C3 1100                    	dw	11h			;AN000;  capitalize - file table
 41815                                  					;AN000;  remove colon at end
 41816 000098C5 [E1A9]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 41817 000098C7 [7797]                  	dw	NO_VALUES		;AN000;
 41818 000098C9 00                      	db	0			;AN000;  no keywords
 41819                                  
 41820                                  ; PARSE BLOCK FOR VER
 41821                                  
 41822                                  ; The following parse control block can be used for any command which
 41823                                  ; needs an optional switch "/debug". Currently used for the VER command.
 41824                                  
 41825                                  PARSE_VER:
 41826 000098CA [CD98]                  	dw	VER_PARMS
 41827 000098CC 00                      	db	0			; no extra delimiters
 41828                                  VER_PARMS:
 41829 000098CD 0000                    	db	0,0			; no positional parameters
 41830                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 41831                                  %if 0	; PCDOS 7.1 (& MSDOS 5.0-6.22) COMMAND.COM 
 41832                                  	db	1			; one switch
 41833                                  	dw	SLASH_R
 41834                                  %else
 41835                                  	; 20/07/2024 - Retro DOS v4-v5 COMMAND.COM
 41836 000098CF 02                      	db	2			; two switches
 41837 000098D0 [D598]                  	dw	SLASH_R
 41838 000098D2 [E198]                  	dw	SLASH_T ; Retro DOS v4-v5 COMMAND.COM switch
 41839                                  %endif
 41840 000098D4 00                      	db	0			; no keywords
 41841                                  SLASH_R:
 41842 000098D5 0000                    	dw	0			; no values
 41843 000098D7 0200                    	dw	2			; capitalize by filename table
 41844 000098D9 [E1A9]                  	dw	PARSE1_OUTPUT		; result buffer
 41845 000098DB [7797]                  	dw	NO_VALUES		; no values
 41846 000098DD 01                      	db	1			; one synonym
 41847                                  SLASH_R_SYN:
 41848 000098DE 2F5200                  	db	"/R",0
 41849                                  
 41850                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 41851                                  %if 1
 41852                                  SLASH_T:
 41853 000098E1 0000                    	dw	0			; no values
 41854 000098E3 0200                    	dw	2			; capitalize by filename table
 41855 000098E5 [E1A9]                  	dw	PARSE1_OUTPUT		; result buffer
 41856 000098E7 [7797]                  	dw	NO_VALUES		; no values
 41857 000098E9 01                      	db	1			; one synonym
 41858                                  SLASH_T_SYN:
 41859 000098EA 2F5400                  	db	"/T",0
 41860                                  %endif
 41861                                  
 41862                                  ; M003 ; Start of changes for LoadHigh support
 41863                                  
 41864                                  ;Parse Control Block for LOADHIGH command
 41865                                  
 41866                                  Parse_LoadHi:
 41867 000098ED [F098]                  	dw	LoadHi_Parms		;extended parm table
 41868 000098EF 00                      	db	0			;no extra delimiters
 41869                                  
 41870                                  LoadHi_Parms:
 41871 000098F0 0101                    	db	1,1			;min. 1 parm, max. 1 parm
 41872 000098F2 [7A97]                  	dw	FILE_REQUIRED		;control struc for filename
 41873 000098F4 00                      	db	0			;no switches
 41874 000098F5 00                      	db	0			;no keywords
 41875                                  
 41876                                  ; M003 ; End of changes for LoadHigh support
 41877                                  
 41878                                  TempVarName:
 41879 000098F6 54454D503D00            	db	"TEMP=",0
 41880                                  
 41881                                  	; 16/04/2023 - Retro DOS v4.0 (MSDOS 5.0) COMMAND.COM
 41882                                  ;TRANDATAEND:		; TRANGROUP:88C2h
 41883                                  
 41884                                  	; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 41885                                  copycmd:
 41886 000098FC 434F5059434D443D        	db 'COPYCMD='
 41887                                  sCVFRoot:
 41888 00009904 5C44424C5350414345-     	db '\DBLSPACE.'
 41888 0000990D 2E                 
 41889                                  
 41890                                  ; ---------------------------------------------------------------------------
 41891                                  ; 20/07/2024 - Retro DOS v4.2 COMMAND.COM
 41892                                  %if 1
 41893 0000990E 0D0A                    RD4CMD_VER_MSG:	db 0Dh,0Ah
 41894 00009910 526574726F20444F53-     		db 'Retro DOS v4.2 COMMAND.COM'
 41894 00009919 2076342E3220434F4D-
 41894 00009922 4D414E442E434F4D   
 41895 0000992A 0D0A                    		db 0Dh,0Ah 
 41896 0000992C 32303234202D204572-     		db '2024 - Erdogan Tan'
 41896 00009935 646F67616E2054616E 
 41897 0000993E 0D0A                    		db 0Dh,0Ah
 41898 00009940 24                      		db '$'
 41899                                  %endif
 41900                                  ; ---------------------------------------------------------------------------
 41901                                  
 41902                                  	; 18/06/2023
 41903                                  	; MSDOS 6.22 COMMAND.COM
 41904                                  TRANDATAEND:		; TRANGROUP:9E53h
 41905                                  
 41906                                  ;============================================================================
 41907                                  ; PSDATA.INC, MSDOS 6.0, 1991
 41908                                  ;============================================================================
 41909                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41910                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 41911                                  
 41912                                  ; 18/04/2023
 41913                                  TRANSPACESTART:
 41914                                  
 41915                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h
 41916                                  	
 41917                                  	; 18/06/2023
 41918                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9E53h
 41919                                  
 41920                                  ;********************** Local Data *************************************
 41921                                  
 41922                                  $P_ORDINAL:
 41923 00009941 0000                    	dw	0		;AN000; Operand ordinal save area
 41924                                  $P_RC:
 41925 00009943 0000                    	dw	0		;AN000; Return code from parser
 41926                                  $P_SI_Save:
 41927 00009945 0000                    	dw	0		;AN000; Pointer of command buffer
 41928                                  $P_DX:
 41929 00009947 0000                    	dw	0		;AN000; Return result buffer address
 41930                                  $P_Terminator:
 41931 00009949 00                      	db	0		;AN000; Terminator code (ASCII)
 41932                                  $P_DBCSEV_OFF:
 41933 0000994A 0000                    	dw	0		;AN000; Offset of DBCS EV
 41934                                  $P_DBCSEV_SEG:
 41935 0000994C 0000                    	dw	0		;AN000; Segment of DBCS EV
 41936                                  $P_Flags:			;AN000; Parser internal flags
 41937                                  $P_Flags1:
 41938 0000994E 00                      	db	0		;AN038; to reference first byte flags
 41939                                  $P_Flags2:
 41940 0000994F 00                      	db	0		;AN038; to reference second byte flags only
 41941                                  $P_SaveSI_Cmpx:
 41942 00009950 0000                    	dw	0		;AN000; save si for later use by complex
 41943                                  $P_KEYorSW_Ptr:
 41944 00009952 0000                    	dw	0		;AN000; points next to "=" or ":" code
 41945                                  $P_Save_EOB:
 41946 00009954 0000                    	dw	0		;AN000; save pointer to EOB
 41947                                  $P_Found_SYNONYM:
 41948 00009956 0000                    	dw	0		;AN000; es:@ points to found synonym
 41949                                  $P_STRING_BUF:
 41950 00009958 00<rep 80h>             	times  128 db 0		;AN000; Pick a operand from command line
 41951                                  $P_ORIG_ORD:
 41952 000099D8 0000                    	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
 41953                                  $P_ORIG_STACK:
 41954 000099DA 0000                    	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
 41955                                  $P_ORIG_SI:
 41956 000099DC 0000                    	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
 41957                                  $P_Got_Time:
 41958 000099DE 00                      	db	0		;AN023; if 1, use Time delimiters
 41959                                  $P_Country_Info:
 41960 000099DF FFFF                    	dw	-1 ; 0FFFFh
 41961 000099E1 00<rep 20h>             	times	32 db 0	
 41962                                  $P_1st_Val:
 41963 00009A01 0000                    	dw	0		;AN000; used when process date or time
 41964                                  $P_2nd_Val:
 41965 00009A03 0000                    	dw	0		;AN000; used when process date or time
 41966                                  $P_3rd_Val:
 41967 00009A05 0000                    	dw	0		;AN000; used when process date or time
 41968                                  $P_4th_Val:
 41969 00009A07 0000                    	dw	0		;AN000; used when process date or time
 41970                                  $P_Char_CAP_Ptr:
 41971 00009A09 FF                      	db	0FFh		;AN000; info id
 41972 00009A0A 0000                    	dw	0		;AN000; offset	of char case map table
 41973 00009A0C 0000                    	dw	0		;AN000; segment of char case map table
 41974                                  $P_File_CAP_Ptr:
 41975 00009A0E FF                      	db	0FFh		;AN000; info id
 41976 00009A0F 0000                    	dw	0		;AN000; offset	of file case map table
 41977 00009A11 0000                    	dw	0		;AN000; segment of file case map table
 41978                                  
 41979                                  	; 18/04/2023
 41980                                  ;M029
 41981                                  ;!!!WARNING!!!
 41982                                  ; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
 41983                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 41984                                  ;changes need to be made in SYSPARSE
 41985                                  
 41986                                  $P_FileSp_Char:
 41987 00009A13 5B5D7C3C3E2B3D3B22      	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 41988                                  $P_FileSp_Len equ $-$P_FileSp_Char ;AN000;
 41989                                  
 41990                                  ;filespec error flag
 41991                                  $P_err_flag:
 41992 00009A1C 00                      	db	0		;AN033; flag set if filespec parsing error
 41993                                  				;AN033;  was detected.
 41994                                  
 41995                                  ;============================================================================
 41996                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 41997                                  ;============================================================================
 41998                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 41999                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42000                                  
 42001                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh
 42002                                  
 42003                                  	; 18/06/2023
 42004                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9F2Fh
 42005                                  
 42006                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 42007                                  ;;
 42008                                  ;; STRUCTURE: $M_RES_ADDRS
 42009                                  ;;
 42010                                  ;; Resident data area definition of variables
 42011                                  ;;
 42012                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 42013                                  
 42014                                  $M_RT:
 42015 00009A1D 00<rep 8Dh>             	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0
 42016                                  
 42017                                  ;============================================================================
 42018                                  ; COPYRIGHT.INC, MSDOS 6.0, 1993
 42019                                  ;============================================================================
 42020                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 42021                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42022                                  
 42023                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
 42024                                  ; ---------------------------------------------------------------------------
 42025                                  ;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
 42026                                  ;;M031 - changed copyright to 1991
 42027                                  ;;9/16 - changed version to 6.0 and copyright to 1992
 42028                                  ;;9/21 - Added international translations, language passed through COUNTRY macro
 42029                                  ;;B49,50 - changed version to 6 and copyright to 1993
 42030                                  ; ---------------------------------------------------------------------------
 42031                                  	
 42032                                  	; 18/06/2023
 42033                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:9FBCh
 42034                                  ;ifdef USA
 42035                                  MsDosVer6_CCopy:
 42036                                  	; MSDOS 6.0
 42037                                  	;db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
 42038                                  	; 18/06/2023
 42039                                  	; MSDOS 6.22
 42040 00009AAA 4D5320444F53205665-     	db	"MS DOS Version 6 (C)Copyright 1981-1994 Microsoft Corp "
 42040 00009AB3 7273696F6E20362028-
 42040 00009ABC 4329436F7079726967-
 42040 00009AC5 687420313938312D31-
 42040 00009ACE 393934204D6963726F-
 42040 00009AD7 736F667420436F7270-
 42040 00009AE0 20                 
 42041 00009AE1 4C6963656E73656420-     	db	"Licensed Material - Property of Microsoft "
 42041 00009AEA 4D6174657269616C20-
 42041 00009AF3 2D2050726F70657274-
 42041 00009AFC 79206F66204D696372-
 42041 00009B05 6F736F667420       
 42042 00009B0B 416C6C207269676874-     	db	"All rights reserved "
 42042 00009B14 732072657365727665-
 42042 00009B1D 6420               
 42043                                  ;endif
 42044                                  
 42045                                  ; ---------------------------------------------------------------------------
 42046                                  ; 18/06/2023
 42047                                  ; 15/04/2023
 42048                                  ;MsDosVer5_CCopy:
 42049                                  	;db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
 42050                                  	;db	"Licensed Material - Property of Microsoft "
 42051                                  	;db	"All rights reserved "
 42052                                  ; ---------------------------------------------------------------------------
 42053                                  ; 15/04/2023
 42054                                  	; 16/04/2023 - 21/04/2023
 42055                                  	;db 	0
 42056                                  	;db	0Dh,0Ah
 42057                                  	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
 42058                                  	;db	0
 42059                                  	;db	'by Erdogan Tan - 05/05/2023'
 42060                                  	;db	0
 42061                                  
 42062                                  	; 19/06/2023
 42063                                  	; 18/06/2023
 42064                                  	;db 	0
 42065                                  	;db	0Dh,0Ah
 42066                                  	;db	'Retro DOS v4.2 COMMAND.COM '
 42067                                  	;db	0
 42068                                  	;db	'by Erdogan Tan - 19/6/2023'
 42069                                  	;db	0
 42070                                  
 42071                                  ;============================================================================
 42072                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 42073                                  ;============================================================================
 42074                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 42075                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42076                                  
 42077                                  PRINTF_HANDLE:
 42078 00009B1F 0000                    	dw	0		;AC000;
 42079                                  
 42080                                  ;============================================================================
 42081                                  ; TSPC.ASM, MSDOS 6.0, 1991
 42082                                  ;============================================================================
 42083                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 42084                                  ; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42085                                  
 42086                                  ;TITLE	COMMAND Transient Uninitialized DATA
 42087                                  
 42088                                  ;The TRANSPACE segment contains variable data that is considered
 42089                                  ;volatile between command cycles, and therefore is not included in the
 42090                                  ;transient checksum area. Contents of these variables MUST be
 42091                                  ;initialized before use, and must not be relied upon from command
 42092                                  ;cycle to command cycle.
 42093                                  ;
 42094                                  ;No constant data values should be stored here.
 42095                                  
 42096                                  ; ---------------------------------------------------------------------------
 42097                                  ; START OF UNITIALIZED DATA
 42098                                  ; ---------------------------------------------------------------------------
 42099                                  
 42100                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h
 42101                                  
 42102                                  	; 18/06/2023
 42103                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A033h
 42104                                  
 42105 00009B21 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 42106 00009B78 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 42107 00009BCF 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 42108 00009C52 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 42109 00009CD5 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 42110 00009D1B 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 42111 00009D9E 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 42112                                  
 42113                                  ; Variables passed up from resident	; in the Resident portion: (initial values)
 42114                                  HEADCALL:
 42115 00009DF1 0000                    	dw 0			; TRANVARS  (dw THEADFIX)
 42116 00009DF3 0000                    RESSEG:	dw 0			; MYSEG     (dw 0)
 42117 00009DF5 0000                    TPA:	dw 0			; LTPA	    (dw 0)
 42118                                  SWITCHAR:
 42119 00009DF7 00                      	db 0			; RSWITCHAR (db '-')
 42120                                  DIRCHAR:
 42121 00009DF8 00                      	db 0			; RDIRCHAR  (db '/')
 42122                                  EXEC_ADDR:
 42123 00009DF9 00000000                	dd 0			; 	    (dw EXT_EXEC)
 42124                                  				; MYSEG1    (dw 0)
 42125                                  RCH_ADDR:
 42126 00009DFD 00000000                	dd 0			;	    (dw TREMCHECK)
 42127                                  				; MYSEG2    (dw 0)
 42128                                  ; 14/08/2024 - PCDOS 7.1 COMMAND.COM
 42129                                  %if 0
 42130                                  	dw 0			; RESTEST   (dw 0)
 42131                                  %endif
 42132                                  
 42133                                  TRAN_TPA:
 42134 00009E01 0000                    	dw 0			; RES_TPA   (dw 0)
 42135                                  
 42136 00009E03 00                      CHKDRV:	db 0
 42137                                  IFNOTFLAG:
 42138                                  FILTYP:
 42139 00009E04 00                      RDEOF:	db 0			; Misc flags
 42140 00009E05 00                      CURDRV:	db 0
 42141                                  PARM1:
 42142 00009E06 00                      Concat:	db 0
 42143                                  PARM2:
 42144 00009E07 00                      ArgC:	db 0
 42145 00009E08 0000                    COMSW:	dw 0			; Switches between command and 1st arg
 42146 00009E0A 0000                    ARG1S:	dw 0			; Switches between 1st and 2nd arg
 42147                                  ARG2S:				; Switches after 2nd arg
 42148                                  DestSwitch:
 42149 00009E0C 0000                    	dw 0
 42150                                  ARGTS:
 42151                                  AllSwitch:
 42152 00009E0E 0000                    	dw 0			; ALL switches except for COMSW
 42153 00009E10 00                      CFLAG:	db 0
 42154                                  DestClosed:
 42155                                  SPECDRV:
 42156 00009E11 00                      	db 0
 42157 00009E12 0000                    BYTCNT:	dw 0			; Size of buffer between RES and TRANS
 42158                                  
 42159                                  ; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 42160                                  ;ifdef DBLSPACE_HOOKS
 42161                                  savBytCnt: ; MSDOS 6.0
 42162 00009E14 0000                    	dw 0
 42163                                  ;endif
 42164                                  	
 42165 00009E16 0000                    NXTADD:	dw 0
 42166                                  FRSTSRCH:
 42167 00009E18 00                      	db 0
 42168                                  ; 15/04/2023
 42169                                  LeftOnLine:
 42170 00009E19 00                      	db 0			; entries left on line u.b. DIR
 42171                                  PerLine:
 42172 00009E1A 00                      	db 0			; entries/line u.b. DIR
 42173                                  
 42174                                  ; 14/08/2024
 42175                                  %if 0
 42176                                  LINCNT:	db 0
 42177                                  LINLEN:	db 0
 42178                                  %endif
 42179                                  
 42180                                  LeftOnPage:
 42181 00009E1B 0000                    	dw 0			; lines left on page u.b. DIR
 42182                                  FileCnt:
 42183 00009E1D 0000                    	dw 0			; file count u.b. DIR
 42184                                  FileSiz:
 42185 00009E1F 00000000                	dd 0			; file size u.b. DIR
 42186                                  
 42187                                  ; Note: keep FileCntTotal through csecUsedTotal together!
 42188                                  
 42189                                  FileCntTotal:
 42190 00009E23 00000000                	dd 0			; total file count u.b. DIR
 42191                                  FileSizTotal:
 42192 00009E27 00000000                	dd 0			; total file size u.b. DIR
 42193                                  
 42194                                  	; 18/06/2023 - Retro DOS v4.2 (MSDOS 6.22) COMMAND.COM
 42195                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A33Fh
 42196                                  	; MSDOS 6.0
 42197                                  ;ifdef DBLSPACE_HOOKS
 42198                                  ccluUsed:
 42199 00009E2B 0000                    	dw 0			; count of DOS clusters used
 42200                                  ccluUsedDir:
 42201 00009E2D 0000                    	dw 0
 42202                                  ccluUsedTotal:
 42203 00009E2F 0000                    	dw 0
 42204                                  csecUsed:
 42205 00009E31 00000000                	dd 0			; count of comp sectors used
 42206                                  csecUsedDir:
 42207 00009E35 00000000                	dd 0
 42208                                  csecUsedTotal:
 42209 00009E39 00000000                	dd 0
 42210                                  
 42211                                  ; Note:  keep FileCntTotal through csecUsedTotal together!
 42212                                  
 42213                                  fhCVF:
 42214 00009E3D 0000                    	dw 0			; Compressed Volume File handle
 42215                                  szCVF:
 42216 00009E3F 00<rep 10h>             	times	16 db 0		; "X:\\12345678.123\0"
 42217                                  MDBPB:
 42218                                  	;MD_BPB	<>		; Extended MagicDrv BPB
 42219 00009E4F 00<rep 40h>             	times	64 db 0
 42220                                  csecPerCluster:
 42221 00009E8F 00                      	db 0			; sectors/cluster for ratio calc
 42222                                  fUseHostSize:
 42223 00009E90 00                      	db 0			; NZ if using host cluster size
 42224                                  cFATEntries:
 42225 00009E91 0000                    	dw 0			; # FAT entries in buffers
 42226                                  entInBuf:
 42227 00009E93 0000                    	dw 0			; 1st entry # in FAT buffers
 42228                                  segFATBuf:
 42229 00009E95 0000                    	dw 0			; seg of DOS & MD FAT buffers
 42230                                  pbufDOSFAT:
 42231 00009E97 0000                    	dw 0			; off of DOS FAT buffer
 42232                                  pbufMDFAT:
 42233 00009E99 0000                    	dw 0			; off of MD FAT buffer
 42234                                  bufDOSFAT:
 42235                                  	;times (cRES_FAT_ENTRIES*2) db 0
 42236 00009E9B 00<rep 40h>             	times 64 db 0	 	; small DOS FAT buffer
 42237                                  bufMDFAT:
 42238                                  	;times (cRES_FAT_ENTRIES*4) db 0
 42239 00009EDB 00<rep 80h>             	times 128 db 0		; small MD FAT buffer
 42240                                  ;endif
 42241                                  
 42242                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
 42243                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A46Fh
 42244                                  CHARBUF:
 42245 00009F5B 00<rep 50h>             	times	80 db 0		;line byte character buffer for xenix write
 42246                                  DESTFCB2:
 42247 00009FAB 00                      IDLEN:	db 0
 42248 00009FAC 00<rep 8h>              ID:	times	8  db 0
 42249 00009FB4 00<rep 3h>              COM:	times	3  db 0
 42250 00009FB7 00<rep 25h>             DEST:	times	37 db 0
 42251                                  DESTNAME:
 42252 00009FDC 00<rep Bh>              	times	11 db 0
 42253                                  DESTDIR:
 42254                                  DestFcb:
 42255 00009FE7 00<rep 43h>             	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
 42256                                  GOTOLEN: ; word
 42257                                  BWDBUF:  ; byte
 42258                                  EXEFCB:  ; word
 42259 0000A02A 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 42260                                  
 42261                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 42262                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 42263                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 42264                                  DIRBUF_FDATE   equ DIRBUF+32  ; word
 42265                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 42266                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 42267                                  
 42268                                  	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 42269                                  
 42270                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42271                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0A584h
 42272                                  SDIRBUF:
 42273 0000A070 00<rep Ch>              	times 12 db 0
 42274                                  _Bits:
 42275 0000A07C 0000                    	dw 0
 42276                                  PathCnt:
 42277 0000A07E 0000                    	dw 0
 42278                                  PathPos:
 42279 0000A080 0000                    	dw 0
 42280 0000A082 0000                    PathSw:	dw 0
 42281                                  AttrSpecified:
 42282 0000A084 00                      	db 0			; attribute bits u.b. DIR
 42283                                  AttrSelect:
 42284 0000A085 00                      	db 0			; attribute bits u.b. DIR
 42285 0000A086 00                      comma:	db 0			; flag set if +,, occurs
 42286                                  plus_comma:
 42287 0000A087 00                      	db 0			; flag set if +,, occurs
 42288                                  DirFlag:
 42289 0000A088 00                       	db 0			;AN015; set when pathcrunch called from DIR
 42290                                  parse_last:
 42291 0000A089 0000                    	dw 0			;AN018; used to hold parsing position
 42292                                  system_cpage:
 42293 0000A08B 0000                    	dw 0			;AC001; used for CHCP variable
 42294                                  ; 03/08/2024
 42295                                  ;Arg_Buf:
 42296                                  ;	times 128 db 0	
 42297                                  File_Size_Low:
 42298 0000A08D 0000                    	dw 0	
 42299                                  File_Size_High:
 42300 0000A08F 0000                    	dw 0		
 42301                                  string_ptr_2:
 42302 0000A091 0000                    	dw 0	
 42303                                  Copy_num:
 42304 0000A093 0000                    	dw 0
 42305                                  cpyflag:
 42306 0000A095 00                      	db 0
 42307                                  Dir_Num:
 42308 0000A096 0000                    	dw 0
 42309                                  
 42310                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42311                                  	; MSDOS 6.0
 42312                                  ;ifdef DBLSPACE_HOOKS
 42313                                  Dir_CRatio_1:
 42314 0000A098 00                      	db 0
 42315                                  Dir_CRatio_2:
 42316 0000A099 00                      	db 0
 42317                                  ;endif
 42318                                  
 42319                                  Bytes_Free:
 42320 0000A09A 00000000                	dd 0
 42321                                  
 42322                                  Major_Ver_Num:
 42323 0000A09E 0000                    	dw 0
 42324                                  Minor_Ver_Num:
 42325 0000A0A0 0000                    	dw 0
 42326                                  
 42327                                  One_Char_Val:
 42328 0000A0A2 00                      	db 0
 42329 0000A0A3 00                      	db 0
 42330                                  vol_drv:
 42331 0000A0A4 00                      	db 0
 42332                                  ROM_CALL:
 42333 0000A0A5 00                      	db 0			; flag for rom function
 42334 0000A0A6 0000                    ROM_IP:	dw 0
 42335 0000A0A8 0000                    ROM_CS:	dw 0
 42336                                  
 42337                                  DestVars:
 42338                                  DestIsDir:
 42339 0000A0AA 00                      	db 0
 42340                                  DestSiz:
 42341 0000A0AB 00                      	db 0
 42342                                  DestTail:
 42343 0000A0AC 0000                    	dw 0
 42344                                  DestInfo:
 42345 0000A0AE 00                      	db 0
 42346                                  DestBuf:
 42347 0000A0AF 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 42348                                  EndDestBuf:
 42349                                  DESTHAND:
 42350 0000A106 0000                    	dw 0
 42351                                  DESTISDEV:
 42352 0000A108 00                      	db 0
 42353                                  FIRSTDEST:
 42354 0000A109 00                      	db 0
 42355                                  MELCOPY:
 42356 0000A10A 00                      	db 0
 42357                                  MELSTART:
 42358 0000A10B 0000                    	dw 0
 42359                                  SrcVars:
 42360                                  SrcIsDir:
 42361 0000A10D 00                      	db 0
 42362 0000A10E 00                      SrcSiz:	db 0
 42363                                  SrcTail:
 42364 0000A10F 0000                    	dw 0
 42365                                  SrcInfo:
 42366 0000A111 00                      	db 0
 42367                                  SrcBuf:
 42368 0000A112 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 42369                                  SRCHAND:
 42370 0000A169 0000                    	dw 0
 42371                                  SRCISDEV:
 42372 0000A16B 00                      	db 0
 42373                                  ScanBuf:
 42374 0000A16C 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 42375                                  
 42376 0000A1C3 0000                    SRCPT:	dw 0
 42377                                  INEXACT:
 42378 0000A1C5 00                      	db 0
 42379                                  NOWRITE:
 42380 0000A1C6 00                      	db 0
 42381                                  BINARY:
 42382 0000A1C7 00                      	db 0
 42383                                  WRITTEN:
 42384 0000A1C8 0000                    	dw 0
 42385                                  TERMREAD:
 42386 0000A1CA 00                      	db 0
 42387 0000A1CB 00                      ASCII:	db 0
 42388 0000A1CC 00                      PLUS:	db 0
 42389 0000A1CD 00                      objcnt:	db 0			; Used in copy
 42390 0000A1CE 0000                    CPDATE:	dw 0
 42391 0000A1D0 0000                    CPTIME:	dw 0
 42392                                  
 42393                                  OFilePtr_Lo:
 42394 0000A1D2 0000                    	dw 0			; original file ptr for COPY when
 42395                                  OFilePtr_Hi:
 42396 0000A1D4 0000                    	dw 0			; 1st source is also destination
 42397                                  zflag:	; 10/08/2024 - PCDOS 7.1 COMMAND.COM
 42398 0000A1D6 00                      OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 42399                                  
 42400                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42401                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0A76Bh
 42402                                  cox_sublist_buff:
 42403 0000A1D7 00<rep Bh>              	times 11 db 0
 42404                                  cox_y_override:
 42405 0000A1E2 00                      	db 0
 42406                                  cox_dest_file:
 42407 0000A1E3 00                      	db 0
 42408                                  cox_src_file:
 42409 0000A1E4 00                      	db 0
 42410                                  
 42411                                  	; (MSDOS 6.22 COMMAND.COM - TRANGROUP:0A779h)
 42412                                  BATHAND:
 42413 0000A1E5 0000                    	dw 0			; Batch handle
 42414                                  STARTEL:
 42415 0000A1E7 0000                    	dw 0
 42416 0000A1E9 00                      ELCNT:	db 0
 42417 0000A1EA 00                      ELPOS:	db 0
 42418                                  
 42419                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 42420                                  ; MSDOS 5.0
 42421                                  SKPDEL:
 42422                                  	; 18/06/2023
 42423 0000A1EB 00                      	db 0	; MSDOS 6.22 (& MSDOS 5.0)
 42424 0000A1EC 00<rep Bh>              SOURCE:	times 11 db 0
 42425                                  
 42426                                  ext_entered:
 42427 0000A1F7 00                      	db 0			;AN005;
 42428                                  
 42429                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh
 42430                                  
 42431                                  Display_Ioctl:
 42432 0000A1F8 00                      	db 0			;AN000; info level
 42433 0000A1F9 00                      	db 0			;AN000; reserved
 42434 0000A1FA 0E00                    	dw crt_ioctl_ln		;AN000; length of data
 42435 0000A1FC 0000                    	dw 0			;AN000; control flags
 42436                                  display_mode:
 42437 0000A1FE 00                      	db 0			;AN000; display mode, colors
 42438 0000A1FF 00                      	db 0			;AN000; reserved
 42439 0000A200 0000                    	dw 0			;AN023; colors
 42440 0000A202 0000                    	dw 0			;AN000; display width (PELS)
 42441 0000A204 0000                    	dw 0			;AN000; display length (PELS)
 42442                                  display_width:
 42443 0000A206 0000                    	dw 0			;AN000; display width
 42444                                  LinPerPag:
 42445 0000A208 1900                    	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)
 42446                                  
 42447                                  vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
 42448 0000A20A 0000                    	dw 0			;AN000; info level
 42449                                  vol_serial:
 42450 0000A20C 00000000                	dd 0			;AN000; volume serial number
 42451                                  vol_label:
 42452 0000A210 20<rep Bh>              	times 11 db 20h ; " "	;AN000; volume label - init to blanks
 42453 0000A21B 20<rep 8h>              	times 8  db 20h ; " "	;AN000; file system type
 42454                                  
 42455                                  expand_star:
 42456 0000A223 00                      	db 0
 42457                                  
 42458                                  msg_flag:
 42459 0000A224 00                      	db 0			;AN022; flag set if non-utility message issued
 42460                                  Msg_Numb:
 42461 0000A225 0000                    	dw 0			;AN022; set with extended error message issued
 42462                                  append_exec:
 42463 0000A227 00                      	db 0			;AN041; set if internal append executed
 42464                                  print_err_flag:
 42465 0000A228 0000                    	dw 0			;AN000; flag set if error during sysdispmsg
 42466                                  subst_buffer:
 42467 0000A22A 00<rep 16h>             	times parm_block_size*2 db 0 ; times 22 db 0 
 42468                                  				;AN061;
 42469                                  ; 15/04/2023
 42470 0000A240 00                      KPARSE:	db 0	; 3/3/KK
 42471                                  
 42472                                  ; Data declarations taken out of parse.asm
 42473                                  
 42474                                  ; MSDOS 6.0
 42475                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 42476                                  ;argbufptr	dw	?		; index for argv[].argpointer
 42477                                  ;tpbuf		db	128 DUP (?)	; temporary buffer
 42478                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 42479                                  ;comptr		dw	?		; ptr into combuf
 42480                                  
 42481                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
 42482                                  
 42483                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42484                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0A7D5h
 42485                                  ARG:
 42486                                  ARG_ARGV:
 42487                                  ARGV0_ARGPOINTER:
 42488 0000A241 0000                    	dw 0	; ARGV[0]
 42489                                  ARGV0_ARG_FLAGS:
 42490 0000A243 00                      	db 0
 42491                                  ARGV0_ARGSTARTEL:
 42492 0000A244 0000                    	dw 0
 42493                                  ARGV0_ARGLEN:
 42494 0000A246 0000                    	dw 0
 42495                                  ARGV0_ARGSW_WORD:
 42496 0000A248 0000                    	dw 0
 42497                                  ARGV0_OCOMPTR:
 42498 0000A24A 0000                    	dw 0
 42499                                  ARGV1_ARGPOINTER:
 42500 0000A24C 0000                    	dw 0	; ARGV[1]
 42501 0000A24E 00<rep 5h>              	times 5 db 0
 42502                                  ARGV1_ARGSW_WORD:
 42503 0000A253 0000                    	dw 0
 42504 0000A255 0000                    	dw 0
 42505                                  ARGV2_ARGPOINTER:
 42506 0000A257 0000                    	dw 0	; ARGV[2]
 42507 0000A259 00<rep 5h>              	times 5 db 0
 42508                                  ARGV2_ARGSW_WORD:
 42509 0000A25E 0000                    	dw 0
 42510 0000A260 0000                    	dw 0
 42511 0000A262 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 42512                                  ARG_ARGVCNT:
 42513 0000A501 0000                    	dw 0
 42514                                  ARG_ARGSWINFO:
 42515 0000A503 0000                    	dw 0
 42516                                  ARG_ARGBUF:
 42517 0000A505 0000<rep 100h>          	times 256 dw 0	; times ARGBLEN dw 0 
 42518                                  ARG_ARGFORCOMBUF:
 42519 0000A705 00<rep 80h>             	times 128 db 0  ; times COMBUFLEN db 0 
 42520                                  
 42521                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
 42522                                  	; 18/06/2023
 42523                                  	; MSDOS 6.22 COMMAND.COM (1994) Transient portion offset 0AD19h
 42524                                  ARGBUF_PTR:
 42525 0000A785 0000                    	dw 0			; index for argv[].argpointer
 42526                                  TPBUF:	;times 128 db 0		; temporary buffer
 42527                                  Arg_Buf:
 42528 0000A787 00<rep 80h>             	times 128 db 0	; 03/08/2024 (PCDOS 7.1 COMMAND.COM)
 42529                                  LASTARG:
 42530 0000A807 0000                    	dw 0			; point at which to accumulate switch info
 42531 0000A809 0000                    COMPTR:	dw 0			; ptr into combuf
 42532                                  
 42533                                  ; Data declarations taken out of path.asm
 42534                                  ;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
 42535                                  ;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
 42536                                  ;psep_char	DB	?		; '/' or '\'
 42537                                  ;search_best	DB	(?)		; best code, best filename so far
 42538                                  ;fname_max_len	equ	13
 42539                                  ;search_best_buf DB	fname_max_len DUP (?)
 42540                                  ;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
 42541                                  ;search_error	DW	(?)		; address of error message to be printed
 42542                                  
 42543                                  FINDBUFLEN equ FIND_BUF.size ; 43
 42544                                  
 42545                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh
 42546                                  
 42547                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42548                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0AD9Fh
 42549                                  
 42550 0000A80B 00<rep 2Bh>             FBUF:	times FINDBUFLEN db 0	; times 43 db 0
 42551                                  FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
 42552                                  pathinfo:
 42553                                  ;pathinfo_0:
 42554 0000A836 0000                    	dw 0
 42555                                  ;pathinfo_2:
 42556 0000A838 0000                    	dw 0
 42557                                  ;pathinfo_4:
 42558 0000A83A 0000                    	dw 0
 42559                                  psep_char:
 42560 0000A83C 00                      	db 0
 42561                                  search_best:
 42562 0000A83D 00                      	db 0
 42563                                  FNAME_MAX_LEN equ 13
 42564                                  search_best_buf:
 42565 0000A83E 00<rep Dh>              	times FNAME_MAX_LEN db 0 ; times 13 db 0
 42566                                  search_curdir_buf:
 42567 0000A84B 00<rep 40h>             	times 64 db 0
 42568                                  search_error:
 42569 0000A88B 0000                    	dw 0
 42570                                  
 42571                                  ; Data declarations taken out of tbatch.asm
 42572                                  
 42573                                  ;if_not_count	DW	?
 42574                                  ;
 42575                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 42576                                  ;
 42577                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 42578                                  
 42579                                  ; 31/03/2023
 42580                                  ;STACK:	;LABEL	WORD
 42581                                  
 42582                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h
 42583                                  
 42584                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42585                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0AE21h
 42586                                  
 42587                                  IF_NOT_COUNT:
 42588 0000A88D 0000                    	dw 0
 42589                                  ; 10/08/2024
 42590                                  ;zflag:	db 0
 42591                                  
 42592 0000A88F 90                      align 2 ; 18/06/2023
 42593                                  
 42594 0000A890 00<rep 100h>            	times 256 db 0
 42595                                  
 42596                                  	; 16/04/2023
 42597                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
 42598                                  
 42599                                  	; 18/06/2023 - Retro DOS v4.2 COMMAND.COM
 42600                                  	; MSDOS 6.22 COMMAND.COM - TRANGROUP:0AF24h
 42601                                  STACK:
 42602                                  
 42603                                  ;INTERNATVARS	internat_block <>
 42604                                  ;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 42605                                  
 42606                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
 42607                                  INTERNATVARS:
 42608                                  		; (24+8 = 32 bytes)
 42609                                  DATE_TIME_FORMAT:
 42610 0000A990 0000                    	dw 0			; 0-USA, 1-EUR, 2-JAP
 42611                                  CURRENCY_SYM:
 42612 0000A992 0000000000              	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 42613                                  THOUS_SEP:
 42614 0000A997 0000                    	db 0,0			; Thousands separator 2 bytes
 42615                                  DECIMAL_SEP:
 42616 0000A999 0000                    	db 0,0			; Decimal separator 2 bytes
 42617                                  DATE_SEP:
 42618 0000A99B 0000                    	db 0,0			; Date separator 2 bytes
 42619                                  TIME_SEP:
 42620 0000A99D 0000                    	db 0,0			; Time separator 2 bytes
 42621                                  BIT_FIELD:
 42622 0000A99F 00                      	db 0			; Bit values
 42623                                  				;   Bit 0 = 0 if currency symbol first
 42624                                  				;	  = 1 if currency symbol last
 42625                                  				;   Bit 1 = 0 if No space after currency symbol
 42626                                  				;	  = 1 if space after currency symbol
 42627                                  CURRENCY_CENTS:
 42628 0000A9A0 00                      	db 0			; Number of places after currency dec point
 42629                                  TIME_24:
 42630 0000A9A1 00                      	db 0			; 1 if 24 hour time, 0 if 12 hour time
 42631                                  MAP_CALL:
 42632 0000A9A2 00000000                	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 42633                                  				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 42634                                  				;  in pieces.
 42635                                  DATA_SEP:
 42636 0000A9A6 0000                    	db 0,0			; Data list separator character
 42637                                  
 42638 0000A9A8 00<rep 8h>              	times 8 db 0
 42639                                  
 42640                                  ; Max size of the block returned by the INTERNATIONAL call
 42641                                  
 42642                                  INTERNAT_BLOCK_SIZE EQU	32
 42643                                  
 42644                                  ;;	Buffer for DOS function 64h (Get extended country information)
 42645                                  ;;	subfunctions 2, 4, 6, or 7:
 42646                                  ;
 42647                                  ;CountryPtrInfo	label	byte
 42648                                  ;CountryPtrId	db	?
 42649                                  ;CountryPtr	dd	?
 42650                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 42651                                  	
 42652                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
 42653                                  CountryPtrInfo:
 42654                                  CountryPtrId:	
 42655 0000A9B0 00                      	db 0
 42656                                  CountryPtr:
 42657 0000A9B1 00000000                	dd 0
 42658                                  
 42659                                  OldCtrlCHandler:
 42660 0000A9B5 00000000                	dd 0			; previous int 23 vector
 42661                                  
 42662                                  BATLEN equ 32
 42663                                  
 42664                                  BATBUFPOS:
 42665 0000A9B9 0000                    	dw 0			; integer position in buffer of next byte
 42666                                  
 42667 0000A9BB 00<rep 20h>             BATBUF:	times BATLEN db 0 ; times 32 db 0
 42668                                  BATBUFEND:
 42669 0000A9DB 0000                    	dw 0
 42670                                  TypeFilSiz:
 42671 0000A9DD 00000000                	dd 0			; stores size of file to be typed
 42672                                  
 42673                                  ; *****************************************************
 42674                                  ; EMG 4.00
 42675                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 42676                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 42677                                  ; *****************************************************
 42678                                  ;
 42679                                  ; COMMON PARSE OUTPUT BLOCKS
 42680                                  
 42681                                  ; Common output blocks for PARSE number, complex, or string values.
 42682                                  
 42683                                  PARSE1_OUTPUT:
 42684                                  PARSE1_TYPE:
 42685 0000A9E1 00                      	db 0			;AN000;  type
 42686                                  PARSE1_CODE:
 42687 0000A9E2 00                      	db 0			;AN000;  return value
 42688                                  PARSE1_SYN:
 42689 0000A9E3 0000                    	dw 0			;AN000;  es offset of synonym
 42690                                  PARSE1_ADDR:
 42691 0000A9E5 00000000                	dd 0			;AN000;  numeric value / address
 42692                                  				;	 of string value
 42693                                  
 42694                                  ;  Common output block for PARSE date strings.
 42695                                  
 42696                                  DATE_OUTPUT:
 42697                                  DATE_TYPE:
 42698 0000A9E9 00                      	db 0			;AN000;  type
 42699 0000A9EA 00                      	db 0			;AN000;  return value
 42700 0000A9EB 0000                    	dw 0			;AN000;  es offset of synonym
 42701                                  DATE_YEAR:
 42702 0000A9ED 0000                    	dw 0			;AN000;  year
 42703                                  DATE_MONTH:
 42704 0000A9EF 00                      	db 0			;AN000;  month
 42705                                  DATE_DAY:
 42706 0000A9F0 00                      	db 0			;AN000;  day
 42707                                  
 42708                                  ;  Common output block for PARSE time strings.
 42709                                  
 42710                                  TIME_OUTPUT:
 42711                                  TIME_TYPE:
 42712 0000A9F1 00                      	db 0			;AN000;  type
 42713 0000A9F2 00                      	db 0			;AN000;  return value
 42714 0000A9F3 0000                    	dw 0			;AN000;  es offset of synonym
 42715                                  TIME_HOUR:
 42716 0000A9F5 00                      	db 0			;AN000;  hour
 42717                                  TIME_MINUTES:
 42718 0000A9F6 00                      	db 0			;AN000;  minutes
 42719                                  TIME_SECONDS:
 42720 0000A9F7 00                      	db 0			;AN000;  seconds
 42721                                  TIME_FRACTION:
 42722 0000A9F8 00                      	db 0			;AN000;  hundredths
 42723                                  
 42724                                  ;  Common output block for PARSE drive specifier (one based drive number).
 42725                                  
 42726                                  DRIVE_OUTPUT:
 42727                                  DRIVE_TYPE:
 42728 0000A9F9 00                      	db 0			;AN000;  type
 42729                                  DRIVE_VALUE:
 42730 0000A9FA 00                      	db 0			;AN000;  return value
 42731 0000A9FB 0000                    	dw 0			;AN000;  es offset of synonym
 42732                                  DRIVE_NUMBER:
 42733 0000A9FD 00                      	db 0			;AN000;  drive number
 42734 0000A9FE 000000                  	db 0,0,0		;AN000;  reserved
 42735                                  
 42736                                  	; 18/04/2023
 42737                                  	; 16/04/2023
 42738                                  ;TRANSPACEEND:	; 98C5h
 42739                                  		; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion
 42740                                  
 42741                                  	; 18/06/2023
 42742                                  ;TRANSPACEEND:	; 0AF95h 
 42743                                  		; End of MSDOS 6.22 COMMAND.COM (1994) Transient portion
 42744                                  
 42745                                  ; ----------------------------------------------------------------------------
 42746                                  ; 18/06/2023
 42747                                  ; 20/04/2023
 42748                                  TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
