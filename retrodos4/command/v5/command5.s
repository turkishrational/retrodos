; ****************************************************************************
; COMMAND.COM (MSDOS 5.0 Command Interpreter) - RETRO DOS v4.0 by ERDOGAN TAN
; ----------------------------------------------------------------------------
; Last Update: 14/06/2023 (v5.0) ((Previous: 20/10/2018 COMMAND.COM v3.3))
; ----------------------------------------------------------------------------
; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
; ----------------------------------------------------------------------------
; Assembler: NASM version 2.15 (2.11)
; ----------------------------------------------------------------------------
;	    ((nasm command5.s -l command5.lst -o COMMAND.COM)) 	
; ----------------------------------------------------------------------------
; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
; by Microsoft, 18/08/1983
; ****************************************************************************
; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
; in NASM syntax (by Erdogan Tan), 20/10/2018
; ----------------------------------------------------------------------------
;; 11/09/2018 - Erdogan Tan
; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
; ----------------------------------------------------------------------------
; MSDOS 6.0 source files:
;;============================================================================
; This MSDOS source code is verified & modified by using IDA Pro Disassembler
; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
;;============================================================================
;
; COMMAND.COM v6.0 source files:
;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
;
; COMMAND.COM v2.11 source files:
;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
;
; ----------------------------------------------------------------------------
; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)

;============================================================================
; SYSCALL.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;	SCCSID = @(#)syscall.asm	1.1 85/04/10
;BREAK <system call definitions>

;
;	Microsoft Confidential
;	Copyright (C) Microsoft Corporation 1991
;	All Rights Reserved.
;

;SUBTTL	system call definitions
;PAGE

Abort				EQU 0	;  0	  0
STD_CON_INPUT			EQU 1	;  1	  1
Std_Con_Output			EQU 2	;  2	  2
Std_Aux_Input			EQU 3	;  3	  3
Std_Aux_Output			EQU 4	;  4	  4
Std_Printer_Output		EQU 5	;  5	  5
Raw_Con_IO			EQU 6	;  6	  6
RAW_CON_INPUT			EQU 7	;  7	  7
Std_Con_Input_No_Echo		EQU 8	;  8	  8
STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
Std_Con_String_Input		EQU 10	; 10	  A
Std_Con_Input_Status		EQU 11	; 11	  B
STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
DISK_RESET			EQU 13	; 13	  D
Set_Default_Drive		EQU 14	; 14	  E
FCB_Open			EQU 15	; 15	  F
FCB_Close			EQU 16	; 16	 10
Dir_Search_First		EQU 17	; 17	 11
Dir_Search_Next 		EQU 18	; 18	 12
FCB_Delete			EQU 19	; 19	 13
FCB_Seq_Read			EQU 20	; 20	 14
FCB_Seq_Write			EQU 21	; 21	 15
FCB_Create			EQU 22	; 22	 16
FCB_Rename			EQU 23	; 23	 17
GET_DEFAULT_DRIVE		EQU 25	; 25	 19
Set_DMA 			EQU 26	; 26	 1A
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_Default_DPB 		EQU 31	; 31	 1F
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
FCB_Random_Read 		EQU 33	; 33	 21
FCB_Random_Write		EQU 34	; 34	 22
Get_FCB_File_Length		EQU 35	; 35	 23
Get_FCB_Position		EQU 36	; 36	 24
SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
Create_Process_Data_Block	EQU 38	; 38	 26
FCB_Random_Read_Block		EQU 39	; 39	 27
FCB_Random_Write_Block		EQU 40	; 40	 28
Parse_File_Descriptor		EQU 41	; 41	 29
Get_Date			EQU 42	; 42	 2A
Set_Date			EQU 43	; 43	 2B
Get_Time			EQU 44	; 44	 2C
Set_Time			EQU 45	; 45	 2D
SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
; Extended functionality group
Get_DMA 			EQU 47	; 47	 2F
GET_VERSION			EQU 48	; 48	 30
Keep_Process			EQU 49	; 49	 31
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Get_DPB 			EQU 50	; 50	 32
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Set_CTRL_C_Trapping		EQU 51	; 51	 33
Get_InDOS_Flag			EQU 52	; 52	 34
Get_Interrupt_Vector		EQU 53	; 53	 35
Get_Drive_Freespace		EQU 54	; 54	 36
CHAR_OPER			EQU 55	; 55	 37
International			EQU 56	; 56	 38
;   Directory Group
MKDir				EQU 57	; 57	 39
RMDir				EQU 58	; 58	 3A
CHDir				EQU 59	; 59	 3B
;   File Group
Creat				EQU 60	; 60	 3C
OPEN				EQU 61	; 61	 3D
CLOSE				EQU 62	; 62	 3E
READ				EQU 63	; 63	 3F
Write				EQU 64	; 64	 40
Unlink				EQU 65	; 65	 41
LSEEK				EQU 66	; 66	 42
CHMod				EQU 67	; 67	 43
IOCTL				EQU 68	; 68	 44
XDUP				EQU 69	; 69	 45
XDup2				EQU 70	; 70	 46
Current_Dir			EQU 71	; 71	 47
;    Memory Group
ALLOC				EQU 72	; 72	 48
DEALLOC				EQU 73	; 73	 49
SETBLOCK			EQU 74	; 74	 4A
;    Process Group
Exec				EQU 75	; 75	 4B
EXIT				EQU 76	; 76	 4C
WAITPROCESS			EQU 77	; 77	 4D
Find_First			EQU 78	; 78	 4E
;   Special Group
Find_Next			EQU 79	; 79	 4F
; SPECIAL SYSTEM GROUP
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
SET_CURRENT_PDB 		EQU 80	; 80	 50
GET_CURRENT_PDB 		EQU 81	; 81	 51
Get_In_Vars			EQU 82	; 82	 52
SetDPB				EQU 83	; 83	 53
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Get_Verify_On_Write		EQU 84	; 84	 54
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Dup_PDB 			EQU 85	; 85	 55
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
Rename				EQU 86	; 86	 56
File_Times			EQU 87	; 87	 57
AllocOper			EQU 88	; 88	 58
; Network extention system calls
GetExtendedError		EQU 89	; 89	 59
CreateTempFile			EQU 90	; 90	 5A
CreateNewFile			EQU 91	; 91	 5B
LockOper			EQU 92	; 92	 5C Lock and Unlock
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
					;	    CloseByName, CloseUser,
					;	    CloseUserProcess,
					;	    GetOpenFileList
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
UserOper			EQU 94	; 94	 5E Get and Set
AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
xNameTrans			EQU 96	; 96	 60
PathParse			EQU 97	; 97	 61
GetCurrentPSP			EQU 98	; 98	 62
Hongeul 			EQU 99	; 99	 63
ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;									   ;
Set_Printer_Flag		EQU 100 ; 100	 64
;									   ;
;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
GetExtCntry			EQU 101 ; 101	 65
GetSetCdPg			EQU 102 ; 102	 66
ExtHandle			EQU 103 ; 103	 67
Commit				EQU 104 ; 104	 68
GetSetMediaID			EQU 105 ; 105	 69
IFS_IOCTL			EQU 107 ; 107	 6B
ExtOpen 			EQU 108 ; 108	 6C
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;                                                                          ;
;ifdef ROMEXEC
;ROM_FIND_FIRST			EQU 109 ; 109    6D
;ROM_FIND_NEXT			EQU 110 ; 110    6E
;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
;endif
;                                                                          ;
;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
;
;
Set_Oem_Handler 		EQU 248 ; 248	 F8
OEM_C1				EQU 249 ; 249	 F9
OEM_C2				EQU 250 ; 250	 FA
OEM_C3				EQU 251 ; 251	 FB
OEM_C4				EQU 252 ; 252	 FC
OEM_C5				EQU 253 ; 253	 FD
OEM_C6				EQU 254 ; 254	 FE
OEM_C7				EQU 255 ; 255	 FF

;============================================================================
; DOSSYM.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;BREAK <Control character definitions>

c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
c_BS	    EQU     08h 	; ^H ASCII backspace
c_CR	    EQU     0Dh 	; ^M ASCII carriage return
c_LF	    EQU     0Ah 	; ^J ASCII linefeed
c_ETB	    EQU     17h 	; ^W ASCII end of transmission
c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
c_ETX	    EQU     03h 	; ^C ASCII end of text
c_HT	    EQU     09h 	; ^I ASCII tab

;============================================================================
; DIRENT.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;Break <Directory entry>

;	NOTE:  These offsets are also used in the DTA for
;	extended FCB SearchFirst/Next. DIR_NAME lines up
;	with the FCB filename field, and the rest of the
;	DIR_ENTRY fields follow. -DavidOls

;**	DIRENT.INC - FAT Directory Entry Definition
;
;	+---------------------------+
;	|  (12 BYTE) filename/ext   |	    0	    0
;	+---------------------------+
;	|     (BYTE) attributes     |	    11	    B
;	+---------------------------+
;	|    (10 BYTE) reserved     |	    12	    C
;	+---------------------------+
;	| (WORD) time of last write |	    22	    16
;	+---------------------------+
;	| (WORD) date of last write |	    24	    18
;	+---------------------------+
;	|   (WORD) First cluster    |	    26	    1A
;	+---------------------------+
;	|     (DWORD) file size     |	    28	    1C
;	+---------------------------+
;
;   First byte of filename  = E5 -> free directory entry
;			    = 00 -> end of allocated directory
;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
;

STRUC DIR_ENTRY
.DIR_NAME:	RESB  11	; file name
.DIR_ATTR:	RESB  1		; attribute bits
.DIR_CODEPG:	RESW  1		; code page DOS 4.00
.DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
.DIR_ATTR2:	RESB  1		; reserved
.DIR_PAD:	RESB  5		; reserved for expansion
.DIR_TIME:	RESW  1		; time of last write
.DIR_DATE:	RESW  1		; date of last write
.DIR_FIRST:	RESW  1		; first allocation unit of file
.DIR_SIZE_L:	RESW  1		; low 16 bits of file size
.DIR_SIZE_H:	RESW  1		; high 16 bits of file size
.size:

;	    Caution: An extended FCB SearchFirst/Next on a network
;	    drive under Novell Netware 286 or 386 returns the time/date
;	    in the SIZE fields for subdirectory files. Ordinarily,
;	    this field is zero for subdirectory files.

ENDSTRUC

ATTR_READ_ONLY	equ	 1h
ATTR_HIDDEN	equ	 2h
ATTR_SYSTEM	equ	 4h
ATTR_VOLUME_ID	equ	 8h
ATTR_DIRECTORY	equ	10h
ATTR_ARCHIVE	equ	20h
ATTR_DEVICE	equ	40h	; This is a VERY special bit.
				;   NO directory entry on a disk EVER
				;   has this bit set. It is set non-zero
				;   when a device is found by GETPATH

ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
				; OR of hard attributes for FINDENTRY

ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
				; ignore this(ese) attribute(s) during
				; search first/next

ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
				; changeable via CHMOD

DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot

;============================================================================
; ERROR.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;**	ERROR.INC - DOS Error Codes
;
;    The newer (DOS 2.0 and above) "XENIX-style" calls
;    return error codes through AX.	If an error occurred then
;    the carry bit will be set and the error code is in AX.	If no error
;    occurred then the carry bit is reset and AX contains returned info.
;
;    Since the set of error codes is being extended as we extend the operating
;    system, we have provided a means for applications to ask the system for a
;    recommended course of action when they receive an error.
;
;    The GetExtendedError system call returns a universal error, an error
;    location and a recommended course of action.	The universal error code is
;    a symptom of the error REGARDLESS of the context in which GetExtendedError
;    is issued.


;	2.0 error codes

error_invalid_function		EQU	1
ERROR_FILE_NOT_FOUND		EQU	2
ERROR_PATH_NOT_FOUND		EQU	3
ERROR_TOO_MANY_OPEN_FILES	EQU	4
ERROR_ACCESS_DENIED		EQU	5
error_invalid_handle		EQU	6
error_arena_trashed		EQU	7
ERROR_NOT_ENOUGH_MEMORY 	EQU	8
error_invalid_block		EQU	9
error_bad_environment		EQU	10
ERROR_BAD_FORMAT		EQU	11
error_invalid_access		EQU	12
ERROR_INVALID_DATA		EQU	13
;**** reserved			EQU	14	; *****
error_invalid_drive		EQU	15
error_current_directory 	EQU	16
error_not_same_device		EQU	17
ERROR_NO_MORE_FILES		EQU	18

;	These are the universal int 24 mappings for the old INT 24 set of errors

ERROR_WRITE_PROTECT		EQU	19
error_bad_unit			EQU	20
error_not_ready 		EQU	21
error_bad_command		EQU	22
error_CRC			EQU	23
error_bad_length		EQU	24
error_Seek			EQU	25
error_not_DOS_disk		EQU	26
error_sector_not_found		EQU	27
error_out_of_paper		EQU	28
error_write_fault		EQU	29
error_read_fault		EQU	30
ERROR_GEN_FAILURE		EQU	31

;	the new 3.0 error codes reported through INT 24

error_sharing_violation 	EQU	32
error_lock_violation		EQU	33
error_wrong_disk		EQU	34
ERROR_FCB_UNAVAILABLE		EQU	35
ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;

;	New OEM network-related errors are 50-79

error_not_supported		EQU	50

error_net_access_denied		EQU	65	;M028

;	End of INT 24 reportable errors

error_file_exists		EQU	80
error_DUP_FCB			EQU	81	; *****
error_cannot_make		EQU	82
error_FAIL_I24			EQU	83

;	New 3.0 network related error codes

error_out_of_structures 	EQU	84
error_Already_assigned		EQU	85
error_invalid_password		EQU	86
error_invalid_parameter 	EQU	87
error_NET_write_fault		EQU	88
error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;

;============================================================================
; DEVSYM.INC, MSDOS 6.0, 1991
;============================================================================
; 22/09/2018 - Retro DOS v3.0

;**	DevSym.inc - Device Symbols

;	THE DEVICE TABLE LIST HAS THE FORM:

STRUC SYSDEV
.NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
.ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
.STRAT:	RESW 1			;STRATEGY ENTRY POINT
.INT:	RESW 1			;INTERRUPT ENTRY POINT
.NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
.size:
ENDSTRUC

; 24/09/2018
DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK

;============================================================================
; CURDIR.INC, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings

;============================================================================
; COMEQU.ASM, MSDOS 6.0, 1991
;============================================================================
; 21/09/2018 - Retro DOS v3.0

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;	SCCSID = @(#)comequ.asm 1.1 85/05/14
;*************************************
; COMMAND EQUs which are not switch dependant

;		include	curdir.inc	; to get DIRSTRLEN
;		Note dossym.inc must already have been included!

GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND

SYM		EQU	">"

LINESPERPAGE	EQU	25		;AC000; default lines per page

NORMPERLIN	EQU	1
WIDEPERLIN	EQU	5
COMBUFLEN	EQU	128		; Length of commmand buffer
BatLen		EQU	32		; buffer for batch files
YES_ECHO	EQU	1		; echo line
NO_ECHO 	EQU	0		; don't echo line
No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
call_in_progress EQU	1		; indicate we're in the CALL command
length_call	EQU	4		; length of CALL
max_nest	EQU    10		; max # levels of batch nesting allowed
FAIL_ALLOWED	EQU    00001000b	; critical error
RETRY_ALLOWED	EQU    00010000b	; critical error
IGNORE_ALLOWED	EQU    00100000b	; critical error
nullcommand	EQU     1		; no command on command line
END_OF_LINE	EQU    -1		;AN000; end of line return from parser
END_OF_LINE_OUT EQU	0		;AN000; end of line for output
END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
result_number	EQU	1		;AN000; number returned from parser
result_string	EQU	3		;AN000; string returned from parser
RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
result_drive	EQU	6		;AN000; drive returned from parser
result_date	EQU	7		;AN000; date returned from parser
result_time	EQU	8		;AN000; time returned from parser
RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
no_cont_flag	EQU	0		;AN000; no control flags for message
util_msg_class	EQU	-1		;AN000; message class for utility
ext_msg_class	EQU	1		;AN000; message class for extended error
parse_msg_class EQU	2		;AN000; message class for parse error
crit_msg_class	EQU	3		;AN000; message class for critical error
ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
colon_char	EQU	":"             ;AN000; colon character
crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
text_mode	EQU	1		;AN000; text mode return from ioctl
get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
%define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
parm_block_size equ	11		;AN000; size of message subst block
blank		equ	" "             ;AN000; blank character
no_subst	equ	0		;AN000; no substitutions for messages
one_subst	equ	1		;AN000; one substitution for messages
no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
res_subst	equ	2		;AN000; offset from start of message definition to number of subst
read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
capital_A	equ	'A'             ;AC000;
vbar		equ	'|'             ;AC000;
labracket	equ	'<'             ;AC000;
rabracket	equ	'>'             ;AC000;
dollar		equ	'$'             ;AC000;
lparen		equ	'('             ;AC000;
rparen		equ	')'             ;AC000;
nullrparen	equ	29h		;AC000;
in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
star		equ	'*'             ;AC000;
plus_chr	equ	'+'             ;AC000;
small_a 	equ	'a'             ;AC000;
small_z 	equ	'z'             ;AC000;
dot_chr 	equ	'.'             ;AC000;
tab_chr 	equ	9		;AN032;
equal_chr	equ	'='             ;AN032;
semicolon	equ	';'             ;AN049;
dot_qmark	equ	2e3fh		;AC000; '.?'
dot_colon	equ	2e3ah		;AC000; '.:'
capital_n	equ	0		;AC000; result from Y/N call if N entered
capital_y	equ	1		;AC000; result from Y/N call if Y entered
AppendInstall	equ	0B700H		;AN020; append install check
AppendDOS	equ	0B702H		;AN020; append DOS version check
AppendGetState	equ	0B706H		;AN020; append get current state
AppendSetState	equ	0B707H		;AN020; append set current state
AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;

;*************************************
;* PARSE ERROR MESSAGES
;*************************************

MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number

;*************************************
;* EQUATES FOR MESSAGE RETRIEVER
;*************************************

GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever

;*********************************
;* EQUATES FOR INT 10H
;*********************************

VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white

AltPipeChr	equ	"|"             ; alternate pipe character

FCB		equ	5Ch

STRUC VARSTRUC
.ISDIR:		RESB	1
.SIZ:		RESB	1
.TTAIL:		RESW	1
.INFO:		RESB	1
.BUF:		RESB	DIRSTRLEN + 20
.size:
ENDSTRUC
;
; Flags for internal command parsing
;
fCheckDrive	equ	00000001b	; validate drive letter
fSwitchAllowed	equ	00000010b	; switches allowed
fLimitHelp	equ	00000100b	; /? must appear alone

;
; Test switches
;
fParse		EQU	0001h		; display results of parseline

;
; Batch segment structure
;
;   BYTE    type of segment
;   BYTE    echo state of parent on entry to batch file
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters. -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;

BATCHTYPE   equ 0

STRUC BATCHSEGMENT
.BatType:	RESB	1		; signature
.BatEchoFlag:	RESB	1		; G state of echo
; MSDOS 5.0 (& 6.0) - 11/01/2023
.BatchEOF:	RESB	1		; records if EOF reached on file
.BatLast: 	RESW	1		; G segment of last batch file
.BatForPtr:	RESW	1		; G segment for FOR command
.BatForFlag:	RESB	1		; G state of FOR
.BatSeek:	RESD	1		; lseek position of next char
.BatParm:	RESW	10		; pointers to parameters
.BatFile:	RESB	1		; beginning of batch file name
.SIZE:
ENDSTRUC

ANULL		equ	0		; terminates an argv string
ARGMAX		equ	64		; max args on a command line
ARGBLEN 	equ	2*128		; 1char each plus term NUL
tplen		equ	64		; max size of one argument
arg_cnt_error	equ	1		; number of args > MAXARG
arg_buf_ovflow	equ	2		; overflowed argbuffer

STRUC ARGV_ELE				; elements in the argv array
.argpointer:	RESW	1		; pointer to the argstring
.argflags:	RESB	1		; cparse flags for this argstring
.argstartel:	RESW	1		; the result of cparse's [STARTEL]
.arglen:	RESW	1		; cparse's char count + one (for null)
.argsw_word:	RESW	1		; any switches after this? what kinds?
.arg_ocomptr:	RESW	1		; pointer into original command string
.SIZE:
ENDSTRUC

STRUC ARG_UNIT
.argv:		RESB	ARGMAX * ARGV_ELE.SIZE
.argvcnt:	RESW	1		; number of arguments
.argswinfo:	RESW	1		; Switch information for entire line
.argbuf:	RESW	ARGBLEN		; storage for argv strings
.argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
.SIZE:
ENDSTRUC

; Equates for initialization
;
INITINIT	equ	01h		; initialization in progress
INITSPECIAL	equ	02h		; in initialization time/date routine
INITCTRLC	equ	04h		; already in ^C handler

;============================================================================
;  INTNAT.INC, MSDOS 6.0, 1991
;============================================================================
; 16/04/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 

; Current structure of the data returned by the international call

struc INTERNAT_BLOCK
.date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
.currency_sym:	resb 5			; Currency Symbol 5 bytes
.thous_sep:	resb 2			; Thousands separator 2 bytes
.decimal_sep:	resb 2			; Decimal separator 2 bytes
.date_sep:	resb 2			; Date separator 2 bytes
.time_sep:	resb 2			; Decimal separator 2 bytes
.bit_field:	resb 1			; Bit values
					;   Bit 0 = 0 if currency symbol first
					;	  = 1 if currency symbol last
					;   Bit 1 = 0 if No space after currency symbol
					;	  = 1 if space after currency symbol
.currency_cents:
		resb 1			; Number of places after currency dec point
.time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
.map_call:	resw 2			; Address of case mapping call (DWORD)
					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
					;  in pieces.
.data_sep:	resb 1			; Data list separator character
		resb 1
endstruc

; Max size of the block returned by the INTERNATIONAL call

internat_block_max equ 32

;============================================================================
; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
;============================================================================
; 13/10/2018 - Retro DOS v3.0
; 16/02/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 

;Break	<find first/next buffer>

	; MSDOS 3.3 & MSDOS 6.0

struc FIND_BUF
.DRIVE:	    resb 1	; drive of search
.NAME:	    resb 11	; formatted name
.SATTR:	    resb 1	; attribute of search
.LASTENT:   resw 1	; LastEnt
.DIRSTART:  resw 1	; DirStart
.NETID:	    resb 4	; Reserved for NET
.ATTR:	    resb 1	; attribute found
.TIMR:	    resw 1	; time
.DATE:	    resw 1	; date
.SIZE_L:    resw 1	; low(size)
.SIZE_H:    resw 1	; high(size)
.PNAME:	    resb 13	; packed name
.size:
endstruc

;=============================================================================
; PDB.INC, MSDOS 6.0, 1991
;=============================================================================
; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')

;**	Process data block (otherwise known as program header)

;	These offset are documented in the MSDOS Encyclopedia, so nothing
;	can be rearranged here, ever. Reserved areas are probably safe
;	for use.

FILPERPROC	EQU     20

struc PDB	; Process_data_block
.EXIT_CALL:	resw 1   	; INT int_abort system terminate
.BLOCK_LEN:	resw 1		; size of execution block
                resb 1
.CPM_CALL:	resb 5		; ancient call to system
.EXIT:		resd 1		; pointer to exit routine
.CTRL_C:	resd 1		; pointer to ^C routine
.FATAL_ABORT:	resd 1		; pointer to fatal error
.PARENT_PID:	resw 1		; PID of parent (terminate PID)
.JFN_TABLE:     resb FILPERPROC ; indices into system table
.ENVIRON:	resw 1		; seg addr of environment
.USER_STACK:	resd 1		; stack of self during system calls
.JFN_Length:	resw 1		; number of handles allowed
.JFN_Pointer:	resd 1		; pointer to JFN table
.Next_PDB:	resd 1		; pointer to nested PDB's
.InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
.Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
.Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
.Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
.PAD1:		resb 14 ; 0Eh
.CALL_SYSTEM:	resb 5		; portable method of system call
.PAD2:		resb 7		; reserved so FCB 1 can be used as
				;  an extended FCB
;endstruc 	; MSDOS 3.3
	  	; MSDOS 6.0
.FCB1:		resb 16 ; 10h	; default FCB 1
.FCB2:		resb 16 ; 10h	; default FCB 2
.PAD3:		resb 4		; not sure if this is used by PDB_FCB2
.TAIL:		resb 128	; command tail and default DTA
endstruc

;=============================================================================
; VERSIONA.INC, MSDOS 6.0, 1991
;=============================================================================
; 24/09/2018 - Retro DOS v3.0

;major_version	equ 6		; Major DOS version
;minor_version	equ 0		; Minor DOS Version

;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION

; MSDOS 3.3 COMMAND.COM
;MAJOR_VERSION	EQU 3
;MINOR_VERSION	EQU 30

; 09/01/2023 - Retro DOS v4.0 (& v4.1)
MAJOR_VERSION	EQU 5		; Major DOS version
MINOR_VERSION	EQU 0		; Minor DOS version

EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	

;-----------------------------------------------------------------------------
; 21/09/2018
;-----------------------------------------------------------------------------
; Retro DOS v3.0 NOTE:  
;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
;	with minor modifications which are done by me (Erdogan Tan).
;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
;	source code files (written by using MASM syntax).
;-----------------------------------------------------------------------------
; All of this Retro DOS 3.0 (2018) source code has been written by using
; NASM (2.11) x86 assembly language/compiler syntax.	
;----------------------------------------------------------------------------- 	

;=============================================================================
; COMMAND1.ASM, MSDOS 6.0, 1991
;=============================================================================
; 21/09/2018 - Retro DOS v3.0

;	page ,132
;	title	COMMAND - resident code for COMMAND.COM
;	name	COMMAND

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;*****************************************************************************
;
; MODULE:	       COMMAND.COM
;
; DESCRIPTIVE NAME:    Default DOS command interpreter
;
; FUNCTION:	       This version of COMMAND is divided into three distinct
;		       parts.  First is the resident portion, which includes
;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
;		       error), and 2EH (command line execute); it also has
;		       code to test and, if necessary, reload the transient
;		       portion. Following the resident is the init code, which
;		       is overwritten after use.  Then comes the transient
;		       portion, which includes all command processing (whether
;		       internal or external).  The transient portion loads at
;		       the end of physical memory, and it may be overlayed by
;		       programs that need as much memory as possible. When the
;		       resident portion of command regains control from a user
;		       program, a check sum is performed on the transient
;		       portion to see if it must be reloaded.  Thus programs
;		       which do not need maximum memory will save the time
;		       required to reload COMMAND when they terminate.
;
; ENTRY POINT:	       PROGSTART
;
; INPUT:	       command line at offset 81H
;
; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
;		       from a secondary command processor via the EXIT
;		       internal command.
;
; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
;		       hang the system.
;
; INTERNAL REFERENCES:
;
;     ROUTINES:        See the COMMAND Subroutine Description Document
;		       (COMMAND.DOC)
;
;     DATA AREAS:      See the COMMAND Subroutine Description Document
;		       (COMMAND.DOC)
;
; EXTERNAL REFERENCES:
;
;      ROUTINES:       none
;
;      DATA AREAS:     none
;
;*****************************************************************************
;
;			      REVISION HISTORY
;			      ----------------
;
; DOS 1.00 to DOS 3.30
; --------------------------
; SEE REVISION LOG IN COPY.ASM ALSO
;
; REV 1.17
;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
;	       resident since the EXELOAD may have overwritten the transient.
;
; REV 1.18
;    05/21/82  IBM version always looks on drive A
;	       MSVER always looks on default drive
;
; REV 1.19
;    06/03/82  Drive spec now entered in command line
;    06/07/82  Added VER command (print DOS version number) and VOL command
;	       (print volume label)
;
; REV 1.20
;    06/09/82  Prints "directory" after directories
;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
;
; REV 1.50
;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
;	       do it right.
;
; REV 1.70
;	       EXEC used to fork off new processes
;
; REV 1.80
;	       C switch for single command execution
;
; REV 1.90
;	       Batch uses XENIX
;
; Rev 2.00
;	       Lots of neato stuff
;	       IBM 2.00 level
;
; Rev 2.01
;	       'D' switch for date time suppression
;
; Rev 2.02
;	       Default userpath is NUL rather than BIN
;		       same as IBM
;	       COMMAND split into pieces
;
; Rev 2.10
;	       INTERNATIONAL SUPPORT
;
; Rev 2.50
;	       all the 2.x new stuff -MU
;
; Rev 3.30     (Ellen G)
;	       CALL internal command (TBATCH2.ASM)
;	       CHCP internal command (TCMD2B.ASM)
;	       INT 24H support of abort, retry, ignore, and fail prompt
;	       @ sign suppression of batch file line
;	       Replaceable environment value support in batch files
;	       INT 2FH calls for APPEND
;	       Lots of PTR fixes!
;
; Beyond 3.30 to forever  (Ellen G)
; ----------------------
;
; A000 DOS 4.00  -	Use SYSPARSE for internal commands
;			Use Message Retriever services
;			/MSG switch for resident extended error msg
;			Convert to new capitalization support
;			Better error recovery on CHCP command
;			Code page file tag support
;			TRUENAME internal command
;			Extended screen line support
;			/P switch on DEL/ERASE command
;			Improved file redirection error recovery
;	(removed)	Improved batch file performance
;			Unconditional DBCS support
;			Volume serial number support
;	(removed)	COMMENT=?? support
;
; A001	PTM P20 	Move system_cpage from TDATA to TSPC
;
; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
;			require delimiters.
;
; A003	PTM P5,P9,P111	Included in A000 development
;
; A004	PTM P86 	Fix IF command to turn off piping before
;			executing
;
; A005	DCR D17 	If user specifies an extension on the command
;			line search for that extension only.
;
; A006	DCR D15 	New message for MkDir - "Directory already
;			exists"
;
; A007	DCR D2		Change CTTY so that a write is done before XDUP
;
; A008	PTM P182	Change COPY to set default if invalid function
;			returned from code page call.
;
; A009	PTM P179	Add CRLF to invalid disk change message
;
; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
;			transient COMMAND.
;
; A011	DCR D130	Change redirection to overwrite an EOF mark
;			before appending to a file.
;
; A012	PTM P189	Fix redirection error recovery.
;
; A013	PTM P330	Change date format
;
; A014	PTM P455	Fix echo parsing
;
; A015	PTM P517	Fix DIR problem with * vs *.
;
; A016	PTM P354	Fix extended error message addressing
;
; A017	PTM P448	Fix appending to 0 length files
;
; A018	PTM P566,P3903	Fix parse error messages to print out parameter
;			the parser fails on. Fail on duplicate switches.
;
; A019	PTM P542	Fix device name to be printed correctly during
;			critical error
;
; A020	DCR D43 	Set append state off while in DIR
;
; A021	PTM P709	Fix CTTY printing ascii characters.
;
; A022	DCR D209	Enhanced error recovery
;
; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
;
; A024	PTM P899	Fix EXTOPEN open modes.
;
; A025	PTM P922	Fix messages and optimize PARSE switches
;
; A026	DCR D191	Change redirection error recovery support.
;
; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
;			with a carriage return.
;
; A028	PTM P1076	Print a blank line before printing invalid
;			date and invalid time messages.
;
; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
;			and TIME.
;
; A030	DCR D201	New extended attribute format.
;
; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
;
; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
;
; A033	PTM P1298	Fix problem with system crashes on ECHO >""
;
; A034	PTM P1387	Fix COPY D:fname+,, to work
;
; A035	PTM P1407	Fix so that >> (appending) to a device does
;			do a read to determine eof.
;
; A036	PTM P1406	Use 69h instead of 44h to get volume serial
;			so that ASSIGN works correctly.
;
; A037	PTM P1335	Fix COMMAND /C with FOR
;
; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
;
; A039	DCR D284	Change invalid code page tag from -1 to 0.
;
; A040	PTM P1787	Fix redirection to cause error when no file is
;			specified.
;
; A041	PTM P1705	Close redirected files after internal APPEND
;			executes.
;
; A042	PTM P1276	Fix problem of APPEND paths changes in batch
;			files causing loss of batch file.
;
; A043	PTM P2208	Make sure redirection is not set up twice for
;			CALL'ed batch files.
;
; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
;			as an end of line character
;
; A045	PTM P2560	Make sure we don't lose parse, critical error,
;			and extended message pointers when we EXIT if
;			COMMAND /P is the top level process.
;
; A046	PTM P2690	Change COPY message "fn File not found" to
;			"File not found - fn"
;
; A047	PTM P2819	Fix transient reload prompt message
;
; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
;			when DBCS code was added.
;
; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
;			on line.
;
; A050	PTM P3030	Fix TYPE to work properly on files > 64K
;
; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
;
; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
;
; A053	PTM P2865	Fix DIR to work in 40 column mode.
;
; A054	PTM P3407	Code reduction and critical error on single line
;	PTM P3672	(Change to single parser exported under P3407)
;
; A055	PTM P3282	Reset message service variables in INT 23h to fix
;			problems with breaking out of INT 24h
;
; A056	PTM P3389	Fix problem of environment overlaying transient.
;
; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
;			before the "string".  EX: COMMAND /CDIR
;
; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
;			DBCS switch.
;
; A059	PTM P3394	Change the TIME command to right align the display of
;			the time.
;
; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
;			messages to be disk based.  Only keep them if /MSG
;			is used.
;
; A061	PTM P3928	Fix so that transient doesn't reload when breaking
;			out of internal commands, due to substitution blocks
;			not being reset.
;
; A062	PTM P4079	Fix segment override for fetching address of environment
;			of parent copy of COMMAND when no COMSPEC exists in
;			secondary copy of environment.	Change default slash in
;			default comspec string to backslash.
;
; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
;			text for critical error messages.
;
; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
;	5/20/88 	with Microsoft product already shipped.
;
; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
;	 5/20/88	with Microsoft product already shipped.
;
; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
;	 5/24/88	cases; where the listing would barely fit without the
;			header and space remaining.
;
; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
;			environment was putting a "Z block" marker in the old
;			environment.  The fix is to move to the old environment
;			to the new environment before doing the SETBLOCK.
;
; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
;        09/19/88       because the check for APPEND needed to be performed
;                       before the DIR's findfirst.
;
; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
;                       loading trans w/new comspec with no user change comspec.
;
; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
;        11/05/88       Expansion of environment variables into batch line of
;                       128 chars was not being counted and "%" which should be
;                       ignored were being counted.
;
; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
;        03/02/89       used.  Comspec_flag was not in protected data file be-
;                       ing included in checksum and was being overwritten by
;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
;                       Also removed fix A069 (because flag now protected).
;
; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
;        07/25/89       version and CSD version in U.S. date format.  Files
;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
;
;***********************************************************************************

;
;	Revision History
;	================
;
;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
;					at init time (date/time prompt)
;

;
;.xcref
;.xlist
;	include dossym.inc		; basic DOS symbol set
;	include syscall.inc		; DOS function names
;	include comsw.asm		; build version info
;	include comequ.asm		; common command.com symbols
;	include resmsg.equ		; resident message names
;
;	include comseg.asm		;segment ordering
;.list
;.cref

;CODERES segment public byte
;CODERES ends
;
;DATARES 	segment public byte
;		extrn	AccDen:byte
;		extrn	Batch:word
;		extrn	EchoFlag:byte
;		extrn	ExeBad:byte
;		extrn	ExecEMes:byte
;		extrn	ExecErrSubst:byte
;		extrn	ExtCom:byte
;		extrn	ForFlag:byte
;		extrn	IfFlag:byte
;		extrn	InitFlag:BYTE
;		extrn	Nest:word
;		extrn	PipeFlag:byte
;		extrn	RBadNam:byte
;		extrn	RetCode:word
;		extrn	SingleCom:word
;		extrn	TooBig:byte
;
;		extrn	OldDS:word
;
;DATARES 	ends
;
;
;INIT		segment public para
;		extrn	ConProc:near
;		extrn	Init_Contc_SpecialCase:near
;INIT		ends

; 09/01/2023 - Erdogan Tan - Istanbul
; --------------------------------------
; 'command5.s' source code reference(s):

;	1) MSDOS 6.0 COMMAND.COM source files
;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
; ----------------------------------------------------------------------				 	 	

; ----------------------------------------------------------------------------
; START OF RESIDENT PORTION
; ----------------------------------------------------------------------------
; SEGMENT - DATARES
; ----------------------------------------------------------------------------

section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 

; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)

; ----------------------------------------------------------------------------
; STUB.ASM - MSDOS 6.0 - 1991
; ----------------------------------------------------------------------------

;This file contains the low memory stub for command.com which hooks all the
;entry points into the resident command.com and directs the calls to the
;appropriate routines in the resident code which may be located in HIMEM. 
;
;The stub has been made part of the resident data and will always
;be duplicated on every invocation of command.com. However, the only stubs
;that actually hook the interrupt vectors belong to either the first 
;command.com or to any other command.com executed with the /p switch. 
;
;The stub also keeps track of the current active data segment. The 
;INIT code of each command.com updates this variable via an int 2fh mechanism
;with its own data segment. The INIT code also updates a pointer in its data
;segment to the previous resident data segment. Whenever a command.com exits,
;the exit code picks up the previous data segment pointer from the current
;data segment and patches it into the CurResDataSeg variable in the stub.
;
;Right now the stub does not bother about A20 switching. We assume
;A20 is always on. It just does a far jump to the resident code with the 
;value of the current data segment in one of the registers. A20 toggle 
;support maybe added as a future enhancement, if the need is felt.

	; 09/01/2023 - Retro DOS v4.0 (& v4.1)

	[ORG 100H]

	; 21/09/2018 - Retro DOS v3.0
StartCode:
	jmp	ConProc	; 10/01/2023 

	; 09/01/2023

; Make following table word-aligned, and at the same time, provide a
; signature that sysinit can use to (attempt to) validate the interpreter

	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)

;All the entry points declared below are patched in at INIT time with the
;proper segment and offset values after the resident code segment has been
;moved to its final location

;!!!WARNING!!!
; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
;in the correct segments and offsets

Int2f_Entry:
	dw	MsgInt2fHandler		; Address of int 2fh handler
	dw	0
Int2e_Entry:
	dw	Int_2e			; Address of int 2eh handler
	dw	0
Ctrlc_Entry:
	dw	ContC			; Address of Ctrl-C handler
	dw	0
CritErr_Entry:
	dw	DSKERR			; Address of critical error handler
	dw	0

Exec_Entry:
	dd	0			; Entry from transient to Ext_Exec
RemCheck_Entry:
	dd	0			; Entry from transient to TRemCheck
TrnLodCom1_Entry:
	dd	0			; Entry from transient to LodCom1
LodCom_Entry:
	dd	0			; Entry after exit from command.com
MsgRetrv_Entry:
	dd	0			; Entry from external to MsgRetriever
HeadFix_Entry:
	dd	0			; Entry from trans to HeadFix
UMBOff_Entry:
	dd	0			; Entry from here to UMBOff routine; M003
XMMCallAddr:
	dd	0			; Call address for XMM functions
ComInHMA:
	db	0			; Flags if command.com in HMA

Int2f_Trap:
	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:Int2f_Entry
	jmp	far [cs:Int2f_Entry]

Int2e_Trap:
	sti
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:Int2e_Entry
	jmp	far [cs:Int2e_Entry]

Ctrlc_Trap:
	sti
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:Ctrlc_Entry
	jmp	far [cs:Ctrlc_Entry]

CritErr_Trap:
	sti
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:CritErr_Entry
	jmp	far [cs:CritErr_Entry]

Exec_Trap:
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:Exec_Entry
	jmp	far [cs:Exec_Entry]

RemCheck_Trap:
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:RemCheck_Entry
	jmp	far [cs:RemCheck_Entry]

TrnLodCom1_Trap:
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:TrnLodCom1_Entry
	jmp	far [cs:TrnLodCom1_Entry]

LodCom_Trap:
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:LodCom_Entry
	jmp	far [cs:LodCom_Entry]

MsgRetrv_Trap:
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:MsgRetrv_Entry
	jmp	far [cs:MsgRetrv_Entry]

HeadFix_Trap:
	call	CheckA20
	push	ds			; push current ds value
	push	cs			; push resident data segment value
	;jmp	cs:HeadFix_Entry
	jmp	far [cs:HeadFix_Entry]

; ----------------------------------------------------------------------------

	; 09/01/2023
	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh

CheckA20:
	pushf				; save current flags
	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
	jz	short A20_on		; no, jump to resident

	call	QueryA20
	jnc	short A20_on		; A20 is on, jump to resident

	call	EnableA20		; turn A20 on
A20_on:
	popf				; flags have to be unchanged
	retn

; ----------------------------------------------------------------------------

; M005; This is a far jump to the actual int 2fh entry point. The renormalized
; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
; M005; handler. Note that we have to hardcode a jump and we cannot use any
; M005; pointers because our cs is going to be different. The segment to
; M005; jump to is patched in at init time. (in init.asm)

Carousel_i2f_Hook:			; M005
	db	0EAh			; far jump opcode; M005
	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
	dw	0			; int 2fh segment; M005

; ----------------------------------------------------------------------------

XMM_QUERY_A20 equ 7 ; 09/01/2023

QueryA20:
	push	bx
	push	ax
	;mov	ah,7
	mov	ah,XMM_QUERY_A20
	;call	cs:XMMCallAddr
	call	far [cs:XMMCallAddr]
	or	ax,ax
	pop	ax
	pop	bx
	; 16/04/2023
	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON

	stc					; OFF
	;retn
QA20_ON:
	;clc					; ON
	retn

; ----------------------------------------------------------------------------

XMM_LOCAL_ENABLE_A20 equ 5

EnableA20:
	push	bx
	push	ax
	;mov	ah,5
	mov	ah,XMM_LOCAL_ENABLE_A20
	;call	cs:XMMCallAddr
	call	far [cs:XMMCallAddr]
	or	ax,ax
	jz	short XMMerror			; AX = 0 fatal error
	pop	ax
	pop	bx
	retn

;If we get an error, we just loop forever

XMMerror:
	jmp	short XMMerror

; -----------------------------------------------------------------------------

HV_Extern   equ	1
HV_LoadHigh equ	1
HV_Stub	    equ	1

	; 09/01/2023 - Retro DOS v4.0 (& 4.1)

;The Exec call has to be issued from the data segment. The reason for this 
;is TSRs. When a TSR does a call to terminate and stay resident, the call
;returns with all registers preserved and so all our segment registers are
;still set up. However, if the TSR unloads itself later on, it still 
;comes back here. In this case the segment registers and the stack are
;not set up and random things can happen. The only way to setup all the 
;registers is to use the cs value and this can only be done when we are in
;the data segment ourselves. So, this piece of code had to be moved from
;the code segment to the data segment.

Issue_Exec_Call:
	int 	21h

;We disable interrupts while changing the stack because there is a bug in 
;some old 8088 processors where interrupts are let through while ss & sp
;are being changed.

	cli
	push	cs
	pop	ss
	;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
	;mov	sp,offset DATARES:RStack ; stack is set up
	mov	sp,RStack		; stack is set up
	
	; 20/04/2023
	;sti
	;push	cs
	;pop	ds			; ds = DATARES

; M009; Restore UMB state to that before Exec

	;pushf				;    This call frees HIDDEN umb's,
	;call	UnHideUMBs		; <- restores the memory-allocation
	;popf				;    strategy and link state, as app.

	; 09/01/2023 - Retro DOS v4.0
	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
	; ----------------------
	sti
	
	push    cs
	pop     ds
	pushf
	;mov	al,[cs:fInHigh]
	; 18/04/2023
	mov	al,[fInHigh]
	test	al,80h
	jz      short uhu10
	and     al,7Fh
	;;call	cs:UMBOff_Entry
	;call	far [cs:UMBOff_Entry]
	call	far [UMBOff_Entry]
uhu10:
	;and	byte [cs:fInHigh],7Fh
	; 18/04/2023
	and	byte [fInHigh],7Fh
	popf
	; ----------------------

;We now jump to the stub trap which returns us to the resident code. All
;flags are preserved by the stub code.

	jmp	Exec_Trap

; ----------------------------------------------------------------------------
; RDATA.ASM, MSDOS 6.0, 1992
; ----------------------------------------------------------------------------
; 09/01/2023 - Retro DOS v4.0 (& v4.1)

;***	Message substitution blocks

; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)

;BlkDevErrSubst	label	byte
;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter

BlkDevErrSubst: db	2
BlkDevErrRw:	dw	0
		db	1
		dw	DrvLet

DrvLet:		db	'A'			; drive letter


;CharDevErrSubst label	byte
;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name

CharDevErrSubst: db	2
CharDevErrRw:	dw	0
		db	2
		dw	DevName

DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
		db	0

;NeedVolSubst	label	byte
;		subst	<STRING,DATARES:VolName> ; volume name
;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #

NeedVolSubst:	db	2
		dw	VolName
		db	3
		dw	VolSer+2
		db	3
		dw	VolSer

	; NOTE:	VolName and VolSer must be adjacent
VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
		db	0
VolSer:		dd	0			; volume serial #

CDevAt:		db	0

;BadFatSubst	label	byte
;		subst	<CHAR,DATARES:DrvLet>	; drive letter

BadFatSubst:	db	1
		dw	DrvLet

;PutBackSubst	label	byte
;PutBackComSpec	subst	<STRING,>		  ; comspec string
;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in

PutBackSubst:	db	2
PutBackComSpec:	dw	0
		db	1
		dw	PutBackDrv

PutBackDrv:	db	' '			; drive letter

;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>

ExecErrSubst:	db	2
		dw	SafePathBuffer

NeedVol:	dd	0	; ptr to volume name from get ext err
ErrType: 	db	0	; critical error message style, 0=old, 1=new

Int_2e_Ret:	dd	0	; magic command executer return address
Save_Pdb:	dw	0
Parent:		dw	0
OldTerm:	dd	0
ErrCd_24:	dw	0
Handle01:	dw	0
Loading:	db	0
Batch:		dw	0	; assume no batch mode initially

;;;;SR;
;;;; This flag has been added for a gross hack introduced in batch processing. 
;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
;;;;we need to fake the CR-LF for the line to be properly processed
;;;;
;;;BatchEOF:	db	0

	; Bugbug: ComSpec should be 64+3+12+1?
	; What's this comspec_end about?
ComSpec:	times 64 db 0 ; db 64 dup (0)
ComSpec_End:	dw	0

;Trans		label	dword
;		dw	TRANGROUP:Command

Trans:		;dw	12Ch
		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
		dw	COMMAND ; 16/04/2023
TrnSeg:		dw	0

TrnMvFlg:	db	0	; set if transient portion has been moved

In_Batch:	db	0	; set if we are in batch processing mode
Batch_Abort:	db	0	; set if user wants to abort from batch mode

ComDrv:		db	0	; drive spec to load autoexec and command
MemSiz:		dw	0
Sum:		dw	0
ExtCom:		db	1	; for init, pretend just did an external
RetCode: 	dw	0
Crit_Err_Info:	db	0	; hold critical error flags for r,i,f


; The echo flag needs to be pushed and popped around pipes and batch files.
; We implement this as a bit queue that is shr/shl for push and pop.

EchoFlag:	db	00000001b ; low bit true => echo commands
Suppress:	db	1	; used for echo, 1=echo line
Io_Save: 	dw	0
RestDir: 	db	0
PermCom: 	db	0	; true => permanent command
;SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
				; true => semi-permanent command (/K)
SingleCom:	dw	0	; true => single command version
VerVal:		dw	-1
fFail:		db	0	; true => fail all int 24s
IfFlag:		db	0	; true => IF statement in progress

ForFlag: 	db	0	; true => FOR statement in progress
ForPtr:		dw	0

Nest:		dw	0	; nested batch file counter
Call_Flag:	db	0	; no CALL (batch command) in progress
Call_Batch_Flag: db	0
Next_Batch:	dw	0	; address of next batch segment
NullFlag:	db	0	; flag if no command on command line
FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
				; buffer for file ucase address
; Bugbug: don't need crit_msg_ anymore?

Crit_Msg_Off:	dw	0	; saved critical error message offset
Crit_Msg_Seg:	dw	0	; saved critical error message segment
Dbcs_Vector_Addr: dw	0	; DBCS vector offset
		 dw	0	; DBCS vector segment
Append_State:	dw	0	; current state of append
				;  (if Append_Flag is set)
Append_Flag:	db	0	; set if append state is valid
Re_Out_App:	db	0
Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)

; We flag the state of COMMAND in order to correctly handle the ^Cs at
; various times. Here is the breakdown:
;
;   INITINIT	We are in the init code.
;   INITSPECIAL We are in the date/time prompt
;   INITCTRLC	We are handling a ^C already.
;
; If we get a ^C in the initialization but not in the date/time prompt, we
; ignore the ^C. This is so the system calls work on nested commands.
;
; If we are in the date/time prompt at initialization, we stuff the user's
; input buffer with a CR to pretend an empty response.
;
; If we are already handling a ^C, we set the carry bit and return to the user
; (ourselves). We can then detect the carry set and properly retry the
; operation.

InitFlag:	;db	1
		db	INITINIT

; Note: these two bytes are referenced as a word
PipeFlag:	db	0
PipeFiles:	db	0

; (rdata.asm, msdos 6.0, 1992)
; ----------------------------------------------------------------------------
; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)


;;SR
;; Pipe1 & Pipe2 now need to store full-fledged pathnames
;;
;
;; Bugbug: can we find any way around maintaining these
;; large buffers?
;
;Pipe1		db	67+12 dup (?)
;Pipe2		db	67+12 dup (?)
;
;PipePtr 	dw	?
;
;PipeStr 	db	129 dup (?)
;
;EndPipe	label	byte	; marks end of buffers; M004
;
;;SR;
;; We can move our EndInit code into above buffers. This way, the code will
;;automatically be discarded after init.
;;
;; M004; We overlap our code with the Pipe buffers located above by changing
;; M004; the origin.
;;
;	ORG	Pipe1	; M004
;
;; Bugbug: really need a procedure header for EndInit, describing
;; what it expects, what it does.
;

; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

Pipe1	equ	EndInit
Pipe2	equ	Pipe1+67+12
PipePtr	equ	Pipe2+67+12
PipeStr	equ	PipePtr+2
EndPipe	equ	PipeStr+129	; EndInit+289

; Bugbug: really need a procedure header for EndInit, describing
; what it expects, what it does.

; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h 

EndInit:
	push	ds
	push	es		; save segments
	push	cs
	pop	ds		
	;assume	ds:RESGROUP

; M004; Save size of transient here before INIT segment is deallocated

	mov	dx,[TrnSize]		; M004
;M027
; These variables are also defined in the INIT segment and need to be saved
;before we resize
;
	mov	ax,[OldEnv]	; Old Environment seg ;M027
	mov	bx,[EnvSiz]	; Size of new environment ;M027
	mov	cx,[UsedEnv]	; Size of old environment ;M027
	push	ax		; Save all these values ;M027
	push	bx		; M027
	push	cx		; M027


; Bugbug: push ds, pop es here.
	;mov	bx,ds
	;mov	es,bx		; es = RESGROUP
	; 09/01/2023
	push	ds
	pop	es

;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
; code + data for low COMMAND

	mov	bx,[ResSize]	; Total size of resident
	mov	ah,4Ah
	;mov	ah,SETBLOCK
	int	21h		; Set block to resident size

		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
		; ES = segment address of block to change
		; BX = new size in paragraphs

;We check if this is for autoexec.bat (PermCom = 1). If so, we then
;allocate a new batch segment, copy the old one into new batchseg and free
;the old batchseg. Remember that the old batchseg was allocated on top of the
;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
;
; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
	
	cmp	byte [PermCom],1 ; permanent command.com?
	jne	short adjust_env ; no, do not free batchseg

	cmp	word [Batch],0	 ; was there a valid batchseg?
	je	short adjust_env ; no, dont juggle

	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ; batchseg size
	; 21/01/2023
	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
	;mov	bx,4	; 09/01/2023
			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
	mov	ah,48h
	;mov	ah,ALLOC
	int	21h

		; DOS - 2+ - ALLOCATE MEMORY
		; BX = number of 16-byte paragraphs desired

; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
; a hole, the batch segment COULD already be in the ideal place. We
; could be making it worse! We're second-guessing where memory
; allocations go, which might not be such a great idea. Is there
; a strategy, short of doing something even worse like diddling
; arena headers, where we can minimize the possibility of fragmentation
; under all cases? Hmm..
	
	jc	short adjust_env ; no memory, use old batchseg

	mov	es,ax		 ; es = New batch segment
	xor	di,di
	xor	si,si

	push	ds
	mov	ds,[Batch]	 ; ds = Old Batch Segment
	;assume	ds:nothing
	;mov	cx,SIZE BatchSegment
	; 23/01/2023
	;mov	cx,BATCHSEGMENT.SIZE
	;;mov	cx,33	; 09/01/2023
	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
	;
	;add	cx,16		 ; for the filename
	; 20/04/2023
	mov	cx,BATCHSEGMENT.SIZE+16 

	; Bugbug: 16? Shouldn't this be a common equate or something?
	; It's sure be bad if we copied more bytes than the batch segment
	; holds!
	
	cld
	rep	movsb
	pop	ds
	;assume	ds:RESGROUP

	mov	cx,es		; save new batch segment 
	mov	es,[Batch]
	mov	ah,49h
	;mov	ah,DEALLOC
	int	21h		; free the old batch segment

	; Bugbug: should we check for error?

	mov	[Batch],cx	; store new batch segment address

adjust_env:
	pop	cx		; cx = size of old env ;M027
	pop	bx		; bx = size of new env needed ;M027
	pop	bp		; bp = old env seg ;M027

;Allocate the correct size for the environment

	mov	ah,48h
	;mov	ah,ALLOC
	int	21h		; get memory
	jc	short nomem_err	; out of memory,signal error
	
	; Bugbug: why not continue, leaving environment where it is?

	mov	[EnvirSeg],ax	; Store new environment segment
	;;mov	[ds:2Ch],ax
	;mov	[2Ch],ax
	;mov	[PDB_Environ],ax ; Put new env seg in PSP
	mov	[PDB.ENVIRON],ax
	mov	es,ax		; es = address of allocated memory
	;assume	es:nothing

;Copy the environment to the newly allocated segment

	push	ds
	mov	ds,bp		; ds = Old environment segment
	;assume	ds:nothing

	xor	si,si
	mov	di,si		; Start transfer from 0

	cld
	rep	movsb		; Do the copy

	pop	ds		; ds = RESGROUP
	;assume	ds:RESGROUP

; We have to free the old environment block if it was allocated by INIT

; Bugbug: is this only for the case when we were NOT passed an environment,
; or does it also apply to passed environments?

;M036
; Free up old env segment always because this is a copy passed by Exec and
; takes up memory that is never used

;M044
; Go back to the old strategy of not freeing the environment. Freeing it leaves
; a hole behind that Ventura does not like. Basically, Ventura gives strange
; errors if it gets a memory alloc that it is below its load segment. The
; freed environment creates a large enough hole for some of its allocs to fit
; in

	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
        ;je	short no_free	    ; no, do not free it
	; 21/01/2023
	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
	cmp	byte [AllocedEnv],0 ; flag - old environment segment	
	jne	short no_free 

	mov	es,bp
	mov	ah,49h
	;mov	ah,DEALLOC	
	int	21h		    ; Free it
no_free:

; M004; Start of changes 

; Move the transient now. We will allocate the biggest block available
; now and move the transient to the top of the block. We will then
; deallocate this block. When the resident starts executing, it will
; hopefully allocate this block again and find the transient intact.

	mov	byte [TrnMvFlg],1   ; Indicate that transient has been moved
	push	es
	;;mov	si,offset ResGroup:TranStart
	; 09/01/2023
	;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
	mov	si,TRANSTART	    ; (End of the resident portion)
	;mov	di,0
	xor	di,di ; 0
	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
	;mov	cx,98C5h
	mov	cx,TRANSPACEEND
	
; Find the largest block available

	mov	bx,0FFFFh
	mov	ah,48h
	;mov	ah,ALLOC
	int	21h

; dx = size of transient saved previously 

	cmp	bx,dx		; enough memory?
	jb	short nomem_err	; not enough memory for transient

	mov	ah,48h
	;mov	ah,ALLOC
	int	21h		; get the largest block
	jc	short nomem_err	; something is really screwed up

	push	ax		; save memory address
	add	ax,bx		; ax = top of my memory block
	sub	ax,dx		; less size of transient
	mov	[TrnSeg],ax	; save transient segment
	mov	es,ax		;
	pop	ax		; restore our seg addr

; Everything is set for a move. We need to move in the reverse direction to
; make sure we dont overwrite ourselves while copying

	add	si,cx
	dec	si
	add	di,cx
	dec	di
	std
	rep	movsb
	cld

; Now we have to free up this block so that resident can get hold of it

	mov	es,ax
	mov	ah,49h
	;mov	ah,DEALLOC
	int	21h		; release the memory block

; M004; End of changes

	;mov	InitFlag,FALSE	; indicate INIT is done
	; 09/01/2023
	mov	byte [InitFlag],0	

	pop	es
	pop	ds
	;assume	ds:nothing
	
	; Bugbug: did we need to save & restore seg reg's during EndInit?
	
	jmp	LodCom_Trap	; allocate transient

nomem_err:

;We call the error routine which will never return. It will either exit
;with an error ( if not the first COMMAND ) or just hang after an error 
;message ( if first COMMAND )

	jmp	Alloc_error

;EndCodeInit:	; label	byte		; M004

	; 16/04/2023
	EndCodeInit equ $

;; M004; Check if the EndInit code will fit into the Pipe buffers above.
;; M004; If not, we signal an assembly error
;
;IF2
;	IF ($ GT EndPipe)
;		.err
;		%out	"ENDINIT CODE TOO BIG"
;	ENDIF
;ENDIF

;; M004; Set the origin back to what it was at the end of the buffers
;;
;		ORG	EndPipe		; M004

; 09/01/2023

; MSDOS 5.0 COMMAND.COM - CODERES:03EDh
;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)

; 16/04/2023
	FillBytes equ EndPipe - EndCodeInit			

;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
; 16/04/2023
%if FillBytes>0
	;times EndPipe - EndCodeInit db 0
	times FillBytes db 0   
%endif

; 09/01/2023 - Retrodos v4.0 (& v4.1)
; MSDOS 5.0 COMMAND.COM - CODERES:0441h ; EndInit+289 

;InPipePtr	dw	offset DATARES:Pipe1	; 320h 
;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh

InPipePtr:	dw	Pipe1 ; 320h for MSDOS 5.0 COMMAND.COM
OutPipePtr:	dw	Pipe2 ; 36Fh for MSDOS 5.0 COMMAND.COM

Exec_Block:	; label	byte	; the data block for exec calls
EnvirSeg:	dw	0
Com_Ptr:	; label	dword
		dw	80h	; point at unformatted parameters
		dw	0
Com_Fcb1:	; label	dword
		dw	5Ch
		dw	0
Com_Fcb2:	; label	dword
		dw	6Ch
		dw	0

; variables passed to transient
TranVars:	; label	byte			
		;dw	offset DATARES:HeadFix_Trap
		dw	HeadFix_Trap
MySeg:		dw	0	; put our own segment here
LTpa:		dw	0	; will store tpa segment here
RSwitChar:	db	"/"
RDirChar:	db	"\"
		;dw	offset DATARES:Issue_Exec_Call
		dw	Issue_Exec_Call
MySeg1:		dw	0
		;dw	offset DATARES:RemCheck_Trap
		dw	RemCheck_Trap
MySeg2:		dw	0
ResTest: 	dw	0
Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
TranVarEnd:	; label	byte

OldErrNo:	dw	0

;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
;  MsgBuffer is only used while a command is being executed.
;  SafePathBuffer is no longer needed, since it is used for
;  unsuccessful program launches.

MsgBuffer:	; label	byte	; buffer for messages from disk
SafePathBuffer: ; label	byte	; resident pathname for EXEC
	;Bugbug: Why so big a buffer?
		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
		times	64+3+13 db 0		

LENMSGORPATHBUF	equ $ - MsgBuffer

Int2fHandler:	dd	0	; address of next int 2f handler
ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)

;SR;
; The three vars below have been added for a pure COMMAND.COM

ResSize:	dw	0

;SR;
; Moved the stack here from the code segment
;
; bugbug: Why this odd stack size? And what should stack size be?
	
		;db	(80h - 3) dup (?)
align 2
		times	124 db 0		
; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
RStack:		; label	word
OldDS:		dw	0	; keeps old ds value when jumping to
				; resident code segments
;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003

; include highvar.inc		; Add variables for 6.0 loadhigh functionality
; -------------------------------

; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
; SegLoad  - Segment address for first UMB specified; set automatically.
; UmbLoad  - The load UMB number; for example, this is 3 if the user has
;            given a command-line like "/L:3,500;4"
; UmbUsed  - An array of characters, each of which is 1 iff the UMB
;            matching its index number was specified on the command-line;
;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
;            will be set to 1.  All others will be set to 0.
; UmbSize  - An array of words, each of which is interpereted as a size
;            specified by the user for a UMB (in the above example, all
;            elements would be zero save UmbSize[3], which would be 500.
; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
; fm_strat - Set to the old memory-allocation strategy (0$00000???)
; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
;            for details).

; - MSDOS 6.0 COMMAND.COM -
;; To keep track of which UMBs were specified on the DH/LH command lines, and
;; to keep track of the minimum sizes given for each, there're two arrays kept
;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
;; big. 16 should be around 14 too many for most users, so there's no expected
;; space problem (it's just such a nice round number, eh?).

;MAXUMB	equ	16

; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)

fInHigh:	db	0

; MSDOS 6.0 COMMAND.COM
;fUmbTiny:	db	0
;SegLoad:	dw	0
;UmbLoad:	db	0
;UmbUsed:	db	times MAXUMB db 0 ; db MAXUMB dup (?)
;UmbSize:	dw	times MAXUMB dw 0 ; dw MAXUMB dup (?)
;fm_umb:	db	0
;fm_strat:	db	0
;fm_argc:	db	0

; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
; UmbLoad is set to the UMB number given.

;*** MESSAGES
;    and other translatable text

; include comrmsg.inc	; M00
; ------------------------------

; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)

ABORT_CHAR:	db 'A'
RETRY_CHAR:	db 'R'
IGNORE_CHAR:	db 'I'
FAIL_CHAR:	db 'F'
YES_CHAR:	db 'Y'
NO_CHAR:	db 'N'
REQ_ABORT:	db 5
		db 'Abort'
REQ_RETRY:	db 7
		db ', Retry'
REQ_IGNORE:	db 8
		db ', Ignore'
REQ_FAIL:	db 6
		db ', Fail'
REQ_END:	db 1
		db '?'
MREAD:		db 8
		db 'reading', 0
MWRITE:		db 8
		db 'writing', 0
MDRIVE:		db 14
		db ' %1 drive %2',0Dh,0Ah
MDEVICE:	db 15
		db ' %1 device %2',0Dh,0Ah
MVOLSERIAL:	db 38
		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
BADFATMSG:	db 37
		db 'File allocation table bad, drive %1',0Dh,0Ah
COMBAD:		db 21
		db 'Invalid COMMAND.COM',0Dh,0Ah
PUTBACKMSG:	db 33
		db 'Insert disk with %1 in drive %2',0Dh,0Ah
PROMPT:		db 33
		db 'Press any key to continue . . .',0Dh,0Ah
ENDBATMES:	db 28
		db 0Dh,0Ah
		db 'Terminate batch job (Y/N)?'
EXECEMES:	db 19
		db 'Cannot execute %1',0Dh,0Ah
EXEBAD:		db 19
		db 'Error in EXE file',0Dh,0Ah
TOOBIG:		db 34
		db 'Program too big to fit in memory',0Dh,0Ah
NOHANDMES:	db 22
		db 0Dh,0Ah
		db 'No free file handles'
RBADNAM:	db 26
		db 'Bad Command or file name',0Dh,0Ah
ACCDENIED:	; 14/01/2023
		; 10/01/2023
ACCDEN:		db 14
		db 'Access denied '
BMEMMES:	db 25
		db 0Dh,0Ah,'Memory allocation error'
HALTMES:	db 38
		db 0Dh,0Ah
		db 'Cannot load COMMAND, system halted',0Dh,0Ah
FRETMES:	db 33
		db 0Dh,0Ah,
		db 'Cannot start COMMAND, exiting',0Dh,0Ah
PATRICIDE:	db 46
		db 0Dh,0Ah
		db 'Top level process aborted, cannot continue'
		db 0Dh,0Ah
NEWLINE:	db 2
		db 0Dh, 0Ah

; 10/01/2023
; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh

MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
		dw 1
		dw PARSMSGPTRS		; parse	error messages
		dw 1
		dw EXTMSGPTRS		; critical error messages
		dw 1
		dw 0			; File system error messages
		dw 0			; are not supported.
		dw MsgRetrv_Trap	; disk retriever routine
MySeg3:		dw 0			; segment of retriever routine

; MSDOS 5.0 COMMAND.COM RESGROUP:0791h

CRMSG0:		db 19
		db 'Write protect error'
CRMSG1:		db 12
		db 'Invalid unit'
CRMSG2:		db 9
		db 'Not ready'
CRMSG3:		db 22
		db 'Invalid device request'
CRMSG4:		db 10
		db 'Data error'
CRMSG5:		db 33
		db 'Invalid device request parameters'
CRMSG6:		db 10
		db 'Seek error'
CRMSG7:		db 18
		db 'Invalid media type'
CRMSG8:		db 16
		db 'Sector not found'
CRMSG9:		db 26
		db 'Printer out of paper error'
CRMSG10:	db 17
		db 'Write fault error'
CRMSG11:	db 16
		db 'Read fault error'
CRMSG12:	db 15
		db 'General failure'
CRMSG13:	db 17
		db 'Sharing violation'
CRMSG14:	db 14
		db 'Lock violation'
CRMSG15:	db 19
		db 'Invalid disk change'
CRMSG16:	db 15
		db 'FCB unavailable'
CRMSG17:	db 25
		db 'System resource exhausted'
CRMSG18:	db 18
		db 'Code page mismatch'
CRMSG19:	db 12
		db 'Out of input'
CRMSG20:	db 23
		db 'Insufficient disk space'

; MSDOS 5.0 COMMAND.COM RESGROUP:0914h

CRITMSGPTRS:	dw CRMSG0
		dw CRMSG1
		dw CRMSG2
		dw CRMSG3
		dw CRMSG4
		dw CRMSG5
		dw CRMSG6
		dw CRMSG7
		dw CRMSG8
		dw CRMSG9
		dw CRMSG10
		dw CRMSG11
		dw CRMSG12
		dw CRMSG13
		dw CRMSG14
		dw CRMSG15
		dw CRMSG16
		dw CRMSG17
		dw CRMSG18
		dw CRMSG19
		dw CRMSG20

		; 14/01/2023
DataresEnd:	; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)

PAERRMSG0:	db 19
		db 'Too many parameters'
PAERRMSG1:	db 26
		db 'Required parameter missing'
PAERRMSG2:	db 14
		db 'Invalid switch'
PAERRMSG3:	db 15
		db 'Invalid keyword'
PAERRMSG4:	db 1
		db 20h
PAERRMSG5:	db 36
		db 'Parameter value not in allowed range'
PAERRMSG6:	; 10/01/2023
PAERRMSG7:	db 27
		db 'Parameter value not allowed'
;PAERRMSG7:	db 27
;		db 'Parameter value not allowed'
PAERRMSG8:	db 28
		db 'Parameter format not correct'
PAERRMSG9:	db 17
		db 'Invalid parameter'
PAERRMSG10:	db 29
		db 'Invalid parameter combination'

; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h

PARSMSGPTRS:	dw PAERRMSG0
		dw PAERRMSG1
		dw PAERRMSG2
		dw PAERRMSG3
		dw PAERRMSG4
		dw PAERRMSG5
		dw PAERRMSG6
		dw PAERRMSG7
		dw PAERRMSG8
		dw PAERRMSG9
		dw PAERRMSG10
; 21/04/2023
NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023

INVLFUNCT:	db 16
		db 'Invalid function'
FNOTFOUND:	db 14
		db 'File not found'
PNOTFOUND:	db 14
		db 'Path not found'
TOOMANYOF:	db 19
		db 'Too many open files'
; 14/01/2023
;ACCDEN:	; 10/01/2023
;ACCDENIED:	db 14
;		db 'Access denied '
INVHANDLE:	db 14
		db 'Invalid handle'
MEMCBDEST:	db 31
		db 'Memory control blocks destroyed'
INSUFFMEM:	db 19
		db 'Insufficient memory'
INVMEMBLA:	db 28
		db 'Invalid memory block address'
INVENVIRO:	db 19
		db 'Invalid Environment'
INVFORMAT:	db 14
		db 'Invalid format'
INVFNPARM:	db 26
		db 'Invalid function parameter'
INVLDDATA:	db 12
		db 'Invalid data'
INVDRVSPC:	db 27
		db 'Invalid drive specification'
ATRCURDIR:	db 35
		db 'Attempt to remove current directory'
NOTSAMDEV:	db 15
		db 'Not same device'
NOMOREFIL:	db 13
		db 'No more files'
FILEXISTS:	db 11
		db 'File exists'
CANTMKDIR:	db 27
		db 'Cannot make directory entry'
FAILINT24:	db 14
		db 'Fail on INT 24'
TOOMANYRD:	db 21
		db 'Too many redirections'
DUPLREDIR:	db 21
		db 'Duplicate redirection'
INVPASSWD:	db 16
		db 'Invalid password'
INVLDPARM:	db 17
		db 'Invalid parameter'
NETDATFAU:	db 18
		db 'Network data fault'
FNOSUPNET:	db 33
		db 'Function not supported by network'
RSCNOTINS:	db 39
		db 'Required system component not installed'

; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch

EXTMSGPTRS:	dw INVLFUNCT
		dw FNOTFOUND
		dw PNOTFOUND
		dw TOOMANYOF
		dw ACCDENIED
		dw INVHANDLE
		dw MEMCBDEST
		dw INSUFFMEM
		dw INVMEMBLA
		dw INVENVIRO
		dw INVFORMAT
		dw INVFNPARM
		dw INVLDDATA
		dw 0
		dw INVDRVSPC
		dw ATRCURDIR
		dw NOTSAMDEV
		dw NOMOREFIL
		dw CRMSG0
		dw CRMSG1
		dw CRMSG2
		dw CRMSG3
		dw CRMSG4
		dw CRMSG5
		dw CRMSG6
		dw CRMSG7
		dw CRMSG8
		dw CRMSG9
		dw CRMSG10
		dw CRMSG11
		dw CRMSG12
		dw CRMSG13
		dw CRMSG14
		dw CRMSG15
		dw CRMSG16
		dw CRMSG17
		dw CRMSG18
		dw CRMSG19
		dw CRMSG20
		times 40 dw 0	; db 80 dup(0)
		dw FILEXISTS
		dw 0
		dw CANTMKDIR
		dw FAILINT24
		dw TOOMANYRD
		dw DUPLREDIR
		dw INVPASSWD
		dw INVLDPARM
		dw NETDATFAU
		dw FNOSUPNET
		dw RSCNOTINS
; ----------------------------------------------------------------------------
	; 17/04/2023
ExtMsgEnd:

; 21/04/2023
NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023

; ----------------------------------------------------------------------------

; 20/04/2023

align 16

; ----------------------------------------------------------------------------

; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)

; ----------------------------------------------------------------------------
; SEGMENT - CODERES
; ----------------------------------------------------------------------------

; 11/01/2023
RCODE_START:	

; ----------------------------------------------------------------------------
;***	EXEC error handling
;
;	COMMAND has issued an EXEC system call and it has returned an error.
;	We examine the error code and select an appropriate message.
; --------------------------
;	Bugbug:	optimize reg usage in following code? Careful of DX!
;	Condense the error scan?
;	RBADNAM is checked by transient, no need here?
;	Move below Ext_Exec.
; ----------------------------------------------------------------------------

Exec_Err:
;SR;
; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
; in order here

;	Bugbug:	can we use byte compares here?
;	Might be able to use byte msg#s, too.

;	Store errors in a 3 or 4 byte table. Msg #s in another.
;	Speed not high priority here.

;	Move this to transient.

	; 10/01/2023

	;mov	bx,RBADNAM	; offset DATARES:RBadNam
	mov	dx,RBADNAM
	cmp	al,ERROR_FILE_NOT_FOUND ; 2
	je	short GotExecEMes		; bad command
	;mov	bx,TOOBIG	; offset DATARES:TooBig
	mov	dx,TOOBIG
	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
	je	short GotExecEMes		; file not found
	;mov	bx,EXEBAD	; offset DATARES:ExeBad
	mov	dx,EXEBAD
	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
	je	short GotExecEMes		; bad exe file
	;mov	bx,ACCDEN	; offset DATARES:AccDen
	mov	dx,ACCDEN
	cmp	al,ERROR_ACCESS_DENIED ; 5
	je	short GotExecEMes		; access denied

Default_Message:
	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
	mov	dx,EXECEMES
						; default message
	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
						; get address of subst block
GotExecEMes:
	;mov	dx,bx				; DX = ptr to msg
	call	RPrint ; invoke	RPrint
	jmp	short NoExec

; ----------------------------------------------------------------------------
;***	EXEC call
;
;	The transient has set up everything for an EXEC system call.
;	For cleanliness, we issue the EXEC here in the resident 
;	so that we may be able to recover cleanly upon success.
;
;	CS,DS,ES,SS = DATARES seg addr
; ----------------------------------------------------------------------------

Ext_Exec:
;SR;
; The words put on the stack by the stub will be popped off when we finally
;jump to LodCom (by LodCom).

	; 10/01/2023
	;int	21h			; do the exec
	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
Exec_Ret:
	jc	short Exec_Err		; exec failed

;	The exec has completed. Retrieve the exit code.

Exec_Wait:
	mov	ah,4Dh
	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
	int	21h			; get the return code
	;mov	[cs:RetCode],ax
	; 11/01/2023
	mov	[RetCode],ax

;	See if we can reload the transient. The external command
;	may have overwritten part of the transient.

NoExec:
;SR;
; ds = es = ss = DATARES when we jump to LodCom
;
	jmp	LodCom

; ----------------------------------------------------------------------------
;***	Int 23 (ctrl-c) handler
;
;	This is the default system INT 23 handler. All processes
;	(including COMMAND) get it by default. There are some
;	games that are played: We ignore ^C during most of the
;	INIT code. This is because we may perform an ALLOC and
;	diddle the header! Also, if we are prompting for date/time
;	in the init code, we are to treat ^C as empty responses.
; ---------------------------
;	Bugbug:	put init ctrl-c handling in init module.
; ----------------------------------------------------------------------------

;SR;
;The stub has pushed the previous ds and DATARES onto the stack. We get
;both these values off the stack now
;
;ContC	proc	far

;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
ContC:
	pop	ds			; ds = DATARES
;	assume	ds:DATARES
;;	pop	word [OldDS]		; OldDS = old ds

	test	byte [InitFlag],INITINIT ; 1
	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
	jz	short NotAtInit		; no
	test	byte [InitFlag],INITSPECIAL ; 2 
	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
	jz	short CmdIret		; no, ignore ^C
	pop	ds			; restore before jumping; M021
	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
	jmp	init_contc_specialcase
CmdIret:
;SR;
; Restore ds to its previous value
;

;;	mov	ds,[OLdDS]		;
	pop	ds
	iret				; yes, ignore the ^C

NotAtInit:
	test	byte [InitFlag],INITCTRLC ; 4
	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
	jz	short NotInit 		; nope too.

;*	We are interrupting ourselves in this ^C handler. We need
;	to set carry and return to the user sans flags only if the
;	system call was a 1-12 one. Otherwise, we ignore the ^C.

	cmp	ah,1
	jb	short CmdIret
	cmp	ah,12
	ja	short CmdIret

	pop	ds			;restore ds to old value
	add	sp,6			; remove int frame
	stc

;;	mov	ds,[OldDS]		;restore ds to its old value
	retf	2			; remove those flags...

NotInit:

;*	We have now received a ^C for some process (maybe ourselves
;	but not at INIT).
;	
;	Note that we are running on the user's stack!!! Bad news if
;	any of the system calls below go and issue another INT
;	24... Massive stack overflow! Another bad point is that
;	SavHand will save an already saved handle, thus losing a
;	possible redirection...
;	
;	All we need to do is set the flag to indicate nested ^C. 
;	The above code will correctly flag the ^C diring the
;	message output and prompting while ignoring the ^C the rest
;	of the time.
;	
;	Clean up: flush disk. If we are in the middle of a batch
;	file, we ask if he wants to terminate it. If he does, then
;	we turn off all internal flags and let the DOS abort.

	or	byte [InitFlag],INITCTRLC ; 4
	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
	sti

;	push	cs			; el yucko! change the user's ds!!
;	pop	ds

;	assume	ds:RESGROUP

	pop	ax			; discard the old ds value

	mov	ax,[SingleCom]
	or	ax,ax
	jnz	short NoReset
	push	ax
	mov	ah,DISK_RESET ; 0Dh
	int	21h			; reset disks in case files were open
	pop	ax

NoReset:

;	In the generalized version of FOR, PIPE and BATCH, we would
;	walk the entire active list and free each segment. Here,
;	we just free the single batch segment.

	test	word [Batch],-1 ; 0FFFFh
	jz	short ContCTerm
	or	ax,ax
	jnz	short ContCTerm
	call	SavHand
	call	AskEnd			; ask if user wants to end batch

;	If the carry flag is clear, we do NOT free up the batch file

	jnc	short ContBatch
	mov	cl,[EchoFlag]		; get current echo flag
	push	bx

ClearBatch:
	mov	es,[Batch]		; get batch segment
	;mov	di,20h
	; 06/06/2023 (BugFix)
	mov	di,BATCHSEGMENT.BatFile ; get offset of batch file name
	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
	;mov	bx,es:BatForPtr		; get old FOR segment
	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
	; MSDOS 3.3 ([ES:4])
	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
	;
	cmp	bx,0			; is a FOR in progress
	je	short No_Bat_For	; no - don't deallocate
	push	es			;
	mov	es,bx			; yes - free it up...
	mov	ah,49h
	;mov	ah,DEALLOC ; 49h	;
	int	21h			;
	pop	es			; restore to batch segment

No_Bat_For:
	;mov	cl,[es:1]
	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
	;mov	bx,[es:3]
	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
	mov	ah,49h
	;mov	ah,DEALLOC ; 49h	; free it up...
	int	21h
	mov	[Batch],bx		; get ready to deallocate next batch
	dec	word [Nest]		; is there another batch file?
	jnz	short ClearBatch	; keep going until no batch file

;	We are terminating a batch file; restore the echo status

;Shell_Bat_Cont: 			; continue batch for SHELL
	pop	bx
	mov	[EchoFlag],cl		; reset echo status
	; 29/05/2018
	mov	byte [PipeFlag],0	; turn off pipeflag

ContBatch:
	call	crlf			; print out crlf before returning
	call	RestHand

;	Yes, we are terminating. Turn off flags and allow the DOS to abort.

ContCTerm:
	xor	ax,ax			; indicate no read
	mov	bp,ax

;	The following resetting of the state flags is good for the
;	generalized batch processing.

	mov	[IfFlag],al		; turn off iffing
	mov	[ForFlag],al		; turn off for processing
	call	ResPipeOff
	cmp	[SingleCom],ax		; see if we need to set SingleCom
	jz	short NoSetSing
	mov	word [SingleCom],-1	; cause termination on 
					;  pipe, batch, for
NoSetSing:

;	If we are doing an internal command, go through the reload process.
;	If we are doing an external, let DOS abort the process.
;	In both cases, we are now done with the ^C processing.

	and	byte [InitFlag],~INITCTRLC ; 0FBh
	cmp	[ExtCom],al
	jnz	short DoDAb		; internal ^c
	jmp	LodCom1
DoDAb:
	stc				; tell dos to abort

;SR;
;We dont need to restore ds here because we are forcing DOS to do an abort
;by setting carry and leaving flags on the stack

	retf				; Leave flags on stack

;ContC	endp

;SR;
;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
;both have ds = DATARES

	; 11/01/2023
ResPipeOff:
	push	ax
	xor	ax,ax
	;xchg	al,[cs:PIPEFLAG]
	xchg	al,[PipeFlag]
	or	al,al
	jz	short NoPipePop
	;shr	byte [cs:ECHOFLAG],1
	shr	byte [EchoFlag],1
NoPipePop:
	pop	ax
	retn

;CODERES ends

;=============================================================================
; COMMAND2.ASM, MSDOS 6.0, 1991
;=============================================================================
; 21/09/2018 - Retro DOS v3.0

;	title	COMMAND2 - resident code for COMMAND.COM part II
;	name	COMMAND2

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;
;	Revision History
;	================
;
; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
;			reserve memory by changing int 12h and then give it
;			back to DOS by changing arenas in autoexec.bat.
;			This makes command.com reload transient and this
;			cannot be done at this stage.
;

;CODERES segment public byte

;*	If we cannot allocate enough memory for the transient or there
;	was some other allocation error, we display a message and
;	then die.

;SR;
; We will have to make sure that at this entry point and at FatalC, 
;ds = DATARES. All jumps to these points are made from only within this file
;and so we should be able to do this

; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)

	;assume	ds:DATARES
BadMemErr:
	mov	dx,BMEMMES			; DX = ptr to msg
FatalC:
	; 12/01/2023
;;	push	cs
;;	pop	ds
;;	assume	ds:ResGroup
;	invoke	RPrint

	; 12/01/2023
	; MSDOS 5.0 (& MSDOS 6.0-6.22)
	call	RPrint

	; MSDOS 3.3
	;call	RDISPMSG

;	If this is NOT a permanent (top-level) COMMAND, then we exit;
;	we can't do anything else!

	cmp	byte [PermCom],0
	je	short FatalRet

;	We are a permanent command. If we are in the process of the
;	magic interrupt (Singlecom) then exit too.

	cmp	word [SingleCom],0		; if PermCom and SingleCom
	jne	short FatalRet			; must take int_2e exit

;	Permanent command. We can't do ANYthing except halt.

	mov	dx,HALTMES			; DX = ptr to msg
	;invoke	RPrint
	; 12/01/2023	
	; MSDOS 5.0 (& MSDOS 6.0-6.22)
	call	RPrint	
	; MSDOS 3.3
	;call	RDISPMSG
	sti
Stall:
	jmp	short Stall			; crash the system nicely

FatalRet:
	mov	dx,FRETMES			; DX = ptr to msg
	;call	RDISPMSG
	; 12/01/2023	
	call	RPrint	
FatalRet2:
	cmp	byte [PermCom],0		; if we get here and PermCom,
	jne	short Ret_2e			; must be int_2e

;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
;	were a non-permanent COMMAND that had hooked it! (Just in 
;	case we decide to do that.)

	mov	ax,[Parent]
	;mov	[16h],ax
	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
	mov	ax,[OldTerm]
	;mov	[0Ah],ax
	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
	mov	ax,[OldTerm+2]
	;mov	[0Ch],ax
	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
	mov	ax,4C00h
	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
	int	21h
Ret_2e:
;SR;
; We will ensure that ds = DATARES for all entries to this place
;

;;	push	cs
;;	pop	ds
;;	assume	ds:resgroup,es:nothing,ss:nothing
  	
;	assume	ds:DATARES

	;PUSH	CS
	;POP	DS

	mov	word [SingleCom],0	; turn off SingleCom
	mov	es,[Res_Tpa]
	;mov	ah,49h	; 12/01/2023
	mov	ah,DEALLOC
	int	21h			; free up space used by transient
	mov	bx,[Save_Pdb]
	mov	ah,50h
	;mov	ah,SET_CURRENT_PDB ; 50h
	int	21h			; current process is user
	mov	ax,[RetCode]
	cmp	byte [ExtCom],0
	jne	short GotECode
	xor	ax,ax			; internals always return 0
GotECode:
	mov	byte [ExtCom],1		; force external

;SR; This is actually returning to the caller. However, the old code had
;ds = RESGROUP so I guess we can keep ds = DATARES for us.
;Yes, int 2eh can corrupt all registers so we are ok.

	; 12/01/2023
	jmp	far [Int_2e_Ret]	; "iret"

;***	Int_2e, magic command executer

Int_2e:
	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
;SR;
;We are going to come here from the stub with the old ds and DATARES value
;pushed on the stack in that order. Pick up this stuff off the stack

	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)

	pop	ds			; ds = DATARES
	;assume	ds:DATARES
	pop	ax
;	;pop	ds:OldDS 		; Save old value of ds

	;pop	word [cs:Int_2e_Ret]
	;pop	word [cs:Int_2e_Ret+2]	; store return address
	;pop	ax			; chuck flags
	pop	word [Int_2e_Ret]
	pop	word [Int_2e_Ret+2]
	
	add	sp,2

;;	push	cs
;;	pop	es

	push	ds
	pop	es			; es = DATARES
;	;mov	ds,OldDS
	mov	ds,ax
	;assume	ds:nothing		; ds = old value

	mov	di,80h
	mov	cx,64
;	Bugbug:	cld
	rep	movsw
	mov	ah,51h
	;mov	ah,GET_CURRENT_PDB ; 51h
	int	21h			; get user's header
	; 12/01/2023
	mov	[es:Save_Pdb],bx
	;mov	[cs:Save_Pdb],bx
	mov	ah,50h
	;mov	ah,SET_CURRENT_PDB ; 50h

;;	mov	bx,cs
;SR;
;Set ds = DATARES because BadMemErr expects this

	; 12/01/2023
	push	es
	pop	ds
	;assume	ds:DATARES

	mov	bx,ds			; es = our PSP now
	;mov	bx,cs

	int	21h			; current process is me
	;mov	word [cs:SingleCom],81h
	;mov	byte [cs:ExtCom],1	; make sure this case forced
	; 12/01/2023
	mov	word [SingleCom],81h
	mov	byte [ExtCom],1		; make sure this case forced

;SR;
;We can enter LodCom directly after a command shell is terminated or we
;can fall thru from above. When we enter directly from the stub, the stack
;has the old ds value and the data seg value on the stack, so that ds can
;be properly set. To fake this, we push dummy values here.

	; 12/01/2023
	push	ds			; old value of ds
	push	ds			; data seg value, ds = DATARES
LodCom: 				; termination handler
	pop	ds			; ds = DATARES
	;assume	ds:DATARES
	add	sp,2
;	;pop	OldDS			; store old ds
	;cmp	ExtCom,0
	cmp	byte [ExtCom],0
	;cmp	byte [cs:ExtCom],0
	;jne	short @f	 	; internal cmd - memory allocated
	; 16/04/2023
	jne	short LodCom0 ; 24/09/2018
	jmp	LodCom1
	;je	short LodCom1 ; 25/09/2018	
;@@:
LodCom0: ; 24/09/2018
	mov	bx,0FFFFh
	mov	ah,48h	; 12/01/2023
	;mov	ah,ALLOC ; 48h	
	int	21h		; DOS - 2+ - ALLOCATE MEMORY
				; BX = number of 16-byte paragraphs desired
	call	SetSize
	add	ax,20h
	cmp	bx,ax
	jnb	short MemOk		; > 512 byte buffer - good enough
BadMemErrJ:
	jmp	BadMemErr		; not enough memory

;***	SetSize - get transient size in paragraphs

SetSize:
	; 12/01/2023
	;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
	;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
	mov	cl,4
	shr	ax,cl
	retn

MemOk:
	;assume	ds:DATARES		;we have set ds = DATARES 

	mov	ah,48h
	;mov	ah,ALLOC  ; 48h
	int	21h
	jc	short BadMemErrJ	; memory arenas probably trashed
	;mov	byte [cs:ExtCom],0
	;mov	[cs:Res_Tpa],ax
	; 12/01/2023
	mov	byte [ExtCom],0		; flag not to alloc again
	mov	[Res_Tpa],ax		; save current tpa segment

	and	ax,0F000h
	add	ax,1000h		; round up to next 64k boundary
	jc	short Bad_Tpa		; memory wrap if carry set

;	Make sure that new boundary is within allocated range

	;mov	dx,[cs:Res_Tpa]
	; 12/01/2023
	mov	dx,[Res_Tpa]
	add	dx,bx			; compute maximum address
	cmp	dx,ax			; is 64k address out of range?
	jbe	short Bad_Tpa

;	Must have 64K of usable space.

	sub	dx,ax			; compute the usable space
	cmp	dx,1000h		; is space >= 64k ?
	jae	short LTpaSet
Bad_Tpa:
	;mov	ax,[cs:Res_Tpa]
	; 12/01/2023
	mov	ax,[Res_Tpa]
LTpaSet:
	;mov	[cs:LTPA],ax
	;mov	ax,[cs:Res_Tpa]
	; 12/01/2023
	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
	add	bx,ax
	;mov	[cs:MemSiz],bx
	mov	[MemSiz],bx
	call	SetSize
	sub	bx,ax

	; MSDOS 6.0

;M038; Start of changes
;Changes for Novell RPL. These guys reserve memory for themselves by
;reducing int 12h size and add this memory to the system at autoexec time by
;running a program that changes arenas. This changes the largest block that
;command.com gets and so changes the transient segment. So, command.com does
;a checksum at the wrong address and thinks that the transient is destroyed
;and tries to reload it. At this point, no Comspec is defined and so the
;reload fails, hanging the system. To get around this we just copy the
;transient from the previous address to the new address(if changed) and
;then let command.com do the checksum. So, if the transient area is not
;corrupted, there will not be any reload. In Novell's case, the transient
;is not really corrupted and so this should work.

	; 12/01/2023
	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)

	cmp	bx,[TrnSeg]		; Segment still the same?
	je	short LodCom1		; yes, dont copy

;Check if the new segment is above or below the current move. If the new
;segment is above (i.e new block is larger than previous block), then we
;have to move in the reverse direction

	;mov	cx,98C5h
	mov	cx,TRANSPACEEND		; cx = length to move
	ja	short mov_down		; new seg > old seg, reverse move
	xor	si,si			; normal move
	mov	di,si
	cld
	jmp	short copy_trans
mov_down:
	mov	si,cx			; reverse move, start from end
	dec	si
	mov	di,si
	std
copy_trans:
	push	ds
	push	es
	mov	es,bx			; dest segment
	mov	ds,[TrnSeg]		; source segment
	;assume	ds:nothing

	rep	movsb			; copy transient
	cld
	pop	es
	pop	ds
	;assume	ds:DATARES

;M038; End of changes

	;mov	[cs:TrnSeg],bx		; new location of transient
	; 12/01/2023
	mov	[TrnSeg],bx

LodCom1:
;;	mov	ax,cs
;;	mov	ss,ax
;SR; At this point ds = DATARES which is where the stack is located

	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 (& MSDOS 6.0-6.22)
	mov	ax,ds
	mov	ss,ax
	;assume	ss:DATARES
	;;mov	sp,offset DATARES:RStack
	;mov	sp,53Eh
	mov	sp,RStack

;;	mov	ds,ax

	;assume	ds:DATARES
	
	; MSDOS 3.3
	;mov	ax,cs
	;mov	ss,ax
	;mov	sp,RSTACK
	;mov	ds,ax

	call	HeadFix			; close files, restore stdin, stdout
	xor	bp,bp			; flag command ok
	mov	ax,-1
	xchg	ax,[VerVal]
	cmp	ax,-1
	je	short NoSetVer
	mov	ah,2Eh
	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
	int	21h 		; DOS - SET VERIFY FLAG
				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
NoSetVer:
	cmp	word [SingleCom],-1
	jne	short NoSng
	jmp	FatalRet2		; we have finished the single command
NoSng:
	call	ChkSum			; check the transient
	;cmp	dx,[Sum]
	;je	short HavCom		; transient ok
	; 12/01/2023
	jz	short HavCom
Bogus_Com:
	mov	byte [Loading],1	; flag DskErr routine
	call	LoadCom
ChkSame:
	call	ChkSum
	;cmp	dx,[Sum]
	;je	short HavCom		; same command
	; 12/01/2023
	jz	short HavCom
Also_Bogus:
	call	WrongCom
	jmp	short ChkSame

	; 12/01/2023
;HavCom:
;	; 25/09/2018
;	mov     ax,(CHAR_OPER*256) ; 3700h
;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
;			; Return: AL = FFh unsupported subfunction
;			; DL = current switch character
;	mov     [RSWITCHAR],dl
;	cmp     dl,'/'
;	jnz     short USESLASH
;	;mov	cl,'\'
;	;mov	[RDIRCHAR],cl
;	mov	byte [RDIRCHAR],'\'
;USESLASH:

HavCom:
	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
	mov	byte [Loading],0		; flag to DskErr
	;;mov	si,offset DATARES:TranVars
	;mov	si,453h		; MSDOS 5.0 COMMAND.COM
	mov	si,TranVars
	;;mov	di,offset TRANGROUP:HeadCall
	;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
	mov	di,HEADCALL
	mov	es,[TrnSeg]
	cld
	;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
	mov	cx,TranVarEnd
	sub	cx,si
	rep	movsb			; transfer info to transient
	mov	ax,[MemSiz]
	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header

;***	TJmp - jump-off to transient
;
;	Public label so debugger can find this spot.

TJmp:	; 12/01/2023
	jmp	far [Trans]		; jmp dword ptr Trans

;***	TRemCheck - far version of RemCheck for transient

TRemCheck:
	; 12/01/2023
	pop	ds			; ds = DATARES
	add	sp,2			; discard old value of ds

	call	RemCheck
	retf

;***	RemCheck
;
;	ENTRY	AL = drive (0=default, 1=A, ...)
;
;	EXIT	ZR set if removeable media
;		ZR clear if fixed media
;
;	USED	none

	; 12/01/2023
RemCheck:
	push	ax
	push	bx
	mov	bx,ax
	mov	ax,4408h
	;mov	ax,(IOCTL<<8)+8 ; 4408h
	int	21h		; DOS - 2+ - IOCTL -
	jnc	short rcCont		

;	If an error occurred, assume the media is non-removable.
;	AX contains the non-zero error code from the int 21, so
;	'or ax,ax; sets non-zero. This behavior makes network drives
;	appear to be non-removable.				
					
	or	ax,ax			
	jmp	short ResRegs
rcCont:
	and	ax,1
	not	ax
ResRegs:
	pop	bx
	pop	ax
	retn

;***	THeadFix
;
;	Far version of HeadFix, called from transient.

THeadFix:
	; 12/01/2023
	pop	ds			; ds = DATARES
	add	sp,2			; discard old ds value on stack

	call	HeadFix
	retf

;***	HeadFix

	; 12/01/2023
HeadFix:
	call	SetVect			; set vectors to our values

;	Clean up header

;	Bugbug:	optimize:
;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes

	xor	bx,bx			; BX = handle = 0
	mov	cx,[Io_Save]		; CX = original stdin, stdout
	;mov	dx,[18h] 
	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
	cmp	cl,dl
	je	short Chk1		; stdin matches
	mov	ah,3Eh
	;mov	ah,CLOSE  ; 3Eh
	int	21h			; close stdin
	;mov	[18h],cl
	mov	[PDB.JFN_TABLE],cl	; restore stdin
Chk1:
	inc	bx			; BX = handle = 1
	cmp	ch,dh			
	je	short ChkOtherHand	; stdout matches
	mov	ah,3Eh
	;mov	ah,CLOSE
	int	21h			; close stdout
	;mov	[19h],ch
	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
ChkOtherHand:
	add	bx,4			; skip handles 2,3,4
	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
					; (handles 0-4 already done)
CloseLoop:
	mov	ah,3Eh
	;mov	ah,CLOSE ; 3Eh
	int	21h			; close each handle
	inc	bx			; BX = next handle
	loop	CloseLoop

	; MSDOS 6.0
;	Bugbug:	since this is for transient code, move it there
	
	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)

;	M012: remove this CS -> DS. Must've been missed during
;	purification.
;;	push	ds			; save data segment
;;	push	cs			; get local segment into DS
;;	pop	ds			;
	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
	jne	short Append_Fix_End	; no - just exit
	mov	ax,0B707h
	;mov	ax,AppendSetState	; set the state of Append
	mov	bx,[Append_State] 	; back to the original state
	int	2Fh			;
	mov	byte [Append_Flag],0	; set append flag to invalid
Append_Fix_End: 			;
;;	pop	ds			; get data segment back
	retn

	; MSDOS 3.3
	;retn

;***	SavHand - save current program's stdin/out & set to our stderr
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Handle01 = current program's stdin,stdout JFN entries
;	  current program's stdin,stdout set to our stderr
;

;SR;
; Changed ds = DATARES. We need it to access our JFN_Table
; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).

SavHand:
	;assume	ds:DATARES,es:NOTHING,ss:NOTHING

	; 12/01/2023
	;push	ds ; MSDOS 3.3

	push	bx			;preserve registers
	push	ax
	; 12/01/2023
	push	es
	push	ds			; save DATARES value

	mov	ah,51h
	;mov	ah,GET_CURRENT_PDB ; 51h
	int	21h			; BX = user's header seg addr
	mov	ds,bx			; DS = user's header seg addr
	;lds	bx,[34h]	
	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
	mov	ax,[bx]			; AX = stdin,stdout JFN's
	; 12/01/2023
	pop	es			; es = DATARES
	push	es			; save it back on stack
	mov	[es:Handle01],ax	; save user's stdin, stdout
	;mov	[cs:HANDLE01],ax

;SR;
; Use es to address Handle01 & our JFN_Table

	; 12/01/2023
	;mov	al,[es:1Ah]
	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
	mov	ah,al			; AH = COMMAND stderr
	mov	[bx],ax			; set user's stdin/out to our stderr
	; 12/01/2023
	pop	ds			; restore registers
	pop	es
	pop	ax
	pop	bx
	;pop	ds ; MSDOS 3.3
	retn

	;assume	ds:DATARES
GetComDsk2:
	call	GetComDsk
	jmp	LodCom1			; memory already allocated

RestHand:
	push	ds
	push	bx			; restore stdin, stdout to user
	push	ax
	; 12/01/2023
	mov	ah,51h
	;mov	ah,GET_CURRENT_PDB ; 51h
	int	21h			; point to user's header
	mov	ax,[Handle01]
	mov	ds,bx
	;assume ds:NOTHING
	;lds	bx,[34h] 
	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
	mov	[bx],ax			; stuff his old 0 and 1
	pop	ax
	pop	bx
	pop	ds
	retn

	;assume ds:DATARES,ss:DATARES
Hopeless:
	mov	dx,COMBAD
	jmp	FatalC

GetComDsk:
	mov	al,[ComDrv]
	call	RemCheck
	jnz	short Hopeless		; non-removable media
GetComDsk3:
	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
	jne	short GetComDsk4
	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
	; 12/01/2023
	;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
	;invoke	RPrint			; say COMMAND is invalid
	call	RPrint
	;call	RDISPMSG

GetComDsk4:

;	Bugbug:	there's always a drive here? No need to check?

	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
	jne	short Users_Drive	; yes - use it
	mov	ah,19h
	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
	int	21h
	add	al,"A"                  ; convert to ascii
	mov	[PutBackDrv],al		; put in message to print out

Users_Drive:
	; 12/01/2023
	; MSDOS 6.0
	mov	dx,PUTBACKMSG		; prompt for diskette
	;mov	si,offset DATARES:PutBackSubst
	;invoke	RPrint
	mov	si,PutBackSubst		; containing COMMAND
	call	RPrint
	;mov	dx,offset DATARES:Prompt
	;invoke	RPrint
	mov	dx,PROMPT		; "Press any key"
	call	RPrint

	; MSDOS 3.3
	;mov	dx,PUTBACKMSG		; prompt for diskette
	;call	RDISPMSG
	;mov	dx,[PUTBACKSUBSTPTR]
	;mov	si,[COMSPEC_END]
	;mov	byte [si+1],'$'
	;call	RDISPMSG
	;mov	byte [si+1],0
	;mov	dx,PROMPT
	;call	RDISPMSG

	;call	GetRawFlushedByte
	;retn
	; 12/01/2023
	;jmp	short GetRawFlushedByte

;***	GetRawFlushedByte - flush world and get raw input

GetRawFlushedByte:
	; 12/01/2023
	mov	ax,0C07h
	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
	int	21h			; get char without testing or echo
	mov	ax,0C00h
	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
	int	21h

;	Bugbug:	get rid of this return and the following retz.

LoadCom_retn:
	retn

	; 21/04/2023
TryDoOpen:
	call	GetComDsk
	;jmp	short LoadCom

;***	LoadCom - load in transient

	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)

LoadCom:
	;assume	ds:DATARES
	
	inc	bp				; flag command read

	mov	dx,ComSpec
	mov	ax,3D00h
	;mov	ax,OPEN<<8	; 3D00h
	int	21h				; open command.com
	jnc	short ReadCom
	;cmp	ax,4
	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
	jnz	short TryDoOpen
	mov	dx,NOHANDMES
	jmp	FatalC				; will never find a handle

	; 21/04/2023
;TryDoOpen:
	;call	GetComDsk
	;jmp	short LoadCom

ReadCom:
	mov	bx,ax				; BX = handle
	;mov	dx,offset RESGROUP:TranStart
	mov	dx,TRANSTART
	xor	cx,cx				; CX:DX = seek loc
	mov	ax,4200h
	;mov	ax,LSEEK<<8	; 4200h
	int	21h
	jc	short WrongCom1
	; 12/01/2023
	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
	push	ds
	mov	ds,[TrnSeg]
	;assume	ds:NOTHING
	mov	dx,100h
	mov	ah,3Fh
	;mov	ah,READ	; 3Fh	
	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
			; BX = file handle, CX = number of bytes to read
			; DS:DX -> buffer
	pop	ds
	;assume	ds:DATARES
WrongCom1:
	pushf
	push	ax
	mov	ah,3Eh
	;mov	ah,CLOSE ; 3Eh
	int	21h			; close command.com
	pop	ax
	popf
	jc	short WrongCom		; error on read
	cmp	ax,cx
	;retz				; size matched
	jz	short LoadCom_retn
WrongCom:
	mov	dx,COMBAD
	call	GetComDsk
	jmp	short LoadCom		; try again

;***	ChkSum - compute transient checksum

	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
ChkSum:
	push	ds
	mov	ds,[TrnSeg]
	mov	si,100h
	;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
	;mov	cx,87C2h
	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
Check_Sum:
	cld
	shr	cx,1
	xor	dx,dx
Chk:
	lodsw
	add	dx,ax
	adc	dx,0
	loop	Chk

	; 04/05/2023
	pop	ds

	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	cmp	dx,[Sum]

	;pop	ds ; 04/05/2023
	retn

;***	SetVect - set interrupt vectors

SetVect:
	;mov	dx,offset DATARES:LodCom_Trap 
	; 12/01/2023
	mov	dx,LodCom_Trap
	;mov	dx,LODCOM ; MSDOS 3.3
	mov	ax,2522h
	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
	int	21h
	;mov	dx,offset DATARES:Ctrlc_Trap
	mov	dx,Ctrlc_Trap
	;mov	dx,CONTC ; MSDOS 3.3
	inc	al	; 23h
	int	21h
	;mov	dx,offset DATARES:CritErr_Trap
	mov	dx,CritErr_Trap
	;mov	dx,CRITERR ; MSDOS 3.3
	inc	al	; 24h
	int	21h
	retn

	; MSDOS 6.0
;;SR;
;We have this to take care of the extra values pushed on the stack by 
;the stub before jumping to LodCom1. We set up ds here and then jump to
;Lodcom1

;public	TrnLodCom1
	; 12/01/2023
TrnLodCom1:
	pop	ds			; ds = DATARES
	add	sp,2
;	pop	ds:OldDS
	jmp	LodCom1

; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	

%if 0

;***	EndInit - end up initialization sequence
;
;	Move the environment to a newly allocated segment.

	; MSDOS 3.3
ENDINIT:
	push	ds			; save segments
	push	es			;
	push	cs			; get resident segment to DS
	pop	ds			;
	;assume	ds:RESGROUP
	mov	cx,[USEDENV]		; get number of bytes to move
	mov	es,[ENVIRSEG]		; get target environment segment
	;assume	es:NOTHING

	cmp	byte [RESETENV],1	; do we need to setblock to env end?
	jne	short NO_RESET 		; no - we already did it
	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
	push	es			; save environment - just to be sure
	mov	ah,SETBLOCK  ; 4Ah	;
	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
				; ES = segment address of block to change
				; BX = new size in paragraphs
	pop	es

NO_RESET:
	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
	mov	ds,[OLDENV]		; source environment segment
	;assume	ds:NOTHING
	xor	si,si			; set up offsets to start of segments
	xor	di,di
	cld
	rep	movsb			; move it
	xor	ax,ax
	stosb				; make sure it ends with double-null

	;mov	[cs:InitFlag],FALSE	; turn off init flag
	pop	es
	pop	ds
	jmp	LODCOM			; allocate transient

	; MSDOS 6.0

;The init code has been changed to take care of the new way in which the
;environment segment is allocated.
;NB: We can use all the init variables at this point because they are all in
;RESGROUP
;Bugbug: The above approach will not work for ROMDOS

;IF 0
;
;EndInit:
;	push	ds
;	push	es			;save segments
;	push	cs
;	pop	ds		
;	assume	ds:RESGROUP
;;
;; AllocedEnv flag signals whether it is a passed environment or not
;;
;	mov	bx,ds
;	mov	es,bx			;es = RESGROUP
;;
;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
;; code + data for low COMMAND
;;
;	mov	bx,ResSize		;Total size of resident
;	mov	ah,SETBLOCK
;	int	21h			;Set block to resident size
;;
;;Allocate the correct size for the environment
;;
;	mov	bx,EnvSiz		;bx = env size in paras
;	mov	ah,ALLOC
;	int	21h			;get memory
;	jc	nomem_err		;out of memory,signal error
;
;	mov	EnvirSeg,ax		;Store new environment segment
;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
;	mov	es,ax			;es = address of allocated memory
;	assume	es:nothing
;
;;
;;Copy the environment to the newly allocated segment
;;
;	mov	cx,UsedEnv		;number of bytes to move
;
;	push	ds
;	mov	ds,OldEnv		;ds = Old environment segment
;	assume	ds:nothing
;
;	xor	si,si
;	mov	di,si			;Start transfer from 0
;
;	cld
;	rep	movsb			;Do the copy
;
;	xor	ax,ax			
;	stosb				;Make it end with double-null
;
;	pop	ds			;ds = RESGROUP
;	assume	ds:RESGROUP
;;
;;We have to free the old environment block if it was allocated by INIT
;;
;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
;	je      no_free                 ;no, do not free it
;
;	mov	ax,OldEnv		;Get old environment
;	mov	es,ax
;	mov	ah,DEALLOC	
;	int	21h			;Free it
;no_free:
;	mov	InitFlag,FALSE		;indicate INIT is done
;	
;	pop	es
;	pop	ds
;	assume	ds:nothing
;	
;	jmp	LodCom			;allocate transient
;
;nomem_err:
;;
;;We call the error routine which will never return. It will either exit
;;with an error ( if not the first COMMAND ) or just hang after an error 
;;message ( if first COMMAND )
;;
;
;	call	Alloc_error
;ENDIF
;
;CODERES ends

;	This TAIL segment is used to produce a PARA aligned label in
;	the resident group which is the location where the transient
;	segments will be loaded initial.

;TAIL		segment public para
;
;		org	0
;TranStart	label	word
;		public	TranStart
;
;TAIL		ends
;

;	This TAIL segment is used to produce a PARA aligned label in
;	the transient group which is the location where the exec
;	segments will be loaded initial.
;
;	Bugbug:	Is TRANTAIL used anymore?

;TRANTAIL	segment public para
;
;		org	0
;ExecStart   	label   word
;
;TRANTAIL    	ends

%endif ; 12/01/2023

;=============================================================================
; RUCODE.ASM, MSDOS 6.0, 1991
;=============================================================================
; 22/09/2018 - Retro DOS v3.0

;	title	Localizable code for resident COMMAND

	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

; ----------------------------------------------------------------------------
;***	AskEnd - ask user to confirm batch file termination
;
;	Confirm with user before freeing batch ...
;
;	ENTRY	nothing
;
;	EXIT	CY = set if batch termination is confirmed
;
;		CY = clear if batch should continue
;
;	USED	AX,DX,...
;
;	Bugbug:	move this to transient, copy to batch segment.
;	Bugbug:	or move it to command1 1st.
;
;	Bugbug: No_Char and Yes_Char should be constants.
; ----------------------------------------------------------------------------

	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)

AskEnd:
	;assume	ds:DATARES

	mov	dx,ENDBATMES			; DX = message #
	call	RPrint
	;call	RDISPMSG  ; MSDOS 3.3
	mov	ax,0C01h
	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
	call	CharToUpper			; change to upper case
	cmp	al,[NO_CHAR]
	je	short aeRet			; answer is no (CY is clear)
	cmp	al,[YES_CHAR]
	jne	short AskEnd			; invalid response, try again
	stc					; answer is yes
aeRet:	
	retn

; ----------------------------------------------------------------------------
;***	DskErr - critical error handler
;
;	Default critical error handler unless user intercepts int 24h.
;
;	ENTRY	int 24h
;
;	EXIT
;
;	USED
;
;	EFFECTS
; ----------------------------------------------------------------------------

	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)

;SR; 
;The stub is going to push the old ds value and the resident data segment
;onto the stack in that order. Get it off the stack

;DskErr	proc	far
DSKERR:
	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
	; 12/01/2023
	pop	ds			; ds = DATARES
	;assume ds:DATARES
	pop	word [OldDS]		; save old ds value

;CRITERR: ; MSDOS 3.3
	sti
	; 12/01/2023
	;push	ds ; 25/09/2018
	push	es
	push	si
	push	cx
	push	di
	push	cx
	push	ax

	push	ds			;save our data segment
	;push	cs ; 25/09/2018
	pop	es			;es = DATARES

	mov	ds,bp
	;assume	ds:nothing

	;mov	ax,[si].SDEVATT
	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
	mov	[es:CDevAt],ah

	;push	cs
	;pop	es

	mov	di,DevName
	mov	cx,8
	;add	si,SDEVNAME  ; add si,10
	add	si,SYSDEV.NAME	; save device name (even for block device)
				
	cld
	rep	movsb
	pop	ax
	pop	cx
	pop	di

;	Stack still contains DS and ES.

;SR;
;We need ds = DATARES for SavHand

	 ;12/01/2023
	push	es
	pop	ds
	;assume	ds:DATARES

	;invoke	SavHand		; save user's stdin/out, set to our stderr
	call	SavHand

	; 12/01/2023
	; 25/09/2018
	;;push	cs
	;push	es
	;pop	ds		; set up local data segment
	;assume	ds:resgroup

	push	dx
	call	crlf
	pop	dx

;	Bugbug:	rename Crit_Err_Info to CritErrAH?

	mov	[Crit_Err_Info],ah	; save critical error flags

;	Compute and save ASCII drive letter (nonsense for char devices)

	add	al,'A'
	mov	[DrvLet],al

;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.

	test	ah,80h
	jz	short NoHardE		; it's a disk-device error
	test	byte [CDevAt],DEVTYP>>8 ; 80h
	jnz	short NoHardE		; it's a character device
	jmp	FatErr			; it's a FAT error

NoHardE:
	mov	si,MREAD		; SI = "read" msg #
	test	ah,1
	jz	short SavMes		; it's a read error
	mov	si,MWRITE		; SI = "write" msg #
SavMes:
	mov	[OldErrNo],di		; save critical error code

;	Bugbug:	don't need to save/restore all here?

	push	es
	push	ds			; GetExtendedError likes to STOMP
	; 12/01/2023
	; (all registers are changed -in dos service- except bp) *
	;push	bp
	push	si
	push	dx
	push	cx
	push	bx
	mov	ah,59h ; * ; 05/06/2023 (BugFix)
	;mov	ah,GetExtendedError ; 59h ; get extended error info
	int	21h
	pop	bx
	pop	cx
	pop	dx
	pop	si
	; 12/01/2023
	;pop	bp
	pop	ds
	mov	[NeedVol],di		; save possible ptr to volume label
	mov	[NeedVol+2],es
	pop	es

;	Bugbug:	AX has extended error code, so no need to zero AH?

	xor	ah,ah
	mov	di,ax			; DI = error code

; Bugbug: somewhat obsolete documentation?
;
; DI is now the correct error code. Classify things to see what we are
; allowed to report. We convert DI into a 0-based index into a message table.
; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
; the like) are contiguous.

;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
;	Check use of ErrCd_24, though.

	sub	di,ERROR_WRITE_PROTECT ; 13h
	jae	short HavCod

;	Bugbug:	wouldn't it be better to display the original error msg,
;	even though it's not a critical error?

	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch

; DI now has the mapped error code. Old style errors are:
;   FOOBAR <read|writ>ing drive ZZ.
; New style errors are:
;   FOOBAR
; We need to figure out which the particular error belongs to.

HavCod:
	mov	byte [ErrType],0	; assume old style
	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
	je	short SetStyle
	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
	jne	short GotStyle

SetStyle:
;	Bugbug:	use INC
	;mov	byte [ErrType],1		; must be new type
	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018

GotStyle:
	mov	[ErrCd_24],di
	; 12/01/2023
	; 25/09/2018
	; MSDOS 6.0
	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
	; MSDOS 3.3
	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h

						; If the error message is unknown
	jbe	short NormalError		;  redirector, continue. Otherwise,

; We do not know how to handle this error. Ask IFSFUNC if she knows
; how to handle things

;input to IFSFUNC:    AL=1
;		      BX=extended error number
;
;output from IFSFUNC: AL=error type (0 or 1)
;			 0=<message> error (read/writ)ing (drive/device) xxx
;			   Abort, Retry, Ignore
;			 1=<message>
;			   Abort, Retry, Ignore
;		      ES:DI=pointer to message text
;		      carry set=>no message

	mov	di,ax			; retrieve correct extended error...
	mov	ax,0500h		; is the redir there?
	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
			; Return: AL = 00h not installed, OK to install
			; 01h not installed, can't install
			; FFh installed
	cmp	al,0FFh
	jne	short NoHandler		; no, go to NoHandler

	; 12/01/2023
	; MSDOS 6.0
	push	bx
	mov	bx,di			; get ErrType and ptr to error msg
	mov	ax,0501h
	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
	pop	bx 
	jc	short NoHandler
	
	; MSDOS 3.3
	;mov     ax,di
	;mov     ah,5
	;int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
	;jc      short NOHANDLER

;	Bugbug:	need to record error type?

	mov	[ErrType],al

	push	ds
	push	es
	pop	ds
	mov	dx,di
	mov	cx,-1			; find end of msg
	xor	al,al

	cld
	repnz	scasb

;	Bugbug:	we can do better than this.

	mov	byte [di-1],'$'
	
	;CALL	RDISPMSG ; MSDOS 3.3
	
	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
	int	21h

	mov	byte [di-1],0			; restore terminal byte

	pop	ds				; clean up and continue
	jmp	short CheckErrType

;*	Redir isn't available or doesn't recognize the error.
;	Restore regs to unextended error.

NoHandler:
	mov	byte [ErrType],0
;	Bugbug:	won't this break, since we add error_write_protect back in?
	mov	di,[OldErrNo]
	mov	[ErrCd_24],di

NormalError:
	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 6.0
	add	di,ERROR_WRITE_PROTECT
	xchg	di,dx			; may need dx later
	call	RPrintCrit		; print error type

	; MSDOS 3.3
	;shl     di,1
	;mov     di,[CRMSGTBL+di]
	;xchg    di,dx
	;call    RDISPMSG

CheckErrType:
	cmp	byte [ErrType],0	; Check error style...
	je	short ContOld
	call	crlf			; if new style then done printing
	jmp	short Ask

ContOld:
	; 12/01/2023
	; MSDOS 6.0
	inc	si			; DS:SI = ptr to asciiz string

;	Bugbug:	combine some of the following two sections?

	; 12/01/2023
	test	byte [CDevAt],DEVTYP>>8 ; 80h
	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
	jz	short BlkErr
	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
	;mov	dx,ChardevErr
	mov	dx,MDEVICE
	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
	mov	[CharDevErrRw],si
	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
	mov	si,CharDevErrSubst

	call	RPrint				; print the message
	jmp	short Ask			; don't ralph on command

	; 12/01/2023
	; MSDOS 3.3
	;mov	dx,ERRMES
	;call	RDISPMSG
	;mov	dx,si
	;call	RDISPMSG
	;
	;test	byte [CDevAt],80h
	;jz	short BLKERR
	;mov	dx,CHARDEVERR	; " device "
	;mov	ah,STD_CON_STRING_OUTPUT ; 9
	;int	21h		; DOS - PRINT STRING
	;			; DS:DX -> string terminated by "$"
	;jmp	short ASK

BlkErr:
	; 12/01/2023
	; MSDOS 6.0
	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
	;mov	dx,BlkDevErr
	mov	dx,MDRIVE
	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
	mov	[BlkDevErrRw],si
	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
	mov	si,BlkDevErrSubst
	call	RPrint

	; MSDOS 3.3
	;mov	dx,BLKDEVERR
	;call	RDISPMSG

	cmp	byte [Loading],0
	jz	short Ask
	call	RestHand
	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
Ask:
	cmp	word [ErrCd_24],15	; error 15 has an extra message
	jne	short Not15		; not error 15

;*	For error 15, tell the user which volume/serial # are needed.

	push	cx

;	Bugbug:	does this push/pop need to be done?

	push	ds
	pop	es
	lds	si,[NeedVol]
	;assume	ds:NOTHING
	push	di
	mov	di,VolName
	; 12/01/2023
	; MSDOS 6.0
	mov	cx,16			; copy volume name & serial #
	; MSDOS 3.3
	;mov	cx,11			; copy volume name
	cld
	rep	movsb
	pop	di
	push	es
	pop	ds
	pop	cx
	;assume	ds:DATARES
	; 12/01/2023
	; MSDOS 6.0
	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
	;mov	dx,NeedVolMsg
	mov	dx,MVOLSERIAL
	mov	si,NeedVolSubst
	call	RPrint

	; MSDOS 3.3
	;mov	dx,NEEDVOLMSG
	;mov	ah,STD_CON_STRING_OUTPUT ; 9
	;int	21h		; DOS - PRINT STRING
	;			; DS:DX -> string terminated by "$"
Not15:
;*	Print abort, retry, ignore, fail message.
;	Print only options that are valid.

;	Bugbug:	sizzle this.

	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	mov	dx,REQ_ABORT
	call	RPrint
	;call	RDISPMSG
	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
	jz	short Try_Ignore
	mov	dx,REQ_RETRY
	call	RPrint
	;call	RDISPMSG
Try_Ignore:
	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
	jz	short Try_Fail
	mov	dx,REQ_IGNORE
	call	RPrint
	;call	RDISPMSG
Try_Fail:
	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
	jz	short Term_Question
	mov	dx,REQ_FAIL
	call	RPrint
	;call	RDISPMSG
Term_Question:
	mov	dx,REQ_END
	call	RPrint
	;call	RDISPMSG

;	If the /f switch was given, we fail all requests.

	test	byte [fFail],-1
	jz	short DoPrompt
	mov	ah,3				; signal fail
	jmp	EExit

	; 16/04/2023
Abort_Process:
	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
	jz	short AbortCont			; no, handle it normally
	cmp	byte [PermCom],0		; are we top level process?
	jz	short JustExit			; yes, just exit

	mov	dx,PATRICIDE			; no, load ptr to error msg
	; 12/01/2023
	call	RPrint				; print it
	;call	RDISPMSG
DeadInTheWater:
	jmp	short DeadInTheWater		; loop until the user reboots

DoPrompt:
	; 12/01/2023
	mov	ax,0C01h
	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
	int	21h				; get response

	call	crlf
	call	CharToUpper			; convert to upper case
	mov	ah,0				; return code for ignore
	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
	jz	short User_Retry
	cmp	al,[IGNORE_CHAR]		; ignore?
	;jz	short EExitJ
	; 16/04/2023
	jz	short EExit

;	Bugbug:	optimize following code.

User_Retry:
	inc	ah				; return code for retry
	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
	jz	short User_Abort
	cmp	al,[RETRY_CHAR]			; retry?
	;jz	short EExitJ
	; 16/04/2023
	jz	short EExit
User_Abort:
	inc	ah				; return code for abort
						;  (abort always allowed)
	cmp	al,[ABORT_CHAR]			; abort?
	jz	short Abort_Process		; exit user program
	inc	ah				; return code for fail
	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
	jz	short AskJ
	cmp	al,[FAIL_CHAR]			; fail?
	;jz	short EExitJ
	; 16/04/2023
	jz	short EExit
AskJ:
	jmp	Ask

	; 12/01/2023
;EExitJ:
	;jmp	short EExit

JustExit:
	;assume	ds:DATARES
	; 12/01/2023
	mov	ax,[Parent]			; load real parent pid
	;mov	[16h],ax
	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
	mov	ax,4CFFh
	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
				; AL = exit code
AbortCont:
	test	byte [In_Batch],-1		; Are we accessing a batch file?
	jz	short Not_Batch_Abort
	mov	byte [Batch_Abort],1		; set flag for abort

Not_Batch_Abort:
	mov	dl,[PipeFlag]
	call	ResPipeOff
	or	dl,dl
	je	short CheckForA
	cmp	word [SingleCom],0
	je	short CheckForA
	mov	word [SingleCom],-1		; make sure SingleCom exits

CheckForA:
	cmp	word [ErrCd_24],0		; write protect?
	je	short abortfor
	cmp	word [ErrCd_24],2		; drive not ready?
	jne	short EExit			; don't abort the FOR

abortfor:
	mov	byte [ForFlag],0		; abort a FOR in progress
	cmp	word [SingleCom],0
	je	short EExit
	mov	word [SingleCom],-1		; make sure SingleCom exits

EExit:
	mov	al,ah
	mov	dx,di
RestHd:
	call    RestHand
	pop	cx
	pop	si				; restore registers
	pop	es

	; 12/01/2023	
	; MSDOS 6.0
;;	pop	ds
;SR;
;ds has to be got from the variable we saved it in

 	mov	ds,[OldDS]			; restore old value of ds

;	pop	ds
;	assume	ds:nothing

	; MSDOS 3.3
	;pop	ds

	iret

FatErr:
	; 12/01/2023
	; MSDOS 6.0
	;mov	dx,offset DATARES:BadFatMsg
	;mov	si,offset DATARES:BadFatSubst
	mov	dx,BADFATMSG
	mov	si,BadFatSubst
	call	RPrint

	; MSDOS 3.3
	;mov	dx,BADFATMSG
	;call	RDISPMSG
	;mov	dx,BLKDEVERR
	;call	RDISPMSG

	mov	al,2				; abort
	jmp	short RestHd

;DskErr	endp

	; MSDOS 6.0
; ----------------------------------------------------------------------------
;***	RPrint - print message
;***	Crlf - display cr/lf
;
;	ENTRY	DS:DX = ptr to count byte, followed by message text
;		DS:SI = ptr to 1st substitution block for this msg, if any
;		variable fields related to substitution blocks are set
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout.
;
;	NOTE
;	  Number of substitutions (%1, %2,...) in message text must not
;	  be greater than number of substition blocks present.
; ----------------------------------------------------------------------------

	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)

crlf: 
	;mov	dx,offset DATARES:Newlin ; cheap newline
	; 14/01/2023
	mov	dx,NEWLINE

;RPrint	proc
;
;	assume	ds:DATARES,ss:DATARES
;
	; 14/01/2023
RPrint:

;	Bugbug:	do we need to save all reg's?

	push	si			; preserve registers
	push	ax
	push	bx
	push	cx
	push	dx

	mov	bx,si			; DS:BX = ptr to subst block
	mov	si,dx			; DS:SI = ptr to count byte
	lodsb				; AL = message length
					; DS:SI = ptr to message text
	xor	cx,cx
	mov	cl,al			; CX = message length
	jcxz	rpRet

	call	RDispMsg

rpRet:	pop	dx
	pop	cx
	pop	bx
	pop	ax
	pop	si
	retn

;RPrint	endp

	; 14/01/2023
;	; MSDOS 3.3
;CRLF:
;	mov     dx,NEWLIN
;
;RDISPMSG: ; Display message/text
;	; DS:DX = ($ terminated) Message/Text address 
;	push    ax
;	mov     ah,STD_CON_STRING_OUTPUT ; 9
;	clc
;	int     21h             ; DOS - PRINT STRING
;				; DS:DX -> string terminated by "$"
;	pop     ax
;	retn


	; MSDOS 6.0
; ----------------------------------------------------------------------------
;***	RPrintCrit - print critical error message
;
;	ENTRY	DX = extended error # (19-39)
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout
; ----------------------------------------------------------------------------

	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;RPrintCrit	proc
;	assume	ds:DATARES,ss:DATARES

	; 14/01/2023
RPrintCrit:
	push	dx			; preserve DX
	xchg	bx,dx			; BX = extended error #
					; DX = saved BX
	sub	bx,19			; BX = critical error index, from 0
	shl	bx,1			; BX = offset in word table
	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
	xchg	bx,dx			; DX = ptr to error msg
					; BX = restored
	call	RPrint			; print the message
	pop	dx			; restore DX
	retn

;RPrintCrit	endp

; ----------------------------------------------------------------------------
;***	RDispMsg - display message
;
;	Display message, with substitutions, for RPrint.
;
;	ENTRY	DS:SI = ptr to message text
;		CX = message length
;		DS:BX = ptr to substitution block, if any
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI
; ----------------------------------------------------------------------------

;RDispMsg	proc
;	assume	ds:DATARES,ss:DATARES

RDispMsg:
	; 14/01/2023
rdNextChar:
	lodsb				; AL = next char
	cmp	al,'%'
	jne	short rdOutChar		; not a substitution
	mov	dl,[si]			; DL = possible '1' - '9'
	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
	cmp	dl,9
	jae	short rdOutChar		; not a substitution

;*	A substitution code %1 - %9 has been encountered.
;	DL = 0-8, indicating %1-%9
;	DS:BX = ptr to substitution block

	call	SubstMsg		; display the substitution
	inc	si			; SI = ptr past %n
	dec	cx			; count extra character in %n
	jmp	short rdCharDone

;*	Normal character output.

rdOutChar:
	mov	dl,al			; DL = char
	mov	ah,2			; AH = DOS Character Output code
	int	21h			; call DOS
rdCharDone:
	loop	rdNextChar
	retn

;RDispMsg	endp

; ----------------------------------------------------------------------------
;***	SubstMsg - display message substitution
;
;	Display a substitution string within a message.
;	Substitution can be a char, an ASCIIZ string, or
;	a word to be displayed as hex digits.
;
;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
;		DS:BX = ptr to substitution block
;
;	EXIT	nothing
;
;	USED	AX,DX
; ----------------------------------------------------------------------------

	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;SubstMsg	proc
;	assume	ds:DATARES,ss:DATARES
	
	; 14/01/2023
SubstMsg:
	push	bx			; preserve BX
	push	cx			; preserve CX

	;mov	al,size SUBST		; AL = size of substitution block
	mov	al,3
	mul	dl			; AX = offset of desired subst block
	add	bx,ax			; DS:BX = ptr to desired subst block

	;mov	al,[bx].SubstType	; AX = substitution type flag
	mov	al,[bx]
	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
	mov	bx,[bx+1]

;	AL = 1, 2, or 3 for char, string, or hex type

	dec	al
	jz	short smChar
	dec	al
	jz	short smStr

;*	Hex number substitution.

	;mov	ax,ds:[bx]		; AX = word value
	mov	ax,[bx]
	mov	cx,4			; CX = # digits to display
smDigit:
	rol	ax,1
	rol	ax,1
	rol	ax,1
	rol	ax,1			; AL<3:0> = next digit

	push	ax			; save other digits
	and	al,0Fh			; AL = binary digit
	add	al,'0'			; AL = ascii digit if 0-9
	cmp	al,'9'
	jbe	short smDigit09		; it's 0-9
	;add	al,7
	add	al,('A' - '0') - 10	; AL = ascii digit A-F
smDigit09:
	mov	dl,al			; DL = ascii digit
	mov	ah,2
	int	21h			; output the ascii digit
	pop	ax			; restore all digits

	loop	smDigit
	;jmp	short smRet
	; 14/01/2023
smRet:	
	pop	cx
	pop	bx
	retn

;*	Char substitution.

smChar:
	;mov	dl,ds:[bx]		; DL = char to output
	mov	dl,[bx]
	mov	ah,2
	int	21h
	jmp	short smRet

;*	String substitution.

smStr:
	;mov	dl,ds:[bx]		; DL = next char
	mov	dl,[bx]
	or	dl,dl
	jz	short smRet		; null char - we're done
	mov	ah,2
	int	21h			; display char
	inc	bx			; DS:BX = ptr to next char
	jmp	short smStr

;smRet:	pop	cx
;	pop	bx
;	retn

;SubstMsg	endp

	; MSDOS 6.0
; ----------------------------------------------------------------------------
;***	CharToUpper - convert character to uppercase
;
;	ENTRY	AL = char
;
;	EXIT	AL = uppercase char
;
;	USED	AX
; ----------------------------------------------------------------------------

	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;CharToUpper	proc
;	assume	ds:DATARES
CharToUpper:
	push	ax		; put char on stack as arg to int 2F
	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
	int	2Fh
	inc	sp		; throw away old char on stack
	inc	sp
	retn

;CharToUpper	endp

	; 14/01/2023
;	; MSDOS 3.3
;CHARTOUPPER:
;	cmp	al,80h
;	jb	short CHARTOUPPER1
;	sub	al,80h
;	push	ds
;	push	bx
;	lds	bx,[UPPERCASETBL]
;	add	bx,2
;	xlat
;	pop	bx
;	pop	ds
;	jmp	short CHARTOUPPER_RETN
;CHARTOUPPER1:
;	cmp	al,'a'
;	jb	short CHARTOUPPER_RETN
;	cmp	al,'z'
;	ja	short CHARTOUPPER_RETN
;	sub	al,20h
;CHARTOUPPER_RETN:
;	retn

;public	EndCode
;EndCode label byte

	; MSDOS 6.0
; ----------------------------------------------------------------------------
;***	MsgInt2fHandler - int 2f handler for message retrieval
;
;	ENTRY	If we handle it -
;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
;		  DL = operation =
;		     0 = get extended error messages
;		     1 = set extended error messages
;		     2 = get parse error messages
;		     3 = set parse error messages
;		     4 = get critical error messages
;		     5 = set critical error messages
;		     6 = get file system error messages
;		     7 = set file system error messages
;		     8 = get disk retriever routine
;		     9 = set disk retriever routine
;		  ES:DI = address for 'set' operations
;
;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
;
;	NOTE
;	  This handler replaces the one that used to reside in DOS.
;	  'Set' operations are ignored.
;	  'File system error messages' are not supported.
; ----------------------------------------------------------------------------

	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
;SR;
;At the int 2fh entry point we push the old ds value and the resident data
;segment address. Get them off the stack

;MsgInt2fHandler proc	far
;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	; 14/01/2023
MsgInt2fHandler:
	pop	ds			; ds = DATARES
	;assume	ds:DATARES
;	pop	word [OldDS]		; save old value of ds

	cmp	ax,122Eh
	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
	je	short miOurs		; it's ours

;ifndef ROMDOS
	;cmp	ax,5500h
	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
;else
;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
;endif	;ROMDOS
	je	short fcOurs

;SR;
;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
;onto the stack and do a far return to jump to the next 2fh handler. 
;Our old ds is on the stack. We need to restore it but we cannot lose the
;current value of ds as it points at the data segment. So we do some kinky
;stack manipulations.

	push	ax
	push	ax			; create 2 words on stack for retf

	push	bp
	push	ax

	mov	bp,sp			; bp can be used to address stack

;Swap the old ds value with the second dummy word on the stack. Now, we can
;do a 'pop ds' at the end to restore our ds

	mov	ax,[bp+8]		; ax = old ds value
	mov	[bp+4],ax
	
	;mov	ax,word ptr ds:Int2fHandler+2
	mov	ax,[Int2fHandler+2]
	mov	[bp+8],ax		; put segment address
	;mov	ax,word ptr ds:Int2fHandler
	mov	ax,[Int2fHandler]
	mov	[bp+6],ax		; put offset address

	pop	ax
	pop	bp
	pop	ds

	retf				; chain on to next handler

;;	jmp	Int2fHandler		; hand off to next 2f handler

fcOurs:

;We have to clear ax, and return in ds:si a pointer to the stub jump table

	pop	ax			; discard ds currently on stack
	push	ds			; store our data segment

	;mov	si,offset DATARES:Int2f_Entry ; start of table
	mov	si,Int2f_Entry

	xor	ax,ax			; indicate COMMAND present
	jmp	short miRet		; return to caller

miOurs:
	test	dl,1
	jnz	short miRet		; ignore 'set' operations

	push	bx			; preserve BX
	mov	bx,dx
	xor	bh,bh			; BX = index in word table
	shl	bx,1			; BX = index in dword table
	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
	les	di,[bx+MsgPtrLists]
	pop	bx			; restore BX
miRet:
;	mov	ds,[OldDS]		; restore ds
	pop	ds
	;assume	ds:nothing

	iret

;MsgInt2fHandler endp

	; MSDOS 6.0
; ----------------------------------------------------------------------------
;***	MsgRetriever - message retrieval routine for utilities
;
;	Address of this routine is passed to utility programs via 
;	message services int 2f. We try to find the desired message
;	in memory or in our disk image.
;
;	ENTRY	AX = message #
;		DI = offset in RESGROUP of msg ptr list
;		ComSpec = asciiz pathname to our disk image
;
;	EXIT	CY clear for success
;		ES:DI = ptr to count byte, followed by message text
;
;		CY set for failure
;		ES,DI undefined
;
;	USED	flags
;
;	NOTE
;	  The message # in AX is used to compute an offset into
;	  the message ptr list pointed to by DI. The lists must
;	  start with message # 1 and proceed through consecutive
;	  message #'s.  
;
;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
;	  valid message #.  ;M033
;
;	  List positions with no corresponding message text are
;	  indicated by null pointers, which this routine detects.
; ----------------------------------------------------------------------------

	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;SR; This routine will be called directly by the utilities. So, we have
; trap for it in the stub. The stub pushes the old value of ds and the 
; DATARES value on the stack. We get them off the stack to setup ds here

;MsgRetriever	proc	far
;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING

	; 14/01/2023
MsgRetriever:
	pop	ds			; ds = DATARES
	;assume	ds:DATARES
;	pop	word [OldDS]		; save old ds

	push	ax			; preserve registers
	push	bx
	push	cx
	push	dx
	push	si

;;	push	ds
;;	push	cs
;;	pop	ds			; DS = DATARES seg addr
;;	assume	ds:RESGROUP
;;	push	cs

	push	ds			; get es from ds
	pop	es			; ES = DATARES seg addr

;	Begin modification M033.

;	Make sure msg # is valid.
;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.

	;mov	bx,11
	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
	;cmp	di,offset DATARES:ParsMsgPtrs
	cmp	di,PARSMSGPTRS
	je	short chkmsgnum		; it's ParsMsgPtrs
	;mov	bx,90
	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
chkmsgnum:
	cmp	bx,ax
	jc	short mrRet		; msg # too high, return carry

;	Msg # is valid.

;	End modification M033.

	dec	ax
	shl	ax,1			; AX = offset into msg ptr list
	add	di,ax			; DI = ptr to msg ptr

	cmp	di,ResMsgEnd
	jb	short mrInMem		; ptr (and message) in memory

;*	Retrieve message from disk (or ROM) image.
;	Read once to get the ptr to the message, then again for the message.

;ifndef	ROMDOS
	; 14/01/2023
	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
	mov	si,ComSpec
	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
	mov	ax,6C00h
	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
	int	21h				; call DOS
	jc	short mrRet			; return failure

	mov	bx,ax				; BX = file handle
	mov	dx,di				; DX = ptr to msg ptr
	xor	si,si				; SI = read count
mrRead:
	sub	dx,100h				; DX = LSW of file offset
	xor	cx,cx				; CX = MSW of file offset
	mov	ax,4200h
	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
	int	21h				; call DOS
	jc	short mrCloseFile		; handle error

	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
	mov	dx,MsgBuffer
	mov	cx,64				; CX = # bytes to read
	mov	ah,3Fh
	;mov	ah,READ				; AH = 'Read File'
	int	21h				; call DOS
	jc	short mrCloseFile		; handle error

	or	si,si				; (CY cleared)
	jnz	short mrCloseFile		; 2nd time thru - we're done
	inc	si				; mark one read done
	mov	dx,[MsgBuffer]			; DX = ptr to message
	or	dx,dx
	jnz	short mrRead			; go read the message
	stc					; null ptr found- no msg

mrCloseFile:
	pushf				; save success/failure (CY)
	mov	ah,3Eh
	;mov	ah,CLOSE		; AH = 'Close File'
	int	21h			; call DOS
;	Bugbug: should we avoid this popf?
	popf				; CY = success/failure
	mov	di,dx			; ES:DI = ptr to msg, if successful
	jmp	short mrRet		; we're done

;else	;ROMDOS
;
;;	DI = ptr to msg ptr
;
;	mov	si,di			; SI = ptr to msg ptr
;	sub	si,100h			; SI = offset into image of msg ptr
;	mov	cx,2			; CX = # bytes to copy from image
;
;;	ASSUME ES:NOTHING is still in effect.
;
;	push	ds
;	pop	es				; ES = DATARES seg addr
;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
;	invoke	LoadFromROM			; copy msg ptr from ROM
;	mov	si,word ptr MsgBuffer		; SI = ptr to message
;	or	si,si
;	jz	mrNoMsg			; null ptr- no message text
;
;	sub	si,100h			; SI = offset into image of msg
;	mov	cx,64			; CX = # bytes to copy from image
;	mov	di,offset DATARES:MsgBuffer
;	invoke	LoadFromROM
;	clc					; success
;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
;	jmp	short mrRet
;
;mrNoMsg:
;	stc
;	jmp	short mrRet
;
;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
;	assume	es:NOTHING
;
;endif	;ROMDOS

;*	Message ptr is in memory.
;	If ptr is in memory, assume message is in memory (/msg).

mrInMem:
	; 14/01/2023
	mov	di,[es:di]		; ES:DI = ptr to msg
	or	di,di			; (CY cleared)
	jnz	short mrRet		; found message
	stc				; null ptr found - no message
mrRet:	
	pop	si			; restore all registers
	pop	dx
	pop	cx
	pop	bx
	pop	ax

;	mov	ds,[OldDS]		; restore ds
	pop	ds
	;assume	ds:nothing

	retf	; 21/04/2023

;MsgRetriever endp

; M003; Start of changes for UMB support

; ----------------------------------------------------------------------------
;***	Lh_OffUnlink -- Restore allocation strat and link state
;
;	ENTRY	al = Saved alloc strat and link state
;			b0 = 1 if alloc strat to restore is HighFirst
;			b1 = 1 if link state to restore is Linked
;
;	EXIT	None
;
;	USED	ax, bx, cx
; ----------------------------------------------------------------------------

	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;public	Lh_OffUnlink
Lh_OffUnlink:	; proc	far
	; 14/01/2023
	mov	ch,al
	mov	cl,al
	;;mov	ax,(ALLOCOPER shl 8) OR 0
	;mov	ax,(ALLOCOPER<<8)
	mov	ax,5800h
	int	21h
	mov	bx,ax
	ror	cl,1				; b7 = HighFirst bit
	and	cl,80h				; mask off b6-b0
	and	bl,7fh				; mask off HighFirst bit
	or	bl,cl				; set HighFirst bit state
	;;mov	ax,(ALLOCOPER shl 8) OR 1
	;mov	ax,(ALLOCOPER<<8)|1
	mov	ax,5801h
	int	21h				; set alloc strat

	mov	bl,ch
	shr	bl,1
	xor	bh,bh				; bx = linkstate
	;mov	ax,(ALLOCOPER shl 8) OR 3
	;mov	ax,(ALLOCOPER<<8)|3
	mov	ax,5803h
	int	21h				; set linkstate

	retf

;Lh_OffUnlink endp

; M003; End of changes for UMB support

;public	EndCode
; 14/01/2023
;EndCode: ; label byte
; 06/06/2023
; 16/04/2023
EndCode equ ($-StartCode)+100h
; 06/06/2023
;EndCode equ $-StartCode	

;CODERES ends
;	end

; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	times	(((EndCode+15)>>4)<<4)-EndCode db 0

;align 16

;=============================================================================
; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
;=============================================================================
; 22/09/2018 - Retro DOS v3.0 ('command3.s')

; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)

;TITLE   COMMAND Initialization

;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
;ENVIRONSIZ2 EQU 092H
;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018

; UINIT.ASM, MSDOS 6.0, 1991
; 23/09/2018
ENVBIG	EQU 32768		;AN000; maximum environment size
; 14/01/2023
;ENVSML	EQU 160			;AN000; minimum environment size

; ----------------------------------------------------------------------------

; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
ENVIRONSIZ equ 160
ENVSML	equ 256	; minimum environment size
;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
MAX_COMSPEC equ 146
ECOMSPEC equ 14

; 14/01/2023
TAB_CHAR equ 09h
SPACE_CHAR equ 20h	

; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
;ENVIRONSIZ equ 180	; SIZE Environment 

;----------------------------------------------------
; MSDOS 6.0 - ENVDATA.ASM - 1991
;----------------------------------------------------
;Environment Struc	; Default COMMAND environment
;
;Env_PathString  db	"path="
;Env_PathSpec	 db	"c:\msdos"
;                db	0
;Env_PrmptString db	"prompt="
;Env_PrmptSpec   db	"$p$g"
;                db	0
;Env_ComString   db	"comspec="
;Env_ComSpec     db	"\command.com"
;		 db	134 dup (0)
;
;Environment ends
;----------------------------------------------------

;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
; START OF INIT PORTION
; This code is deallocated after initialization.
;-----------------------------------------------------------------------------

;INIT	SEGMENT PUBLIC PARA

; 	EXTRN   HEADER:BYTE
;	EXTRN   BADCOMLKMES:BYTE

;	PUBLIC  CONPROC

;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP

        ;ORG 0
;ZERO = $
	; 23/09/2018
ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM

	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
ConProc:
	;mov	sp,offset ResGroup:RStack	; must be first instruction
	mov	sp,RStack

; We need to set the PSP to us right at start because Carousel needs
; to be lied to and it does not set PSP when it transfers control to
; us after loading us as an overlay. By setting PSP, we ensure that
; command.com is also not lied to.

	; 14/01/2023
	; MSDOS 6.0
        mov	ah,50h
	;mov	ah,SET_CURRENT_PDB
        mov	bx,es
        int	21h

	; 14/01/2023
	mov	ah,30h 
	;mov	ax,GET_VERSION<<8 ; 30h
	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
	;mov	ax,3000h
	int	21h
	;;cmp	ax,EXPECTED_VERSION ; 1E03h
	;cmp	ax,5
	cmp	ax,EXPECTED_VERSION ; 0005h
	je	short okdos			; DOS version is ok

	mov	dx,BADVERMSG			; DX = ptr to msg
	call	RPrint

	; MSDOS 3.3
	;mov	ah,STD_CON_STRING_OUTPUT ; 9
	;int	21h             ; DOS - PRINT STRING
				; DS:DX -> string terminated by "$"
	mov	ax,es
	cmp	[es:PDB.PARENT_PID],ax
	;cmp	[es:16h],ax			; if COMMAND is own parent,
Here:	
	jz	short Here			;  loop forever
	
	int	20h				; otherwise, exit
okdos:
	; 23/09/2018

;  Calculate and save the end of the INIT segment (which is also
;  the beginning of TRANGROUP).

	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 3.3
	;mov	ah,65h
	;mov	al,2
	;mov	dx,-1
	;mov	bx,-1
	;mov	cx,5
	;mov	di,UCASE_ADDR
	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
	;		; AL = 02h : Get pointer to character translation table
	;		; BX = code page (-1 = current global code page)
	;		; DX = country ID (-1 = current country)
	;		; CX = amount of data to return
	;; ES:DI = pointer to output buffer
	;; Buffer offset :
	;;	00h -  byte,  country Id
	;;  	01h -  dword, pointer to uppercase table	

	; 14/01/2023
	; MSDOS 6.0 (& MSDOS 3.3)
  	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
	mov	dx,TRANSTART+15			; get end of init code
	; 27/09/2018
	;mov	dx,TRANSTART ; (paragraph aligned address)
	mov	cl,4				; change to paragraphs
        shr	dx,cl				;
        mov     ax,cs                           ; get current segment
        add     ax,dx                           ; calculate segment of end of init
        mov     [initend],ax			; save this

	; 14/01/2023
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 

;  Check for /? on the command line. If found, display help text and exit.
;  NOTE: this routine may terminate the program, never returning.

	call	CheckHelp

; We have to patch the segment values for the various interrupt entry points.
; This is because we need to have the default addresses of the handlers in our
; stub before the relocation is done. These values will then be changed once
; the resident is relocated

	call	patch_segs

;  Turn APPEND off during initialization processing

	; 14/01/2023
	mov     ax,0B700h
	;mov	ax,APPENDINSTALL                ; see if append installed
	int	2Fh				;
	;cmp	al,0				; append installed?
	or	al,al
	jz	short set_msg_addr		; no - continue
	
	mov	ax,0B702h
	;mov	ax,APPENDDOS			; see if append DOS version right
	int	2Fh				;
	;cmp	ax,-1				; append version correct?
	;jne	short set_msg_addr		; no - continue
	inc	ax ; -1 -> 0
	jnz	short set_msg_addr        
	
	mov     ax,0B706h
	;mov	ax,APPENDGETSTATE               ; Get the state of Append
	int	2Fh				;
        mov     [Append_State],bx		; save append state
       
	xor	bx,bx                           ; clear out state
	mov	ax,0B707h
	;mov	ax,APPENDSETSTATE               ; Set the state of Append
	int	2Fh				; set everything off

set_msg_addr:
	; 14/01/2023
	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
	mov	di,DataresEnd
	mov	[ResMsgEnd],di			; save it

        call    get_XMMAddr                     ; get XMM call address

; Check if this is the first instance of command.com. If not, we just exit
; this routine without moving any code.
; After the int 2fh, ds:si points at the resident jump table in the previous
; stub. We just have to copy this over
	
;ifndef ROMDOS
	mov	ax,5500h
	;mov	ax,GET_COMMAND_STATE	
;else
;	mov	ax,GET_ROMCOMMAND_STATE	
;endif ; ROMDOS

	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
	;assume	ds:nothing

	; 03/05/2023
	; Return:
	;   AX = 0000h if an instance of COMMAND.COM is already running
	;   DS:SI -> entry point table

	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))

	or	ax,ax
	jnz	short first_com			; this is the first instance

	; 14/01/2023
	mov	[es:ResJmpTable],si		; save old stub jump table
	mov	[es:ResJmpTable+2],ds
	jmp	short init_cntry

first_com:
	mov	byte [es:FirstCom],1		; indicate first command.com

init_cntry:
	; 14/01/2023
	push	es
	pop	ds
	;assume	ds:RESGROUP

	mov	ah,65h
	;mov	ah,GETEXTCNTRY			; get extended country info
	mov	al,4				; get file ucase table
	mov	dx,-1				;
	;mov	bx,-1				;
	mov	bx,dx
	mov	cx,5				; number of bytes we want
	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
	mov	di,FUCase_Addr
	int	21h
		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
		; AL = function -

;	Bugbug:	conditionalize dbcs_vector stuff?

	push	ds				;
	mov	ax,6300h
	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
	int	21h				;
		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
			
	mov	bx,ds				; get segment to bx
	pop	ds				;
	mov	[Dbcs_Vector_Addr],si		; save address of
	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector

	;mov	ax,[16h]
	mov	ax,[PDB.PARENT_PID]
				; mov ax,ds:16h	; Init PARENT so we can exit
	mov	[Parent],ax			;  correctly.
	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
	mov	[OldTerm],ax
	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
	mov	[OldTerm+2],ax

	; 14/01/2023
	;;;mov	ax,offset ResGroup:EndCode + 15
	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
	;mov	ax,EndCode+15
	;;mov	ax,INITSTART+15 ; 24/09/2018
	; 14/01/2023
	;mov	cl,4				; ax = size of resident part of
	;shr	ax,cl				;  command in paragraphs. Add
	;mov	cx,cs				;  this to CS and you get the
	;add	ax,cx				;  segment of the TPA.

	mov	ax,cs
	add	ax,(EndCode+15)>>4
	
	mov     [Res_Tpa],ax			; Temporarily save the TPA segment
	and     ax,0F000h
	add     ax,1000h			; Round up to next 64K boundary
	jnc     short TpaSet			; Memory wrap if carry set
	mov     ax,[Res_Tpa]
TpaSet:
	mov	[LTpa],ax			; Good enough for the moment
	;mov	ax,[2]
	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command

	mov	[MySeg1],ds			; These 3 variables are used as part of
	mov	[MySeg2],ds			;  3 long ptrs that the transient will
	mov	[MySeg],ds			;  use to call resident routines.
	; 19/04/2023
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
	mov	[MySeg3],ds			; segment of msg retriever routine 

	mov	[MemSiz],ax			; Needed for execing other programs

	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h

; First reallocate the COMMAND size to its memory image
	
	push	ax    
  	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
	;;mov	bx,offset RESGROUP:TranStart    ;
	;mov	bx,TRANSTART
	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
        ;add	bx,offset TRANGROUP:TranSpaceEnd;
	;add	bx,15 ; *			; round up the size

	; 03/05/2023
	;;mov	bx,TRANSTART+15 ; * ; 14/01/2023
	;;add	bx,TRANSPACEEND
	; 06/06/2023
	;mov	bx,TRANSTART+TRANSPACEEND+15 
        ;mov	cl,4				;
        ;shr	bx,cl				; size of command.com
	mov	bx,(TRANSTART+TRANSPACEEND+15)>>4
	
	mov	ah,4Ah
	;mov	ah,SETBLOCK			; free all memory above pgm
        int     21h				;
        pop     ax				;
	
; Compute maximum size of environment

	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
        ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
;
; Compute minimum size of environment
;
	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
	mov	word [EnvSiz],ENVSML/16 ; 256/16

	;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
	;mov	dx,98D4h	 ; MSDOS 5.0 COMMAND.COM
	; 06/06/2023
	;mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
	;mov	cl,4				;  in paragraphs.
	;shr	dx,cl
	mov	dx,(TRANSPACEEND+15)>>4
        mov     [TrnSize],dx			; save size of transient in paragraphs

	sub	ax,dx				; max seg addr - # para's needed for transient
	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
	;mov	ax,[2Ch]
	mov	ax,[PDB.ENVIRON]		; ax = environment segment

	; 14/01/2023
        ; MSDOS 6.0
	;mov	[EnvirSeg],ax
        
	; 21/01/2023
	or	ax,ax				; if there is no environment segment,
	jz	short buildenv			; make one
  
	; 21/01/2023
	; MSDOS 3.3 & MSDOS 5.0
	;inc	byte [CHUCKENV]
	inc	byte [AllocedEnv]		; Flag - old environment segment
	
	; MSDOS 3.3 & MSDOS 5.0
	jmp	short environpassed
	; MSDOS 6.0
        ;cmp	byte [FirstCom],0		; if this is the first command.com,
	;je	short environpassed		; do a merge job (make sure COMSPEC exists)

	; MSDOS 6.0

; We allocate a buffer here just large enough to hold the 'PATH=' and
; the COMSPEC. After parsing, we will allocate an environment of the right
; size and free this buffer. We need this buffer because we no longer have an
; ENVIRONMENT segment but need a place to store the COMSPEC which can be
; given on the command line before we know the environment size. This routine
; will not return in case of an allocation error. It will either exit or hang
; depending on whether or not this is the first COMMAND.COM or not.

	; 14/01/2023
buildenv:
	call	alloc_env                       ; try to allocate buffer
environpassed:
	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
	mov	[EnvirSeg],ax
	;
	mov	es,ax                           ; and it load into es.
	;assume	es:nothing

gottheenvir:

; Initialize the command drive

; 14/01/2023
%if 0
	; MSDOS 3.3
BUILDENV:
        ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
	mov	ax,PATHSTRING ; "PATH="
	mov	cl,4
	shr	ax,cl
	mov	dx,ds
	add	ax,dx
ENVIRONPASSED:
        mov	[ENVIRSEG],ax
        MOV     es,ax

        ;mov	ax,CHAR_OPER<<8
        mov	ax,CHAR_OPER*256 ; 3700h
	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
			; Return: AL = FFh unsupported subfunction
			; DL = current switch character
        mov	[RSWITCHAR],dl

        ;CMP	dl,'/'
	cmp	dl,[slash_chr]
        jnz	short IUSESLASH

	;mov	al,'\'
 	mov	al,[bslash_chr]
	mov	[COMSPECT],al

	cmp	byte [CHUCKENV],0
	jnz	short IUSESLASH

        ;mov	ES:[ECOMSPEC-10h],'\'
	; 30/04/2018
	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
	; 23/09/2018
	mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
gottheenvir:
IUSESLASH:

; Initialize the command drive

%endif
	; 14/01/2023
	; MSDOS 3.3 & MSDOS 6.0
	mov	ah,19h
	;mov	ah,GET_DEFAULT_DRIVE	; 19h
	int	21h
	inc	al
	mov	[ComDrv],al

        ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
        mov	al,[FCB]
	or	al,al
	jz	short nocomdrv		; no drive specified

	mov	ah,':'
	mov	[ComDrv],al
	add	al,40h			; convert number to uppercase character

	std

	; MSDOS 6.0
	;cmp	byte [AllocedEnv],0	; if a new environment is being built,
	;je	short notwidenv		;  move the default comspec string in it
	; 14/01/2023
	; MSDOS 5.0 COMMAND.COM
	;mov	di,[ComspOffset]
        ;cmp	byte [es:di+1],':'	; drive specifier already exist?
        ;je	short notwidenv		; yes, must have been inherited that way

	; MSDOS 3.3
	;cmp	byte [CHUCKENV],0
	;jne	short NOTWIDENV
	; 21/01/2021
	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
 	cmp	byte [AllocedEnv],0
	ja	short notwidenv

  	push	ds			;  2 bytes to make room for a drivespec.
	push	es			;  the drivespec is in ax and is copied
	pop	ds			;  on to the front of the string.

	; MSDOS 6.0
        ;lea	si,[di+MAX_COMSPEC-3]	
        ;lea	di,[di+MAX_COMSPEC-1]

	; 21/01/2023
	; 14/01/2023
	; MSDOS 5.0 COMMAND.COM
	; MSDOS 3.3
	; 23/09/2018
	; 30/04/2018
	;mov	di,159
	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
	mov	di,ENVIRONSIZ-1 ; 21/01/2023
	;mov	si,157
	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
        ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
	;mov	cx,144
	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
        mov	cx,MAX_COMSPEC-2 ; 144

	rep	movsb
	pop	ds

	; MSDOS 6.0
	;mov	word ptr es:[di-1],ax

	; MSDOS 3.3
	;mov	[es:0Eh],ax
	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
	; 14/01/2023
	mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax

	; MSDOS 3.3 & MSDOS 6.0
notwidenv:
	cld
	mov	[AUTOBAT],ax ; ":\AUTOEXEC.BAT"
	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
	;mov	[KAUTOBAT],ax
nocomdrv:
	call	SetVect        ; Set the vectors

; parsing starts here

	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C9h)
	; MSDOS 6.0
	push	cs
	push	cs
	pop	ds
	pop	es
	;assume ds:ResGroup,es:ResGroup

; 14/01/2023
%if 0	
	; MSDOS 3.3
	mov	si,80h		; get command line
	lodsb			; get length of line
	mov	cl,al
	xor	ch,ch		; cx = length of command line

; insure that the command line correctly ends with a cr

	add	si,cx		; go to end of command line	
	mov	byte [si], 0Dh	; insert a carriage return

	mov	si,81h		; Start of parms
CHKARG:
        jcxz	COMRETURNSJ     ; No parameters
        dec	cx
	lodsb
CHECKSWITCHCHR:
	;cmp	al,' '
	cmp	al,[SPACE_CHR]	 ;Skip blank spaces
	jz	short CHKARG
	cmp	al,9		; Skip TAB characters
	jz	short CHKARG
	cmp	al,[RSWITCHAR]	; Switch?
	jz	short PARSE_CONT ; Yes, get the char after the switch
	jmp	CHKOTHERARGS	; No

%endif
	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16CDh - CODERES:098Dh)
	; MSDOS 6.0

	mov	si,80h				; get command line
	lodsb					; get length of line
	mov	di,si				; get line position in di
	xor	ah,ah				; ax = length of command line

; insure that the command line correctly ends with a cr

	add	di,ax				; go to end of command line
        mov	byte [di],0Dh			; insert a carriage return
	xor	cx,cx				; clear cx
        mov	[num_positionals],cx		; initialize positionals

; Scan the command line looking for the parameters

Parse_command_line:
	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
	mov	di,PARSE_COMMAND
	mov	cx,[num_positionals]		; Get number of positionals
	xor	dx,dx				; clear dx
        mov	[old_parse_ptr],si		; save position before calling parser
	;call	dword ptr Init_Parse
	call	far [Init_Parse]		; call parser
        mov     [num_positionals],cx		; Save number of positionals
	; 29/01/2023
	;;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
        ;cmp	ax,-1
	;jne	short t1
	; 10/06/2023
	inc	ax	 ; cmp ax,-1
	jnz	short t1 ; 0FFFFh -> 0
	; ax = 0
	jmp     ArgsDone                        ; yes - exit
t1:	
	;;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
	;;cmp	ax,0
	;and	ax,ax
	; 10/06/2023
	dec	ax  ; cmp ax,0
	jz	short parse_cont  ; 1 -> 0	; no - continue

; Before issuing error message - make sure switch is not /C

parse_line_error:
	; 14/01/2023
	;push	si				; save line position
	;push	ax				; save error number
	;cmp	ax,3
	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
        ;jnz	short parse_line_error_disp	; No - just issue message
	jne	short parse_line_error_disp2
	push	si ; **				; save line position
	push	ax ; *				; save error number
	mov	di,si				; Get terminating pointer in DI
        mov     si,[old_parse_ptr]		; Get starting pointer in SI

init_chk_delim:
	cmp	si,di				; at end of parsed parameter?
        je	short parse_line_error_disp	; Yes - just display message
	lodsb					;
	cmp	al,20h ; ' ' ; 16/04/2023
	;cmp	al,space_chr ; 14/01/2023
	;;cmp	al,[space]			; Skip blank spaces
	je	short init_chk_delim		;
	;cmp	al,9
	cmp	al,tab_chr ; 9			; Skip tab characters
	je	short init_chk_delim		;

	cmp	al,[RSwitChar]	; '/'		; Switch?
        jne	short parse_line_error_disp	; No - just issue message
	lodsb					; Get the char after the switch

	call	iupconv 			; upper case it

	;cmp	al,[scswitch]	; 'C'		; it is /C?
        ;jne	short check_k_too ; MSDOS 6.0	;
	;16/04/2023
	cmp	al,'C' ; scswitch
	jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
	pop	dx ; *				; even up stack
	pop	dx ; **				; even up stack
	jmp	SetSSwitch			; Yes - go set COMMAND /C

	; MSDOS 6.0
;check_k_too:
	;cmp	al,[skswitch]	; 'K'		; it is /K?
        ;jne	short parse_line_error_disp	;
	;pop	dx ; *				; even up stack
	;pop	dx ; **				; even up stack
        ;jmp	SetKSwitch			; Yes - go set COMMAND /K

parse_line_error_disp:
	; 14/01/2023
	pop	ax ; *				; restore error number
	pop	si ; **				; restore line position
parse_line_error_disp2:
	mov	dx,ax				; get message number
	call	RPrintParse
	call	crlf
        jmp     short Parse_command_line        ; continue parsing

; 16/04/2023
%if 1
SetMSwitch:
        ;cmp	byte [ext_msg],1
	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
	; 16/04/2023
	;jnz	short setMswitchok		; no - set it
	;;mov	ax,1
	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
	;jmp	parse_line_error                ; go issue error message
	; 16/04/2023
	je	short parse_line_error_j
setMswitchok:
        ;mov	byte [ext_msg],1
	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
	; 06/06/2023
	jmp	short Parse_command_line	; keep parsing
%endif

parse_cont:

; 15/01/2023
%if 0
	; MSDOS 3.3

; See if a switch was entered

	jcxz	COMRETURNSJ
	dec	cx
	lodsb
	or	al,20h		; Lower case
	cmp	al,'f'		; FAIL switch
	jnz     short CHECKPSWITCH
%endif

	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
	; MSDOS 6.0

; See if a switch was entered
;
; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare

	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
	je	short SetFSwitch		; yes go set fail switch
	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
	Je	short SetPSwitch		; yes go set up PERMCOM
	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
	je	short SetDSwitch		; yes go set date switch
	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
	je	short SetSSwitch		; yes go set up SINGLECOM
	; MSDOS 6.0 only!
	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
        ;je	short SetKSwitch		; yes go set up SINGLECOM
	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
	je	short SetESwitch		; yes go set up environment
	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
	;je	short SetMSwitchjmp		; yes go set up message flag
	; 15/01/2023
	je	short SetMSwitch 
	jmp	ChkOtherArgs		; Must be something else

	; MSDOS 6.0
;SetMSwitchjmp:
	;jmp	SetMSwitch
	
	; MSDOS 6.0
SetFSwitch:
	cmp	byte [fFail],-1		; has fail switch been set?
	; 16/04/2023
	;jne	short failok		; no - set it
	;;mov	ax,1
	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
        ;jmp	parse_line_error        ; go issue error 
	; 16/04/2023
	je	short parse_line_error_j

	; MSDOS 3.3 & MSDOS 6.0
failok:
	mov	byte [fFail],-1		; fail all INT 24s.
	; MSDOS 3.3
	;jmp	short CHKARG
	; MSDOS 6.0
	jmp	Parse_command_line

;CHECKPSWITCH:
	;;cmp	al,'p'			; Permanent COMMAND switch
	;cmp	al,[letter_p]
        ;jnz	short CHECKDSWITCH

SetPSwitch:

; We have a permanent COMMAND switch /P. Flag this and stash the
; termination address.

	; MSDOS 6.0
	cmp	byte [PermCom],0	; has /p switch been set?
	jz	short permcomok		; no - set it
	; 16/04/2023
parse_line_error_j:
        ;mov	ax,1
	mov	ax,MoreArgs_Ptr		; set up too many arguments
        jmp	parse_line_error	; go issue error 

permcomok:
	; MSDOS 3.3 & MSDOS 6.0
	inc	byte [PermCom]
	;mov	word [OLDTERM],LODCOM
	mov	word [OldTerm],LodCom_Trap
	;mov	[OLDTERM+2],ds
	mov	[OldTerm+2],ds

; make sure that we display the date and time. if the flag was not
; initialized, set it to indicate yes, do prompt.

	; MSDOS 3.3
	;cmp	byte [PRDATTM],-1
	;jnz	short CHKARG
	;mov	byte [PRDATTM],0
	;jmp	short CHKARG

	; MSDOS 6.0
	cmp	byte [PRDATTM],-1
	jne	short Parse_command_line_jmp
	mov	byte [PRDATTM],0
Parse_command_line_jmp:
	jmp     Parse_command_line	; keep parsing

;COMRETURNSJ:
;	; MSDOS 3.3
;	JMP	ARGSDONE

;CHECKDSWITCH:
	;;cmp	al,'d'
        ;cmp	al,[letter_d]
	;jnz	short CHECKCSWITCH

SetDSwitch:

; Flag no date/time prompting.

	; MSDOS 6.0
	cmp	byte [dswitch],0	; has /D switch been set?
	; 16/04/2023
	;jz	short setdateok		; no - set it
        ;;mov	ax,1
	;mov	ax,MoreArgs_Ptr		; set up too many arguments
        ;jmp	parse_line_error	; go issue error message
	; 16/04/2023
	jnz	short parse_line_error_j
setdateok:
	inc	byte  [dswitch]		; indicate /D entered

	; MSDOS 3.3 & MSDOS 6.0
        mov	byte [PRDATTM],1	; User explicitly says no date time
	; MSDOS 3.3
	;jmp	short CHKARG
	; MSDOS 6.0
	jmp     Parse_command_line	; continue parsing

	; 15/01/2023
	; MSDOS 6.0 
;SetKSwitch:
	;mov	byte [SemiPermCom],0
	;jmp	short SetSorKSwitch

;CHECKCSWITCH:
	;;cmp	al,'c'
	;cmp	al,[letter_c]
        ;jnz	short CHECKESWITCH

SetSSwitch:
;SETCSWITCH:

; Set up pointer to command line, flag no date/time and turn off SingleCom.

	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
;SetSorKSwitch:
	mov	[SingleCom],si		; Point to the rest of the command line
	mov	byte [PRDATTM],1	; no date or time either, explicit
;COMRETURNSJ: ; 24/09/2018
	jmp     ArgsDone

;CHECKESWITCH:
	;cmp	al,'e'
	;jnz	short CHKARG

; Look for environment-size setting switch

; The environment size is represented in decimal bytes and is
; converted into paragraphs (rounded up to the next paragraph).

SetESwitch:
	; MSDOS 6.0
	cmp	byte [eswitch],0	; has environment size switch been set?
	; 16/04/2023
	;jz	short eswitchok		; no - set it
	;;mov	ax,1
	;mov	ax,MoreArgs_Ptr		; set up too many arguments
        ;jmp	parse_line_error	; go issue error message
	; 16/04/2023
	jnz	short parse_line_error_j
eswitchok:
	inc	byte [eswitch]		; indicate /E entered 	

; 15/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
%if 0
	; 23/09/2018 - Retro DOS v3.0

	; MSDOS 3.3
	; (COMMAND.COM offset 0FC5h)
ESWITCHOK:
	jcxz    CHKARG
	dec     cx
	lodsb
	cmp     al,':'
	jnz     short CHECKSWITCHCHR
	xor     bx,bx
	mov     ax,bx
GETENVSIZE:
	jcxz    SETENVSIZE
	dec     cx
	lodsb
	cmp     al,'0'
	jb      short NOTDECIMALCHR
	cmp     al,'9'
	ja      short NOTDECIMALCHR
	sub     al,'0'
	mov     dx,bx
	shl     dx,1
	shl     dx,1   ; dx = 4*bx	
	add     bx,dx  ; bx = 5*bx
	shl     bx,1   ; bx = 10*bx	
	add     bx,ax
	jmp     short GETENVSIZE

NOTDECIMALCHR:
	;cmp	al,' '
	cmp	al,[SPACE_CHAR]
	jz      short CHECKENVSIZE
	;cmp	al,'/'
	cmp     al,[RSWITCHAR]
	jz      short CHECKENVSIZE

CHECKNEXTECHR:
	jcxz    INVENVSIZE
	dec     cx
	lodsb
	;cmp	al,' '
	cmp     al,[SPACE_CHR]
	jz      short ENVSIZESPC
	;cmp	al,'/'
	cmp     al,[RSWITCHAR]
	jnz     short CHECKNEXTECHR

ENVSIZESPC:
	dec     si
	inc     cx
	jmp     short INVENVSIZE
	
	;nop

CHECKENVSIZE: 
	dec     si
	inc     cx

SETENVSIZE:
	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
	mov	word [ENVSIZ],ENVBIG/16
	cmp     bx,32768
	ja      short INVENVSIZE
	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
	mov	word [ENVSIZ],ENVSML/16
	cmp     bx,160
	jb      short INVENVSIZE
	add     bx,15
	shr     bx,1
	shr     bx,1
	shr     bx,1
	shr     bx,1
	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
	jmp     short NEXTCH2

	;nop

INVENVSIZE:
	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
	mov     ah,STD_CON_STRING_OUTPUT ; 9
	int     21h             ; DOS - PRINT STRING
				; DS:DX -> string terminated by "$"
NEXTCH2:
	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
	jmp     CHKARG

	;jmp	ARGSDONE

%endif
	; 15/01/2023
	; MSDOS 6.0
	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
        mov	di,COMND1_ADDR
	mov     bx,[di]				; into bx

	add	bx,0Fh				; Round up to next paragraph
	mov	cl,4				; convert to pargraphs
	shr	bx,cl				; by right 4

	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
	jmp	Parse_command_line		; continue parsing command line

; 16/04/2023
%if 0
SetMSwitch:
        ;cmp	byte [ext_msg],1
	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
	jnz	short setMswitchok		; no - set it
	;mov	ax,1
	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
	jmp	parse_line_error                ; go issue error message
setMswitchok:
        ;mov	byte [ext_msg],1
	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
	jmp	Parse_command_line              ; keep parsing
%endif

;ArgsDoneJ:
	;jmp	ArgsDone

	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
	
ChkOtherArgs:

; We have a non-switch character here.

	; MSDOS 6.0
	push	ds ; ****			;
	push	si ; *** 			; save place in command line
	lds	si,[COMND1_ADDR]		; get address of filespec
	;assume	ds:nothing			;

	mov	dx,si				; put in dx also
	mov	ax,3D02h
	;mov	ax,(OPEN shl 8) or 2            ; Read and write
	int	21h
	jc	short ChkSrchSpec		; Wasn't a file
	mov	bx,ax
	mov	ax,4400h
	;mov	ax,IOCTL shl 8
	int	21h
	test	dl,80h
	jnz	short IsaDevice
BadSetCon:
	mov	ah,3Eh
	;mov	ah,CLOSE		; Close initial handle, wasn't a device
	int	21h
	jmp	short ChkSrchSpec

; 15/01/2023
%if 0
	; MSDOS 3.3
	; (COMMAND.COM offset 1047h)
        dec	si
	inc	cx
	mov	dx,si
	push	cx ; **
	push	si ; *
CONTRLOOP:
	lodsb
	dec	cx
	;cmp	al,' '
	cmp	al,[SPACE_CHR]
	jz	short SETCDEV
	cmp	al,9
	jz	short SETCDEV
	jcxz	SETCDEVA
	jmp	short CONTRLOOP

SETCDEVA:
        inc	si
SETCDEV:
	mov	byte [SI-1],0
        ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
        mov	ax,(OPEN*256) | 2 ; 3D02h
        int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX -> ASCIZ filename
			; AL = access mode
			; 2 - read & write
        jc	short CHKSRCHSPEC	; Wasn't a file
        mov	bx,ax
        ;mov	ax,IOCTL shl 8
        mov     ax,IOCTL*256 ; 4400h
	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
			; BX = file or device handle
        test	dl,80H
	jnz	short ISADEVICE
BADSETCON: ; MSDOS 6.0
	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
        int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
        JMP     short CHKSRCHSPEC
%endif
	;nop

	; 15/01/2023
IsaDevice:
	; MSDOS 3.3 & MSDOS 6.0
	xor	dh,dh
	or	dl,3				; Make sure has CON attributes
	;mov	ax,(IOCTL shl 8) or 1
	mov	ax,(IOCTL*256)|1 ; 4401h
	int	21h
	;
	; 15/01/2023
	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
	; 25/09/2018
	;pop	dx ; *
	;pop	dx ; **
	;
	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
	
	mov	dx,bx				; Save new handle

	; MSDOS 6.0
	cmp	byte [es:DevFlag],1
	jz	short DevErr

	; MSDOS 3.3
        ;pop	bx ; *				; Throw away saved SI
        ;pop	bx ; **				; Throw away saved CX

	; MSDOS 3.3 & MSDOS 6.0
	push	cx ; **
	mov	cx,3
	xor	bx,bx

	; 15/01/2023
rcclloop:
	mov	ah,3Eh
	;mov	ah,CLOSE ; 3Eh
	int	21h
	inc	bx
	loop	rcclloop

	mov	bx,dx				; New device handle
	mov	ah,45h
	;mov	ah,XDUP ; 45h
	int	21h				; Dup to 0
	mov	ah,45h
	;mov	ah,XDUP
	int	21h				; Dup to 1
	mov	ah,45h
	;mov	ah,XDUP
	int	21h				; Dup to 2
	mov	ah,3Eh
	;mov	ah,CLOSE
	int	21h				; Close initial handle
	
	pop	cx ; **
	
	; MSDOS 6.0
	pop	si ; ***			; restore position of command line
	pop	ds ; ****			;

; Register the fact that we already have redirected the output
; and can not do it again

	inc	byte [es:DevFlag]		
	jmp	Parse_command_line		; continue parsing

	; MSDOS 3.3
	;jcxz	ARGSDONEJ2
	;jmp	CHKARG

	; MSDOS 6.0
DevErr:
	pop	si ; ***
	pop	ds ; ****
	mov	dx,1
        call	RPrintParse                     ; "Too many parameters"
        call	crlf
	jmp	Parse_command_line

ChkSrchSpec:				; Not a device, so must be directory spec
	; MSDOS 6.0
        cmp	byte [es:PathFlag],1		; already set COMSPEC?
        jz	short DevErr			; yes, error
	
        inc	byte [es:PathFlag]		; mark that we have a path

; We have to override the passed environment. Allocate a buffer for use now.
; This buffer will later be replaced by a proper environment

	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
	mov	ax,[ss:EnvirSeg]
	
	; MSDOS 6.0
	;call	alloc_env                       ; environment buffer

	; 15/01/2023
	; MSDOS 5.0
	cmp	byte [ss:AllocedEnv],1
	mov	byte [ss:AllocedEnv],0
	jne     short env_alloced
	call	alloc_env
	mov	[ss:EnvirSeg],ax

env_alloced:
	; MSDOS 5.0 & MSDOS 6.0
	mov	es,ax
	;assume	es:nothing
	push	si ; **				; remember location of file
	xor	cx,cx				; clear cx for counting
	
	; 15/01/2023
countloop:
	lodsb					; get a character
	inc	cx				; increment counter
        ;;cmp	al,0
	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
	;jne	short countloop			; no - keep counting
	or	al,al	
	jnz	short countloop

	;;;;mov	al,[Space]
	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
	; 16/04/2023
	;mov	al,20h ; ' ' 
	dec	si				; move back one
        ;mov	[si],al				; put a space at end of line
	mov	byte [si],20h ; ' ' ; space_chr

; We now know how long the new pathspec for command.com is. Time to
; figure out how long the current COMSPEC setting is, and then to move
; all the environment data up, throwing that COMSPEC setting away, and
; preparing to append the new COMSPEC. ComspOffset (the offset of
; where the filespec exists in the environment) is updated as well.

	; MSDOS 6.0 COMMAND.COM
	;push	cx                              ;
        ;mov	cx,ENVBIG                       ;
        ;mov	di,ComspOffset                  ; get location of COMSPEC
        ;mov	al,0                            ;
        ;repne	scasb                           ; find the end of COMSPEC
        ;mov	si,di                           ;
;comp_endenv:                                   ;
        ;scasb                                  ; end of env?
        ;je	got_endenv                      ; yes
        ;repne	scasb                           ;
        ;jmp	comp_endenv                     ;
;got_endenv:                                    ;
        ;mov    cx,di                           ;
        ;sub    cx,si                           ;
        ;mov    di,ComspOffset                  ;
        ;sub    di,ComspStrLen                  ;
        ;push   ds                              ;
        ;push   es                              ;
        ;pop    ds                              ;
        ;rep    movsb                           ;
        ;dec    di                              ; copy in new COMSPEC=
        ;push   cs                              ;
        ;pop    ds                              ;
        ;assume ds:ResGroup                     ;
        ;mov    si,offset RESGROUP:ComspString  ;
        ;mov    cx,ComspStrLen                  ;
        ;rep    movsb                           ;
        ;mov    ComspOffset,di                  ;
        ;pop    ds                              ;
        ;assume ds:nothing                      ;
        ;pop    cx                              ;
	;
        ;pop    si                              ; get new comspec location back

	; MSDOS 3.3 COMMAND.COM
	;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
	;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
	;mov	cl,4
	;shr	ax,cl
	;mov	dx,ds
	;add	ax,dx
	;mov	[ENVIRSEG],ax
	;mov	es,ax
	;;mov	al,' '
	;mov	al,[SPACE_CHR]
	;mov	[si-1],al
	;pop	si ; **				; Remember location
	;pop	cx ; *				; and count
	;;mov	di,[ECOMLOC]
	;mov	di,[COMSPOFFSET]

	; 15/01/2023
	; MSDOS 5.0 COMMAND.COM
	pop	si ; **
	;mov	di,14
	mov	di,ECOMSPEC ; mov di,0Eh

ComtrLoop:
	; MSDOS 3.3 & MSDOS 6.0
	lodsb
	dec	cx
	;;;;cmp	al,' '
	;;;cmp	al,[space_chr]
	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
	; 16/04/2023
	cmp	al,20h ; ' ' ; space_chr
	je	short SetComsr
	; MSDOS 3.3
	;cmp	al,9
	;je	short SetComsr
	; MSDOS 3.3 & MSDOS 6.0
	stosb
	jcxz	SetComsr
	jmp	short ComtrLoop

SetComsr:
	; 15/01/2023
	; MSDOS 6.0
	push	cx ; **
	push	cs				; Get local segment
	pop	ds				;
	;assume	ds:ResGroup			;
	push	ds ; *
	;mov	si,offset ResGroup:ComSpect
	mov	si,COMSPECT
	mov	cx,14
	mov	al,[es:di-1]
	cmp	al,[RDirChar]
	jne	short iNotRoot
	inc	si				; Don't make a double /
	dec	cx
	
	; MSDOS 3.3
	;push	si
	;push	cx
	;push	ds
	;mov	si,COMSPECT ; "/COMMAND.COM"
	;mov	cx,14
	;mov	al,[es:di-1]
	;call	PATHCHRCMPR
	;jnz	short INOTROOT			
	;inc	si				; Don't make a double /
	;dec	cx

iNotRoot:
	; MSDOS 3.3 & MSDOS 6.0
	rep	movsb

	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
        ;mov	dx,[ComspOffset] ; [COMSPOFFSET]
	; 15/01/2023
	;mov	dx,14
	mov	dx,ECOMSPEC ; mov dx,0Eh

	push	es
	pop	ds
	;;mov	ax,OPEN shl 8
	;mov	ax,OPEN*256 ; 3D00h
	mov	ax,3D00h ; 15/01/2023
	int	21h				; Open COMMAND.COM
	pop	ds ; *
	jc	short SetComsrBad		; No COMMAND.COM here
	mov	bx,ax				; Handle
	mov	ah,3Eh ; 15/01/2023
	;mov	ah,CLOSE ; 3Eh
	int	21h				; Close COMMAND.COM
SetComsrRet:
	; 15/01/2023
	pop	cx ; **
	pop	si ; ***

	; MSDOS 6.0
	pop	ds ; ****			;
	;assume	ds:ResGroup			;
	;
	push	cs				; Make sure local ES is
	pop	es				;  restored
	jmp	Parse_command_line		; continue parsing command line

	; MSDOS 3.3
;ARGSDONEJ2:
	;jcxz	ARGSDONE
	;jmp	CHKARG

	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
SetComsrBad:
	; MSDOS 3.3 & MSDOS 6.0
	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
	mov	dx,BADCOMLKMES

;	Note: we're about to make a near call to TriageError, which
;	lives in a different segment and group. Some linkers will
;	generate a warning like "Possible fix-up overflow". We're
;	ok, though, because we all fit in 64 KB and, at init time,
;	we're still all together.

	; 16/01/2023
	TRIAGEERROR equ TRANSTART+TriageError
	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)

	;call	50B2h
	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
				; in original MSDOS 3.3 COMMAND.COM

			; TriageError procedure is at offset 50B2h
			; in original MSDOS 5.0 COMMAND.COM	
	cmp	ax,65
	jne	short doprt
	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
	mov	dx,BADCOMACCMSG
doprt:
	call	RPrint
	;mov	si,offset ResGroup:ComSpect
	mov     si,COMSPECT ; "\COMMAND.COM"
	;;mov	di,[ECOMLOC]
	;mov	di,[COMSPOFFSET] ; [ComspOffset]
	; 16/01/2023
	mov	di,ECOMSPEC ; mov di,0Eh
	mov	cx,14
	rep	movsb				; get my default back

	jmp	short SetComsrRet

	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
ArgsDone:
	; MSDOS 6.0
	mov	es,[EnvirSeg]			; get environment back
	;assume	es:nothing			;

	; MSDOS 3.3 & MSDOS 6.0
        cmp	byte [PermCom],0
        jz	short ComReturns

	push	es				; Save environment pointer
	mov	ah,50h
	;mov	ah,SET_CURRENT_PDB ; 50h
	mov	bx,ds
	mov	es,bx
	int	21h				; current process is me
	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
	;;mov	ax,offset RESGROUP:LODCOM
	;mov	ax,LODCOM
	; 16/01/2023
	mov	ax,LodCom_Trap
        stosw
        mov	ax,ds
        stosw
	;;mov	ax,offset RESGROUP:CONTC
	;mov	ax,CONTC
	; 16/01/2023
	mov	ax,Ctrlc_Trap
        stosw
        mov	ax,ds
        stosw
	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
	;mov	ax,CRITERR
	; 16/01/2023
	mov	ax,CritErr_Trap
	stosw
	mov     ax,ds
	stosw
	;;mov	word ptr ds:16h,ds
	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
	mov	[PDB.PARENT_PID],ds
        ;;mov	dx,offset RESGROUP:Int_2e
	;mov	dx,Int_2e
        ; 16/01/2023
	mov	dx,Int2e_Trap
	mov	ax,252Eh
	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
	int     21h	; DOS - SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX = new vector to be used for specified interrupt
        pop	es				; Remember environment
	
ComReturns:
        ;mov	ax,word ptr ds:Pdb_Parent_Pid
	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
	; 16/01/2023
	mov	[Parent],ax			; Save parent
        ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
        ;mov	ax,word ptr ds:PDB_Jfn_Table
        mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
        mov	[Io_Save],ax		; Get the default stdin and out
        mov	[Com_Ptr+2],ds		; Set all these to resident
        mov	[Com_Fcb1+2],ds
	mov	[Com_Fcb2+2],ds
        ;mov	di,offset ResGroup:ComSpec
        mov	di,ComSpec

	;;mov	si,[ECOMLOC]
	; 16/01/2023
	;mov	si,[ComspOffset]
	mov	si,ECOMSPEC ; mov si,0Eh
	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
        ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
	
	mov	ax,ds				; Xchg es,ds
	push	es
	pop	ds
	mov	es,ax

	;jne	short CopyComsp ; MSDOS 6.0
	; 16/01/2023	
	je	short CopyComsp ; MSDOS 5.0
	;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy

        push	cs
        pop	ds

        ;mov	si,offset ResGroup:ComspString
	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
	push	es
	push	di
	call	IfindE
	mov	si,di
	push	es
	pop	ds
	pop	di
	pop	es
        jnc	short CopyComsp

	; MSDOS 6.0
ComSpecNofnd:
	;mov	si,offset ResGroup:ComspString
	;add	si,ComspStrLen
	;push	cs
	;pop	ds

	; 21/01/2023
	; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
	;mov	si,0Eh
	mov	si,ECOMSPEC
	push	cs
	pop	ds	

	; 21/01/2023
;COMSPECNOFND:
	; MSDOS 3.3
        ;;mov	si,[es:ECOMLOC]
        ;mov	si,[es:COMSPOFFSET]
	;;add	si,offset RESGROUP:PATHSTRING
        ;add	si,PATHSTRING ; "PATH="
	;push	cs
	;pop	ds

CopyComsp:
	; 21/01/2023
;COPYCOMSP:
	; MSDOS 3.3 & MSDOS 6.0
	;;mov	es:PutBackComSpec.SubstPtr,di
	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
	mov	[es:PutBackComSpec],di
	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
	;;add	es:PutBackComSpec.SubstPtr,2
	;add	word [es:PUTBACKSUBSTPTR],2
	add	word [es:PutBackComSpec],2
CopyComspLoop:
	lodsb
	stosb
	or	al,al
	jnz	short CopyComspLoop

	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
	dec	word [es:ComSpec_End]
	mov	ah,[es:ComDrv]
	add	ah,'A'-1 ; 40h
	mov	[es:PutBackDrv],ah		; save drive letter

	; -------------------------------

; 21/01/2023 - Retro DOS v4.0 COMMAND.COM
%if 0

	; MSDOS 3.3
	push	cs
        pop	ds
        ;mov	bx,offset RESGROUP:DATARESEND + 15
	mov	bx,DATARESEND+15
        mov	cl,4
        shr	bx,cl
        MOV     AH,SETBLOCK ; 4Ah
        int	21h			; Shrink me to the resident only

ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     

	mov	byte [TRNMVFLG], 1
	push	es ; *
	mov	si,TRANSTART
	mov	di,0
	mov	es,[TrnSeg]
	;mov	cx,4D5Ch
	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
	push	cx
	mov	ax,cx
	add	ax,si
	mov	cl,4
	shr	ax,cl
	inc	ax
	mov	cx,ds
	add	ax,cx
	cmp	ax,[TrnSeg]
	pop	cx
	jb	short MOV_DOWN

	call	LOADCOM
	jmp	short ICHKSUM

MOV_DOWN:
	add     si,cx
	dec     si
	add     di,cx
	dec     di
	std
	rep	movsb
	cld

ICHKSUM:
	; 24/09/2018
;
; Compute checksum right now before we can get corrupted and save it
;
	; MSDOS 6.0
	;mov	si,offset RESGROUP:TranStart
	;add	si,100h
	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
	;
	;cld
	;shr	cx,1
	;xor	dx,dx
;Ichksum:
	;lodsw
	;add	dx,ax
	;adc	dx,0
	;loop	Ichksum
	;
        ;mov	Sum,dx			; store checksum

	; MSDOS 3.3
	pop     es ; *
	call    CHKSUM
	mov     [SUM],dx

	; MSDOS 3.3 & MSDOS 6.0
        cmp     byte [PRDATTM],0	;
        jnz     short NOBATCHSEG	; don't do autoexec or date time
;
; Allocate batch segment for d:/autoexec.bat + no arguments
;
	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
	;mov	bx,3
	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
        mov     ah,ALLOC ; 48h		;
	int     21h	; DOS - 2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
        mov     [BATCH],ax		; save batch segment

NOBATCHSEG:

%endif
	; -------------------------------

	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
	
	; MSDOS 6.0
	call	setup_for_messages		; set up parse and extended error messages

; The routine below sets up the exact resident size of COMMAND. If this is not
; the first COMMAND, then the resident code is not duplicated and the resident
; size is just the data. If we are the first COMMAND, it checks if we are to
; be loaded into HIMEM. If not, then the resident size includes the code and
; the data otherwise it is just the data.
 
	call	Setup_res_end			; put resident size in ResSize

	push	cs
	pop	ds
	;assume	ds:RESGROUP

;Public EnvMaximum
; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh

	; 21/01/2023
	; MSDOS 6.0
	;;mov	si,offset RESGROUP:TranStart
	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
	;mov	si,TRANSTART
	;add	si,100h
	; 23/04/2023
	mov	si,TRANSTART+100h

	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
	;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
	mov	cx,TRANDATAEND-100h

	cld
	shr	cx,1
	xor	dx,dx
Ichksum:
	lodsw
	add	dx,ax
	adc	dx,0
	loop	Ichksum

        mov	[Sum],dx			; store checksum

        cmp     byte [PRDATTM],0
        jne	short NoBatchSeg		; don't do autoexec or date time
	
; Allocate batch segment for d:/autoexec.bat + no arguments

	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
	; 21/01/2023
	;mov	bx,4
        mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
	mov	ah,48h
	;mov	ah,ALLOC                        ;
        int	21h                             ;
	jc	short NoBatchSeg		; didn't allocate - pretend no batch
        mov	[Batch],ax			; save batch segment

NoBatchSeg:

; 21/01/2023
%if 0
	; MSDOS 3.3
	mov     bx,0FFFFh ; 65535
	mov     ah,ALLOC ; 48h
	int     21h	; DOS - 2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	sub     bx,[TRNSIZE]
	sub     bx,128
	mov     [ENVMAX],bx

	cmp     bx,4096
	jb      short ALLOCENVIRSEG
	mov     bx,4096-1		; max. allowed environment size
	mov     [ENVMAX],bx

ALLOCENVIRSEG:
	mov     ah,ALLOC ; 48h
	int     21h	; DOS - 2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	mov     bx,[ENVIRSEG]		; get old environment segment
	mov     [OLDENV],bx		; save it	
	mov     word [USEDENV],0	; initialize environment size counter
	mov     ds,bx
	mov     [ss:ENVIRSEG], ax	; save new environment segment
	mov     es,ax
	xor     si,si
	mov     di,si
	mov     bx,[ss:ENVMAX]
	shl     bx,1
	shl     bx,1
	shl     bx,1
	shl     bx,1
	mov     [ss:ENVMAX],bx		; convert envmax to bytes
	dec     bx			; dec by one to leave room for double 0
	xor     dx,dx			; use dx to indicate that there was
					; no environment size error.

NXSTR:
	call    GETSTRLEN		; get the size of the current env string

	push    ds
	push    cs
	pop     ds
	add     [USEDENV],cx		; add the string length to env size
	pop     ds
	cmp     cx,1			; end of environment was encountered.
	je      short ENVEXIT
	sub     bx,cx
	jnb     short OKCPYSTR		; can't fit in all of enviroment.
	inc     dx			; out of env space msg must be displayed
	jmp     short ENVEXIT

	;nop

OKCPYSTR:
	jmp     short NXSTR

ENVEXIT: 
	push    cs
	pop     ds
	or      dx, dx			; dx will be non-zero if error
	jz      short ENVNOERR
	mov     dx,OUTENVMSG		; dx = ptr to msg
	call    RPRINT

%endif

	; 21/01/2023
	; MSDOS 6.0 (& MSDOS 5.0)
	mov	bx,[EnvirSeg]			; get old environment segment
	mov	[OldEnv],bx			; save it
	mov	word [UsedEnv],0		; initialize env size counter
	mov	ds,bx
	;assume	ds:nothing
	
	xor	si,si
	mov	di,si

; This is the maximum allowed size for the environment

	; 21/01/2023
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
	;;mov	[ss:EnvMax],bx
	;shl	bx,1
	;shl	bx,1
	;shl	bx,1
	;shl	bx,1
	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
	mov	[ss:EnvMax], bx			; convert envmax to bytes
	dec	bx				; dec by one to leave room for double 0
	xor	dx,dx				; use dx to indicate that there was
						; no environment size error.
;public NxtStr
NxtStr:
	call	GetStrLen			; get the size of the current env string

;Bugbug: Can use ss here to address UsedEnv

	push	ds                              ; get addressability to environment
        push	cs                              ;                       counter
        pop	ds                              ;
	;assume	ds:ResGroup
        add	[UsedEnv],cx			; add the string length to env size
	pop	ds                              ;
	;assume	ds:nothing
	
	cmp	cx,1				; end of environment was encountered.
	je	short EnvExit
	sub	bx,cx
	;jae	short OkCpyStr			; can't fit in all of enviroment.
	; 21/01/2023
	jae	short NxtStr
	inc	dx				; out of env space msg must be displayed
	;jmp	short EnvExit

;OkCpyStr:
	;jmp	short NxtStr

EnvExit:
	push	cs
	pop	ds
	;assume	ds:ResGroup
	or	dx,dx				; dx will be non-zero if error
	jz	short EnvNoErr
	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
	mov	dx,OUTENVMSG
	call 	RPrint
EnvNoErr:
	mov	ax,[EnvSiz]			; env size previously set
	mov	cl,4
	shl	ax,cl				; get size in bytes
	cmp	ax,[UsedEnv]			; is it a new env?
	ja	short st_envsize		; yes, store the size
	mov	ax,[UsedEnv]
	add	ax,15				; round up
st_envsize:	
	shr	ax,cl
	mov	[EnvSiz],ax			; store env size needed(paras)

;if MSVER
	;cmp	SingleCom,0
	;jnz	nophead 			; don't print header if SingleCom
	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
	;call	RPrint
;nophead:
;endif

; 21/01/2023
%if 0
	; MSDOS 3.3
ENVNOERR:
	mov     cx,[ENVMAX]
	sub     cx,bx			; current environment size in bytes
	add     cx,16			; add memory arena to the size
	shr     cx,1
	shr     cx,1
	shr     cx,1
	shr     cx,1			; convert current env size to paragraphs
	cmp     cx,[ENVSIZ]		; compare with env size previously set
	;jb	short SET_ENVSIZE
	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
	mov     [ENVSIZ],cx		; store env size needed (paragraphs)

SET_ENVSIZE:
	mov     bx,[ENVSIZ]
	mov     ax,es
	add     ax,bx			; get end segment of environemnt
	cmp     ax,[INITEND]		; compare with init code end segment
	ja      short NOPHEAD
					; free unused paragraghs		
	mov     ax,es
	mov     bx,[INITEND]
	sub     bx,ax
	;mov	byte [RESETENV],1  ; 24/09/2018
	mov	word [RESETENV],1	; environment segment reset sign

NOPHEAD:
	; MSDOS 3.3
	mov     ah,SETBLOCK ; 4Ah
	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block to change
			; BX = new size in paragraphs
%endif
	; 21/01/2023

	; MSDOS 3.3 & 6.0
	cmp     word [Batch],0		; did we set up a batch segment?
	jnz     short DoDate		; yes - go initialize it
	jmp     NoDttm			; don't do autoexec or date time

DoDate:

; allocate batch segment for d:/autoexec.bat + no arguments

	mov	ax,[Batch]		; get batch segment
	mov	byte [EchoFlag],3	; set batch echo
	mov	word [Nest],1		; set nest flag to 1 batch
	mov	es,ax

; initialize the segment

	xor	di,di
	;;mov	al,0
	;mov	al,BATCHTYPE ; 0
	; 06/06/2023
	xor	ax,ax
	stosb
	;mov	al,1			; initialize echo for batch exit
	inc	al
	stosb

; Hosebag! This guy does not use the struct fields to init the BatchSegment

	;xor	ax,ax			; initialize to zero
	; 06/06/2023
	dec	al ; ax = 0	

	; 21/01/2023
	stosb	; MSDOS 6.0 		; clear out BatchEOF

	stosw				; batch segment of last job - batlast
	stosw				; segment for FOR
	stosb				; FOR flag
	stosw				; position in file - batseek
	stosw

; clean out the parameters

	;mov	ax,-1			; initialize to no parameters
	; 06/06/2023
	dec	ax ; ax = -1

	mov	cx,10
	rep	stosw

; decide whether we should grab the default drive

	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
	jne	short NoAutSet
	mov	ah,19h	; 21/01/2023
	;mov	ah,GET_DEFAULT_DRIVE ; 19h
	int	21h
	;;add	al,'A'
	;add	al,[letter_A] ; Ucasea
	;add	al,[ucasea] ; 21/01/2023
	; 21/01/2023
	add	al,'A'
	mov	[AUTOBAT],al
	; 21/01/2023
	;mov	[KAUTOBAT],al
NoAutSet:

; copy in the batch file name (including nul)

	;mov	si,offset ResGroup:AutoBat
	mov	si,AUTOBAT
	mov	cx,8
	rep	movsw
	; 23/04/2023
	movsb	; MSDOS 6.0		; move in carriage return to terminate string

	;mov	dx,offset ResGroup:AutoBat
	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"

	;;mov	ax,OPEN shl 8
	mov	ax,3D00h ; 21/01/2023
	;mov	ax,OPEN*256 ; 3D00h  ; open for read
	int	21h			; see if autoexec.bat exists
	jc	short noabat
	mov	bx,ax
	mov	ah,3Eh ; 21/01/2023
	;mov	ah,CLOSE  ; 3Eh
	int	21h
	jmp	short Drv0		; go process autoexec

noabat:
	push	ax
	call	Setup_Seg
	mov	[triage_add+2],ax
	pop	ax
	call	far [triage_add]	; get extended error
	cmp	ax,65			; network access denied?
	;jne	short OPENERR		; no - go deallocate batch
	; 21/01/2023
	;je	short AccDenErr
	jne	short OpenErr 

	; 21/01/2023
;_ACCDENERROR:					; yes - put out message
;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
;	mov	dx,ACCDENERR
;	call	RPRINT

	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 6.0 (& MSDOS 5.0)

; 21/01/2023
%if 0

; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
; by Ellen to check only when in Korea. The country information
; returned will overlay the old parse data area, but we don't care
; since we won't need the parse information or country information.
; We only care about the country code returned in BX.

	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h

	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
	mov	dx,INTERNAT_INFO
	mov	ax,3800h
	;mov	ax,INTERNATIONAL<<8
	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
	int	21h				;
	jc	short NoKabat 			; error - don't bother with it
	cmp	bx,52h
	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
	jnz	short OpenErr 			; no, don't check for kautoexe

	;mov	di,BatFile			; 3/3/kk
	mov	di,20h
	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
	mov	si,KAUTOBAT
	mov	cx,8				; auto execution for the 3/3/kk
	rep	movsw				; non-english country	3/3/kk
	movsb					; move in carraige return to terminate string
	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
	mov	dx,KAUTOBAT
	mov	ax,3D00h
	;mov	ax,OPEN<<8
	;;mov	ax,OPEN shl 8			; 3/3/kk
	int	21h				; see if kautoexe.bat exists  3/3/kk
	jc	short NoKabat 			; 3/3/kk
	mov	bx,ax				; 3/3/kk
	mov	ah,3Eh
	;mov	ah,CLOSE			; 3/3/kk
	int	21h				; 3/3/kk
	jmp	short Drv0			; 3/3/kk

NoKabat:					; 3/3/kk
	call	far [Triage_Add]		; get extended error
	cmp	ax,65				; network access denied?
	jnz	short OpenErr 			; no - go deallocate batch

%endif
	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

AccDenErr:					; yes - put out message
	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
	mov	dx,ACCDEN
	call	RPrint
OpenErr:
;OPENERR:
	mov	es,[Batch]		; not found--turn off batch job
	mov	ah,49h
	;mov	ah,DEALLOC ; 49h
	int	21h
	mov	word [Batch],0		; after dealloc in case of ^c
	mov	byte [EchoFlag],1
	mov	word [Nest],0		; indicate no batch in progress

;DoDttm:
	;mov	ax,offset TranGroup:Datinit
	mov	ax,DATINIT
	mov	[INITADD],ax

	; MSDOS 6.0
;;M004;;mov	ax,TrnSeg	
;
; M004; We cant use TrnSeg now because it is not initialized. We now that
; M004; the transient starts on a para boundary at the label TranStart.
; M004; We use TranStart to get the start of the transient segment.

	; 21/01/2023
	;mov	ax,offset RESGROUP:TranStart	; M004
	;;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
	; 06/06/2023
	;mov	ax,TRANSTART
	;mov	cl,4				; M004
	;shr	ax,cl				; get relative seg ; M004
	; 06/06/2023
	mov	ax,TRANSTART>>4	

	mov	cx,cs
	add	ax,cx				; ax = transient seg ; M004

	; 21/01/2023
	; MSDOS 3.3
	; 25/09/2018
	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h

	; MSDOS 3.3 & MSDOS 6.0
	mov	[INITADD+2],ax
	;call	dword ptr InitAdd
	call	far [INITADD]

NoDttm:
	; MSDOS 6.0
	; 21/01/2023
;Copyright:
	;public	Copyright
;	Bugbug:	remove Copyright label.

;if IBMVER
	cmp	word [SingleCom],0
	jnz	short Drv0			; don't print header if SingleCom
	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
	mov	dx,COPYRIGHTMSG
	call	RPrint
;endif
	; 21/01/2023
	; MSDOS 3.3
	;cmp	word [SingleCom],0	; don't print header if SingleCom
	;jnz	short DRV0
	;mov	dx,HEADERPTR	; dx = ptr to msg
	;call	RPRINT
;DRV0:
	; MSDOS 3.3
	;mov	byte [INITFLAG],0
	;jmp	ENDINIT

	; 21/01/2023
	; MSDOS 6.0
Drv0:						; Reset APPEND state
	push	ds				; save data segment
	push	cs				; Get local segment into DS
	pop	ds				;
	mov	ax,0B707h ; 21/01/2023
	;mov	ax,APPENDSETSTATE		; Set the state of Append
	mov	bx,[Append_State] 		;  back to the original state
	int	2Fh				;
	pop	ds				; get data segment back

;Check FirstCom set previously to see if this is the first instance of
;command.com. If not, we do not move command.com. Instead, we copy over the
;jump table from the previous stub to the current stub.

	cmp	byte [FirstCom],1		; first command.com?
	jz	short move_code			; yes, move it

	push	es
	push	ds

	push	ds
	pop	es
	;mov	di,offset DATARES:Int2f_Entry
	mov	di,Int2f_Entry	

	mov	ds,[es:ResJmpTable+2]		; get segment address
	mov	si,[es:ResJmpTable]		; get offset address

	;mov	cx,11
	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
	;shl	cx,1
	;shl	cx,1				; size of table in bytes
	; 21/01/2023
	mov	cx,44				; size of table in bytes

	cld
	rep	movsb				; copy the jump table

;Check if the resident code is in HMA. We assume that it is in HMA if its 
;code segment > 0f000h. If in HMA, we set the ComInHMA flag

	cmp	word [es:di-2],0F000h		; is resident code in HMA?
	jb	short res_low			; no, dont set flag

	mov	byte [es:ComInHMA],1		; indicate code in HMA
res_low:
	pop	ds
	pop	es
	jmp	short finish_init

;Now, we can move the resident code to its final location, either to HIMEM
;or to overlay the messages in the data segment if the user has not used the
;/msg switch.

move_code:
	call	Move_res_code			; move the code

finish_init:
	;jmp	RESGROUP:EndInit 		; finish initializing
	jmp	EndInit

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)

GetStrLen:
;	Get length of string pointed to by DS:SI. Length includes NULL.
;	Length is returned in CX

	; MSDOS 3.3 & MSDOS 6.0
	xor	cx,cx
NxtChar:
	lodsb
	inc	cx
	or	al,al
	jnz	short NxtChar
	retn

	; 29/01/2023
Setup_Seg:

; If the transient has been loaded in TranSeg, then we need to use that
; segment for calls to routines in the transient area. Otherwise, the current
; code segment is used
; Segment returned in AX.

	; MSDOS 3.3 & MSDOS 6.0
	mov	ax,[TrnSeg]
	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
	je	short setup_end

;06/06/2023
%if 0
	push	bx
	mov	bx,cs
	;mov	ax,offset ResGroup:TranStart
	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
	; 06/06/2023
	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
	;mov	ax,TRANSTART
	;shr	ax,1
	;shr	ax,1
	;shr	ax,1
	;shr	ax,1
	; 29/01/2023
	mov	ax,TRANSTART>>4
	add	ax,bx
	pop	bx
%endif
	; 06/06/2023
	mov	ax,cs
	add	ax,TRANSTART>>4

setup_end:
	retn

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
;RPRINT:
	; MSDOS 3.3
	;push    ax
	;call    SETUP_SEG
	;mov     [PRINTADD+2], ax
	;;call	dword ptr PRINTADD
	;call	far [PRINTADD]
	;pop     ax
	;retn

	; 29/01/2023
	; MSDOS 6.0
;***	RPrintParse - display parse error message
;
;	ENTRY	DX = parse error #
;
;	EXIT	nothing
;
;	USED	flags
;
;	EFFECTS
;	  Message is displayed on stdout.

RPrintParse:	;proc
	;assume	ds:ResGroup,ss:ResGroup

	push	dx				; preserve DX
	xchg	bx,dx				; bx = parse error #
						; dx = saved BX
	dec	bx				; bx = parse error index, from 0
	shl	bx,1				; bx = offset in word table
	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
	mov	bx,[bx+PARSMSGPTRS]
	xchg	bx,dx				; dx = ptr to error msg
						; bx = restored
	call	RPrint				; print the message
	pop	dx				; restore DX
	retn

;RPrintParse	endp

	; 29/01/2023
;PATHCHRCMPR:
	; MSDOS 3.3
	;push	dx
	;mov	dl,[slash_chr]
	;;cmp	byte [RSWITCHAR],'/'
        ;cmp	[RSWITCHAR],dl
	;je	short RNOSLASHT
	;;cmp	al,'/'
	;cmp	al,dl
	;je	short RET41 ; zf = 1 
;RNOSLASHT:
        ;;cmp	al,'\'
	;cmp	al,[bslash_chr]
;RET41:
	;pop	dx
	;retn

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
IfindE:
	; MSDOS 3.3 & MSDOS 6.0
	call	ifind				; find the name
	;jc	short ifind2			; carry means not found
	;jmp	short Iscasb1 			; scan for = sign
	; 29/01/2023
	jnc	short Iscasb1
ifind2:
	retn

	; 29/01/2023

; on return of find1, es:di points to beginning of name

ifind:
	cld
	call	Icount0				; cx = length of name
	mov	es,[EnvirSeg]
	xor	di,di
ifind1:
	push	cx
	push	si
	push	di
ifind11:
	lodsb
	call	iupconv
	inc	di
	cmp	al,[es:di-1]
	jnz	short ifind12
	loop	ifind11
ifind12:
	pop	di
	pop	si
	pop	cx
	jz	short ifind2
	push	cx
	call	Iscasb2 			; scan for a nul
	pop	cx
	;cmp	byte [es:di],0
	;jnz	short ifind1
	;stc					; indicate not found
	cmp	byte [es:di],1
	jnb	short ifind1
	; cf=1					; indicate not found
;ifind2:
	retn

	; 29/01/2023
Icount0:
	push	ds
	pop	es
	mov	di,si

	push	di				; count number of chars until "="
	call	Iscasb1
	; 25/09/2018
	;jmp	short Icountx
	;push	di				; count number of chars until nul
	;call	Iscasb2
;Icountx:
	pop	cx
	sub	di,cx
	xchg	di,cx
	retn

Iscasb1:
	; 29/01/2023
	mov	al,"="
	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
	jmp	short Iscasbx
Iscasb2:
	xor	al,al				; scan for a nul
Iscasbx:
	mov	cx,256 ; 100h
	repnz	scasb
	retn

	; 29/01/2023
;IUPCONV:
	; MSDOS 3.3
        ;;cmp	al,"a"
	;cmp	al,[letter_a]
        ;jb	short IRET22
        ;;cmp	al,"z"
        ;cmp	al,[letter_z]
	;ja	short IRET22
        ;sub	al,20h			; Lower-case changed to upper-case
;IRET22:
	;retn

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h

	; MSDOS 6.0
; *****************************************************************
; *
; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
; *
; * FUNCTION:	 This routine returns the upper case equivalent of
; *		 the character in AL from the file upper case table
; *		 in DOS if character if above ascii 128, else
; *		 subtracts 20H if between "a" and "z".
; *
; * INPUT:	 DS	      set to resident
; *		 AL	      char to be upper cased
; *		 FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:	 AL	      upper cased character
; *
; *****************************************************************

iupconv:	;proc	near				
	;assume	ds:ResGroup			;

	cmp	al,80h				; see if char is > ascii 128
	jb	short other_fucase		; no - upper case math
	sub	al,80h				; only upper 128 chars in table
	push	ds				;
	push	bx				;
	;lds	bx,dword ptr FUCase_Addr+1	; get table address
	lds     bx,[FUCase_Addr+1]
	add	bx,2				; skip over first word
	;xlat	ds:byte ptr [bx]		; convert to upper case
	xlat
	pop	bx				;
	pop	ds				;
	jmp	short iupconv_end		; we finished - exit

other_fucase:					;
	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
	cmp	al,'a'
	jb	short iupconv_end		;     subtract 20h to get
	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
	cmp	al,'z'
	ja	short iupconv_end		;
	sub	al,20h				; Change lower-case to upper
iupconv_end:					;
	retn

;iupConv endp

	; 29/01/2023
init_contc_specialcase:
	; MSDOS 3.3 & MSDOS 6.0
						; This routine is called if control-C
	add	sp,6				;  is type during the date/time prompt
	push	si				;  at initialization time.  The desired
	mov	si,dx				;  response is to make it look like the
	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
	pop	si				;  INT 21h stuff off the stack, putting
	iret					;  a <CR> in the user's buffer, and
						;  returning directly to the user.
						; In this case the user is TCODE.

; ----------------------------------------------------------------------------

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)

	; MSDOS 6.0
; ****************************************************************
; *
; * ROUTINE:	 Setup_for_messages
; *
; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
; *		 messages as follows:
; *
; *		 IF /P and /MSG are entered
; *		    keep PARSE and EXTENDED ERRORS in memory
; *		 ELSE IF /P is entered
; *		    use PARSE and EXTENDED ERRORS on disk
; *		    remove PARSE ERRORS from memory
; *		 ELSE
; *		    remove PARSE ERRORS from memory
; *		 ENDIF
; *
; * INPUT:	 PERMCOM	Set up with user input
; *		 EXT_MSG	Set up with user input
; *		 System set up to retain PARSE ERRORS
; *
; * OUTPUT:	 registers unchanged
; *
; ****************************************************************

setup_for_messages: ;proc near		

	push	bx
	push	ds				; save data segment
	push	es				; save environment segment
	push	ax				;
	push	dx				;
	push	di				;
	mov	ax,cs				; get local segment to ES and DS
	mov	ds,ax				;
	mov	es,ax				;

	cmp	byte [PermCom],0		; was permcom set?
	jz	short no_permcom		; No - don't worry about messages

;*	We're permanent. Install our message services int 2f handler.

	push	es
	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
	mov	ax,352Fh
	int	21h
			; DOS - 2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX = value of interrupt vector
	mov	[Int2fHandler],bx
	mov	[Int2fHandler+2],es
	pop	es

;	DS = RESGROUP seg addr

; M005; We will not hook int 2fh on any command.com other than the first.
; M005; Carousel loads as a permanent command.com and when we exit Carousel,
; M005; it just wipes our arena out. So, int 2fh is still hooked and the
; M005; first int 2fh call after exit from Carousel (from the DOS terminate
; M005; call) goes off into space.

	cmp	byte [FirstCom],0		; M005
	je	short no_msg_hook		; M005
;
; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
; M005; Carousel plays around with the interrupt vector tables. He saves it
; M005; before loading a new command.com. Then, it takes hold of the current
; M005; command.com's PSP and then looks at all interrupt vectors whose
; M005; segment matches the command.com PSP and then updates these segments
; M005; to the new command.com's PSP in his saved vector table. Whenever we
; M005; we pop into his menu, he puts this saved table into the vector table.
; M005; If we now quit, Carousel just wipes out command.com's arena and then
; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
; M005; the command.com that was wiped out and so the next int 2fh call will
; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
; M005; renormalize our int 2fh pointer so that its cs is not the same as the
; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
; M005; remains nice and happy. The renormalized pointer points at a far 
; M005; jump to the actual int 2fh entry point.
;
	push	ds				; M005
	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
	mov     dx,Carousel_i2f_Hook
	sub	dx,10h				; renormalize offset; M005
	mov	ax,ds				; M005
	inc	ax				; Relocated cs ; M005
	mov	ds,ax				; M005
	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
	mov	ax,252Fh
	int	21h
			; DOS - SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX = new vector to be used for specified interrupt
	pop	ds				; M005
	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
	mov	[Carousel_i2f_Hook+3],ds
						; patch in the cs for jump
no_msg_hook:					; M005
	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
	jne	short permcom_end		; no /msg - exit

permcom_slash_msg:				; Keep messages in memory
	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
	mov     di,ExtMsgEnd
	mov	[ResMsgEnd],di			; save it
	jmp	short permcom_end		; exit

no_permcom:					
	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
	cmp	byte [ext_msg],1
	jne	short permcom_end		; no - no error
	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
	mov	dx,2
	call	RPrintParse

permcom_end:
	pop	di				;
	pop	dx				;
	pop	ax				;
	pop	es				; get environment back
	pop	ds				;
	pop	bx

	retn					;

;setup_for_messages	endp

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h

	; MSDOS 6.0

;***	CheckHelp - print help text and exit if /? is on command line
;
;	ENTRY	command-line tail at 81h
;
;	EXIT	return if /? not found
;		terminate if /? found
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS	Help text displayed if /? found on command line

CheckHelp:	; proc
	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP

	mov	si,81h			; DS:SI = ptr to command-line tail
	;mov	di,offset RESGROUP:Parse_Command
	mov	di,PARSE_COMMAND
					; ES:DI = ptr to primary parse block
	xor	cx,cx			; CX = # positional param's found
	xor	dx,dx			; DX will be ptr to result buffer
chParse:
	;call	dword ptr Init_Parse
	call	far [Init_Parse]	; call system parser

	;;cmp	ax,END_OF_LINE
	;cmp	ax,-1 ; 0FFFFh	
	;je	short chRet		; end of command line, no /? found
	;;cmp	ax,RESULT_NO_ERROR
	;;cmp	ax,0
	;;je	short chWhich		; valid syntax element found
	;;jmp	short chParse		; go parse more
	;and	ax,ax ; cmp ax,0
	;jnz	short chParse ; jne
	; 10/06/2023
	inc	ax	; cmp ax,-1
	jz	short chRet   ; 0FFFFh -> 0
	dec	ax	; cmp ax,0
	jnz	short chParse ; 1 -> 0
	; ax = 0
chWhich:
	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
	je	short chHelp		; /? found - display help & exit
	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
	;je	short chRet		; /c found - ignore rest of line
	; 29/01/2023
	jne	short chParse
	; MSDOS 6.0
        ;;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
      	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
	;je	short chRet		; /k found - ignore rest of line
	;jmp	short chParse		; anything else - ignore, keep looking
chRet:
	retn
chHelp:
	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
	mov	si,HelpMsgs
chHelpNext:
	lodsw					; AX = ptr to msg
	or	ax,ax
	jz	short chHelpDone		; end of list - all done
	mov	dx,ax				; DX = ptr to msg
	call	RPrint				; display msg
	jmp	short chHelpNext		; go do next msg

chHelpDone:
	int	20h				; terminate program
;chRet:
	retn

;CheckHelp	endp

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h

	; MSDOS 6.0

;***** Setup_res_end -- This routine determines the resident size of COMMAND.
;
; It determines based on 2 factors:
;	1. Is this is the first COMMAND?
;	2. Is COMMAND to be loaded into HIMEM?
;   The strategy works as follows:
;
;	if (First COMMAND)
;	then if (COMMAND in HIMEM)
;		ResSize = resident_data;
;	     else
;		ResSize = resident_data + resident_code;
;	else
;	   ResSize = resident_data;
;
; Int 2fh calls have been added to determine whether or not we are the first
; COMMAND and whether DOS is in HIMEM.
;
;	ENTRY: ResMsgEnd = resident size of data in paras
;
;	EXIT:  ResSize = resident size in low memory
;
;	REGISTERS AFFECTED: ax,cx,dx
;

GET_HMA_ADDR	equ	4A02h

Setup_res_end:	;proc near
	
	push	ds
	mov	ax,cs
	mov	ds,ax				;ds = RESGROUP
	;assume	ds:RESGROUP

	mov	cx,[ResMsgEnd]			;set resident size = data

;ifndef	ROMDOS

;M042 -- Begin changes
;If messages are to be kept behind, we need to round up the messages to
;the next para boundary. This is because we have a dummy segment between the
;data and the resident code segment so that the code segment starts on a
;para boundary

	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
	cmp	cx,ExtMsgEnd
	jne	short calc_res			;no, continue
	add	cx,15				;round up
	and	cx,0FFF0h
calc_res:

;M042 -- End changes

	xor	ax,ax
       	cmp	byte [FirstCom],1		;is it first command.com?
	;jne	short not_first			;no, do not keep code
	; 06/06/2023
	jne	short not_first2

;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
;bit 4 of dh is set

	push	bx
	push	cx
	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
	mov	ax,3306h
	int	21h
		; DOS - 5+ Get TRUE Version Number
		; (BL major, BH minor, DL revision, DH flags)
	pop	cx

;bugbug: remove version check after testing

	cmp	bl,5				;bl has true version ; M013
	jb	short oldver

	xor	ax,ax
	and	dh,10h				;is DOS in HMA ; M013
	;pop	bx
	;jnz	short not_first			;DOS in HIMEM, code not
						;	resident
	; 29/01/2023
	jnz	short not_first_pop
oldver:
	;mov	ax,offset CODERES:EndCode	;size of code in bytes
	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
	; 06/06/2023
	; 29/01/2023
	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
	; 03/05/2023
	mov	ax,EndCode-RCODE_START	; 06/06/2023

not_first_pop:
	; 29/01/2023
	pop	bx

not_first:

;Note that ax = 0 (side effect of int 2fh), if the code is not to be retained

	add	cx,ax

not_first2:	; 06/06/2023

;endif	;not ROMDOS

	add	cx,15				;round up to next para
	shr	cx,1
	shr	cx,1
	shr	cx,1
	shr	cx,1				;ax = para size of res code
	mov	[ResSize],cx			;store resident size

	pop	ds
	;assume	ds:nothing
	retn

;ifndef	ROMDOS

;bugbug: remove this code (for version independent COMMAND) after testing

	; 29/01/2023
;oldver:
;	pop	bx
;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
;	; 29/01/2023
;	mov	ax,EndCode-RCODE_START
;	jmp	short not_first

;endif	;not ROMDOS

;setup_res_end	endp

;ifndef	ROMDOS

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h

	; MSDOS 6.0
;*** Move_res_code -- This routine moves the resident code to its final 
; location. We check if DOS is in HIMEM. If so, we try to load ourselves
; in HIMEM. If we fail, then we remain low and update ResSize to reflect
; the correct resident size. When remaining low, we have to check if we 
; need to overlay the messages part of the data segment which is determined
; by the /msg switch.
;
;	ENTRY: ResMsgEnd = end of resident data
;
;	EXIT:  The resident code is either up high or in its final location
;		down low.
;
;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
	
Move_res_code:	;proc near

	push	ds
	push	es

	mov	ax,cs
	mov	ds,ax
	;assume	ds:RESGROUP

	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
	mov	ax,3306h
	int	21h				;DOS in HIMEM?
		; DOS - 5+ Get TRUE Version Number
		; (BL major, BH minor, DL revision, DH flags)

	and	dh,10h				; M013
	jnz	short move_high			;yes, move code high

;Check if messages have been discarded or not

load_low:
	push	ds
	pop	es				;es = RESGROUP
	mov	di,[ResMsgEnd]			;end offset in DATARES
	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
	;mov	bx,ExtMsgEnd
	; 29/01/2023
	cmp	di,ExtMsgEnd
	;cmp	di,bx				;are messages to be kept?
	je	short no_move			;yes, dont move code

	jmp	short setup_move		;es:di points at dest.

move_high:

;We have to call DOS to get the load address in HIMEM for COMMAND
;We pass in bx the number of bytes we need

	;mov	bx,offset CODERES:EndCode
	; 29/01/2023
	;;mov	bx,81Ah ; MSDOS 5.0 COMMAND.COM
	; 06/06/2023
	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023 ; 06/06/2023
	; 03/05/2023
	mov	bx,EndCode-RCODE_START ; 06/06/2023

;M030;
; Set di=0ffffh so that we load low in case no one answers this int 2fh

	mov	di,0FFFFh			;DT - in case no-one handles
						;this ; M030
	mov	ax,GET_HMA_ADDR ; 4A02h
	int	2Fh

;If the offset = 0xffff, then no HMA available

	cmp	di,0FFFFh			;HMA available?
	mov	byte [ComInHMA],1		;assume command.com in HMA
	jne	short setup_move		;no error, es:di = memory

	;mov	byte [ComInHMA],0		;could not load in HMA
	; 29/01/2023	
	dec	byte [ComInHMA] ; 1 -> 0

;Zero means that we do not have enough HIMEM. Remain low and update
;ResSize to reflect this

	mov	cx,[ResMsgEnd]			;size of data in bytes
	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
	;mov	ax,EndCode-RCODE_START
	;add	cx,ax
	; 06/06/2023
	; 29/01/2023
	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 ; 06/06/2023
	;add	cx,15				;round up to next para
	; 03/05/2023
	add	cx,(EndCode-RCODE_START)+15 ; 06/06/2023
	shr	cx,1
	shr	cx,1
	shr	cx,1
	shr	cx,1				;ax = para size of res code
	mov	[ResSize],cx			;store resident size
	jmp	short load_low			;let code remain low

no_move:
	; 05/05/2023
	;mov	cl,4
	add	di,0Fh
	and	di,0FFF0h			;round it to a para offset
	jmp	short patch_up

setup_move:
	;mov	si,offset RESGROUP:StartCode
	; 03/05/2023
	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
				; 0D40h for MSDOS 5.0 COMMAND.COM
	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
	;mov	cx,81Ah ; MSDOS 5.0 COMMAND.COM
	; 06/06/2023
	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
	; 03/05/2023
	mov	cx,EndCode-RCODE_START	; 06/06/2023

	cld
	push	di				;need di for patching offset
	rep	movsb
	pop	di

patch_up:
	call	patch_stub
	pop	es
	pop	ds
	;assume	ds:nothing
	retn

;Move_res_code endp

;else	;ROMDOS
;
;;***	Move_res_code - ROMDOS version - locate ROM resident
;
;Move_res_code	proc
;
;	push	es
;
;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
;	call	patch_stub
;
;	pop	es
;	ret
;
;Move_res_code	endp
;
;	assume	ds:NOTHING		; to match ending assume above
;
;endif	;ROMDOS

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h

	; MSDOS 6.0
;*** Alloc_env -- This routine allocates the temporary environment for the
; Init code to initialize the COMSPEC. This is not a complete environment. 
; Later on, at EndInit time, a proper sized environment is allocated and
; the contents of this temporary environment are copied to it. This routine
; will not be called in case a valid environment is passed to command.com
;
;       ENTRY:  FirstCom and initial EnvirSeg set
;
;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
;
;       REGISTERS AFFECTED: ax,bx,cx,dx

alloc_env:	;proc near
	;assume ds:nothing
	
        push    ds
	push	es
	push	si
	push	di

; 29/01/2023 - MSDOS 6.0 COMMAND.COM
%if 0
        push    ss
        pop     ds
	;assume ds:RESGROUP

        mov     ax,[EnvirSeg]

        cmp	byte [AllocedEnv],0
        je	short alloc_cont
        jmp     alloc_done

alloc_cont:
        sub     di,di                           ; default start
        ;mov	bx,SIZE Environment             ; default size needed
	; 29/01/2023
	mov	bx,ENVIRONSIZ

        cmp	byte [FirstCom],0		; first COMMAND.COM?
        je	short alloc_seg			; no

;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
;   Record their respective locations and do not add the default vars.

	or      ax,ax
	jz	short alloc_new			; no previous environment

        mov     es,ax
	;assume es:nothing

_find_path:
        mov     al,0
        sub     di,di
comp_path:
        scasb                                   ; end of env?
	je	short _find_prompt		; yes
        dec     di
        mov     cx,PathStrLen ; mov cx,5 ; "PATH="
        ;mov	si,offset RESGROUP:PathString
	mov	si,PathString	
        repe    cmpsb
        je	short got_path
        mov	cx,256
        repne   scasb                           ; find next NULL
        jmp     short comp_path

got_path:
        mov	byte [PathString],0		; don't add it

_find_prompt:
        sub     di,di
comp_prompt:
	scasb                                   ; end of env?
	je	short find_comspec		; yes
	dec     di
	mov     cx,PrmptStrLen2 ; mov cx,7
	;mov	si,offset RESGROUP:PrmptString
	mov	si,PrmptString
        repe    cmpsb
        je	short got_prompt
        mov     cx,256
        repne   scasb                           ; find next NULL
        jmp	short comp_prompt

got_prompt:
	mov	byte [PrmptString],0		; don't add it

find_comspec:
        sub     di,di
comp_comspec:
        scasb                                   ; end of env?
        je	short got_envend		; yes
        dec     di
        mov	cx,ComspStrLen ; mov cx,8
	;mov	si,offset RESGROUP:ComspString
	mov	si,ComspString
        repe    cmpsb
        je	short got_comspec
        mov     cx,256
        repne   scasb                           ; find next NULL
        jmp	short comp_comspec

got_comspec:
        mov     [ComspOffset],di

find_envend:
        sub     di,di
        mov     cx,ENVBIG                       ; max env size
comp_envend:
        dec     cx                              ;
        scasb                                   ; end of env?
        je	short got_envend		; yes
        repne   scasb
        jmp	short comp_envend

got_envend:
        dec     di
        lea     bx,[di+SIZE Environment]        ; add room for the basics

;   We want to fall through to alloc_new and set up default
;   path and prompt ONLY IF this is the first process;  in all other
;   cases, we assume it is a bad idea to try editing the user's environment

        push    ds
        ;mov	ds,ds:[PDB_Parent_Pid]
        mov	ds,[PDB.PARENT_PID]
	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
	cmp	word [PDB.PARENT_PID],0
	pop     ds
        jne	short alloc_seg			; no, we're not the first process
                                                ; so don't muck with the env.
alloc_new:
	inc	byte [AllocedEnv]		; note we have virgin env.

alloc_seg:

; Allocate default environment size

        mov     cx,bx                           ; save byte-granular size in CX
        add     bx,15
        shr     bx,1
        shr     bx,1
        shr     bx,1
        shr     bx,1                            ; BX = # paras
	mov	ah,ALLOC
	int	21h
        jnc	short init_ok
        jmp     init_nomem                      ; insufficient memory, error

; If a previous environment existed (ie, DI != 0), then copy it into
; the new buffer

init_ok:
	mov	es,ax
	;assume	es:nothing                      ; es = temp env segment

	or      di,di
        jz	short copy_path

        push    cx
        push    ds
        mov     ds,[EnvirSeg]
        ;assume ds:nothing
        sub     si,si
        mov     cx,di
        sub     di,di
        rep     movsb
        pop     ds
        ;assume ds:RESGROUP
        pop     cx
        sub     cx,di

copy_path:

; First clear out (the rest of) the buffer

        push    di
        sub     ax,ax
        rep     stosb
        pop     di

; Initialize the path string (PATH=) first

        ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
	mov	si,PathString
        cmp     byte [si],al			; add it?
        je	short init_prompt		; no
	;mov	cx,PathStrLen+1                 ;
	mov	cx,6 ; db "PATH=",0
        rep     movsb                           ;
        cmp     [AllocedEnv],al			; virgin env?
        je	short init_prompt		; no

; Establish a more reasonable default for the PATH

	;mov	ah,GET_DEFAULT_DRIVE
	mov	ah,19h
	int	21h
        add     al,'A'                          ; convert to letter
        mov     [DefPathString],al              ;
        mov     [DefPath2String],al             ; now our default paths are complete

        mov     dl,0                            ; get dir for default drive
        push    ds                              ;
        push    es                              ;
        pop     ds                              ;
        mov     byte [di],'\'			;
        lea     si,[di+1]                       ; set DS:SI -> available space
	;mov	ah,Current_Dir                  ;
        mov	ah,47h
	int     21h                             ;
        pop     ds                              ;

	;mov	cx,DefPathStrLen+1              ;
	mov	cx,9 ; db "C:\MSDOS",0
	;mov	dx,offset RESGROUP:DefPathString
	mov	dx,DefPathString 
	mov	si,dx                           ;
        ;mov	ah,CHDir                        ;
        mov	ah,3Bh
	int     21h                             ;
        jnc	short init_setpath		; DefPathString exists!

	;mov	cx,DefPath2StrLen+1		;
        mov	cx,7 ; db "C:\DOS",0
	;mov	dx,offset RESGROUP:DefPath2String
	mov	dx,DefPath2String
        mov     si,dx                           ;
        ;mov	ah,CHDir                        ;
        mov	ah,3Bh
        int     21h                             ;
        jc	short init_prompt		; DefPath2String doesn't exist

init_setpath:
        mov     dx,di                           ; success
        push    ds                              ; so restore prev dir
        push    es                              ;
        pop     ds                              ; DS:DX -> prev dir
        ;mov	ah,CHDir                        ;
        mov	ah,3Bh
        int     21h                             ;
        pop     ds                              ;

        dec     di                              ; then copy in DefPathString
        rep     movsb                           ; DS:SI -> "C:\\DOS\0"

; Initialize the default prompt

init_prompt:
        push    di                              ;
        sub     ax,ax                           ;
        mov     cx,64                           ; insure any data read in
        rep     stosb                           ; from Current_Dir is zapped
        pop     di                              ;

	cmp	[AllocedEnv],al			; virgin env?
        je	short init_comspec		; no
        ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
        mov	si,PrmptString
	cmp     [si],al				; add it?
        je      short init_comspec		; no
	;mov	cx,PrmptStrLen+1                ;
        mov	cl,12  ; db "PROMPT=$P$G",0
	rep     movsb                           ;

; Initialize the Comspec string

init_comspec:
        cmp	[ComspOffset],ax		; add it?
        jne	short init_done			; no
        lea     ax,[di+ComspStrLen]             ;
        mov	[ComspOffset],ax		;
        ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
        mov	si,ComspString
	;mov	cx,ComspStrLen2+1               ;
        mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
	rep     movsb                           ;

init_done:
        mov     ax,es                           ; return env seg in ax
        mov     [EnvirSeg],ax			; save env seg
        inc	byte [AllocedEnv]		; remember that *we* alloced it
%endif

; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
%if 1
	;mov	bx,10
	mov	bx,ENVIRONSIZ>>4 ; 160/16
	mov	ah,48h
	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	jc	short init_nomem

init_ok:
	mov	es,ax
	;assume	es:nothing                      ; es = temp env segment

	xor	di,di
	mov	ax,di
	;mov	cx,160	
        mov     cx,ENVIRONSIZ
        rep	stosb

init_pathstr:

; Initialize the path string (PATH=) first

	push	ss
	pop	ds

        ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
	mov	si,PathString
	mov	di,0
init_cp_pathstr:
	lodsb
	stosb
	or	al,al
	jnz	short init_cp_pathstr

; Initialize the Comspec string

init_comspec:
        ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
        mov	si,ComspString
	; 05/05/2023
	mov	di,6
init_cp_compstr:
	lodsb
	stosb
	or	al,al
	jnz	short init_cp_compstr

init_done:
        mov     ax,es                           ; return env seg in ax
        ;mov	[EnvirSeg],ax			; save env seg
        ;inc	byte [AllocedEnv]		; remember that *we* alloced it
%endif	

	; 29/01/2023
alloc_done:
	pop	di
	pop	si
	pop	es
        pop     ds
	;assume	ds:nothing
	retn

	; 29/01/2023
init_nomem:

;We call the error routine from here. This routine never returns. It either
;terminates COMMAND with error( if it is not the first invocation ) or hangs
;the system ( if it is the first COMMAND.COM ).

	call	Alloc_error

;Alloc_env	endp

;*** Alloc_error: This routine just jumps to the actual label where we 
; check if this is a permanent or secondary command.com and take the 
; appropriate action.
;
;	ENTRY:	ds = RESGROUP = DATARES
;
;	EXIT:	None - does not return
;
;	REGISTERS AFFECTED: Does not matter
;

;public Alloc_error
Alloc_error:	;proc	near

	;jmp	RESGROUP:BadMemErr
	; 29/01/2023
	jmp	BadMemErr	
	
;Alloc_error	endp

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh

	; MSDOS 6.0
;*** Patch_stub -- This routine patches in the segment and offset values in
; the stub table of the various entry points in the resident code segment.
; Some of them are interrupt entry points and some of them are entries from
; the transient to the resident code segment.
;
;	ENTRY:	ds = RESGROUP
;		es:di = segment:offset of final location of resident code
;
;	EXIT:	All segments and offsets patched into the stub table
;
;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di

patch_stub:	;proc near
	;assume	ds:RESGROUP
	
	push	es

	mov	bx,es			;bx = resident code segment
	mov	dx,di
	;mov	di,offset DATARES:Int2f_Entry
	mov	di,Int2f_Entry
	;mov	si,offset RESGROUP:Reloc_Table
	mov	si,Reloc_Table
	push	ds
	pop	es			;es = RESGROUP = DATARES

;bx:dx = segment:offset of resident code segment
;es:di = entry point table in stub
;ds:si = offset table in INIT segment -- offsets of code entry points now

	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
patchlp:
	lodsw				;get current offset
	add	ax,dx			;offset it by code seg location 
	stosw				;store offset
	mov	ax,bx			
	stosw				;store segment 
	loop	patchlp

	pop	es
	retn

;Patch_stub	endp

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 6.0
;*** Patch_segs -- This routine patches the segment values in the dword 
; pointers that the stub uses to jump to the actual handler. These values 
; are temporarily needed to handle these interrupts if they occur before
; the resident is relocated to its final position and all the addresses of
; the handlers have been updated.
;
;	ENTRY:	es = PSP segment = code segment
;
;	EXIT:	Current segment values patched into the jump table in the
;		stub.
;
;	REGISTERS AFFECTED: ax, cx, di

patch_segs:	;proc near

	;mov	di,offset RESGROUP:Int2f_Entry
	mov	di,Int2f_Entry 
	mov	cx,4			;we have to patch 4 handlers
	add	di,2
	mov	ax,es
pseglp:
	stosw				;store the segment value
	add	di,2			;skip the next offset value
	loop	pseglp

	retn

;Patch_segs	endp

	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch

	; MSDOS 6.0
;*** get_XMMAddr -- This routine gets the call address for the XMM driver
; by issuing the appropriate int 2fh. This is stored in a stub variable 
; and is used by the stub when we have to jump to the resident in HMA
;
;	ENTRY:	ds = RESGROUP
;
;	EXIT:	XMMCallAddr = XMM driver far call address
;
;	REGISTERS AFFECTED:
;

get_XMMAddr:	;proc near
	;assume	ds:RESGROUP

	push	es

	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
	mov	ax,4300h
	int	2Fh
		; - Multiplex - XMS - INSTALLATION CHECK
		; Return: AL = 80h XMS driver installed
		; AL <> 80h no driver
	cmp	al,80h			; Q: installed
	jne	short cXMMexit		; N: set error, quit
;
; get the XMM control functions entry point, save it, we
; need to call it later.
;
	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
	mov	ax,4310h
	int	2Fh
		; - Multiplex - XMS - GET DRIVER ADDRESS
		; Return: ES:BX -> driver entry point

	mov	[XMMCallAddr], bx
	mov	[XMMCallAddr+2],es
cXMMexit:
	pop	es
	retn				; done

;get_XMMAddr	endp

;=============================================================================
; UNINIT.ASM, MSDOS 6.0, 1991
;=============================================================================
; 24/09/2018 - Retro DOS v3.0

; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)

; TITLE	COMMAND Initialization messages

;INIT	SEGMENT PUBLIC PARA

; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; 25/09/2018
	; (15 bytes filler)
	db 0
	;db "25/9/2018 ETAN"
	; 14/06/2023
	db "14/6/2023 ETAN"	
	db 0

; 30/01/2023
%if 0
	; MSDOS 3.3 COMMAND.COM - offset 145Eh
	;dw 0
COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
	db 0Dh,0Ah
	db 0Dh,0Ah
	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
	db 0Dh,0Ah
	db '             (C)Copyright Microsoft Corp 1981-1987               '
	db ' ',0Dh,0Ah
	db '                                                   ',
	db 0Dh,0Ah,0

	times 43 db 20h

_152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
BADCOMLKMES:
	dw _152Fh

_155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
BADCOMACCMSG:
	dw _155Ah

_1593h:	db 'Access denied',0Dh,0Ah,0
ACCDENERR:
	dw _1593h

_15A5h:	db 'Out of environment space',0Dh,0Ah,0
OUTENVMSG:
	dw _15A5h

BADVERMSG:
	db 'Incorrect DOS version',0Dh,0Ah,'$'

BADENVSIZMSG:
	db 'Invalid environment size specified',0Dh,0Ah,'$'

HEADERPTR:
	dw COPYRIGHTMSG
%endif

; 30/01/2023
;align 16
	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
ICONDEV:
        db '/DEV/'
	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
BADCSPFL:
	db 0
COMSPECT:
	db '\COMMAND.COM',0
	db 0
AUTOBAT:
	db 0,':\AUTOEXEC.BAT',0,0Dh
;KAUTOBAT:
	;db 0,':\KAUTOEXEC.BAT',0,0Dh 
PRDATTM:
	db -1 ; 0FFh		; Init not to prompt for date time
INITADD:
	dd 0
print_add:
	dw Printf_Init
	dw 0
triage_add:
	dw Triage_Init
	dw 0
;CHUCKENV:
AllocedEnv:
	db 0

; 30/01/2023 - MSDOS 3.3
;COMSPOFFSET:
;ECOMLOC:
;	;dw 0Eh
;	;dw offset ENVIRONMENT:ECOMSPEC-10h
;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
;COMSPSTRING:
;	db 'COMSPEC='

; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
PathString:
	db 'PATH=',0
PathStrLen equ $-PathString-1
; MSDOS 6.0
;DefPathString:
;	db 'C:\MSDOS',0
;DefPathStrLen equ  $-DefPathString-1
;DefPath2String:
;	db 'C:\DOS',0
;DefPath2StrLen equ $-DefPath2String-1
;
;PrmptString:
;	db 'PROMPT=$P$G',0
;PrmptStrLen equ $-PrmptString-1
;PrmptStrLen2 equ 7		; length of PROMPT=
;ComspOffset:
;	dw 0
ComspString:
	db 'COMSPEC=\COMMAND.COM',0
ComspStrLen equ 8		; length of COMSPEC=
ComspStrLen2 equ $-ComspString-1
				; length of full COMSPEC
	; 29/01/2023
;equal_sign:
;equalsign:
;	db '='
;letter_a:
;lcasea:
;	db 'a'
;letter_z:
;lcasez:
;	db 'z'
	; 30/01/2023
;;slash_chr:
;;	db '/'
;;bslash_chr:
;;	db '\'
;space_chr:
;;space:
;	db 20h
;;letter_p:
;;	db 'p'
;;letter_d:
;;	db 'd'
;;letter_c:
;;	db 'c'
	; 16/04/2023
; MSDOS 5.0 & MSDOS 6.0
;scswitch:
;	db 'C'		; Single command
;;skswitch:
;	db 'K' ; MSDOS 6.0
;;letter_A:
;ucasea: ; 21/01/2023 
;	db 'A'

	; 30/01/2023
EnvSiz:
	dw 0		; size user wants to allocate
EnvMax:
	dw 0		; maximum size allowed
OldEnv:
	dw 0		; envirseg at initialization
UsedEnv:
	dw 0		; amount of envirseg used
	; MSDOS 5.0 & MSDOS 6.0
PARS_MSG_OFF:
	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
PARS_MSG_SEG:
	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT

;Do not separate the following two words. Used to call transient PARSE routine

Init_Parse:
	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
init_p:
	dw append_parse
initend:
	dw 0		; segment address of end of init
TrnSize:
	dw 0		; size of transient in paragraphs
resetenv:
	dw 0		; set if we need to setblck env at endinit

ext_msg:
	db 0		; set if /MSG switch entered
eswitch:
	db 0		; set if /e was entered
dswitch:
	db 0		; set if /d was entered
parsemes_ptr:
	dw 0		; word to store parse error number

	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h 

	; MSDOS 6.0 (UINIT.ASM, 1991)
;  The following parse control block is used for COMMAND. This block is
;  used for parsing during initialization. The syntax for COMMAND is:
;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
;
;  Anything on the command line after the /C switch will be passed to the
;  executable command, so if /C is used, it must be specified last. The
;  /MSG switch can only be specified if the /P switch is specified.
;
;  The /? switch causes help text to be displayed. Any other options
;  on the command line are ignored. Command.com will not load if /?
;  is specified.

INTERNAT_INFO:		; used for country info after parsing is completed
PARSE_COMMAND:
	dw COMMAND_PARMS
	db 0			; no extra delimiter
COMMAND_PARMS:
	db 0,2			; 1 positional parm
	dw COMMAND_FILE
	dw COMMAND_FILE
        ; MSDOS 5.0
	db 7			; 7 switches
	; MSDOS 6.0
	;db 8 			; 8 switches
	dw COMMAND_SWITCH1
	dw COMMAND_SWITCH2
	dw COMMAND_SWITCH3
	dw COMMAND_SWITCH4
	dw COMMAND_SWITCH5
	dw COMMAND_SWITCH6
	dw COMMAND_SWITCH7
	;dw COMMAND_SWITCH8 ; MSDOS 6.0
	db 0			; no keywords

COMMAND_FILE:
	dw 0201h		; filespec - optional
	dw 1			; capitalize - file table
	dw COMND1_OUTPUT	; result buffer
	dw NO_VAL 		;
	db 0			; no keywords

COMMAND_SWITCH1:
	dw 0			; no match flags
	dw 2			; capitalize by char table
	dw COMND1_OUTPUT	; result buffer
	dw NO_VAL 		;
	db 1			; 1 keyword
COMMAND_P_SYN:
	db '/P',0		; /P switch

COMMAND_SWITCH2:
	dw 0			; no match flags
	dw 2			; capitalize by char table
	dw COMND1_OUTPUT	; result buffer
	dw NO_VAL 		;
	db 1			; 1 keyword
COMMAND_F_SYN:
	db '/F',0		; /F switch

COMMAND_SWITCH3:
	dw 0			; no match flags
	dw 2			; capitalize by char table
	dw COMND1_OUTPUT	; result buffer
	dw NO_VAL 		;
	db 1			; 1 keyword
COMMAND_D_SYN:
	db '/D',0		; /D switch

COMMAND_SWITCH4:
	dw 8000h		; numeric value - required
	dw 0			; no function flags
	dw COMND1_OUTPUT	; result buffer
	dw COMMAND_E_VAL	; pointer to value list
	db 1			; 1 keyword
COMMAND_E_SYN:
	db '/E',0		; /E switch

COMMAND_E_VAL:
	db 1			;
	db 1			; 1 range
	db 1			; returned if result
	;dd ENVSML,ENVBIG	; minimum & maximum value
	; MSDOS 5.0 COMMAND.COM
	; (RESGROUP:1F2Bh)
	dd 160	 ; ENVSML
	dd 32768 ; ENVBIG
	db 0			; no numeric values
	db 0			; no string values

COMMAND_SWITCH5:
	dw 0			; no match flags
	dw 2			; capitalize by char table
	dw COMND1_OUTPUT	; result buffer
	dw NO_VAL 		;
	db 1			; 1 keyword
COMMAND_C_SYN:
	db '/C',0		; /C switch

COMMAND_SWITCH6:
	dw 0			; no match flags
	dw 2			; capitalize by char table
	dw COMND1_OUTPUT	; result buffer
	dw NO_VAL 		;
	db 1			; 1 keyword
COMMAND_M_SYN:
	db '/MSG',0		; /MSG switch

COMMAND_SWITCH7:
	dw 0			; no match flags
	dw 2			; capitalize by char table
	dw COMND1_OUTPUT	; result buffer
	dw NO_VAL 		;
	db 1			; 1 keyword
COMMAND_?_SYN:
	db '/?',0 		; /? switch

	; MSDOS 6.0
;COMMAND_SWITCH8:
;	dw 0			; no match flags
;	dw 2			; capitalize by char table
;	dw COMND1_OUTPUT	; result buffer
;	dw NO_VAL 		;
;	db 1			; 1 keyword
;COMMAND_K_SYN:
;	db '/K',0		; /K switch

COMND1_OUTPUT:
COMND1_TYPE:
	db 0			; type
COMND1_CODE:
	db 0			; return value
COMND1_SYN:
	dw 0			; synonym pointer
COMND1_ADDR:
	dd 0			; numeric value / address
					; of string value
NO_VAL:
	db 0			; no values
num_positionals:
	dw 0			; counter for positionals
old_parse_ptr:
	dw 0			; SI position before calling parser

	; 30/01/2023
;***	INITIALIZATION MESSAGES
;	-------------------------
;	include	comimsg.inc	;M00
;-----------------------------------------------------------------------------	

BADVERMSG:
	db 23
	db 'Incorrect DOS version',0Dh,0Ah
OUTENVMSG:
	db 26
	db 'Out of environment space',0Dh,0Ah
COPYRIGHTMSG:
	db 94
	db 0Dh,0Ah
	db 0Dh,0Ah
	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
BADCOMLKMES:
	db 40
	db 'Specified COMMAND search directory bad',0Dh,0Ah
BADCOMACCMSG:
	db 54
	db 'Specified COMMAND search directory bad '
	db 'access denied',0Dh,0Ah
HELPMSG1:
	db 60
	db 'Starts a new instance of the MS-DOS command interpreter.',0Dh,0Ah
	db 0Dh,0Ah
HELPMSG2:
	db 70
	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
	db 0Dh,0Ah
	db 0Dh,0Ah
HELPMSG3:
        db 72
	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
	db 'file.',0Dh,0Ah
HELPMSG4:
	db 77
	db '  device          Specifies the device to use for command input and '
	db 'output.',0Dh,0Ah
HELPMSG5:
	db 69
	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
	db 0Dh,0Ah
HELPMSG6:
	db 77
	db '  /P              Makes the new command interpreter permanent '
	db '(can',27h,'t exit).',0Dh,0Ah
HELPMSG7:
	db 80
	db '  /C string       Carries out the command specified by string, and '
	db 'then stops.',0Dh,0Ah
HELPMSG8:
	db 78
	db '  /MSG            Specifies that all error messages be stored in '
	db 'memory. You',0Dh,0Ah
HELPMSG9:
	db 56
	db '                  need to specify /P with this switch.',0Dh,0Ah
HelpMsgs:
        dw HELPMSG1
	dw HELPMSG2
	dw HELPMSG3
	dw HELPMSG4
	dw HELPMSG5
	dw HELPMSG6
	dw HELPMSG7
	dw HELPMSG8
	dw HELPMSG9

	; 23/04/2023
	dw 0

;-----------------------------------------------------------------------------

;SR;
; This table of offsets is used by the init code to calculate the new offsets
;for these labels after the resident code has been relocated

;Reloc_Table:
	;dw offset CODERES:MsgInt2fHandler
	;dw offset CODERES:Int_2e
	;dw offset CODERES:ContC
	;dw offset CODERES:DskErr
	;dw offset CODERES:Exec_Ret
	;dw offset CODERES:TRemCheck
	;dw offset CODERES:TrnLodCom1
	;dw offset CODERES:LodCom
	;dw offset CODERES:MsgRetriever
	;dw offset CODERES:THeadFix
	;dw offset CODERES:Lh_OffUnlink	; M003

	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h

Reloc_Table:			          ; MSDOS 5.0 CODERES address
	dw MsgInt2fHandler - RCODE_START  ; 738h
	dw Int_2e - RCODE_START		  ; 177h	
	dw ContC - RCODE_START		  ; 035h
	dw DSKERR - RCODE_START		  ; 445h
	dw Exec_Ret - RCODE_START	  ; 029h
	dw TRemCheck - RCODE_START	  ; 2A3h
	dw TrnLodCom1 - RCODE_START	  ; 422h
	dw LodCom - RCODE_START		  ; 1AEh
	dw MsgRetriever - RCODE_START	  ; 77Bh
	dw THeadFix - RCODE_START	  ; 2C2h
	dw Lh_OffUnlink - RCODE_START	  ; 7F4h

NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2

ResJmpTable:
	dd 0			; stores prev stub jump table addr
FirstCom:
	db 0			; flag set if first command.com
DevFlag:
	db 0
PathFlag:
	db 0

	; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
	;times 13 db 0

; 30/01/2023
coderes_end equ $

;INIT	ENDS

;	END

;-----------------------------------------------------------------------------
; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
;-----------------------------------------------------------------------------

;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
	; 30/01/2023
db	0
db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"		
db	0

;-----------------------------------------------------------------------------
; 24/09/2018 (Retro DOS v3.0 COMMAND)
;-----------------------------------------------------------------------------

;TAIL    SEGMENT PUBLIC PARA
;        ORG     0
;TRANSTART LABEL WORD
;TAIL    ENDS

;ALIGN 16  ; 25/09/2018

; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

numbertodiv equ ($-StartCode)+100h ; 16/04/2023
numbertomod equ (numbertodiv % 16)

%if numbertomod>0 & numbertomod<16
	times (16-numbertomod) db 0
%endif

; 30/01/2023
;TRANSTART:

; 21/04/2018 (Retro DOS v2.0 COMMAND)
;	times	128 db 0	

;-----------------------------------------------------------------------------
; SEGMENT - TRANSCODE
;-----------------------------------------------------------------------------

;TRANGROUP: ; 21/04/2018

; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
;-----------------------------------------------------------------------------

; MSDOS 3.3 COMMAND.COM Transient Portion Addresses

; 21/04/2018 - Retro DOS v2.0
; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
; (these values must be changed when transcom.s source code is changed
; and data offsets are changed)
;
; 30/04/2018
; 29/04/2018

; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
;COMMAND      EQU  012CH
;DATINIT      EQU  2091H
;HEADCALL     EQU  428FH
;TRANSPACEEND EQU  4D5CH
;TRANDATAEND  EQU  3F44H

; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
;TRIAGE_INIT  EQU  1F15H
;PRINTF_INIT  EQU  34E0H 

;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	

;TPA	EQU  4293H
;TRNLEN	EQU  04D6H

; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
;COMMAND      EQU  012CH
;DATINIT      EQU  206FH
;HEADCALL     EQU  426FH
; 09/01/2023
;TRANSPACEEND EQU  4D3CH
;TRANDATAEND  EQU  3F24H
;TRIAGE_INIT  EQU  1EF3H
;PRINTF_INIT  EQU  34BFH 
;
;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr

;-----------------------------------------------------------------------------
; ARENA.INC, MSDOS 6.0, 1991
;-----------------------------------------------------------------------------
; 13/10/2018 - Retro DOS 3.0
; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;BREAK <Memory arena structure>

; (-*-) Same with MSDOS 2.11 & MSDOS 6.0

; arena item

struc ARENA
  .signature:	resb 1		; 4D for valid item, 5A for last item
  .owner:	resw 1		; owner of arena item
  .size:	resw 1		; size in paragraphs of item
endstruc

;-----------------------------------------------------------------------------
;START OF TRANSIENT PORTION
;This code is loaded at the end of memory and may be overwritten by
;memory-intensive user programs.
;-----------------------------------------------------------------------------

; 16/04/2023
TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
; 29/09/2018
; 31/01/2023 
;TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
			; 09/01/2023
			; Offset 2320h in original MSDOS 5.0 COMMAND.COM

; 25/09/2018
; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
;
; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
;
;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
;
;
;COMTRANS:
;
; 20/10/2018 - Retro DOS v3.0	
;INCBIN	"TRANCOM3.BIN"
;
;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
;
; 29/04/2018
;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
;
;TIMES BSS_SIZE db 0
;
;COMLEN	EQU $-COMTRANS ; 30/04/2018

;COMMANDCOMSIZE equ $ - 100h

; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; ============================================================================
; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
; ============================================================================

; ----------------------------------------------------------------------------
; START OF TRANSIENT PORTION
; ----------------------------------------------------------------------------
; SEGMENT - TRANSCODE
; ----------------------------------------------------------------------------

; 18/04/2023
section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 

; 18/04/2023
;-----------------------------------------------------------------------------
; TRANSCODE segment offset 0
TRANSIENTSTART:

	; 31/01/2023
	times 256 db 0		; Allow for 100H parameter area

;============================================================================
; TCODE.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/10/2018 - Retro DOS v3.0
; 31/01/2023 - Retro DOS v4.0 (& v4.1)

;[ORG 100h]

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h

; ---------------------------------------------------------------------------
		
		; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
		; (TRANGROUP:0100h)
SETDRV:
	mov	ah,0Eh
	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
	int	21h	; DOS -	SELECT DISK
			; DL = new default drive number
			;		(0 = A, 1 = B, ..)
			; Return: AL = number of logical drives

; ---------------------------------------------------------------------------

; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
; No registers (CS:IP) no flags, nothing.

TCOMMAND:
	mov	ds,[cs:RESSEG]
	mov	ax,-1
	xchg	ax,[VerVal]
	cmp	ax,-1
	je	short NOSETVER2
	mov	ah,2Eh
	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
	int	21h	; DOS -	SET VERIFY FLAG
			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
NOSETVER2:
	call	far [cs:HEADCALL]   ; Make sure header fixed
	xor	bp,bp		    ; Flag transient not read
	cmp	word [SingleCom],-1
	jne	short COMMAND
_$EXITPREP:
	push	cs
	pop	ds
	jmp	_$EXIT		; Have finished the single command

; ---------------------------------------------------------------------------
;
; Main entry point from resident portion.
;
;   If BP <> 0, then we have just loaded transient portion otherwise we are
;   just beginning the processing of another command.
;
; ---------------------------------------------------------------------------

; We are not always sure of the state of the world at this time. We presume
; worst case and initialize the relevant registers: segments and stack.

COMMAND:
	cld
	mov	ax,cs
	cli
	mov	ss,ax
	;mov	sp,offset TRANGROUP:STACK
				; 07/06/2023
	mov	sp,STACK	; 09854h for MSDOS 5.0 COMMAND.COM
				; 0AF24h for MSDOS 6.22 COMMAND.COM
	sti
		
	mov	es,ax
		
	; MSDOS 6.0
	mov	ds,ax		;AN000; set DS to transient
	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
	;invoke	TSYSLOADMSG	;AN000; preload messages
	; 31/01/2023
	call	TSYSLOADMSG
	mov	byte [append_exec],0 ;AN041; set internal append state off

	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	ds,[ss:RESSEG]
	; 31/01/2023
	mov	ds,[RESSEG]
	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)

; If we have just loaded the transient, then we do NOT need to initialize the
; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
; I guess not: the only circumstances in which we reload the command processor
; is after a transient program execution. In this case, we let the current
; directory lie where it may.

	or	bp,bp		; See if just read
	jz	short TESTRDIR	; Not read, check user directory
	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
	jmp	short NOSETBUF
TESTRDIR:
	cmp	byte [RestDir],0
	jz	short NOSETBUF	; User directory OK
	push	ds

; We have an unusual situation to handle. The user *may* have changed his
; directory as a result of an internal command that got aborted. Restoring it
; twice may not help us: the problem may never go away. We just attempt it
; once and give up.

	mov	byte [RestDir],0 ; Flag users dirs OK

	; Restore users directory
	push	cs
	pop	ds
	mov	dx,USERDIR1
	mov	ah,3Bh
	;mov	ah,CHDir ; 3Bh
	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
			; DS:DX	-> ASCIZ directory name	(may include drive)
	pop	ds
NOSETBUF:
	cmp	byte [PipeFiles],0
	jz	short NOPCLOSE	; Don't bother if they don't exist
	cmp	byte [PipeFlag],0
	jnz	short NOPCLOSE	; Don't del if still piping
	call	PIPEDEL
NOPCLOSE:
	;mov	byte [0BE9h],0	; MSDOS 3.3
	; 31/01/2023
	mov	byte [ExtCom],0 ; Flag internal command
	mov	ax,cs		; Get segment we're in
	mov	ds,ax
	push	ax
			; 07/06/2023 (INTERNATVARS addr = STACK addr)
	mov	dx,INTERNATVARS ; 09854h for MSDOS 5.0 COMMAND.COM
				; 0AF24h for MSDOS 6.22 COMMAND.COM
	mov	ax,3800h
	;mov	ax,INTERNATIONAL*256 ; 3800h
	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
			; get current-country info
			; DS:DX	-> buffer for returned info
	pop	ax
	sub	ax,[TPA]	; AX=size of TPA in paragraphs
	push	bx
	mov	bx,16
	mul	bx		; DX:AX=size of TPA in bytes
	pop	bx
	or	dx,dx		; See if over 64K
	jz	short SAVSIZ	; OK if not
	mov	ax,-1		; If so, limit to 65535 bytes
SAVSIZ:

; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1. We round this down to a multiple of 512.

	cmp	ax,512
	jbe	short GOTSIZE
	;and	ax,~1FFh
	and	ax,0FE00h	; NOT 511 = NOT 1FF
GOTSIZE:
	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
	mov	ds,[RESSEG]	; All batch work must use resident seg.

	test	byte [EchoFlag],1 
	jz	short GETCOM	; Don't do the CRLF
	call	SINGLETEST
	jb	short GETCOM
	test	byte [PipeFlag],0FFh ; -1
	jnz	short GETCOM
				; G  Don't print prompt in FOR
	test	byte [ForFlag],0FFh ; -1
	jnz	short GETCOM
				; G  Don't print prompt if in batch
	test	word [Batch],0FFFFh ; -1
	jnz	short GETCOM
	call	CRLF2
GETCOM:
	mov	byte [Call_Flag],0 ; G Reset call flags
	mov	byte [Call_Batch_Flag],0
	mov	ah,19h
	;mov	ah,GET_DEFAULT_DRIVE ; 19h
	int	21h	; DOS -	GET DEFAULT DISK NUMBER
	mov	[ss:CURDRV],al
	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
	jz	short NOPIPE
	jmp	PIPEPROC	; Continue the pipeline
NOPIPE:
	test	byte [EchoFlag],1
	jz	short NOPDRV	; No prompt if echo off
	call	SINGLETEST
	jb	short NOPDRV
	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
	jnz	short NOPDRV
	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
	jnz	short TESTFORBAT
	call	PRINT_PROMPT	; Prompt the user
NOPDRV:
	test	byte [ForFlag],0FFh ; FOR has next highest precedence
	jz	short TESTFORBAT
	jmp	FORPROC		; Continue the FOR

TESTFORBAT:
	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
	mov	byte [IfFlag],0	; no more ifs...
	test	word [Batch],0FFFFh ; Batch has lowest precedence
	jz	short ISNOBAT

	; 31/01/2023

	; MSDOS 6.0

;	Bugbug:	MULT_SHELL_GET no longer used?

	push	es			;AN000; save ES
	push	ds			;AN000; save DS
	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
	; 05/02/2023
	mov	ax,1902h
	mov	es,[Batch]		;AN000; get batch segment
	;mov	di,20h
	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
	push	cs			;AN000; get local segment to DS
	pop	ds			;AN000;
	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
	mov	dx,COMBUF
	int	2Fh			;AN000; call the shell
		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
		; ES:DI -> ASCIZ full filename of current batch file, with at least the
		; final filename element uppercased
		; DS:DX -> buffer for results
	;cmp	al,0FFh
	cmp	al,shell_action 	;AN000; does shell have a commmand?
	pop	ds			;AN000; restore DS
	pop	es			;AN000; restore ES
	jz	short JDOCOM1		;AN000; yes - go process command

	; MSDOS 3.3 (& MSDOS 6.0)
	push	ds
	call	READBAT			; Continue BATCH
	pop	ds
	mov	byte [NullFlag],0	;G reset no command flag
	test	word [Batch],0FFFFh
	jnz	short JDOCOM1		;G if batch still in progress continue
	mov	bx,[Next_Batch]
	; 31/01/2023
	or	bx,bx
	;cmp	bx,0			;G see if there is a new batch file
	jz	short JDOCOM1		;G no - go do command
	mov	[Batch],bx		;G get segment of next batch file
	mov	word [Next_Batch],0	;G reset next batch
JDOCOM1:
	push	cs
	pop	ds
	jmp	short DOCOM1
ISNOBAT:
	cmp	word [SingleCom],0
	jz	short REGCOM
	;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
	mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
	xchg	si,[SingleCom]
	mov	di,COMBUF+2
	xor	cx,cx
SINGLELOOP:
	lodsb
	stosb
	inc	cx
	cmp	al,0Dh
	jnz	short SINGLELOOP
	dec	cx
	push	cs
	pop	ds
	mov	[COMBUF+1],cl

; do NOT issue a trailing CRLF...

	jmp	short DOCOM1

	;nop

	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h

; We have a normal command.  
; Printers are a bizarre quantity. Sometimes they are a stream and
; sometimes they aren't. At this point, we automatically close all spool
; files and turn on truncation mode.

REGCOM:
	;mov	ax,(ServerCall shl 8) + 9
	; 31/01/2023
	mov	ax,5D09h
	;mov	ax,(SERVERCALL<<8)+9
	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
	;mov	ax,(ServerCall shl 8) + 8
	mov	ax,5D08h
	;mov	ax,(SERVERCALL<<8)+8
	mov	dl,1
	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
			; DL = 00h redirected output is	combined
			;      01h redirected output placed in separate	jobs
			; start	new print job now
	push	cs
	pop	ds	; Need local segment to point to buffer
	mov	dx,UCOMBUF

	; MSDOS 6.0
;	Try to read interactive command line via DOSKey.
;	If that fails, use DOS Buffered Keyboard Input.

	; 31/01/2023
	mov	ax,4810h	; AX = DOSKey Read Line function
	int	2Fh
	or	ax,ax
	jz	short GOTCOM	; DOSKey gave us a command line

	mov	ah,0Ah
	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
			; DS:DX	-> buffer
GOTCOM:
	mov	cl,[UCOMBUF]
	xor	ch,ch
	add	cx,3
	mov	si,UCOMBUF
	mov	di,COMBUF
	rep	movsb		; Transfer it to the cooked buffer
DOCOM:
	call	CRLF2
DOCOM1:
	call	PRESCAN		; Cook the input buffer
	jz	short NOPIPEPROC
	jmp	PIPEPROCSTRT	; Fire up the pipe

NULLCOMJ:
	jmp	NULLCOM

NOPIPEPROC:
	call	PARSELINE
	jnb	short OKPARSE	; user error? or maybe we goofed?
BADPARSE:
	push	cs
	pop	ds
	mov	dx,BADNAM_PTR	; 31/01/2023
	call	std_eprintf
	jmp	TCOMMAND

OKPARSE:
	;test	byte [ARGV0_ARG_FLAGS],2
	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
	; 01/02/2023
	test	byte [ARG+ARGV_ELE.argflags],2
	jnz	short BADPARSE	; ambiguous commands not allowed
	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
	cmp	word [ARG+ARG_UNIT.argvcnt],0
	jz	short NULLCOMJ
	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
	cmp	word [ARG+ARGV_ELE.arglen],0
	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>

	mov	si,COMBUF+2
	mov	di,IDLEN
	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
				; Make FCB with blank scan-off
	;mov	ax,(Parse_File_Descriptor<<8)|01h
	mov	ax,2901h
	int	21h	; DOS -	PARSE FILENAME
			; DS:SI	-> string to parse
			; ES:DI	-> buffer to fill with unopened	FCB
			; AL = bit mask	to control parsing
	;mov	bx,[ARG_ARGV]
	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
	cmp	byte [bx+1],':'	; was a drive specified?
	jne	short DRVGD	; no, use default of zero...
	mov	dl,[bx]		; pick-up drive letter
	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
	;and	dl,~20h
	and	dl,0DFh		; uppercase the sucker
	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
	; 31/01/2023
	sub	dl,'A'
	cmp	al,-1		; See what PARSE said about our drive letter.
	je	short DRVBADJ	; It was invalid.
	;mov	di,[ARGV0_ARGSTARTEL]
	mov	di,[ARG+ARGV_ELE.argstartel]
	cmp	byte [di],0	; is there actually a command there?
	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
	jmp	SETDRV		; and set drive to new drive spec
DRVBADJ:
	jmp	DRVBAD
DRVGD:
	mov	al,[di]
	mov	[SPECDRV],al
	mov	al,' '
	mov	cx,9
	inc	di
	repne	scasb		; Count number of letters in command name
	mov	al,8
	sub	al,cl
	mov	[IDLEN],al	; IDLEN is truly the length
	mov	di,81h
	push	si
	mov	si,COMBUF+2	; Skip over all leading delims
	call	scanoff

	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h

	; MSDOS 6.0
;SR;
; We are going to skip over the first char always. The logic is that the
;command tail can never start from the first character. The code below is 
;trying to figure out the command tail and copy it to the command line 
;buffer in the PSP. However, if the first character happens to be a switch
;character and the user given command line is a full 128 bytes, we try to
;copy 128 bytes to the PSP while it can take only 127 chars. This extra
;char overwrites the code and leads to a crash on future commands.

	inc	si ;  MSDOS 6.0
DO_SKIPCOM:
	lodsb			; move command line pointer over
	call	DELIM		; pathname -- have to do it ourselves
	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
	cmp	al,0Dh		; can't always depend on argv[0].arglen
	jz	short DO_SKIPPED ; to be the same length as the user-
	cmp	al,[SWITCHAR]	; specified command string
	jnz	short DO_SKIPCOM 
DO_SKIPPED:
	dec	si
	xor	cx,cx
COMTAIL:
	lodsb
	stosb			; Move command tail to 80h
	cmp	al,0Dh
	loopne	COMTAIL
	dec	di
	mov	bp,di
	not	cl
	mov	[80h],cl
	pop	si
;-----
; Some of these comments are sadly at odds with this brave new code.
;-----
; If the command has 0 parameters must check here for
; any switches that might be present.
; SI -> first character after the command.

	;mov	di,arg.argv[0].argsw_word
	;mov	di,[ARGV0_ARGSW_WORD]
	mov	di,[ARG+ARGV_ELE.argsw_word]
	mov	[COMSW],di	; ah yes, the old addressing mode problem...
	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
				; s = argv[1];
	;mov	si,[ARGV1_ARGPOINTER]
	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
	or	si,si		;   if (s == NULL)
	jnz	short DOPARSE	;	s = bp; (buffer end)
	mov	si,bp
DOPARSE:
	mov	di,FCB ; 5Ch
	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
	; 01/02/2023
	mov	ax,2901h
	;mov	ax,(Parse_File_Descriptor<<8)|01h
	int	21h	; DOS -	PARSE FILENAME
			; DS:SI	-> string to parse
			; ES:DI	-> buffer to fill with unopened	FCB
			; AL = bit mask	to control parsing
	mov	[PARM1],al	; Save result of parse
	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
	;mov	di,[ARGV1_ARGSW_WORD]
	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
	mov	[ARG1S],di
	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
				; s = argv[2];
	;mov	si,[ARGV2_ARGPOINTER]
	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
	or	si,si		; if (s == NULL)
	jnz	short DOPARSE2
	mov	si,bp		;     s = bp; (buffer end)
DOPARSE2:			
	mov	di,FCB+10h ; 6Ch
	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
	mov	ax,2901h
	;mov	ax,(Parse_File_Descriptor<<8)|01h
	int	21h	; DOS -	PARSE FILENAME
			; DS:SI	-> string to parse
			; ES:DI	-> buffer to fill with unopened	FCB
			; AL = bit mask	to control parsing
	mov	[PARM2],al	; Save result
	;mov	di,[ARGV2_ARGSW_WORD]
	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
	mov	[ARG2S],di
	;mov	di,[ARGV0_ARGSW_WORD]
	;mov	di,arg.argv[0].argsw_word
	mov	di,[ARG+ARGV_ELE.argsw_word]
	not	di		; ARGTS doesn't include the flags
	;and	di,[ARG_ARGSWINFO] ; from COMSW...
	;and	di,arg.argswinfo	
	and	di,[ARG+ARG_UNIT.argswinfo]
	mov	[ARGTS],di

	mov	al,[IDLEN]
	mov	dl,[SPECDRV]
	or	dl,dl		; if a drive was specified...
	jnz	short EXTERNALJ1 ; it MUST be external, by this time
	dec	al		; (I don't know why -- old code did it)
	jmp	FNDCOM		; otherwise, check internal com table
EXTERNALJ1:
	jmp	EXTERNAL
NULLCOM:
	mov	ds,[RESSEG]
	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
	jz	short NOSETFLAG	  ;G only set flag if in batch
	mov	byte [NullFlag],1 ;G set flag to indicate no command
	;mov	byte [NullFlag],nullcommand ; 1
NOSETFLAG:
	cmp	word [SingleCom],0FFFFh ; -1
	je	short EXITJ
	jmp	GETCOM
EXITJ:
	jmp	_$EXITPREP

;============================================================================
; MSHALO.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/10/2018 - Retro DOS v3.0

; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM

;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
;   there is a header that describes a block of rom program.  This header
;   contains information needed to initialize a module and to provide PCDOS
;   with a set of reserved names for execution.
;
;   This header has the following format:
;
;   rom_header	STRUC
;	Signature1  DB	55h
;	Signature2  DB	AAh
;	rom_length  DB	?		; number of 512 byte pieces
;	init_jmp    DB	3 dup (?)
;	name_list   name_struc <>
;   rom_header	ENDS
;
;   name_struc	STRUC
;	name_len    DB	?
;	name_text   DB	? DUP (?)
;	name_jmp    DB	3 DUP (?)
;   name_struc	ENDS
;
;   The name list is a list of names that are reserved by a particular section
;   of a module.  This list of names is terminated by a null name (length
;   is zero).
;
;   Consider now, the PCDOS action when a user enters a command:
;
;	COMMAND.COM has control.
;	o   If location FFFFEh has FDh then
;	o	Start scanning at C0000h, every 800h for a byte 55h followed
;		    by AAh, stop scan if we get above or = F0000H
;	o	When we've found one, compare the name entered by the user
;		    with the one found in the rom.  If we have a match, then
;		    set up the environment for execution and do a long jump
;		    to the near jump after the found name.
;	o	If no more names in the list, then continue scanning the module
;		    for more 55h followed by AAh.
;	o   We get to this point only if there is no matching name in the
;		rom.  We now look on disk for the command.
;
;   This gives us the flexibility to execute any rom cartridge without having
;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
;   want to be invisible to the DOS should not have any names in their lists
;   (i.e. they have a single null name).
;
;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
;   Clearly this version will be available on disk.  How does a user actually
;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
;   EXEC loader will execute the ROM before it even looks at the disk!	Only
;   solution:
;
;   o	Keep things consistent and force the user to have his software named
;	differently from the ROM names (BASIC1, BASIC2, etc).

struc ROM_HEADER
    .signature1: resb 1
    .signature2: resb 1
    .rom_length: resb 1
    .init_jmp:	 resb 3
    .name_list:	 resb 1
    .size:
endstruc

struc NAME_STRUC
    .name_len:	resb 1
    .name_text:	resb 1
    .name_jmp:	resb 3
    .size:	
endstruc

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h

; =============== S U B	R O U T	I N E =======================================

;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING

; 05/02/2023
; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh

; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name

ROM_SCAN:
	push	es
	push	si
	push	di
	push	cx
	push	ax
	push	bx

	; check for PC Jr signature in rom

	mov	ax,0F000h
	mov	es,ax
	cmp	byte [es:0FFFEh],0FDh
	je	short SCAN_IT
NO_ROM:
	clc
ROM_RET:
	pop	bx
	pop	ax
	pop	cx
	pop	di
	pop	si
	pop	es
	retn

	; start scanning at C000h
SCAN_IT:
	mov	ax,0C000h
SCAN_ONE:
	mov	es,ax
	xor	di,di

	; check for a valid header
SCAN_MODULE:
	cmp	word [es:di],0AA55h
	je	short SCAN_LIST
	add	ax,80h
SCAN_END:
	cmp	ax,0F000h
	jb	short SCAN_ONE
	jmp	short NO_ROM

	; trundle down list of names
SCAN_LIST:
	;mov	bl,[es:di+2]	; number of 512-byte jobbers
	mov	bl,[es:di+ROM_HEADER.rom_length]
	xor	bh,bh		; nothing in the high byte
	shl	bx,1
	shl	bx,1		; number of paragraphs
	add	bx,7Fh
	and	bx,0FF80h	; round to 2k	
	;mov	di,6
	; 05/05/2023
	mov	di,ROM_HEADER.name_list
	;nop
SCAN_NAME:
	mov	cl,[es:di]	; length of name
	inc	di		; point to name
	xor	ch,ch
	or	cx,cx		; zero length name
	jnz	short SCAN_TEST	; nope... compare
	add	ax,bx		; yep, skip to next block
	jmp	short SCAN_END

	; compare a single name
SCAN_TEST:
	mov	si,dx
	inc	si
	repe cmpsb		 ; compare name
	jz	short SCAN_FOUND ; success!
SCAN_NEXT:
	add	di,cx		; failure, next name piece
	add	di,3
	jmp	short SCAN_NAME

	; found a name. save entry location
SCAN_FOUND:	
	cmp	byte [si],'?'
	je	short SCAN_SAVE
	cmp	byte [si],' '
	jne	short SCAN_NEXT
SCAN_SAVE:
	mov	[cs:ROM_CS],es
	mov	[cs:ROM_IP],di
	stc
	jmp	short ROM_RET

; ---------------------------------------------------------------------------

; execute a rom-placed body of code. allocate largest block

ROM_EXEC:
	mov	bx,0FFFFh
	; 05/02/2023
	mov	ah,48h
	;mov	ah,ALLOC ; 48h
	int	21h	; DOS -	2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	mov	ah,48h
	;mov	ah,ALLOC ; 48h
	int	21h	; DOS -	2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	push	bx
	push	ax

	; set terminate addresses

	mov	ax,2522h
	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
	push	ds
	mov	ds,[cs:RESSEG]
	;mov	dx,offset RESGROUP:EXEC_WAIT
	;mov	dx,131h ; MSDOS 3.3
	; 05/02/2023
	;mov	dx,0D6Bh ; MSDOS 5.0
	mov	dx,Exec_Wait
	int	21h	; DOS -	SET INTERRUPT VECTOR
			; AL = interrupt number
			; DS:DX	= new vector to	be used	for specified interrupt
	mov	dx,ds
	mov	es,dx
	pop	ds
		
	; and create program header and dup all jfn's

	pop	dx
	mov	ah,55h
	;mov	ah,DUP_PDB ; 55h
	int	21h	; DOS -	2+ internal - CREATE PSP
			; DX = segment number at which to set up PSP
			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
		
	; set up dma address

	mov	ds,dx
	mov	dx,80h
	mov	ah,1Ah
	;mov	ah,Set_DMA ; 1Ah
	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
			; DS:DX	-> disk	transfer buffer

	; copy in environment info

	mov	ax,[es:EnvirSeg]
	;mov	[2Ch],ax
	mov	[PDB.ENVIRON],ax

	; set up correct size of block

	pop	bx		; BX has size, DS has segment
	mov	dx,ds
	add	dx,bx
	;mov	[2],dx
	mov	[PDB.BLOCK_LEN],dx

	; change ownership of block

	mov	dx,ds
	dec	dx
	mov	ds,dx
	inc	dx	
	;mov	[1],dx
	mov	[ARENA.owner],dx
	mov	ds,dx

	; set up correct stack

	cmp	bx,1000h
	jb	short GOT_STACK
	xor	bx,bx
GOT_STACK:
	mov	cl,4
	shl	bx,cl
	mov	dx,ds
	mov	ss,dx
	mov	sp,bx
	xor	ax,ax
	push	ax

	; set up initial registers and go to the guy

	not	ax
	push	word [cs:ROM_CS]
	push	word [cs:ROM_IP]
	mov	es,dx
	retf	; far return

;============================================================================
; TBATCH.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h

; =============== S U B	R O U T	I N E =======================================

;Break	<PromptBat - Open or wait for batch file>

; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h

; Open the batch file. If we cannot find the batch file. If the media is
; changeable, we prompt for the change. Otherwise, we terminate the batch
; file. Leave segment registers alone.

PROMPTBAT:
	call	BATOPEN
	jc	short PROMPTBAT1
	retn
PROMPTBAT1:
	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 6.0 COMMAND.COM
	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
	je	short BAT_REMCHECK	;AN022;
	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
	call	output_batch_name
	jmp	short BATDIE		;AN022;

	; 05/02/2023
	; MSDOS 3.3 COMMAND.COM
	;cmp	dx,ACCDENPTR
	;jz	short BATDIE

	; MSDOS 3.3 (& MSDOS 6.0)
BAT_REMCHECK:				;AN022; Go see if media is removable
	call	far [cs:RCH_ADDR]	; DX has error number
	jz	short ASKFORBAT		; Media is removable

; The media is not changeable. Turn everything off.

	call	FOROFF
	call	PipeOff
	mov	[IfFlag],al	; No If in progress.	
	mov	dx,BADBAT_PTR
BATDIE:
	call	BATCHOFF
	push	cs
	pop	ds
	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
	; 05/02/2023
	call	std_eprintf	; MSDOS 6.0
	;call	STD_PRINTF	; MSDOS 3.3

; TCOMMAND resets the stack. This is the equivalent of a non-local goto.

	jmp	TCOMMAND

; Ask the user to reinsert the batch file

ASKFORBAT:
	push	ds
	push	cs
	pop	ds

	; MSDOS 6.0
	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
	mov	dx,NEEDBAT_PTR
	;invoke	std_eprintf	 	;Prompt for batch file on stderr
	; 05/02/2023
	call	std_eprintf
	;mov	dx,offset trangroup:pausemes_ptr
	mov	dx,PAUSEMES_PTR
	;invoke std_eprintf		;AN000; get second part of message
	call	std_eprintf
					;AN000; print it to stderr
	; MSDOS 3.3 (& MSDOS 6.0)
	;call	STD_EPRINTF
	call	GETKEYSTROKE
	pop	ds
	jmp	short PROMPTBAT


	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah

	; MSDOS 6.0
;****************************************************************
;*
;* ROUTINE:	Output_batch_name
;*
;* FUNCTION:	Sets up batch name to be printed on extended error
;*
;* INPUT:	DX - extended error number
;*
;* OUTPUT:	Ready to call print routine
;*
;****************************************************************
;
;public	output_batch_name		;AN022;

output_batch_name:	;proc near	;AN022;

	push	ds			;AN022; save resident segment
	mov	ds,[Batch]		;AN022; get batch file segment
	;assume	DS:nothing		;AN022;
	;;mov	SI,BatFile		;AN022; get offset of batch file
	; 05/02/2023
	;mov	si,20h
	; 24/04/2023
	mov	si,BATCHSEGMENT.BatFile
	;invoke	dstrlen 		;AN022; get length of string
	call	dstrlen
	;mov	di,offset Trangroup:bwdbuf
					;AN022; target for batch name
	mov	di,BWDBUF
	rep	movsb			;AN022; move the name

	push	cs			;AN022; get local segment
	pop	ds			;AN022;
	;assume	DS:trangroup		;AN022;
	; 05/02/2023
	mov	[extend_buf_ptr],dx	;AN022; put message number in block
	;mov	byte [msg_disp_class],1
	mov	byte [msg_disp_class],ext_msg_class
					;AN022; set up extended error msg class
	;mov	dx,offset TranGroup:Extend_Buf_ptr
	mov	dx,extend_buf_ptr	
					;AN022; get extended message pointer
	;mov	string_ptr_2,offset trangroup:bwdbuf 
	mov	word [string_ptr_2],BWDBUF	
					;AN022; point to substitution
	;mov	byte [extend_buf_sub],1
	mov	byte [extend_buf_sub],one_subst
					;AN022; set up for one subst
	pop	ds			;AN022; restore data segment
	retn				;AN022; return

;output_batch_name    endp		;AN022;


; =============== S U B	R O U T	I N E =======================================

;Break	<GetKeystroke - get a keystroke and flush queue>

; Read the next keystroke. Since there may be several characters in the queue
; after the one we ask for (function keys/Kanji), we need to flush the queue
; AFTER waiting.

	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h

GETKEYSTROKE:
	; 05/02/2023
	; MSDOS 3.3
	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
	;;mov	ax,0C08h
	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
	;		; AL must be 01h,06h,07h,08h,or 0Ah.
	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
	;;mov	ax,0C00h
	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
	;		; AL must be 01h,06h,07h,08h,or 0Ah.
	;retn

	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 6.0
	push	dx			;AN000;  3/3/KK
	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
					;AN000;  3/3/KK
	mov	ax,6302h
	int	21h			;AN000;  3/3/KK
		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
	
	push	dx			;AN000;  save interim state 3/3/KK
	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
					;AN000;  3/3/KK
	mov	ax,6301h
	mov	dl,1
	;mov	dl,InterimMode		;AN000;  3/3/KK
	int	21h			;AN000;  3/3/KK
		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
		; DL = new mode
		; 00h return only full characters on DOS keyboard input functions
		; 01h return partially-formed characters also
	
	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
	mov	ax,0C08h
	int	21h			; Get character with KB buffer flush
		; DOS - CLEAR KEYBOARD BUFFER
		; AL must be 01h, 06h, 07h, 08h, or 0Ah.

	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
	mov	ax,0C00h
	int	21h
		; DOS - CLEAR KEYBOARD BUFFER
		; AL must be 01h, 06h, 07h, 08h, or 0Ah.

	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
					;AN000;  3/3/KK
	mov	ax,6301h
	pop	dx			;AN000;  restore interim state 3/3/KK
	int	21h			;AN000;  3/3/KK
	pop	dx			;AN000;  3/3/KK
	
	retn

; =============== S U B	R O U T	I N E =======================================

; Break	<ReadBat - read 1 line from batch file>

; ReadBat - read a single line from the batch file. 
; Perform all substitutions as appropriate.

	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h

READBAT:
	;ASSUME	DS:ResGroup,ES:TranGroup
		
	;mov	byte [Suppress],1
				; initialize line suppress status
	mov	byte [Suppress],YES_ECHO 
	test	byte [Batch_Abort],-1 ; 0FFh
	jnz	short TRYING_TO_ABORT
	mov	byte [In_Batch],1 ; set flag to indicate batch job

	; MSDOS 6.0

;M037; Start of changes
; We check here if we have set the flag indicating that the batchfile is at
;EOF. In this case, we do not want to continue with the normal processing.
;We call GetBatByt once more so that the batch segment gets freed up, the
;batch file gets closed etc. and then return as if everything is done.

	; 05/02/2023
	push	ds
	mov	ds,[Batch]
	;cmp	byte [2],0
	cmp	byte [BATCHSEGMENT.BatchEOF],0
				; are we at EOF in batchfile
	pop	ds
	jz	short CONTBAT	; no, continue normal processing
	;invoke	GetBatByt	; frees up batchseg
	call	GETBATBYT
	mov	[es:COMBUF+2],al
				; stuff CR into command buffer
				; as a dummy command
	;;invoke CrLf2		; print a CR-LF
	;call	CRLF2
	;;return		; done batch processing
	;retn
	; 24/04/2023
	jmp	CRLF2

;M037; End of changes
		
	; MSDOS 3.3 (& MSDOS 6.0)
CONTBAT:
	call	PROMPTBAT

TRYING_TO_ABORT:
	mov	di,COMBUF+2

; Save position and try to scan for first non delimiter.

TESTNOP:
	mov	ax,ds
	mov	ds,[Batch]
	push	word [BATCHSEGMENT.BatSeek]
	push	word [BATCHSEGMENT.BatSeek+2]
				; save current location.
	mov	ds,ax
	call	SKIPDELIM	; skip to first non-delim

; If the first non-delimiter is not a : (label), we reseek back to the
; beginning and read the line.

	cmp	al,':'		; is it a label?
	pop	cx
	pop	dx		; restore position in bat file
	jz	short NOPLINE	; yes, resync everything.
	test	word [Batch],-1 ; are we done with the batch file?
	jz	short RDBAT	; no, go read batch file

	;cmp	al,'@'
	cmp	al,No_Echo_Char	; see if user wants to suppress line
	jne	short SET_BAT_POS ; no - go and set batch file position
	;mov	byte [Suppress],0
	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
	jmp	short RDBAT	; go read batch file
	;nop
SET_BAT_POS:
	push	ds
	mov	ds,[Batch]
	;mov	[8],dx
	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
	;mov	[10],cx
	mov	[BATCHSEGMENT.BatSeek+2],cx
	pop	ds
	;;mov	ax,(LSEEK SHL 8) + 0
	; 05/02/2023
	mov	ax,4200h
	;mov	ax,(LSEEK*256) ; 4200h ; ; seek back
	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from beginning of	file
	;mov	word [cs:BATBUFPOS],0FFFFh
	; 24/04/2023
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
	mov	word [es:BATBUFPOS],-1; 0FFFFh
	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
	xor	cx,cx		; Initialize line length to zero
	jmp	short RDBAT

	;nop

; The first non-delimiter is a :. This line is not echoed and is ignored.
; We eat characters until a CR is seen.

NOPLINE:
	call	SKIPTOEOL
	call	GETBATBYT	; eat trailing LF
	;test	word [Batch],0FFFFh
	test	word [Batch],-1 ; are we done with the batch file?
	jnz	short TESTNOP	; no, go get another line
READBAT_RETN:				; Hit EOF			
	retn

; ---------------------------------------------------------------------------

; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
; input, we are to consider two special cases:
;
;   %0 to %9	These represent replaceable parameters from the batch segment
;   %sym%	This is a symbol from the environment

RDBAT:
	call	GETBATBYT
	inc	cx		; Inc the line length

	; 05/02/2023
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
	call	testkanj
	jz	short RDBAT1
	;cmp	cx,127
	cmp	cx,COMBUFLEN-1
	jnb	short TOOLONG
	stosb
	call    GETBATBYT
	inc	cx
	jmp	short SAVBATBYT
RDBAT1:
	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
	jnb	short TOOLONG	   ; Yes - handle it, handle it

; See if we have a parameter character.

	cmp	al,'%'		; Check for parameter
	je	short NEEDPARM

; no parameter character. Store it as usual and see if we are done.

SAVBATBYT:
	stosb			; End of line found?
	cmp	al,0Dh
	jne	short RDBAT	; no, go for more

; We have read in an entire line. 
; Decide whether we should echo the command line or not.

FOUND_EOL:
	sub	di,COMBUF+3
	mov	ax,di		; remember that we've not counted the CR
	mov	[es:COMBUF+1],al
				; Set length of line
	call	GETBATBYT	; Eat linefeed
	call	BATCLOSE
	cmp	byte [Suppress],NO_ECHO ; 0
	jz	short RESET
	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
RESET:
	push	cs
	pop	ds		; Go back to local segment
	jz	short READBAT_RETN ; no echoing here...
TRY_NEXTFLAG:
	cmp	byte [NullFlag],nullcommand ; 1
				;G was there a command last time?
	jz	short NO_CRLF_PRINT
				;G no - don't print crlf
	call	CRLF2		;G Print out prompt
NO_CRLF_PRINT:
	call	PRINT_PROMPT
	push	cs		;G change data segment
	pop	ds
	mov	dx,COMBUF+2	; get command line for echoing
	call	CRPRINT
	;call	CRLF2
	;retn
	; 06/02/2023
	jmp	CRLF2

; The line was too long. Eat remainder of input text up until the CR

TOOLONG:
	cmp	al,0Dh		; Has the end of the line been reached?
	jz	short LTLCONT	; Yes, continue
	call	SKIPTOEOL	; Eat remainder of line	
LTLCONT:
	stosb			; Terminate the command
	jmp	short FOUND_EOL	; Go process the valid part of the line

; We have found a parameter lead-in character. Check for the 0-9 case first

NEEDPARM:
	call	GETBATBYT	; get next character
	cmp	al,'%'		; Check for two consecutive %
	je	short SAVBATBYT	; if so, replace with a single %
	cmp	al,0Dh		; Check for end-of-line
	je	short SAVBATBYT	; yes, treat it normally

; We have found %<something>. If the <something> is in the range 0-9, we
; retrieve the appropriate parameter from the batch segment. Otherwise we
; see if the <something> has a terminating % and then look up the contents
; in the environment.

PAROK:
	sub	al,'0'
	jb	short NEEDENV	; look for parameter in the environment
	cmp	al,9
	ja	short NEEDENV

; We have found %<number>. This is taken from the parameters in the
; allocated batch area.

	cbw
	mov	bx,ax		; move index into AX
	shl	bx,1		; convert word index into byte ptr
	push	es
	mov	es,[Batch]

; The structure of the batch area is:
;
;   BYTE    type of segment
;   DWORD   offset for next line
;   10 WORD pointers to parameters. -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; Get pointer to BX'th argument

	;;mov	si,[es:bx+0Bh]
	; 05/02/2023
	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
	mov	si,[es:bx+BATCHSEGMENT.BatParm]
	pop	es

; Is there a parameter here?

	cmp	si,-1		; Check if parameter exists
	jnz	short YES_THERE_IS ; Yes go get it
	jmp	RDBAT		; Ignore if it doesn't

; Copy in the found parameter from batch segment

YES_THERE_IS:
	push	ds
	mov	ds,[Batch]
	dec	cx		; Don't count '%' in line length
COPYPARM:
	lodsb			; From resident segment
	cmp	al,0Dh		; Check for end of parameter
	je	short ENDPARAM
	inc	cx		; Inc the line length
	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
	jnb	short LINETOOL	; Yes - handle it, handle it
	stosb
	jmp	short COPYPARM

; We have copied up to the limit. Stop copying and eat remainder of batch
; line. We need to make sure that the tooLong code isn't fooled into
; believing that we are at EOL. Clobber AL too.

LINETOOL:
	xor	al,al
	pop	ds
	jmp	short TOOLONG

; We have copied in an entire parameter. Go back for more

ENDPARAM:
	pop	ds
	jmp	RDBAT

; We have found % followed by something other than 0-9. We presume that there
; will be a following % character. In between is an environment variable that
; we will fetch and replace in the batch line with its value.

NEEDENV:
	; MSDOS 6.0 COMMAND.COM
	; 05/02/2023 
	dec     cx 		;AN070; Don't count "%"

	; MSDOS 3.3 (& MSDOS 6.0)
	push	ds
	push	di
				; temp spot for name
	mov	di,ID
	add	al,'0'		; reconvert character
	stosb			; store it in appropriate place

; loop getting characters until the next % is found or until EOL

GETENV1:
	call	GETBATBYT	; get the byte
	stosb			; store it
	cmp	al,0Dh		; EOL?
	jne	short GETENV15	; no, see if it the term char

; The user entered a string with a % but no trailing %. We copy the string.

	mov	byte [es:di-1],0 ; nul terminate the string
	mov	si,ID 		; point to buffer
	pop	di		; point to line buffer
	push	cs
	pop	ds
	call	STRCPY
	; 05/02/2023
	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
	; 24/04/2023
	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
	pop	ds
	jmp	SAVBATBYT
GETENV15:
	cmp	al,'%'		; terminating %?
	jne	short GETENV1	; no, go suck out more characters

; M017 - following DEC is wrong, because we replace the % with a = here.
; This was the source of bug #1.
;	dec	cx		;AN070; Don't count "%"

	mov	al,'='		; terminate  with =
	mov	[es:di-1],al

; ID now either has a =-terminated string which we are to find in the
; environment or a non =-terminated string which will not be found in the
; environment.

GETENV2:
	mov	si,ID
	push	cs
	pop	ds		; DS:SI points to name
	push	cx
	call	find_name_in_environment
	pop	cx
	push	es
	pop	ds
	push	cs
	pop	es
	mov	si,di
	pop	di		; get back pointer to command line

; If the parameter was not found, there is no need to perform any replacement.
; We merely pretend that we've copied the parameter.

	jc	short GETENV6

; ES:DI points to command line being built
; DS:SI points either to nul-terminated environment object AFTER =

	call	STRCPY		; (let RdBat handle overflow)
	; 24/04/2022
	;dec	di 		; MSDOS 3.3 COMMAND.COM
GETENV6:
	pop	ds
	jmp	RDBAT		; go back to batch file

; =============== S U B	R O U T	I N E =======================================

;   SkipToEOL - read from batch file until end of line

	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
SKIPTOEOL:
	test	word [Batch],-1 ; 0FFFFh
	;jnz	short SKIPTOEOL1  	
	;retn			; no batch file in effect
	
	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
SKIPTOEOL1:
	call	GETBATBYT
	cmp	al,0Dh		; eol character?
	jnz	short SKIPTOEOL	; no, go eat another
SKIPTOEOL2:
	retn

; =============== S U B	R O U T	I N E =======================================

;Break	<Allocate and deallocate the transient portion>

; Free Transient. Modify ES,AX,flags

	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
FREE_TPA:
	push	es
	mov	es,[RESSEG]
	mov	es,[es:Res_Tpa]
	mov	ah,49h
	;mov	ah,DEALLOC ; 49h
	int	21h	; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
	pop	es
	retn

; =============== S U B	R O U T	I N E =======================================

; Allocate transient. Modify AX,BX,DX,flags

	; 06/02/2023
ALLOC_TPA:
	push	es
	mov	es,[RESSEG]
	mov	bx,0FFFFh 	; Re-allocate the transient	
	mov	ah,48h
	;mov	ah,ALLOC ; 48h
	int	21h	; DOS -	2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	push	bx	  	; Save size of block
	mov	ah,48h
	;mov	ah,ALLOC ; 48h
	int	21h	; DOS -	2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired

; Attempt to align TPA on 64K boundary

	pop	bx		; Restore size of block
	mov	[es:Res_Tpa],ax
				; Save segment to beginning of block
	mov	[TRAN_TPA],ax

; Is the segment already aligned on a 64K boundary

	mov	dx,ax		; Save segment
	and	ax,0FFFh	; Test if above boundary
	jnz	short CALC_TPA
	mov	ax,dx
	and	ax,0F000h	; Test if multiple of 64K
	jnz	short NOROUND
CALC_TPA:
	mov	ax,dx
	and	ax,0F000h
	add	ax,1000h	; Round up to next 64K boundary
	jc	short NOROUND	; Memory wrap if carry set

; Make sure that new boundary is within allocated range

	mov	dx,[es:Res_Tpa]
	add	dx,bx		; Compute maximum address
	cmp	dx,ax		; Is 64K address out of range?
	jb	short NOROUND

; Make sure that we won't overwrite the transient

	mov	bx,cs		; CS is beginning of transient
	cmp	bx,ax
	jb	short NOROUND

; The area from the 64K boundary to the beginning of the transient must
; be at least 64K.

	sub	bx,ax
	;cmp	bx,4096
	cmp	bx,1000h	; Size greater than 64K?	
	jnb	short ROUNDDONE
NOROUND:
	mov	ax,[es:Res_Tpa]
ROUNDDONE:
	mov	[es:LTpa],ax	; Re-compute everything
	mov	[TPA],ax
	mov	bx,ax
	mov	ax,cs
	sub	ax,bx
	push	bx
	mov	bx,16
	mul	bx
	pop	bx
	or	dx,dx
	jz	short SAVSIZ2
	mov	ax,-1
SAVSIZ2:

; AX is the number of bytes free in the buffer between the resident and the
; transient with a maximum of 64K-1. We round this down to a multiple of 512.

	cmp	ax,512
	jbe	short GOTSIZE2
	;and	ax,~1FFh
	and	ax,0FE00h	; NOT 511 = NOT 1FFh
GOTSIZE2:
	mov	[BYTCNT],ax
	pop	es
	retn

; =============== S U B	R O U T	I N E =======================================

;Break	<BatCom - enter a batch file>

; The exec search has determined that the user has requested a batch file for
; execution. We parse the arguments, create the batch segment, and signal
; batch processing.

	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
BATCOM:	

;ASSUME	DS:TRANGROUP, ES:NOTHING

; Batch parameters are read with ES set to segment of resident part

	; MSDOS 6.0
	mov	es,[RESSEG]
	;ASSUME	ES:RESGROUP
	;cmp	byte [es:Call_Batch_Flag],1
	cmp	byte [es:Call_Batch_Flag],call_in_progress
					;AN043; If in CALL,
	jz	short skip_ioset	;AN043; redirection was already set up
	;invoke	IOSET			; Set up any redirection
	call	IOSET
skip_ioset:				;AN043;
	call	FREE_TPA		; G
	;cmp	byte [es:Call_Batch_Flag],1
	cmp	byte [es:Call_Batch_Flag],call_in_progress
	jz	short GETECHO 		; G if we're in a call, don't execute

	; 12/02/2023
	; MSDOS 3.3
	;call	IOSET
	;mov	es,[RESSEG]
	;call	FREE_TPA
	;;cmp	byte [es:CALL_BATCH_FLAG],1
	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
	;jz	short GETECHO		; G if we're in a call, don't execute

	; MSDOS 3.3 (& MSDOS 6.0)

; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
; being started it MUST be true that no FOR or PIPE is currently in progress.
; Don't execute if in call

	call	FOROFF
GETECHO:
	call	PipeOff
	mov	al,[es:EchoFlag]	; preserve echo state for chaining
	and	al,1			; Save current echo state

	push	ax
	xor	ax,ax
	test	word [es:Batch],-1 	; Are we in a batch file?
	jz	short LEAVEBAT	   	; No, nothing to save
	mov	ax,[es:Batch] 		; Get current batch segment
	;cmp	byte [es:Call_Batch_Flag],1
	cmp	byte [es:Call_Batch_Flag],call_in_progress
	jz	short LEAVEBAT

;  We are in a chained batch file, save batlast from previous batch segment
;  so that if we're in a CALL, we will return to the correct batch file.

	push	es
	mov	es,ax		; Get current batch segment
	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
				; Get previous batch segment
	; 12/02/2023
	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
	mov	ax,[es:BATCHSEGMENT.BatLast]
	pop	es
LEAVEBAT:
	push	ax		; Keep segment until new one created
	;cmp	byte [es:Call_Batch_Flag],1
	cmp	byte [es:Call_Batch_Flag],call_in_progress
	jz	short STARTBAT
	call	BATCHOFF

; Find length of batch file

STARTBAT:
	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
	mov	si,EXECPATH

	; 12/02/2023
	; MSDOS 6.0
	mov	ax,0B711h
	;mov	ax,AppendTruename
				;AN042; Get the real path where the batch file
	int	2Fh		;AN042;    was found with APPEND
	mov	ah,4Eh
	;mov	ah,Find_First	;AN042; The find_first will return it
	mov	dx,si		;AN042; Get the string
	mov	cx,13h
	;mov	cx,search_attr	;AN042; filetypes to search for
	int	21h		;AN042;

	; MSDOS 3.3 (& MSDOS 6.0)
	call	dstrlen
;
; Allocate batch area:
;   BYTE    type of segment
;   WORD    segment of last batch file
;   WORD    segment for FOR command
;   BYTE    FOR flag state on entry to batch file
;   DWORD   offset for next line
;   10 WORD pointers to parameters.  -1 is empty parameter
;   ASCIZ   file name (with . and ..)
;   BYTES   CR-terminated parameters
;   BYTE    0 flag to indicate end of parameters
;
; We allocate the maximum size for the command line and use setblock to shrink
; later when we've squeezed out the extra
;
	mov	bx,cx		; length of file name.
	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
	; 12/02/2023
	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
	; 25/04/2023
	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
					; structure + max len + round up
	push	cx
	mov	cl,4
	shr	bx,cl		; convert to paragraphs
	push	bx		; Save size of batch segment
	mov	ah,48h
	;mov	ah,ALLOC ; 48h ; Allocate batch segment
	int	21h	; DOS -	2+ - ALLOCATE MEMORY
				; BX = number of 16-byte paragraphs desired
	pop	bx		; Get size of batch segment

; This should *NEVER* return an error. The transient is MUCH bigger than
; the batch segment. This may not be true, however, in a multitasking system.
; G This error will occur with nesting of batch files. We also need to
; G make sure that we don't overlay the transient.

	jc	short MEM_ERROR	;G not enough memory - exit

	push	ax		;G save batch segment
	add	ax,bx		;G get end of batch segment
	add	ax,20h		;G add some tpa work area
	mov	bx,cs		;G get the transient segment

	; MSDOS 6.0
; M006; We cant check just for above. If the batchseg goes into a UMB, the
; M006; batchseg is always above the transient. We need to change this code
; M006; to only check for an overlap

	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
	; 12/02/2023
	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
	;mov	dx,TRANSPACEEND		
	;add	dx,15		;round up para; M006
	mov	dx,TRANSPACEEND+15

	shr	dx,cl		;para size of transient; M006
	add	dx,bx		;dx = top of transient; M006

	cmp	ax,bx		; M006
	jb	short ENOUGH_MEM
				; Batchseg below transient
				; enough memory ; M006
	cmp	ax,dx		; M006
	ja	short ENOUGH_MEM	
				; Batchseg above transient
				; enough memory ; M006

; M006; Batchseg overlaps transient -- insufficient memory

	pop	ax		; restore ax; M006

	; 12/02/2023
	; MSDOS 3.3
; M006;	cmp	ax,bx		;G do we end before the transient
; M006;	pop	ax		;G get batch segment back
; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue

	; MSDOS 3.3 (& MSDOS 6.0)
	push	es		;G no we're hitting the transient
	mov	es,ax
	mov	ax,4900h
	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
	int	21h	; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
	pop	es
MEM_ERROR:
	jmp	NO_MEMORY	;G Set up for message and exit

ENOUGH_MEM:
	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 6.0
	pop	ax		; restore ax; M006

	; MSDOS 3.3 (& MSDOS 6.0)
	mov	[es:Batch],ax
	call	ALLOC_TPA

; Initialize batch segment

	pop	dx		; length of name
	pop	ax		;G get saved batch segment back
	inc	word [es:Nest]	;G increment # batch files in progress
	push	es
	mov	es,[es:Batch]
	;mov	byte [ES:0],0
				; signal batch file type
	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
	;;mov	[es:2],ax	; MSDOS 3.3
				;G save segment of last batch file
	;mov	[es:3],ax	; MSDOS 6.0
	mov	[es:BATCHSEGMENT.BatLast],ax
	push	ds
	mov	ds,[RESSEG]	;G set to resident data

	xor	ax,ax
	mov	bl,[ForFlag]	;G get the current FOR state
	;;mov	[es:6],bl	; MSDOS 3.3
				;G save it in the batch segment
	;mov	[es:7],bl	; MSDOS 6.0 	
	mov	[es:BATCHSEGMENT.BatForFlag],bl
	test	bl,-1		;G are we in a FOR?
	jz	short FOR_NOT_ON ;G no, for segment set to 0	
	mov	ax,[ForPtr]	;G yes, get current FOR segment	
	mov	byte [ForFlag],0 ;G reset forflag
FOR_NOT_ON:
	;;mov	[es:4],ax	; MSDOS 3.3
				;G save FOR segment in batch segment
	;mov	[es:5],ax	; MSDOS 6.0		
	mov	[es:BATCHSEGMENT.BatForPtr],ax	
	xor	ax,ax
	mov	[ForPtr],ax	;G make sure for segment is not active
	mov	bl,[EchoFlag]
	pop	ds
	;mov	[es:1],bl 
				 ;G save echo state of parent
	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
;SR;
; Initialize the new BatchEOF flag we have added to 0

	; MSDOS 6.0
	;mov	byte [es:2],0
	mov	byte [es:BATCHSEGMENT.BatchEOF],0

	;mov	[es:08h],ax  ; MSDOS 6.0
	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
	;mov	[es:0Ah],ax  ; MSDOS 6.0	
	mov	[es:BATCHSEGMENT.BatSeek+2],ax

; Initialize pointers

	dec	ax		; put -1 into AX
	;;mov	di,0Bh  ; MSDOS 3.3
				; point to parm area
	;mov	di,0Ch	; MSDOS 6.0
	mov	di,BATCHSEGMENT.BatParm
	mov	bx,di
	mov	cx,10
	rep stosw		; Init to no parms

; Move in batch file name

	mov	cx,dx
	rep	movsb

; Now copy the command line into batch segment, parsing the arguments along
; the way. Segment will look like this:
;
;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
;
; or, in the case of fewer arguments:
;
;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0

	mov	si,COMBUF+2
	;mov	cx,10		; at most 10 arguments
	; 07/06/2023
	mov	cl,10
EACHPARM:
	call	scanoff		; skip to argument

; AL is first non-delimiter. DS:SI points to char = AL

	cmp	al,0Dh		; end of road?
	jz	short HAVPARM	; yes, no more arguments

; If CX = 0 then we have stored the most parm we can. Skip store

	jcxz	MOVPARM		; Only first 10 parms get pointers

; Go into allocated piece and stick in new argument pointer.

	mov	[es:bx],di	; store batch pointer
	add	bx,2		; advance arg counter

; Move the parameter into batch segment

MOVPARM:
	lodsb			; get byte
	call	DELIM		; if delimiter
	jz	short ENDPARM	; then done with parm
	stosb			; store byte
	cmp	al,0Dh		; if CR then not delimiter
	jz	short HAVPARM	; but end of parm list, finish
	jmp	short MOVPARM

; We have copied a parameter up until the first separator.
; Terminate it with CR.

ENDPARM:
	mov	al,0Dh
	stosb
	jcxz	EACHPARM	; if no parameters, don't dec
	dec	cx		; remember that we've seen one.	
	jmp	short EACHPARM

; We have parsed the entire line. Terminate the arg list

HAVPARM:
	xor	al,al		; Nul terminate the parms
	stosb

; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
; into paragraphs and setblock to the appropriate size

	lea	bx,[di+15]
	mov	cl,4
	shr	bx,cl
	mov	ah,4Ah
	;mov	ah,SETBLOCK ; 4Ah
	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
	pop	es
	push	es
	pop	ds		; Simply batch FCB setup
	cmp	word [SingleCom],-1 ; 0FFFFh
	jne	short NOBATSING
	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job

NOBATSING:

; Enter the batch file with the current echo state

	pop	ax		; Get original echo state
	mov	[EchoFlag],al	; restore it
	jmp	TCOMMAND

; The following is executed if there isn't enough memory for batch segment

NO_MEMORY:
	pop	dx		; even up our stack 
	pop	ax
	pop	ax
	call	ALLOC_TPA	; reallocate memory

	; 12/02/2023
	; MSDOS 3.3
	;mov	dx,INSFMEMMESPTR
	;jmp	CERROR

	; MSDOS 6.0
	;mov	byte [msg_disp_class],1
	mov	byte [msg_disp_class],ext_msg_class
				;AN000; set up extended error msg class
	;mov	dx,offset TranGroup:Extend_Buf_ptr
	mov	dx,extend_buf_ptr
	;			;AC000; get extended message pointer
	;mov	word [extend_buf_ptr],8
	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
				;AN000; get message number in control block
	jmp	cerror		;g print error message and go...

; =============== S U B	R O U T	I N E =======================================

	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
BATCHOFF:
	push	ax
	push	es
	push	ds
	push	bx

	mov	es,[cs:RESSEG]
	mov	ds,[cs:RESSEG]
	mov	ax,[Batch]	; Free the batch segment
	or	ax,ax
	jz	short NOTFREE

	push	es
	mov	es,ax
	test	byte [EchoFlag],1
				;G Is echo on?
	jnz	short ECHO_LAST_LINE
				;G Yes - echo last line in file
	;mov	byte [SUPPRESS],0
	mov	byte [Suppress],NO_ECHO
				;G no - don't echo last line in file	
ECHO_LAST_LINE:
	;mov	bl,[es:1]
	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
				; G get echo state
	mov	[EchoFlag],bl
				; G  and restore it
	;;mov	bx,[es:4]  ; MSDOS 3.3
	;mov	bx,[es:5]  ; MSDOS 6.0
	mov	bx,[es:BATCHSEGMENT.BatForPtr]
				;G Get FOR segment
	mov	[ForPtr],bx	;G  and restore it
	;;mov	bl,[es:6]  ; MSDOS 3.3
	;mov	bl,[es:7]  ; MSDOS 6.0	
	mov	bl,[es:BATCHSEGMENT.BatForFlag]
				;G Get FOR flag
	mov	[ForFlag],bl
				;G  and restore it
	;;mov	bx,[es:2] ; MSDOS 3.3
	;mov	bx,[es:3] ; MSDOS 6.0	
	mov	bx,[es:BATCHSEGMENT.BatLast]
				;G  Get old batch segment

	mov	ah,49h
	;mov	ah,DEALLOC ; 49h
	int	21h	; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
	pop	es
	mov	[Next_Batch],bx	;G reset batch segment	
	dec	word [es:Nest]
	xor	ax,ax
	mov	[Batch],ax	; No batch in progress
NOTFREE:
	pop	bx
	pop	ds
	pop	es
	pop	ax
	retn

; =============== S U B	R O U T	I N E =======================================

	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; StrCpy - copy string, checking count in CX against COMBUFLEN
;	Entry : DS:SI ==> source string
;		ES:DI ==> destination string
;		CX = current length of destination string
;	Exit  : string copied, CX updated, Carry set if length limit exceeded

	; 12/02/2023	
	; MSDOS 3.3
;STRCPY:
	;push	ax
;CCYCLE:
	;lodsb
	;stosb
	;or	al,al
	;jnz	short CCYCLE
	;pop	ax
	;retn

;Procedure StrCpy,NEAR

	; 12/02/2023
	; MSDOS 6.0
STRCPY:
	push	ax
ccycle:
	lodsb
	inc	cx
	;cmp	cx,128
	cmp	cx,COMBUFLEN
	;jb	short ccopy
	;stc			; set carry to signal error
	;jmp	short ccend
	; 12/02/2023
	cmc
	jc	short ccend
ccopy:
	stosb
	or	al,al
	jnz	short ccycle
ccend:
	dec	cx		; discount extra byte
	dec	di		; back up pointer
	pop	ax
	retn			; return carry clear

;EndProc StrCpy

;============================================================================
; TBATCH2.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h

; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h

; =============== S U B	R O U T	I N E =======================================

;Break	<GetBatByt - retrieve a byte from the batch file>

; Get one byte from the batch file and return it in AL. End-of-file returns
; <CR> and ends batch mode. DS must be set to resident segment.
; AH, DX destroyed.

GETBATBYT:
	push	bx
	push	cx
	push	ds
	test	byte [Batch_Abort],-1
	;jnz	short BATEOF
	; 14/02/2023
	jz	short getbatbyt1
	jmp	BATEOF
getbatbyt1:
	test	word [Batch],-1
	;jz	short BATEOF
	; 14/02/2023
	jnz	short getbatbyt2
	jmp	BATEOF
getbatbyt2:
	push	es
	mov	es,[Batch]

	; MSDOS 6.0
;M020;
;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
;try to read from the batchfile again.

	;cmp	byte [es:2],0
	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
				;already reached EOF?	;M020
	jz	short not_eof	;no, read batch file	;M020
	jmp	At_EOF		;yes, no more reads	;M020
not_eof:						;M020
	; MSDOS 3.3 (& MSDOS 6.0)
	;add	word [es:8],1	; MSDOS 6.0
	add	word [es:BATCHSEGMENT.BatSeek],1
	;adc	word [es:10],0	; MSDOS 6.0
	adc	word [es:BATCHSEGMENT.BatSeek+2],0
	pop	es

; See if we have bytes buffered...

	mov	ax,cs
	mov	ds,ax
	mov	bx,[BATBUFPOS]
	cmp	bx,-1
	jnz	short UNBUF

; There are no bytes in the buffer. Let's try to fill it up.

	mov	dx,BATBUF
	mov	cx,[BATBUFLEN] ; max to read.
	mov	bx,[BATHAND]
	; 14/02/2023
	mov	ah,3Fh
	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
			; BX = file handle,CX = number	of bytes to read
			; DS:DX	-> buffer
	; MSDOS 6.0
	jnc	short bat_read_ok	;AN022; if no error - continue
	;invoke	get_ext_error_number	;AN022; get the error
	call	get_ext_error_number
	push	ds			;AN022; save local segment
	mov	ds,[RESSEG]		;AN022; get resident segment
	;assume ds:resgroup		;AN022;
	mov	dx,ax			;AN022; put error in DX
	;invoke	output_batch_name	;AN022; set up to print the error
	call	output_batch_name
	pop	ds			;AN022;
	;assume	ds:trangroup		;AN022;
	;invoke	std_eprintf		;AN022; print out the error
	call	std_eprintf
	;mov	byte ptr combuf+2,end_of_line_in
	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
	;				;AN022; terminate the batch line for parsing
	;mov	byte ptr combuf+3,end_of_line_out 
	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
	;				;AN022; terminate the batch line for output
;M020;
;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
;error is never hit (and it shouldn't be)

	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
	jmp	short BATEOF		;AN022; terminate the batch file
bat_read_ok:				;AN022;
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	cx,ax
	;jcxz	TURN_OFF ; MSDOS 3.3
	; 14/02/2023
	jcxz	BATEOFDS ; MSDOS 6.0
	mov	[BATBUFEND],cx
	xor	bx,bx
	mov	[BATBUFPOS],bx

	; Buffered bytes!
UNBUF:
	mov	al,[BATBUF+bx]		; get next byte
	inc	bx
	cmp	bx,[BATBUFEND]		; beyond end of buffer?
	jb	short SETBUFPOS
	mov	bx,-1
SETBUFPOS:
	mov	[BATBUFPOS],bx
	cmp	al,1Ah			; ^Z for termination?
	jne	short GETBYTEDONE

;We get here only when we hit an EOF
	
	; MSDOS 6.0
BATEOFDS:
;SR;
; HACK!!! A massive hack being put in here to get batch processing to work
;properly on EOF. Previously, a CR was returned and batch processing turned
;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
;batch processing is turned off before the last line is processed and so 
;this line would never be executed. 
;   	To fix this, a new flag BatchEOF has been introduced. This flag is
;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
;at the buffer contents. If there is no LF ( we assume that presence of LF
;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
;fake CR to the caller. This decrements BatchEOF. On the next call to this
;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
;third call, BatchEOF becomes zero and batch processing is turned off,
;now that the last line has been processed. If the EOF is the first char read into the buffer 
;during this call, and there was a CR-LF previously, we are going to fake
;another redundant CR-LF. There is no work-around I can think of.
; 	I would love to restructure this entire routine and its caller to
;make the flow really easy to understand but I guess this will have to wait.
;
	push	es
	mov	es,[RESSEG]
;SR;
; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
;or BatchEOF == 1 now), then do not do the LF check.
;
	mov	es,[es:Batch]
	;cmp	byte [es:2],0
	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
	jnz	short crpresent

	;inc	byte [es:2]
	inc	byte [es:BATCHSEGMENT.BatchEOF]
					;match the dec following
	mov	bx,[BATBUFEND]
	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
	je	short crpresent		;yes, no need to fake it

	;add	byte [es:2],3
	add	byte [es:BATCHSEGMENT.BatchEOF],3
					;BatchEOF == 4 to fake CR-LF
crpresent:
;;	;pop	es

	;ASSUME	DS:TranGroup
	; 14/02/2023
	mov	ds,[RESSEG]
	;ASSUME	DS:ResGroup
;SR;
; The shift operation is done here to replace the decrement. This is because
;we can jump to this label directly from above when bogus calls are made to
;this routine even after batch processing is turned off. The shift ensures
;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
;it is used as a decrement and also as a NOP to just fall through on bogus 
;calls.
;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
;turning batch processing off.

At_EOF:					;new label added ;M020
	;shr	byte [es:2],1
	shr	byte [es:BATCHSEGMENT.BatchEOF],1
					;decrement the flag
	jz	short turn_off		;zero,turn batch off
	;cmp	byte [es:2],1
	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
	jz	short ret_lf		;BatchEOF was 2, return LF
;
;BatchEOF == 4, indicates return fake CR now and fake LF next.
;
	mov	al,0Dh			;return fake CR.
	pop	es
	jmp	short GETBYTEDONE
ret_lf:
	mov	al,0Ah			;return fake LF
	pop	es
	jmp	short GETBYTEDONE		
turn_off:
	pop	es
;BATEOF:
	; MSDOS 3.3
;TURN_OFF:
	;mov	ds,[RESSEG]

	; MSDOS 3.3 (& MSDOS 6.0)
BATEOF:
	call	BATCHOFF
	call	BATCLOSE

;;;	mov	BatchEOF,0	;make sure BatchEOF = 0

;SR; BugBug
; There is a good reason why this carriage return is being returned here. 
;This was part of the old code, thanks to some brain-damaged coding. Because,
;of the way the caller is structured, a fake CR has to be returned again on
;EOF to ensure the termination of the caller's loop. If echo is on, this
;results in an extra linefeed after the batchfile is run if the last line of
;the batchfile already had a CR-LF. 
;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
;the end-of-line. This CR is to mark the end-of-file.

	mov	al,0Dh			; If end-of-file, then end of line
	test	byte [Batch_Abort],-1
	mov	byte [Batch_Abort],0
	jz	short CONT_GET_BYT
	mov	di,COMBUF+2		; reset pointer to beginning of buffer
	xor	cx,cx			; zero line length
	jmp	short GETBYTEDONE
CONT_GET_BYT:
	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
	jne	short GETBYTEDONE
	cmp	word [Nest],0		;G See if we have nested batch files
	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
GETBYTEDONE:
	pop	ds
	pop	cx
	pop	bx
	retn

; ---------------------------------------------------------------------------

;break	<$If - conditional execution>

	; 17/04/2023
;IFERRORP:
;	pop	ax
;IFERROR:
;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
;FORERROR:
;	mov	dx,SYNTMES_PTR
;	jmp	cerror

; ---------------------------------------------------------------------------

	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
_$IF:
	; MSDOS 6.0
; Turn off any pipes in progress.
	push	ds			;AN004; save local DS
	mov	ds,[RESSEG]		;AN004; get resident segment
	;assume	ds:resgroup		;AN004;
	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
	jz	short IFNoPipe		;AN004; no pipe - continue
	;invoke	PipeDel 		;AN004; turn off piping
	call	PIPEDEL	
IFNoPipe:				;AN004;
	pop	ds			;AN004; get local DS back
	;assume	ds:trangroup		;AN004;

	; MSDOS 3.3 (&MSDOS 6.0)
	mov	byte [IFNOTFLAG],0
	mov	word [IF_NOT_COUNT],0
	mov	si,81h
IFREENT:
	call	scanoff
	cmp	al,0Dh
	je	short IFERROR
	mov	bp,si
	mov	di,IFTAB		; Prepare to search if table	
	;mov	ch,0
	; 17/04/2023
	xor	ch,ch
IFINDCOM:
	mov	si,bp
	mov	cl,[di]
	inc	di
	jcxz	IFSTRING
	jmp	short FIRSTCOMP
IFCOMP:
	jnz	short IF_DIF
FIRSTCOMP:
	lodsb
	mov	ah,[es:di]
	inc	di
	cmp	al,ah
	je	short IFLP
	or	ah,20h			; Try lower case
	cmp	al,ah
IFLP:
	loop	IFCOMP
IF_DIF:
	lahf
	add	di,cx			; Bump to next position without affecting flags
	mov	bx,[di]			; Get handler address
	inc	di
	inc	di
	sahf
	jnz	short IFINDCOM
	lodsb
	cmp	al,0Dh
IFERRJ:
	jz	short IFERROR
	call	DELIM
	jnz	short IFINDCOM
	call	scanoff
	jmp	bx

	; 17/04/2023
IFERRORP:
	pop	ax
IFERROR:
	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
FORERROR:
	mov	dx,SYNTMES_PTR
	jmp	cerror

IFNOT:
	not	byte [IFNOTFLAG]
	inc	word [IF_NOT_COUNT]
	jmp	short IFREENT

; We are comparing two strings for equality. First, find the end of the
; first string.

IFSTRING:
	push	si			; save away pointer for later compare
	xor	cx,cx			; count of chars in first string
FIRST_STRING:
	lodsb				; get character
	cmp	al,0Dh			; end of line?
	jz	short IFERRORP		; yes => error
	call	DELIM			; is it a delimiter?
	jz	short EQUAL_CHECK 	; yes, go find equal sign
	inc	cx			; remember 1 byte for the length
	jmp	short FIRST_STRING 	; go back for more
EQUAL_CHECK:
	cmp	al,'='			; is char we have an = sign?
	je	short EQUAL_CHECK2 	; yes, go find second one.
	cmp	al,0Dh			; end of line?
	je	short IFERRORP		; yes, syntax error
	lodsb				; get next char
	jmp	short EQUAL_CHECK

; The first = has been found. The next char had better be an = too.

EQUAL_CHECK2:
	lodsb				; get potential = char
	cmp	al,'='			; is it good?	
	;jnz	short IFERRPJ		; no, error
	; 17/04/2023
	jne	short IFERRORP

; Find beginning of second string.

	call	scanoff
	cmp	al,0Dh
	;jz	short IFERRPJ
	; 17/04/2023
	je	short IFERRORP
	pop	di

; DS:SI points to second string
; CX has number of chars in first string
; ES:DI points to first string

	repe	cmpsb
	jz	short MATCH		; match found!

; No match. Let's find out what was wrong. The character that did not match
; has been advanced over. Let's back up to it.

	dec	si

; If it is EOL, then syntax error

	cmp	byte [si],0Dh
	;jz	short IFERRJ
	; 17/04/2023
	je	short IFERROR

; Advance pointer over remainder of unmatched text to next delimiter

SKIPSTRINGEND:
	lodsb
NOTMATCH:
	cmp	al,0Dh
IFERRORJ2:
	;jz	short IFERRJ
	; 17/04/2023
	jz	short IFERROR
	call	DELIM
	jnz	short SKIPSTRINGEND

; Signal that we did NOT have a match

	mov	al,-1
	jmp	short IFRET

	; 17/04/2023
;IFERRPJ:
	;jmp	IFERRORP

; The compare succeeded. Was the second string longer than the first?
; We do this by seeing if the next char is a delimiter.

MATCH:
	lodsb
	call	DELIM
	jnz	short NOTMATCH ; not same.
	xor	al,al
	jmp	short IFRET

; ---------------------------------------------------------------------------

IFEXISTS:

IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6

;MOREDELIM:
	lodsb
	call	DELIM
	jnz	short IFEXISTS
	;jnz	short MOREDELIM

	mov	dx,DIRBUF
	mov	ax,1A00h
	;mov	ax,Set_DMA*256 ; 1A00h
	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
			; DS:DX	-> disk	transfer buffer
	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
	add	bx,[IF_NOT_COUNT]
	;mov	ax,ARG_ARGV
	;mov	ax,ARG+ARG_UNIT.argv
	mov	ax,ARG
	call	argv_calc		; convert arg index to pointer
	mov	dx,[bx]
	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
	;mov	cx,6
	mov	cx,IFEXIST_ATTR ; filetypes to search for
	mov	ax,4E00h
	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
			; CX = search attributes
			; DS:DX	-> ASCIZ filespec
			; (drive,path, and wildcards allowed)
	jc	short IF_EX_C ; carry is how to determine error
	xor	al,al
	jmp	short IFRET

	;nop
IF_EX_C:
	mov	al,-1			; false 'n' fall through...
IFRET:
	test	byte [IFNOTFLAG],-1 ; 0FFh
	jz	short REALTEST
	not	al
REALTEST:
	or	al,al
	jz	short IFTRUE
	jmp	TCOMMAND

IFTRUE:
	call	scanoff
	mov	cx,si
	sub	cx,81h
	sub	[80h],cl
	mov	cl,[80h]
	mov	[COMBUF+1],cl
	mov	di,COMBUF+2
	cld
	rep	movsb
	mov	al,0Dh
	stosb

; Signal that an IF was done. 
; This prevents the redirections from getting lost.

	push	ds
	mov	ds,[RESSEG]
	mov	byte [IfFlag],-1
	pop	ds

; Go do the command

	jmp	DOCOM1

; ---------------------------------------------------------------------------

IFERRORJ3:
	jmp	IFERRORJ2

IFERLEV:
	mov	bh,10
	xor	bl,bl
GETNUMLP:
	lodsb
	cmp	al,0Dh
	je	short IFERRORJ3
	call	DELIM
	jz	short GOTNUM
	sub	al,'0'
	xchg	al,bl
	mul	bh
	add	al,bl
	xchg	al,bl
	jmp	short GETNUMLP
GOTNUM:
	push	ds
	mov	ds,[RESSEG]
	mov	ah,[RetCode]
	pop	ds
	xor	al,al
	cmp	ah,bl
	jnb	short IFRET
	dec	al
	jmp	short IFRET

; ---------------------------------------------------------------------------

; Shift the parameters in the batch structure by 1 and set up the new argument.
; This is a NOP if no batch in progress.

_SHIFT:
	mov	ds,[RESSEG]
	mov	ax,[Batch]		; get batch pointer
	or	ax,ax			; in batch mode?
	jnz	short SHIFT1		; yes, operate in batch segment	
SHIFT_RETN:				; no, done.
	retn
SHIFT1:
	mov	es,ax
	mov	ds,ax

; Now move the batch args down by 1 word

	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
	mov	di,BATCHSEGMENT.BatParm ; point to parm table
	lea	si,[di+2]		; make source = dest + 2
	mov	cx,9			; move 9 parameters
	rep	movsw			; SHIFT down

; If the last parameter (the one not moved) is empty (= -1) then we are done.
; We have copied it into the previous position.

	cmp	word [di],-1	; if last one was not in use then
	je	short SHIFT_RETN ; No new parm

; This last pointer is NOT nul. Get it and scan to find the next argument.
; Assume, first, that there is no next argument.
 
	mov	si,[di]
	mov	word [di],-1		; Assume no parm

; The parameters are CR separated. Scan for end of this parm.

SKIPCRLP:
	lodsb
	cmp	al,0Dh
	jne	short SKIPCRLP

; We are now pointing at next arg. If it is 0 (end of original line) then we
; are finished. There are no more parms and the pointer has been previously
; initialized to indicate it.

	cmp	byte [si],0
	jz	short SHIFT_RETN 	; End of parms
	mov	[di],si			; Pointer to next parm as %9
	retn

; =============== S U B	R O U T	I N E =======================================

; Skip delim reads bytes from the batch file until a non-delimiter is seen.
; returns char in AL, carry set -> eof

SKIPDELIM:
	test	word [Batch],-1		; batch file empty. OOPS!
	jz	short SKIPERR
	call	GETBATBYT		; get a char
	call	DELIM			; check for ignoreable chars
	jz	short SKIPDELIM		; ignore this char.
	clc
	retn
SKIPERR:
	stc
GOTO_RETN:
	retn

; ---------------------------------------------------------------------------

;  CALL is an internal command that transfers control to a .bat, .exe, or
;  .com file. This routine strips the CALL off the command line, sets
;  the CALL_FLAG to indicate a call in progress, and returns control to
;  DOCOM1 in TCODE to reprocess the command line and execute the file
;  being CALLed.

	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
_$CALL:

;  strip off CALL from command line

	;ASSUME DS:trangroup,ES:trangroup

	push	si
	push	di
	push	ax
	push	cx
	mov	si,COMBUF+2
	call	scanoff			;get to first non-delimeter
	;add	si,4
	add	si,length_call		;point to char past CALL
	mov	di,COMBUF+2
	;mov	cx,124		
	mov	cx,COMBUFLEN-length_call 
					;get length of buffer
	rep	movsb			;move it
	pop	cx
	pop	ax
	pop	di
	pop	si

;  set call flag to indicate call in progress

	push	ds
	mov	ds,[RESSEG]
	mov	byte [Call_Flag],call_in_progress ; 1
	mov	byte [Call_Batch_Flag],call_in_progress ; 1

; Turn off any pipes in progress.

	cmp	byte [PipeFiles],0 	; Only turn off if present.
	jz	short _NOPIPE
	call	PIPEDEL
_NOPIPE:
	pop	ds
	retn

; ---------------------------------------------------------------------------

	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
_GOTO:
	mov	ds,[RESSEG]
	test	word [Batch],-1	; If not in batch mode, a nop
	jz	short GOTO_RETN
	xor	dx,dx
	push	ds
	mov	ds,[Batch]
	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start

	; MSDOS 6.0
;M037
; Clear EOF indicator because we have reseeked to the beginning of the file.
;
	mov	byte [BATCHSEGMENT.BatchEOF],0
					; clear eof indicator ;M037
	; MSDOS 3.3 (& MSDOS 6.0)
	pop	ds
GOTOOPEN:
	call	PROMPTBAT
	;mov	di,5Dh
	mov	di,FCB+1		; Get the label
	mov	cx,11
	mov	al,' '
	repne	scasb
	jnz	short NOINC
	inc	cx
NOINC:
	sub	cx,11
	neg	cx
	;mov	[cs:GOTOLEN],cx
	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)

; At beginning of file. Skip to first non-delimiter char

	call	SKIPDELIM
	jb	short BADGOTO
	cmp	al,':'
	jz	short CHKLABEL
LABLKLP:				; Look for the label
	call	GETBATBYT
	cmp	al,0Ah
	jne	short LABLKTST

; At beginning of line. Skip to first non-delimiter char

	call	SKIPDELIM
	jb	short BADGOTO
	cmp	al,':'
	je	short CHKLABEL
LABLKTST:
	test	word [Batch],0FFFFh ; -1
	jnz	short LABLKLP
BADGOTO:
	call	BATCLOSE

	; MSDOS 6.0
;SR;
; At this point we are terminating without freeing up any nested batch 
;segments i.e if the error occurred within a called batch file. This routine
;will traverse the linked list of batch segments and free all of them.
;
	call	free_batch		; free up nested batch segments

	; MSDOS 3.3 (& MSDOS 6.0)
	push	cs
	pop	ds
	mov	dx,BADLAB_PTR
	jmp	cerror

; Found the :.	Skip to first non-delimiter char

CHKLABEL:
	call	SKIPDELIM
	jb	short BADGOTO
	mov	di,FCB+1 ; 5Dh
	;mov	cx,[cs:GOTOLEN]
	; 14/02/2023
	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
	jmp	short GOTBYTE

NEXTCHRLP:
	push	cx
	call	GETBATBYT
	pop	cx
GOTBYTE:
	; 18/03/2023
	; 14/02/2023
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
	call	testkanj
	jz	short NOTKANJ1
	cmp	al,[es:di]
	jne	short LABLKTST
	inc	di
	dec	cx
	jcxz	LABLKTST
	push	cx
	call	GETBATBYT
	pop	cx
	cmp	al,[es:di]
	jmp	short KNEXTLABCHR
NOTKANJ1:
	; 14/02/2023
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
	or	al,20h
	cmp	al,[es:di]
	;jne	short TRYUPPER
	;jmp	short NEXTLABCHR
	; 25/04/2023
	je	short NEXTLABCHR 
TRYUPPER:
	sub	al,20h
	cmp	al,[es:di]
KNEXTLABCHR:
	jnz	short LABLKTST
NEXTLABCHR:
	inc	di
	loop	NEXTCHRLP
	call	GETBATBYT
	; 14/02/2023
	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
	jge	short GOTOCONT	; Yes, then the next char doesn't matter
	cmp	al,' '
	ja	short LABLKTST
GOTOCONT:
	cmp	al,0Dh
	je	short SKIPLFEED
TONEXTBATLIN:
	call	GETBATBYT
	cmp	al,0Dh
	jne	short TONEXTBATLIN
SKIPLFEED:
	call	GETBATBYT

	; MSDOS 6.0
;SR;
; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
;CR-LF for the last line. On a goto, this flag has to be cleared, because
;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
;to get the EOF has not been made yet because we encountered the Goto. On
;all other cases, EOF will be hit while trying to read the next line and
;we are fine. I know, I know, what a massive hack from hell!! God help us!!
;
	push	es
	mov	es,[Batch]
	mov	byte [es:BATCHSEGMENT.BatchEOF],0
					;invalidate fake CR-LF flag
	pop	es

	; MSDOS 3.3 (& MSDOS 6.0)
	;call	BATCLOSE
	;retn
	; 14/02/2023
	;jmp	short BATCLOSE

; =============== S U B	R O U T	I N E =======================================

BATCLOSE:
	mov	bx,[cs:BATHAND]
	cmp	bx,5
	jb	short CLOSERETURN
	; 14/02/2023
	mov	ah,3Eh
	;mov	ah,CLOSE ; 3Eh
	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
CLOSERETURN:
	mov	byte [In_Batch],0 ; reset flag	
	retn

; =============== S U B	R O U T	I N E =======================================

; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
; Also, fills internal batch buffer. If access denied, then AX = -1

	; 14/02/2023
BATOPEN:
	push	ds
	mov	ds,[Batch]
	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
	mov	dx,BATCHSEGMENT.BatFile
	mov	ax,3D00h
	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 0 - read
	jb	short SETERRDL
	;mov	dx,[8]
	mov	dx,[BATCHSEGMENT.BatSeek]
	;mov	cx,[10]
	mov	cx,[BATCHSEGMENT.BatSeek+2]
	pop	ds
	;mov	[cs:BATHAND],ax
	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
	mov	bx,ax
	mov	ax,4200h
	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from beginning of	file

	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
					; nuke batch buffer position
	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
BATOPEN_RETN:
	retn

SETERRDL:
	mov	bx,dx
	; MSDOS 6.0
	;invoke	get_ext_error_number 	;AN022; get the extended error
	; 14/02/2023
	call	get_ext_error_number
	mov	dx,ax		     	;AN022; save extended error in DX

	; MSDOS 3.3
	;mov	dx,INSERTDSKPTR
	;call	GET_EXT_ERR_NUMBER

	; MSDOS 3.3 (& MSDOS 6.0)
	mov	al,[bx]			; Get drive spec
	sub	al,'@'			; A = 1
	pop	ds
	stc				; SUB mucked over carry
	retn

; =============== S U B	R O U T	I N E =======================================

;Free_batch : This routine traverses the linked batch segments freeing all
;the batch and FOR segments until all of them are freed. It also restores
;the old state of the EchoFlag.
;
;	ENTRY:	ds = RESGROUP
;
;	EXIT: 	All batch & FOR segments freed.
;		EchoFlag restored to old state before batch process.
;
;	REGISTERS AFFECTED: bx, cx

	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh

free_batch: ;proc near
	;assume	ds:RESGROUP,es:nothing

	push	es
	mov	bx,[Next_Batch]
	or	bx,bx
	jz	short fb_ret
_ClearBatch:
	mov	es,bx			; get batch segment
	;mov	bx,es:BatForPtr		; get old FOR segment
	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
	cmp	bx,0			; is a FOR in progress
	je	short no_bat_for	; no - don't deallocate
	push	es			;
	mov	es,bx			; yes - free it up...
	mov	ah,49h
	;mov	ah,DEALLOC		;
	int	21h			;
	pop	es			; restore to batch segment
no_bat_for:
	;mov	cl,[es:1]
	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
					; get old echo flag
	;mov	bx,[es:3]
	mov	bx,[es:BATCHSEGMENT.BatLast]
					; get old batch segment
	mov	ah,49h
	;mov	ah,DEALLOC		; free it up...
	int	21h
	; 14/02/2023
	;mov	[Batch],bx		; get ready to deallocate next batch
	dec	word [Nest]		; is there another batch file?
	jnz	short _ClearBatch	; keep going until no batch file
	
	mov	[EchoFlag],cl		;restore echo status
	mov	word [Batch],0		;no batch process in progress
fb_ret:
	pop	es
	ret

;free_batch endp

;============================================================================
; TFOR.ASM, MSDOS 6.0, 1991
;============================================================================
; 10/10/2018 - Retro DOS v3.0

; All batch proccessing has DS set to segment of resident portion
;ASSUME DS:RESGROUP,ES:TRANGROUP

; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h

; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh

; ---------------------------------------------------------------------------

	; 15/02/2023
FORTERM:
	; MSDOS 6.0
	push	cs			;AN037; Get local segment into
	pop	ds			;AN037;  DS, ES
	push	cs			;AN037;
	pop	es			;AN037;

	; MSDOS 3.3 (& MSDOS 6.0)
	call	FOROFF
	;mov	ds,[cs:RESSEG]
	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
	cmp	word [SingleCom],0FF00h
	jne	short BAT_CRLF
	cmp	word [Nest],0		;See if we have nested batch files
	jne	short BAT_CRLF		;Yes - don't exit just yet
	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
	jmp	short NOFORP2
BAT_CRLF:
	test	byte [EchoFlag],1 	; Is echo on?
	jz	short NOFORP2		; no - exit
	test	word [Batch],-1 ; 0FFFFh
					; print CRLF if in batch
	jz	short NOFORP2
	call	CRLF2
NOFORP2:
	jmp	TCOMMAND

; ---------------------------------------------------------------------------

;------
;   For-loop processing. For loops are of the form:
;	    for %<loop-variable> in (<list>) do <command>
; where <command> may contain references of the form %<variable>, which are
; later substituted with the items in <list>. The for-loop structure is
; set-up by the procedure '$for'; successive calls to 'forproc' execute
; <command> once for each item in <list>. All of the information needed for
; loop processing is stored on a piece of memory gotten from 'alloc'. This
; structure is actually fairly large, on the order of 700 bytes, and includes
; a complete copy of the original command-line structure as parsed by
; 'parseline', loop control variables, and a dma buffer for the
; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
; processing has completed, this chunk of memory is returned to the system.
;
;   All of the previously defined variables, in 'datares', used for loop
; processing may be erased. Only one, (DW) ForPtr, need be allocated.
;
;   The error message, 'for_alloc_mes', should be moved into the file
; containing all of the other error messages.
;
;   Referencing the allocated for-loop structure is a little tricky.
; At the moment, a byte is defined as part of a new segment, 'for_segment'.
; When 'forproc' actually runs, ES and DS are set to point to the base of the
; new chunk of memory.	References to this byte, 'f', thus assemble correctly
; as offsets of ES or DS. 'f' would not be necessary, except that the
; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
; immediate move of the offset of 'for_minarg' into AX. In other words, in
; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
;	mov  AX, #for_minarg 	; AX := 02CA (for example)
; instead of
;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
; By using 'f', we pretend that we are actually referencing an allocated
; structure, and the assembler coughs up the code we want. Notice that it
; doesn't matter whether we put brackets around the location or not -- the
; assembler is "smart" enough to know that we want an address instead of the
; contents of that location.
;
;   Finally, there now exists the potential to easily implement nested loops.
; One method would be to have a link field in each for-structure pointing to
; its parent.  Variable references that couldn't be resolved in the local
; frame would cause a search of prior frames. For-structures would still be
; allocated and released in exactly the same fashion. The only limit on the
; number of nested loops would be memory size (although at 700 bytes a pop,
; memory wouldn't last THAT long). Alternately, a small structure could be
; maintained in the resident data area. This structure would be an array of
; control-variable names and pointers to for-structure blocks. This would
; greatly speed up the resolution of non-local variable references. However,
; since space in the resident is precious, we would have to compromise on a
; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
; allocation and de-allocation would have to be modified slightly to take this
; new structure into account.
;
;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
; It could just as well be one structure allocated in 'transpace'. Actually,
; it may be easier to allocate it as part of 'for_segment'.
;------
		; include fordata.asm

; Data structure definitions included by tfor.asm

struc FOR_INFO
  .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
  .FOR_COM_START: resb  1		; beginning of <command>
  .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
  .FOR_MINARG:	  resw  1		; beginning of <list>
  .FOR_MAXARG:	  resw  1		; end of <list>
  .FORBUF:	  resw  64		; temporary buffer
  .FORDMA:	  resw  64		; FindFirst/Next buffer
  .FOR_VAR:	  resb  1		; loop control variable
  .size:
endstruc
					; ARG_UNIT.SIZE = 1348 (544h)
_$FOR_EXIT:
	jmp	short FORTERM		; exceeding maxarg means all done

; ---------------------------------------------------------------------------

	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
FORPROC:
	mov	ax,[ForPtr]
	mov	ds,ax
	mov	es,ax			; operate in for-info area
	;mov	dx,5CBh	; MSDOS 5.0
	mov	dx,FOR_INFO.FORDMA ; 5CBh
					; 1348+1+2+2+2+128 = 1483 = 5CBh
	mov	ax,1A00h
	;mov	ax,Set_DMA*256 ; 1A00h
	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
			; DS:DX	-> disk	transfer buffer
FOR_BEGIN:
	;cmp	word [545h],0
	cmp	word [FOR_INFO.FOR_EXPAND],0 ; [545h]
	jz	short FOR_BEGIN1
					; non-zero for_expand equals FALSE
	;inc	word [547h]
	inc	word [FOR_INFO.FOR_MINARG] ; [547h]
FOR_BEGIN1:
	mov	bx,[FOR_INFO.FOR_MINARG] ; [547h]
					; current item in <list> to examine
	cmp	bx,[FOR_INFO.FOR_MAXARG] ; [549h]
	jg	short _$FOR_EXIT	; exceeding maxarg means all done	
	;mov	ax,0
	mov	ax,FOR_INFO.FOR_ARGS ; 0 
	call	argv_calc		; compute argv[x] address
	;mov	cx,[bx+3]
	mov	cx,[bx+ARGV_ELE.argstartel]
	mov	dx,[bx]
	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
	;test	byte [bx+2],4		; Is there a path separator in this arg?
	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
	jnz	short FORSUB		; Yes, argstartel should be correct
	mov	si,[bx]
	;mov	si,[bx+ARGV_ELE.argpointer]

	;mov	al,[cs:LPAREN]
	; 15/02/2023
	; MSDOS 6.0 (& 5.0) COMMAND.com
	mov	al,'('	; mov al,lparen
	cmp	[si-1],	al		; If the current token is the first
	jne	short FORSUB		;  one in the list and originally had
	inc	cx			;  the opening paren as its first char,
					;  the argstartel ptr needs to be
					;  advanced passed it before the prefix
					;  length is computed.
	mov	al,':'
	cmp	[si+1],	al		; If the token begins with "(d:",
	jne	short FORSUB		;  argstartel has to be moved over the
	add	cx,2			;  rest of the prefix as well.
FORSUB:
	sub	cx,dx			; compute length of pathname prefix
	;cmp	word [545h],0
	cmp	word [FOR_INFO.FOR_EXPAND],0
					; are we still expanding a name?
	jz	short FOR_FIND_NEXT
					; if so, get next matching filename
	;test	byte [bx+2],2
	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
	jnz	short FOR_FIND_FIRST
					; should we expand THIS (new) arg?
	;mov	cx,[bx+5]	
					; else, just copy all of it directly	
	mov	cx,[bx+ARGV_ELE.arglen]
	jmp	short FOR_SMOOSH

	;nop
	; 15/02/2023
FOR_FIND_FIRST:
	push	cx
	xor	cx,cx
	mov	ax,4E00h
	;mov	ax,Find_First*256 ; 4E00h
	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
			; CX = search attributes
			; DS:DX	-> ASCIZ filespec
			; (drive,path, and wildcards allowed)
	pop	cx
	jmp	short FOR_RESULT

	;nop
FOR_FIND_NEXT:
	mov	ax,4F00h
	;mov	ax,Find_Next*256 ;4F00h
	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
			; [DTA]	= data block from
			; last AH = 4Eh/4Fh call
FOR_RESULT:
	mov	ax,-1 ; 0FFFFh		; assume worst case
	jc	short FOR_CHECK
	; 15/02/2023
	inc	ax ; ax = 0
	;mov	ax,0			; Find* returns 0 for SUCCESS
FOR_CHECK:				; record success of findfirst/next
	mov	[FOR_INFO.FOR_EXPAND],ax
	or	ax,ax			; anything out there?
	jnz	short FOR_BEGIN		; if not, try next arg
FOR_SMOOSH:
	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
	;mov	di,54Bh	; MSDOS 5.0
	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
	rep	movsb			; arg, some days just the path prefix
					
	cmp	word [FOR_INFO.FOR_EXPAND],0
					; if we're not expanding, we can
	jnz	short FOR_MAKE_COM 	; skip the following	
	; 15/02/2023
	;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.0 COMMAND.COM
	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
FOR_MORE:
	;cmp	byte [si],0		; tack on matching filename
	;jz	short FOR_MAKE_COM
	;movsb
	;jnz	short FOR_MORE
	; 25/04/2023
	lodsb
	stosb
	or	al,al
	jnz	short FOR_MORE
FOR_MAKE_COM:
	; 25/04/2023
	;xor	al,al			; tack a null byte onto the end
	;stosb				; of the substitute string
	xor	cx,cx			; character count for command line
	not	cx			; negate it -- take advantage of loopnz
	xor	bx,bx			; argpointer
	mov	di,COMBUF+2
	; 15/02/2023
	;mov	bl,[544h]  ; MSDOS 5.0
	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
	;mov	dh,[64Bh]
	mov	dh,[FOR_INFO.FOR_VAR] 
					; %<for-var> is replaced by [forbuf]
	push	cs			; time to form the <command> string
	pop	es
	;assume ES:trangroup
	;mov	ax,FOR_INFO.FOR_ARGS
	mov	ax,0			; translate offset to pointer
	call	argv_calc
	;mov	si,[bx+9]
	mov	si,[bx+ARGV_ELE.arg_ocomptr] 
					; mov ptr passed beginning space
	inc	si
FOR_MAKE_LOOP:
	mov	al,[si]			; the <command> arg, byte by byte
	inc	si
	cmp	al,'%'			; looking for %<control-variable>
	jne	short FOR_STOSB 	; no % ... add byte to string
	cmp	[si],dh			; got the right <variable>?
	jnz	short FOR_STOSB		; got a %, but wrong <variable>
	inc	si			; skip over <for-variable>

	push	si
	; 15/02/2023
	;mov	si,54Bh	; MSDOS 5.0
	mov	si,FOR_INFO.FORBUF
					; substitute the <item> for <variable>
					; to make a final <command> to execute
SLOOP:					
	lodsb				; grab all those <item> bytes, and
	stosb				; add 'em to the <command> string,
	or	al,al			; until we run into a null
	loopne	SLOOP
	dec	di			; adjust length and <command> pointer
	inc	cx			; so we can overwrite the null
	pop	si
	jmp	short FOR_MAKE_LOOP
					; got back for more <command> bytes
FOR_STOSB:
	stosb				; take a byte from the <command> arg
	dec	cx			; and put it into the <command> to be
					; executed (and note length, too)
	cmp	al,0Dh		
	jne	short FOR_MAKE_LOOP	; If not done, loop.
FOR_MADE_COM:
	not	cl
	;mov	[cs:COMBUF+1],cl
	;mov	ds,[cs:RESSEG]
	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM
	mov	[es:COMBUF+1],cl
	mov	ds,[es:RESSEG]				
	;assume DS:resgroup
	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
	jz	short NOECHO3
	;cmp	byte [NullFlag],nullcommand
	cmp	byte [NullFlag],1 	;G was there a command last time?
	jz	short NO_CRLF_PR  	;G no - don't print crlf	 	

	call	CRLF2		  	;G Print out prompt
NO_CRLF_PR:
	mov	byte [NullFlag],0 	;G reset no command flag
	push	cs
	pop	ds
	push	di
	call	PRINT_PROMPT	  	;G Prompt the user
	pop	di

	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
	mov	word [string_ptr_2],COMBUF+2
	; 17/04/2023
	mov	dx,string_buf_ptr
	call	std_printf
	mov	byte [es:di-1],0Dh
	jmp	DOCOM		  	; run silent, run deep...
NOECHO3:
	mov	byte [NullFlag],0
	push	cs
	pop	ds
	jmp	DOCOM1

FORNESTERRJ:				; no multi-loop processing... yet!		
	call	FOROFF
	jmp	FORNESTERR

; ---------------------------------------------------------------------------

FORERRORJ:
	jmp	FORERROR

; ---------------------------------------------------------------------------

_$FOR:
	mov	es,[RESSEG]
	cmp	byte [es:ForFlag],0 ; is another one already running?
	jnz	short FORNESTERRJ   ; if flag is set.... boom!

; Turn off any pipes in progress.

	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
	jz	short NO_PIPE
	call	PIPEDEL
NO_PIPE:
	xor	dx,dx			; counter (0 <= DX < argvcnt)
	call	NEXTARG			; move to next argv[n]
	jc	short FORERRORJ		; no more args -- bad forloop
	cmp	al,'%'			; next arg MUST start with '%'...
	jne	short FORERRORJ
	mov	bp,ax			; save forloop variable
	lodsb
	or	al,al			; and MUST end immediately...
	jnz	short FORERRORJ
	call	NEXTARG			; let's make sure the next arg is 'in'
	jb	short FORERRORJ
	;and	ax,0DFDFh
	and	ax,~2020h		; uppercase the letters
	; 15/02/2023
	;cmp	ax,4E49h  	; MSDOS 5.0	
	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
	;cmp	ax,in_word	; MSDOS 5.0
	cmp	ax,'IN'
	jnz	short FORERRORJ
	lodsb

	; 15/02/2023
	; MSDOS 3.3
	;or	al,al			; it, too, must end right away
	;jz	short CHECKLPAREN
	;cmp	al,[LPAREN]
	;jnz	short FORERRORJ
	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
	;add	word [bx],2
	;;add	word [bx+9],2
	;add	word [bx+ARGV_ELE.arg_ocomptr],2
	;;sub	word [bx+5],2
	;sub	word [bx+ARGV_ELE.arglen],2
	;mov	ax,[si-1]
	;jmp	short LPCHECK

	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh

	; MSDOS 6.0
; Compaq bug fix -- exit from this loop on error

	or	al,al
	jne	short FORERRORJ		; jump on error

;	je	short CHECKLPAREN
;
; Not null. Perhaps there are no spaces between this and the (:
;   FOR %i in(foo bar...
; Check for the Lparen here
;
;;	cmp	al,lparen
;;	jnz	short FORERRORJ	
;
; The token was in(... We strip off the "in" part to simulate a separator
; being there in the first place.
;
;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
;;						; advance original string
;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
;
; SI now points past the in(.  Simulate a nextarg call that results in the
; current value.
;
;;	mov	ax,[si-1]		; get lparen and next char
;;	jmp	short LPCHECK
;
; end of Compaq bug fix

; ---------------------------------------------------------------------------

	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh

	; MSDOS 3.3 (& MSDOS 6.0)
CHECKLPAREN:
	call	NEXTARG			; lparen delimits beginning of <list>
	jc	short FORERRORJ
LPCHECK:
	; 15/02/2023
	; MSDOS 5.0 (% MSDOS 6.0)	
	;;cmp	al,[LPAREN]
	;cmp	al,lparen
	cmp	al,'('
	jne	short FORERRORJ
	cmp	ah,0
	je	short FOR_PAREN_TOKEN
	;;cmp	ah,[RPAREN]		; special case:  null list	
	;cmp	ah,rparen
	cmp	ah,')'
	jne	short FOR_LIST_NOT_EMPTY
	jmp	FORTERM
FOR_LIST_NOT_EMPTY:
	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
	inc	word [bx]		; Advance ptr past "("
	;dec	word [bx+5]		; Adjust the rest of this argv entry	
	dec	word [bx+ARGV_ELE.arglen] ; to agree.
	inc	si			; Inc si so check for ")" works
	jmp	short FOR_LIST

	;nop
FOR_PAREN_TOKEN:
	call	NEXTARG			; what have we in our <list>?
	jc	short FORERRORJ
	; 15/02/2023
	;;;cmp	ax,[RPAREN+1]	
	;;cmp	ax,[NULLRPAREN]		; special case:  null list
	;cmp	ax,nullrparen
	cmp	ax,29h	; db 29h,0 ; db ')',0
	jne	short FOR_LIST
	jmp	FORTERM

;FORERORJJ:
	;jmp	FORERROR

FOR_LIST:				; skip over rest of <list>
	mov	cx,dx			; first arg of <list>

SKIP_LIST:
	;add	si,[bx+5]
	add	si,[bx+ARGV_ELE.arglen]
	sub	si,3			; si = ptr to last char of token
	; 15/02/2023
	;;mov	al,[RPAREN]
	;mov	al,rparen
	mov	al,')'
	cmp	[si],al			; Is this the last element in <list>
	je	short FOR_END_LIST 	; Yes, exit loop.
	call	NEXTARG			; No, get next arg <list>
	;jc	short FORERORJJ		; If no more and no rparen, error.
	;jmp	short SKIP_LIST
	; 15/02/2023
	jnc	short SKIP_LIST

	; 15/02/2023
FORERORJJ:
	jmp	FORERROR

FOR_END_LIST:
	mov	di,dx			; record position of last arg in <list>
	mov	byte [si],0		; Zap the rparen
	; 15/02/2023
	;;;cmp	ax,[RPAREN+1]	
	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
	;cmp	ax,nullparen
	cmp	ax,29h	; db 29h,0 ; db ')',0
	je	short FOR_DO		; Yes, continue
	inc	di			; No, inc position of last arg
FOR_DO:
	call	NEXTARG			; now we had BETTER find a 'do'...
	jc	short FORERORJJ
	;and	ax,0DFDFh	
	and	ax,~2020h		; uppercase the letters
	; 15/02/2023
	;;cmp	ax,[DO_WORD]
	;cmp	ax,do_word ; 4F44h
	cmp	ax,'DO'	 ; 4F44h	
	jne	short FORERORJJ
	lodsb
	or	al,al			; and it had BETTER be ONLY a 'do'...
	jnz	short FORERORJJ
		
	call	NEXTARG			; on to the beginning of <command>
	jc	short FORERORJJ		; null <command> not legal

	push	ax
	push	bx
	push	cx
	push	dx			; preserve registers against disaster
	push	di
	push	si
	push	bp
	call	FREE_TPA		; need to make free memory, first
	call	FOROFF
	;mov	bx,264
	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
	call	SAVE_ARGS		; extra bytes needed for for-info
	pushf
	mov	[es:ForPtr],ax
	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
	popf
	pop	bp
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	jc	short FOR_ALLOC_ERR

	push	es			; save resgroup seg...
	push	word [es:ForPtr]
	pop	es
	;assume es:for_segment	
	dec	cx			; forproc wants min pointing before
	dec	di			; first arg, max right at last one
	; 15/02/2023
	;mov	[547h],cx
	mov	[es:FOR_INFO.FOR_MINARG],cx
	;mov	[549h],di
	mov	[es:FOR_INFO.FOR_MAXARG],di
	;mov	[544h],dl
	mov	[es:FOR_INFO.FOR_COM_START],dl
	;mov	word [545h],0FFFFh ; -1
	mov	word [es:FOR_INFO.FOR_EXPAND],-1
					; non-zero means FALSE
	mov	ax,bp
	;mov	[64Bh],ah
	mov	[es:FOR_INFO.FOR_VAR],ah
	pop	es
	;assume es:resgroup	
	inc	byte [es:ForFlag]
	cmp	word [es:SingleCom],-1
	jne	short FOR_RET
	mov	word [es:SingleCom],0FF00h
FOR_RET:
	retn

FOR_ALLOC_ERR:
	; 15/02/2023
	; MSDOS 3.3
	;mov	dx,INSFMEMMESPTR
	;jmp	CERROR

	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 6.0
	;mov	byte [msg_disp_class],1
	mov	byte [msg_disp_class],ext_msg_class	
					;AN000; set up extended error msg class
	;mov	dx,offset TranGroup:Extend_Buf_ptr     
	mov	dx,extend_buf_ptr
					;AC000; get extended message pointer
	;mov	word [extend_buf_ptr],8
	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
					;AN000; get message number in control block
	jmp	cerror


; =============== S U B	R O U T	I N E =======================================

NEXTARG:
	inc	dx			; next argv[n]
	;cmp	dx,[ARG_ARGVCNT]
	cmp	dx,[ARG+ARG_UNIT.argvcnt]
					; make sure we don't run off end
	jge	short NEXTARG_ERR 	;  of argv[]...	
	mov	bx,dx
	;mov	ax,ARG_ARGV
	;mov	ax,ARG+ARG_UNIT.argv
	mov	ax,ARG
	call	argv_calc		; convert array index to pointer
	mov	si,[bx]			; load pointer to argstring
	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
	lodsw				; and load first two chars
	clc
	retn
NEXTARG_ERR:
	stc
	retn

; ---------------------------------------------------------------------------

FORNESTERR:
	push	ds
	mov	ds,[RESSEG]
	;ASSUME DS:RESGROUP
	mov	dx,FORNESTMES_PTR
	cmp	word [SingleCom],0FF00h
	jne	short NOFORP3
	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
NOFORP3:
	pop	ds
	jmp	cerror

; =============== S U B	R O U T	I N E =======================================

; General routine called to free the for segment. We also clear the forflag
; too. Change no registers.

FOROFF:
	push	ax
	push	es
	mov	es,[cs:RESSEG]
	mov	ax,[es:ForPtr]
	or	ax,ax
	jz	short FREEDONE
	push	es
	mov	es,ax
	; 15/02/2023
	mov	ah,49h
	;mov	ah,DEALLOC ; 49h
	int	21h	; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
	pop	es
FREEDONE:
	mov	word [es:ForPtr],0
	mov	byte [es:ForFlag],0
	pop	es
	pop	ax
	retn

;============================================================================
; TCMD1A.ASM, MSDOS 6.0, 1991
;============================================================================
; 09/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh

; ---------------------------------------------------------------------------

; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

%if 0

; The DIR command displays the contents of a directory.
;
; ****************************************************************
; *
; * ROUTINE:	 CATALOG - display file(s) in directory
; *
; * FUNCTION:	 PARSE command line for drive, file, or path name.
; *		 DIR allows two switches, /P (pause) and /W (wide).
; *		 If an error occurs issue and error message and
; *		 transfer control to CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

CATALOG:
	; MSDOS 3.3

	;mov	ax,ARG_ARGV
	;mov	ax,ARG+ARG_UNIT.argv
	mov	ax,ARG
	mov	dx,0FFFFh
	xor	cx,cx
	xor	si,si
DIR1:
	;cmp	cx,[ARG_ARGVCNT]
	cmp	cx,[ARG+ARG_UNIT.argvcnt]
	jnb	short DIR6 ; No more arguments
	mov	bx,cx
	call	ARGV_CALC
	;or	si,[bx+7]
	or	si,[bx+ARGV_ELE.argsw_word]
	test	si,7FFCh  ; test si,~8003
	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
	;test	byte [bx+2],1
	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
	jz	short DIR3
	jmp	short DIR5
DIR2:
	mov	dx,BADPARMPTR
	jmp	CERROR
DIR3:
	or	cx,cx
	jnz	short DIR4	
	;cmp	word [bx+5],3
	cmp	word [bx+ARGV_ELE.arglen],3
	jz	short DIR5
	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
	add	word [bx],3
	;add	word [bx+9],3
	add	word [bx+ARGV_ELE.arg_ocomptr],3
	;add	word [bx+3],3
	add	word [bx+ARGV_ELE.argstartel],3
	;sub	word [bx+5],3
	sub	word [bx+ARGV_ELE.arglen],3
DIR4:
	cmp	dx,0FFFFh
	jnz	short DIR2
	mov	dx,bx
DIR5:
	inc	cx
	jmp	short DIR1
DIR6:
	mov	[COMSW],si
	push	dx
	xor	al,al
	cmp	dx,0FFFFh
	jz	short DIR7
	mov	bx,dx
	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
	mov	di,[bx]
	cmp	byte [di+1],':'
	jnz	short DIR7
	mov	al,[di]
	or	al,20h		; Lowercase drive name	
	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
DIR7:
	;mov	[5CH],al
	mov	[FCB],al
	call	OKVOLARG
	mov	al,'?'		; *.* is default file spec.
	;mov	di,5Dh
	mov	di,FCB+1
	mov	cx,11
	rep stosb

; Begin by processing any switches that may have been specified.
; BITS will contain any information about switches that was
; found when the command line was parsed.

	mov	ax,[COMSW]	; Get switches from command
	mov	[_BITS],ax	; initialize switches
	mov	word [COMSW],0	; initialize flags
	mov	byte [LINPERPAG],23 ; Set default for lines per page
	;test	al,1
	test	al,SWITCHW	; /W ?
	;mov	al,1
	mov	al,NORMPERLIN
	jz	short DIR8
	;mov	al,5
	mov	al,WIDEPERLIN
DIR8:
	mov	[LINLEN],al	; Set number of entries per line
	mov	[LINCNT],al
	mov	word [FILECNT],0 ; Keep track of how many files found
	mov	dx,DIRBUF
	mov	ah,Set_DMA ; 1Ah
	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
			; DS:DX	-> disk	transfer buffer
	;mov	dl,[5Ch]
	mov	dl,[FCB]
	call	SAVUDIR
	pop	bx
	cmp	bx,0FFFFh
	jz	short DIR9
	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
	mov	dx,[bx]

; The user may have specified a device. Search for the path and see if the
; attributes indicate a device.

	mov	ah,Find_First ; 4Eh
	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
			; CX = search attributes
			; DS:DX	-> ASCIZ filespec
			; (drive,path, and wildcards allowed)
	jc	short DIR10
			; Check device atrribute..
	;test	byte [DIRBUF_ATTRIB2],40h
	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
	; 14/10/2018
	;test	byte [DIRBUF+21],40h
	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
	jz	short DIR10	; no, go do normal operation
	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
DIR9:
	jmp	short DOHEADER
DIR10:
	;mov	dx,[bx+ARGV_ELE.argpointer]
	mov	dx,[bx]
	mov	ah,CHDir ; 3Bh
	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
			; DS:DX	-> ASCIZ directory name	(may include drive)
	jnc	short DOHEADER
	;mov	si,[bx+3]
	mov	si,[bx+ARGV_ELE.argstartel]
	cmp	dx,si
	jz	short DIR_NO_DRIVE
	xor	cl,cl
	xchg	cl,[si]
	mov	ah,CHDir ; 3Bh
	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
			; DS:DX	-> ASCIZ directory name	(may include drive)
	xchg	cl,[si]
	jnc	short DIR_NO_DRIVE
	mov	al,[si-1]
	call	PATHCHRCMP
	jnz	short DIR11
	mov	al,[si-2]
	call	PATHCHRCMP
	jz	short DIR12
	xchg	cl,[si-1]
	mov	ah,CHDir ; 3Bh
	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
			; DS:DX	-> ASCIZ directory name	(may include drive)
	xchg	cl,[si-1]
	jnc	short DIR_NO_DRIVE
DIR11:
	mov	ch,':'
	cmp	ch,[si-1]
	jnz	short DIR12
	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
	mov	cx,[bx]
	xchg	cx,si
	sub	cx,si
	cmp	cx,2
	jz	short DIR_NO_DRIVE
DIR12:
	mov	dx,BADCDPTR
	;test	byte [bx+2],4
	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
	jnz	short DIRERROR
DIRNF:
	mov	dx,FNOTFOUNDPTR
DIRERROR:
	jmp	CERROR
DIR_NO_DRIVE:
	cmp	word [si],'..'
	jnz	short DOREALPARSE
	cmp	byte [si+2],0
	jnz	short DOREALPARSE
	inc	word [COMSW]
	jmp	short DOHEADER
DOREALPARSE:
	mov	di,FCB ; 5Ch	
	;mov	ax,290Eh
	mov	ax,(Parse_File_Descriptor<<8)|0Eh
	int	21h	; DOS -	PARSE FILENAME
			; DS:SI	-> string to parse
			; ES:DI	-> buffer to fill with unopened	FCB
			; AL = bit mask	to control parsing
	cmp	byte [si],0
	jz	short DOHEADER
	dec	word [COMSW]
DOHEADER:
		
; Display the header

	push	bx
	call	BUILD_DIR_STRING
	mov	dx,DIRBUF
	mov	[VOL_DIR],dx
	mov	dx,DIRHEADPTR
	call	PRINTF_CRLF
	pop	bx
	cmp	bx,0FFFFh
	jz	short DOSEARCH

; If there were chars left after parse or device, then invalid file name

	cmp	word [COMSW],0
	jz	short DOSEARCH	; nothing left; good parse
	jl	short DIRNFFIX	; not .. => error file not found
	call	RESTUDIR
	mov	dx,BADCDPTR
	jmp	CERROR		; was .. => error directory not found
DIRNFFIX:
	call	RESTUDIR
	jmp	short DIRNF

; We are assured that everything is correct. Let's go and search. Use
; attributes that will include finding directories. Perform the first search
; and reset our directory afterward.

DOSEARCH:
	;mov	byte [55h],0FFh
	mov	byte [FCB-7],0FFh
	;mov	byte [5Bh],10h
	mov	byte [FCB-1],10h

; Caution! Since we are using an extended FCB, we will *also* be returning
; the directory information as an extended FCB. We must bias all fetches into
; DIRBUF by 8 (Extended FCB part + drive)

	mov	ah,Dir_Search_First ; 11h
	mov	dx,FCB-7 ; 55h
	int	21h	; DOS -	SEARCH FIRST USING FCB
			; DS:DX	-> FCB

; Restore the user's directory. We preserve, though, the return from the
; previous system call for later checking.

FOUND_FIRST_FILE:
	push	ax		; save return state
	call	RESTUDIR	; restore user's dir	
	pop	ax		; get return state back

; Main scanning loop. Entry has AL = Search first/next error code. Test for
; no more.

DIRSTART:
	inc	al		; 0FFh = file not found
	jnz	short DISPLAY	; Either an error or we are finished
	jmp	CHKCNT
DISPLAY:
	inc	word [FILECNT]	; Keep track of how many we find
	mov	si,DIRBUF+8	; SI -> information returned by sys call
	;call	SHONAME
	call	DISPLAYNAME
	;test	byte [_BITS],1
	test	byte [_BITS],SWITCHW ; W switch set?
	jz	short DIRTEST	; If so, no size, date, or time
	jmp	NEXENT
DIRTEST:
	;test	byte [DIRBUF_ATTRIB1],10h
	; 14/10/2018
	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
	;test	byte [DIRBUF+19],10h
	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
	jz	short FILEENT
	mov	dx,DMESPTR
	call	STD_PRINTF
	jmp	short NOFSIZ
FILEENT:
	;mov	dx,[DIRBUF_FSIZ_L]
	;mov	dx,[DIRBUF+36]
	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
	mov	[FILESIZE_L],dx
	;mov	dx,[DIRBUF_FSIZ_H]
	;mov	dx,[DIRBUF+38]
	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
	mov	[FILESIZE_H],dx
	mov	dx,FSIZEMESPTR
	call	STD_PRINTF	; Print size of file
NOFSIZ:
	;mov	ax,[DIRBUF_FDATE]  ; Get date
	;mov	ax,[DIRBUF+32]
	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
	or	ax,ax
	jz	short NEXENT	; Skip if no date
	mov	di,CHARBUF
	push	ax
	mov	ax,'  '
	stosw
	pop	ax
	mov	bx,ax
	and	ax,1Fh		; Get day
	mov	dl,al
	mov	ax,bx
	mov	cl,5
	shr	ax,cl		; Align month
	and	al,0Fh		; Get month
	mov	dh,al
	mov	cl,bh
	shr	cl,1		; Align year
	xor	ch,ch
	add	cx,80		; Relative 1980
	cmp	cl,100
	jb	short MILLENIUM
	sub	cl,100
MILLENIUM:
	call	DATE_CXDX
	;mov	cx,[DIRBUF_FTIME]
	;mov	cx,[DIRBUF+30]
	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
	jcxz	PRBUF		; Time field present?
	mov	ax,2020h
	stosw
	shr	cx,1
	shr	cx,1
	shr	cx,1
	shr	cl,1
	shr	cl,1		; Hours in CH, minutes in CL
	mov	bl,[TIME_24]
	or	bl,80h		; Tell P_TIME called from DIR
	call	P_TIME		; Don't care about DX, never used with DIR
PRBUF:
	xor	ax,ax
	stosb
	mov	dx,CHARBUF
	mov	[STRING_PTR_2],dx
	mov	dx,STRINGBUF2PTR
	call	STD_PRINTF
NEXENT:
	dec	byte [LINCNT]
	jnz	short SAMLIN
NEXLIN:
	mov	al,[LINLEN]
	mov	[LINCNT],al
	call	CRLF2
	dec	byte [LINPERPAG]
	jnz	short SCROLL
	;test	byte [_BITS],2
	test	byte [_BITS],SWITCHP ; P switch present?
	jz	short SCROLL	; If not, just continue
	mov	byte [LINPERPAG],23
	call	PAUSE
	jmp	short SCROLL
SAMLIN:
	mov	dx,TABPTR	; Output a tab
	call	STD_PRINTF
SCROLL:
	mov	ah,Dir_Search_Next ; 12h
	;mov	dx,55h
	mov	dx,FCB-7	; DX -> Unopened FCB
	int	21h	; DOS -	SEARCH NEXT USING FCB
			; DS:DX	-> FCB
			; Return: AL = status
	jmp	DIRSTART
CHKCNT:
	test	word [FILECNT],0FFFFh ; -1
	jnz	short TRAILER
	jmp	DIRNF
TRAILER:
	mov	al,[LINLEN]
	cmp	al,[LINCNT]
	jz	short MMESSAGE
	call	CRLF2
MMESSAGE:
	mov	dx,DIRMESPTR
	mov	si,[FILECNT]
	mov	[DIR_NUM],si
	call	STD_PRINTF
DTFREE:
	mov	ah,GET_DRIVE_FREESPACE ; 36h
	;mov	dl,[5Ch]
	mov	dl,[FCB]
	int	21h	; DOS -	2+ - GET DISK SPACE
			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
	cmp	ax,-1
	jnz	short DTFREE1
DTRET:
	retn
DTFREE1:
	mul	cx
	mul	bx
	mov	[BYTES_FREE],ax
	mov	[BYTES_FREE+2],dx
	mov	dx,BYTEMESPTR
	jmp	STD_PRINTF

; =============== S U B	R O U T	I N E =======================================

SHONAME:
DISPLAYNAME:
	; MSDOS 3.3
	mov	di,CHARBUF
	mov	cx,8
	rep	movsb
	mov	al,' '
	stosb
	mov	cx,3
	rep	movsb
	xor	ax,ax
	stosb
	push	dx
	mov	dx,CHARBUF
	mov	[STRING_PTR_2],dx
	mov	dx,STRINGBUF2PTR
	call	STD_PRINTF
	pop	dx
	retn

%endif

;============================================================================
; DIR.ASM, MSDOS 6.0, 1991
;============================================================================
; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 6.0
%if 0

;***	DIR.ASM - DIR internal command

comment	% =================================================================

This module replaces TCMD1A.ASM.  The old module was titled 
"PART4 COMMAND Transient routines".

From residual documentation, I surmise that TCMD.ASM originally
contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
VER.  The file seems to have been successively split:

  TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B

TCMD1A.ASM contained only the DIR command.

Usage:
------

DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>

DIR /?


<filespec> may include any or none of:  drive; directory path;
           wildcarded filename.  If drive or directory path are
	   omitted, the current defaults are used.  If the
	   file name or extension is omitted, wildcards are
	   assumed.

/w	Wide listing format.  Files are displayed in compressed
	'name.ext' format.  Subdirectory files are enclosed in
	brackets, '[dirname]'.

/p	Paged, or prompted listing.  A screenful is displayed
	at a time.  The name of the directory being listed appears
	at the top of each page.

	Bugbug:  pages nead to be uniform length..?

/b	Bare listing format.  Turns off /w or /p.  Files are 
	listed in compressed 'name.ext' format, one per line,
	without additional information.  Good for making batch
	files or for piping.  When used with /s, complete
	pathnames are listed.

/s	Descend subdirectory tree.  Performs command on current
	or specified directory, then for each subdirectory below
	that directory.  Directory header and footer is displayed
	for each directory where matching files are found, unless
	used with /b.  /b suppresses headers and footers.

	Tree is explored depth first, alphabetically within the
	same level.

	Bugbug:  hidden directories aren't searched.

/l	Display file names, extensions and paths in lowercase.	;M010

/c	Display file compression ratio, if the file is on a MagicDrv
	compressed volume.

/o	Sort order.  /o alone sorts by default order (dirs-first, name,
	extension).  A sort order may be specified after /o.  Any of
	the following characters may be used: nedsgc (name, extension,
	date/time, size, group-dirs-first, compression ratio).	Placing
	a '-' before any letter causes a downward sort on that field.
	E.g., /oe-d means sort first by extension in alphabetical order,
	then within each extension sort by date and time in reverse
	chronological order.

/a	Attribute selection.  Without /a, hidden and system files
	are suppressed from the listing.  With /a alone, all files
	are listed.  An attribute list may follow /a, consisting of
	any of the following characters:  hsdar (hidden, system,
	directory, archive, read-only).  A '-' before any letter
	means 'not' that attribute.  E.g., /ar-d means files that
	are marked read-only and are not directory files.  Note
	that hidden or system files may be included in the listing.
	They are suppressed without /a but are treated like any other
	attribute with /a.

/?	Help listing.  Display DIR useage information.	;M008;Handled externally

/h has been removed.					;M008

DIRCMD	An environment variable named DIRCMD is parsed before the
	DIR command line.  Any command line options may be specified
	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
	A filespec may be specified in DIRCMD and will be used unless
	a filespec is specified on the command line.  Any switch
	specified in DIRCMD may be overridden on the command line.
	If the original DIR default action is desired for a particular
	switch, the switch letter may be preceded by a '-' on the
	command line.  E.g.,

	  /-w	use long listing format
	  /-p	don't page the listing
	  /-b	don't use bare format
	  /-s	don't descend subdirectory tree
	  /-o	display files in disk order
	  /-a	suppress hidden and system files

Notes:
------

For sorted listings, file entries are loaded into the TPA buffer, which
is usually about 64K in size.  This allows sorts of up to 3000 files at
a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
The byte after the last entry is 0FFh.  The first byte of each entry is
a flag byte which is made zero when the entry is loaded, and made one
when the entry is used.

Revision History
================
M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
				in the absence of ANSI.SYS

M007	sa	8/1/90		Allow /p/b combination

M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
				to internally handle /? message.

M010	sa	8/5/90		Add support for /l (lowercase) option.

M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
				first FCB with the drive number when the drive
				letter in the command line is preceded by a
				switch.  Now dir manually loads the drive
				number after parsing.

M018	md	8/12/90 	Increment the screen height by 1 when obtained
				from the ROM BIOS.

M023	sa	8/31/90		Prevent DIR from failing if it encounters
				a subdirectory having len(pathname)>MAXPATH.
				Just skip over that subdirectory.

M028	dbo	9/24/90		When country=US, sort by strict character
				byte value, rather than collating table.
				This to match MS-DOS Shell's sort order.

========================================================================= %

%endif

; 16/02/2023

NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list

;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
;
;		on/off bit record for /l, /b, /s, /p, /w, /c options
;		(order is hard-coded; see OnOffSw)
;		Inmem is set when entries are loaded in memory.

; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
mask.wide  equ 1
mask.pagd  equ 2
mask.subd  equ 4
mask.bare  equ 8
mask.lcase equ 16
mask.inmem equ 32
;
mask.dev    equ 1
mask.baddir equ 2	

NUM_ATTR_LTRS	equ	6	; length of attribute letter list

NUM_ORDER_LTRS	equ	5	; length of sort order letter list

;ResultBuffer	struc		; structure of parse result buffer
;ValueType	db	?
;ValueTag	db	?
;SynPtr		dw	?
;ValuePtr	dd	?
;ResultBuffer	ends

;ErrorRec	record	baddir:1,dev:1
;
;		Error bits are:
;		  Invalid directory format
;		  File is device

;EntryStruc	struc			; our private directory entry structure
;used		db	?		; =0 until entry used, then =1
;filename	db	8 dup (?)	; filename
;fileext	db	3 dup (?)	; extension
;fileattr	db	?		; file attributes
;filetime	dw	?		; file time
;filedate	dw	?		; file date
;filesize	dd	?		; file size
;EntryStruc	ends

;shove	macro	val		; hose-bag 8086 doesn't push immediate
;	mov	ax,val		; invisible, dangerous use of AX!
;	push	ax
;	endm

;	public	Catalog		; our entry point
;
;	break	<DIR (Catalog) principal routines>
;
;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
; ---------------------------------------------------------------------------
;	Bugbug:	Each routine should start with it's own ASSUME.

;----------------------------------------------------------------------------
;----------------------------------------------------------------------------

; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh

;***	Catalog - DIR command main routine
;
;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
;		Cmd-line tail text is at 81h, terminated by 0Dh
;		CS, DS, ES, SS = TRANGROUP seg addr
;		Tpa = TPA buffer seg addr
;		BytCnt = # bytes in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;
;	ERROR EXITS
;
;	  Errors are handled by setting up error message pointers
;	   for Std_EPrintf and jumping to CError. Syntax errors in
;	   the environment variable, however, are handled by printing
;	   an error message and continuing.
;
;	EFFECTS
;
;	  Directory listing is displayed (on standard output).
;	  APPEND is disabled. HeadFix routine is expected to
;	   restore APPEND state.
;	  Working directory may be changed. The user's default
;	   directory is saved and flagged for restoration by RestUDir
;	   during COMMAND cycle.
;	  Lots of variables may be changed in TRANSPACE segment.
;
;	NOTES
;
;	  ES = TRANGROUP seg addr except when used to address the
;	   the TPA buffer, where directory entries are loaded from disk.

	; 16/02/2023
CATALOG:
	call	SetDefaults
	call	ParseEnvironment
	call	ParseCmdLine
	jnc	short catalog1	; no parse error
	jmp	catErr		; error msg is set up
catalog1:
	call	SetOptions
	call	SetCollatingTable

;	Drive # to operate on has already been placed in FCB by
;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.

	;;;test	Bits,mask bare
	;;test 	word [_Bits],8
	;test	byte [_Bits],8
	test	byte [_Bits],mask.bare
	jnz	short catalog2	; don't display volume info for /b
	;invoke	OkVolArg	; find & display volume info
	call	OkVolArg
	;sub	byte [LeftOnpage],2
	sub	word [LeftOnPage],2
				; record display lines used by volume info
	jmp	short catCrunch

;	OkVolArg side effects:
;	APPEND is disabled;
;	DTA established at DirBuf;
;	Filename fields in FCB are wildcarded.

catalog2:
;	OkVolArg wasn't executed, so we have to do these ourselves.

	;invoke	DisAppend	; disable APPEND
	call	DisAppend

	;mov	dx,offset TRANGROUP:DirBuf
	mov	dx,DIRBUF
	mov	ah,1Ah
	;mov	ah,Set_DMA
	int	21h		; set DTA

	mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
	inc	di		; ES:DI = ptr to filename field of FCB
	mov	al,'?'		; AL = wildcard character
	mov	cx,11
	rep	stosb		; wildcard filename field

catCrunch:
	call	CrunchPath	; crunch pathname to get directory and filename
	jc	short catRecErr	; handle recorded or extended error

;	User's directory has been saved, we've changed to specified directory.
;	ComSw = error bits for later use
;	FCB contains parsed filename

	;cmp	byte [COMSW],0
	cmp	word [COMSW],0
	jne	short catRecErr	; handle recorded error

	call	InstallCtrlC	; install control-C handler
	call	ZeroTotals	; zero grand totals
	call	ListDir		; list main directory
	jc	short catExtErr

	;;;test	Bits,mask subd
	;;test	word [_Bits],4
	;test	byte [_Bits],4
	test	byte [_Bits],mask.subd
	jz	short catalog3	; subdirectories option not set
	call	ListSubds	; list subdirectories
	jc	short catExtErr
catalog3:
;	Check if any files were found.

	;;;test	Bits,mask bare
	;;test	word [_Bits],8
	;test	byte [_Bits],8
	test	byte [_Bits],mask.bare
	jnz	short catRet	; don't bother for bare format

	mov	ax,[FileCntTotal]
	or	ax,ax
	jz	short catNoFiles ; no files found

	call	DisplayTotals	; display trailing grand totals
	;jmp	short catRet	; all done
	; 25/04/2023
catRet:
	retn

catRecErr:

;	ComSw may have error bit set. If not, do extended error.

	;;;test	ComSw,mask dev
	;;test	word [COMSW],1
	;test	byte [COMSW],1
	test	byte [COMSW],mask.dev
	jnz	short catNoFiles 
				; filename is device, respond 'file not found'
	;;test	ComSw,mask baddir
	;;test	word [COMSW],2
	;test	byte [COMSW],2
	test	byte [COMSW],mask.baddir
	jz	short catExtErr	; no ComSw error bits, must be extended error
	;mov	dx,offset TRANGROUP:BadCd_Ptr
				; invalid directory
	mov	dx,badcd_ptr
	jmp	short catErr

catNoFiles:

;	Display header and force 'file not found' message.

	call	DisplayHeader
	mov	ax,ERROR_FILE_NOT_FOUND ; 2
	mov	byte [msg_disp_class],ext_msg_class ; 1
	mov	dx,extend_buf_ptr
	mov	[extend_buf_ptr],ax
	jmp	short catErr

catExtErr:

;	DOS has returned an error status. Get the extended error#, and
;	set up an error message, changing 'No more files' error 
;	to 'File not found' error.

	call	Set_Ext_Error_Msg
	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
	jne	short catalog4  ; catErr
	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
catalog4:

;	Error exit. Error message information has been set up
;	for Std_EPrintf.

catErr:
	jmp	cerror		; go to COMMAND error recycle point

	; 25/04/2023
;catRet:
	;retn

; ---------------------------------------------------------------------------

;***	SetDefaults - set default pathname, options
;
;	ENTRY	DS = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,DI
;
;	EFFECTS
;	  SrcBuf = '*',EOL - default pathname
;	  PathPos = ptr to pathname
;	  PathCnt = length of pathname

	; 16/02/2023
SetDefaults:
	mov	di,SrcBuf		; DI = ptr to pathname buffer
	mov	[PathPos],di		; PathPos = ptr to pathname
	;mov	al,STAR
	mov	al,'*'
	stosb
	;mov	al,END_OF_LINE_IN
	mov	al,0Dh ; cr
	stosb				; SrcBuf = '*',0Dh
	mov	word [PathCnt],1	; PathCnt = pathname length

	xor	ax,ax			; AX = 0
	mov	[COMSW],ax		; = no error
	mov	[_Bits],ax		; = options off
	mov	[DestBuf],al		; = no sort
	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
	mov	[AttrSelect],al		; exclude hidden, system files
peRet:	; 25/04/2023
	retn

; ---------------------------------------------------------------------------

;***	ParseEnvironment - find and parse our environment variable
;
;	Find our environment variable and parse it. If a parse
;	error occurs, issue an error message. The parse results
;	up to the error will still have effect. Always leave
;	the option variables in a useable state.
;
;	ENTRY	DS = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If a parse error occurred, an error message will be issued.

	; 16/02/2023
ParseEnvironment:
	call	GetEnvValue		; get environment variable value
	jc	short peRet		; name not found in environment

;	SI = ptr to value of environment variable, in TRANGROUP seg

	call	Parse_Line		; parse environment value
	cmp	ax,-1 ; 0FFFFh
	;cmp	ax,END_OF_LINE
	je	short peRet		; successful completion

;	Some kind of parse error occurred.
;	We're set up for a Std_EPrintf call.

	call	std_eprintf		; display the parse error
	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
					; restore default msg class
	mov	byte [msg_disp_class],0FFh ; -1
	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
	mov	dx,errparsenv_ptr
	;;invoke Printf_Crlf		; "(Error occurred in environment.."
	;call	Printf_Crlf
	; 25/04/2023
	;retn
	jmp	Printf_Crlf
					;M008;Internal handling of /? removed
;peOk:	and	Bits,not mask help	; disallow /h in environment variable
	; 25/04/2023
;peRet:
	;retn

; ---------------------------------------------------------------------------

;***	ParseCmdLine - parse and record command line parameters
;
;	ENTRY	PSP offset 81h is beginning of cmd line buffer
;		DS, ES, CS = TRANGROUP seg addr
;
;	EXIT	CY = set if parse error occurred
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		AX = system parser error code
;		DX = ptr to message block
;
;	USED	AX,BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

	; 16/02/2023
ParseCmdLine:
	mov	si,81h			; SI = ptr to cmd-line tail text
	call	Parse_Line		; parse cmd line tail
	cmp	ax,-1 ; 0FFFFh
	;;cmp	ax,END_OF_LINE
	; 25/04/2023
	;je	short pcOk		; parse completed successfully

;	A parse error occurred. We're all set up for message output.

	; 25/04/2023
	; cf = 1 (ax < 0FFFFh)
	;stc		   		; return failure
	;jmp	short pcRet
	; 25/04/2023
	;retn
pcOk:
	; 25/04/2023
	;cf = 0 (ax = 0FFFFh)
	;clc				; return success
pcRet:
	retn

; ---------------------------------------------------------------------------

;***	SetCollatingTable - set up character collating table for sorting
;
;	If country is other than USA, try to get a collating table
;	for character sorting. For USA, use straight byte values.
;	This is so DIR behaves like the MS-DOS Shell, which sorts
;	by straight byte values in the USA for better performance.
;
;	ENTRY	ES = TRANGROUP seg addr
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX,DI
;
;	EFFECTS
;
;	  If collating table is set -
;	    CountryPtrId = 6.
;	    CountryPtr points to collating table.
;
;	  Otherwise -
;	    CountryPtrId = 0.

SetCollatingTable:

;	Begin modification M028

	;mov	dx,offset TRANGROUP:InternatVars
	;			; DS:DX = ptr to international info buffer
	mov	dx,INTERNATVARS
	mov	ax,3800h
	;mov	ax,INTERNATIONAL << 8
	;;mov	ax,INTERNATIONAL shl 8
				; AX = 'Get current country info'
	int	21h		; call DOS
	jc	short scNoTable	; error - so don't collate

;	BX = country code

	cmp	bx,1
	je	short scNoTable	; we're in USA, don't collate

;	End modification M028

;*	Country code is other than USA. Try to get a collating table.

	mov	ax,6506h
	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
				; AH = 'Get Extended Country Info'
				; AL = 'Get Pointer to Collating Table'
	mov	bx,-1		; BX = code page of interest = CON
	mov	cx,5		; CX = length of info buffer
	mov	dx,bx		; DX = country ID = default
	;mov	di,offset TRANGROUP:CountryPtrInfo
	mov	di,CountryPtrInfo
				; ES:DI = ptr to info buffer
	int	21h		; call DOS
	jnc	short scRet	; success

;*	Set CountryPtrId = 0 to signal no collating table.

scNoTable:			;M028
	mov	byte [CountryPtrId],0
scRet:
	retn

; ---------------------------------------------------------------------------

;***	SetOptions - check and set options
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX,CX,DX
;
;	EFFECTS
;
;	  Bits may contain modified option settings.
;	  Display_Ioctl table, including LinPerPag variable, is filled in.
;	  LeftOnPage is initialized to # lines till end of page is handled.
;	  PerLine is set according to /w presence.

	; 16/02/2023
SetOptions:

;	If bare listing requested, cancel wide listings.

	;;;test	Bits,mask bare
	;;test	word [_Bits],8
	;test	byte [_Bits],8
	test	byte [_Bits],mask.bare
	jz	short setopts1
	;;;and	Bits,not mask wide	;M007;Allow /p with /b
	;;and	word [_Bits],0FFFEh
	;;and	byte [_Bits],0FEh
	and	byte [_Bits],~mask.wide ; 0FEh
setopts1:
;	Set # lines per display page.

;M01  Obtain screen height from ROM BIOS data area
;
;M01	mov	LinPerPag,LINESPERPAGE	; default value

	push	ds
	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
	mov	ax,40h
	mov	ds,ax			;
	;Assume	DS:ROMBIOS_DATA

	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
	mov	al,[84h]
	pop	ds			;
	;Assume	DS:Trangroup

	or	al,al			; If zero specified
	jnz	short setopts2		;

	;mov	al,LINESPERPAGE 	; assume 24 rows
	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
setopts2:
	xor	ah,ah
setopts3:
	inc	al			; height + 1 ;M018

	mov	[LinPerPag],ax		; set the rows now

; Now the console driver can change the rows if it knows better (M01 end)

	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE 
					; IOCTL for handles
	mov	ax,440Ch
	;mov	bx,STDOUT		; handle #
	mov	bx,1
	;mov	ch,IOC_SC		; screen
	mov	ch,3
	;mov	cl,get_generic		; get display info
	mov	cl,7Fh
	mov	dx,Display_Ioctl	; info block
	int	21h			; call DOS

	mov	ax,[LinPerPag]		; AX = # lines per page
	mov	[LeftOnPage],ax		; initialize # lines left on page

;	Set # entries per line.

	;mov	byte [PerLine],NORMPERLIN
					; # entries per line without /w
	mov	byte [PerLine],1
	;;;test	Bits,mask wide
	;;test	word [_Bits],1
	;test	byte [_Bits],1
	test	byte [_Bits],mask.wide
	jz	short setopts4
	;mov	byte [PerLine],WIDEPERLIN
					; # entries per line with /w
	mov	byte [PerLine],5
setopts4:
				;M011;start;The following code checks if a drive
				;letter has been parsed into SrcBuf, and if
				;so, the correct drive number is loaded into
				;the first FCB, at offset 5C.

	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
	cmp	byte [SrcBuf+1],':'
	jne	short soRet
	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
	mov	al,[SrcBuf]
	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
	and	al,0DFh ; ~20h ; not 20h
	sub	al,'@'				; convert to 1-based number (1=A)
	mov	[FCB],al  ; [5Ch]		; store in first FCB
						;M011;end
soRet:
	retn

; ---------------------------------------------------------------------------

;***	CrunchPath - analyze supplied or default pathname
;
;	ENTRY	PathPos = ptr to pathname buffer
;		PathCnt = length of pathname, not incl trailing delimiter
;		Pathname in buffer must end in delimiter (like CR) and
;		 must have space for another char after the delimiter.
;
;	EXIT	CY = clear if no error
;		We are changed to directory found in pathname
;		Previous directory ready to be restored via RestUDir
;		FCB filename fields contain filename (possibly w/ wildcards)
;
;		If error occurred,
;		CY = set
;		ComSw = error bits (see ErrorRec)
;		If ComSw not set,
;		Ready for DOS Get Extended Error call

	; 16/02/2023
CrunchPath:
	call	FileIsDevice
	jne	short crpath1	; not a device, skip ahead
	;;;or	ComSw,mask dev	; signal file is device
	;;or	word [COMSW],1
	;or	byte [COMSW],1
	or	byte [COMSW],mask.dev
	jmp	short cpErr	; return error
crpath1:
	push	word [PathPos]	; save ptr to pathname
	mov	byte [DirFlag],-1
				; tell PathCrunch not to parse file into FCB
	call	PathCrunch	; change to directory in pathname
	mov	byte [DirFlag],0
				; reset our little flag
	pop	si		; SI = ptr to pathname
	jc	short cpNoDir	; didn't find directory path
	jz	short cpRet	; found directory path w/ no filename
				;  - leave wildcard default in FCB and return

;*	We found a directory, and there was a filename attached.
;	DestTail = ptr to ASCIIZ filename

	mov	si,[DestTail]	; SI = ptr to filename
	jmp	short cpFile	; go parse the file into FCB

;*	PathCrunch failed to find a directory in the pathname.
;
;	Msg_Numb = error code
;	DestIsDir = nonzero if path delimiter char's occur in pathname
;	SI = ptr to pathname (now an ASCIIZ string)

cpNoDir:
	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
	or	ax,ax
	jnz	short cpErr	  ; error occurred - return it
	cmp	byte [DestIsDir],0
	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
crpath3:
	;;;or	ComSw,mask baddir ; signal invalid directory name
	;;or	word [COMSW],2
	;or	byte [COMSW],2
	or	byte [COMSW],mask.baddir
	;jmp	short cpErr	  ; return error
	; 16/02/2023
cpErr:
	stc			  ; return error
cpRet:
	retn

cpMaybe:
;	SI = ptr to pathname

	;cmp	byte [si+1],COLON_CHAR
	cmp	byte [si+1],':'
	jne	short crpath2	  ; no drive specifier, skip ahead
	lodsw			  ; SI = ptr past drive specifier "d:"
crpath2:
	cmp	word [si],".."
	jne	short cpFile	  ; if not "..", treat as a file
	cmp	byte [si+2],0
	;jne	short cpFile	  ; or if there's more after "..", treat as file
	;;;;or	ComSw,mask baddir ; signal invalid directory
	;;;or	word [COMSW],2
	;;or	byte [COMSW],2
	;or	byte [COMSW],mask.baddir
	;jmp	short cpErr	  ; return error
	; 16/02/2023
	je	short crpath3

;	The preceding code was taken from the old DIR routine.
;	It's garbage, I'm afraid. It's meant to check for ".."
;	occurring when we're at the root directory. Too bad it
;	doesn't handle problems with "..\..", etc.

;	We're ready to parse a filename into the FCB.
;	SI = ptr to ASCIIZ filename

cpFile:	
	mov	di,FCB	; 5Ch	; DI = ptr to FCB
	mov	ax,290Eh
	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
				; wildcards already in FCB used as defaults
	int	21h
	clc			; return success
	;jmp	short cpRet
	; 16/02/2023
	retn

;cpErr:
;	stc			; return error
;cpRet:
;	retn

; ---------------------------------------------------------------------------

;***	InstallCtrlC - install our private control-C handler
;
;	Put our control-c handler in front of command.com's default
;	handler, to make sure the user's default directory gets restored.
;	This shouldn't be necessary, but, for now, there are situations
;	where the TDATA segment is left in a modified state when a
;	control-c occurs.  This means that the transient will be
;	reloaded, and the user's directory cannot be restored.
;
;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX,DX
;
;	EFFECTS
;
;	  CtrlCHandler address placed in int 23 vector.
;
;	NOTE
;
;	  Command.com's basic control-c handler will be restored
;	  to the int 23 vector by the HeadFix routine, after DIR finishes.

	; 16/02/2023
InstallCtrlC:
	push	es			; preserve ES
	mov	ax,3523h
	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
	int	21h
	mov	[OldCtrlCHandler],bx	; save old int 23 vector
	mov	[OldCtrlCHandler+2],es	 
	pop	es			; restore ES

	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
	mov	ax,2523h
	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
	int	21h
	retn

; ---------------------------------------------------------------------------

;***	ListSubds - search and list files in subdirectories
;
;	ENTRY	Current directory (on selected drive) is top of subdir tree
;		FCB is still set up for file searches
;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
;
;	EXIT	CY = clear if no error
;		FileCnt = # files found & displayed
;		FileSiz = total size of files found
;
;		If error,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  FileCntTotal, FileSizTotal are updated.
;	  Subdirectories may be listed on standard output device.
;
;	NOTES
;
;	  ListSubds seeds the recursive entry point lsNode with a ptr
;	   to a buffer where we'll stack up subdirectory filenames.
;	   Each name is stored ASCIIZ.

	; 16/02/2023
ListSubds:
	;invoke	SetRest1		; make sure user's dir gets restored
	call	SetRest1

	mov	bx,ScanBuf   		; BX = ptr to child name buffer
lsNode:
	mov	byte [bx],0		; start with null child name
lsLoop:
	call	FindNextChild		; search for next subdirectory
	jc	short lsErr		; search failed - examine error

	mov	dx,bx			; DX = ptr to child's name
	call	ChangeDir		; enter child directory

					; M023;start
	jnc	short lstsd1		; check for error
	;cmp	ax,3
	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
	je	short lsLoop		; yes, skip over this subdirectory
	;jmp	short lsRet		; no, other error: DIR must fail
	; 16/02/2023			; M023;end
	retn
lstsd1:	
	push	bx
	call	ListDir			; list the directory
	pop	bx

;	Note we're ignoring errors returned here.

	mov	di,bx			; DI = ptr to child's name
	mov	cx,13			; CX = max name length w/ null
	xor	al,al			; AL = zero byte to look for
	repne	scasb			; DI = ptr to next name pos'n in buf
	push	bx			; save ptr to child's name
	mov	bx,di			; BX = ptr to next name pos'n in buf
	call	lsNode			; recurse from new node
	pop	bx			; BX = ptr to child's name
	pushf				; save error condition
	
	;;shove	0
	;mov	ax,0
	sub	ax,ax ; 0
	push	ax
	;shove	".."
	mov	ax,'..'  ; 2E2Eh
	push	ax
	mov	dx,sp			; DX = ptr to "..",0 on stack
	call	ChangeDir		; return to parent directory
	pop	ax			; restore stack
	pop	ax

	popf				; restore error condition from child
	;jc	short lsRet		; return error
	;jmp	short lsLoop		; look for more children
	; 16/02/2023
	jnc	short lsLoop
	retn
lsErr:
	call	get_ext_error_number	; AX = extended error code
	;cmp	ax,2
	cmp	ax,ERROR_FILE_NOT_FOUND
	je	short lsRet		; file not found, we're ok
	;cmp	ax,18
	cmp	ax,ERROR_NO_MORE_FILES
	je	short lsRet		; no more files, we're ok
	stc				; return other errors
lsRet:	
	retn

; ---------------------------------------------------------------------------

	;break	<DIR support routines>

;***	SUPPORT ROUTINES

; ----------------------

;***	CheckChild - check potential subdirectory name for FindNextChild
;
;	ENTRY	DirBuf contains DOS Find-buffer with potential child
;		BX = ptr to last child's name
;		BP = ptr to temp child's name
;
;	EXIT	nothing
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename pointed to by BP may be changed.
;
;	NOTES
;
;	  Potential filename replaces temp filename if:
;	   it's a subdirectory file;
;	   it doesn't start with a '.';
;	   it's alphanumerically greater than last child's name;
;	   and it's alphanumerically less than temp name.

	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
	; 07/06/2023
CheckChild:
	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
	jz	short ccRet	; not a subdirectory file- return

	; 16/02/2023
	mov	si,DIRBUF+FIND_BUF.PNAME
	cmp	byte [si],'.'
	;;cmp	DirBuf.find_buf_pname,'.'
	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
	je	short ccRet	; starts with a dot- return

	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	;mov	si,DIRBUF+FIND_BUF.PNAME
	mov	di,bx
	call	CmpAscz		; compare candidate to last child's name
	jna	short ccRet	; it's not above it- return


	; 07/06/2023
	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	;mov	si,DIRBUF+FIND_BUF.PNAME
	; si = DIRBUF+FIND_BUF.PNAME
	mov	di,bp
	call	CmpAscz		; compare candidate to temp name
	jnb	short ccRet	; it's not below it- return

;	New kid is alright. Copy to temp.

	; 07/06/2023
	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
	;mov	si,DIRBUF+FIND_BUF.PNAME
	; si = DIRBUF+FIND_BUF.PNAME
	mov	di,bp
	mov	cx,13
	rep	movsb
ccRet:
	retn

; ---------------------------------------------------------------------------

;***	CmpEntry - compare one directory entry to another in sort order
;
;	Compare one directory entry against another according to
;	the sort codes in DestBuf. One or more comparisons
;	may be made of file name, extension, time/date, and
;	size.  Comparisons may be made for upward or downward
;	sort order.
;
;	ENTRY	ES:BX = ptr to entry to compare
;		ES:BP = ptr to entry to be compared against
;		DestBuf contains sort codes (see DestBuf)
;		DS = TRANGROUP seg addr
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry against BP entry.
;		 'Same, above, below' translate to 'same, after, before'.
;
;	USED:	AX,CX,DX,SI,DI

	; 16/02/2023
CmpEntry:
	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
ceLoop:
	xor	ax,ax		; AX = 0
	mov	al,[si]		; AL = sort code
	or	al,al
	jz	short ceDone	; sort code is zero, we're done
	inc	si		; DS:SI = ptr to next sort code
	push	si		; save ptr to next sort code
	dec	al
	shl	al,1
	;sal	al,1		; AX = index into cmp call table
				; CY set for downward sort order
	mov	si,ax		; SI = index into cmp call table
	mov	ax,[cs:si+FieldCmps]
				; AX = addr of compare routine
	jc	short ceDn	; downwards sort - go swap entries
	call	ax 		; do upwards sort
	jmp	short ceNs
ceDn:
	xchg	bx,bp		; swap entry ptrs for downward sort order
	call	ax		; do sort
	xchg	bx,bp		; swap ptrs back
ceNs:
	pop	si		; SI = ptr to next sort code
	je	short ceLoop	; compare showed no difference, keep trying
ceDone:

;	Get here either from unequal compare or sort code = 0.
;	In the latter case, condition codes indicate equality,
;	which is correct.

	retn

	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)

FieldCmps:		; call table of entry comparisons
	dw	CmpName
	dw	CmpExt
	dw	CmpTime
	dw	CmpSize
	dw	CmpType

; ---------------------------------------------------------------------------

;***	CmpName - compare file name of two entries
;***	CmpExt - compare extension of two entries
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		comparing BX entry to BP entry.
;
;	USED:	AX,CX,DX,SI,DI

	; 16/02/2023
CmpName:
	mov	si,bx		; ES:SI = ptr to BX entry
	mov	di,bp		; ES:DI = ptr to BP entry
	;;add	si,filename	; ES:SI = ptr to BX name
	;add	si,1
	; 25/04/2023
	inc	si
	;;add	di,filename	; ES:DI = ptr to BP name
	;add	di,1
	; 25/04/2023
	inc	di
	;mov	cx,size filename
				; CX = length of name
	mov	cx,8
	jmp	short CmpStr

CmpExt:
	; 07/06/2023
	;mov	si,bx		; ES:SI = ptr to BX entry
	;mov	di,bp		; ES:DI = ptr to BP entry
	;;add	si,fileext	; ES:SI = ptr to BX extension
	;add	si,9
	;;add	di,fileext	; ES:DI = ptr to BP extension
	;add	di,9
	;
	mov	si,9
	mov	di,si ; mov di,9
	add	si,bx
	add	di,bp
	;
	;mov	cx,size fileext	; CX = length of extension field
	mov	cx,3

;	Bugbug:	use symbol for subfunction code.

CmpStr:	
	cmp	byte [CountryPtrId],6
	jne	short cnNoCollTable
				; no collating table available

;*	Compare strings using collating table.
;
;	ES:SI = ptr to 1st string
;	ES:DI = ptr to 2nd string
;	CX = length

	push	bp		; preserve BP
	push	bx		; preserve BX
	push	ds		; preserve DS
	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
	;assume	ds:NOTHING
	mov	bp,[bx]		; BP = size of collating table
	inc	bx
	inc	bx		; DS:BX = ptr to collating values
				; DS:[BX]-2 = size of table
	xor	ax,ax		; AX = 0 for starters

;	Bugbug:	Investigate removing collating table length checks.

cnNextChar:
	mov	al,[es:di]	; AL = AX = char from 2nd string
	inc	di		; ES:DI = ptr to next char 2nd string
	cmp	ax,bp		; compare to collating table length
	jae	short cn1 	; char not in table
	xlat				
cn1:				; AL = AX = collating value
	mov	dx,ax		; DX = collating value from 2nd string
	;lods	byte ptr es:[si]
	es	lodsb		; AL = AX = char from 1st string
				; ES:SI = ptr to next char 1st string
	cmp	ax,bp		; compare to collating table length
	jae	short cn2	; char not in table
	xlat				
cn2:				; AL = AX = collating value
	cmp	ax,dx		; compare collating values
	loope	cnNextChar	; until unequal or no more left

	pop	ds		; restore DS
	;assume	ds:TRANGROUP
	pop	bx		; restore BX
	pop	bp		; restore BP
	retn

;*	If no collating table is available, simply compare raw ASCII values.
;	Don't we wish we could just do this all the time?  Sigh.

	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
cnNoCollTable:
	;repe	cmps byte ptr es:[si],[di]
				;db 0F3h,26h,0A6h,0C3h
	repe	; 0F3h
	es	; 26h
	cmpsb	; 0A6h
	retn	; 0C3h

; ---------------------------------------------------------------------------

;***	CmpTime - compare entries by date/time
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	CX,SI,DI
;
;	NOTE	Filetime and filedate fields in our private entry
;		structure must be adjacent and in that order.

	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
	; 07/06/2023
CmpTime:
	mov	si,bx
	mov	di,bp
	;add	si,filedate + size filedate - 1
	add	si,16 ; 15+2-1
	;add	di,filedate + size filedate - 1
	add	di,16 ; 15+2-1
	; 07/06/2023
	mov	si,16
CmpST2:		; 07/06/2023
	mov	di,si	; mov di,16
	add	si,bx
	add	di,bp

	;mov	cx,size filetime + size filedate
	mov	cx,4 ; 2+2
	std
	;repe	cmps byte ptr es:[si],[di]
				;db 0F3h,26h,0A6h, 0FCh,0C3h
	repe	; 0F3h
	es	; 26h
	cmpsb	; 0A6h
	
	cld	; 0FCh
	retn	; 0C3h

; ---------------------------------------------------------------------------

;***	CmpSize - compare entries by size
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	CX,SI,DI

	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
	; 07/06/2023
CmpSize:
	;mov	si,bx
	;mov	di,bp
	;;add	si,filesize + size filesize - 1
	;add	si,20  ; 17+4-1
	;;add	di,filesize + size filesize - 1
	;add	di,20  ; 17+4-1
	; 07/06/2023
	mov	si,20
	;;;
	jmp	short CmpST2 ; 07/06/2023
	;;;
;CmpST2:
;	mov	di,si	; mov di,20
;	add	si,bx
;	add	di,bp
;
;	;mov	cx,size filesize
;	mov	cx,4
;	std
;	;repe	cmps byte ptr es:[si],[di]
;				;db 0F3h,26h,0A6h
;	repe	; 0F3h
;	es	; 26h
;	cmpsb	; 0A6h
;
;	cld
;	retn

; ---------------------------------------------------------------------------

;***	CmpType - compare entries by file type (subdirectory or not)
;
;	ENTRY	ES:BX = ptr to one entry
;		ES:BP = ptr to another entry
;
;	EXIT	BX = unchanged
;		BP = unchanged
;		Condition flags set for same, above, or below
;		 comparing BX entry to BP entry.
;
;	USED:	AX

	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
CmpType:
	;mov	al,es:[bx].fileattr
	mov	al,[es:bx+12]
	;mov	ah,es:[bp].fileattr
	mov	ah,[es:bp+12]
	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
	;and	ax,1010h
	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
	cmp	ah,al
	retn

; ---------------------------------------------------------------------------

;***	DefaultAttr - set default attribute conditions
;
;	ENTRY	nothing
;
;	EXIT	CY clear
;
;	USED
;
;	EFFECTS
;
;	  AttrSpecified, AttrSelect are updated with new attribute conditions.

	; 16/02/2023
DefaultAttr:
	;mov	byte [AttrSpecified],6
	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
					; specify H and S
	mov	byte [AttrSelect],0	; H and S must be off
	clc				; return success
dtRet:	; 18/02/2023
	retn

; ---------------------------------------------------------------------------

;***	DisplayTotals - display grand total stats
;
;	If we searched subdirectories, display the total # files found
;	 and total size of files found.
;	Display disk space remaining.
;
;	ENTRY	FileCntTotal, FileSizTotal contain correct values
;		Bits contains setting of /s
;		FCB contains drive #
;
;	EXIT	nothing
;
;	USES	AX,DX
;		FileSiz

	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h

DisplayTotals:
	;;;test	Bits,mask subd
	;;test	word [_Bits],4
	;test	byte [_Bits],4
	test	byte [_Bits],mask.subd
	jz	short dtFree		; no subdirectories- do bytes free

	call	CRLF2			; start on new line
	call	UseLine

	mov	dx,total_ptr
	call	std_printf		; "Total:",cr,lf
	call	UseLine

	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
	mov	si,FileSizTotal
	mov	di,FileSiz
	movsw
	movsw				; move total size to size variable
	call	DisplayCntSiz		; display file count & size &
dtFree: 				;   (maybe) compression ratio
	mov	ah,36h
	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
	mov	dl,[FCB] ; [5Ch]	; DL = drive#
	int	21h			; call DOS
	cmp	ax,-1			; check 'invalid drive' return code
	jz	short dtRet		; can't get drive space - return
	mul	cx
	mul	bx
	mov	[Bytes_Free],ax
	mov	[Bytes_Free+2],dx
	mov	dx,bytmes_ptr
	call	std_printf		; "nnn bytes free",cr,lf
	;call	UseLine
;dtRet:
	;retn
	; 18/02/2023
	jmp	UseLine

; ---------------------------------------------------------------------------

;***	FileIsDevice - see if file looks like a device
;
;	ENTRY	PathPos = ptr to pathname
;		PathCnt = length of pathname w/o terminating char
;		DirBuf is DOS DTA
;
;	EXIT	ZR = set if file looks like a device
;
;	USED	AX,BX,CX,DX,DI
;
;	EFFECTS
;
;	  DTA buffer holds results of Find First function
;
;	NOTES
;
;	  We try to flag devices in two ways. First, we try
;	  the DOS Find First function. It returns attribute bit 6
;	  set on a successful find if it identifies a device name.
;	  Unfortunately, it returns 'path not found' for a device
;	  name terminated with colon, such as "CON:". So, we look
;	  for any colon in the pathname after the 2nd character,
;	  and flag the pathname as a device if we find one.

	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
FileIsDevice:
	mov	dx,[PathPos]	 ; DX = ptr to pathname

	mov	di,dx
	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
	xor	bl,bl		 ; BL = NUL to terminate pathname with
	xchg	bl,[di] 	 ; BL = saved pathname terminating char

	xor	cx,cx		 ; CX = attribute mask (normal search)
	mov	ah,4Eh
	;mov	ah,Find_First	 ; AH = DOS Find First function code
	int	21h	 	 ; call DOS
	xchg	bl,[di]		 ; restore pathname terminating char
	jc	short piCol	 ; didn't find a dir entry, check for colon

;	Found a dir entry, see if Find First thinks it's a device.

	;test	byte [DIRBUF+21],40h
	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
	jz	short piCol	 ; device attribute not set, look for colon
	xor	cx,cx		 ; it's a device, return ZR flag
	;jmp	short piRet
	; 25/04/2023
piRet:
	retn

;	Device attribute not returned by Find First function. But
;	let's check for a colon anywhere in the pathname after the
;	second byte.
;
;	DI = ptr to byte after pathname

piCol:
	dec	di		 ; DI = ptr to last char in pathname
	mov	al,':'
	;mov	al,COLON_CHAR	 ; AL = colon char to search for
	mov	cx,[PathCnt]	 ; CX = # chars to scan
	dec	cx
	dec	cx		 ; ignore 1st two chars of pathname
	or	cx,cx
	js	short piRet	 ; if < 2 chars in pathname, just return
	or	di,di		 ; clear ZR in case CX = 0
	std			 ; scan downward
	repne	scasb
	cld			 ; restore default upward direction

;	After scanning, the ZR flag is set to indicate presence of a colon.
;piRet:
	retn

;FileIsDevice endp

; ---------------------------------------------------------------------------

;***	FindFirst - find first directory entry to display
;***	FindNext - find next directory entry to display
;
;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
;		AttrSpecified, AttrSelect are set
;
;	EXIT	CY = clear if successful
;		BX = offset in TPA buffer of directory entry found
;
;		If unsuccessful,
;		CY = set
;		AX = DOS error code
;		DOS Get Extended Error call will get error code
;
;		NOTE: if entries were loaded into TPA, AX contains
;		ERROR_NO_MORE_FILES when no more entries are available,
;		but DOS Get Extended Error call WON'T return the correct
;		error. That's ok, because we'll see the value in AX
;		and recognize it as a non-error condition.
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Entries in memory may be marked as output.
;	  If not sorted, entry is loaded at TPA.
;
;	NOTES
;
;	  If we don't find a qualifying file, we return after the final
;	   DOS Find File call. A DOS Get Extended Error call will then
;	   indicate an appropriate condition.

	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
	
FindFirst:
	;mov	ax,offset TRANGROUP:GetFirst
	mov	ax,GetFirst
	jmp	short ffFindEntry

	; 18/02/2023
FindNext:
	;mov	ax,offset TRANGROUP:GetNext
	mov	ax,GetNext

;	AX = address of correct disk get routine to use.

ffFindEntry:
	push	es			; save TRANGROUP seg addr
	;;;test	Bits,mask inmem
	;;test	word [_Bits],20h
	;test	byte [_Bits],20h
	test	byte [_Bits],mask.inmem
	jz	short ffDisk		; entries not in memory, search disk

;	Entries are loaded in memory to sort out. Find the first one.
;	There will always be one, or LoadEntries would've failed.

	call	FindInMem		; find first entry in TPA
	jmp	short ffRet		; return what TPA search returns

;	Get entry from disk.

ffDisk:
	call	ax			; get entry from disk
	jc	short ffGetErr		; get & return error
	mov	es,[TPA]		; ES = seg addr of TPA
	xor	di,di			; ES:DI = ptr to TPA
	mov	bx,di			; BX = offset of entry in TPA
	call	LoadEntry		; load entry to TPA
	clc				; return success
	jmp	short ffRet

ffGetErr:
	call	 get_ext_error_number	; AX = DOS error code
	stc
ffRet:
	pop	es			; ES = TRANGROUP seg addr again
	retn

; ---------------------------------------------------------------------------

;***	FindInMem - find next directory entry in TPA buffer
;
;	ENTRY	TPA is loaded (see LoadEntries)
;
;	EXIT	BX = offset in TPA of entry found
;
;		If no more files,
;		CY = set
;		AX = DOS 'no more files' error code
;
;	USED	AX,BX,CX,DX,SI,DI,BP,ES
;
;	EFFECTS
;
;	  Entry found is flagged as 'used' (see EntryStruc).

	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
FindInMem:
	mov	es,[TPA]		; ES = TPA seg addr
	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
	cld				; make sure default string direction is up
	
	call	FindOneInMem		; locate an entry
	jc	short fiNoMore		; none left, set up 'no more files' error

;	BX = ptr to entry in TPA

fiBest:
	mov	bp,bx			; BP = ptr to best entry so far
fiNext:
	call	FindNextInMem		; locate next entry
	jc	short fiFound		; no more, best entry so far wins

;	BX = ptr to next entry

	call	CmpEntry		; compare it to best found so far (BP)
	jnb	short fiNext		; it's not better, go look at next one
	jmp	short fiBest		; it's better, go mark it as best so far

fiNoMore:

;	No more entries available in TPA. Set up 'no more files' error.

	;mov	ax,18
	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
	stc				; return error
	;jmp	short fiRet
	; 18/02/2023
	retn

fiFound:
	mov	bx,bp			; BX = ptr to best entry found
	mov	byte [es:bx],1		; mark entry 'used'
	clc				; return success
fiRet:
	retn

; ---------------------------------------------------------------------------

;***	FindNextChild - find next subdirectory in current directory
;
;	ENTRY	BX = ptr to last child found, ASCIIZ filename
;		DirBuf is established DTA
;
;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
;
;		If failure,
;		CY = set
;		DOS Get Extended Error call will get error
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  DirBuf is used for find first/next calls.
;
;	NOTES
;
;	  We keep on checking files until DOS returns an error. If
;	  the error is 'no more files' and the temp filename is not
;	  the initial high tag, copy the temp to the child's name spot
;	  and return success. Otherwise, send the error back to caller.
;
;	  This routine depends on DS,ES,CS, & SS all being equal.

	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
FindNextChild:
	sub	sp,12			; make temp filename buf on stack
	;shove	00FFh			; temp filename = high tag
	mov	ax,0FFh
	push	ax
	mov	bp,sp			; BP = ptr to temp filename buf
	;shove	"*"	
	mov	al,'*'  ; ax = 002Ah
	push	ax
	;;shove	".*" 
	;mov	ax,"*."
	;mov	ax,2E2Ah
	mov	ah,'.'
	push	ax
	call	GetDriveLtr		; AX = "d:"
	push	ax
	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack

;	See that the stack is restored properly at the end of this proc.

	;mov	cx,10h
	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
	mov	ah,4Eh
	;mov	ah,Find_First
	int	21h			; DOS- Find First matching file
	jc	short fcRet		; return error

	call	CheckChild		; check child against last, temp
fcNext:	
	;mov	cx,10h
	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
	mov	ah,4Fh
	;mov	ah,Find_Next
	int	21h			; DOS- Find Next matching file
	jc	short fcErr		; examine error

	call	CheckChild		; check child against last, temp
	jmp	short fcNext		; go find another child

fcErr:
	call	get_ext_error_number	; AX = extended error code
	;cmp	ax,18
	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
	jne	short fcNope		; some other error- return it

;	We ran out of files. See if we qualified at least one.

	cmp	byte [bp],0FFh
	je	short fcNope		; temp filename is unused- no child

;	Move temp filename to child name position.

	mov	si,bp			; SI = ptr to temp filename
	mov	di,bx			; DI = ptr to child name pos'n
fcMove:
	lodsb				; AL = next byte of filename
	stosb				; store byte
	or	al,al
	jz	short fcRet		; byte was zero, return success (CY clear)
	jmp	short fcMove		; go move another byte
fcNope:
	stc				; return error
fcRet:
	lahf
	add	sp,20			; restore stack
	sahf
	retn

; ---------------------------------------------------------------------------

;***	FindOneInMem - find the first available entry in TPA
;***	FindNextInMem - find the next available entry in TPA
;
;	ENTRY	ES = TPA seg addr
;		BX = ptr to entry in TPA
;
;	EXIT	BX = ptr to entry found
;		CY = set if no more entries available in TPA
;
;	USED	AL

	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
FindOneInMem:
	mov	al,[es:bx]		; examine 'used' byte of starting entry
	cmp	al,1
	je	short FindNextInMem	; entry has already been used
	cmp	al,0FFh
	je	short foNoMore		; 0FFh, we're at the end of the list

;	BX = ptr to entry that hasn't been output yet.

	clc				; return success
	retn

FindNextInMem:
	add	bx,21
	;add	bx,size EntryStruc	; BX = ptr to next entry
	jmp	short FindOneInMem	; go look at it
foNoMore:
	stc				; ran out of entries, return failure
	retn

; ---------------------------------------------------------------------------

;***	GetEnvValue - get value of our environment variable
;
;	ENTRY	DS, ES = TRANGROUP seg addr
;
;	EXIT	CY = set if environment variable not in environment
;
;		Otherwise:
;		SI = ptr to environment variable asciiz value in TRANGROUP
;
;	USED	AX,BX,CX,DX,DI
;		(We assume the (almost) worst, since we don't know about
;		Find_Name_In_Environment.)
;
;	EFFECTS
;
;	  ScanBuf is loaded with value text

	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
GetEnvValue:
	push	es				; save ES
	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
	mov	si,DirEnvVar
	;invoke	Find_Name_In_Environment
	call	find_name_in_environment
	jc	short geRet			; name not found in environment

;	ES:DI = ptr to value of environment variable
;	We're assuming DS, CS, and SS are unchanged.

	push	ds
	push	es
	pop	ds
	pop	es

	;assume	ds:nothing

;	DS = seg addr of environment variable value (in environment segment)
;	ES = TRANGROUP seg addr

	mov	si,di				; DS:SI = ptr to value string
	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
	mov	di,ScanBuf
geLoop:
;@@:	
	lodsb
	or	al,al
	stosb
	;loopnz	@B		; move the string, including trailing null
	loopnz	geLoop

	push	es
	pop	ds		; DS = TRANGROUP seg addr again
	;assume	ds:TRANGROUP

	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
	mov	si,ScanBuf
geRet:
	pop	es				; restore ES
	retn

; ---------------------------------------------------------------------------

;***	GetFirst - get first directory entry from disk
;
;	ENTRY	DOS DTA established at DirBuf
;		FCB contains drive # and filename
;		Current directory (on selected drive) is the one to search
;		AttrSpecified & AttrSelect masks set
;
;	EXIT	CY = clear if success
;		DirBuf contains extended FCB for file found
;
;		If unsuccessful,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  FCB-7 = 0FFh to mark extended FCB
;	  FCB-1 = attribute mask to find all files
;	  These fields should remain unmodified for GetNext calls.
;
;***	GetNext - get next directory entry from disk
;
;	ENTRY	As for GetFirst, plus
;		FCB-7 set up as extended FCB w/ find-all attribute byte
;
;	EXIT	As for GetFirst
;
;	USED	AX,DX

	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
GetFirst:
	;mov	byte [55h],0FFh	; -1
	mov	byte [FCB-7],0FFh	; signal extended FCB
	;mov	byte [5Bh],16h
	mov	byte [FCB-1],ATTR_ALL ; 16h
					; find any file
	; 07/06/2023
	;mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
	mov	ah,11h
	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
	; 07/06/2023
	;int	21h			; call DOS
	;shl	al,1			; CY = set if error
	;jc	short gfRet		; return error
	;jmp	short gfFound		; go look at attr's
	; 07/06/2023
	jmp	short GetFrstNxt
GetNext:
	; 07/06/2023
	;;mov	dx,55h
	;mov	dx,FCB-7		; DX = ptr to extended FCB
	mov	ah,12h
	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
GetFrstNxt:
	; 07/06/2023
	mov	dx,FCB-7 ; mov dx,55h
	;
	int	21h			; call DOS
	shl	al,1			; CY = set if error
	jc	short gfRet		; return error

;*	Found an entry. Check attributes.
gfFound:
	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
	;mov	al,[DIRBUF+19]
	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
	and	al,ah			; AL = pertinent attr's of file
	and	ah,[AttrSelect]		; AH = attr settings to match
	cmp	al,ah
	jne	short GetNext		; attr's don't match, look for another
gfRet:
	retn

; ---------------------------------------------------------------------------

;***	ListDir - search for and list files in the current directory
;
;	List header, files, and trailer for current directory on selected
;	drive. Header & trailer are listed if at least one file is found.
;	If no qualifying files are found, no display output occurs.
;
;	ENTRY	Current directory (on selected drive) is the one to be listed
;		FCB contains selected drive # and filename spec
;		Option bits, attribute masks, and sort codes set up
;
;	EXIT	CY = clear if no error
;		FileCnt = # files found & displayed
;
;		If error,
;		CY = set
;		Ready for DOS Get Extended Error call
;
;	USED	AX,BX,CX,DX,SI,DI,BP
;		FileSiz
;
;	EFFECTS
;
;	  FileCntTotal, FileSizTotal are updated.
;	  Files found are listed. A directory header and trailer are
;	   displayed only if files are found.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh

ListDir:
	xor	ax,ax
	mov	[FileCnt],ax		; zero file count
	mov	[FileSiz],ax		; zero file size accumulator
	mov	[FileSiz+2],ax
	cmp	byte [DestBuf],0	; check for sort code
	je	short ld1		; no sort
	call	LoadEntries		; load entries for sorted listing
	jnc	short ld1		; no error - continue
	call	get_ext_error_number	; AX = DOS error code
	; 19/02/2023
	;stc
	jmp	short ldErr		; return error
ld1:
	call	FindFirst		; find first file
	jc	short ldErr		; not found, return error

;	BX = offset in TPA buffer of entry found

	call	DisplayHeader		; if at least one file, display header
ldNext:
	call	DisplayFile		; display the file entry
;ldNext:
	call	FindNext		; find another file
	jc	short ldErr		; not found
	;call	DisplayFile		; display entry
	;jmp	short ldNext		; go find another one
	; 19/02/2023
	jmp	short ldNext
ldErr:
	;cmp	ax,2
	cmp	ax,ERROR_FILE_NOT_FOUND
	je	short ldDone		; file not found, we're done
	;cmp	ax,18
	cmp	ax,ERROR_NO_MORE_FILES
	je	short ldDone		; no more files, we're done
	stc
	;jmp	short ldRet
	; 19/02/2023
	retn
ldDone:
	cmp	word [FileCnt],0
	;je	short ld2		; no files found, just return
	; 25/04/2023
	jz	short ldRet
	call	DisplayTrailer		; display trailing info
	; 08/06/2023
	; cf=0
;ld2:	
	;clc				; return success
ldRet:
	retn

; ---------------------------------------------------------------------------

;***	LoadEntries - attempt to load entries from current directory
;
;	Load all qualifying directory entries from the current directory
;	into the TPA. If an error is returned by FindFirst/FindNext calls
;	other than 'no more files', return to caller with carry flag set.
;	If we run out of buffer space, display a message that we haven't
;	enough memory to sort this directory, but return without error.
;	Other routines know whether or not entries have been loaded by
;	the 'inmem' flag bit, which we set here.
;
;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
;	this allows sorting over 3000 entries in a directory.
;
;	ENTRY	Tpa = buffer seg addr
;		BytCnt = buffer length, in bytes
;		Current directory (on selected drive) is the one to load
;		FCB contains drive # and filespec
;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
;
;	EXIT	CY = set if error
;		If error, DOS Get Extended Error will get error info
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Inmem bit of Bits = set if load succeeded.
;	  Tpa buffer contains directory entries.
;	  Byte after last entry = 0FFh.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
LoadEntries:
	push	es			; save TRANGROUP seg addr
	mov	es,[TPA]		; ES = TPA seg addr
	xor	di,di			; ES:DI = destination ptr
	;;;and	Bits,not mask inmem	; signal entries not loaded
	;;and	word [_Bits],0FFDFh
	;and	byte [_Bits],0DFh	; not 20h
	and	byte [_Bits],~mask.inmem ; ~20h

	call	GetFirst		; look for first file
	jc	short leRet		; return any error
	call	LoadEntry		; load entry into TPA
leNext:
	call	GetNext			; get another file
	jc	short leLoaded		; assume any error is no more files
	mov	ax,[BYTCNT]		; AX = size of TPA
	sub	ax,di			; AX = bytes left in TPA
	;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
	cmp	ax,23 ; 21+2 
	jb	short leOk		; not enough memory left, give up
	call	LoadEntry		; load entry into TPA
	jmp	short leNext		; go get another file

leLoaded:
	mov	byte [es:di],0FFh	; mark end of entry list
	;;;or	Bits,mask inmem		; signal entries loaded in memory
	;;or	word [_Bits],20h
	;or	byte [_Bits],20h
	or	byte [_Bits],mask.inmem
	; 25/04/2023
	; cf = 0
leOk:
	clc				; return no error
leRet:
	pop	es			; ES = TRANGROUP seg addr again
	retn


; ---------------------------------------------------------------------------

;***	LoadEntry - load directory entry from DirBuf ext'd FCB
;
;	ENTRY	ES:DI = ptr to load point in TPA
;		DirBuf contains extended FCB of entry to load
;
;	EXIT	ES:DI = ptr to next byte available in TPA
;
;	USED	AX,CX,SI
;
;	NOTES
;
;	  I could've used symbolic offsets and sizes of fields from
;	   the dir_entry struc to do this, but this is time-critical,
;	   so I hard-wired the structure of the DOS 4.x returned FCB,
;	   as well as our private directory entry structure.
;
;	  We force a zero size for subdirectory files. A zero size is
;	   ordinarily returned for subdirectories, but with Novell
;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
LoadEntry:
	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
	mov	si,DIRBUF+8
	xor	al,al				; AL = 0
	stosb					; 'used' byte = false
	mov	cx,11
	rep	movsb				; transfer filename & extension
	lodsb					; AL = attrib byte
	stosb					; store attrib byte
	;add	si,10 ; 22-11-1
	;add	si,dir_time-dir_attr-1		; skip to time field
	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
	movsw					; transfer time
	movsw					; transfer date
	inc	si				; skip alloc unit
	inc	si
	;and	al,10h
	and	al,ATTR_DIRECTORY
	jnz	short leSetDirSize		; force zero size for subdir
	movsw
	movsw					; transfer size
	retn
leSetDirSize:
	xor	ax,ax ; 0
	stosw
	stosw					; store zero size
	retn

; ---------------------------------------------------------------------------

;***	NoOrder - turn sorting off
;
;	ENTRY	nothing
;
;	EXIT	CY clear
;
;	USED	AX
;
;	EFFECTS
;
;	  DestBuf is updated with sort code bytes. See DestBuf description.

	; 19/02/2023
NoOrder:
	mov	byte [DestBuf],0
				; no sort
	clc			; no error
	retn

; ---------------------------------------------------------------------------

;***	OnOffSw - record occurence of on/off option switch
;
;	ENTRY	DI = index into word list of switches
;
;	EXIT	CY clear
;
;	USED	AX,CX
;
;	EFFECTS
;
;	  Bits modified to indicate option state.

	; 19/02/2023
OnOffSw:
	mov	cx,di		; CX = index into word list of options
	shr	cx,1
	shr	cx,1		; CX = bit position of option
	mov	ax,1		
	shl	ax,cl		; AX = bit mask of option
	test	di,2		; check if it is a negated option
	jz	short oo1	; it's negated
	;or	Bits,ax		; turn option on
	or	[_Bits],ax
	;jmp	short ooRet
	; 19/02/2023
	;cf=0
	retn
oo1:	
	not	ax		; AX = complemented bit mask of option
	;and	Bits,ax		; turn option off
	and	[_Bits],ax
ooRet:
	; 19/02/2023
	;cf=0
	;clc			; always return success
	retn

; ---------------------------------------------------------------------------

;***	ParseAttr - parse and record /A option
;
;	ENTRY	BX = ptr to system parser result buffer for /A occurence
;
;	EXIT	CY = set if error occurs parsing attribute conditions
;
;		For parse error, we set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,CX,DX,DI
;
;	EFFECTS
;
;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
;	  If parse error occurs, attribute conditions parsed so far hold.
;
;	  For parse error, we set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

	; 19/02/2023
ParseAttr:
	push	si			; save SI
	mov	byte [AttrSpecified],0	; cancel all attribute conditions

;	Each /A invocation starts by assuming all files are to be listed.

	;;mov	si,word ptr [bx].ValuePtr
					; SI = ptr to string after /A
	;mov	si,[bx+ResultBuffer.ValuePtr]
	mov	si,[bx+4]
paLoop:	
	mov	dx,1			; DX = 1 (for un-negated attribute)
	lodsb				; AL = next char in string
	or	al,al
	;jz	short paOk		; it's terminating null, we're done
	; 19/02/2023
	jz	short paRet ; cf=0
	cmp	al,'-'
	jne	short pa1		; not '-', go look for letter
	dec	dx			; DX = 0 (for negated attribute)
	lodsb				; AL = next char
pa1:	
	;mov	di,offset TRANGROUP:AttrLtrs 
					; DI = ptr to attrib letter list
	mov	di,AttrLtrs ; "RHSvDA"
	;mov	cx,6
	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
	repne	scasb			; look for our letter in the list
	jne	short paErr		; not found, return error

	not	cx
	;add	cx,6
	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5

;	Note that we rely on AttrLtrs to be in the attribute bit order,
;	starting from bit 0.

;	Record this attribute bit in AttrSpecified.

	mov	al,1
	shl	al,cl			; AL = mask for our bit
	or	[AttrSpecified],al	; set it in the 'specified' mask

;	Record the selected state for this attribute in AttrSelect.
;	DX = 0 or 1, the selected state for this attribute.

	not	al			; AL = mask for all other bits
	and	[AttrSelect],al		; clear our bit
	shl	dl,cl			; DL = our bit state in position
	or	[AttrSelect],dl		; set selected attr state
	jmp	short paLoop		; go look at next char

;	The attribute letter string is invalid.

paErr:	
	call	SetupParamError		; set message up for Std_EPrintf
	stc		   		; return error
	; 19/02/2023
	;jmp	short paRet
;paOk:
	;clc				; return success		
paRet:	
	pop	si			; restore SI
	retn

; ---------------------------------------------------------------------------

;***	ParseLine - parse a line of text
;
;	Parse text until an EOL (CR or NUL) is found, or until a parse
;	error occurs.
;
;	ENTRY	DS:SI = ptr to text
;		CS, DS, ES = TRANGROUP seg addr
;
;	EXIT	AX = last return code from system parser
;		CX = # positional parameters (pathnames) found - 0 or 1
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		DX = ptr to message block
;
;	USED	BX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;	  SrcBuf may contain a new default pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

	; 19/02/2023
Parse_Line:
	; 04/05/2023
	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
	xor	cx,cx			; CX = # positionals found
plPars:
	call	Parse_With_Msg		; call parser
	cmp	ax,-1
	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
	je	short plRet		; EOL encountered, return
	cmp	ax,RESULT_NO_ERROR ; 0
	jne	short plRet		; parse error occurred, return

;	Parse call succeeded. We have a filespec or a switch.
;	DX = ptr to result buffer

	mov	bx,dx			; BX = ptr to parse result buffer
	cmp	byte [bx],RESULT_FILESPEC ; 5
	je	short plFil		; we have a filespec

	call	ParseSwitch		; else we have a switch
	;jc	short plRet		; error parsing switch, return
	;jmp	short plPars		; parse more
	; 19/02/2023
	jnc	short plPars
plRet:
	retn	
plFil:	
	call	CopyPathname		; copy pathname into our buffer
	jmp	short plPars		; parse more
;plRet:
;	retn

; ---------------------------------------------------------------------------

;***	ParseOrder - parse and record /O option
;
;	ENTRY	BX = ptr to system parser result buffer for /O occurence
;
;	EXIT	CY = set if error occurs parsing order
;
;		For parse error, we set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,CX,DX,DI
;
;	EFFECTS
;
;	  DestBuf is updated with sort code bytes. See DestBuf description.
;
;	  For parse error, we set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

	; 19/02/2023
ParseOrder:
	push	si			; save SI
	push	bx			; save ptr to result buffer

	;;mov	si,word ptr [bx].ValuePtr
	;mov	si,[bx+ResultBuffer.ValuePtr]
	mov	si,[bx+4]		; SI = ptr to order letters
	;mov	bx,offset TRANGROUP:DestBuf
	; 08/06/2023 (BugFix)
	mov	bx,DestBuf		; BX = ptr to sort code buffer
	mov	al,[si]			; AL = 1st char of order string
	or	al,al
	jnz	short poLtr		; not NUL, go parse letters

;	We have /O alone. Set standard sort order.
;	Note hardwired dependency on character order in OrderLtrs.

	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
	inc	bx
	mov	byte [bx],1		; then by name
	inc	bx
	mov	byte [bx],2		; then by extension
	inc	bx
	jmp	short poOk		; return success

;	We have /O<something>. Parse sort order letters.

poLtr:	
	xor	dl,dl			; DL = 0 (upward sort)
	lodsb				; AL = next sort order letter
	or	al,al
	jz	short poOk		; NUL found, return success

	cmp	al,'-'
	jne	short po1		; not '-', go look for letter
	mov	dl,80h			; DL = downward sort mask
	lodsb				; AL = next char
po1:
	;mov	di,offset TRANGROUP:OrderLtrs
	; 08/06/2023 (BugFix)
	mov	di,OrderLtrs	;"NEDSG" ; DI = ptr to list of letters
	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
	repne	scasb			; look for our letter in the list
	jne	short poErr		; not found, return error

	neg	cx
	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6

	or	cl,dl			; CL = sort code with up/dn bit
	mov	[bx],cl			; store sort order code in buffer
	inc	bx			; BX = ptr to next spot in buffer
	;cmp	bx,offset TRANGROUP:EndDestBuf
	cmp	bx,EndDestBuf
	;jae	short poErr		; too many letters
	;
	;jmp	short poLtr		; go look at next char
	; 19/02/2023
	jb	short poLtr

;	The sort order string is invalid.  

poErr:
	pop	bx			; BX = ptr to result buffer
	call	SetupParamError		; set message up for Std_EPrintf
	stc				; return failure
	jmp	short poRet
poOk:	
	mov	byte [bx],0		; mark end of sort code list
	pop	bx			; BX = ptr to result buffer
	; 19/02/2023
	;cf=0
	;clc				; return success
poRet:
	pop	si			; restore SI
	retn

; ---------------------------------------------------------------------------

;***	ParseSwitch - parse a switch
;
;	ENTRY	BX = ptr to parse result buffer after system parser processed
;		     a switch
;
;	EXIT	CY = set if parse error occurred
;
;		If parse error occurred, we're set up for Std_EPrintf call:
;		AX = parse error code, like system parser
;		DX = ptr to message block
;
;	USED	AX,BX,DX
;
;	EFFECTS
;
;	  Bits may contain new option settings.
;	  DestBuf may contain new series of sort codes.
;	  AttrSpecified, AttrSelect may contain new attribute conditions.
;
;	  If parse error occurred, we're set up for Std_EPrintf call:
;	  Msg_Disp_Class = parse error class
;	  Byte after last parameter in text is zeroed to make ASCIIZ string
;	  Message block (see DX) is set up for parse error message

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
ParseSwitch:
	push	cx			; save CX
	push	di			; save DI

	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
	;mov	ax,[bx+ResultBuffer.SynPtr]
	mov	ax,[bx+2]
	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
	cld				; scan direction = upward
	repne	scasw			; locate synonym ptr in list
	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
	sub	di,Dir_Sw_Ptrs+2

;	DI = index into word list of synonym ptrs

	call	word [cs:di+SwHandler]	; use same index into call table

	pop	di			; restore DI
	pop	cx			; restore CX

	retn

; ---------------------------------------------------------------------------

;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
;	Simple on/off switches must occur first in both lists, and must be
;	  in order of option bits in Bits, starting with bit 0.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh

SwHandler:
	dw	OnOffSw		; /-W
	dw	OnOffSw		; /W
	dw	OnOffSw		; /-P
	dw	OnOffSw		; /P
	dw	OnOffSw		; /-S
	dw	OnOffSw		; /S
	dw	OnOffSw		; /-B
	dw	OnOffSw		; /B
	dw	OnOffSw		; /-L	;M010
	dw	OnOffSw		; /L	;M010
	dw	NoOrder		; /-O
	dw	ParseOrder	; /O
	dw	DefaultAttr	; /-A
	dw	ParseAttr	; /A

; ---------------------------------------------------------------------------

	;break	<DIR utility routines>

;***	UTILITY ROUTINES
; ---------------------- 

; ---------------------------------------------------------------------------

;***	ChangeDir - change directory on target drive
;
;	ENTRY	FCB contains drive #
;		DS:DX = ptr to ASCIIZ string w/o drive specifier
;
;	EXIT	Changed current directory on drive
;
;		If error,
;		CY = set
;		DOS Get Extended Error call will get error
;
;	USED	AX,DX,SI,DI
;
;	EFFECTS
;
;	  DirBuf is used to build "d:string".

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h

ChangeDir:
	;mov	di,offset TRANGROUP:DirBuf
	mov	di,DIRBUF
	call	GetDriveLtr	; AX = "d:"
	stosw			; put drive specifier in buffer
	mov	si,dx		; SI = ptr to argument string
cdLoop:
	lodsb
	stosb			; move byte to buffer
	or	al,al
	jne	short cdLoop	; continue until null transferred

	;mov	dx,offset TRANGROUP:DirBuf
	mov	dx,DIRBUF	; DX = ptr to "d:string"
	;mov	ah,CHDir
	mov	ah,3Bh
	int	21h		; change directory
	retn			; return what CHDIR returns

; ---------------------------------------------------------------------------

;***	CmpAscz - compare two ASCIIZ strings alphanumerically
;
;	ENTRY	DS:SI = ptr to one ASCIIZ string
;		ES:DI = ptr to another ASCIIZ string
;
;	EXIT	flags set after REPE CMPSB
;
;	USED	AL,CX,SI,DI
;
;	NOTES
;
;	Maximum run of comparison is length of DS:SI string.
;	This ensures that two identical strings followed by
;	random characters will compare correctly.

	; 19/02/2023
CmpAscz:
	; 07/06/2023
	push	si ; *
	;
	push	di

	mov	di,si
	xor	al,al
	mov	cx,0FFFFh
	repne	scasb
	not	cx

	pop	di
	repe	cmpsb

	; 07/06/2023
	pop	si ; *
	;
	retn

; ---------------------------------------------------------------------------

;***	CopyPathname - copy pathname to our buffer
;
;	ENTRY	BX = ptr to parse result buffer after system parser processed
;		     a filespec
;
;	EXIT	nothing
;
;	USED	AX
;
;	EFFECTS
;
;	  SrcBuf may contain a new pathname/filespec.
;	  PathPos, PathCnt updated for new pathname.

	; 19/02/2023
CopyPathname:
	push	si
	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
	;lds	si,[bx+ResultBuffer.ValuePtr]
	lds	si,[bx+4]
	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
	call	Move_To_SrcBuf
	pop	si
	retn

; ---------------------------------------------------------------------------

;***	CountFile - update counters with current file
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
CountFile:
	push	es			; save TRANGROUP seg addr
	mov	es,[TPA]		; ES = TPA seg addr

	inc	word [FileCnt]		; # files this directory
	inc	word [FileCntTotal]	; # files total
	jnz	short cntf1
	inc	word [FileCntTotal+2]
cntf1:
	;mov	ax,word ptr es:[bx].filesize
					; AX = low word of file size
	;mov	dx,word ptr es:[bx].filesize+2
					; DX = high word of file size
	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
	add	[FileSiz],ax
	adc	[FileSiz+2],dx		; size of this directory
	add	[FileSizTotal],ax
	adc	[FileSizTotal+2],dx	; total size of files listed

	pop	es			; ES = TRANGROUP seg addr again
dbRet:	; 19/02/2023
	retn

; ---------------------------------------------------------------------------

;***	DisplayBare - display filename in bare format
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	DX = # char's displayed, including dot
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename is displayed in name.ext format, followed by cr/lf.
;	  If /s is on, complete pathname is displayed.
;
;	NOTE
;
;	  Directory pseudofiles . and .. and suppressed in bare listing.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h

DisplayBare:
;	Suppress . and .. files from bare listing.

	mov	cx,ds			; CX = saved TRANGROUP seg addr
	mov	ds,[TPA]		; DS:BX = ptr to file entry
	;assume	ds:NOTHING
	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
	mov	ds,cx			; DS = TRANGROUP seg addr again
	;assume	ds:TRANGROUP
	je	short dbRet		; it's . or .. - don't display

	;;;test	Bits,mask subd
	;;test	word [_Bits],4
	;test	byte [_Bits],4
	test	byte [_Bits],mask.subd
	jz	short dbNameExt		; not /s - display filename only

	;invoke	Build_Dir_String
	call	build_dir_string
	;mov	di,offset TRANGROUP:BwdBuf
	mov	di,BWDBUF		; ES:DI = ptr to dir string
   
	;;;test	Bits,mask lcase		;M010;check for lowercase option
	;;test	word [_Bits],10h
	;test	byte [_Bits],10h
	test	byte [_Bits],mask.lcase
	;jz	@F			;M010;lowercase not needed
	jz	short dbare1
	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
	call	LowercaseString		;M010;path string is in BwdBuf
dbare1:
;@@:	
	;xor	al,al			; AL = 0
	; 19/02/2023
	xor	ax,ax
	mov	cx,0FFFFh
	cld
	repne	scasb			; ES:DI = ptr to byte after null
	dec	di			; ES:DI = ptr to null byte

	cmp	byte [es:di-1],'\'
	;je	@F
	je	short dbare2		; already terminated w/ '\'

	;mov	ax,'\'			; AX = '\',0
	mov	al,'\'
	stosw				; add to dir string
;@@:
dbare2:
	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
	mov	word [string_ptr_2],BWDBUF
	;mov	dx,offset TRANGROUP:String_Buf_Ptr
	mov	dx,string_buf_ptr
	;invoke	Std_Printf		; display device & directory path
	call	std_printf
dbNameExt:
	call	DisplayDotForm		; display name.ext
	;invoke	CrLf2			; display cr/lf
	call	CRLF2
	; 19/02/2023
	;call	UseLine			;M007;Allow /p with /b
;dbRet:
	;retn

	; 19/02/2023
	;jmp	short UseLine

; ---------------------------------------------------------------------------

;***	UseLine - use a display line, start a new page if none left
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	flags

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
UseLine:
	dec	word [LeftOnPage]
	cmp	word [LeftOnPage],2
	ja	short ulRet
	; 19/02/2023
	;call	EndPage
;ulRet:
	;retn

	; 19/02/2023
	;jmp	short EndPage

; ---------------------------------------------------------------------------

;***	EndPage - end the current display page
;
;	ENTRY	LeftOnPage = # lines left on display page
;		Current directory (on selected drive) is the one being listed
;		Bits contains /p setting
;
;	EXIT	LeftOnPage = # lines left for next page
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  Pause is invoked to display a message and wait for a keystroke.
;	  BwdBuf (same as DirBuf) used to build directory string.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h

EndPage:
	;;;test	Bits,mask pagd
	;;test	word [_Bits],2
	;test	byte [_Bits],2
	test	byte [_Bits],mask.pagd
	jz	short epNew		; paged display isn't enabled

	push	bx			; save BX
	push	cx			; save CX

	;invoke	Pause			; "Press any key to continue..."
	call	PAUSE

	;invoke	Build_Dir_String
	call	build_dir_string
	;mov	dx,offset TRANGROUP:DirCont_Ptr
	mov	dx,dircont_ptr
	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
	call	Printf_Crlf

	pop	cx			; restore CX
	pop	bx			; restore BX
epNew:	
	mov	ax,[LinPerPag]		; AX = # lines per page
	dec	ax			; AX = # lines till next EndPage
	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
ulRet:	
	; 19/02/2023
	retn

; ---------------------------------------------------------------------------

;***	DisplayDotForm - display filename in compressed dot format
;
;	Display name.ext, with no cr/lf's. Dot is displayed only
;	if the filename has a nonblank extension.
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	DX = # char's displayed, including dot
;
;	USED	AX,CX,SI,DI
;
;	EFFECTS
;
;	  Filename is displayed in name.ext format.
;
;	NOTE
;
;	  We allow for bogus filenames that have blanks embedded
;	  in the name or extension.

;	Bugbug:	might be a good performance gain if we buffered
;	up the output and used DOS function 9.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h

DisplayDotForm:
	push	ds			; save TRANGROUP seg addr
	push	es			; save ES
	mov	ax,[cs:TPA]		; AX = TPA seg addr
	mov	ds,ax			; DS:BX = ptr to entry
	;assume	ds:nothing
	mov	es,ax			; ES:BX = ptr to entry

	; 08/06/2023
	;mov	di,bx			; ES:DI = ptr to entry
	;;;add	di,filename + size filename - 1
	;add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
	;;mov	cx,size filename	; CX = length of name field
	;mov	cx,8
	; 08/06/2023
	mov	cx,8
	mov	di,cx
	add	di,bx	
	
	mov	al,' '
	std				; scan down
	repe	scasb			; scan for nonblank

;	Assume file name has at least one character.

	inc	cx			; CX = # chars in name
	mov	dx,cx			; DX = # chars to be displayed

	mov	si,bx			; DS:SI = ptr to entry
	;;add	si,filename		; DS:SI = ptr to name
	;add	si,1 
	;		; add si,EntryStruc.filename
	; 25/04/2023
	inc	si
NextNameChar:
	cld
	lodsb				; AL = next char

	;;;test	Bits,mask lcase		;M010;check for lowercase option
	;;test	word [ss:_Bits],10h
	;test	byte [ss:_Bits],10h
	test	byte [ss:_Bits],mask.lcase
	;jz	short @F		;M010;lowercase not required
	jz	short ddf1
	call	LowerCase		;M010;filename char is in AL
ddf1:
;@@:	
	;invoke	Print_Char		; display it
	call	PRINT_CHAR
	loop	NextNameChar

;	Now do extension.

	mov	di,bx			; ES:DI = ptr to entry
	;add	di,fileext + size fileext - 1
	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
	;mov	cx,size fileext		; CX = length of ext field
	mov	cx,3
	mov	al,' '
	std				; scan down
	repe	scasb			; scan for nonblank
	je	short ddDone		; no nonblank chars in ext

	inc	cx			; CX = # chars in ext
	add	dx,cx			; DX = total # chars to be displayed
	inc	dx			;      including dot

	mov	al,'.'
	call	PRINT_CHAR
	mov	si,bx			; DS:SI = ptr to entry
	;add	si,fileext		; DS:SI = ptr to ext
	add	si,9

NextExtChar:
	cld
	lodsb				; AL = next char

	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
	;;test	word [cs:_Bits],10h
	;test	byte [cs:_Bits],10h
	test	byte [cs:_Bits],mask.lcase
	;jz	short @F		;M010;lowercase not required
	jz	short ddf2
	call	LowerCase		;M010;fileext char is in AL
;@@:	
ddf2:
	;invoke	Print_Char		; display it
	call	PRINT_CHAR
	loop	NextExtChar
ddDone:
	pop	es			; restore ES
	pop	ds			; DS = TRANGROUP seg addr again
	;assume	ds:TRANGROUP
	cld				; leave direction flag = up
	retn

; ---------------------------------------------------------------------------

;***	DisplayFile - display file entry, update counters
;
;	ENTRY	BX = offset of entry in TPA buffer
;		Bits contains /w, /p settings
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  Entry is displayed.  
;	  If not /b,
;	    Cursor is left at end of entry on screen.
;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
;	  If /b,
;	    Cursor is left at beginning of next line.
;	    Cnt's and Siz's aren't updated.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh

DisplayFile:
	;;;test	Bits,mask bare
	;;test	word [_Bits],8
	;test	byte [_Bits],8
	test	byte [_Bits],mask.bare
	jz	short dfNorm		; not /b - do normal display

	call	DisplayBare		; display file in bare format
	jmp	short dfRet
dfNorm:	
	call	DisplayNext		; pos'n cursor for next entry
	;;;test	Bits,mask wide
	;;test	word [_Bits],1
	;test	byte [_Bits],1
	test	byte [_Bits],mask.wide
	jz	short dfFull		; full format
	call	DisplayWide		; wide format
	jmp	short dfCnt
dfFull:	
	call	DisplayName		; display filename & extension
	call	DisplayTheRest		; display size, date, time
dfCnt:
	call	CountFile		; update file counters
dfRet:
dhRet:	; 19/02/2023
	retn

; ---------------------------------------------------------------------------

;***	DisplayHeader - display directory header of working directory
;
;	ENTRY	Current directory (on selected drive) is the one to display
;		LeftOnPage = # lines left on display page
;
;	EXIT	nothing
;
;	ERROR EXIT
;
;	  Build_Dir_String will exit through CError with "Invalid drive
;	   specification" if there's a problem obtaining the current 
;	   directory pathname.
;
;	USED	AX,DX,SI,DI
;
;	EFFECTS
;
;	  BwdBuf (which is really the same buffer as DirBuf, which
;	   we are using for the DTA) contains the directory string.
;	  LeftOnPage is adjusted.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

DisplayHeader:
	;;;test	Bits,mask bare
	;;test	word [_Bits],8
	;test	byte [_Bits],8
	test	byte [_Bits],mask.bare
	jnz	short dhRet		; /b - don't display header

	;;;test	Bits,mask subd
	;;test	word [_Bits],4
	;test	byte [_Bits],4
	test	byte [_Bits],mask.subd
	jz	short dhNorm		; not /s

;	For subdirectory listings, put a blank line before the header.

	;invoke	Crlf2			; start with a blank line
	call	CRLF2
	call	UseLine
	jmp	short dhCom
dhNorm:
	mov	al,' ' ; 20h
	;mov	al,BLANK		; if not /s, precede by a blank
	call	PRINT_CHAR		; print a leading blank
dhCom:
	call	build_dir_string
	mov	dx,dirhead_ptr
	call	std_printf		; print header & cr/lf
	call	UseLine
	call	CRLF2			; another cr/lf
	;call	UseLine
;dhRet:
	;retn

	; 19/02/2023
	jmp	UseLine

; ---------------------------------------------------------------------------

;***	DisplayName - display file name & extension
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Filename & extension are displayed in spread format.
;	  Cursor is left at end of extension.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; 08/06/2023
DisplayName:
	push	ds			; save TRANGROUP seg addr
	mov	ds,[TPA]		; DS:BX = ptr to entry
	;assume	ds:nothing
	mov	si,bx			; DS:SI = ptr to entry
	;add	si,filename		; DS:SI = ptr to filename
	;add	si,1  ; EntryStruc.filename
	; 08/06/2023
	inc	si
	mov	di,CHARBUF		; ES:DI = ptr to CharBuf

	mov	cx,8
	cld
	rep	movsb			; move filename to CharBuf
	mov	al,' '
	stosb				; add a blank
	;mov	cx,3
	; 08/06/2023
	mov	cl,3
	rep	movsb			; add extension
	xor	al,al
	stosb				; add a NULL

	pop	ds			; DS = TRANGROUP seg addr again
	;assume	ds:TRANGROUP

	;;;test	Bits,mask lcase		;M010;check for lowercase option
	;;test	word [_Bits],10h
	;test	byte [_Bits],10h
	test	byte [_Bits],mask.lcase
	jz	short dn1		;M010;lowercase not required
	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
	call	LowercaseString		;M010;filename.ext string is in CharBuf
dn1:	
	mov	word [string_ptr_2],CHARBUF
	mov	dx,string_buf_ptr
	;call	std_printf		; print filename & extension
	;retn
	; 19/02/2023
	jmp	std_printf

; ---------------------------------------------------------------------------

;***	DisplayNext - move display cursor to next entry position
;
;	ENTRY	LeftOnLine = # entries can still be printed on this line
;		LeftOnPage = # lines can still be printed for this page
;		FileCnt = # files in this dir displayed before this one
;		Bits contains /w setting
;
;	EXIT	nothing
;
;	USED	AX,DX
;
;	EFFECTS
;
;	  LeftOnLine will be updated to reflect the entry about to be
;	   displayed.
;	  LeftOnPage may be updated.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

DisplayNext:
	cmp	word [FileCnt],0
	je	short dn1st		; 1st file in directory
	cmp	byte [LeftOnLine],0
	jng	short dnEol		; no more room on this line

;	We are in wide mode (LeftOnLine is always 0 otherwise) and
;	we still have room for more on this line.
;	Tab to next position.

	mov	dx,tab_ptr
	call	std_printf
	jmp	short dnDone
dnEol:	
;	Start this entry on a new line.

	call	CRLF2		; start on new line
	call	UseLine
dn1st:
	mov	al,[PerLine]
	mov	[LeftOnLine],al	; reset # entries left on line

dnDone:
	dec	byte [LeftOnLine]
				; reflect the entry about to be displayed
	retn

; ---------------------------------------------------------------------------

;***	DisplayTheRest - display file size/dir, date, time
;
;	ENTRY	BX = offset of entry in TPA buffer
;		Display cursor is at end of file extension
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI,BP
;
;	EFFECTS
;
;	  File size, date, & time are displayed.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
DisplayTheRest	:
	push	es			; save TRANGROUP seg addr
	mov	es,[TPA]		; ES = TPA seg addr
	mov	bp,bx			; BP = offset of entry in TPA
	;;test	es:[bp].fileattr,ATTR_DIRECTORY
	;test	byte [es:bp+EntryStruc.fileattr],10h
	test	byte [es:bp+12],ATTR_DIRECTORY
	jz	short drNonDir		; not a directory file

;	For a directory file, display <DIR> instead of size.

	mov	dx,dmes_ptr
	call	std_printf
	jmp	short drCom		; skip to common fields

drNonDir:
;	For a non-directory file, display file size.

	;;mov	dx,word ptr es:[bp].filesize
	;mov	dx,[es:bp+EntryStruc.filesize]
	mov	dx,[es:bp+17]
	mov	[File_Size_Low],dx
	;;mov	dx,word ptr es:[bp].filesize+2
	;mov	dx,[es:bp+EntryStruc.filesize+2]
	mov	dx,[es:bp+19]
	mov	[File_Size_High],dx
	mov	dx,disp_file_size_ptr
	call	std_printf
drCom:
;	For all files, display date & time.

	;;mov	ax,es:[bp].filedate	; AX = date word
	;mov	ax,[es:bp+EntryStruc.filedate]
	mov	ax,[es:bp+15]
	or	ax,ax			; test for null date (DOS 1.x)
	jz	short drDone		; no date, skip date/time display
	mov	bx,ax			; BX = date word
	and	ax,1Fh			; AX = day of month
	mov	dl,al			; DL = day of month
	mov	ax,bx			; AX = date word
	mov	cl,5
	shr	ax,cl			; shift day out
	and	al,0Fh			; AL = month
	mov	dh,al			; DH = month
	mov	cl,bh
	shr	cl,1			; CL = year - 1980
	xor	ch,ch			; CX = year - 1980
	add	cx,80			; CX = 2-digit year
	cmp	cl,100
	jb	short dr_1		; not year 2000 yet, skip ahead
	sub	cl,100			; adjust for 21st century
dr_1:	
	xchg	dh,dl			; DX = month/day
	mov	[DirDat_Yr],cx		; move year to msg block
	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
	;;mov	cx,es:[bp].filetime	; CX = file time
	;mov	cx,[es:bp+EntryStruc.filetime]
	mov	cx,[es:bp+13]
	jcxz	drPrint			; no time field - go print
	shr	cx,1
	shr	cx,1
	shr	cx,1			; CH = hours
	shr	cl,1
	shr	cl,1			; CL = minutes
	xchg	ch,cl			; CX = hr/min
	mov	[DirTim_Hr_Min],cx	; move time to msg block
drPrint:
	mov	dx,dirdattim_ptr
	call	std_printf		; print date & time
drDone:
	pop	es			; ES = TRANGROUP seg addr again	
	mov	bx,bp			; BX = offset of entry in TPA again
dtrRet:
	; 19/02/2023
	retn

; ---------------------------------------------------------------------------

;***	DisplayTrailer - display trailing lines for directory listing
;
;	ENTRY	LeftOnPage = # lines left on display page
;		FileCnt = # files listed
;		FileSiz = total size of files listed
;
;	EXIT	nothing
;
;	USED
;
;	EFFECTS
;
;	  Trailing info lines are displayed

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

DisplayTrailer:
	;;;test	Bits,mask bare
	;;test	word [_Bits],8
	;test	byte [_Bits],8
	test	byte [_Bits],mask.bare
	jnz	short dtrRet		; /b - don't display trailer

	call	CRLF2			; start on new line
	call	UseLine
	mov	ax,[FileCnt]		; AX = # files found

;	DisplayTotals uses this entry point.
;
DisplayCntSiz:
;	AX = # files
;	FileSiz = dword total size of files

	mov	[Dir_Num],ax		; load # files
	mov	dx,dirmes_ptr		; DX = ptr to message block
	call	std_printf		; "nnn File(s)"

	mov	dx,bytes_ptr
	call	std_printf		; "nnn bytes",cr,lf
	; 19/02/2023
	;call	UseLine
;dtrRet:
	;retn

	; 19/02/2023
	jmp	UseLine

; ---------------------------------------------------------------------------

;***	DisplayWide - display filename in wide format
;
;	ENTRY	BX = offset of entry in TPA buffer
;
;	EXIT	nothing
;
;	USED	AX,CX,DX,SI,DI
;
;	EFFECTS
;
;	  Name.ext is displayed. Cursor left at end of field (padded
;	  with blanks). Subdirectory files are displayed as [name.ext].

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah

DisplayWide:
	push	ds			; save TRANGROUP seg addr
	mov	ds,[TPA]		; DS:BX = ptr to entry
	;assume	ds:nothing

	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
	;test	byte [bx+EntryStruc.fileattr],10h
	test	byte [bx+12],ATTR_DIRECTORY
	jz	short dw1		; not a subdirectory file
	mov	al,'['
	call	PRINT_CHAR		; prefix subdirectory
dw1:	
	call	DisplayDotForm		; display name.ext

;	DX = # chars displayed in name.ext

	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
	;test	byte [bx+EntryStruc.fileattr],10h
	test	byte [bx+12],ATTR_DIRECTORY
	jz	short dw2		; not a subdirectory file
	mov	al,']'
	call	PRINT_CHAR		; postfix subdirectory
dw2:
;	Pad field with blanks.

	;mov	cx,size filename + size fileext + 1
	mov	cx,12 ; 8+3+1
					; CX = field size
	sub	cx,dx			; CX = # pad char's
	jcxz	dwDone
	mov	al,' '
dw3:	
	call	PRINT_CHAR
	loop	dw3
dwDone:	
	pop	ds			; DS = TRANGROUP seg addr again
	;assume	ds:TRANGROUP
	retn

; ---------------------------------------------------------------------------

;***	GetDriveLtr - get target drive letter
;
;	ENTRY	FCB contains drive #
;
;	EXIT	AX = "d:"
;
;	USED	nothing

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
GetDriveLtr:
	mov	al,[FCB] ; 5Ch	; AL = target drive #
	or	al,al
	jnz	short gdl1	; not current drive default, skip ahead
	mov	al,[CURDRV]	; AL = current drive #
	inc	al		; AL = 1-based drive #
gdl1:	
	add	al,'A'-1 ; 40h	; AL = target drive letter
	mov	ah,':'		; AX = "d:"
	retn

; ---------------------------------------------------------------------------

;***	SetupParamError - set up for Std_EPrintf parameter parse error message
;
;	Do for our /O and /A string parsers what Parse_With_Msg does
;	for system parser calls. Set up a message substitution block,
;	etc. for invalid value strings. I copied the procedure from
;	Setup_Parse_Error_Msg.
;
;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
;		
;
;	EXIT	AX = system parser error return code for bad param format
;		DX = ptr to message description block for Std_EPrintf
;
;	USED	SI
;
;	EFFECTS
;
;	  Msg_Disp_Class = parse error message class
;	  Message block (see DX) is set up for parse error message

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
SetupParamError:
	mov	ax,9			; parse error #
	mov	byte [msg_disp_class],parse_msg_class
	;mov	byte [msg_disp_class],2
	mov	[extend_buf_ptr],ax
	;mov	si,[bx+ResultBuffer.ValuePtr]
	mov	si,[bx+4]
	mov	[string_ptr_2],si
	mov	byte [extend_buf_sub],one_subst
	;mov	byte [extend_buf_sub],1
	mov	dx,extend_buf_ptr
	retn

; ---------------------------------------------------------------------------

;***	ZeroTotals - zero grand total file count, size
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX
;
;	EFFECTS
;
;	  FileCntTotal & FileSizTotal are zeroed.
;
;	NOTES
;
;	  FileCntTotal throuth csecUsedTotal must be together!
	
	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h	
ZeroTotals:
	mov	di,FileCntTotal

	;mov	cx,size FileCntTotal+size FileSizTotal
	mov	cx,8

	xor	al,al
	rep	stosb
	retn	

; ---------------------------------------------------------------------------

;***	CtrlCHandler - our own control-c handler
;
;	Make sure user's default directory gets restored. See notes
;	at InstallCtrlCHandler.
;
;	ENTRY	control-c
;
;	EXIT	to OldCtrlCHandler
;
;	USED	DS,flags
;
;	EFFECTS
;
;	  Restore user's default directory.
;
;	NOTES
;
;	  This handler is only installed after calling PathCrunch,
;	  which sets UserDir1, so the restoration will work.
;
;	  The original control-c vector will be restored, whether
;	  or not this one is invoked, in the HeadFix routine.

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh

CtrlCHandler:	;proc	far

;SR;
; Save all registers used: ds, dx, ax. I know ax is being used by the 
;CtrlC handler, am not sure about ds & dx. Save them to be safe
;
	push	ds
	push	cs
	pop	ds			; DS = TRANGROUP seg addr
	push	ax
	push	dx
	call	RestUDir		; restore user's default directory
	pop	dx
	pop	ax
	pop	ds
	jmp	far [cs:OldCtrlCHandler]
					; go to previous int 23 handler

; ---------------------------------------------------------------------------

;M010;start
;***	LowerCase - convert ASCII character in AL to lowercase
;
;	ENTRY	AL = character to be displayed
;
;	EXIT	AL is lowercase
;
;	USED	nothing

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
LowerCase:
	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
	jb	short lcRet
	cmp	al,'Z'
	ja	short lcRet

	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase
lcRet:
	retn

; ---------------------------------------------------------------------------

;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
;
;	ENTRY	DS:SI points to start of ASCIIZ string
;		ES = DS
;
;	EXIT	nothing
;	
;	USED	AL,SI

	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
LowercaseString:
	push	di			; save di
	mov	di,si			; ES:DI --> ASCIIZ string
	cld
NextChar: 
	lodsb				; get character from string into al
	or	al,al			; are we at end of string?
	jz	short EndOfString

	call	LowerCase		; convert character to lowercase
	stosb				; store character back into buffer
	jmp	short NextChar		; repeat until end of string

EndOfString:
	pop	di			; restore di
	retn

;M010;end

;============================================================================
; TCMD1B.ASM, MSDOS 6.0, 1991
;============================================================================
; 09/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h

; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah

; =============== S U B	R O U T	I N E =======================================

PAUSE:
	mov	dx,PAUSEMES_PTR ; 19/02/2023
	call	std_printf
	call	GETKEYSTROKE
	;call	CRLF2
	;retn
	; 19/02/2023
	jmp	CRLF2

; ---------------------------------------------------------------------------

;****************************************************************
;*
;* ROUTINE:	DEL/ERASE - erase file(s)
;*
;* FUNCTION:	PARSE command line for file or path name and /P
;*		and invoke PATHCRUNCH. If an error occurs, set
;*		up an error message and transfer control to CERROR.
;*		Otherwise, transfer control to NOTEST2 if /P not
;*		entered or SLASHP_ERASE if /P entered.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	if no error:
;*		FCB at 5ch set up with filename(s) entered
;*		Current directory set to entered directory
;*
;****************************************************************

	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
	; 10/06/2023
ERASE:
	; MSDOS 6.0

	;assume	ds:trangroup,es:trangroup

	mov	si,81h		;AC000; get command line
	mov	word [COMSW],0 	;AN000; clear switch indicator
	mov	di,PARSE_ERASE
				;AN000; Get address of PARSE_ERASE
	xor	cx,cx		;AN000; clear cx,dx
erase_scan:
	xor	dx,dx		;AN000;
	call	Parse_With_Msg	;AC018; call parser

	;cmp	ax,-1  ; 0FFFFh
	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
	;je	short good_line	;AN000; yes - done parsing
	;;cmp	ax,0
	;;cmp	ax,RESULT_NO_ERROR ; 0
	;and	ax,ax		;AC000; did we have an error?
	;jnz	short errj2	;AC000; yes exit
	; 10/06/2023
	inc	ax  ; cmp ax,-1
	jz	short good_line ; 0FFFFh -> 0
	dec	ax  ; cmp ax,0	
	jnz	short errj2  ; 1 -> 0
	; ax = 0

	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
				;AN000; was /P entered?
	je	short set_erase_prompt
				;AN000; yes - go set prompt
;
; Must be filespec since no other matches occurred. move filename to srcbuf
;
	push	si		;AC000; save position in line
	lds	si,[PARSE1_ADDR]
				;AC000; get address of filespec
	;cmp	byte [si+1],colon_char
	cmp	byte [si+1],':'	;AC000; drive specified?
	jne	short erase_drive_ok
				;AC000; no - continue
	;cmp	byte [si+2],END_OF_LINE_OUT	
	cmp	byte [si+2],0	;AC000; was only drive entered?
	jne	short erase_drive_ok
				;AC000; no - continue
	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
				;AN022; get message number in control block
	jmp	short extend_setup
				;AC000; exit
erase_drive_ok:
	call	Move_To_SrcBuf	;AC000; move to srcbuf
	pop	si		;AC000; get position back
	jmp	short erase_scan
				;AN000; continue parsing
set_erase_prompt:
	cmp	word [COMSW],0 	;AN018; was /P already entered?
	jz	short ok_to_set_erase_prompt
				;AN018; no go set switch
	;mov	ax,1
	mov	ax,MoreArgs_Ptr 
				;AN018; set up too many arguments
	call	setup_parse_error_msg
				;AN018; set up an error message
	jmp	short errj2	;AN018; exit

ok_to_set_erase_prompt: 	;AN018;
	inc	word [COMSW]	;AN000; indicate /p specified
	jmp	short erase_scan
				;AN000; continue parsing
good_line:			;G  We know line is good
	call	PathCrunch
	jnc	short checkdr
	mov	ax,[Msg_Numb]	;AN022; get message number
	;cmp	ax,0		;AN022; was message flag set?
	or	ax,ax
	jnz	short extend_setup
				;AN022; yes - print out message
	;cmp	byte [DestIsDir],0
	cmp	[DestIsDir],al 	; No CHDIRs worked
	jnz	short badpath_err
				;AC022; see if they should have
checkdr:
	cmp	word [COMSW],0 	;AN000; was /p specified
	jz	short notest2j	;AN000; no - go to notest2
	jmp	slashp_erase	;AN000; yes - go to slashp_erase
notest2j:
	jmp	notest2

badpath_err:			;AN022; "Path not found" message
	mov	ax,ERROR_PATH_NOT_FOUND ; 3
				;AN022; set up error number
extend_setup:			;AN022;
	;mov	byte [msg_disp_class],1
	mov	byte [msg_disp_class],ext_msg_class
				;AN022; set up extended error msg class
	mov	dx,extend_buf_ptr
				;AC022; get extended message pointer
	mov	[extend_buf_ptr],ax
				;AN022; get message number in control block
errj2:				;AC022; exit jump
	jmp	cerror		;AN022;

; 20/02/2023
%if 0
	; MSDOS 3.3
	mov	dx,BADARGSPTR
	mov	si,80h
	lodsb
	or	al,al
	jz	short ERRJ2
	call	SCANOFF
	cmp	al,0Dh		; Return key
	jz	short ERRJ2	; If so no parameters specified
	push	dx
	push	si
	mov	dx,FNOTFOUNDPTR
ERASE_SCAN:
	lodsb
	call	DELIM
	jz	short ERASE_CHKDELIMCHR
	cmp	al,0Dh
	jz	short GOOD_LINE
	jmp	short ERASE_SCAN
ERASE_CHKDELIMCHR:
	cmp	al,20h
	jg	short ERRJ2
	lodsb
	call	DELIM
	jz	short ERASE_CHKDELIMCHR
	cmp	al,0Dh
	jz	short GOOD_LINE
	mov	dx,BADARGSPTR
	jmp	short ERRJ2
GOOD_LINE:
	pop	si
	pop	dx
	push	si
	call	PATHCRUNCH
	jnc	short CHECKDR
	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
	jz	short CHECKDR	   ; see if they should have
BADCDERR:
	pop	si
	mov	dx,BADCDPTR
ERRJ2:
	jmp	CERROR
CHECKDR:
	mov	dx,FNOTFOUNDPTR
	pop	cx
	mov	al,' '
	;cmp	[5Dh],al
	cmp	[FCB+1],al
	jz	short ERRJ2
	add	cx,3
	cmp	si,cx
	jnz	short NOTEST2J
	mov	al,':'
	cmp	[si-2],al
	jz	short ERRJ2
NOTEST2J:
	jmp	NOTEST2
%endif

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 CRENAME - rename file(s)
; *
; * FUNCTION:	 PARSE command line for one full filespec and one
; *		 filename. Invoke PATHCRUNCH on the full filespec.
; *		 Make sure the second filespec only contains a
; *		 filename. If both openands are valid, attempt
; *		 to rename the file.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
CRENAME:
	; MSDOS 6.0
	;assume	ds:trangroup,es:trangroup

	mov	si,81h		;AC000; Point to command line
	mov	di,PARSE_RENAME
				;AN000; Get address of PARSE_RENAME
	xor	cx,cx		;AN000; clear cx,dx
	xor	dx,dx		;AN000;
	call	Parse_With_Msg	;AC018; call parser
	;cmp	ax,RESULT_NO_ERROR ; 0
	or	ax,ax ; 0 ?	;AC000; did we have an error?
;	jz	short crename_no_parse_error
				;AC000; no - continue
	jnz	short crename_parse_error
				;AC000; Yes, fail. (need long jump)
;
;  Get first file name returned from parse into our buffer
;
crename_no_parse_error:
	push	si		;AN000; save position in line
	lds	si,[PARSE1_ADDR]
				;AN000; get address of filespec
	call    Move_To_SrcBuf	;AN000; move to srcbuf
	pop	si		;AN000; restore position in line

	xor	dx,dx		;AN000; clear dx
	call	Parse_With_Msg	;AC018; call parser
	;cmp	ax,RESULT_NO_ERROR
	and	ax,ax ; 0 ?	;AN000; did we have an error?
	jnz	short crename_parse_error
				;AN000; Yes, fail.
;
;  Check the second file name for drive letter colon
;
	push	si		;AN000; save position in line
	lds	si,[PARSE1_ADDR]
				;AC000; get address of path
	;mov	al,':'		;AC000;
	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
	cmp	byte [si+1],':'
	jnz	short ren_no_drive
				;AN000; Yes, error
	;mov	byte [msg_disp_class],2
	mov	byte [msg_disp_class],parse_msg_class
				;AN000; set up parse error msg class
	mov	dx,extend_buf_ptr
				;AC000; get extended message pointer
	;mov	word [extend_buf_ptr],0Ah
	mov	word [extend_buf_ptr],BadParm_Ptr
				;AN000; get "Invalid parameter" message number
	pop	si		;AN000;
crename_parse_error:		;AC022;
	jmp	short errj	;AC000;

;  Get second file name returned from parse into the fCB. Save
;  character after file name so we can later check to make sure it
;  isn't a path character.

ren_no_drive:
	mov	di,FCB+10h ; 6Ch
				;AC000; set up to parse second file name
	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
	mov	ax,2901h
	int	21h		;AC000; do the function
	lodsb			;AC000; Load char after filename
	mov	[One_Char_Val],al
				;AN000; save char after filename
	pop	si		;AN000; get line position back
;
; We have source and target. See if any args beyond.
;
	mov	di,PARSE_RENAME
				;AC000; get address of parse_rename
	call	parse_check_eol ;AC000; are we at end of line?
	jnz	short crename_parse_error
				;AN000; no, fail.

	call	PathCrunch
	mov	dx,BADCPMES_PTR
	jz	short errj2	; If 1st parm a dir, print error msg
	jnc	short notest3
	mov	ax,[Msg_Numb]	;AN022; get message number
	;cmp	ax,0		;AN022; was message flag set?
	and	ax,ax ; 0 ?
	jnz	short extend_setup
				;AN022; yes - print out message
	;cmp	byte [DestIsDir],0
	cmp	[DestIsDir],al	; No CHDIRs worked
	jz	short notest3 	; see if they should have
	Jmp	badpath_err	;AC022; set up error
notest3:
	mov	al,[One_Char_Val]
				;AN000; move char into AX
	mov	dx,INORNOT_PTR 
				; Load invalid fname error ptr
	call	pathchrcmp	; Is the char in al a path sep?
	jz	short errj	; Yes, error - 2nd arg must be
				;  filename only.
	;mov	ah,FCB_Rename
	mov	ah,17h
	mov	dx,FCB ; 5Ch
	int	21h
	cmp	al,0FFh		; Did an error occur??
	jne	short renameok

	call	get_ext_error_number
				;AN022; get extended error
	push	ax		;AC022; Save results
	mov	al,0FFh		; Restore original error state
renameok:
	push	ax
	call	RestUDir
	pop	ax
	inc	al
	;;retnz
	;jz	short rn1
	;retn	
	jnz	short ret56
rn1:
	pop	ax		;AC022; get the error number back
	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
				;AN022; error file not found?
	jz	short use_renerr
				;AN022; yes - use generic error message
	cmp	ax,ERROR_ACCESS_DENIED ; 5 
				;AN022; error file not found?
	jz	short use_renerr
				;AN022; yes - use generic error message
	jmp	extend_setup	;AN022; need long jump - use extended error

use_renerr:
	mov	dx,RENERR_PTR	;AC022;
errj:
	jmp	cerror
ret56:
;typefil_ret:	; 20/02/2023 ; 17/04/2023	
	retn

; 20/02/2023
%if 0
	; MSDOS 3.3
	mov	dx,BADARGSPTR
	call	SCANOFF
	cmp	al,0Dh
	jz	short ERRJ2
	call	PATHCRUNCH
	mov	dx,BADCPMESPTR
	jz	short ERRJ2
	jnb	short CRENAME_NO_PARSE_ERROR
	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
	jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
	jmp	short BADCDERR

;  Get first file name returned from parse into our buffer

CRENAME_NO_PARSE_ERROR:
	mov	si,[PATHPOS]
	call	SCANOFF
	cmp	al,0Dh
	mov	dx,BADARGSPTR
	jz	short ERRJ
	mov	al,':'
	mov	dx,BADPARMPTR
	cmp	[si+1],al
	jz	short ERRJ

;  Get second file name returned from parse into the FCB. Save
;  character after file name so we can later check to make sure it
;  isn't a path character.

REN_NO_DRIVE:
	;mov	di,6Ch
	mov	di,FCB+10h
	mov	ax,(Parse_File_Descriptor<<8)|01h ; 2901h
	int	21h	; DOS -	PARSE FILENAME
			; DS:SI	-> string to parse
			; ES:DI	-> buffer to fill with unopened	FCB
			; AL = bit mask	to control parsing
	mov	al,' '
	;cmp	[6Dh],al
	cmp	[FCB+10h+1],al	; Check if parameter exists
	jz	short ERRJ	; Error if missing parameter
	lodsb
	mov	dx,INORNOTPTR
	call	PATHCHRCMP
	jz	short ERRJ
	mov	ah,FCB_RENAME ; 17h
	mov	dx,FCB ; 5Ch
	int	21h	; DOS -	RENAME FILE via	FCB
			; DS:DX	-> FCB
			; FCB contains new name	starting at byte 17h.
	cmp	al,0FFh		; Did an error occur??	
	jnz	short RENAMEOK
	stc
	mov	dx,RENERRPTR
	call	GET_EXT_ERR_NUMBER ; get extended error
	push	dx
	mov	al,0FFh		; Restore original error state
RENAMEOK:
	push	ax
	call	RESTUDIR
	pop	ax
	inc	al
	jz	short RENAME_ERR
RENAME_RETN:
TYPELP_RET:
	retn
RENAME_ERR:
	pop	dx
ERRJ:				; Retro DOS v3.0
	call	STD_EPRINTF
	jmp	TCOMMAND

; ---------------------------------------------------------------------------

;ERRJ:
;	jmp	CERROR

; ---------------------------------------------------------------------------

;TYPELP_RET:
;	retn

%endif

; ---------------------------------------------------------------------------

;****************************************************************
;*
;* ROUTINE:	TYPEFIL - Display the contents of a file to the
;*		standard output device
;*
;* SYNTAX:	TYPE filespec
;*
;* FUNCTION:	If a valid filespec is found, read the file until
;*		1Ah and display the contents to STDOUT.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
TYPEFIL:
	; MSDOS 6.0	
	;assume	ds:trangroup,es:trangroup

	mov	si,81h
	mov	di,PARSE_MRDIR
				;AN000; Get address of PARSE_MRDIR
	xor	cx,cx		;AN000; clear cx,dx
	xor	dx,dx		;AN000;
	call	Parse_With_Msg	;AC018; call parser
	;cmp	ax,RESULT_NO_ERROR
	or	ax,ax ; 0 ?	;AC000; did we have an error?
	jnz	short typefil_parse_error
				;AN000; yes - issue error message

	push	si		;AC000; save position in line
	lds	si,[PARSE1_ADDR]
				;AC000; get address of filespec
	call	Move_To_SrcBuf	;AC000; move to srcbuf
	pop	si		;AC000; get position back
	mov	di,PARSE_MRDIR
				;AC000; get address of parse_mrdir
	call	parse_check_eol ;AC000; are we at end of line?
	;jz	short gottarg 	;AC000; yes - continue
	; 20/02/2023
;typefil_parse_error:		;AN000; no - set up error message and exit
	;jmp	cerror
	jnz	short typefil_parse_error
gottarg:
	call	SETPATH
	test	byte [DestInfo],00000010b ; 2
				; Does the filespec contain wildcards
	jz	short nowilds 	; No, continue processing
	mov	dx,INORNOT_PTR	; Yes, report error
	; 20/02/2023
typefil_parse_error:
	jmp	cerror
nowilds:
	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
	mov	ax,6C00h
	;mov	bx,read_open_mode ; 0
				;AN000; get open mode for TYPE
	xor	cx,cx		;AN000; no special files
	mov	bx,cx ; 20/02/2023
	mov	dx,101h
	;mov	dx,read_open_flag ; 101h
				;AN000; set up open flags
	mov	si,SrcBuf	;AN030; get file name
	int	21h
	jnc	short typecont	; If open worked, continue. Otherwise load

typerr: 			;AN022;
	push	cs		;AN022; make sure we have local segment
	pop	ds		;AN022;
	call	Set_Ext_Error_Msg ;AN022;
	mov	word [string_ptr_2],SrcBuf 
				;AC022; get address of failed string
	;mov	byte [extend_buf_sub],1
	mov	byte [extend_buf_sub],one_subst
				;AC022; put number of subst in control block
	jmp	cerror		;AC022; exit

typecont:
	mov	bx,ax		;AC000; get Handle
;M043
; We should do the LSEEK for filesize only if this handle belongs to a file
;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
;indicate it is a device.
;
	;mov	ax,(IOCTL shl 8) or 0
	mov	ax,4400h
	int	21h

	test	dl,80h		;is it a device?
	jz	short not_device
				;no, a file

	mov	word [TypeFilSiz+2],-1
				;indicate it is a device
	jmp	short dotype
not_device:
;SR;
; Find the filesize by seeking to the end and then reset file pointer to
;start of file

	;mov	ax,(LSEEK shl 8) or 2
	mov	ax,4202h
	xor	dx,dx
	mov	cx,dx		;seek  to end of file
	int	21h

	mov	[TypeFilSiz],ax
	mov	[TypeFilSiz+2],dx ;store filesize
	;mov	ax,(LSEEK shl 8) or 0
	mov	ax,4200h
	xor	dx,dx
	int	21h	        ;reset file pointer to start
dotype:				;M043
	mov	byte [zflag],0 	; Reset ^Z flag
	mov	ds,[TPA]
	xor	dx,dx
	;ASSUME	DS:NOTHING
typelp:
	cmp	byte [cs:zflag],0
				;AC050; Is the ^Z flag set?
	;retnz			; Yes, return
	; 17/04/2023
	jz	short tf1
	retn
tf1:
	mov	cx,[cs:BYTCNT]	;AC056; No, continue

;Update the filesize left to read

	cmp	word [cs:TypeFilSiz+2],-1
				;is it a device? M043
	je	short typ_read	;yes, just read from it; M043

	cmp	word [cs:TypeFilSiz+2],0
				;more than 64K left?
	jz	short lt64k	;no, do word subtraction
	sub	[cs:TypeFilSiz],cx
	sbb	word [cs:TypeFilSiz+2],0
				;update filesize
      	jmp	short typ_read	;do the read
lt64k:
	cmp	cx,[cs:TypeFilSiz]
				;readsize <= buffer?
	jbe	short gtbuf	; yes, just update readsize

;Buffer size is larger than bytes to read

	mov	cx,[cs:TypeFilSiz]
	jcxz	typelp_ret
	mov	word [cs:TypeFilSiz],0
	jmp	short typ_read
gtbuf:
	sub	[cs:TypeFilSiz],cx
				;update filesize remaining
typ_read:
	;mov	ah,read
	mov	ah,3Fh
	int	21h		
	jnc	short tf2	;M043
	jmp	typerr		;M043
tf2:				;M043
;M043;	jc	typerr		;AN022; Exit if error

	mov	cx,ax
	jcxz	typelp_ret	;AC000; exit if nothing read
	push	ds
	pop	es		; Check to see if a ^Z was read.
	;assume es:nothing
	xor	di,di
	push	ax
	mov	al,1Ah
	repnz	scasb
	pop	ax
	xchg	ax,cx
	;cmp	ax,0
	and	ax,ax
	jnz	short foundz	; Yes, handle it
	cmp	byte [di-1],1Ah	; No, double check
	jnz	short typecont2	; No ^Z, continue
foundz:
	sub	cx,ax		; Otherwise change cx so that only those
	dec	cx		;  bytes up to but NOT including the ^Z
	push	cs		;  will be typed.
	pop	es
	;assume es:trangroup
	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
typecont2:			;  will quit after this write.
	push	bx
	mov	bx,1
	;mov	ah,Write
	mov	ah,40h
	int	21h
	pop	bx
	jc	short Error_outputj
	cmp	ax,cx
	jnz	short tf3	;M043
	jmp	typelp		;M043
tf3:				;M043
;M043;	jz	short typelp
	dec	cx
	cmp	ax,cx
	;;retz			; One less byte OK (^Z)
	;jnz	short Error_outputj
;tf4:
	;retn
	jz	short typelp_ret ; 20/02/2023

Error_outputj:
	mov	bx,1
	;mov	ax,IOCTL SHL 8
	mov	ax,4400h
	int	21h
	test	dl,80h
	;test	dl,devid_ISDEV
	;;retnz			; If device, no error message
	;jnz	short tf4
	jnz	short typelp_ret
	jmp	error_output
typelp_ret:
	retn

; 20/02/2023
%if 0
	; MSDOS 3.3
	mov	si,81h
	call	SCANOFF		; Skip to first non-delim
	cmp	al,0Dh
	jnz	short GOTTARG
	mov	dx,BADARGSPTR

	;jmp	CERROR
	jmp	short ERRJ	; No args
GOTTARG:
	call	SETPATH
	test	byte [DESTINFO],2
	jz	short NOWILDS
	mov	dx,INORNOTPTR

	;jmp	CERROR
	jmp	short ERRJ
NOWILDS:
	mov	ax,OPEN*256 ; 3D00h
	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 0 - read
	jnc	short TYPECONT
	mov	dx,FNOTFOUNDPTR
	cmp	ax,2
	jz	short ERRJ
	mov	dx,BADCPMESPTR
	stc
	call	GET_EXT_ERR_NUMBER
	
	;jmp	CERROR
	jmp	short ERRJ
TYPECONT:
	mov	byte [ZFLAG],0	; Reset ^Z flag
	mov	bx,ax		; Handle
	mov	ds,[TPA]
	xor	dx,dx
TYPELP:
	cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
	jnz	short RENAME_RETN ; Yes, return	
	mov	cx,[cs:BYTCNT]	; No, continue
	mov	ah,READ ; 3Fh
	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
			; BX = file handle,CX = number	of bytes to read
			; DS:DX	-> buffer
	mov	cx,ax
	jcxz	TYPELP_RET	; exit if nothing read
				; Check to see if a ^Z was read.
	push	ds
	pop	es		
	xor	di,di
	push	ax
	mov	al,1Ah
	repne	scasb
	pop	ax
	xchg	ax,cx
	cmp	ax,0
	jnz	short FOUNDZ	; Yes, handle it
	cmp	byte [di-1],1Ah	; No, double check
	jnz	short TYPECONT2	; No ^Z, continue
FOUNDZ:
	sub	cx,ax		; Otherwise change cx so that only those
	dec	cx		;  bytes up to but NOT including the ^Z
	push	cs		;  will be typed.
	pop	es
	not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
				;  will quit after this write.
TYPECONT2:
	push	bx
	mov	bx,1
	mov	ah,WRITE ; 40h
	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			; BX = file handle, CX = number of bytes to write,
			; DS:DX -> buffer
	pop	bx
	jc	short ERROR_OUTPUTJ
	cmp	ax,cx
	jz	short TYPELP
	dec	cx
	cmp	ax,cx		; One less byte OK (^Z)
	jnz	short ERROR_OUTPUTJ
TYPEFIL_RETN:
	retn
ERROR_OUTPUTJ:
	mov	bx,1
	mov	ax,IOCTL*256 ; 4400h
	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
	;test	dl,devid_ISDEV
	test	dl,80h
	jnz	short TYPEFIL_RETN ; If device, no error message
	jmp	ERROR_OUTPUT
%endif

; ---------------------------------------------------------------------------

; VOLUME command displays the volume ID on the specified drive

	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; 10/06/2023
VOLUME:
	; MSDOS 6.0
	mov	si,81h
	mov	di,PARSE_VOL
				;AN000; Get address of PARSE_VOL
	xor	cx,cx		;AN000; clear cx,dx
	xor	dx,dx		;AN000;
	call	Parse_With_Msg	;AC018; call parser

	;cmp	ax,-1 ; 0FFFFh
	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
	;je	short OkVolArg	;AC000; Yes, display default volume ID
	;;cmp	ax,RESULT_NO_ERROR
	;;cmp	ax,0		;AC000; did we have an error?
	;or	ax,ax ; 0?
	;jnz	short badvolarg	;AC000; Yes, fail.
	; 10/06/2023
	inc	ax  ; cmp ax,-1
	jz	short OkVolArg ; 0FFFFh -> 0
	dec	ax  ; cmp ax,0
	jnz	short badvolarg ; 1 -> 0
	; ax = 0

; We have parsed off the drive. See if there are any more chars left

	mov	di,PARSE_VOL
				;AC000; get address of parse_vol
	xor	dx,dx		;AC000;
	call	parse_check_eol ;AC000; call parser
	jz	short OkVolArg	;AC000; yes, end of road

; The line was not interpretable. Report an error.

badvolarg:
	jmp	cerror

; 20/02/2023
%if 0
	; MSDOS 3.3
	mov	si,81h
	call	SCANOFF		; Skip to first non-delim
	;mov	ah,[5Ch]
	mov	ah,[FCB]
	;mov	byte [5Ch],0
	mov	byte [FCB],0
	cmp	al,0Dh		; are we at end of line?
	jz	short OKVOLARG	; Yes, display default volume ID
	;mov	[5Ch],ah
	mov	[FCB],ah
	lodsb
	lodsb
	cmp	al,':'
	jnz	short VOLUME_ERR
	call	SCANOFF
	cmp	al,0Dh
	jz	short OKVOLARG
VOLUME_ERR:
	mov	dx,BADDRVPTR
	jmp	CERROR

; ---------------------------------------------------------------------------

OKVOLARG:
	call	CRLF2
	push	ds
	pop	es
	;mov	di,55h
	mov	di,FCB-7	; Set up extended FCB
	mov	al,-1
	stosb
	xor	ax,ax
	stosw
	stosw
	stosb
	mov	al,8		; Look for volume label
	stosb
	inc	di		; Skip drive byte
	mov	cx,11
	mov	al,'?'
	rep stosb
	mov	dx,DIRBUF
	mov	ah,Set_DMA ; 1Ah
	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
			; DS:DX	-> disk	transfer buffer
	;mov	dx,55h
	mov	dx,FCB-7
	mov	ah,Dir_Search_First ; 11h
	int	21h	; DOS -	SEARCH FIRST USING FCB
			; DS:DX	-> FCB
	jmp	PRINTVOL
%endif

; ---------------------------------------------------------------------------

;***	DisAppend - disable APPEND
;
;	ENTRY	nothing
;
;	EXIT	nothing
;
;	USED	AX,BX
;
;	EFFECTS
;
;	  APPEND is disabled. If it was active, it will be re-enabled
;	  after the command finishes, by the HeadFix routine.
;
;	NOTE
;
;	  This routine must not be called more than once during a single
;	  command cycle. The second call would permanently disable APPEND.

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh

	; MSDOS 6.0
DisAppend:
	push	ds			; save DS
	push	es			; save ES
	push	di

	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
	mov	ax,0B700h
	int	2Fh			; talk to APPEND via multiplex
	or	al,al
	jz	short daRet		; APPEND not installed, return

	;mov	ax,APPENDDOS		; AX = Get Append Version code
	mov	ax,0B702h
	int	2Fh			; talk to APPEND via multiplex
	cmp	ax,0FFFFh
	jne	short daRet		; it's not a local version, return

	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
	mov	ax,0B706h
	int	2Fh			; talk to APPEND via multiplex

	mov	ds,[RESSEG]		; DS = resident seg addr

	mov	[Append_State],bx	; Append_State = saved APPEND state
	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state

	xor	bx,bx			; BX = APPEND state = off
	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
	mov	ax,0B707h
	int	2Fh			; talk to APPEND via multiplex
daRet:	
	pop	di
	pop	es			; restore ES
	pop	ds			; restore DS

	retn

; ---------------------------------------------------------------------------

; Find the Volume ID on the disk.

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 6.0
OkVolArg:
	call	DisAppend		; disable APPEND
	call	CRLF2
	;mov	al,blank			
	mov	al,' ' ; 20h		;AN051; Print out a blank
	call	PRINT_CHAR		;AN051;  before volume message
	push	ds
	pop	es

; Volume IDs are only findable via extended FCBs or find_first with attributes
; of volume_id ONLY.

	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
	mov	al,-1			; Tag to indicate Extention
	stosb
	xor	ax,ax			; Zero padding to volume label
	stosw
	stosw
	stosb
	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
	stosb
	inc	di			; Skip drive byte; it is already set
	mov	cx,11			; fill in remainder of file
	mov	al,'?'
	rep	stosb

; Set up transfer address (destination of search first information)

	mov	dx,DIRBUF
	;mov	ah,Set_DMA
	mov	ah,1Ah
	int	21h

; Do the search

	mov	dx,FCB-7 ; 55h
	;mov	ah,Dir_Search_First
	mov	ah,11h
	int	21h

;********************************
; Print volume ID info

	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
	add	al,'@'  ; add al,40h
	cmp	al,'@'
	jne	short drvok
	mov	al,[CURDRV]
	;add	al,capital_A
	add	al,'A'
drvok:
	mov	[vol_drv],al		;AC000; get drive letter into argument
	pop	ax			;AC000; get return code back
	or	al,al			;AC000; volume label found?
	jz	short Get_vol_name	;AC000; volume label exists - go get it
	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
	jmp	short print_serial	;AC000; go print it

Get_vol_name:
	mov	di,CHARBUF
	mov	dx,di
	mov	si,DIRBUF+8		;AN000;  3/3/KK
	mov	cx,11			;AN000;  3/3/KK
	rep	movsb			;AN000;  3/3/KK

	xor	al,al			;AC000; store a zero to terminate the string
	stosb
	mov	dx,VolMes_Ptr		;AC000; set up message

print_serial:

; Attempt to get the volume serial number from the disk. If an error
; occurs, do not print volume serial number.

	push	dx			;AN000; save message offset
	;mov	ax,(GetSetMediaID SHL 8)
	mov	ax,6900h		;AC036; Get the volume serial info
	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
	mov	dx,vol_ioctl_buf	;AN000;target buffer
	int	21h			;AN000; do the call
			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
			; AL = 00h get serial number / 01h set serial number
			; BL = drive (0=default, 1=A, 2=B, etc)
			; DS:DX -> disk info
	pop	dx			;AN000; get message offset back
	jc	short printvol_end	;AN000; if error, just go print label
	call	std_printf		;AC000; go print volume message
	;mov	al,blank				
	mov	al,' ' ; 20h		;AN051; Print out a blank
	call	PRINT_CHAR		;AN051;  before volume message
	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
printvol_end:
	jmp	std_printf		;AC000; go print and exit

; ---------------------------------------------------------------------------

;****************************************************************
;*
;* ROUTINE:	Set_ext_error_msg
;*
;* FUNCTION:	Sets up extended error message for printing
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	extended error message set up in extended error
;*		buffer.
;*
;****************************************************************
	
	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 6.0
Set_Ext_Error_Msg:			;AN000;
	call	get_ext_error_number	;AC022; get the extended error
	mov	byte [msg_disp_class],ext_msg_class
	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
	stc				;AN000; make sure carry is set
	retn				;AN000; return

; ---------------------------------------------------------------------------

;****************************************************************
;*
;* ROUTINE:	Get_ext_error_number
;*
;* FUNCTION:	Does get extended error function call
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	AX - extended error number
;*
;****************************************************************

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 6.0
get_ext_error_number:			;AN022;

	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
					;AN022; save registers
	push	bx
	push	cx
	push	dx
	push	si
	push	di
	push	bp
	push	es
	push	ds
	;mov	ah,GetExtendedError	;AN022; get extended error
	mov	ah,59h
	xor	bx,bx			;AN022; clear BX
	int	21h			;AN022;
			; DOS - 3+ - GET EXTENDED ERROR CODE
			; BX = version code (0000h for DOS 3.x)

	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
					;AN022; restore registers
	pop	ds
	pop	es
	pop	bp
	pop	di
	pop	si
	pop	dx
	pop	cx
	pop	bx

	retn				;AN022; return

;============================================================================
; TCMD2A.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h

; 21/02/2023 - Retro DOS v4.0 (& v4.1)
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h

; ---------------------------------------------------------------------------

; MSDOS 6.0
;***	Version - display DOS version
;
;	SYNTAX	ver [/debug]
;
;		/debug - display additional DOS configuration info
;
;	ENTRY	command-line tail is in PSP
;
;	EXIT	if successful, nothing
;		if parse fails,
;		  parse error message is set up (for Std_EPrintf)
;		    AX = system parser error code
;		    DX = ptr to message block
;		  we jump to CError
;
;	EFFECTS
;	  If parse fails, a parse error message is displayed.
;	  Otherwise, version message is displayed.
;	  If /debug is specified, additional DOS info is displayed.

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
VERSION:
	;assume	ds:TRANGROUP,es:TRANGROUP

;	Parse command line for /debug switch.

	mov	si,81h			; DS:SI = ptr to command tail
	mov	di,PARSE_VER		; ES:DI = ptr to parse block
	xor	cx,cx			; CX = # positional param's found
	call	Parse_With_Msg

	mov	bl,1			; BL = flag = /debug present
	;cmp	ax,RESULT_NO_ERROR
	;cmp	ax,0
	;je	short verPrintVer	; something parsed - must be /debug
	or	ax,ax
	jz	short verPrintVer 
	dec	bl			; BL = flag = no /debug present
	;cmp	ax,END_OF_LINE ; -1
	cmp	ax,-1 ; 0FFFFh
	je	short verPrintVer	; reached end of line - ok

;	The parse failed. Error message has been set up.

	jmp	cerror

verPrintVer:
	push	bx			; save /debug flag
	call	CRLF2
	call	PRINT_VERSION
	call	CRLF2
	pop	bx   			; BL = /debug flag
	or	bl,bl
	jz	short verDone		; /debug is false - we're done

;*	For /debug, display DOS internal revision and DOS location
;	(low memory, HMA, or ROM).

;	Bugbug:	use symbols for bitmasks below.

	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
	mov	ax,3306h
	int	21h
		; DOS - 5+ Get TRUE Version Number
		; (BL major, BH minor, DL revision, DH flags)
	mov	al,dl			;revision number in dl; M013
	mov	bh,dh			;flags in dh now; M013
;M032	and	al,7			; AL = DOS internal revision
	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
	;jbe	short @f	 ;M032	; A-to-Z revision ok
	jbe	short ver1
	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
;@@:
ver1:
	add	al,'A' ; 41h		; AL = DOS internal rev letter
	mov	[One_Char_Val],al
	mov	dx,dosrev_ptr
	call	std_printf		; print DOS internal revision

	mov	cl,4
	shr	bh,cl			; CY = DOS in ROM
	jc	short verRom
	shr	bh,1			; CY = DOS in HMA
	jc	short verHma

;	DOS isn't in ROM or HMA, so it must be in lower memory.

	;mov	dx,offset TRANGROUP:DosLow_Ptr
	mov	dx,DosLow_Ptr
	jmp	short verPrintLoc
verRom: 
	;mov	dx,offset TRANGROUP:DosRom_Ptr
	mov	dx,DosRom_Ptr
	jmp	short verPrintLoc
verHma: 
	;mov	dx,offset TRANGROUP:DosHma_Ptr
	mov	dx,DosHma_Ptr
verPrintLoc:
	call	std_printf
verDone:
	jmp	CRLF2

; 21/02/2023
;	; MSDOS 3.3
;VERSION:
;	call	CRLF2
;	call	PRINT_VERSION
;	jmp	CRLF2

; =============== S U B	R O U T	I N E =======================================

	; 21/02/2023 - Retro DOS v4.0
PRINT_VERSION:
	;mov	ah,GET_VERSION ; 30h
	mov	ah,30h
	int	21h	; DOS -	GET DOS	VERSION
			; Return: AL = major version number (00h for DOS 1.x)
	push	ax
	xor	ah,ah
	mov	[Major_Ver_Num],ax
	pop	ax
	xchg	ah,al
	xor	ah,ah
	mov	[Minor_Ver_Num],ax
	mov	dx,VerMes_Ptr
	jmp	std_printf

; =============== S U B	R O U T	I N E =======================================

	; 21/02/2023 - Retro DOS v4.0
PRINT_PROMPT:
	push	ds
	push	cs
	pop	ds		; Make sure DS is in TRANGROUP
	push	es
	call	find_prompt	; Look for prompt string
	jc	short PP0	; Can't find one	
	cmp	byte [es:di],0
	jnz	short PP1
PP0:				; Use default prompt
	call	PRINT_DRIVE
	mov	al,'>'
	;mov	al,SYM
	call	PRINT_CHAR
	jmp	short PP5
;PP1:
;	mov	al,[es:di]	; Get a char
;	inc	di
;	or	al,al
;	jz	short PP5	; Nul terminated
;	; 21/02/2023
;	cmp	al,'$' ; 24h
;	;cmp	al,[DOLLAR]	; Meta character
;	jz	short PP2	; Nope
;	call	PRINT_CHAR
;	jmp	short PP1
PP2:
	mov	al,[es:di]
	inc	di
	;mov	bx,CLSSTRING+2	; "[2J"
	mov	bx,PROMPT_TABLE-3
	or	al,al
	jz	short PP5
PP3:
	add	bx,3
	; 21/02/2023
	call	UPCONV		; MSDOS 5.0 (& 6.0)
	;call	UPCONV_MAPCALL  ; MSDOS 3.3
	cmp	al,[bx]
	jz	short PP4
	cmp	byte [bx],0
	jnz	short PP3
	;jmp	short PP1
	; 21/02/2023
PP1:
	mov	al,[es:di]	; Get a char
	inc	di
	or	al,al
	jz	short PP5	; Nul terminated
	; 21/02/2023
	cmp	al,'$' ; 24h
	;cmp	al,[DOLLAR]	; Meta character
	jz	short PP2	; Nope
	call	PRINT_CHAR
	jmp	short PP1
PP4:
	push	es
	push	di
	push	cs
	pop	es
	call	word [bx+1]
	pop	di
	pop	es
	jmp	short PP1
PP5:
	pop	es		; Restore segments
	pop	ds
	retn

; ---------------------------------------------------------------------------

PRINT_BACK:
	; 21/02/2023
	mov	dx,dback_ptr
	jmp	std_printf

; ---------------------------------------------------------------------------

PRINT_EQ:
	mov	al,'='
	jmp	short PRINT_CHAR

; ---------------------------------------------------------------------------

PRINT_ESC:
	mov	al,1Bh
	jmp	short PRINT_CHAR

; ---------------------------------------------------------------------------

	; 21/02/2023
PRINT_G:
	;mov	al,[RABRACKET]
	mov	al,'>' ; 3Eh
	jmp	short PRINT_CHAR

; ---------------------------------------------------------------------------

	; 21/02/2023
PRINT_L:
	;mov	al,[LABRACKET]
	mov	al,'<' ; 3Ch
	jmp	short PRINT_CHAR

; ---------------------------------------------------------------------------

	; 21/02/2023
Print_B:
	;mov	al,[VBAR]
	mov	al,'|' ; 7Ch

; =============== S U B	R O U T	I N E =======================================

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
PRINT_CHAR:
	; MSDOS 6.0

;	Bugbug:	Why bother with ds,es here?
		
	push	es
	push	ds
	pop	es
	push	di
	push	dx
	mov	dl,al		;AC000; Get char into al
	;mov	ah,STD_CON_OUTPUT
				;AC000; print the char to stdout
	mov	ah,2
	int	21h		;AC000;
	pop	dx
	pop	di
	pop	es
	retn

;21/02/2023
%if 0
	; MSDOS 3.3
	push	es
	push	ds
	pop	es
	push	di
	push	dx
	mov	di,ONE_CHAR_VAL	
	stosb
	mov	dx,ONECHRVALPTR
	call	STD_PRINTF
	pop	dx
	pop	di
	pop	es
	retn
%endif

; ---------------------------------------------------------------------------

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
PRINT_DRIVE:
	;mov	ah,GET_DEFAULT_DRIVE ; 19h
	mov	ah,19h
	int	21h	; DOS -	GET DEFAULT DISK NUMBER
	add	al,'A'
	;add	al,[CAPITAL_A]
	;call	PRINT_CHAR
	;retn
	; 21/02/2023
	jmp	short PRINT_CHAR

; ---------------------------------------------------------------------------

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h

build_dir_for_prompt:
	xor	dl,dl
	mov	si,BWDBUF
	mov	di,si
	mov	al,[CURDRV]
	add	al,'A'
	mov	ah,':'
	stosw
	mov	al,[DIRCHAR]
	stosb
	xchg	si,di
	mov	[string_ptr_2],di
	;mov	ah,CURRENT_DIR ; 47h
	mov	ah,47h
	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
			; DL = drive (0=default,1=A,etc.)
			; DS:SI	points to 64-byte buffer area
	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
	mov	dx,string_buf_ptr
	jnc	short doprint
	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
	mov	dx,BADCURDRV
doprint:
	;call	std_printf
	;retn
	jmp	std_printf

; =============== S U B	R O U T	I N E =======================================

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh

build_dir_for_chdir:
	call	build_dir_string
	mov	dx,DIRBUF
	mov	[string_ptr_2],dx
	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
	mov	dx,string_buf_ptr
	;call	std_printf
	;retn
	; 21/02/2023
	;jmp	short doprint
	jmp	std_printf


; =============== S U B	R O U T	I N E =======================================

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
build_dir_string:
	mov	dl,[FCB] ; mov dl,[5Ch]
	mov	al,dl
	add	al,'@'	; 40h
	cmp	al,'@'
	jne	short gotdrive
	add	al,[CURDRV]
	inc	al
gotdrive:
	push	ax
	mov	si,BWDBUF+3
	;mov	ah,CURRENT_DIR ; 47h
	mov	ah,47h
	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
			; DL = drive (0=default,1=A,etc.)
			; DS:SI	points to 64-byte buffer area
	jnc	short dpbisok
	push	cs
	pop	ds
	jmp	DRVBAD
dpbisok:
	mov	di,BWDBUF
	mov	dx,di
	pop	ax
	mov	ah,':'
	stosw
	mov	al,[DIRCHAR]
	stosb
	retn

; ---------------------------------------------------------------------------

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
PATH:
	; MSDOS 6.0
	xor	al,al			;AN049; Set up holding buffer
	mov	di,SRCXNAME		;AN049;  for PATH while parsing
	stosb				;AN049; Initialize PATH to null
	dec	di			;AN049; point to the start of buffer
	call	PGETARG 		; Pre scan for arguments
	jz	short disppath		; Print the current path
	;cmp	al,semicolon		;AC049; NUL path argument?
	cmp	al,';' ; 3Bh
	jne	short pathslp 		;AC049;
	inc	si			;AN049; point past semicolon
	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
pathslp:					; Get the user specified path
	lodsb				; Get a character
	cmp	al,0Dh
	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
	je	short path_eol		;AC049; yes - end of command
	call	testkanj		;See if DBCS
	jz	short notkanj2		;No - continue
	stosb				;AC049; Yes - store the first byte
	lodsb				;skip second byte of DBCS
path_hold:				;AN049;
	stosb				;AC049; Store a byte in the PATH buffer
	jmp	short pathslp		;continue parsing
notkanj2:
	call	UPCONV			;upper case the character

	cmp	al,';' ; 3Bh
	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
	je	short path_hold		;AC049; go store it
	call	DELIM			;delimiter?
	jnz	short path_hold		;AC049; no - go store character
scan_white:				;AN049; make sure were at EOL
	lodsb				;AN049; get a character
	cmp	al,0Dh
	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
	je	short path_eol		;AN049; yes - go set path
	cmp	al,' ' ; 20h
	;cmp	al,blank		;AN049; whitespace?
	je	short scan_white	;AN049; yes - continue scanning
	;cmp	al,9
	cmp	al,tab_chr ; 9		;AN049; whitespace?
	je	short scan_white	;AN049; yes - continue scanning

	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
	mov	word [extend_buf_ptr],MoreArgs_Ptr
	;mov	byte [msg_disp_class],2		
					;AN049; set up parse error msg class
	mov	byte [msg_disp_class],parse_msg_class
	jmp	cerror			;AN049;
path_eol:				;AN049; Parsing was clean
	xor	al,al			;AN049; null terminate the PATH
	stosb				;AN049;    buffer
	call	find_path		;AN049; Find PATH in environment
	call	delete_path		;AC049; Delete any offending name
	call	scan_double_null	;AC049; Scan to end of environment
	call	move_name		;AC049; move in PATH=
	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
store_path:				;AN049; Store the PATH in the environment
	lodsb				;AN049; Get a character
	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
	and	al,al ; al=0 ?
	jz	short got_paths		;AN049; yes - exit
	call	store_char		;AN049; no - store character
	jmp	short store_path	;AN049; continue
got_paths:				;AN049; we're finished
	xor	ax,ax			;	null terminate the PATH in
	stosw				;    	the environment
	retn
disppath:
	call	find_path		;AN049;
	call	print_path
	;call	CRLF2
	;retn
	; 21/02/2023
	jmp	CRLF2

; 21/02/2023
%if 0
	; MSDOS 3.3
	call	FIND_PATH		; Find PATH in environment
	call	PGETARG			; Pre scan for arguments
	jz	short DISPPATH		; Print the current path
	call	DELETE_PATH		; Delete any offending name
	call	SCAN_DOUBLE_NULL	; Scan to end of environment	
	call	MOVE_NAME		; Move in PATH=
	call	PGETARG
	cmp	al,';'
	jz	short GOTPATHS
PATHSLP:
	lodsb
	cmp	al,0Dh			; End of line (CR) ?		
	jz	short GOTPATHS		; yes - exit
	;call	UPCONV	; MSDOS 6.0
	call	UPCONV_MAPCALL		; convert to uppercase
	cmp	al,';'			; ';' not a delimiter on PATH
	jz	short NOTDELIM		; go set path
	call	DELIM			; is it delim/null char ?
	jz	short GOTPATHS		; yes - exit
NOTDELIM:
	call	STORE_CHAR		; no - store character
	jmp	short PATHSLP
GOTPATHS:
	xor	ax,ax			; null terminate the PATH
	stosw				; in the environment
	retn
DISPPATH:
	call	PRINT_PATH
	call	CRLF2
	retn
%endif

; =============== S U B	R O U T	I N E =======================================

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
print_path:
	cmp	byte [es:di],0
	jnz	short path1
path0:
	mov	dx,NULLPATH_PTR
	push	cs
	pop	es
	push	cs
	pop	ds
	jmp	std_printf
path1:
	push	es
	pop	ds
	sub	di,5
	mov	si,di
	call	SCASB2		; Look for null
	;cmp	cx,0FFh ; 255
	; 21/02/2023
	;ch = 0
	cmp	cl,255
	je	short path0
	push	cs
	pop	es
	mov	di,Arg_Buf
	;mov	dx,100h ; 256
	;sub	dx,cx
	;xchg	dx,cx
	; 21/02/2023
	neg	cl ; 256-cl
	rep	movsb
	mov	dx,arg_buf_ptr
	push	cs
	pop	ds
	jmp	std_printf

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 CLS
; *
; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
; *		 installed, send a control string to clear the
; *		 screen.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; MSDOS 6.0

ANSI_installed	equ 0FFh

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
CLS:
	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
	;mov	ah,1Ah
	;mov	al,0			;AN000;
	mov	ax,1A00h
	int	2Fh			;AN000;
		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
		; Return: AL = FFh if installed
	cmp	al,ANSI_installed	;AN000;
	je	short ansicls 		;AN000; installed - go do ANSI CLS

check_lines:
	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
	mov	ax,440Ch		;AN000; get lines per page on display
	;mov	bx,stdout		;AN000; lines for stdout
	mov	bx,1   ; handle
	;;mov	ch,ioc_sc		;AN000; type is display
	;mov	ch,3   ; CON device	
	;;mov	cl,get_generic		;AN000; get information
	;mov	cl,7Fh ; minor function, get display info
	; 25/04/2023
	mov	cx,037Fh
	mov	dx,Display_Ioctl	;AN000;
	int	21h			;AN000;
	jc	short no_variable	;AN000; function had error, use default
		; 21/02/2023
		; ds:dx = parameter block
		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
		; offset 00h  byte  level (0 for DOS 4.0)
		;   	 01h  byte  reserved
		;   	 02h  word  length of following data
		;   	 04h  word  control flags
		;	       bit 0 set for blink, clear for intensity
		;	       bits 1 to 15 reserved
		;   	 06h  byte  mode type (1=text, 2=graphics)
		;   	 07h  byte  reserved
		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
		;   	 0Ah  word  pixel columns
		;   	 0Ch  word  pixel rows
		;   	 0Eh  word  character columns
		;   	 10h  word  character rows
	
	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
	;				;AN000; get number of rows returned
	;mov	dh,al			;AN000; set number of rows
	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
	;				;AN000; get number of columns returned
	;mov	dl,al			;AN000; set number of columns
	; 21/02/2023
	mov	dl,[display_width]
	mov	dh,[LinPerPag]
	jmp	short regcls		;AN000; go do cls

no_variable:
	;;mov	bx,stdout		;AC000; set handle as stdout
	;mov	bx,1
	; bx = 1
	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
	mov	ax,4400h
	int	21h			;AC000;
	test	dl,80h
	;test	dl,devid_ISDEV		;AC000; is handle a device
	jz	short ansicls 		;AC000; If a file put out ANSI
	test	dl,10h
	;test	dl,devid_SPECIAL	;AC000;
	jnz	short cls_normal	;AC000; If not special CON, do ANSI

ansicls:
	call	ansi_cls		;AN000; clear the screen
	jmp	short cls_ret		;AN000; exit

; Get video mode

cls_normal:				;AC000;
	;mov	ah,get_video_state	;AC000; set up to get video state
	mov	ah,0Fh
	;int	video_io_int		;AC000; do int 10h - BIOS video IO
	int	10h
	cmp	al,3
	;cmp	al,video_alpha		;AC000; see if in text mode
	jbe	short DoAlpha
	cmp	al,7
	;cmp	al,video_bw		;AC000; see if black & white card
	je	short DoAlpha

; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
; be just as bogus and set the mode that we just got. This will blank the
; screen too.

	;mov	ah,set_video_mode	;AC000; set video mode call
	mov	ah,0
	;int	video_io_int		;AC000; do int 10h - BIOS video IO
	int	10h
	jmp	short cls_ret		;AC000; exit

DoAlpha:

; Get video mode and number of columns to scroll

;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
;M01   adaptors. We circumvent this by reaching directly into the BIOS data
;M01   area
;M01   Commented out code here is the original
;M01	mov	ah,get_video_state	;AC000; set up to get current video state
;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
;M01	mov	dl,ah
;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen

;M01   Following code lifted from a fix Compaq applied to ANSI

	push	ds
	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
	mov	ax,40h
	mov	ds,ax			;  *			M01

	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
	mov	dl,[4Ah]
	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
	mov	dh,[84h]
	pop	ds			;			M01

	or	dh,dh			; Q:ZERO		M01
	jnz	short regcls		;  *JMP IF NO		M01

	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
	; 25/04/2023
	mov	dh,25
regcls:
	inc	dh			; height+1		M018
	call	reg_cls 		; go clear the screen
cls_ret:
	retn				; exit

; ---------------------------------------------------------------------------

; 21/02/2023
%if 0
	; MSDOS 3.3
CLS:
	mov	bx,STDOUT ; 1
	mov	ax,IOCTL*256 ; 4400h
	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
	test	dl,80h	; devid_ISDEV
	jz	short ANSICLS	; If a file put out ANSI
	test	dl,10h  ; devid_SPECIAL
	jz	short ANSICLS	; If not special CON, do ANSI

	mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
	mov	dx,es
	mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
			; AL = interrupt number
			; Return: ES:BX	= value	of interrupt vector
	mov	ax,es
	cmp	dx,ax	; If not default driver, do ANSI
	ja	short ANSICLS

	mov	ah,0Fh
	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
			; Return: AH = number of columns on screen
			; AL = current video mode
			; BH = current active display page
	cmp	al,3
	jbe	short DOALPHA
	cmp	al,7
	jz	short DOALPHA
	mov	ah,0
	int	10h	; - VIDEO - SET	VIDEO MODE
			; AL = mode
	retn

DOALPHA:
	mov	ah,0Bh	; Set overscan to black
	xor	bx,bx
	int	10h	; - VIDEO - SET	COLOR PALETTE
			; BH = 00h, BL = border color
			; BH = 01h, BL = palette (0-3)
	mov	ah,0Fh
	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
			; Return: AH = number of columns on screen
			; AL = current video mode
			; BH = current active display page
	mov	dl,ah
	dec	dl
	mov	dh,24
	xor	ax,ax
	mov	cx,ax
	mov	bx,700h
	mov	ah,6
	int	10h	; - VIDEO - SCROLL PAGE	UP
			; AL = number of lines to scroll window	
			;	(0 = blank whole window)
			; BH = attributes to be	used on	blanked	lines
			; CH,CL	= row,column of	upper left corner of window 
			;	  to scroll
			; DH,DL	= row,column of	lower right corner of window
	xor	dx,dx
	mov	bh,0
	mov	ah,2
	int	10h	; - VIDEO - SET	CURSOR POSITION
			; DH,DL	= row,column (0,0 = upper left)
			; BH = page number
	retn

ANSICLS:
	mov	si,CLSSTRING
	lodsb
	mov	cl,al
	xor	ch,ch
	mov	ah,RAW_CON_IO ; 6
CLRLOOP:
	lodsb
	mov	dl,al
	int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
			; DL = character <> FFh
			;  Return: ZF set = no character
			;   ZF clear = character recieved, AL = character
	loop	CLRLOOP
	retn
%endif

; ---------------------------------------------------------------------------

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 REG_CLS
; *
; * FUNCTION:	 Clear the screen using INT 10H.
; *
; * INPUT:	 DL = NUMBER OF COLUMNS
; *		 DH = NUMBER OF ROWS
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
reg_cls:
; Set overscan to black.

	dec	dh			; decrement rows and columns
	dec	dl			;  to zero base
	push	dx			; save rows,columns
	;mov	ah,set_color_palette	; set up to set the color to blank
	mov	ah,0Bh
	xor	bx,bx
	;int	video_io_int		; do int 10h - BIOS video IO
	int	10h
	pop	dx			;  restore rows,colums

	xor	ax,ax			; zero out ax
	mov	cx,ax			;  and cx

; Scroll active page

	;mov	ah,scroll_video_page	; set up to scroll page up
	mov	ah,6
	;mov	bh,video_attribute	; attribute for blank line
	mov	bh,7
	xor	bl,bl			; set BL to 0
	;int	video_io_int		; do int 10h - BIOS video IO
	int	10h

; Seek to cursor to 0,0

;M022 following two lines added
	;mov	ah,get_video_state	; get current video page in BH
	mov	ah,0Fh
	;int	video_io_int
	int	10h
	;mov	ah,set_cursor_position	; set up to set cursor position
	mov	ah,2
	xor	dx,dx			; row and column 0
;M022	mov	bh,0
	;int	video_io_int		; do into 10h - BIOS video IO
	int	10h

	retn

; ---------------------------------------------------------------------------

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 ANSI_CLS
; *
; * FUNCTION:	 Clear the screen using by writing a control code
; *		 to STDOUT.
; *
; * INPUT:	 none
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
ansi_cls:			;AC000;
	mov	si,CLSSTRING
			; db 4,1Bh,'[2J'
	lodsb
	mov	cl,al	; al = 4
	xor	ch,ch
	;mov	ah,Raw_CON_IO
	mov	ah,6
clrloop:
	lodsb
	mov	dl,al
	int	21h
		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
	loop	clrloop
	retn

;============================================================================
; TCMD2B.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh

; 21/02/2023 - Retro DOS v4.0 (& v4.1)
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 CTTY - Change console
; *
; * SYNTAX:	 CTTY device
; *
; * FUNCTION:	 If a valid console device is specified, CTTY will
; *		 duplicate the device handle to STDIN, STDOUT and
; *		 STDERR. This routine returns to LODCOM1.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; 21/02/2023 - Retro DOS v4.0
	; 10/06/2023
CTTY:
	; MSDOS 6.0
	push	ds			;AN000; Get local ES
	pop	es			;AN000;
	mov	si,81h			;AC000; Get command argument for CTTY
	mov	di,PARSE_CTTY
					;AC000; Get address of PARSE_CTTY
	xor	cx,cx			;AC000; clear cx,dx
	xor	dx,dx			;AC000;
	call	cmd_parse		;AC000; call parser

	;cmp	ax,-1 ; 0FFFFh
	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
	;je	short ctty_error	;AN000; yes - error
	;;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
	;and	ax,ax ; ax > 0 ?
	;jnz	short ctty_error	;AN000; YES -ERROR
	; 10/06/2023
	inc	ax  ; cmp ax,-1
	jz	short ctty_error  ; 0FFFFh -> 0
	dec	ax  ; cmp ax,0
	jnz	short ctty_error  ; 1 -> 0
	; ax = 0

	push	si			;AN000; save position in line
	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
	mov	di,SrcBuf		;AN000; get address of srcbuf
ctty_move_filename:			;AN000; put filespec in srcbuf
	lodsb				;AN000; get a char from buffer
	stosb				;AN000; store in srcbuf
	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
	or	al,al ; al = 0 ?
	jnz	short ctty_move_filename ; 26/04/2023
					;AN000; no - keep moving
	pop	si			;AN000; get line position back
	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
	call	parse_check_eol 	;AN000; are we at end of line?
	;jz	short nocolon 		;AN000; yes - continue
	; 21/02/2023
	jnz	short ctty_error
;ctty_error:
	;jmp	short isbaddev		;AC000; yes - exit

	; 21/02/2023
	; MSDOS 3.3
	;call	SETPATH
	;dec	si
	;dec	si
	;cmp	byte [si],':'
	;jnz	short NOCOLON
	;mov	byte [si],0
nocolon:
	; 21/02/2023
	; MSDOS 6.0
	mov	dx,SrcBuf
;NOCOLON:
	; MSDOS 3.3 & MSDOS 6.0
	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
	;mov	ax,(OPEN<<8)|2 ; 3D02h
	mov	ax,3D02h ; 21/02/2023
	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 2 - read & write
	jc	short isbaddev
	mov	bx,ax
	;mov	ax,IOCTL*256 ; 4400h
	mov	ax,4400h
	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
	test	dl,80h
	jnz	short devisok
closedev:
	;mov	ah,CLOSE ; 3Eh ; Close initial handle
	mov	ah,3Eh
	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
ctty_error:
isbaddev:
	mov	dx,BADDEV_PTR
	call	std_printf
	jmp	short resret

	;nop
devisok:
	; 21/02/2023
	; MSDOS 6.0
	push	dx		;AN007; save device info
	; 08/06/2023 (BugFix)
	mov	ax,[acrlf_ptr]	;AN021; get message number for 0d, 0a
	;mov	dh,util_msg_class
	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
	push	bx		;AN021; save handle
	call	TSYSGETMSG	;AN021; get the address of the message
	mov	dx,si		;AN021; get address into dx
	;mov	ax,(Write shl 8)
	mov	ax,4000h	;AN007; write to device
	mov	cx,2		;AN007; write two bytes
	int	21h		;AN007;
	pop	bx		;AN021; get back handle
	pop	dx		;AN007; get back device info
	jc	short closedev	;AN007; if error, quit

	; MSDOS 3.3 & MSDOS 6.0
	xor	dh,dh
	or	dl,3
	;;mov	ax,(IOCTL SHL 8) OR 1
	;mov	ax,(IOCTL<<8)|1 ; 4401h
	mov	ax,4401h
	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
			; BX = device handle,DH = 0
			; DL = device information to set 
			;	(bits 0-7 from	function 0)
	push	bx
	mov	cx,3
	xor	bx,bx
iclloop:			; Close basic handles
	;mov	ah,CLOSE ; 3Eh
	mov	ah,3Eh
	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
	inc	bx
	loop	iclloop
	pop	bx		; Get handle
	;mov	ah,XDUP ; 45h
	mov	ah,45h
	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
			; BX = file handle to duplicate
	;mov	ah,XDUP ; 45h
	mov	ah,45h
	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
			; BX = file handle to duplicate
	;mov	ah,XDUP ; 45h
	mov	ah,45h
	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
			; BX = file handle to duplicate
	;mov	ah,CLOSE ; 3Eh
	mov	ah,3Eh
	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
resret:
	mov	ds,[RESSEG]
	push	ds
	;mov	ax,[18h]
	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
	mov	[Io_Save],ax
	;;;mov	ax,31Eh ; MSDOS 3.3
	;;mov	ax,LODCOM1
	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
	;mov	ax,175h ; MSDOS 6.0
	mov	ax,TrnLodCom1_Trap
	push	ax

	retf		; Far return

; ---------------------------------------------------------------------------

;****************************************************************
;*
;* ROUTINE:	CHCP - Change code page internal command
;*		(added DOS 3.30 07/21/86)
;*
;* SYNTAX:	CHCP [xxx]
;*		where xxx is a valid code page
;*
;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
;*		6402H to set the code page to xxxx. If no parameters
;*		are specified, CHCP will use INT 21H function 6401H
;*		to get global code page and display it to the user.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	none
;*
;****************************************************************

NLSFUNC_installed equ  0FFh
set_global_cp	  equ  2
get_global_cp	  equ  1

	; 21/02/2023 - Retro DOS v4.0
	; 09/06/2023
	; 10/06/2023
CHCP:
	; MSDOS 6.0
	push	ds		;AN000; Get local ES
	pop	es		;AN000;
	mov	si,81h		;AC000; Get command argument for CHCP
	mov	di,PARSE_CHCP
				;AN000; Get address of PARSE_CHCP
	xor	cx,cx		;AC000; clear cx,dx
	xor	dx,dx		;AC000;
	call    Parse_With_Msg	;AC018; call parser

	;cmp	ax,-1
	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
	;;jne	short setcp	;AC000; no go get number & set code page
	;je	short getcp	;AC000; yes - no parm - get code page
;setcp:
	;;cmp	ax,0
	;;cmp	ax,RESULT_NO_ERROR
	;			;AN000; did we have an error?
	;;jne	short cp_error	;AC018; yes - go issue message
	;and	ax,ax ; ax > 0 ?
	;jnz	short cp_error	
	; 10/06/2023
	inc	ax  ; cmp ax,-1	
	jz	short getcp ; 0FFFFh -> 0
	dec	ax  ; cmp ax,0
	jnz	short cp_error ; 1 -> 0
	; ax = 0

	;;push	cx		;AN000; save positional count
	;mov	bx,PARSE1_ADDR	;AN000; get number returned
	;;mov	cx,[bx]		;AN000;  into cx
	;;mov	[system_cpage],cx
	;			;AN000; save user input number
	;;pop	cx		;AC000; restore positional count
	;; 21/02/2023
	;mov	di,[bx]
	;mov	[system_cpage],di
	; 09/06/2023	
	mov	bx,[PARSE1_ADDR]
	mov	[system_cpage],bx
	;
	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
	call	parse_check_eol ;AN000; are we at end of line?
	jnz	short cp_error	;AC000; no - exit
okset:
	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
	;mov	ah,14h
	;mov	al,0		;AN000;
	mov	ax,1400h
	int	2Fh		;AN000;
	;cmp	al,0FFh
	cmp	al,NLSFUNC_installed
				;AN000;
	je	short got_NLS 	;AN000; Yes - continue
	mov	dx,NLSFUNC_PTR
				;AN000; no - set up error message
	jmp	short cp_error	;AN000; error exit

; 21/02/2023
%if 0
	; MSDOS 3.3
	mov	si,81h
	call	SCANOFF
	cmp	al,0Dh ; CR
	jnz	short SETCP
	jmp	short GETCP

	;nop
SETCP:
	xor	bx,bx
	mov	cx,bx
	mov	ax,bx
GET_CP_DIGIT:
	lodsb
	cmp	al,'0'
	jb	short CHRNOTNUMBER
	cmp	al,'9'
	ja	short CHRNOTNUMBER
	sub	al,'0'
	inc	cl
	cmp	cl,4
	ja	short CHCP_BADPARM
	mov	dx,bx
	shl	dx,1
	shl	dx,1
	add	bx,dx
	shl	bx,1
	add	bx,ax
	jmp	short GET_CP_DIGIT
CP_NEXTCHR:
	lodsb
CHRNOTNUMBER:
	cmp	al,' '		; SPACE
	jz	short CP_NEXTCHR
	cmp	al,9		; TAB
	jz	short CP_NEXTCHR
	cmp	al,0Dh		; CR
	jz	short SET_CP_TBL_NUM
CHCP_BADPARM:
	mov	dx,BADPARMPTR
	jmp	CERROR
;GOT_NLS:
%endif
	; 21/02/2023
got_NLS:
	; MSDOS 6.0
	mov	bx,[system_cpage]
				;AN000; get user input code page
;SET_CP_TBL_NUM:
	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
	;
	; MSDOS 3.3 & MSDOS 6.0
	;;mov	ah,GETSETCDPG 	;get/set global code page function
	;mov	ah,66h
	;;mov	al,set_global_cp 
	;mov	al,2		;minor - set
	; 26/04/2023
	mov	ax,6602h
	int	21h
		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
		; BX = active code page
		; DX = system code page (active page at boot time)

	jnc	short chcp_return
				;no error - exit

	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
	jnz	short chcp_other_error

	;mov	ah,GETEXTENDEDERROR ; 59h
	mov	ah,59h
	xor	bx,bx
	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
			; BX = version code (0000h for DOS 3.x)

	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
	jne	short no_countrysys ; 26/04/2023
	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
	mov	dx,INV_CODE_PAGE
	;jmp	cerror
	jmp	short cp_error

	; 21/02/2023
	; MSDOS 6.0 (& 5.0) COMMAND.COM
no_countrysys:
;M045;	mov	byte [msg_disp_class],ext_msg_class	   
;					;AN000; set up extended error msg class
;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
					;AN000; get message number in control block
	mov	dx,NoCntry_Ptr
	jmp	short cp_error

chcp_other_error:		; end of p716
	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
	mov	ah,59h
	xor	bx,bx
	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
			; BX = version code (0000h for DOS 3.x)
	cmp	ax,65		;was it access denied?
	jne	short none_set	;no - assume all failed
	mov	dx,cp_not_all_ptr
				;set up message
	;jmp	cerror		;AC000; error exit
	jmp     short cp_error
none_set:
	mov	dx,cp_not_set_ptr
				;set up message
cp_error:
	jmp	cerror		;exit
getcp:
	;;mov	ah,GETSETCDPG ; 66h
	;mov	ah,66h		;get/set global code page function	
	;;mov	al,get_global_cp ; 1
	;mov	al,1		;minor - get
	; 26/04/2023
	mov	ax,6601h
	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
	mov	[system_cpage],bx
				;get active cp for output
	mov	dx,cp_active_ptr
	call	std_printf	;print it out
chcp_return:
	retn

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 TRUENAME
; *
; * FUNCTION:	 Entry point for the internal TRUENAME command.
; *		 Parses the command line. If a path is found, set
; *		 SRCXNAME to path. If only a drive letter is found,
; *		 set SRCXNAME to the drive letter. If no path
; *		 is found, set the path of SRCXNAME to dot (.) for
; *		 current directory. Use the NAME TRANSLATE system
; *		 call to get the real name and  then display the 
; *		 real name. If an error occurs issue an error
; *		 message and transfer control to  CERROR.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
	; 10/06/2023
TRUENAME:				;AN000; TRUENAME entry point
	push	ds			;AN000; Get local ES
	pop	es			;AN000;
	mov	si,81h			;AN000; Get command line
	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
	xor	cx,cx			;AN000; clear cx,dx
	xor	dx,dx			;AN000;
	call	Parse_With_Msg		;AC018; call parser

	mov	di,SRCXNAME		;AN000; get address of srcxname
	;cmp	ax,0FFFFh
	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
	;je	short tn_eol		;AN000; yes - go process
	;; 22/02/2023
	;;cmp	ax,0
	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
	;;jne	short tn_parse_error	;AN000; yes - go issue message
	;and	ax,ax ; ax = 0 ?
	;jnz	short tn_parse_error ; no, parse error
	; 10/06/2023
	inc	ax  ; 0FFFFh -> 0 ; cmp ax,0FFFFh
	jz	short tn_eol ; ah = 0 ; *
	dec	ax  ; 1 -> 0 ; cmp ax, 0
	jnz	short tn_parse_error

	;cmp	byte [PARSE1_TYPE],6
	cmp	byte [PARSE1_TYPE],result_drive
					;AN000; was a drive entered?
	;je	short tn_drive		;AN000; yes - go process
	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
	; 23/02/2023
	jne	short tn_filespec

;tn_eol: 
;	;mov	ah,0			;AN000; no parameters on line
;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
;	;mov	al,dot_chr		;AN000;   for current dir
;	mov	al,'.'
;	stosw				;AN000; store in srcxname
;	jmp	short tn_doit		;AN000; go do command

tn_drive:				;AN000; a drive was entered
	push	si			;AN000; save position in line
	mov	si,PARSE1_ADDR		;AN000; get address of drive
	lodsb				;AN000; get the drive number
	add	al,"A"-1 ; 40h		;AN000; convert it to char
	stosb				;AN000; store it in srcxname
	;mov	ax,dot_colon		;AN000; get colon and . and
	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
	stosw				;AN000;  store in srcxname
	;mov	al,0
	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
	stosb				;AN000;
	pop	si			;AN000; get line position back
	jmp	short tn_check_eol	;AN000; check to make sure eol

tn_filespec:				;AN000; a filespec was entered
	push	si			;AN000; save position in line
	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec

tn_move_filename:			;AN000; put filespec in srcxname
	lodsb				;AN000; get a char from buffer
	stosb				;AN000; store in srcxname
	;;cmp	al,0
	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
	or	al,al ; al = 0 ?
	jnz	short tn_move_filename	;AN000; no - keep moving
	pop	si			;AN000; get line position back

tn_check_eol:				;AN000; make sure no extra parms
	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
	call	parse_check_eol 	;AN000; are we at end of line?
	jz	short tn_doit 		;AN000; Yes - do the command
tn_parse_error: 			;AN000; A parse error occurred
	jmp	cerror			;AN000; Go to error routine

tn_eol: 
	;23/02/2023
	;;mov	ah,0			;AN000; no parameters on line
	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
	;;mov	al,dot_chr		;AN000;   for current dir
	;mov	al,'.'
	; 10/06/2023
	;mov	ax,002Eh
	; ah = 0 ; *
	mov	al,'.'  ;dot_chr ; 2Eh
	;
	stosw				;AN000; store in srcxname
	; 23/02/2023
	;jmp	short tn_doit		;AN000; go do command

tn_doit:				;AN000;
	mov	si,SRCXNAME		;AN000; set up srcxname as source
	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
	;mov	ah,xNameTrans		;AN000; do name translate call
	mov	ah,60h
	int	21h			;AN000;
	jnc	short tn_print_xname	;AN000; If no error - print result

	call	Set_Ext_Error_Msg	;AN000; get extended message
	mov	word [string_ptr_2],SRCXNAME
					;AN000; get address of failed string
	;mov	byte [extend_buf_sub],1
	mov	byte [extend_buf_sub],one_subst
					;AN000; put number of subst in control block
	jmp	cerror			;AN000; Go to error routine

tn_print_xname: 			;AN000;
	mov	word [string_ptr_2],COMBUF
					;AN000; Set up address of combuf
	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
	call	CRLF2			;AN000; print a crlf
	;call	Printf_Crlf		;AN000; print it out
	;retn				;AN000;
	; 23/02/2023
	jmp	Printf_Crlf

; ---------------------------------------------------------------------------

	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
_$EXIT:
	; MSDOS 6.0
	push	ds			;AN000; save data segment
	mov	ds,[RESSEG]		;AN000; get resident data segment
	;assume	ds:resgroup		;AN000;

	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
	jz	short free_com		;AN045; no - free everything

;	We're a permanent command.
;	Unless this is a singlecom (int 2Eh), don't deallocate transient.

	cmp	word [SingleCom],-1	;M034
	je	short no_reset		;M034 ; exit singlecom
	jmp	TCOMMAND		;permanent command, recycle

free_com:
	;mov	ax,(multdos shl 8 or message_2f)
	mov	ax,122Eh		;AN060; reset parse message pointers
	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
	mov	dl,5
	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
	int	2Fh			;AN000; go set it
no_reset:				;AN045;
	pop	ds			;AN000; restore local data segment
	;assume	ds:trangroup		;AN000;
;M040
; Restore user directory if the restore flag is set. RestUDir1 checks for
;this, restores user dir if flag is set and resets the flag.

	;invoke	RestUDir1		;restore user dir if needed ;M040
	call	RestUDir1
	mov	es,[RESSEG]
	;assume	es:resgroup

	mov	ax,[es:Parent]
	;mov	[es:16h],ax
	;mov	[es:PDB_Parent_PID],ax
	mov	[es:PDB.PARENT_PID],ax
	mov	ax,[es:OldTerm]
	;mov	[es:0Ah],ax
	;mov	[es:PDB_Exit],ax
	mov	[es:PDB.EXIT],ax
	mov	ax,[es:OldTerm+2]
	;mov	[es:0Ch],ax
	;mov	[es:PDB_Exit+2],ax
	mov	[es:PDB.EXIT+2],ax

	push	es
	mov	es,[TRAN_TPA]
	;mov	ah,DEALLOC
	mov	ah,49h
	int	21h			; Now running in "free" space
	pop	es

	;mov	ah,Exit
	mov	ah,4Ch
	;mov	al,byte ptr RetCode
	mov	al,[es:RetCode]
	int	21h

	;..........

; 23/02/2023
%if 0
_$EXIT:
	; MSDOS 3.3
	mov	es,[RESSEG]
	mov	ax,[es:PARENT]
	;mov	[es:16h],ax
	mov	[es:PDB.PARENT_PID],ax
	mov	ax,[es:OLDTERM]
	;mov	[es:0Ah],ax
	mov	[es:PDB.EXIT],ax
	mov	ax,[es:OLDTERM+2]
	;mov	[es:0Ch],ax
	mov	[es:PDB.EXIT+2],ax
	push	es
	mov	es,[TRAN_TPA]
	mov	ah,DEALLOC ; 49h
	int	21h	; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
	pop	es
	mov	ah,EXIT ; 4Ch
	;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
	mov	al,byte [es:RETCODE]
	int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
;;here:
;;	jmp	short here
%endif

; ---------------------------------------------------------------------------

; MSDOS 6.0
; ****************************************************************
; *
; * ROUTINE:	 PARSE_CHECK_EOL
; *
; * FUNCTION:	 Calls parser to see if end of line occurred.
; *		 If not end of line, set up to print parse
; *		 error message. ASSUMES NO MORE PARAMETERS ARE
; *		 EXPECTED!
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if end of line found
; *		     zero flag set
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *
; ****************************************************************

	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h

parse_check_eol:
	xor	dx,dx			;AN000;
	mov	[parse_last],si 	;AN018; save start of parameter
	call	cmd_parse		;AN000; call parser
	cmp	al,-1 ; 0FFh
	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
	je	short parse_good_eol	;AN000; yes - no problem
	;cmp	ax,0
	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
	and	ax,ax ; ax = 0 ?
	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
	inc	ax			;AN018; set AX to 1 and turn off zero flag
ok_to_setup_pmsg:
	call	setup_parse_error_msg	;AN018; go set up error message
parse_good_eol:
parse_msg_good:	; 23/02/2023
	retn				;AN000;

; ---------------------------------------------------------------------------

; MSDOS 6.0
; ****************************************************************
; *
; * ROUTINE:	 PARSE_WITH_MSG
; *
; * FUNCTION:	 Calls parser. If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 DS:SI	  last output from parser
; *		 ES:DI	  points to parse block
; *		 CX	  last output from parser
; *
; * OUTPUT:	 AX	  parser return code
; *
; *		 if no error
; *		     outputs from parser
; *		 else
; *		     MSG_DISPLAY_CLASS set to parse error
; *		     error message set up for STD_PRINTF
; *
; ****************************************************************

	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
Parse_With_Msg:
	mov	[parse_last],si 	;AN018; save start of parameter
	call	cmd_parse		;AN018; call parser
	cmp	al,-1 ; 0FFh
	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
	je	short parse_msg_good	;AN018; yes - no problem
	;cmp	ax,0
	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
	or	ax,ax ; ax = 0 ?
	jz	short parse_msg_good	;AN018; yes - no problem
	; 23/02/2023
	;call	setup_parse_error_msg	;AN018; go set up error message
;parse_msg_good:
	;retn				;AN018;
	; 23/02/2023
	;jmp	short setup_parse_error_msg	

; ---------------------------------------------------------------------------

; MSDOS 6.0
; ****************************************************************
; *
; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
; *
; * FUNCTION:	 Calls parser.	If an error occurred, the error
; *		 message is set up.
; *
; * INPUT:	 AX	     Parse error number
; *		 SI	     Set to past last parameter
; *		 Parse_last  Set to start of last parameter
; *
; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
; *		 error message set up for STD_PRINTF
; *
; ****************************************************************

	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
setup_parse_error_msg:
	mov	byte [msg_disp_class],parse_msg_class
	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
	mov	byte [si],END_OF_LINE_OUT ; 0
					;AC018; terminate the parameter string
	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
	cmp	ax,2
	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
	je	short setup_parse_msg_ret
					;AN018;    no subst
	mov	si,[parse_last] 	;AC018; get start of parameter
	mov	[string_ptr_2],si 	;AC018; get address of failed string
	mov	byte [extend_buf_sub],one_subst
					;AC018; put number of subst in control block
	;mov	byte [extend_buf_sub],1
setup_parse_msg_ret:
	inc	si			;AN018; make sure zero flag not set
	retn				;AC018;

;============================================================================
; TENV.ASM, MSDOS 6.0, 1991
;============================================================================
; 08/10/2018 - Retro DOS v3.0

; TITLE	Part6 COMMAND Transient routines.

;	Environment utilities and misc. routines

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h

; 23/02/2023 - Retro DOS v4.0 (& v4.1)
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh

; ---------------------------------------------------------------------------

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
ADD_PROMPT:
	call	delete_prompt	; Delete any existing prompt
	call	scan_double_null

ADD_PROMPT2:
	push	si
	call	GETARG
	pop	si
	jnz	short ADD_PROMPT3
ADD_PROMPT_RETN:
	retn
ADD_PROMPT3:			; Pre scan for arguments
	call	move_name	; Move in name
	call	GETARG
	push	si
	jmp	short ADD_NAME

;break	The SET command

; Input: DS:SI points to a CR terminated string
; Output: carry flag is set if no room
;	  otherwise name is added to environment

DISP_ENVJ:
	jmp	DISP_ENV

ADD_NAME_TO_ENVIRONMENT:
	call	GETARG
	jz	short DISP_ENVJ

; check if line contains exactly one equals sign

	xor	bx,bx		; = count is 0
	push	si		; Save pointer to beginning of line
EQLP:
	lodsb			; Get a char
	cmp	al,13 ; 0Dh	; IF CR we're all done
	je	short QUEQ	
	cmp	al,'='		; Look for = sign	
	jne	short EQLP	; not there, get next char
	inc	bl		; Otherwise increment EQ count
	cmp	byte [si],13	; Look for CR following = sign
	jne	short EQLP
	inc	bh		; Set BH=1 means no parameters
	jmp	short EQLP	; And look for more
QUEQ:
	pop	si		; Restore beginning of line
	dec	bl		; Zero flag means only one EQ
	jz	short ONEQ	; Good line
	mov	dx,SYNTMES_PTR
	jmp	cerror
ONEQ:
	push	bx
	call	delete_name_in_environment
	pop	bx
	dec	bh
	jz	short ADD_PROMPT_RETN
	call	scan_double_null
	mov	bx,di		; Save ptr to beginning of env var name
	call	move_name
	push	si
	xchg	bx,di		; Switch ptrs to beginning and end of
				;  env var name
		
; We want to special-case COMSPEC. This is to reduce the amount of code
; necessary in the resident for re-reading the transient. Let's look for
; COMSPEC=

	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
	mov	si,COMSPECSTR ; "COMSPEC="
	mov	cx,4
	repe	cmpsw
	jnz	short NOT_COMSPEC
				; Zero set => exact match
	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
	;mov	byte [COMSPEC_FLAG],1
NOT_COMSPEC:
	mov	di,bx		; Load ptr to end of env var name
ADD_NAME:
	pop	si		; Add the value of the new env var
	push	si		;  to the environment.
ADD_NAME1:
	lodsb
	cmp	al,13 ; 0Dh
	je	short ADD_NAME_RET
	call	store_char
	jmp	short ADD_NAME1
ADD_NAME_RET:
	pop	si
	cmp	byte [comspec_flag],0
				; If the new env var is comspec,	
ADD_NAME_JZ_RET:
	jz	short ADD_PROMPT_RETN 
				;  copy the value into the
				;  comspec var in the resident

; We have changed the COMSPEC variable. We need to update the resident
; pieces necessary to reread in the info. First, skip all delimiters

	call	scanoff
	mov	es,[RESSEG]	;  comspec var in the resident

; Make sure that the printer knows where the beginning of the string is

	mov	di,ComSpec
	mov	bx,di

; Generate drive letter for display

	xor	ax,ax		;g assume no drive first
	mov	[es:ComDrv],al
	; 23/02/2023
	; MSDOS 6.0 (& 5.0)
	push	ax		;AN000; 3/3/KK
	mov	al,[si]		;AN000; 3/3/KK
	call	testkanj	;AN000; 3/3/KK	
	pop	ax		;AN000; 3/3/KK
	jnz	short _GOTDRIVE
	;
	cmp	byte [si+1],':'	; drive specified?
	jne	short _GOTDRIVE
	mov	al,[si]		; get his specified drive
	; 23/02/2023
	call	UPCONV
	;call	UPCONV_MAPCALL	; convert to uppercase
	sub	al,'A'		; convert to 0-based
	add	di,2
	inc	al		; convert to 1-based number
	mov	[es:ComDrv],al

; Stick the drive letter in the prompt message. Nothing special needs to be
; done here..
	;add	al,40h
	add	al,'A'-1
_GOTDRIVE:
	; 23/02/2023
	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
	;mov	[es:PUTBACKSUBSTPTR],di
	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
	mov	[es:PutBackComSpec],di
				;g point to beginning of name after drive
	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
	;mov	[es:PUTBACKDRV],al
	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
	mov	[es:PutBackDrv],al

; Copy chars until delim      	

	mov	di,bx
COPY_COMSPEC:
	lodsb
	call	DELIM
	jz	short COPYDONE
	cmp	al,13 ; 0Dh
	je	short COPYDONE
	stosb
	jmp	short COPY_COMSPEC
COPYDONE:
	xor	al,al		; Null terminate the string and quit
	stosb
	;mov	byte [comspec_flag],0
	mov	[comspec_flag],al ; 0 ; 23/02/2023
	dec	di
	mov	[es:ComSpec_End],di
	retn

DISP_ENV:
	mov	ds,[RESSEG]
	mov	ds,[EnvirSeg]
	; assume ds:nothing
	xor	si,si
PENVLP:
	cmp	byte [si],0
	jz	short ADD_NAME_JZ_RET
	mov	di,Arg_Buf
PENVLP2:
	lodsb
	stosb
	or	al,al
	jnz	short PENVLP2
	mov	dx,arg_buf_ptr
	push	ds
	push	es
	pop	ds
	; assume ds:nothing
	call	Printf_Crlf
	pop	ds
	jmp	short PENVLP

; =============== S U B	R O U T	I N E =======================================

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
delete_path:
	mov	si,PATH_TEXT ; "PATH="
	jmp	short delete_name_in_environment

; =============== S U B	R O U T	I N E =======================================

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
delete_prompt:
	mov	si,PROMPT_TEXT ; "PROMPT="

; ---------------------------------------------------------------------------

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
delete_name_in_environment:

; Input: DS:SI points to a "=" terminated string
; Output: carry flag is set if name not found
;	  otherwise name is deleted

	push	si
	push	ds
	call	FIND		; ES:DI points to name
	jc	short del1
	mov	si,di		; Save it
	call	SCASB2		; Scan for the nul
	xchg	si,di
;SR;
; If we have only one env string, then the double null is lost when the last
;string is deleted and we have an invalid empty environment with only a 
;single null. To avoid this, we will look for the double null case and then
;move an extra null char.
; Bugbug: The only possible problem is that the last pathstring 
;will be followed by a triple null. Is this really a problem?

	; MSDOS 6.0
	cmp	byte [es:si],0	;null char?
	jnz	short not_dnull	;no, we are at a double null
	dec	si		;point at the double null
not_dnull:
	; MSDOS 3.3 (& MSDOS 6.0)
	call	GETENVSIZ
	sub	cx,si
	push	es
	pop	ds		; ES:DI points to name
				; DS:SI points to next name
	rep	movsb
del1:
	pop	ds
	pop	si
find_retn:
	retn

; =============== S U B	R O U T	I N E =======================================

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
find_path:
	mov	si,PATH_TEXT ; "PATH="
	jmp	short find_name_in_environment

; =============== S U B	R O U T	I N E =======================================

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
find_prompt:
	mov	si,PROMPT_TEXT ; "PROMPT="

; ---------------------------------------------------------------------------

find_name_in_environment:

; Input: DS:SI points to a "=" terminated string
; Output: ES:DI points to the arguments in the environment
;	  zero is set if name not found
;	  carry flag is set if name not valid format

	call	FIND		; Find the name
	jc	short find_retn	; Carry means not found	
	jmp	SCASB1		; Scan for = sign

; ---------------------------------------------------------------------------
	;nop

; =============== S U B	R O U T	I N E =======================================

; On return of FIND1, ES:DI points to beginning of name

FIND:
	cld
	call	COUNT0		; CX = Length of name
	mov	es,[RESSEG]
	;assume es:RESGROUP
	mov	es,[es:EnvirSeg]
	;assume es:NOTHING
	xor	di,di
find1:	
	push	cx
	push	si
	push	di
find11:
	lodsb
	; 23/02/2023 
	; MSDOS 6.0 (& 5.0)
	call	testkanj	
	jz	short notkanj3
	dec	si
	lodsw
	inc	di
	inc	di
	cmp	ax,[es:di-2]
	jne	short find12
	dec	cx
	loop	find11
	jmp	short find12
notkanj3:
	call	UPCONV		; MSDOS 5.0 (& 6.0)
	;call	UPCONV_MAPCALL	; MSDOS 3.3
	inc	di
	cmp	al,[es:di-1]
	jne	short find12
	loop	find11
find12:
	pop	di
	pop	si
	pop	cx
	jz	short find_retn
	push	cx
	call	SCASB2		; Scan for a nul
	pop	cx
	cmp	byte [es:di],0
	jnz	short find1
	stc			; Indicate not found
	retn

; =============== S U B	R O U T	I N E =======================================

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
COUNT0:
	push	ds
	pop	es
	;assume es:nothing
	mov	di,si
;COUNT1:
	push	di		; Count number of chars until "="
	call	SCASB1
	; 23/02/2023
;	jmp	short COUNTX
;COUNT2:
;	push	di		; Count number of chars until nul
;	call	SCASB2
;COUNTX:
	pop	cx
	sub	di,cx
	xchg	di,cx
move_name_retn:
	retn

; =============== S U B	R O U T	I N E =======================================

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
move_name:
	cmp	byte [si],13 ; 0Dh
	je	short move_name_retn
	lodsb
	; 23/02/2023 
	; MSDOS 6.0 (& 5.0)
	call	testkanj		
	jz	short notkanj1
	call	store_char
	lodsb
	call	store_char
	jmp	short move_name
notkanj1: 
	call	UPCONV
	;call	UPCONV_MAPCALL ; MSDOS 3.3
	call	store_char
	cmp	al,'='
	jne	short move_name
getarg_retn:
	retn

; =============== S U B	R O U T	I N E =======================================

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
GETARG:
	mov	si,80h
	lodsb
	or	al,al
	jz	short getarg_retn
	call	scanoff
	cmp	al,13 ; 0Dh
sdn_retn:
	retn

; =============== S U B	R O U T	I N E =======================================

; Point ES:DI to the final NULL string. Note that in an empty environment,
; there is NO double NULL, merely a string that is empty.

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
scan_double_null:
	mov	es,[RESSEG]
	mov	es,[es:EnvirSeg]
	xor	di,di

; Top cycle-point. If the string here is empty, then we are done

sdn1:
	cmp	byte [es:di],0	; nul string?
	jz	short sdn_retn	; yep, all done
	call	SCASB2
	jmp	short sdn1

; =============== S U B	R O U T	I N E =======================================

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
SCASB1:
	mov	al,'='		; Scan for an =
	jmp	short SCASBX

; =============== S U B	R O U T	I N E =======================================

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
SCASB2:
	xor	al,al		; Scan for a nul

; ---------------------------------------------------------------------------

	; 23/02/2023
SCASBX:
	mov	cx,256
	repne	scasb
	retn

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;Bugbug: This is Kanji stuff - put it in conditionals

	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
testkanj:
	push	ds			;AN000;  3/3/KK
	push	si			;AN000;  3/3/KK
	push	ax			;AN000;  3/3/KK
	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
ktlop:					;AN000;  3/3/KK
	cmp	word [si],0		;AN000;  end of Table 3/3/KK
	je	short notlead 		;AN000;  3/3/KK
	pop	ax			;AN000;  3/3/KK
	push	ax			;AN000;  3/3/KK
	cmp	al,[si]			;AN000;  3/3/KK
	jb	short notlead 		;AN000;  3/3/KK
	inc	si			;AN000;  3/3/KK
	cmp	al,[si]			;AN000;  3/3/KK
	jbe	short islead		;AN000;  3/3/KK
	inc	si			;AN000;  3/3/KK
	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
notlead:				;AN000;  3/3/KK
	xor	ax,ax			;AN000;  set zero 3/3/KK
	jmp	short ktret		;AN000;  3/3/KK
islead: 				;AN000;  3/3/KK
	xor	ax,ax			;AN000;  reset zero 3/3/KK
	inc	ax			;AN000;  3/3/KK
ktret:					;AN000;  3/3/KK
	pop	ax			;AN000;  3/3/KK
	pop	si			;AN000;  3/3/KK
	pop	ds			;AN000;  3/3/KK
	retn				;AN000;  3/3/KK

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
; *
; * FUNCTION:	 This routine returns the upper case equivalent of
; *		 the character in AL from the file upper case table
; *		 in DOS if character if above  ascii 128, else
; *		 subtracts 20H if between "a" and "z".
; *
; * INPUT:	 AL	      char to be upper cased
; *		 FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:	 AL	      upper cased character
; *
; ****************************************************************

	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
UPCONV:
	cmp	al,80h			;AN000;  see if char is > ascii 128
	jb	short oth_fucase	;AN000;  no - upper case math
	sub	al,80h			;AN000;  only upper 128 chars in table
	push	ds			;AN000;
	push	bx			;AN000;
	mov	ds,[RESSEG]		;AN000;  get resident data segment
	;lds	bx,dword ptr FUCase_Addr+1
	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
	add	bx,2			;AN000;  skip over first word
	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
	xlat
	pop	bx			;AN000;
	pop	ds			;AN000;
	;jmp	short upconv_end	;AN000;  we finished - exit
	; 24/02/2023
	retn
oth_fucase:				;AN000;
	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
	jb	short upconv_end	;AC000;    subtract 20h to get
	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
	ja	short upconv_end	;AC000;
	sub	al,20h			;AC000; Change lower-case to upper
upconv_end:				;AN000;
	retn

; ---------------------------------------------------------------------------

; MSDOS 3.3

	; 24/02/2023
;UPCONV_MAPCALL:
	;			; If between "a" and "z"
	;cmp	al,[small_a]
	;jb	short UPCONV_END
	;cmp	al,[small_z]
	;ja	short UPCONV_END
	;sub	al,20h		; Change lower-case to upper
;UPCONV_END:
	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
	;			  ; 	  for (current) country
	;retn

; =============== S U B	R O U T	I N E =======================================

; STORE A CHAR IN environment, GROWING IT IF NECESSARY

	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; 10/06/2023
store_char:
	push	cx
	push	bx

	; 24/02/2023
	;;16/10/2018
	; MSDOS 6.0
	push	es		;AN056;*
	push	ds		;AN056; Save local DS
	mov	ds,[RESSEG]	;AN056; Get resident segment
	mov	es,[EnvirSeg]	;AN056; Get environment segment
	pop	ds		;AN056; Get local segment back

	; MSDOS 3.3 (& MSDOS 6.0)
	call	GETENVSIZ
	mov	bx,cx		; Save room for double nul	
	sub	bx,2
	cmp	di,bx
	jb	short store1
	push	ax
	push	cx
	push	bx		; Save Size of environment
	call	FREE_TPA
	pop	bx
	add	bx,2		; Recover true environment size

	cmp	bx,8000h	; Don't let environment grow > 32K	
	jb	short envsiz_ok
bad_env_size:			;AN056;
	stc
	jmp	short envnoset
	;nop
envsiz_ok:
	mov	cl,4
	shr	bx,cl		; Convert back to paragraphs
	inc	bx
	; 24/02/2023
	; MSDOS 6.0
	mov	cx,es		;AN056; Get environment segment
	add	cx,bx		;AN056; Add in size of environment
	add	cx,20h		;AN056; Add in some TPA
	mov	ax,cs		;AN056; Get the transient segment
	cmp	cx,ax		;AN056; Are we hitting the transient?
	jnb	short bad_env_size
				;AN056; Yes - don't do it!!!
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	ah,4Ah
	;mov	ah,SETBLOCK ; 4Ah
	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
			; ES = segment address of block	to change
			; BX = new size	in paragraphs
envnoset:
	pushf
	push	es
	mov	es,[RESSEG]
	call	ALLOC_TPA
	pop	es
	popf
	pop	cx
	pop	ax
	; 24/02/2023
	;pop	es ; MSDOS 6.0	;AN056;*	
	jnc	short store1
	; 10/06/2023 (BugFix)
	pop	es ; MSDOS 6.0	;AN056;*	
	mov	dx,ENVERR_PTR
	jmp	cerror
store1:	
	stosb
	mov	word [es:di],0	; NULL IS AT END
	; 24/02/2023
	pop	es ; MSDOS 6.0	;AN056;*
	pop	bx
	pop	cx
	retn

; =============== S U B	R O U T	I N E =======================================

	; 24/02/2023
GETENVSIZ:

;Get size of environment in bytes, rounded up to paragraph boundry
;ES has environment segment
;Size returned in CX, all other registers preserved

	push	es
	push	ax
	mov	ax,es
	dec	ax		;Point at arena	
	mov	es,ax
	;mov	ax,[es:3]
	mov	ax,[es:ARENA.size]
	mov	cl,4
	shl	ax,cl		;Convert to bytes
	mov	cx,ax
	pop	ax
	pop	es
getenvsiz_retn:
	retn

; =============== S U B	R O U T	I N E =======================================

	; 24/02/2023
RestUDir1:
	push	ds
	mov	ds,[RESSEG]
	cmp	byte [RestDir],0
	pop	ds
	jz	short getenvsiz_retn

; =============== S U B	R O U T	I N E =======================================

	; 24/02/2023
RestUDir:
	mov	dx,USERDIR1
	mov	ah,3Bh
	;mov	ah,CHDir ; 3Bh
	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
			; DS:DX	-> ASCIZ directory name	(may include drive)
	xor	al,al
	;call	SETREST
	;retn
	; 24/02/2023
	jmp	SETREST	

;============================================================================
; TENV2.ASM, MSDOS 6.0, 1991
;============================================================================
; 07/10/2018 - Retro DOS v3.0

; TITLE	Part6 COMMAND Transient routines.

;	Environment utilities and misc. routines

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h

; 24/02/2023 - Retro DOS v4.0 (& v4.1)
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h

; ---------------------------------------------------------------------------

; ****************************************************************
; *
; * ROUTINE:	 $CHDIR
; *
; * FUNCTION:	 Entry point for CHDIR command. Parse the command
; *		 line. If path is found, CHDIR to path. If a drive
; *		 letter is found, get and display the current dir
; *		 of the specified drive. If nothing is found, get
; *		 and display the current dir of the default drive.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
	; 10/06/2023
_$CHDIR:
	; MSDOS 6.0
	mov	si,81h
	mov	di,PARSE_CHDIR
				;AN000; Get address of PARSE_CHDIR
	xor	cx,cx		;AN000; clear cx,dx
	xor	dx,dx		;AN000;
	call	Parse_With_Msg	;AC018; call parser
	
	;cmp	ax,-1
	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
	;je	short bwdj	; No args
	;;cmp	ax,0
	;;cmp	ax,RESULT_NO_ERROR
	;			;AC000; did we have an error?
	;or	ax,ax ; ax = 0 ?
	;jnz	short ChDirErr	;AC018; yes - exit
	
	; 10/06/2023
	inc	ax	; cmp ax,-1
	jz	short bwdj ; 0FFFFh -> 0
	dec	ax	; cmp ax,0
	jnz	short ChDirErr ; 1 -> 0
	; ax = 0	

	;cmp	byte [PARSE1_TYPE],6
	cmp	byte [PARSE1_TYPE],result_drive
				;AC000; was a drive entered?
	jne	short REALCD	; no

; D: was found. See if there is anything more.

	mov	di,PARSE_CHDIR
				;AC000; get address of parse_chdir
	xor	dx,dx		;AC000;
	call	parse_check_eol ;AC000; call parser
	jnz	short ChDirErr	;AC000;
bwdj:
	call	build_dir_for_chdir
				; Drive only specified
	call	CRLF2
chdir_retn:
	retn

	; 24/02/2023
	; MSDOS 3.3
	;mov	ax,[COMSW]
	;or	ax,[ALLSWITCH]
	;mov	dx,BADPARMPTR
	;jnz	short CHDIR_ERR
	;mov	si,81h
	;call	SCANOFF
	;cmp	al,0Dh		; are we at end of line?
	;je	short BWDJ	; No args
	;inc	si
	;lodsb
	;cmp	al,':'
	;jne	short REALCD
	;push	si
	;call	SCANOFF
	;pop	si
	;cmp	al,0Dh		; was a drive entered?
	;jne	short REALCD	; no
;BWDJ:
	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
	;call	CRLF2
;CHDIR_RETN:
	;retn

	; 24/02/2023
	; MSDOS 6.0
REALCD:
	push	si		;AN000; save position in line
	lds	si,[PARSE1_ADDR]
				;AN000; get address of filespec
	call	Move_To_SrcBuf	;AN000; move to srcbuf
	pop	si		;AN000; restore position in line
	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
	xor	dx,dx		;AC000;
	call	parse_check_eol ;AC000; call parser
	jnz	short ChDirErr	;AC000;
	
	call	SETPATH
	test	byte [DestInfo],2
	jnz	short BadChDir

	; 26/04/2023
	mov	ah,3Bh
	;mov	ah,CHDir
	int	21h
	jnc	short chdir_retn
	
	call	get_ext_error_number
				;AN022; get the extended error
	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
				;AN022; see if path not found
	je	short BadChDir	;AN022; yes - issue old message
;SR;
; We want to issue "Invalid Directory" message even if the path is valid
;but is not a directory. The extended error returns "Access denied" which
;is kind of confusing. Issue the old message if access denied error is 
;returned

	cmp	ax,ERROR_ACCESS_DENIED ; 5
	je	short BadChDir
	
	call	set_ext_error_subst ;AN022;
	jmp	short ChDirErr	;AN022;

BadChDir:
	mov	dx,badcd_ptr
;ChDirErr:
;	call	std_eprintf
;mkdir_retn:
	;retn
	; 24/02/2023
	jmp	short ChDirErr	;AN022;

	; 24/02/2023
	; MSDOS 3.3
;REALCD:
	;call	SETPATH
	;test	byte [DESTINFO],2
	;jnz	short BADCHDIR
	;mov	ah,CHDir ; 3Bh
	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
	;		; DS:DX	-> ASCIZ directory name	(may include drive)
	;jnc	short CHDIR_RETN
;BADCHDIR:
	;mov	dx,BADCDPTR
;CHDIR_ERR:
	;call	STD_EPRINTF
;MKDIR_RETN:
	;retn

; =============== S U B	R O U T	I N E =======================================

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
_$MKDIR:
	; MSDOS 6.0
	call	SETRMMK
	jc	short MkDirErr

	mov	ah,39h
	;mov	ah,MKDIR
	int	21h
	jnc	short mkdir_retn

	call	get_ext_error_number	
				;AN022; get the extended error
	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
				;AN022; see if path not found
	je	short MD_other_err
				;AN022; yes - issue old message
	cmp	ax,ERROR_ACCESS_DENIED ; 5
				;AN022; access denied?
	je	short badmderr	;AN022; yes - see if file exists
	
	call	set_ext_error_subst
				;AN022;
	;jmp	short MkDirerr	;AC022; yes - go print it
	; 24/02/2023
ChDirErr:
MkDirErr:
RmDirErr:
	call	std_eprintf
mkdir_retn:
rmdir_retn:
	retn
	
badmderr:
	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
	mov	ah,1Ah
	;mov	ah,Set_DMA	;AN006;
	int	21h		;AN006;
	
	mov	ah,4Eh
	;mov	ah,Find_First	;AN006; see if file/dir exists
	;mov	cx,10h
	mov	cx,ATTR_DIRECTORY
				;AN006;   search for directory
	int	21h		;AN006;
	jc	short MD_other_err
				;AN006; doesn't exist - must be something else
	;;mov	dl,SRCXNAME.find_buf_attr
				;AN006; we found a file/dir
	;mov	dl,[SRCXNAME+21] 
	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
	test	dl,ATTR_DIRECTORY
				;AN006; was it a directory?
	jz	short MD_other_err
				;AN006; no - must have been a file
	mov	dx,MD_EXISTS_PTR
				;AN006; set up already exists error
	jmp	short MkDirErr	;AN006; make sure we didn't have network error
MD_other_err:			;AN006;
	mov	dx,badmkd_ptr
;MkDirErr:
	;call	std_eprintf
	;retn
	; 24/02/2023
	jmp	short MkDirErr

	; 24/02/2023
	; MSDOS 3.3
	;call	SETRMMK
	;jb	short MKDIRERR
	;mov	ah,MKDIR ; 39h
	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
	;		; DS:DX	-> ASCIZ pathname (may include drive)
	;jnc	short MKDIR_RETN
	;mov	dx,BADMKDPTR
	;call	GET_EXT_ERR_NUMBER
;MKDIRERR:
	;call	STD_EPRINTF
	;retn

; =============== S U B	R O U T	I N E =======================================

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
_$RMDIR:
	call	SETRMMK
	jb	short RmDirErr
	jnz	short badrderr

	mov	ah,3Ah
	;mov	ah,RMDIR ; 3Ah
	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
			; DS:DX	-> ASCIZ pathname (may include drive)
	jnc	short rmdir_retn ; 24/02/2023

	; 24/02/2023
	; MSDOS 6.0
	call	get_ext_error_number
				;AN022; get the extended error
	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
				;AN022; see if path not found
	je	short badrderr	;AN022; yes - issue old message
	cmp	ax,ERROR_ACCESS_DENIED ; 5
				;AN022; access denied?
	je	short badrderr	;AN022; yes - issue old message

	call	set_ext_error_subst
				;AN022;
	jmp	short RmDirErr	;AC022; yes - go print it

	; MSDOS 6.0
badrderr:
	; 24/02/2023
	mov	dx,badrmd_ptr
	jmp	short RmDirErr
;RmDirErr:
	;call	std_eprintf
;;rmdir_retn
	;retn

	; 24/02/2023
	; MSDOS 3.3
	;mov	dx,BADRMDPTR
	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
;RMDIRERR:
	;call	STD_EPRINTF
;RMDIR_RETN:
	;retn

; =============== S U B	R O U T	I N E =======================================

; 	<Common MkDir/RmDir set up code>
;****************************************************************
;*
;* ROUTINE:	SETRMMK
;*
;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
;*		commands. Parses the command line for a required
;*		filespec.
;*
;* INPUT:	command line at offset 81H
;*
;* OUTPUT:	carry clear
;*		    DS:DX points to ASCIIZ argument
;*		carry set
;*		    DS:DX has error message pointer
;*
;****************************************************************

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
SETRMMK:
	; MSDOS 6.0
	mov	si,81h
	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
	xor	cx,cx		;AN000; clear cx,dx
	xor	dx,dx		;AN000;
	;invoke	Parse_With_Msg	;AC000; call parser
	call	Parse_With_Msg
	;cmp	ax,0
	;cmp	ax,RESULT_NO_ERROR
	or	ax,ax ; 0 ?	;AC000; did we have an error?
	jnz	short noargerr	;AC000; yes - exit

	mov	di,SRCXNAME
				;AN000; get address of srcxname
	push	di		;AN000; save address
	push	si		;AN000; save position in line
	lds	si,[PARSE1_ADDR]
				;AN000; get address of path
mrdir_move_filename:		;AN000; put filespec in srcxname
	lodsb			;get a char from buffer
	stosb			;AN000; store in srcxname
	;cmp	al,0
	;cmp	al,END_OF_LINE_OUT
	and	al,al ; 0 ?	;AC000; it char a terminator?
	jnz	short mrdir_move_filename
				;AC000; no - keep moving
	pop	si		;AN000; get line position back

; we have scanned an argument.	See if any args beyond.

	mov	di,PARSE_MRDIR
	call	parse_check_eol ;AC000; are we at end of line?
	pop	dx		;AC000; get address of SRCXNAME
	;retz			;yes - return no error
	jz	short setrmmk_retn
noargerr:
	mov	dx,extend_buf_ptr
				;AC000; get extended message pointer
	xor	ax,ax
	stc
setrmmk_retn:
	retn

	; 24/02/2023
	; MSDOS 3.3
;SETRMMK:
	;mov	si,81h
	;call	SCANOFF
	;cmp	al,0Dh
	;je	short NOARGERR
	;mov	dx,si
;SETRMMK1:
	;lodsb
	;call	DELIM
	;jz	short SETRMMK3
	;cmp	al,0Dh
	;jne	short SETRMMK1
	;mov	byte [si-1],0
;SETRMMK2:
	;retn
;SETRMMK3:
	;mov	byte [si-1],0
	;push	si
	;call	SCANOFF
	;pop	si
	;cmp	al,0Dh
	;je	short SETRMMK2
;NOARGERR:
	;mov	dx,BADARGSPTR
	;xor	ax,ax
	;stc
;SETRMMK_RETN:
	;retn

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;****************************************************************
;*
;* ROUTINE:	Set_ext_error_subst
;*
;* FUNCTION:	Sets up substitution for extended error
;*
;* INPUT:	AX - extended error number
;*		DX - offset of string
;*
;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
;*
;****************************************************************

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
set_ext_error_subst:
	;mov	byte [msg_disp_class],1
	mov	byte [msg_disp_class],ext_msg_class
					;AN022; set up extended error msg class
	mov	[string_ptr_2],dx 	;AN022; get address of failed string
	;mov	byte [extend_buf_sub],1
	mov	byte [extend_buf_sub],one_subst 
	;AN022; put number of subst in control block
	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
savudir_err_retn: ; 24/02/2023
	retn				;AN022; return

; =============== S U B	R O U T	I N E =======================================

; <SavUDir - preserve the users current directory on a particular drive>

; SavUDir - move the user's current directory on a drive into UserDir1
; SavUDir1 - move the user's current directory on a drive into a specified
;   buffer
;
;   Inputs:	DL has 1-based drive number
;		ES:DI has destination buffer (SavUDir1 only)
;   Outputs:	Carry Clear
;		    DS = TranGroup
;		Carry Set
;		    AX has error code
;   Registers Modified: AX, SI

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
SAVUDIR:
	mov	di,USERDIR1
; --------------
SAVUDIR1:
	mov	al,dl
	add	al,'@' ; 40h
	cmp	al,'@' ; 40h
	jne	short GOTUDRV
	add	al,[CURDRV]
	inc	al		; A = 1
GOTUDRV:
	stosb
	mov	ah,[DIRCHAR]
	mov	al,':' ; 3Ah
	stosw
	push	es
	pop	ds
	mov	si,di
	mov	ah,47h ; 24/02/2023
	;mov	ah,CURRENT_DIR	; 47h
	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
			; DL = drive (0=default,1=A,etc.)
			; DS:SI	points to 64-byte buffer area
	jc	short savudir_err_retn ; 24/02/2023
	push	cs
	pop	ds
	retn

; =============== S U B	R O U T	I N E =======================================

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
CRLF2:
	push	dx
	mov	dx,acrlf_ptr
	push	ds
	push	cs
	pop	ds
	call	std_printf
	pop	ds
	pop	dx
	retn

; =============== S U B	R O U T	I N E =======================================

; These routines (SCANOFF, DELIM) are called in batch processing when DS
; may NOT be TRANGROUP

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
scanoff:
	lodsb
	call	DELIM
	jz	short scanoff
	dec	si		; Point to first non-delimiter
scanoff_retn:
	retn

; =============== S U B	R O U T	I N E =======================================

; Input:    AL is character to classify
; Output:   Z set if delimiter
;	    NZ set otherwise
; Registers modified: none

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
DELIM:
	cmp	al,' '	 ;20h
	je	short scanoff_retn
	cmp	al,'='  ; 3Dh
	je	short scanoff_retn
	cmp	al,','	; 2Ch
	je	short scanoff_retn
	cmp	al,';'	 ;3Bh
	je	short scanoff_retn
	cmp	al,9		; Check for TAB character
	je	short scanoff_retn
	cmp	al,0Ah		; Check for line feed character - BAS
	retn


; =============== S U B	R O U T	I N E =======================================

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
FCB_TO_ASCZ:			
	; Convert DS:SI to ASCIZ ES:DI
	mov	cx,8
MAINNAME:
	lodsb
	cmp	al,' ' ; 20h
	jz	short SKIPSPC
	stosb
SKIPSPC:
	loop	MAINNAME
	lodsb
	cmp	al,' '
	je	short GOTNAME
	mov	ah,al
	; 24/02/2023
	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
	;mov	al,[DOT_CHR]  ; MSDOS 3.3
	;stosb
	;xchg	al,ah
	;stosb
	; 24/02/2023
	stosw
	mov	cl,2
EXTNAME:
	lodsb
	cmp	al,' '
	je	short GOTNAME
	stosb
	loop	EXTNAME
GOTNAME:
	xor	al,al
	stosb
STRCOMP_RETN:
	retn

; =============== S U B	R O U T	I N E =======================================

; Compare ASCIZ DS:SI with ES:DI.
; SI,DI destroyed.

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
STRCOMP:	
	cmpsb
	jnz	short STRCOMP_RETN ; Strings not equal
	cmp	byte [si-1],0	; Hit NUL terminator?	
	;jz	short STRCOMP_RETN ; Yes, strings equal
	;jmp	short STRCOMP	; Equal so far, keep going
	; 24/02/2023
	jnz	short STRCOMP
	retn

; =============== S U B	R O U T	I N E =======================================

	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
CRPRINT:
	push	ax
	;mov	al,13	; 0Dh
	mov	al,0Dh
	push	cx
	push	di
	mov	di,dx
	mov	cx,65535 ; 0FFFFh
	push	es
	push	ds
	pop	es
	repne	scasb		; LOOK FOR TERMINATOR
	mov	byte [di-1],0	; nul terminate the string
	pop	es
	mov	[string_ptr_2],dx
	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
	call	std_printf
	;mov	byte [di-1],13
	mov	byte [di-1],0Dh	; now put the CR back
	jb	short error_output
	pop	di
	pop	cx
	pop	ax
	retn

; ---------------------------------------------------------------------------

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
error_output:
	push	cs
	pop	ds
	mov	es,[RESSEG]
	mov	dx,NOSPACE_PTR
	cmp	byte [es:PipeFlag],0
	jz	short go_to_error
	call	PipeOff
	mov	dx,PIPEEMES_PTR
go_to_error:
	jmp	cerror

; =============== S U B	R O U T	I N E =======================================

;---- Mod for path invocation ----

	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
pathchrcmp:
	; 18/03/2023	
	;push	ax
	;mov	ah,'/' ; 2Fh
	;cmp	[SWITCHAR],ah
	cmp	byte [SWITCHAR],'/' ; 2Fh
	je	short noslasht
	cmp	al,'/'
	je	short pccont
noslasht:
	cmp	al,'\' ; 5Ch
pccont:	
	;pop	ax
	retn

; =============== S U B	R O U T	I N E =======================================

; PATHCRUNCH -
;
; ENTRY FCB (in PSP) contains drive # to crunch on
;       PathPos = ptr to string with pathname in it
;       PathCnt = length of string
;
; EXIT  PathPos = ptr after pathname (w/ NULL) in string
;       PathCnt = length left in string
;       DestIsDir = nonzero if pathname delimiter char's found in pathname
;       DestInfo<bit1> = set if wildcard char's found in pathname
;       If path crunched successfully,
;         CY = clear
;         Current directory is changed to directory in pathname
;         UserDir1 contains previous directory for use by RestUDir
;         RestDir = nonzero to flag later restoration of user's dir
;         DestTail = ptr to beginning of filename
;         If filename found in pathname,
;           ZR = clear
;           FCB filename fields contain filename
;         If filename not found (pure directory path),
;           ZR = set
;           FCB filename fields are wildcarded with ?'s
;       If pathcrunch failed (no ChDir's worked),
;         CY = set
;         Msg_Numb = extended error code
;
; NOTE  DIR asks PathCrunch to forego parsing the filename into the
;       FCB by setting DirFlag. In this case, the FCB is returned
;       with the filename wildcarded.

	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h

PathCrunch:
	; MSDOS 6.0
	mov     word [Msg_Numb],0
				;AN022; Set up message flag
	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	dl,[5Ch]
	mov	dl,[FCB]	; DL = drive # (1 = A)
	call	SAVUDIR		; save current directory in UserDir1
	; MSDOS 6.0
 	jc	short pcrunch_cderrj
				;AN022; if error on current dir - report
	call	SETPATH		; scan past switches, whitespace

;       DX = ptr to pathname, NULL-terminated
;       PathPos = ptr to byte after NULL at end of pathname

	; MSDOS 3.3 (& MSDOS 6.0)
	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
	jnz	short trypeel	; wildcard seen, peel filename

	;mov	ah,CHDir ; 3Bh
	mov	ah,3Bh
	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
			; DS:DX	-> ASCIZ directory name	(may include drive)
	; MSDOS 6.0
	jnc	short chdir_worked	;AN022; no error - continue
	
	call	get_ext_error_number    ;AN022; get the extended error
	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
	je	short trypeel		;AC022;    keep trying
	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
	je	short trypeel		;AC022;    keep trying
	mov	[Msg_Numb],ax           ;AN022; set up message flag
	jmp	peelfail                ;AN022; exit with other error

	; MSDOS 3.3
	;jc	short trypeel
chdir_worked:
	; MSDOS 3.3 (& MSDOS 6.0)
	call	SetRest1	; set 'Restore Directory' flag true
	mov	al,'?'		; if pure dir, wildcard filename in FCB
	mov	di,5Dh  ; FCB+1
	mov	cx,11
	rep	stosb
	xor	al,al		; return carry clear, zero set
	retn

pcrunch_cderrj: 		;AN022; need this for long jmp
	jmp	pcrunch_cderr	;AN022;

trypeel:
	mov	si,[PathPos]
	dec	si		; SI = ptr to NULL at end of pathname
	mov	al,[si-1]	; AL = last char of pathname
	; 25/02/2023
	; MSDOS 5.0 (& 6.0)
	cmp	byte [KPARSE],0
	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
	
	call	pathchrcmp
	jz	short peelfail	; Trailing '/'
delstrt:
	mov	cx,si		; CX = ptr to NULL at end of pathname
	mov	si,dx		; SI = ptr to start of pathname
	push	dx		; save ptr to pathname
delloop:
	cmp	si,cx
	;jz	short BADRET
	; 25/02/2023
	je	short gotdele	; no char's left, we have what we have
	lodsb			; AL = next char of pathname
	call	testkanj
	jz	short notkanj8	; not Kanji, move along
	inc	si
	jmp	short delloop	

	; 25/02/2023
	; MSDOS 3.3
	;mov	al,[si]
	;call	PATHCHRCMP
	;jz	short TRYCD
	;dec	si
	;jmp	short delloop

notkanj8:
	call	pathchrcmp
	jnz	short delloop	; not a path delimiter, keep looking
	mov	dx,si
	dec	dx		; DX = ptr to last delimiter found	
	jmp	short delloop	; go look for more

	; 25/02/2023
	; MSDOS 5.0 (& 6.0)
gotdele:
	mov	si,dx		; SI = ptr to pathname or last delim
	pop	dx		; DX = ptr to pathname
	cmp	si,dx
	je	short badret	; didn't find path delim
	mov	cx,si		; CX = ptr to last path delimiter
	mov	si,dx		; SI = ptr to pathname
delloop2:			; Set value of KPARSE
	cmp	si,cx
	je	short trycd	; roll up till SI meets CX
	mov	byte [KPARSE],0
	lodsb
	call	testkanj
	jz	short delloop2
	inc	si
	inc	byte [KPARSE]
	jmp	short delloop2

trycd:
	push	ax
	; 25/02/2023
	mov	al,'.'
	;mov	al,[DOT_CHR]	; AL = '.'
	; MSDOS 6.0
	cmp	[si+1],al	; check for '.' after path delim
				;M019; allow continuation if '. ' or 
				;M019; '..' is not found.
	jne	short trycd1	;M019; '.' not found
	cmp	[si+2],al	;M019; check for '..'
	je	short trycd1	;M019; found '..'
	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
trycd1:	
	pop     ax
	jz	short peelfail	; if . or .., pure cd should have worked

	; 25/02/2023
	; MSDOS 3.3
	;cmp	[si+1],	al	; check for '.' after path delim
	;pop	ax
	;jz	short PEELFAIL	; if . or .., pure cd should have worked

	; MSDOS 3.3 (& MSDOS 6.0)
	mov	al,[si-1]
	cmp	al,':' 		; Special case d:\file
	je	short badret
	; 25/02/2023
	; MSDOS 6.0
	cmp	byte [KPARSE],0
	jnz	short notdoublesl
	call	pathchrcmp
	;jnz	short notdoublesl
				; Last char is 2nd KANJI byte, might be '\'
	; 25/02/2023
	jz	short peelfail 
;peelfail:
	;stc
	;retn

notdoublesl:
	mov	byte [si],0
	;mov	ah,CHDir ; 3Bh
	mov	ah,3Bh
	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
			; DS:DX	-> ASCIZ directory name	(may include drive)
	jnc	short cdsucc

	; 25/02/2023
	; MSDOS 6.0
pcrunch_cderr:
	call	get_ext_error_number
				;AN022; get the extended error
	mov	[Msg_Numb],ax	;AN022; set up message flag
	or	si,si		;AN022; set up zero flag to not zero
peelfail: ; 25/02/2023
	stc			;AN022; set up carry flag
pcrunch_retn:
	retn

badret:
	; MSDOS 3.3 & MSDOS 6.0
	mov	al,[si]
	call	pathchrcmp	; Special case 'DIRCHAR'file
	stc
	jnz	short pcrunch_retn
	xor	bl,bl
	xchg	bl,[si+1]
	;mov	ah,CHDir ; 3Bh
	mov	ah,3Bh
	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
			; DS:DX	-> ASCIZ directory name	(may include drive)
	;jc	short pcrunch_retn ; MSDOS 3.3
	; 25/02/2023
	jc	short pcrunch_cderr
				;AN022; go to error exit 
	mov	[si+1],bl
cdsucc:
	call	SetRest1
	inc	si		; Reset zero
	mov	[DestTail],si
	; 25/02/2023
	; MSDOS 6.0
	pushf			;AN015; save flags
	cmp	byte [DirFlag],-1
				;AN015; don't do parse if in DIR
	je	short pcrunch_end
				;AN015;
	; MSDOS 3.3 & MSDOS 6.0
	mov	di,FCB  ; 5Ch
	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
	mov	ax,2902h	
	int	21h		; Parse with default drive
			; DOS -	PARSE FILENAME
			; DS:SI	-> string to parse
			; ES:DI	-> buffer to fill with unopened	FCB
			; AL = bit mask	to control parsing
	; MSDOS 3.3
	;retn

pcrunch_end:
	popf			;AN015; get flags back
	retn

;============================================================================
; TMISC1.ASM, MSDOS 6.0, 1991
;============================================================================
; 05/10/2018 - Retro DOS v3.0

;TITLE	Part7 COMMAND Transient Routines

;	More misc routines

;---------------------------
; We can get rid of this switch processing code if we can take
; care of the remaining two calls to switch, later in the file.
; However, I have not checked whether or not any other files use
; switch -- after all, it IS public!
;---------------------------

; 28/03/2023
SWCOUNT  EQU  6  ; MSDOS 6.0		; Length of switch_list
;SWCOUNT EQU  5  ; MSDOS 3.3	

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h

; 25/02/2023 - Retro DOS v4.0 (& v4.1)
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h

; ---------------------------------------------------------------------------

	; 25/02/2023
RETSW:
	xchg	ax,bx		; Put switches in AX
	retn

; =============== S U B	R O U T	I N E =======================================

	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
SWITCH:
	xor	bx,bx		; Initialize - no switches set
SWLOOP:
	call	scanoff		; Skip any delimiters
	cmp	al,[SWITCHAR]	; Is it a switch specifier?
	jnz	short RETSW	; No -- we're finished
	or	bx,8000h
	;or	bx,FSWITCH	; Indicate there is a switch specified
	inc	si		; Skip over the switch character
	call	scanoff
	cmp	al,0Dh
	je	short RETSW	; Oops
	inc	si

	; Convert lower case input to upper case

	call	UPCONV
	;call	UPCONV_MAPCALL	; MSDOS 3.3

	mov	di,switch_list	; "?VBAPW" (for MSDOS 6.0)
				; ("VBAPW" (for MSDOS 3.3))
	mov	cx,6  ; MSDOS 6.0
	;mov	cx,5  ; MSDOS 3.3
	;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
		
	;nop
		
	repne	scasb		; Look for matching switch
	jnz	short BADSW
	mov	ax,1
	shl	ax,cl		; Set a bit for the switch
	or	bx,ax
BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
	jmp	short SWLOOP
;BADSW:
	;jmp	short SWLOOP
;DRVBAD:
;	mov	dx,baddrv_ptr
;	jmp	cerror
EXTERNALJ:
	jmp	EXTERNAL
FNDCOM:				; search the internal command table
	or	al,al		; Get real length of first arg
	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
				;  to be external.
; barryf code starts here

	call	test_append	; see if APPEND installed
	jz	short CONTCOM	; not loaded

APPEND_INTERNAL:
	mov	cl,[IDLEN]
	mov	ch,0
	mov	[PathPos],cx
	
	; 25/02/2023	
	; MSDOS 6.0
	inc 	byte [append_exec]
				;AN041; set APPEND to ON
	call	IOSET		; re-direct the o'l io

	mov	si,IDLEN	; address command name, DS already set	
	mov	dx,-1 ; 0FFFFh	; set invoke function
		
	; MSDOS 6.0
	mov	di,append_parse
				;AN010; Get the entry point for PARSE for APPEND
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	ax,0AE01h
	int	2Fh	; - Multiplex -	DOS 3.3+ internal
			; - INSTALLABLE	COMMAND	- EXECUTE
			; DX = FFFFh, DS:SI -> buffer
			; Return: buffer at DS:SI filled with a	length byte
			; followed by the uppercase internal command
			; to execute (if length not 0)
	; 25/02/2023
	; INT 2Fh
	; 	AX = AE01h
	; entry:
	; 	DX = magic value FFFFh
	; 	CH = 00h
	; 	CL = length of command name
	; 	DS:BX -> command line buffer  -- (offset COMBUF)
	; 	DS:SI -> command name buffer  -- (offset IDLEN)
	; return:
	;	DS:SI buffer updated
	;	if length byte is nonzero, the following bytes contain
	;	the uppercase internal command to execute and the command line
	; 	buffer contains the command's parameters
	;	(the first DS:[SI] bytes are ignored)
	;
	; Format of COMMAND.COM command line buffer:
	;	Offset  Size    Description
	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
	;	N BYTEs command line text, terminated by 0Dh
	;
	; Format of command name buffer:
	;	Offset  Size    Description
	;	00h     BYTE    length of command name
	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)

	cmp	byte [IDLEN],0 ; execute requested
	jne	short CONTCOM
	jmp	CMD_DONE

	;nop
CONTCOM:			; continue with internal scan
	mov	di,COMTAB
	xor	cx,cx
FINDCOM:
	mov	si,ID		; pointer to command argument
	mov	cl,[di]		; load length of internal command
	inc	di		; advance past length
	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
	cmp	cl,[IDLEN]	; that of the command argument
	jne	short ABCD	; lengths not equal ==> strings not eq
	mov	[PathPos],cx	; store length of command
	repe	cmpsb
ABCD:					
	lahf			; save the good ol' flags
	add	di,cx		; skip over remaining internal, if any
	mov	al,[di]		; load drive-check indicator byte (DCIB)
	mov	[CHKDRV],al	; save command flag byte in chkdrv
	inc	di		; increment DI (OK, OK, I'll stop)
	mov	bx,[di]		; load internal command address
	inc	di		; skip over the puppy
	inc	di
		
	; MSDOS 6.0
	mov	dx,[di]		; load ptr to help msg #s
	inc	di
	inc	di
	sahf			; remember those flags?
	jnz	short FINDCOM	; well, if all the cmps worked...

; All messages get redirected.

	cmp     byte [append_exec],0
				;AN041; APPEND just executed?
	jnz 	short DONT_SET_IO
				;AN041; Yes - this junk is already set
	call	IOSET		; re-direct the ol' i/o

DONT_SET_IO:			;AN041;

; Check for /?. Certain commands, flagged fLimitHelp,
; respond to /? only if it is the only command-line argument.

	mov	ax,[COMSW]	; AX = switches after command
	or	ax,[AllSwitch]	; AX = all switches
	;and	ax,SwitchQues	
	and	ax,20h
	jz	short DRIVE_CHECK
				; /? not in command line
	test	byte [CHKDRV],4	
	;test	byte [CHKDRV],fLimitHelp
	jz	short DO_HELP	; /? allowed in combination

; Make sure /? is the only argument on the command line.

	cmp	word [ARG+ARG_UNIT.argvcnt],2
	jne	short DRIVE_CHECK
				; /? not only arg - ignore

; Note: this is all the check we need, even against things like /??.
; Our argv parser breaks /?? into two args, /? and ?.

DO_HELP:
; DX = ptr to word list of msg #s, terminated by zero word

	mov	si,dx		; SI = ptr to list of msg #s
    	;mov	ax,no_subst	; AL = no subst's code
	mov	ax,0
	push	ax		; build subst block on stack

NEXT_HELP_MSG:
	lodsw			; AX = help msg # or zero
	or	ax,ax
	jz	short HELP_DONE
	push	ax		; SS:SP = ptr to subst block
				; (msg # and no_subst byte)
;; We assume DS = SS.
	
	mov     dx,sp		; DS:DX = ptr to subst block
	call	std_printf	; display help message	
	pop	ax		; remove msg # from stack
	jmp	short NEXT_HELP_MSG

HELP_DONE:
	pop	ax		; clean up stack
	jmp	TCOMMAND	

	; 25/02/2023
	; MSDOS 3.3
	;sahf			; remember those flags?
	;jnz	short FINDCOM	; well, if all the cmps worked...
	;call	IOSET		; re-direct the ol' i/o

DRIVE_CHECK:
	test	byte [CHKDRV],1
	;test	byte [CHKDRV],FCHECKDRIVE 
				; did we wanna check those drives?
	jz	short NOCHECK
	mov	al,[PARM1]	; parse_file_descriptor results tell
	or	al,[PARM2]	; us whether those drives were OK
	cmp	al,-1
	jne	short NOCHECK
	;jmp	DRVBAD
	; 25/02/2023
DRVBAD:
	mov	dx,baddrv_ptr
	jmp	cerror

; The user may have omitted the space between the command and its arguments.
; We need to copy the remainder of the user's command line into the buffer.
; Note that thisdoes not screw up the arg structure; it points into COMBUF not
; into the command line at 80.

NOCHECK:
	call	cmd_copy
SWITCHECK:
	;test	byte [CHKDRV],2
	test	byte [CHKDRV],fSwitchAllowed 
				; Does the command take switches
	jnz	short REALWORK	; Yes, process the command
	call	noswit		; No, check to see if any switches
	jnz	short REALWORK	; None, process the command

	; MSDOS 6.0
	;mov	byte [msg_disp_class],2
	mov	byte [msg_disp_class],parse_msg_class
				;AN000; set up parse error msg class
	mov	dx,extend_buf_ptr	
				;AC000; get extended message pointer
	;mov	word [extend_buf_ptr],3
	mov	word [extend_buf_ptr],BadSwt_Ptr
				;AN000; get "Invalid switch" message number
	jmp	cerror		; Print error and chill out...

	; 25/02/2023
	; MSDOS 3.3
	;mov	dx,BADPARMPTR
	;jmp	CERROR

REALWORK:
	call	bx		; do some real work, at last

; See if we're in a batch CALL command. If we are, reprocess the command line,
; otherwise, go get another command.

CMD_DONE:
	push	cs		; g  restore data segment
	pop	ds		; g
	push	ds
	mov	ds,[RESSEG]	; g  save data segment
	;cmp	byte [Call_Flag],1
				; G  Is a call in progress?
	cmp	byte [Call_Flag],call_in_progress
	mov	byte [Call_Flag],0
				; G  Either way, reset flag
	pop	ds		; g  get data segment back
	jz	short INCALL	; G
	jmp	TCOMMAND	; chill out...
INCALL:
	jmp	DOCOM1

; =============== S U B	R O U T	I N E =======================================

	; 25/02/2023
noswit:
	push	di		; Save di
	mov	di,81h		; di = ptr to command args
	mov	si,80h		; Get address of length of command args
	lodsb			; Load length
	mov	cl,al		; Move length to cl
	xor	ch,ch		; Zero ch
	mov	al,[cs:SWITCHAR] ; al = switch character
	;cmp	al,0		; Turn off ZF
	; 25/02/2023
	and	al,al
	repne	scasb		; Scan for a switch character and return
	pop	di		;  with ZF set if one was found
	retn

; ---------------------------------------------------------------------------

	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h

EXTERNAL:
	call	test_append	; check to see if append installed
	jz	short NOT_BARRYF
				; no - truly external command
	jmp	APPEND_INTERNAL	; yes - go to Barryf code

NOT_BARRYF:
	mov	byte [cs:FILTYP],0
	mov	dl,[cs:SPECDRV]
	mov	[cs:IDLEN],dl
	mov	byte [cs:ROM_CALL],0
	push	dx
	mov	dx,IDLEN
	call	ROM_SCAN
	pop	dx
	;jnc	short POSTSAVE
	jnc	short DO_SCAN
	inc	byte [cs:ROM_CALL]
	;jmp	short POSTSAVE

	;nop
DO_SCAN:
POSTSAVE:
	mov	di,EXECPATH
	mov	byte [di],0	; Initialize to current directory
	
	cmp	byte [cs:ROM_CALL],0
	;jz	short RESEARCH
	; 25/02/2023
	;jmp	short NEOEXECUTE
	jnz	short NEOEXECUTE	

	;nop
RESEARCH:
	call	path_search	; find the mother (result in execpath)
	or	ax,ax		; did we find anything?
	;jz	short BADCOMJ45	; null means no (sob)
	; 25/02/2023
	jz	short BADCOM
	cmp	ax,4		; 04H and 08H are .exe and .com
				; fuckin' sixteen-bit machine ought
	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
				; DISPLACEMENT!!
	;;jmp	short NEOEXECUTE
	;jmp	short EXECUTE	
	; 25/02/2023
	jnl	short EXECUTE ; jge

	; 02H is .bat

	;nop
BATCOMJ:
	jmp	BATCOM

	; 25/02/2023
;BADCOMJ45:
	;jmp	short BADCOM

	;nop
EXECUTE:
NEOEXECUTE:
	call	IOSET

; MSDOS 6.0
;M051
; Previously LoadHigh was jumping to the execute label above. This was wrong
;because IOSET was getting invoked twice resulting in 2 sets of redirections.
;After a close, this would still leave one open active resulting in sharing
;errors on subsequent opens of the redirected file.

LH_EXECUTE:			;M051	
	mov	es,[TRAN_TPA]
	;mov	ah,DEALLOC ; 49h
	mov	ah,49h
	int	21h	; DOS -	2+ - FREE MEMORY
			; ES = segment address of area to be freed
				; Now running in "free" space
	mov	es,[RESSEG]
	inc	byte [es:ExtCom] ; Indicate external command
	mov	byte [es:RestDir],0 
				; Since USERDIR1 is in transient, insure
				; this flag value for re-entry to COMMAND
	; MSDOS 6.0
	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
	;mov	cx,LENMSGORPATHBUF
	mov	cx,80
	cld
	rep	movsb		; copy program pathname to resident

	; MSDOS 3.3 (& MSDOS 6.0)
	mov	di,FCB ; 5Ch
	mov	si,di
	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
	mov	cl,82 ; 25/02/2023
	rep	movsw		; Transfer parameters to resident header
	
	; 25/02/2023
	;mov	dx,EXECPATH  ; MSDOS 3.3
	; MSDOS 6.0 (& 5.0)
	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
	mov	dx,SafePathBuffer
	push	es
	pop	ds

	;mov	bx,offset RESGROUP:EXEC_BLOCK
	mov	bx,Exec_Block  ; = offset EnvirSeg
	;mov	ax,EXEC*256 ; 4B00h
	mov	ax,4B00h
	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
	jz	short OK_EXEC
	jmp	ROM_EXEC

OK_EXEC:

; we are now running in free space. Anything we do from here on may get
; trashed. Move the stack (also in free space) to allocated space because
; since EXEC restores the stack, somebody may trash what is on the stack.

	mov	cx,es
	mov	ss,cx
	mov	sp,RStack
	; MSDOS 3.3
	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
	; 25/02/2023
	; MSDOS 6.0
	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident

; ---------------------------------------------------------------------------

	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
BADCOM:
	push	cs
	pop	ds
	mov	dx,BADNAM_PTR
cerror:		
	call	std_eprintf
	jmp	TCOMMAND

; =============== S U B	R O U T	I N E =======================================

; Prescan converts the input buffer into a canonicalized form.
; All redirections and pipes are removed.

	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h

PRESCAN:
	xor	cx,cx
	mov	es,[RESSEG]
	mov	si,COMBUF+2
	mov	di,si
COUNTQUOTES:
	lodsb			; get a byte
	cmp	al,22h	; '"'	; is it a quote?
	jne	short COUNTEND	; no, try for end of road
	inc	ch		; bump count
	jmp	short COUNTQUOTES
				; go get next char
COUNTEND:
	cmp	al,0Dh	; 13	; end of road?
	jne	short COUNTQUOTES
				; no, go back for next char
	; 26/02/2023
	; MSDOS 5.0 (& 6.0)
	push	cx		; save count
	mov	si,di		; restore pointer to begining
KanjiScan:
	lodsb			; get a byte
	call	testkanj	; is it a leadin byte
	jz	short KanjiQuote
				; no, check for quotes
	mov	ah,al		; save leadin
	lodsb			; get trailing byte
	cmp	ax,2020h
	;cmp	ax,DB_SPACE	; is it Kanji space
	jne	short KanjiScan	; no, go get next
	mov	word [si-2],2020h
				; replace with spaces
	jmp	short KanjiScan	; go get next char
	
KanjiQuote:
	cmp	al,22h	; '"'	; beginning of quoted string
	jne	short KanjiEnd	; no, check for end
	dec	ch		; drop count
	jz	short KanjiScan	; if count is zero, no quoting
KanjiQuoteLoop:
	lodsb			; get next byte
	cmp	al,22h	; '"'	; is it another quote
	jne	short KanjiQuoteLoop
				; no, get another
	dec	ch		; yes, drop count
	jmp	short KanjiScan	; go get next char
KanjiEnd:
	cmp	al,13 ; 0Dh	; end of line character?
	jne	short KanjiScan	; go back to beginning
	pop	cx		; get back original count
	; 26/04/2023
	mov	si,di		; restore pointer to beginning
	
	; MSDOS 3.3 (& MSDOS 6.0)
PRESCANLP:
	lodsb
	; 26/02/2023
	call	testkanj
	jz	short NOTKANJ6
	; MSDOS 6.0
	mov	[di],al
	inc	di		; fake STOSB into DS
	lodsb			; grab second byte
	mov	[di],al		; fake stosb into DS
	inc	cl
	inc	cl
	jmp	short PRESCANLP

NOTKANJ6:
	; MSDOS 3.3 (& MSDOS 6.0)
	cmp	al,'"'	; 22h	; " character
	jne	short TRYGREATER
	dec	ch
	jz	short TRYGREATER
QLOOP:
	mov	[di],al
	inc	di
	inc	cl
	lodsb
	cmp	al,'"'		; " character
	jne	short QLOOP
	dec	ch
TRYGREATER:
	cmp	al,'>' ; 3Eh
	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
	;;cmp	al,[RABRACKET]	; MSDOS 3.3
	jne	short NOOUT

; We have found a ">" char. We need to see if there is another ">"
; following it.

	cmp	[si],al
	jne	short NOAPPND
	lodsb
	inc	byte [es:Re_Out_App] ; Flag >>
NOAPPND:
; Now we attempt to find the file name. First, scan off all whitespace

	call	scanoff

	; 26/02/2023
	; MSDOS 6.0
	cmp	al,'<' ; 3Ch
	;cmp	al,labracket	;AN040; was there no filename?
	je	short REOUT_ERRSET
				;AN040; yes - set up error
	; MSDOS 3.3 (& MSDOS 6.0)
	cmp	al,0Dh
	jnz	short GOTREOFIL

; There was no file present. Set us up at end-of-line.

REOUT_ERRSET:			;AN040; set up for an error
	mov	byte [di],0Dh	; Clobber first ">"
	mov	word [es:Re_OutStr],9
				; Cause an error later
	jmp	PRESCANEND

GOTREOFIL:
	push	di
	;mov	di,offset RESGROUP:RE_OUTSTR
	mov	di,Re_OutStr
	mov	bx,di
	push	es

	; 26/02/2023
	; MSDOS 6.0
SETREOUTSTR:			; Get the output redirection name
				; MSKK06 07/14/89
	push	cx		; save cx
	mov	cx,64+13	; CX = max string length
SETREOUTSTR_LOOP:
	lodsb
	cmp	al,0Dh
	je	short GOTRESTR_J
	call	DELIM
	jz	short GOTRESTR_J
	cmp	al,[SWITCHAR]
	je	short GOTRESTR_J
	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
	je	short PIPEERRSYNJ5_J
				;AN033; Yes - get out quick - or system crashes
	cmp	al,'<' ; 3Ch
	;cmp	al,labracket	;AN002; Is char for input redirection
	je	short ABRACKET_TERM
				;AN002; yes - end of string
	cmp	al,'>' ; 3Eh
	;cmp	al,rabracket	;AN002; Is char for output redirection
	jne	short NO_ABRACKET
				;AN002; no - not end of string
ABRACKET_TERM:			;AN002; have end of string by < or >
	dec	si		;AN002; back up over symbol
	mov	al,20h ; BLANK	;AN002; show delimiter as char
GOTRESTR_J:
	pop	cx		; MSKK06 07/14/89
	jmp	short GOTRESTR	;AN002; go process it
NO_ABRACKET:			;AN002; NOT AT END OF STRING
	stosb			; store it into resgroup
	loop	SETREOUTSTR_LOOP
				; MSKK06 07/14/89
	jmp	short GOTRESTR_J
PIPEERRSYNJ5_J:
	pop	cx		; recover CX
	jmp	short PIPEERRSYNJ5

	; 26/02/2023
;	; MSDOS 3.3
;SETREOUTSTR_LOOP:		; Get the output redirection name
;	lodsb
;	cmp	al,0Dh
;	jz	short GOTRESTR
;	call	DELIM
;	jz	short GOTRESTR
;	cmp	al,[SWITCHAR]
;	je	short GOTRESTR
;	cmp	al,'"'
;	jne	short NO_ABRACKET
;	dec	ch
;NO_ABRACKET:
;	stosb
;	jmp	short SETREOUTSTR_LOOP

NOOUT:
	; 26/02/2023
	; MSDOS 3.3 (& MSDOS 6.0)
	cmp	al, '<' ; 3Ch
	;cmp	al,labracket	; MSDOS 6.0
	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
	jne	short CHKPIPE
	mov	bx,si		; Save loc of "<"
	call	scanoff
	; MSDOS 6.0
	cmp	al,'>' ; 3Eh
	;cmp	al,rabracket	;AN040; was there no filename?
	je	short REIN_ERRSET ;AN040; yes - set up error
	; MSDOS 3.3 (& MSDOS 6.0)
	cmp	al,0Dh
	jne	short GOTREIFIL
REIN_ERRSET:			;AN040; set up for error
	mov	byte [di],0Dh	; Clobber "<"
	mov	word [RE_INSTR],9 
				; Cause an error later
	jmp	short PRESCANEND
GOTREIFIL:
	push	di
	mov	di,RE_INSTR
	mov	bx,di
	push	es
	push	cs
	pop	es		; store in TRANGROUP
	; 26/04/2023
	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
				; Get the input redirection name
CHKPIPE:
	mov	ah,al
	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	cmp	ah,'|' ; 7Ch
	;cmp	ah,ALTPIPECHR ; 7Ch
	;je	short ISPIPE3
	;; MSDOS 6.0
	;cmp	ah,'|' ; 7Ch
	;;cmp	al,vbar ; 7Ch
	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
	jne	short CONTPRESCAN
ISPIPE3:
; Only push the echo flag if we are entering the pipe for the first time.

	cmp	byte [es:PipeFlag],0
	jne	short NOECHOPUSH
	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
NOECHOPUSH:
	inc	byte [es:PipeFlag]
	call	scanoff
	cmp	al,0Dh
	je	short PIPEERRSYNJ5
	; 26/02/2023
	cmp	al,'|' ; 7Ch
	;cmp	al,ALTPIPECHR ; 7Ch
	;je	short PIPEERRSYNJ5
	;; MSDOS 6.0
	;cmp	al,'|' ; 7Ch
	;;cmp	al,vbar ; 7Ch
	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
	jne	short CONTPRESCAN

PIPEERRSYNJ5:
	push	es
	pop	ds
	jmp	PIPEERRSYN

; Trailing :s are allowed on devices. Check to be sure that there is more
; than just a : in the redir string.

GOTRESTR:
	xchg	ah,al
	mov	al,':' ; 3Ah
	sub	bx,di		; compute negative of number of chars
	cmp	bx,-1		; is there just a :?
	je	short NOTRAILCOL ; yep, don't change
	cmp	[es:di-1],al	; Trailing ':' OK on devices
	jne	short NOTRAILCOL
	dec	di		; Back up over trailing ':'
NOTRAILCOL:
	xor	al,al
	stosb			; NUL terminate the string
	pop	es
	pop	di		; Remember the start
CONTPRESCAN:
	mov	[di],ah		; "delete" the redirection string
	inc	di
	cmp	ah,0Dh
	je	short PRESCANEND
	inc	cl
	jmp	PRESCANLP
PRESCANEND:
	cmp	byte [es:PipeFlag],0
	jz	short ISNOPIPE

	; 26/02/2023
	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
	;;			; (EndInit+160]
	;mov	di,offset RESGROUP:PIPESTR
	mov	di,PipeStr	; RESGROUP:EndInit+160
	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
	;;mov	[es:3BEh],di	; [es:EndInit+158]
	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
	
	mov	si,COMBUF+2
	call	scanoff
PIPESETLP:			; Transfer the pipe into the resident
	lodsb			; pipe buffer
	stosb
	cmp	al,0Dh
	jnz	short PIPESETLP
ISNOPIPE:
	mov	[COMBUF+1],cl
	cmp	byte [es:PipeFlag],0
	push	cs
	pop	es
	retn

; =============== S U B	R O U T	I N E =======================================

	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
cmd_copy:
	mov	si,COMBUF+2
	call	scanoff		; advance past separators...
	add	si,[PathPos]
	mov	di,81h
	xor	cx,cx
cmdcopy:
	lodsb
	stosb
	cmp	al,0Dh
	je	short copy_done
	inc	cx
	jmp	short cmdcopy
copy_done:
	mov	[80h],cl
	retn

; =============== S U B	R O U T	I N E =======================================

	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
test_append:
	mov	bx,COMBUF	; barry can address
	mov	si,IDLEN	; address command name, DS already set 	
	mov	dx,-1
	mov	ax,0AE00h
	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
			; - INSTALLABLE	COMMAND	- INSTALL CHECK
			; DX = FFFFh,[BX -> command line
			; Return: AL = FFh if this command is a TSR extension 
			;		   to COMMAND.COM
			; AL = 00h if the command should be executed as	usual
	;cmp	al,0
	or	al,al ; 25/02/2023
	retn

	; 25/02/2023
	; INT 2Fh
	; 	AX = AE00h
	; entry:
	; 	DX = magic value FFFFh
	; 	CH = FFh
	; 	CL = length of command line tail
	; 	DS:BX -> command line buffer  -- (offset COMBUF)
	; 	DS:SI -> command name buffer  -- (offset IDLEN)
	; return:
	;	AL = FFh if this command is a TSR extension to COMMAND.COM
	;	AL = 00h if the command should be executed as usual
	;
	; Format of COMMAND.COM command line buffer:
	;	Offset  Size    Description
	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
	;	N BYTEs command line text, terminated by 0Dh
	;
	; Format of command name buffer:
	;	Offset  Size    Description
	;	00h     BYTE    length of command name
	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)

;============================================================================
; TMISC2.ASM, MSDOS 6.0, 1991
;============================================================================
; 05/10/2018 - Retro DOS v3.0

;	More misc routines

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh

; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh

; =============== S U B	R O U T	I N E =======================================

SETPATH:

; ENTRY PathPos = ptr to string
;       PathCnt = length of string
;
; EXIT  PathPos = ptr to string after pathname
;       PathCnt = length of rest of string
;       DX = ptr to pathname in string, made ASCIIZ
;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
;
;       A null character is dropped at the end of the pathname. If the
;       character in that spot previously was CR, it is copied into the
;       following byte. So there must be at least two two character 
;       positions in the buffer following the pathname.

	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; 11/06/2023
	; MSDOS 6.0
	;mov	ax,[PathCnt]	;AC000; get length of string
	;mov	si,[PathPos]	;AC000; get start of source buffer

	; 26/02/2023
	; MSDOS 3.3
	;mov	si,80h
	;lodsb
	;xor	ah,ah
	;mov	[PATCNT],ax
	;mov	[PATHPOS],si
GETPATH:
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	byte [DestInfo],0
	mov	byte [DestIsDir],0
	mov	si,[PathPos]	; SI = ptr to string
	mov	cx,[PathCnt]	; CX = string length
	mov	dx,si		; DX = ptr to string
	jcxz	PATHDONE	; string length is zero, we're done
	push	cx		; save string length
	push	si		; save ptr to string
	call	SWITCH

;       After Switch, SI has been scanned past any switches, and
;       switches that COMMAND intrinsically recognizes are recorded in AX.

	mov	[PathSw],ax	; PathSw = switch occurrence mask
	pop	bx		; BX = ptr to original string
	sub	bx,si		; BX = -(# chars scanned by Switch)
	pop	cx		; CX = string length
	add	cx,bx		; CX = string length from current SI
	mov	dx,si		; DX = ptr to current string
SKIPPATH:
	; 26/02/2023
	; MSDOS 6.0
	mov	byte [KPARSE],0
SKIPPATH2:
	jcxz	PATHDONE	; string length is zero, we're done
	dec	cx		; CX = length left after next char
	lodsb			; AL = next char of string
				; SI = ptr to char after this one
	; 26/02/2023
	call	testkanj
	jz	short TESTPPSEP
	dec	cx
	inc	si
	inc	byte [KPARSE]
	jmp	short SKIPPATH2
TESTPPSEP:
	call	pathchrcmp	; compare AL to path delimiter char
	jnz	short TESTPMETA	; it's not a path delim
	inc	byte [DestIsDir]
				; DestIsDir = 1, signalling path char
TESTPMETA:
	cmp	al,'?'
	jne	short TESTPSTAR	; char is not '?'
	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
TESTPSTAR:
	cmp	al,'*'
	;cmp	al,[STAR] ; MSDOS 3.3	
	jne	short TESTPDELIM ; char is not '*'
	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
TESTPDELIM:
	call	DELIM		; compare AL to all delimiters
	jz	short PATHDONEDEC ; delimiter found, back up & leave
	cmp	al,[SWITCHAR]
	jne	short SKIPPATH	; char isn't switch, go get next char
PATHDONEDEC:
	dec	si		; SI = ptr to char after pathname
PATHDONE:
	xor	al,al		; AL = NULL
	xchg	al,[si]		; place NULL after pathname
	inc	si		; SI = ptr to byte after NULL
	cmp	al,0Dh		; were we at end of line?
	jne	short NOPSTORE	; not EOL, finish up
	mov	[si],al		; save EOL after NULL
NOPSTORE:
	mov	[PathPos],si	; PathPos = ptr to char after NULL
	mov	[PathCnt],cx	; PathCnt = length of string left
SETPATH_RETN:
	retn

; ---------------------------------------------------------------------------

PGETARG:
	mov	si,80h
	lodsb
	or	al,al
	jz	short SETPATH_RETN
	call	PSCANOFF
	cmp	al,0Dh
	retn

; ---------------------------------------------------------------------------

PSCANOFF:
	lodsb
	call	DELIM
	jnz	short PSCANOFFD
	cmp	al,';' ; 3Bh
	jne	short PSCANOFF	; ';' is not a delimiter
PSCANOFFD:
	dec	si		; Point to first non-delimiter
	retn

; =============== S U B	R O U T	I N E =======================================

	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
IOSET:
	; ALL REGISTERS PRESERVED
	push	ds
	push	dx
	push	ax
	push	bx
	push	cx
	mov	ds,[cs:RESSEG]
	cmp	byte [PipeFlag],0
	jne	short NOREDIR
	test	byte [IfFlag],0FFh
	jnz	short NOREDIR
	call	TESTDOREIN
	call	TESTDOREOUT
NOREDIR:
	pop	cx
	pop	bx
	pop	ax
	pop	dx
	pop	ds
	retn

; =============== S U B	R O U T	I N E =======================================

	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
TESTDOREOUT:
	cmp	byte [Re_OutStr],0
	;je	short NOREOUT  ; MSDOS 3.3
	; 26/02/2023
	jne	short REOUTEXISTS
	jmp	NOREOUT 
REOUTEXISTS:
	cmp	byte [Re_Out_App],0
	je	short REOUTCRT

	mov	dx,Re_OutStr

	; 26/02/2023
	; MSDOS 6.0
	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
	mov	ax,3D02h
	; MSDOS 3.3
	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
	
	; MSDOS 3.3 (& MSDOS 6.0)
	push	ax
	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 1 - write
	pop	bx
	jc	short OpenWriteError

	; 26/02/2023
	; MSDOS 6.0
	mov	bx,ax
	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
	mov	ax,4400h
	int	21h			;AN035;
			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
			; BX = file or device handle
	test	dl,80h
	;test	dl,devid_ISDEV		;AN035; Is it a device?
	jnz	short SET_REOUT		;AN035; Yes, don't read from it
	
	;mov	ax,(LSEEK SHL 8) OR 2
	mov	ax,4202h
	mov	cx,-1			;AC011; MOVE TO EOF -1
	mov	dx,cx			;AC011;
	int	21h
			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from end of file
	push	cs			;AN011; Get transient seg to DS
	pop	ds			;AN011;
	
	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
	mov	ax,3F00h
	mov	cx,1			;AN011;  file into one_char_val
	mov	dx,One_Char_Val		;AN011;
	int	21h			;AN011;
			; DOS - 2+ - READ FROM FILE WITH HANDLE
			; BX = file handle, CX = number of bytes to read
			; DS:DX -> buffer
	jc	short OpenWriteError	;AN011; If error, exit
	cmp	ax,cx			;AN017; Did we read 1 byte?
	jnz	short reout_0_length	;AN017; No - file must be 0 length
	
	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
	mov	ds,[RESSEG]		;AN011; Get resident segment back
	jne	short SET_REOUT		;AN011; No, just continue
	
	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
	mov	ax,4201h
	mov	cx,-1			;AN011; LSEEK back one byte
setreout_p:	; 26/02/2023
	mov	dx,cx			;AN011;
	int	21h			;AN011;
	jmp	short SET_REOUT
reout_0_length: 			;AN017; We have a 0 length file
	; ds = cs ; 26/02/2023
	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
					;AN017; Get resident segment back
	; 26/02/2023
	mov	ds,[RESSEG]
	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
	mov	ax,4200h
	xor	cx,cx			;AN017; Offset is 0
	;mov	dx,cx			;AN017;
	;int	21h			;AN017;
	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
	; 26/02/2023
	jmp	short setreout_p

	; 26/02/2023
	; MSDOS 3.3
	;xor	dx,dx
	;xor	cx,cx
	;mov	bx,ax
	;mov	ax,(LSEEK<<8)|2 ; 4202h
	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
	;		; AL = method: offset from end of file
	;jmp	short SET_REOUT
		
	; MSDOS 3.3 (& MSDOS 6.0)
OpenWriteError:	
	;cmp	ax,5
	cmp	ax,ERROR_ACCESS_DENIED
	stc
	;;je	short REDIRERR ; MSDOS 3.3
	; 26/02/2023
	;jnz	short REOUTCRT
	;jmp	REDIRERR
	je	short REDIRERR

REOUTCRT:	
	mov	dx,Re_OutStr
	xor	cx,cx
	;mov	ah,CREAT ; 3Ch
	mov	ah,3Ch
	push	ax
	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
			; CX = attributes for file
			; DS:DX	-> ASCIZ filename (may include drive and path)
	pop	bx
	;jc	short REDIRERR ; MSDOS 3.3
	; 26/02/2023
	;jnc	short NOREDIRERR
	;jmp	REDIRERR
	jc	short REDIRERR
	
NOREDIRERR:
	mov	bx,ax
SET_REOUT:

; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
; spot. We invalidate the new JFN we got.

	mov	al,0FFh
	;xchg	al,[bx+18h]
	xchg	al,[bx+PDB.JFN_TABLE]
	mov	[PDB.JFN_TABLE+1],al
NOREOUT:
IOSET_RETN:	; 17/04/2023
	retn

; =============== S U B	R O U T	I N E =======================================

	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
TESTDOREIN:
	cmp	byte [cs:RE_INSTR],0
	jz	short IOSET_RETN
	push	ds
	push	cs
	pop	ds
	mov	dx,RE_INSTR
	;mov	ax,OPEN*256 ; 3D00h
	mov	ax,3D00h
	mov	bx,ax
	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 0 - read
	pop	ds

	jc	short REDIRERR

	mov	bx,ax
	mov	al,0FFh

; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
; spot. We invalidate the new JFN we got.

	;xchg	al,[bx+18h]
	xchg	al,[bx+PDB.JFN_TABLE]
	mov	[PDB.JFN_TABLE],al
	retn

; ---------------------------------------------------------------------------

; We had some kind of error on the redirection. Figure out what the
; appropriate message should be; BX has the system call that failed

REDIRERR:
	push	cs
	pop	ds
	call	TriageError  ; MSDOS 6.0
	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3

; At this point, we have recognized the network-generated access denied error.
; The correct message is in DX

	cmp	ax,65
	je	short _CERRORJ	;AC000; just issue message returned
	cmp	bh,OPEN ; 3Dh
	je	short OpenError
	mov	dx,FULLDIR_PTR
_CERRORJ:
	jmp	cerror

OpenError:
; The system call was an OPEN. Report either file not found or path not found.

	; 26/02/2023
	; MSDOS 6.0
	;mov	byte [cs:msg_disp_class],1
	mov	byte [cs:msg_disp_class],ext_msg_class
				;AN000; set up extended error msg class
	mov	dx,extend_buf_ptr
				;AC000; get extended message pointer
	mov	[cs:extend_buf_ptr],ax
				;AN000; get message number in control block
	jmp	cerror

	; 26/02/2023
	; MSDOS 3.3
	;mov	dx,FNOTFOUNDPTR
	;;cmp	ax,2
	;cmp	ax,ERROR_FILE_NOT_FOUND
	;je	short _CERRORJ
	;mov	dx,ACCDENPTR
	;;cmp	ax,5 ; Access denied error
	;cmp	ax,ERROR_ACCESS_DENIED
	;je	short _CERRORJ
	;	; ERROR_PATH_NOT_FOUND
	;mov	dx,PNOTFOUNDPTR
	;jmp	CERROR

; =============== S U B	R O U T	I N E =======================================

; Compute length of string (including NUL) in DS:SI into CX. Change no other
; registers

	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
dstrlen:
	push	ax
	xor	cx,cx
	cld
dloop:
	lodsb
	inc	cx
	or	al,al
	jnz	short dloop
	sub	si,cx
	pop	ax
TRIAGEERR_RETN:
	retn

; =============== S U B	R O U T	I N E =======================================

;Break	<Extended error support>

TriageError:  ; MSDOS 6.0

; TriageError will examine the return from a carry-set system call and
; return the correct error if applicable.
;
;   Inputs:	outputs from a carry-settable system call
;		No system calls may be done in the interrim
;   Outputs:	If carry was set on input
;		   carry set on output
;		   DX contains trangroup offset to printf message
;		else
;		   No registers changed

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh

; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h

GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
	pushf
	push	bx
	push	cx
	push	si
	push	di
	push	bp
	push	es
	push	ds
	push	ax
	push	dx
	mov	ah,59h
	;mov	ah,GETEXTENDEDERROR
	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
			; BX = version code (0000h for DOS 3.x)
	pop	cx
	pop	bx		; restore original AX
	mov	dx,ACCDEN_PTR
	cmp	ax,65		; network access denied?
	je	short NoMove	; Yes, return it.
	mov	ax,bx
	mov	dx,cx
NoMove:
	pop	ds
	pop	es
	pop	bp
	pop	di
	pop	si
	pop	cx
	pop	bx
	popf
	retn

; =============== S U B	R O U T	I N E =======================================

	; Far call from resident portion/segment of COMMAND.COM

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h

	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
Triage_Init:
	call	TriageError	 ; MSDOS 6.0
	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
	retf

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 MOVE_TO_SRCBUF
; *
; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
; *		 terminating 0 to 0dH.	Set PATHCNT to length of
; *		 string.  Set PATHPOS to start of SRCBUF.
; *
; * INPUT:	 DS:SI points to ASCIIZ string
; *		 ES    points to TRANGROUP
; *
; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
; *		 PATHCNT set to length of string
; *		 PATHPOS set to start of SRCBUF
; *		 CX,AX	 changed
; *
; ****************************************************************

	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
Move_To_SrcBuf:
	push	si			;AN000;  save si,di
	push	di			;AN000;
	push	cx			;AN000;
	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
	xor	cx,cx			;AN000; clear cx for counint
	mov	ax,cx			;AN000; clear ax
	push	di			;AN000; save start of srcbuf
	lodsb				;AN000; get a character from DS:SI
mts_get_chars:				;AN000;
	;cmp	al,0			;AN000; was it a null char?
	and 	al,al ; al = 0 ?
	jz	short mts_end_string	;AN000; yes - exit
	stosb				;AN000; no - store it in srcbuf
	inc	cx			;AN000; increment length count
	lodsb				;AN000; get a character from DS:SI
	jmp	short mts_get_chars	;AN000; go check it
mts_end_string: 			;AN000; we've reached the end of line
	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
	mov	al,0Dh
	stosb				;AN000;
	pop	di			;AN000; restore start of srcbuf
	push	cs			;AN000; set DS to local segment
	pop	ds			;AN000;
	mov	[PathCnt],cx		;AN000; set patchcnt to length count
	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
	pop	cx			;AN000; restore cx,di,si
	pop	di			;AN000;
	pop	si			;AN000;
	retn				;AN000; exit

;============================================================================
; TPIPE.ASM, MSDOS 6.0, 1991
;============================================================================
; 03/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h

; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h

; =============== S U B	R O U T	I N E =======================================

	; 26/02/2023
SINGLETEST:
	push	ds
	mov	ds,[cs:RESSEG]
	cmp	word [SingleCom],0
	jz	short TESTDONE
	cmp	word [SingleCom],0EFFFh
TESTDONE:
	pop	ds
	retn

; =============== S U B	R O U T	I N E =======================================

	; 26/02/2023
SetRest1:
	mov	al,1

; ---------------------------------------------------------------------------

SETREST:
	push	ds
	mov	ds,[RESSEG]
	mov	[RestDir],al
	pop	ds
	retn

; =============== S U B	R O U T	I N E =======================================

; Note that we need to handle the same thing that RestDir handles: the
; requirement that we try only once to restore the user's environment after
; and INT 24 or the like. If the condition that causes the INT 24 does not
; disappear, we just give up.

	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
PIPEDEL:
	push	ds
	push	dx
	mov	ds,[cs:RESSEG]
	;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
			; Pipe1 = offset RESGROUP:EndInit
	mov	dx,Pipe1	; Clean up in case ^C
	;mov	ah,Unlink ; 41h 
	mov	ah,41h
	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
			; DS:DX	-> ASCIZ pathname of file to delete 
			;		(no wildcards allowed)

	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
			; Pipe2 = offset RESGROUP:EndInit+79
	mov	dx,Pipe2
	;mov	ah,Unlink ; 41h
	mov	ah,41h
	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
			; DS:DX	-> ASCIZ pathname of file to delete 
			;		(no wildcards allowed)
	pop	dx
	call	PipeOff
	mov	byte [PipeFiles],0
	pop	ds
	retn

; ---------------------------------------------------------------------------

	; 26/02/2023
PIPEERRSYN:
	mov	dx,SYNTMES_PTR
	call	PIPEDEL
	push	cs
	pop	ds
	jmp	cerror

; ---------------------------------------------------------------------------

	; 26/02/2023
PIPERR:
	pushf
	call    TriageError
	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
	push	ax		; Save results from TriageError
	push	dx
	mov	dx,PIPEEMES_PTR
	call	PIPEDEL
	push	cs
	pop	ds
	call	std_eprintf
	pop	dx		; Restore results from TriageError
	pop	ax
	popf
	cmp	ax,65
	jne	short TCOMMANDJ
	jmp	cerror

TCOMMANDJ:
	jmp	TCOMMAND

; ---------------------------------------------------------------------------

	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
PIPEPROCSTRT:
	mov	ds,[RESSEG]
	inc	byte [PipeFiles] ; Flag that the pipe files exist

	; MSDOS 6.0
	push	es
	push	di
	push	ds
	push	si
	
	push	ds
	push	es
	pop	ds			;ds = TRANGROUP
	mov	si,TempVarName		;ds:si = "TEMP="

;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
;so the routine is not really general

	call	find_name_in_environment
					;es:di points at path
	pop	ds			;ds = DATARES again
	jc	short no_temp_path
	
	push	ds
	push	es
	pop	ds
	pop	es			;swap ds and es
	mov	si,di			;ds:si points at path
	
	call	skip_white		;skip white space chars

;This copies the path into both buffers -- Pipe1 & Pipe2

	call	copy_pipe_path		;copy the pipe path
	
;Check if the TEMP path is valid

	push	es
	pop	ds			;ds = DATARES
	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
	;mov	dx,320h ; MSDOS 5.0 - offset EndInit
	mov	dx,Pipe1
	;mov	ax,(CHMOD shl 8) or 0
	mov	ax,4300h
	int	21h
	jc	short no_temp_path
	
	test	cx,10h			;is it a directory?
	jnz	short no_temp_path	;yes, continue (carry clear)
	
	stc				;no, indicate fail
no_temp_path:
	pop	si
	pop	ds
	pop	di
	pop	es
	jnc	short crt_temp		;path found, create tempfiles

	; 27/02/2023
	; MSDOS 3.3
	;mov	ah,GET_DEFAULT_DRIVE ; 19h
	;				; Get current drive
	;int	21h ; DOS - GET DEFAULT DISK NUMBER
	;add	al,[cs:CAPITAL_A]
	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
	;mov	bx,PIPE1
	;mov	[bx],al
	;xor	ah,ah			; nul terminate path names
	;mov	byte [PIPE1+3],ah
	;mov	byte [PIPE2+3],ah

	; MSDOS 6.0
;SR;
; We want to create temp files in the current directory rather than in the 
;root of the drive. This is because the number of files that can be present
;in the root directory is fixed, whereas it is not so in subdirectories.

	;mov	ah,'.'
	;mov	[Pipe1],ah	; = RESGROUP:EndInit
	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
	;xor	ah,ah
	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
	;mov	[Pipe2+1],ah		;create files in current dir
	; 27/02/2023
	mov	cx,002Eh
	mov	[Pipe1],cx
	mov	[Pipe2],cx
crt_temp:
	; MSDOS 6.0
	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
	;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
	mov	dx,Pipe1
	; MSDOS 3.3
	;mov	dx,bx
	
	; MSDOS 3.3 (& MSDOS 6.0)
	xor	cx,cx
	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
	mov	ah,5Ah
	int	21h
		; DOS -	3+ - CREATE UNIQUE FILE
		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
		; receive generated filename
		; CX = file attributes (only bits 0,1,2,5 may be set)
	jc	short PIPERR	; Couldn't create

	mov	bx,ax
	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
	mov	ah,3Eh
	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
	;;mov	dx,PIPE2
	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
	mov	dx,Pipe2
	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
	mov	ah,5Ah
	int	21h
		; DOS -	3+ - CREATE UNIQUE FILE
		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
		; receive generated filename
		; CX = file attributes (only bits 0,1,2,5 may be set)
	; 17/04/2023
	;jc	short PIPERR
	; 27/02/2023
	jnc	short pps1
	jmp	PIPERR
pps1:
	mov	bx,ax
	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
				; BX = file handle
	;call	near ptr TESTDOREIN ; Set up a redirection if specified
	call	TESTDOREIN
	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
	cmp	word [SingleCom],-1
	jne	short NOSINGP
	mov	word [SingleCom],0F000h ; Flag single command pipe
NOSINGP:
	jmp	short FIRSTPIPE

; ---------------------------------------------------------------------------

	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
PIPEPROC:
	and	byte [EchoFlag],0FEh  ; force current echo to be off
	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
	lodsb
	; 27/02/2023
	cmp	al,'|'		
	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
	;je	short ISPIPE1	; Yes
	;cmp	al,'|'
	;;cmp	al,[cs:VBAR]
	je	short ISPIPE1
	jmp	PIPEEND		; Pipe done
ISPIPE1:
	mov	dx,[InPipePtr]	; Get the input file name
	;mov	ax,OPEN*256 ; 3D00h
	mov	ax,3D00h
	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
			; DS:DX	-> ASCIZ filename
			; AL = access mode
			; 0 - read
PIPEERRJ:
	jnc	short NO_PIPEERR
	jmp	PIPERR		; Lost the pipe file
NO_PIPEERR:
	mov	bx,ax
	mov	al,0FFh
	;xchg	al,[bx+18h]
	xchg	al,[bx+PDB.JFN_TABLE]
	mov	[PDB.JFN_TABLE],al	; Redirect
FIRSTPIPE:
	mov	di,COMBUF+2
	xor	cx,cx
	cmp	byte [si],0Dh	; '|<CR>'
	jne	short PIPEOK1
PIPEERRSYNJ:
	jmp	PIPEERRSYN
PIPEOK1:
	;;;mov	al,[cs:VBAR]
	; 27/02/2023
	;;mov	al,vbar
	;mov	al,'|'
	;cmp	[si],al		; '||'
	;je	short PIPEERRSYNJ
	cmp	byte [si],'|'
	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
	je	short PIPEERRSYNJ
PIPECOMLP:
	lodsb
	stosb
	; 27/02/2023
	call	testkanj
	jz	short NOTKANJ5
	movsb
;  Added following 2 commands to the fix pipe bug.
	inc	cx		;AN000;  3/3/KK
	inc	cx		;AN000;  3/3/KK
	jmp	short PIPECOMLP
NOTKANJ5:
	cmp	al,0Dh
	je	short LASTPIPE
	inc	cx
	; 27/02/2023
	cmp	al,'|'
	;cmp	al,ALTPIPECHR
	;je	short ISPIPE2
	;;cmp	al,[cs:VBAR]
	;cmp	al,vbar
	jne	short PIPECOMLP
ISPIPE2:
	mov	byte [es:di-1],0Dh
	dec	cx
	;mov	[cs:COMBUF+1],cl
	; 27/02/2023
	mov	[es:COMBUF+1],cl
	dec	si
	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
	mov	[PipePtr],si		; On to next pipe element
			; mov [EndInit+158],si
	mov	dx,[OutPipePtr]
	push	cx
	xor	cx,cx
	;mov	ax,CREAT*256 ; 3C00h
	mov	ax,3C00h
	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
			; CX = attributes for file
			; DS:DX	-> ASCIZ filename (may include drive and path)
	pop	cx
	jc	short PIPEERRJ		; Lost the file
	mov	bx,ax
	mov	al,0FFh
	;xchg	al,[bx+18h]
	xchg	al,[bx+PDB.JFN_TABLE]
	mov	[PDB.JFN_TABLE+1],al
	xchg	dx,[InPipePtr]	; Swap for next element of pipe
	mov	[OutPipePtr],dx
	jmp	short PIPECOM
LASTPIPE:
	;mov	[cs:COMBUF+1],cl 
	; 27/02/2023
	mov	[es:COMBUF+1],cl
	dec	si
	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
		; mov [EndInit+158],si
	call	TESTDOREOUT	; Set up the redirection if specified
PIPECOM:
	push	cs
	pop	ds
	jmp	NOPIPEPROC	; Process the pipe element
PIPEEND:
	call	PIPEDEL
	cmp	word [SingleCom],0F000h
	jnz	short NOSINGP2
	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
NOSINGP2:
	jmp	TCOMMAND

; =============== S U B	R O U T	I N E =======================================

; Date and time are set during initialization and use
; this routines since they need to do a long return

	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
DATINIT:
	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
	push	es
	push	ds		; Going to use the previous stack
	mov	ax,cs		; Set up the appropriate segment registers
	mov	es,ax
	mov	ds,ax
	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
	mov	dx,INTERNATVARS
	mov	ax,3800h
	;mov	ax,INTERNATIONAL*256 ; 3800h
	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
			; get current-country info
			; DS:DX	-> buffer for returned info
	; 20/10/2018
	mov	word [81h],0Dh ; Want to prompt for date during initialization
	mov	byte [COMBUF],128 ; Init COMBUF
	mov	word [COMBUF+1],0D01h
	call	DATE
	call	CTIME
	pop	ds
	pop	es
	retf	; far return

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 DATE - Set system date
; *
; * FUNCTION:	 If a date is specified, set the system date,
; *		 otherwise display the current system date and
; *		 prompt the user for a new date.  If an invalid
; *		 date is specified, issue an error message and
; *		 prompt for a new date.  If the user enters
; *		 nothing when prompted for a date, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
	; 11/06/2023
DATE:
	mov	si,81h			; Accepting argument for date inline
	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
	xor	cx,cx			;AN000; clear counter for positionals
	xor	dx,dx			;AN000;
	call	cmd_parse		;AC000; call parser
	
	; 27/02/2023
	;cmp	ax,-1
	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
	;je	short PRMTDAT 		;AC000; yes - go ask for date
	;;cmp	ax,0
	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
	;;jne	short DATERR		;AN000; yes - go issue message
	; 26/04/2023
	;or	ax,ax ; ax = 0 ?
	;jnz	short DATERR
	;;jmp	short COMDAT		;AC000; we have a date
	; 11/06/2023
	inc	ax  ; cmp ax,-1
	jz	short PRMTDAT ; 0FFFFh -> 0
	dec	ax  ; cmp ax,0
	jnz	short DATERR ; 1 -> 0
	; ax = 0
	
	; 27/02/2023
COMDAT:
	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
	mov	dl,[DATE_DAY]		;AC000;  date function call.
	push	cx			;AC000; save date
	push	dx			;AC000;
	mov	cx,1			;AC000; set 1 positional entered
	xor	dx,dx			;AN029;
	call	cmd_parse		;AN029; call parser
	cmp	al,0FFh ; -1
	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
	pop	dx			;AC000; retrieve date
	pop	cx			;AC000;
	jnz	short DATERR		;AC000; extra stuff on line - try again
	; 26/04/2023
	;mov	ah,SET_DATE		;yes - set date
	mov	ah,2Bh
	int	21h
			; DOS - SET CURRENT DATE
			; DL = day, DH = month, CX = year
			; Return: AL = 00h if no error /= FFh if bad value sent to routine
	or	al,al
	jnz	short DATERR
date_end:
	retn

PRMTDAT:
	; Print "Current date is

	call	GetDate 		;AN000; get date for output
	xchg	dh,dl			;AN000; switch month & day
	mov	[CurDat_yr],cx		;AC000; put year into message control block
	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
	mov	dx,CurDat_Ptr		;AC000; set up message for output
	call	std_printf

;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block

GET_NEW_DATE:				;AN000;
	call	GETDAT			;AC000; prompt user for date
	
	; 11/06/2023
	;cmp	ax,0FFFFh ; -1
	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
	;je	short date_end		;AC000; yes - exit
	; 26/04/2023
	;;cmp	ax,0
	;;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
	;;;jnz	short DATERR		;AN000; yes - go issue message
	;; 27/02/2023
	;;jz	short COMDAT
	; 26/04/2023
	;and	ax,ax ; 0 ?
	;jz	short COMDAT

	; 11/06/2023
	inc	ax  ; cmp ax,-1
	jz	short date_end ; 0FFFFh -> 0
	dec	ax  ; cmp ax,0
	jz	short COMDAT ; 1 -> 0
	; ax > 0

;COMDAT:
;	....
DATERR:
	call	CRLF2			;AN028; print out a blank line
	mov	dx,BADDAT_PTR
	call	std_printf
	jmp	short GET_NEW_DATE	;AC000; get date again

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; TIME gets and sets the time

; ****************************************************************
; *
; * ROUTINE:	 TIME - Set system time
; *
; * FUNCTION:	 If a time is specified, set the system time,
; *		 otherwise display the current system time and
; *		 prompt the user for a new time.  If an invalid
; *		 time is specified, issue an error message and
; *		 prompt for a new time.  If the user enters
; *		 nothing when prompted for a time, terminate.
; *
; * INPUT:	 command line at offset 81H
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
	; 11/06/2023
CTIME:
	mov	si,81h			; Accepting argument for time inline
	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
	xor	cx,cx			;AN000; clear counter for positionals
	xor	dx,dx			;AN000;
	call	cmd_parse		;AC000; call parser
	
	; 27/02/2023
	;cmp	ax,-1
	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
	;je	short PRMTTIM 		;AC000; yes - prompt for time
	;;cmp	ax,0
	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
	;;jne	short TIMERR		;AN000; yes - go issue message
	;and	ax,ax ; ax = 0 ?
	;jnz	short TIMERR
	;;jmp	short COMTIM		;AC000; we have a time
	; 11/06/2023
	inc	ax  ; cmp ax,-1
	jz	short PRMTTIM ; 0FFFFh -> 0
	dec	ax  ; cmp ax,0
	jnz	short TIMERR ; 1 -> 0
	; ax = 0
	
	; 27/02/2023
COMTIM:
	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
	mov	dh,[TIME_SECONDS]	;AC000;  time function call
	mov	dl,[TIME_FRACTION]	;AC000;
	push	cx			;AC000; save time
	push	dx			;AC000;
	mov	cx,1			;AC000; set 1 positional parm entered
	xor	dx,dx			;AN029;
	call	cmd_parse		;AN029; call parser
	cmp	al, -1
	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
	pop	dx			;AC000; retieve time
	pop	cx			;AC000;
	jnz	short TIMERR		;AC000; extra stuff on line - try again
SAVTIM:
	;mov	ah,SET_TIME
	mov	ah,2Dh
	int	21h
	or	al,al
	jnz	short TIMERR		;AC000; if an error occured, try again
time_end:
	retn

PRMTTIM:
	;Printf "Current time is ... "

	;mov	ah,Get_Time		;AC000; get the current time
	mov	ah,2Ch
	int	21h			;AC000;   Get time in CX:DX
	xchg	ch,cl			;AN000; switch hours & minutes
	xchg	dh,dl			;AN000; switch seconds & hundredths
	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
	mov	dx,CurTim_Ptr		;AC000; set up message for output
	call	std_printf

;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block

GET_NEW_TIME:
	call	GETTIM			;AC000;
	
	; 11/06/2023
	;cmp	ax,-1
	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
	;je	short time_end		;AC000;
	;;cmp	ax,0
	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
	;;jne	short TIMERR		;AN000; yes - go issue message
	;or	ax,ax  ; ax = 0 ?
	;;jnz	short TIMERR
	; 27/02/2023
	;jz	short COMTIM

	; 11/06/2023
	inc	ax  ; cmp ax,-1
	jz	short time_end ; 0FFFFh -> 0
	dec	ax  ; cmp ax,0
	jz	short COMTIM ; 1 -> 0
	; ax > 0

;COMTIM:
;	....
TIMERR:
	call	CRLF2			;AN028; print out a blank line
	mov	dx,BadTim_Ptr
	call	std_printf		; Print error message
	jmp	short GET_NEW_TIME	;AC000; Try again

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; Set the special flag in the INIT flag to the value in CX.

	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
SetInitFlag:
	mov	ds,[RESSEG]

	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
	;and	byte [InitFlag],0FDh
	or	byte [InitFlag],cl
	push	cs
	pop	ds
	retn

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
PipeOff:
	push	ds
	push	ax
	mov	ds,[cs:RESSEG]
	xor	al,al
	xchg	[PipeFlag],al
	or	al,al
	jz	short PipeOffDone
	shr	byte [EchoFlag],1
PipeOffDone:
	pop	ax
	pop	ds
	retn

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
PRINT_TIME:
	;mov	ah,Get_Time
	mov	ah,2Ch
	int	21h			; Get time in CX:DX

	push	es
	push	cs
	pop	es
	xchg	ch,cl			;AN000; switch hours & minutes
	xchg	dh,dl			;AN000; switch seconds & hundredths
	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
	mov	dx,promtim_ptr		;AC000; set up message for output
	call	std_printf

;AD061; mov	word [cs:PromTim_hr_min],0
					;AC000; reset hour, minutes, seconds, and hundredths
;AD061; mov	word [cs:PromTim_Sec_hn],0
					;AC000;  pointers in control block
	pop	es
	retn

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 GETDAT - Prompt user for date
; *
; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new date"
; *		 message with the proper date format. COMBUF
; *		 is reset to get a date from the command line.
; *		 The PARSE_DATE blocks are then reset and the
; *		 PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************

	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
GETDAT:
	;mov	ax,(International SHL 8)
	mov	ax,3800h
					; Determine what format the date
	mov	dx,5Ch			;  should be entered in and
	int	21h			;  print a message describing it
			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
			; get current-country info
			; DS:DX -> buffer for returned info
	mov	si,dx
	lodsw
	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
	dec	ax
	js	short printformat
	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
	jz	short printformat
	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
printformat:
	mov	ax,dx			;AN000; get message number of format
	;mov	dh,util_msg_class	;AN000; this is a utility message
	mov	dh,-1 ; 0FFh
	call	TSYSGETMSG		;AN000; get the address of the message
	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
	mov	dx,NewDat_Ptr		;AC000; get address of message to print
	call	std_printf
	;mov	word [cs:NewDat_Format],no_subst
					;AN000; reset subst block
	mov	word [cs:NewDat_Format],0

	; 28/02/2023
	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
; 28/02/2023
gettim_p:	
	;mov	ah,Std_Con_String_Input
	mov	ah,0Ah
	mov	dx,COMBUF
	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
	call	SetInitFlag		;  prompting for date.
	int	21h			; Get input line
	xor	cx,cx			; Reset bit in InitFlag that indicates
	call	SetInitFlag		;  prompting for date.
	call	CRLF2
	; 28/02/2023
	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
;gettim_p: ; 28/02/2023
	mov	si,COMBUF+2
	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
	xor	dx,dx			;AN000;
	;call	cmd_parse		;AC000; call parser
	;retn
	; 28/02/2023
	jmp	cmd_parse

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

; ****************************************************************
; *
; * ROUTINE:	 GETTIME - Prompt user for time
; *
; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
; *		 INFORMATION and issues the "Enter new time"
; *		 message. COMBUF is reset to get a time from the
; *		 command line. The PARSE_TIME blocks are then
; *		 reset and the PARSE function call is issued.
; *
; * INPUT:	 NONE
; *
; * OUTPUT:	 COMBUF
; *		 PARSER RETURN CODES
; *
; ****************************************************************

	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
GETTIM:
	xor	cx,cx			; Initialize hours and minutes to zero
	mov	dx,NewTim_Ptr
	call	std_printf

	; 28/02/2023
	mov	di,PARSE_TIME
	jmp	short gettim_p

; 28/02/2023
;	;mov	ah,Std_Con_String_Input
;	mov	ah,0Ah
;	mov	dx,COMBUF
;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
;	call	SetInitFlag		;  prompting for time.
;	int	21h			; Get input line
;	; 28/02/2023
;	xor	cx,cx			; Reset bit in InitFlag that indicates
;	call	SetInitFlag		;  prompting for time.
;	call	CRLF2
;	; 28/02/2023
;	;mov	si,COMBUF+2
;	; 28/02/2023
;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
;	; 28/02/2023
;	jmp	short gettim_p	
;	; 28/02/2023
;	;;xor	cx,cx			;AN000; clear counter for positionals
;	;xor	dx,dx			;AN000;
;	;call	cmd_parse		;AC000; call parser
;	;retn


; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;Skip_white: Skips over the whitespace chars that could be present after
;the '=' sign in the environment variable before the actual path.
;
;	ENTRY:	ds:si = arguments of the environment variable
;
;	EXIT:	ds:si = start of the path
;
;	REGISTERS AFFECTED: ax

	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
skip_white:
	cld
skw_lp:
	lodsb
	cmp	al,' '			;blank char?
	jz	short skw_lp		;yes, skip it
	cmp	al,9			;tab char?
	jz	short skw_lp		;yes, skip it
	dec	si			;point at first non-white
	retn

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;Copy_pipe_path: This routine copies the path from the TEMP environment
;variable into the path buffers Pipe1 & Pipe2.
;
;	ENTRY:	ds:si = path to be copied
;		es = RESGROUP
;
;	EXIT:	Path copied into Pipe1 and Pipe2.
;
;	REGISTERS AFFECTED: si, di, cx, ax

	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h

copy_pipe_path:
	mov	cx,0FFFFh ; 65535
	xor	al,al

	mov	di,si
	push	es			;save es
	push	ds
	pop	es			;es:di = path to be copied
	
	cld
	push	di
	repnz	scasb			;look for the null char
	pop	di

	pop	es			;es = RESGROUP again

	not	cx			;length including the null

	;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
	;mov	di,offset DATARES:Pipe1
	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
	push	di
	push	cx			
	rep	movsb			;copy path into Pipe1
	pop	cx
	pop	di

	push	ds
	push	es
	pop	ds			;ds:si = Pipe1
	mov	si,di
	;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
	rep	movsb			;copy path into Pipe2
	pop	ds
	retn

; 28/02/2023
%if 0

;============================================================================
; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
;============================================================================
; 05/10/2018 - Retro DOS v3.0

; DATE - Gets and sets the time

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h

; =============== S U B	R O U T	I N E =======================================

DATE_CXDX:
	mov	bx,cx

; =============== S U B	R O U T	I N E =======================================

P_DATE:
	mov	ax,bx
	mov	cx,dx
	mov	dl,100
	div	dl
	xchg	al,ah
	xchg	ax,dx
	mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
	;mov	ax,[INTERNATVARS]
	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
	or	ax,ax
	jz	short USPDAT
	dec	ax
	jz	short EUPDAT
	mov	bh,0	 ; Disable leading zero suppression	
	call	P_YR
	call	P_DSEP
	call	P_MON
	call	P_DSEP
	call	P_DAY
	retn

USPDAT:
	call	P_MON
	call	P_DSEP
	call	P_DAY
PLST:
	call	P_DSEP
	call	P_YR
	retn

EUPDAT:
	call	P_DAY
	call	P_DSEP
	call	P_MON
	jmp	short PLST

; ---------------------------------------------------------------------------

P_MON:
	mov	al,ch
	call	OUT2
	retn

; ---------------------------------------------------------------------------

P_DSEP:
	;mov	al,[DATE_SEP] ; INTERNATVARS+11
	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
	stosb
	retn

; ---------------------------------------------------------------------------

P_DAY:
	mov	al,cl
	call	OUT2
	retn

; ---------------------------------------------------------------------------

P_YR:
	mov	al,dh
	or	al,al
	jz	short TWODIGYR	; Two instead of 4 digit year
	call	OUT2
TWODIGYR:
	mov	al,dl
	call	OUT2
DATE_RETN:
	retn

; =============== S U B	R O U T	I N E =======================================

DATE:				 ; Accepting argument for date inline
	mov	si,81h
	call	SCANOFF
	cmp	al,0Dh
	jz	short PRMTDAT
	jmp	short COMDAT

	;nop
PRMTDAT:
	; MSDOS 3.3
	mov	dx,CURDATPTR
	call	STD_PRINTF	; Print "Current date is "	
	call	PRINT_DATE
GETDAT:	
	mov	dx,NEWDATPTR
	call	STD_PRINTF	 ; Print "Enter new date: "

	mov	ax,INTERNATIONAL*256 ; 3800h 
				; Determine what format the date
	mov	dx,5Ch		;  should be entered in and
	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
			; get current-country info
			; DS:DX	-> buffer for returned info
	mov	si,dx		;  print a message describing it
	lodsw
	mov	dx,USADATPTR	; get mm-dd-yy
	dec	ax
	js	short PRINTFORMAT
	mov	dx,EURDATPTR	; get dd-mm-yy
	jz	short PRINTFORMAT
	mov	dx,JAPDATPTR	; get yy-mm-dd
PRINTFORMAT:
	call	STD_PRINTF
	mov	ah,Std_Con_String_Input	; 0Ah
	mov	dx,COMBUF
	mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
	call	SETINITFLAG	;  prompting for date.
	int	21h		; Get input line
	xor	cx,cx		; Reset bit in InitFlag that indicates
	call	SETINITFLAG	;  prompting for date.
	call	CRLF2
	mov	si,COMBUF+2
	cmp	byte [si],0Dh
	jz	short DATE_RETN
COMDAT:
	;mov	ax,[INTERNATVARS]
	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
	or	ax,ax
	jz	short USSDAT
	dec	ax
	jz	short EUSDAT
	call	GET_YR
	jc	short DATERRJ
	call	GET_DSEP
	jc	short DATERRJ
	call	GET_MON
	jc	short DATERRJ
	call	GET_DSEP
	jc	short DATERRJ
	call	GET_DAY
DAT_SET:
	jnc	short DATSET
	jmp	DATERR

; ---------------------------------------------------------------------------

DATSET:
	lodsb
	cmp	al,' '
	jz	short DATSET
	cmp	al,9
	jz	short DATSET
	cmp	al,0Dh
	jnz	short DATERR
	mov	ah,SET_DATE ; 2Bh
	int	21h	; DOS -	SET CURRENT DATE
			; DL = day,DH = month,	CX = year
			; Return: AL = 00h if no error 
			; 	     = FFh if bad value sent to routine
	or	al,al
	jnz	short DATERR
DAT_SET_RETN:
	retn

; ---------------------------------------------------------------------------

USSDAT:
	call	GET_MON
	jb	short DATERR
	call	GET_DSEP
DATERRJ:
	jc	short DATERR
	call	GET_DAY
TGET:
	jc	short DATERR
	call	GET_DSEP
	jc	short DATERR
	call	GET_YR
	jmp	short DAT_SET

; ---------------------------------------------------------------------------

EUSDAT:
	call	GET_DAY
	jc	short DATERR
	call	GET_DSEP
	jc	short DATERR
	call	GET_MON
	jmp	short TGET

; =============== S U B	R O U T	I N E =======================================

GET_MON:
	call	GETNUM		; Get one or two digit number
	jc	short DAT_SET_RETN
	mov	dh,ah		; Put in position
	retn


; =============== S U B	R O U T	I N E =======================================

GET_DAY:
		call	GETNUM
		mov	dl,ah		; Put in position
GET_DAY_RETN:
		retn

; =============== S U B	R O U T	I N E =======================================

GET_YR:
	call	GETNUM
	jc	short GET_DAY_RETN
	mov	cx,1900
	call	GET_DSEP
	pushf
	dec	si
	popf
	jz	short BIAS
	cmp	byte [si],0Dh
	je	short BIAS
	cmp	byte [si],' '
	je	short BIAS
	cmp	byte [si],9
	je	short BIAS
	push	bx
	mov	bl,100
	mov	al,ah
	mul	bl
	pop	bx
	mov	cx,ax
	call	GETNUM
	jc	short GET_DAY_RETN
BIAS:
	mov	al,ah
	mov	ah,0
	add	cx,ax
BIAS_RETN:
	retn

; ---------------------------------------------------------------------------

DATERR:
	mov	dx,BADDATPTR
	call	STD_PRINTF
	jmp	GETDAT

; =============== S U B	R O U T	I N E =======================================

GET_DSEP:
	lodsb
	cmp	al,'/'
	je	short BIAS_RETN
	;cmp	al,'.'
	cmp	al,[DOT_CHR]
	je	short BIAS_RETN
	;cmp	al,'-'
	cmp	al,[CHAR_SUB]
	je	short BIAS_RETN
	stc
	retn

; =============== S U B	R O U T	I N E =======================================

; TIME gets and sets the time

CTIME:
	mov	si,81h		; Accepting argument for time inline
	call	SCANOFF
	cmp	al,0Dh
	je	short PRMTTIM
	mov	bx,2E3Ah ; ":."
	call	INLINE
	jmp	COMTIM

; =============== S U B	R O U T	I N E =======================================

PRINT_TIME:
	mov	ah,Get_Time ; 2Ch ; Get time in CX:DX
	int	21h	; DOS -	GET CURRENT TIME
			; Return: CH = hours,CL = minutes,DH = seconds
			; DL = hundredths of seconds
	push	di
	push	es
	push	cs
	pop	es
	mov	di,CHARBUF
	mov	bl,1	; Always 24 hour time
	call	P_TIME
	xor	ax,ax
	stosb
	mov	dx,CHARBUF
	mov	[STRING_PTR_2],dx
	mov	dx,STRINGBUF2PTR
	call	STD_PRINTF
	pop	es
	pop	di
P_TIME_RETN:
	retn

; =============== S U B	R O U T	I N E =======================================

P_TIME:
	mov	al,ch	
	test	bl,7Fh		; Ignore high bit
	jnz	short T24	; 24 hr time?
	mov	bh,'a'		; Assume A.M.
	cmp	al,12		; In the afternoon?
	jb	short MORN
	mov	bh,'p'
	jz	short MORN
	sub	al,12		; Keep it to 12 hours or less
MORN:
	or	al,al		; Before 1 am?
	jnz	short T24
	mov	al,12
T24:
	push	bx
	mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
	call	OUT2
	call	P_TSEP
	mov	al,cl
	call	OUT2
	pop	bx
	push	bx
	test	bl,80h
	jnz	short PAP	; If from DIR, go directly to am pm
	mov	bh,0		; Disable leading zero suppression
	call	P_TSEP
	mov	al,dh
	call	OUT2
	;mov	al,'.'
	mov	al,[DECIMAL_SEP]
	stosb
	mov	al,dl
	call	OUT2
PAP:
	pop	bx
	test	bl,7Fh		; Ignore high bit
	jnz	short P_TIME_RETN
	mov	al,bh
	stosb
	retn

; =============== S U B	R O U T	I N E =======================================

P_TSEP:
	;mov	al,[TIME_SEP]
	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
	stosb
P_TSEP_RETN:
	retn

; ---------------------------------------------------------------------------

PRMTTIM:
	mov	dx,CURTIMPTR
	call	STD_PRINTF	; Print "Current time is "
	call	PRINT_TIME
GETTIM:
	xor	cx,cx		; Initialize hours and minutes to zero
	mov	dx,NEWTIMPTR
	call	STD_PRINTF
	;mov	bx,':.'
	mov	bx,[TIMECHARS] 
	call	GETBUF
COMTIM:
	jz	short P_TSEP_RETN ; If no time present, don't change it	
	jc	short TIMEERR
	mov	cx,dx
	xor	dx,dx
	lodsb
	cmp	al,0Dh
	je	short SAVTIM
	cmp	al,' '
	je	short GOTSEC2
	cmp	al,9
	je	short GOTSEC2
	cmp	al,bl
	je	short GOTSEC
	cmp	al,bh
	jne	short TIMEERR
GOTSEC:
	call	GETNUM
	jc	short TIMEERR
	mov	dh,ah		; Position seconds
	lodsb
	cmp	al,0Dh
	je	short SAVTIM
	cmp	al,' '
	je	short GOTSEC2
	cmp	al,9
	je	short GOTSEC2
	;cmp	al,'.'
	cmp	al,[DECIMAL_SEP]
	jne	short TIMEERR
	call	GETNUM
	jc	short TIMEERR
	mov	dl,ah
GOTSEC2:
	lodsb
	cmp	al,' '
	je	short GOTSEC2
	cmp	al,9
	je	short GOTSEC2
	cmp	al,0Dh
	jne	short TIMEERR
SAVTIM:
	mov	ah,SET_TIME ; 2Dh
	int	21h	; DOS -	SET CURRENT TIME
			; CH = hours,CL = minutes,DH = seconds,
			;		DL = hundredths of seconds
			; Return: AL = 00h if no error 
			;	     = FFh if bad value sent to routine
	or	al,al
P_TSEP_JRETN:
	jz	short P_TSEP_RETN ; Error in time?
TIMEERR:
	mov	dx,BADTIMPTR
	call	STD_PRINTF	; Print "Enter new time: "
	jmp	short GETTIM

; =============== S U B	R O U T	I N E =======================================

GETBUF:
	mov	ah,Std_Con_String_Input ; 0Ah
	mov	dx,COMBUF
	mov	cx,2
	call	SETINITFLAG
	int	21h		; Get input line
	xor	cx,cx
	call	SETINITFLAG
	call	CRLF2
	mov	si,COMBUF+2
	cmp	byte [si],0Dh	; Check if new time entered
	jz	short P_TSEP_JRETN

; =============== S U B	R O U T	I N E =======================================

INLINE:
	call	GETNUM		; Get one or two digit number
	jnb	short INLINE1
	retn
INLINE1:
	mov	dh,ah		; Put in position
	lodsb
	cmp	al,bl
	jz	short NEXT
	cmp	al,bh
	jz	short NEXT
	dec	si		; Clears zero flag
	clc
	mov	dl,0
	retn			; Time may have only an hour specified
NEXT:
	call	GETNUM
	mov	dl,ah		; Put in position
INLINE_RETN:
	retn

;============================================================================
; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
;============================================================================
; 05/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h

; =============== S U B	R O U T	I N E =======================================

GETNUM:
	call	INDIG
	jb	short INLINE_RETN
	mov	ah,al		; Save first digit
	call	INDIG		; Another digit?
	jb	short OKRET
	aad			; Convert unpacked BCD to decimal
	mov	ah,al
OKRET:
	or	al,1
GETNUM_RETN:
	retn

; =============== S U B	R O U T	I N E =======================================

INDIG:
	mov	al,[si]
	sub	al,'0'
	jc	short GETNUM_RETN
	cmp	al,10
	cmc
	jc	short GETNUM_RETN
	inc	si
	retn

; =============== S U B	R O U T	I N E =======================================

OUT2:				; Output binary number as two ASCII digits
	aam			; Convert binary to unpacked BCD
	xchg	al,ah
	or	ax,3030h	; Add "0" bias to both digits
	cmp	al,'0'		; Is MSD zero?
	jnz	short NOSUP
	sub	al,bh		; Suppress leading zero if enabled
NOSUP:
	mov	bh,0		; Disable zero suppression
	stosw
	retn

; ---------------------------------------------------------------------------
	;stosb
	;retn

;============================================================================
; TPIPE.ASM, MSDOS 6.0, 1991
;============================================================================
; 03/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h

; =============== S U B	R O U T	I N E =======================================

; Set the special flag in the INIT flag to the value in CX.

SETINITFLAG:
	mov	ds,[RESSEG]
	;and	byte [INITFLAG],0FDh
	and	byte [INITFLAG],~INITSPECIAL
	or	byte [INITFLAG],cl
	push	cs
	pop	ds
	retn

; =============== S U B	R O U T	I N E =======================================

PIPEOFF:
	push	ds
	push	ax
	mov	ds,[cs:RESSEG]
	xor	al,al
	xchg	al,byte [PIPEFLAG]
	or	al,al
	jz	short PIPEOFFDONE
	shr	byte [ECHOFLAG],1
PIPEOFFDONE:
	pop	ax
	pop	ds
	retn

; ---------------------------------------------------------------------------
	;db    0,0,0,0,0
	;times 5 db 0

align 16

%endif

;============================================================================
; PARSE2.ASM, MSDOS 6.0, 1991
;============================================================================
; 03/10/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------
; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
; argv[argvcnt] array. The most important difference between this array and
; the tradition UNIX format is the extra cparse information included with
; each argument element.
;---------------
; ENTRY:
;	BL	     special delimiter for cparse -- not implemented)
;---------------
; EXIT:
;	CF	    set if error
;	AL	    error code (carry set). Note AH clobbered in any event.
;	argv[]	    array of cparse flags and pointers to arguments
;	argvcnt     argument count
;---------------
; NOTE(S):
;	*   BL (special delimiter) is ignored, for now (set to space).
;	*   Parseflags record contains cparse flags, as follows:
;		sw_flag 	--	was this arg a switch?
;		wildcard	--	whether or not it contained a * or ?
;		path_sep	--	maybe it was a pathname
;		unused		--	for future expansion
;		special_delim	--	was there an initial special delimiter?
;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
;	*   Relationship between input, cparse output, and comtail can be
;	    found in the following chart. Despite the claim of the cparse
;	    documentation that, "Token buffer always starts d: for non switch
;	    tokens", such is not the case (see column two, row two).
;	    Similarly, [STARTEL] is not null when the command line is one of
;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
;	    STARTEL addresses) will be null. This is clearly just a
;	    documentation error.
;	*   cparse also returns a switch code in BP for each switch it
;	    recognizes on the command line.
;	*   arglen for each token does NOT include the terminating null.
;	*   Finally, note that interesting constructions like 'foodir/*.exe'
;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
;	    line parsing may result in slightly different behavior than
;	    previously observed with the old COMMAND.COM command-line parser.
;
;	    Input		    Cparse		Command Line (80H)
;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
;	alan\foo.bat		alan\foo.bat		alan\foo.bat
;	foo.bat 		foo.bat 		foo.bat
;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
;	c:foo.bat		c:foo.bat		c:foo.bat

; =============== S U B	R O U T	I N E =======================================

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h

; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh

PARSELINE:
	push	ax			; most of these are clobbered
	push	bx			; by cparse...
	push	cx
	push	dx
	push	di
	push	si
	pushf
	mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
	mov	word [LASTARG],-1 ; last argument at which to accumulate
	xor	ax,ax
	;mov	cx,1348
	mov	cx,ARG_UNIT.SIZE
	mov	di,ARG
	rep	stosb
	;mov	word [ARGBUF_PTR],ARG_ARGBUF
	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
	mov	word [ARG+ARG_UNIT.argswinfo],0
	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
	mov	word [ARG+ARG_UNIT.argvcnt],0
	mov	si,COMBUF+2	; prescan leaves cooked input in combuf

; This next section of code (up to pcont:)  makes sure that si is set up for
; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
; otherwise. This is done so that commands can get arg pointers into their
; original command line (or an exact copy of it) in arg_ocomptr.
; Arg.argforcombuf is used so that the for loop processor will always be able
; to get a hold of its original command line; even after COMBUF is blasted by
; the command to be repeated or the transient part of command has been
; reloaded.

	push	ds
	mov	ds,[RESSEG]
	cmp	byte [ForFlag],0
	pop	ds
	jnz	short PCONT
	;mov	di,ARG_ARGFORCOMBUF
	mov	di,ARG+ARG_UNIT.argforcombuf 
	xor	ch,ch
	mov	cl,[COMBUF+1]
	inc	cl
	rep	movsb
	;mov	si,ARG_ARGFORCOMBUF
	mov	si,ARG+ARG_UNIT.argforcombuf 
PCONT:
	mov	di,TPBUF	; destination is temporary token buffer	
	mov	bl,' '		; no special delimiter, for now
PARSELOOP:
	mov	[COMPTR],si	; save ptr into original command buffer
	xor	bp,bp		; switch information put here by cparse
	mov	byte [expand_star],0 ; don't expand *'s to ?'s
	call	scanoff		; skip leading blanks...
	call	cparse		; byte off a token (args in SI, DI, BL)
	jnb	short MORE_PRSE
	or	bp,bp		; Check for trailing switch character
	jz	short PARSEDONE
	call	newarg		; We hit CR but BP is non-zero. The
				;   typical cause of this is that a
				;   switch char IMMEDIATELY preceeds
				;   the CR. We have an argument, but it
				;   is sort of an error.
	;jmp	short PARSEDONE	; We're done (found the CR).
	; 01/03/2023
PARSEDONE:
	popf
	clc
	jmp	short PARSE_EXIT

MORE_PRSE:
	mov	byte [cpyflag],2
				; tell CPARSE that 1st token is done
	call	newarg		; add to argv array (CX has char count)
	jnb	short PARSELOOP	; was everything OK?
	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
	; 01/03/2023
;PARSEDONE:
	;popf
	;clc
	;jmp	short PARSE_EXIT

PARSE_ERROR:			; error entry (er, exit) point
	popf
	stc
PARSE_EXIT:			; depend on not changing CF
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	retn

; =============== S U B	R O U T	I N E =======================================

; NEWARG adds the supplied argstring and cparse data to arg.argv[].
;
; ENTRY:
;   BH			argflags
;   CX			character count in argstring
;   DI			pointer to argstring
;   comptr		ptr to starting loc of current token in original command
;   [STARTEL]		cparse's answer to where the last element starts
; EXIT:
;   argbufptr		points to next free section of argbuffer
;   arg.argbuf		contains null-terminated argument strings
;   arg.argvcnt 	argument count
;   arg.argv[]		array of flags and pointers
;   arg.arg_ocomptr	ptr to starting loc of current token in original command
;   CF			set if error
;   AL			carry set:  error code; otherwise, zero

	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
newarg:
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	pushf
	call	arg_switch		; if it's a switch, record switch info
					; LEAVE SWITCH ON COMMAND LINE!!
	;;;jc	short newarg_done 	; previous arg's switches -- and leave

	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
	jge	short to_many_args	; exceeded array limits
	mov	dh,bh			
	;mov	bx,[ARG_ARGVCNT]	; save argflags	
	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
	;inc	word [ARG_ARGVCNT]
	inc	word [ARG+ARG_UNIT.argvcnt]
	;mov	ax,ARG_ARGV
	mov	ax,ARG+ARG_UNIT.argv
	call	argv_calc		; convert offset to pointer
	;mov	[BX].argsw_word,0 	; no switch information, yet...
	;mov	word [bx+7],0
	mov	word [bx+ARGV_ELE.argsw_word],0
	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
	;mov	[bx+5],cx
	mov	[bx+ARGV_ELE.arglen],cx 
	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
	;mov	[bx+2],dh
	mov	[bx+ARGV_ELE.argflags],dh
	mov	si,[ARGBUF_PTR]
	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
	;mov	[bx+ARGV_ELE.argpointer],si
	mov	[bx],si			
	add	si,[STARTEL]		; save startel from new location
	sub	si,di			; form pointer into argbuf
	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
	;mov	[bx+3],si
	mov	[bx+ARGV_ELE.argstartel],si
	mov	si,[COMPTR]
	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
	;mov	[bx+9],si
	mov	[bx+ARGV_ELE.arg_ocomptr],si
	mov	si,di			; now save argstring in argbuffer
	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
	add	di,cx			; sure we're not about to run off
	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
	;cmp	di,ARG_ARGBUF+255
	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
	jge	short buf_oflow		; the end of the buffer (plus null byte)	
	sub	di,cx
	cld
	rep	movsb
	mov	al,ANULL ; 0		; tack a null byte on the end
	stosb
	mov	[ARGBUF_PTR],di		; update argbufptr after copy
newarg_done:
	popf
	clc
	jmp	short newarg_exit
to_many_args:
	mov	ax,1
	jmp	short newarg_error
buf_oflow:
	mov	ax,2
newarg_error:
	popf
	stc
newarg_exit:
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
	retn

; =============== S U B	R O U T	I N E =======================================

; ARG_SWITCH decides if an argument might really be a switch. In the
; event that it is, and we can recognize
;
; ENTRY:
;   As in <newarg>.
; EXIT:
;   CF	    --	    clear (wasn't a switch); set (was a switch)
; NOTE(S):
;   *	The mechanism mapping a switch into a bit-value depends entirely
;	on the order of definition in the <switch_list> variable and the
;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
;	this mechanism. This code taken from CMDT:TCODE.ASM.
;   *	The <switch_list> declared below is redundant to one declared in
;	TDATA.ASM, and used in TCODE.ASM.
;   *	An ugly routine.

	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
arg_switch:
	push	ax
	push	bx
	push	cx
	push	di
	pushf
	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
	jz	short arg_no_switch0
	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
	je	short arg_no_switch1 	; no, so leading switches don't matter
	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
	;mov	ax,offset TRANGROUP:arg.argv
	;mov	ax,ARG_ARGV
	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
	call	argv_calc
	;or	[BX].argsw_word,BP
	;or	[bx+7],bp
	or	[bx+ARGV_ELE.argsw_word],bp
	;or	arg.argswinfo,BP
	;or	[ARG_ARGSWINFO],bp
	or	[ARG+ARG_UNIT.argswinfo],bp
arg_yes_switch:
	popf
	stc
	jmp	short arg_switch_exit

arg_no_switch0:
	;mov	ax,[ARG_ARGVCNT]
	mov	ax,[ARG+ARG_UNIT.argvcnt]
	mov	[LASTARG],ax
arg_no_switch1:
	popf
	clc
arg_switch_exit:
	pop	di
	pop	cx
	pop	bx
	pop	ax
	retn

; =============== S U B	R O U T	I N E =======================================

; ARGV_CALC maps an array index into a byte-offset from the base of
; the supplied array.  Method used for computing the address is:
;	Array Index * Array Elt Size + Base Addr = Elt Addr
; ENTRY:
;   AX	    --	    base of array
;   BX	    --	    array index
; EXIT:
;   BX	    --	    byte offset

	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
argv_calc:
	push	ax		; Save base
	mov	al,bl		; al = array index
	;mov	bl,11
	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
	mul	bl		; ax = base offset
	pop	bx		; Get base
	add	ax,bx		; Add in base offset
	xchg	ax,bx		; Restore ax and put byte offset in bx
	retn

; ---------------------------------------------------------------------------
	
	;db 0Ah dup(0)
	;times 10 db 0

align 16

;============================================================================
; PATH1.ASM, MSDOS 6.0, 1991
;============================================================================
; 03/10/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------
;    PATH.ASM contains the routines to perform pathname incovation. Path and
;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
;    given a pathname, attempts to find a corresponding executable or batch
;    file on disk. Directories specified in the user's search path will be
;    searched for a matching file, if a match is not found in the current
;    directory and if the pathname is actually only an MSDOS filename.
;    <Path_Search> assumes that the parsed command name can be found in
;    argv[0] -- in other words, <Parseline> should be executed prior to
;    <Path_Search>. Alternatively, the command name and appropriate
;    information could be placed in argv[0], or <Path_Search> could be
;    (easily) modified to make no assumptions about where its input is found.
;    Please find enclosed yet another important routine, <Save_Args>, which
;    places the entire arg/argv[]/argbuf structure on a piece of newly
;    allocated memory. This is handy for for-loop processing, and anything
;    else that wants to save the whole shebang and then process other command
;    lines.
;
; Alan L, OS/MSDOS				    August 15, 1983
;
; ENTRY:
;   <Path_Search>:	    argv[0].
;   <Save_Args>:	    bytes to allocate in addition to arg structure
; EXIT:
;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
;   <Save_Args>:	    success flag, segment address of new memory
; NOTE(S):
;   *	<Argv_calc> handily turns an array index into an absolute pointer.
;	The computation depends on the size of an argv[] element (arg_ele).
;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
;	does not function as specified; see <Parseline> for more details.
;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
;	need to know about. This extra information is stored in a switch_flag
;	word with each command-line argument; the switches themselves will not
;	appear in the resulting arg structure.
;   *	With the exception of CARRY, flags are generally preserved across calls.
;----------------------------------------------------------------------------

; =============== S U B	R O U T	I N E =======================================

; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
; of *argv[0].argstartel == 0 implies that there is no command (empty line
; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
; have a match, either in the current working directory if we were handed
; a filename, or in the specified directory, given a pathname. If this call
; fails, and we were given a pathname, then Path_Search fails. Otherwise,
; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
; prefix, we want to skip it) for each pathstring in userpath. Success on
; either the first invocation of search or on one of the succeeding calls
; sets up the appropriate information for copying the successful pathname
; prefix (if any) into the result buffer, followed by the successful filename
; match (from [search_best_buf]). The result is returned in in EXECPATH.
;
; ENTRY:
;   argv[0]		--	command name and associated information
; EXIT:
;   AX			--	non-zero indicates type of file found
;   EXECPATH		--	successful pathname (AX non-zero)
; NOTE(S):
;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
;   2)	Some files are more equal than others.	See search: for rankings.
;   3)	Path_Search terminates as soon as a call to search succeeds, even
;	if search returns an .exe or .bat.
;   5)	Clobbers dma address.

PBUFLEN 	EQU	128		; length of EXECPATH
PATH_SEP_CHAR	EQU	';'

;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1

	;special_delim equ 128
	;path_sep equ 4
	;wildcard equ 2
	;sw_flag  equ 1

;----------------------------------------------------------------------------

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h

; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h

path_search:
	push	bx
	push	cx
	push	dx		; could use a "stack 'em" instruction
	push	si
	push	di
	push	bp
	pushf

	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
	;test	byte [ARGV0_ARG_FLAGS],3
	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
	jz	short path_search_ok
path_failure_jmp:
	jmp	path_failure	; ambiguous commands not allowed

path_search_ok:
	call	STORE_PCHAR	; figure out the pathname separator
	mov	dx,FBUF		; clobber old dma value with
	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
			; DS:DX	-> disk	transfer buffer
	push	es
	call	find_path	; get a handle (ES:DI) on user path
	mov	[pathinfo+0],es	; and squirrel it away
	mov	[pathinfo+2],di	; "old" pathstring pointer
	mov	[pathinfo+4],di	; "new" pathstring pointer
	pop	es
	
	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
	mov	si,EXECPATH
	call	STRIP
	jc	short path_failure_jmp ; if possible, of course
		
	mov	dx,si		; search (EXECPATH, error_message)
	mov	word [search_error],baddrv_ptr
	call	PSEARCH		; must do at least one search
	or	ax,ax		; find anything?
	jz	short path_noinit
				; failure ... search farther	
	mov	bp,ax		; success... save filetype code	
	mov	di,EXECPATH
	;mov	si,ds:arg.argv[0].argpointer
	;mov	si,[ARG_ARGV]
	mov	si,[ARG+ARGV_ELE.argpointer]
	;mov	cx,ds:arg.argv[0].argstartel
	;mov	cx,[ARGV0_ARGSTARTEL]
	mov	cx,[ARG+ARGV_ELE.argstartel]
	sub	cx,si		; compute prefix bytes to copy

; We have the number of bytes in the prefix (up to the final component).
; We need to form the complete pathname including leading drive and current
; directory.
;
; Is there a drive letter present?

	mov	ah,':'
	cmp	cx,2		; room for drive letter?
	jb	short adddrive	; no, stick it in
	cmp	[si+1],	ah	; colon present?
	je	short movedrive	; yes, just move it
adddrive:
	mov	al,[CURDRV]	; get current drive
	add	al,'A'		; convert to uppercase letter
	stosw			; store d:
	jmp	short checkpath

movedrive:
	lodsw			; move d:
	stosw
	sub	cx,2		; 2 bytes less to move
checkpath:
	or	al,20h
	mov	dl,al		
	;sub	dl,60h
	sub	dl,'a'-1	; convert to 1-based for current dir

; Stick in beginning path char

	mov	al,[psep_char]
	stosb

; Is there a leading /? If so, then no current dir copy is necessary.
; Otherwise, get current dir for DL.

	cmp	cx,1		; is there room for path char?
	jb	short addpath	; no, go add path
	lodsb
	dec	cx
	cmp	al,[psep_char]	; is there a path separator?
	je	short movepath	; yes, go move remainder of path
	inc	cx
	dec	si		; undo the lodsb
addpath:
	push	si
	mov	si,di		; remainder of buffer
	mov	ax,Current_Dir*256 ; 4700h
	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
			; DL = drive (0=default,1=A,etc.)
			; DS:SI	points to 64-byte buffer area

; The previous current dir will succeed a previous find_first already worked.
;
; Find end of string.

	mov	di,si
	pop	si
	mov	al,[psep_char]
	cmp	byte [di],0	; root (empty dir string)?
	jz	short movepath	; yes, no need for path char
scanend:
	;cmp	byte [di],0	; end of string?
	;jz	short foundend
	;inc	di
	;jmp	short scanend
	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
	inc	di
	cmp	byte [di],0
	jnz	short scanend

; Stick in a trailing path char.

foundend:
	stosb

; Move remaining part of path. Skip leading path char if present.

movepath:
	cmp	[si],al		; first char a path char?
	jne	short copypath
	; 26/04/2023
	inc	si		; move past leading char
	dec	cx		; drop from count
copypath:
	jcxz	_copydone	; no chars to move!	
	rep	movsb
_copydone:
	jmp	path_success
				; run off and form complete pathname
path_noinit:
	;test	ds:arg.argv[0].argflags, MASK path_sep
	;test	byte [ARGV0_ARG_FLAGS],4
	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
	jnz	short path_failure
				; complete pathname specified ==> fail
	;mov	bh,';'
	mov	bh,PATH_SEP_CHAR
				; semicolon terminates pathstring
	;mov	dx,ds:arg.argv[0].argstartel
				; this is where the last element starts
	;mov	dx,[ARGV0_ARGSTARTEL]
	mov	dx,[ARG+ARGV_ELE.argstartel]
	;sub	dx,ds:arg.argv[0].argpointer
				; form pointer into EXECPATH,
	;sub	dx,[ARG_ARGV]
	sub	dx,[ARG+ARGV_ELE.argpointer]
	add	dx,EXECPATH	; skipping over drive spec, if any
path_loop:
	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
	mov	bp,ax		; save filetype code
	lahf			; save flags, just in case
	or	bp,bp		; did path_crunch find anything?		
	jnz	short path_found 
	sahf			; see? needed those flags, after all!
	jnc	short path_loop	; is there anything left to the path?
path_failure:
	xor	ax,ax
	jmp	path_exit

path_found:				; pathinfo[] points to winner
	mov	di,EXECPATH
	;mov	cx,pathinfo[4] 
	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
	;mov	si,pathinfo[2]
	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string

;	BAS Nov 20/84
;   Look at the pathname and expand . and .. if they are the first element
;   in the pathname (after the drive letter)

	push	es
	;push	pathinfo[0]
	push	word [pathinfo+0]
	pop	es
;SR;
; Oops! Gets fooled if path= \;..
; We should also check if a drive letter is really present
;
	cmp	byte [es:si+2],'.'
				; Look for Current dir at start of path
	jne	short path_cpy

	; 18/03/2023
	; MSDOS 6.0
	cmp	byte [es:si+1],':'
				; does path have drive letter?
	jne	short path_cpy	; no, copy the path string

	push	cx		; Save pointer to end of string
	;mov	al,[es:si]
	;mov	[di],al		; Copy drive letter, :, and root char
	;mov	al,[es:si+1]	; to EXECPATH
	;mov	[di+1],al
	; 05/05/2023
	mov	ax,[es:si]
	mov	[di],ax
	mov	al,[psep_char]
	mov	[di+2],al
	push	si		; Save pointer to begining of string
	mov	dl,[es:si]	; Convert device letter for cur dir
	or	dl,20h
	;sub	dl,60h
	sub	dl,'a'-1
	mov	si,di		; pointer to EXECPATH
	add	si,3		; Don't wipe out drive and root info
	mov	ax,Current_Dir*256 ; 4700h
	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
			; DL = drive (0=default,1=A,etc.)
			; DS:SI	points to 64-byte buffer area
	call	dstrlen		; Determine length of present info
	add	si,cx		; Don't copy over drive and root info
	dec	si
	mov	di,si		; Point to end of target string
	pop	si		; Restore pointer to begining of string
	add	si,3		; Point past drive letter, :, .
	pop	cx		; Restore pointer to end of string
path_cpy:
	pop	es
	sub	cx,si		; yields character count
	push	ds		; time to switch segments
	push	word [pathinfo+0]
				; string lives in this segment
	pop	ds
	cld

	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 (& MSDOS 5.0)
	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
kloop:
	lodsb			;AN000;  3/3/KK
	stosb			;AN000;  3/3/KK
	call	testkanj	;AN000;  3/3/KK
	jz	short _notkanj1	;AN000;  3/3/KK
	dec	cx		;AN000;  3/3/KK
	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
	movsb			;AN000;  3/3/KK
	dec	cx		;AN000;  3/3/KK
	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
	ja	short kloop	;AN000;  no.  3/3/KK
popdone:			;AN000;  3/3/KK
	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
	jmp	short path_store
				;AN000;  3/3/KK
_notkanj1:
	; 26/04/2023
	loop	kloop
	pop	ds		; return to our segment
	dec	di		; overwrite terminator
	mov	al,[psep_char]	; with a pathname separator
	cmp	al,[di-1]
	je	short path_success
path_store:
	stosb
path_success:
	mov	si,search_best_buf
	xor	cx,cx
path_succ_loop:
	lodsb			; append winning filename to path
	stosb			; (including terminating null)	
	or	al,al
	jnz	short path_succ_loop
	mov	ax,bp		; retrieve filetype code
path_exit:
	popf
	pop	bp
	pop	di
	pop	si		; chill out...
	pop	dx
	pop	cx
	pop	bx
	retn

; =============== S U B	R O U T	I N E =======================================

; STORE_PCHAR determines the pathname-element separator and squirrels
; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
;
; ENTRY:
; EXIT:
; NOTE(S):
;   *	Uses <psep_char>, defined in <path_search>.

	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
STORE_PCHAR:
	push	ax
	mov	al,'/'		; is the pathname-element separator
	call	pathchrcmp	; a regular slash?
	jz	short STORE_SLASH
				; if yes, remember slash
	mov	al,'\'
	; 18/03/2023
	;mov	[psep_char],al	; otherwise, remember back-slash
	;pop	ax
	;retn
STORE_SLASH:
	mov	[psep_char],al
	pop	ax
	retn

; =============== S U B	R O U T	I N E =======================================

; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
; EXECPATH, and smooshes them into tpbuf. The caller may supply an
; additional separator to use for breaking up the path-string. Null is the
; default. Once the user-string has been formed, search is invoked to see
; what's out there.
;
; ENTRY:
;   BH			--	additional terminator character
;   SI			--	pointer into pathstring to be dissected
;   DX			--	pointer to stripped filename
; EXIT:
;   AX			--	non-zero (file type), zero (nothing found)
;   SI			--	moves along pathstring from call to call
;   [search_best_buf]	--	name of best file (AX non-zero)
;   [tpbuf]		--	clobbered
; NOTE(S):
;   *	Implicit in this code is the ability to specify when to search
;	the current directory (if at all) through the PATH defined by
;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
;	current directory before the bin and etc directories of drive c).

	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
	
path_crunch:
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	;pushf	; ** ; 18/03/2023
	call	STORE_PCHAR	; figure out pathname separator
	mov	di,TPBUF	; destination of concatenated string
	mov	si,[pathinfo+4]	; "new" pointer to start with
	mov	[pathinfo+2],si	; becomes "old" pointer
	push	ds		; save old segment pointer
	push	word [pathinfo+0]
				; replace with pointer to userpath's
	pop	ds		; segment
	; 26/04/2023
	xor	cl,cl		;AN000; clear flag for later use 3/3/KK	
path_cr_copy:
	lodsb			; get a pathname byte
	or	al,al		; check for terminator(s)
	jz	short path_seg	; null terminates segment & pathstring
	cmp	al,bh
	je	short path_seg	; BH terminates a pathstring segment
	;
	; 18/03/2023
	; MSDOS 6.0 (& 5.0) COMMAND.COM
	call	testkanj	;AN000; 3/3/KK
	jz	short _notkanj2	;AN000; 3/3/KK
	stosb			;AN000; 3/3/KK
	movsb			;AN000; 3/3/KK
	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK	
	jmp	short path_cr_copy
_notkanj2:
	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
	;
	stosb
	jmp	short path_cr_copy

path_seg:
	pop	ds		; restore old data segment
	mov	[pathinfo+4],si	; save "new" pointer for next time
	mov	bl,al		; remember if we saw null or not...
				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
	xor	ax,ax		; in case nothing in pathstr...
	cmp	di,TPBUF	; was there really anything in pathstr?		
	je	short path_cr_leave
				; if nothing was copied, pathstr empty
path_cr_look:
	mov	al,[psep_char]	; form complete pathname
	;
	; 18/03/2023
	; MSDOS 6.0
	or	cl,cl ; *	;AN000; 3/3/KK
	jnz	short path_cr_store
				;AN000; this is a trailing byte of ECS code 3/3/KK
	;
	cmp	al,[di-1]	; add pathname separator for suffix
	je	short path_cr_l1
path_cr_store:
	stosb
path_cr_l1:
	mov	si,dx
path_cr_l2:
	lodsb			; tack the stripped filename onto
	stosb			; the end of the path, up to and
	or	al,al		; including the terminating null
	jnz	short path_cr_l2
	mov	dx,TPBUF	; and look for an appropriate file...	
	mov	word [search_error],BADPMES_PTR
	;invoke search
	call	PSEARCH		; results are in AX & search_best_buf

	; 18/03/2023
;path_cr_leave:
	;or	bl,bl		; did we finish off the pathstring?
	;jz	short path_cr_empty
	;			; null in BL means all gone...
	;popf	; **		; otherwise, plenty left
	;clc
	;jmp	short path_cr_exit
;path_cr_empty:
	;popf	; **
	;stc
;path_cr_exit:

	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
path_cr_leave:
	;popf ; ** ; 18/03/2023
	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
	
path_cr_exit:
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
	retn

;============================================================================
; PATH2.ASM, MSDOS 6.0, 1991
;============================================================================
; 02/10/2018 - Retro DOS v3.0

;----------------------------------------------------------------------------
;   SEARCH, when given a pathname, attempts to find a file with
; one of the following extensions: .com, .exe, .bat (highest to
; lowest priority). Where conflicts arise, the extension with
; the highest priority is favored.
; ENTRY:
;   DX		--	pointer to null-terminated pathname
;   fbuf	--	dma buffer for findfirst/next
; EXIT:
;   AX		--	8)  file found with .com extension
;			4)  file found with .exe extension
;			2)  file found with .bat extension
;			0)  no such file to be found
;   (if AX is non-zero:)
;   [search_best]	identical to AX
;   [search_best_buf]	null-terminated filename
; NOTES:
;   1) Requires caller to have allocated a dma buffer and executed a setdma.
;---------------
; CONSTANTS:
;---------------
SEARCH_FILE_NOT_FOUND	EQU	0
SEARCH_COM		EQU	8
SEARCH_EXE		EQU	4
SEARCH_BAT		EQU	2
FNAME_LEN		EQU	8
FNAME_MAX_LEN		EQU	13
DOT			EQU	'.'
WILDCHAR		EQU	'?'


; =============== S U B	R O U T	I N E =======================================

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h

	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
	
PSEARCH:
	push	cx
	push	dx
	push	di
	push	si
	;pushf	; ** ; 18/03/2023
	push	dx		; check drivespec (save pname ptr)
	mov	di,dx		; working copy of pathname
	mov	si,search_curdir_buf
	xor	dx,dx		; zero means current drive
	cmp	byte [di+1],':'	; is there a drive spec?
	jne	short SEARCH_DIR_CHECK
	mov	dl,[di]		; get the drive byte
	and	dl,0DFh ; ~20h	; uppercase the sucker
	sub	dl,'@' ; 40h	; and convert to drive number
SEARCH_DIR_CHECK:
	mov	ax,Current_Dir*256 ; 4700h
	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
			; DL = drive (0=default,1=A,etc.)
			; DS:SI	points to 64-byte buffer area
	pop	dx		; directory? If we can't we'll		
	jc	short SEARCH_INVALID_DRIVE
				; assume it's a bad drive...
	mov	cx,search_attr	; 13h
				; filetypes to search for
	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
			; CX = search attributes
			; DS:DX	-> ASCIZ filespec
			; (drive,path, and wildcards allowed)
	jc	short SEARCH_NO_FILE
	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
	mov	byte [search_best_buf],ANULL
				; 0 ; nothing's been found, yet
SEARCH_LOOP:
	call	SEARCH_FTYPE	; determine if .com, &c...
	cmp	al,[search_best]
				; better than what we've found so far?
	jle	short SEARCH_NEXT
				; no, look for another	
	mov	[search_best],al
				; found something... save its code	
	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
	;mov	si,FBUF_PNAME
	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
	mov	di,search_best_buf
	mov	cx,FNAME_MAX_LEN ; 13
	cld
	rep	movsb		; save complete pathname representation
	cmp	al,SEARCH_COM	; 8
				; have we found the best of all?	
	je	short SEARCH_DONE
SEARCH_NEXT:			; keep on looking
	mov	cx,search_attr ; 13h
	mov	ax,Find_Next*256 ; 4F00h ; next match
	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
			; [DTA]	= data block from
			; last AH = 4Eh/4Fh call
	jnc	short SEARCH_LOOP
SEARCH_DONE:			; it's all over with...
	mov	al,[search_best]
				; pick best to return with
	; 18/03/2023
	; MSDOS 6.0
	cmp	byte [ext_entered],1
				;AN005; Did user request a specific ext?
	je	short SEARCH_EXIT
				;AN005; no - exit
	mov	al,[ext_entered]
				;AN005; yes - get the real file type back
	mov	[search_best],al
				;AN005; save the real file type
	;
	jmp	short SEARCH_EXIT

SEARCH_INVALID_DRIVE:		; Tell the user path/drive
	mov	dx,[search_error]
				; appropriate error message
	call	std_printf	; and pretend no file found

SEARCH_NO_FILE:			; couldn't find a match
	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
	; 18/03/2023
	xor	ax,ax
SEARCH_EXIT:
	;popf	; ** ; 18/03/2023
	pop	si
	pop	di
	pop	dx
	pop	cx
	retn

; =============== S U B	R O U T	I N E =======================================

; SEARCH_FTYPE determines the type of a file by examining its extension.
;
; ENTRY:
;   fbuf    --	dma buffer containing filename
; EXIT:
;   AX	    --	file code, as given in search header
; NOTE(S):
;   *	Implicit assumption that NULL == search_file_not_found

	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

SEARCH_FTYPE:
	push	di
	push	si
	;mov	ax,ANULL ; 0	; find the end of the filename
	; 18/02/2023
	xor	ax,ax ; ax = 0		
	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
	;mov	di,FBUF_PNAME
	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
	mov	cx,FNAME_MAX_LEN ; 13
	cld
	repnz	scasb		; search for the terminating null
	jnz	short FTYPE_EXIT
				; weird... no null byte at end
	sub	di,5		; . + E + X + T + NULL

	; Compare .COM

	mov	si,comext ; ".COM"
	mov	ax,di
	cmpsw
	jnz	short FTYPE_EXE
	cmpsw
	jnz	short FTYPE_EXE
	;mov	ax,8
	mov	ax,SEARCH_COM	; success!
	jmp	short FTYPE_EXIT

	; Compare .EXE
FTYPE_EXE:			; still looking... now for '.exe'
	mov	di,ax
	mov	si,exeext ; ".EXE"
	cmpsw
	jnz	short FTYPE_BAT
	cmpsw
	jnz	short FTYPE_BAT
	;mov	ax,4
	mov	ax,SEARCH_EXE	; success!
	jmp	short FTYPE_EXIT

	; Compare .BAT
FTYPE_BAT:			; still looking... now for '.bat'
	mov	di,ax
	mov	si,batext ; ".BAT"
	cmpsw
	jnz	short FTYPE_FAIL
	cmpsw
	jnz	short FTYPE_FAIL
	;mov	ax,2
	mov	ax,SEARCH_BAT	; success!
	jmp	short FTYPE_EXIT

FTYPE_FAIL:			; file doesn't match what we need
	;mov	ax,ANULL ; 0
	; 18/03/2023
	sub	ax,ax  ; ax = 0
FTYPE_EXIT:
	; 18/03/2023
	; MSDOS 6.0
	cmp	byte [ext_entered],1
				;AN005; was an extension entered?
	jz	short FTYPE_DONE
				;AN005; no - exit
	;cmp	ax,ANULL	;AN005; was any match found
	and	ax,ax  ; ax = 0 ?
	jz	short FTYPE_DONE
				;AN005; no - exit
	mov	[ext_entered],al
				;AN005; save the match type found
	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
FTYPE_DONE:
	pop	si
	pop	di
	retn

; =============== S U B	R O U T	I N E =======================================

; STRIP copies the source string (argv[0]) into the destination buffer,
; replacing any extension with wildcards.
;
; ENTRY:
;	BX	--	maximum length of destination buffer
;	DS:SI	--	address of destination buffer
;	argv[0] --	command name to be stripped
; EXIT:
;	CF	--	set if failure, clear if successful
; NOTE(S):

	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

STRIP:
	push	ax
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	;pushf	; ** ; 18/03/2023
		
	; 05/05/2023
	; MSDOS 6.0
	mov	byte [ext_entered],1
				;AN005; assume no extension on file name
	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	dx,[ARG_ARGV]
	;mov	dx,ds:arg.argv[0].argpointer
				; save pointer to beginning of argstring
	;mov	dx,[ARGV0_ARGPOINTER]
	mov	dx,[ARG+ARGV_ELE.argpointer]
	;mov	di,ds:arg.argv[0].argstartel
				; beginning of last pathname element
	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
	mov	di,[ARG+ARGV_ELE.argstartel]
	cmp	byte [di],0	; *STARTEL == NULL means no command
	je	short STRIP_ERROR
	mov	cx,dx		; compute where end of argstring lies
	;add	cx,ds:arg.argv[0].arglen
	;add	cx,[ARGV0_ARGLEN]
	add	cx,[ARG+ARGV_ELE.arglen]
	sub	cx,di		; and then find length of last element
	inc	cx		; include null as well
	mov	al,'.'
	;mov	al,DOT		; let's find the filetype extension
	cld
	repnz	scasb		; wind up pointing to either null or dot

	; 18/03/2023
	; MSDOS 6.0
	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
	mov	al,0 ; 18/03/2023
	;mov	byte [ext_entered],0
	mov	[ext_entered],al
				;AN005; we found an extension
	;;mov	al,ANULL	;AN005; continue scanning until the
	;mov	al,0
	repnz	scasb		;AN005; end of line is reached.
PROCESS_EXT:
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	cx,di		; pointer to end of argstring yields
	sub	cx,dx		; number of bytes to be copied
	sub	bx,4		; can argstring fit into dest. buffer?
	cmp	cx,bx
	jg	short STRIP_ERROR
				; if not, we must have a bad pathname
	mov	di,si		; destination buffer
	mov	si,dx		; source is beginning of pathname
	cld
	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg

	; 18/03/2023
	; MSDOS 6.0
	cmp	byte [ext_entered],1
				;AN005; if an extension was entered
	jne	short SKIP_WILDS
				;AN005;    don't set up wildcard ext.

	; MSDOS 3.3 (& MSDOS 6.0)
	dec	di		; overwrite null or dot
	stosb			; with a dot
	mov	al,'?'
	;mov	al,WILDCHAR	; now add wildcards
	stosb
	stosb
	stosb
	mov	al,0
	;mov	al,ANULL	; and a terminating null	
	stosb
SKIP_WILDS:
	;popf	; ** ; 18/03/2023
	clc
	jmp	short STRIP_EXIT ; chill out...

STRIP_ERROR:
	;popf	; ** ; 18/03/2023
	stc
STRIP_EXIT:
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
	pop	ax
	retn

; =============== S U B	R O U T	I N E =======================================

; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
;
; structure in newly allocated memory. The argv[] structure is found at the
; beginning of this area. The caller indicates how much extra space is
; needed in the resulting structure; Save_Args returns a segment number and
; an offset into that area, indicating where the caller may preserve its own
; data. Note that <argvcnt> can be found at <offset-2>.
; ENTRY:
;   BX	    --	size (in bytes) of extra area to allocate
; EXIT:
;   AX	    --	segment of new area.
;   CF	    --	set if unable to save a copy.
; NOTE(S):
;   1)	The allocated area will be AT LEAST the size requested -- since
;	the underlying MSDOS call, <alloc> returns an integral number of
;	paragraphs.
;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
;	as the caller of Save_Args requests.
;   3)	AX is undefined if CF indicates an error.

	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

SAVE_ARGS:
	push	bx
	push	cx
	push	dx
	push	di
	push	si
	push	bp
	; 01/05/2023
	; 26/04/2023
	;pushf ; **
	;add	bx,1363		; space for arg structure, round up
	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
	mov	cl,4		; to paragraph size and convert
	shr	bx,cl		; size in bytes to size in paragraphs
	mov	ax,ALLOC*256 ; 4800h
	int	21h	; DOS -	2+ - ALLOCATE MEMORY
			; BX = number of 16-byte paragraphs desired
	jc	short SAVE_ERROR ; ***
	mov	bp,ax		; save segment id
	push	es		; save TRANGROUP address
	mov	es,ax		; switch to new memory segment
	; assume es:nothing
	;mov	cx,1348		; get back structure size
	mov	cx,ARG_UNIT.SIZE
	xor	di,di		; destination is new memory area
	;mov	si,ARG_ARGV
	mov	si,ARG		; source is arg structure
	rep	movsb		; move that sucker!
	;mov	cx,arg.argvcnt 	; adjust argv pointers
	;mov	cx,[ARG_ARGVCNT]
	mov	cx,[ARG+ARG_UNIT.argvcnt]
	xor	ax,ax		; base address for argv_calc

;	Bugbug:	What did they mean by this?
;	Note that the replacement line produces exactly the same code.
;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
;	mov	SI, OFFSET TRANGROUP:arg

	;mov	si,ARG_ARGV
	mov	si,ARG	
SAVE_PTR_LOOP:
	dec	cx		; exhausted all args?
	jl	short SAVE_DONE
	mov	bx,cx		; get arg index and
	call	argv_calc	; convert to a pointer
	;mov	dx,ds:arg.argv[bx].argpointer
	;mov	dx,[ARG_ARGV+bx]
	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
	sub	dx,si		; adjust argpointer
	;mov	es:argv[BX].argpointer,dx
	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
	mov	[es:bx],dx
	;mov	dx,ds:arg.argv[bx].argstartel
	;mov	dx,[ARGV0_ARGSTARTEL+bx]
	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
	sub	dx,si		; and adjust argstartel
	;mov	es:argv[bx].argstartel,dx
	;mov	[es:bx+3],dx
	mov	[es:bx+ARGV_ELE.argstartel],dx
	;mov	dx,ds:arg.argv[bx].arg_ocomptr
	;mov	dx,[ARGV0_OCOMPTR+bx]
	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
	sub	dx,si		; and adjust arg_ocomptr
	;mov	es:argv[bx].arg_ocomptr,dx
	;mov	[es:bx+9],dx
	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
	jmp	short SAVE_PTR_LOOP
SAVE_DONE:
	pop	es		; back we go to TRANGROUP
	; assume es:nothing
	mov	ax,bp		; restore segment id
	; 26/04/2023
	; cf = 0 ; *
	;jmp	short SAVE_OK

	; 26/04/2023
;SAVE_ERROR:
;	; 26/04/2023
;	;popf ; **
;	stc
;	jmp	short SAVE_EXIT

SAVE_OK:
	; 26/04/2023
	;popf ; **
	; 26/04/2023
	; cf = 0 ; *
	;clc
SAVE_EXIT:
SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
	pop	bp
	pop	si
	pop	di
	pop	dx
	pop	cx
	pop	bx
answ_no:	; 26/04/2023
	retn

;============================================================================
; TUCODE.ASM, MSDOS 6.0, 1991 (1)
;============================================================================
; 02/10/2018 - Retro DOS v3.0

; Title	COMMAND Language midifiable Code Transient

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h

; =============== S U B	R O U T	I N E =======================================

; ****************************************************************
; *
; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
; *
; * FUNCTION:	 Delete files based on user parsed input. Prompt
; *		 user for Y/N if necessary. If an error occurs,
; *		 set up an error message and go to CERROR.
; *
; * INPUT:	 FCB at 5ch set up with filename(s) entered
; *		 Current directory set to entered directory
; *
; * OUTPUT:	 none
; *
; ****************************************************************
;
; ARE YOU SURE prompt when deleting *.*

	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

notest2:
	mov	cx,11
	mov	si,FCB+1 ; 5Dh
ambspec:
	lodsb
	cmp	al,'?'
	jne	short allfil
	loop	ambspec
allfil:
	; 19/03/2023
	;cmp	cx,0
	or	cx,cx
	jnz	short noprmpt
askagn:	
	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
	call	std_printf
	mov	si,80h
	mov	dx,si
	mov	word [si],120	; zero length
	;mov	ax,0C0Ah
	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
			; AL must be 01h,06h,07h,08h or 0Ah.
	lodsw
	or	ah,ah
	jz	short askagn
	call	scanoff
	; 19/03/2023
	; MSDOS 6.0
	call	char_in_xlat	; Convert to upper case
	;retc			; return if function not supported
	; 19/03/2023
	;jnc	short check_yn
;answ_no:
	;retn
	jc	short answ_no

	; 19/03/2023
	; AL = 0 if it was (country depended) NO character
	; AL = 1 if it was (country depenced) YES character

	; MSDOS 3.3
	;call	UPCONV

	; 19/03/2023	
	; MSDOS 3.3 (& MSDOS 6.0)
	;cmp	al,[CAPITAL_N]
	;jne	short CHECK_Y
	;retn
;CHECK_Y:
	;cmp	al,[CAPITAL_Y]
	;pushf
	;call	CRLF2
	;popf
	;jne	short ASKAGN

check_yn:
	; 19/03/2023
	;cmp	al,0	; NO character
	or	al,al
	jz	short answ_no
	;cmp	al,1	 ;YES character
	dec	al ; 1 -> 0 --> zf = 1
	pushf
	call	CRLF2
	popf
	jnz	short askagn
noprmpt:
	mov	ah,FCB_Delete ; 13h
	mov	dx,FCB ; 5Ch
	int	21h	; DOS -	DELETE FILE via	FCB
			; DS:DX	-> FCB with filename field filled with
			; template for deletion ('?' wildcard allowed,but not '*')
			; Return: AL = 00h file	found,FFh file	not found
	inc	al
	jz	short eraerr
	; 26/04/2023
	;call	RestUDir
;answ_no:
	;retn
	jmp	RestUDir ; 26/04/2023

	; 19/03/2023
	; MSDOS 6.0
eraerr:
	;invoke	set_ext_error_msg
				;AN022; set up the extended error
	call	Set_Ext_Error_Msg
	push	dx		;AN022; save message
	;invoke	RESTUDIR
	call	RestUDir
	pop	dx		;AN022; restore message
	
	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
				;AN022; convert no more files to
	jne	short cerrorj2	;AN022;  file not found
	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
				;AN000; get message number in control block
cerrorj2:
	jmp	cerror
	
	; 19/03/2023
	; MSDOS 3.3
;ERAERR:	
	;mov	ah,Set_DMA ; 1Ah
	;mov	dx,FCB ; 5Ch
	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
	;			; DS:DX	-> disk	transfer buffer
	;mov	ah,Dir_Search_First ; 11h
	;int	21h		; DOS -	SEARCH FIRST USING FCB
	;			; DS:DX	-> FCB
	;push	ax
	;call	RESTUDIR
	;pop	ax
	;mov	dx,FNOTFOUNDPTR
	;inc	al
	;jz	short CERRORJ
	;mov	dx,ACCDENPTR
	;jmp	CERROR

	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h

; ****************************************************************
; *
; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
; *
; * FUNCTION:	 Delete files based on user parsed input. Prompt
; *		 user for Y/N where necessary. If an error occurs
; *		 set up and error message and transfer control
; *		 to CERROR.
; *
; * INPUT:	 FCB at 5Ch set up with filename(s) entered
; *		 Current directory set to entered directory
; *
; * OUTPUT:	 none
; *
; ****************************************************************

	; 19/03/2023
slashp_erase:				;AN000; entry point
	;invoke	build_dir_string	;AN000; set up current directory string for output
	call	build_dir_string

	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
	;mov	dx,offset trangroup:destdir
	mov	dx,DESTDIR		;AN000; use Destdir for target
	int	21h			;AN000;

	;mov	ah,11h
	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
	int	21h			;AN000;
	inc	al			;AN000; did an error occur
	;jz	short eraerr		;AN022; go to error exit
	; 26/04/2023
	jnz	short delete_prompt_loop

	; 26/04/2023
stop_del:
	jmp	short eraerr		;AN022; go to error exit - need long jmp

delete_prompt_loop:			;AN000;
	;mov	si,offset trangroup:destdir+1
	mov	si,DESTDIR+1		;AN000; set up FCB as source
	;mov	di,offset trangroup:dest
	mov	di,DEST			;AN000; set up dest as target
	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
	stosb				;AN000;   of DEST
	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
	call	FCB_TO_ASCZ

slashp_askagn:				;AN000;
	call	CRLF2			;AN000; print out carriage return, line feed
	;mov	dx,offset trangroup:bwdbuf
	mov	dx,BWDBUF		;AN000; print out current directory string
	mov	bx,dx			;AN000; get string pointer in bx
	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
					;AN000; see if only D:\,0
	jnz	short not_del_root	;AN000; no continue
	mov	byte [bx+2],END_OF_LINE_OUT ; 0
					;AN000; yes, get rid of \ ;
not_del_root:				;AN000;
	mov	[string_ptr_2],dx 	;AN000;
	;mov	dx,offset trangroup:string_buf_ptr
	mov	dx,string_buf_ptr	;AN000;
	;invoke	std_printf		;AN000;
	call	std_printf
	;mov	dx,offset trangroup:dest
	mov	dx,DEST			;AN000; print out file name string
	mov	[string_ptr_2],dx 	;AN000;
	;mov	dx,offset trangroup:string_buf_ptr
	mov	dx,string_buf_ptr	;AN000;
	;invoke	std_printf		;AN000;
	call	std_printf
	;mov	dx,offset trangroup:Del_Y_N_Ptr
	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
	;invoke	std_printf		;AN000;
	call	std_printf

;;M029	mov	si,80H			;AN000; set up buffer for input
;;M029	mov	dx,si			;AN000;
;;M029	mov	word ptr [si],combuflen ;AN000;
;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
;;M029	int	21h			;AN000; get input from the user
;;M029	lodsw				;AN000;
;;M029	or	ah,ah			;AN000; was a character entered?
;;M029	jz	short slashp_askagn	;AN000; no - ask again
;;M029	invoke	scanoff 		;AN000; scan off leading delimiters

;	Get a single character input.

	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
	mov	ax,0C01h
	int	21h			;M029

	call	char_in_xlat		;AN000; yes - upper case it
	;retc				;AN000; return if function not supported
	; 19/03/2023
	jnc	short slashp_check_yn
slashp_ans_no:
	retn

slashp_check_yn:
	; 19/03/2023
	; AL = 0 if it was (country depended) NO character
	; AL = 1 if it was (country depenced) YES character

	;cmp	al,capital_n		;AN000; was it no?
	;cmp	al,0
	and	al,al ; 0
	jz	short next_del_file	;AN000; yes - don't delete file
	;cmp	al,capital_y		;AN000; was it yes?
	;cmp	al,1
	dec	al  ; 1-> 0 --> zf = 1
	;jz	short delete_this_file	;AN000; yes - delete the file
	;jmp	short slashp_askagn	;AN000; it was neither - ask again
	; 19/03/2023
	jnz	short slashp_askagn

delete_this_file:			;AN000;
	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
	;mov	dx,offset trangroup:destdir
	mov	dx,DESTDIR		;AN000; use Destdir for target
	int	21h			;AN000;
	inc	al			;AN000; did an error occur?
	jnz	short next_del_file	;AN000; no - get next file
;
;M041; Begin changes
; We got an error deleting the file. If this is access denied, we can go on
;to the next file after printing an error message.
;
	;invoke	Get_ext_error_number	;see what error we got
	call	get_ext_error_number
	cmp	ax,ERROR_ACCESS_DENIED ; 5
					;is it access denied?
	jne	short stop_del		;no, some other error
	;invoke	CrLf2			;print a CR-LF
	call	CRLF2
	;invoke set_ext_error_msg	;error message
	call	Set_Ext_Error_Msg
	;invoke	std_eprintf		;"Access denied"
	call	std_eprintf
	; 26/04/2023
	;jmp	short next_del_file	;try next file
	; 26/04/2023
;stop_del:
;;
;;M041; End changes
;;
;	jmp	eraerr			;AN022; go to error exit - need long jmp

next_del_file:				;AN000;
;
; M050 - begin
; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
;       with /protect+ and /light+ makes it intercept all
;       deletes. This hook does not save and restore the DTA correctly.
;       They save the DWORD in a WORD by mistake! They save both the
;       segment and the offset in the SAME variable (WORD)!!!
;
	mov	ah,Set_DMA ; 1Ah
	;mov	dx,offset trangroup:destdir
	mov	dx,DESTDIR
	int	21h
;
; M050 - end

	mov	ah,Dir_Search_Next ; 12h
					;AN000; search for another file
	mov	dx,FCB	; 5Ch		;AN000;
	int	21h			;AN000;
	inc	al			;AN000; was a file found?
	;jz	short slash_p_exit	;AN000; no - exit
	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
	; 26/04/2023
	jnz	short delete_prompt_loop

slash_p_exit:
	;invoke	get_ext_error_number	;AN022; get the extended error number
	call	get_ext_error_number
	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
	jz	short good_erase_exit 	;AN022; yes - clean exit
	jmp	extend_setup		;AN022; go issue error message

good_erase_exit:
	;invoke	restudir		;AN000; we're finished - restore user's dir
	call	RestUDir
	;call	CRLF2			;AN000; print out carriage return, line feed
	;retn				;AN000; exit
	; 19/03/2023
	jmp	CRLF2

; =============== S U B	R O U T	I N E =======================================

; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"

	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
_ECHO:
	call	ON_OFF
	jb	short DOEMES
	mov	ds,[RESSEG]
	jnz	short ECH_OFF
	or	byte [EchoFlag],1
	retn

ECH_OFF:
	and	byte [EchoFlag],0FEh
	retn

	; 19/03/2023
	; MSDOS 6.0 (& MSDOS 5.0)
;CERRORJ:
	;jmp	cerror

; There was no discrenable ON or OFF after the ECHO. If there is nothing but
; delimiters on the command line, we issue the ECHO is ON/OFF message.

DOEMES:
	; 19/03/2023
	; MSDOS 6.0
	;cmp	cl,0		;AC000; was anything on the line?
	and	cl,cl
	jz	short PECHO	; just display current state.
	mov	dx,82h		; Skip one char after "ECHO"
	call	CRPRINT
	jmp	CRLF2

	; 19/03/2023
	; MSDOS 3.3
	;call	MOVE_TO_FIRST_ARG
	;jz	short PECHO
	;mov	dx,82h
	;call	CRPRINT
	;jmp	CRLF2

PECHO:
	; MSDOS 3.3 (& MSDOS 6.0)
	mov	ds,[RESSEG]
	mov	bl,[EchoFlag]
	push	cs
	pop	ds
	and	bl,1
	mov	dx,EchoMes_Ptr
	jmp	short PYN

; ---------------------------------------------------------------------------

	; 19/03/2023
	; MSDOS 3.3
CERRORJ:
	jmp	cerror

; =============== S U B	R O U T	I N E =======================================

	; 19/03/2023
	; MSDOS 3.3
;MOVE_TO_FIRST_ARG:
	;mov	si,81h
	;call	SCANOFF
	;cmp	al,0Dh
	;retn

; =============== S U B	R O U T	I N E =======================================

CNTRLC:
	call	ON_OFF
	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
	jc	short PCNTRLC
	jnz	short CNTRLC_OFF
	mov	dl,1
	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
			; AL = 00h get state / 01h set state / 02h set AND get
			; DL = 00h for OFF or 01h for ON
	retn

; ---------------------------------------------------------------------------

CNTRLC_OFF:
	xor	dl,dl
	int	21h		; Turn off ^C check
	retn

; ---------------------------------------------------------------------------

PCNTRLC:
	; 19/03/2023
	; MSDOS 6.0
	;cmp	cl,0		;AC000; rest of line blank?
	or	cl,cl
	jnz	short CERRORJ 	; no, oops!

	; 19/03/2023
	; MSDOS 3.3
	;call	MOVE_TO_FIRST_ARG
	;jnz	short CERRORJ
;pccont:
	; MSDOS 3.3 (& MSDOS 6.0)
	xor	al,al
	int	21h		; get Ctrl-Break state (ah=33h)
	mov	bl,dl
	mov	dx,CtrlcMes_Ptr

; ---------------------------------------------------------------------------

PYN:	; write "ON" or "OFF" state 

	; 26/04/2023
	; 19/03/2023
	; MSDOS 3.3
	;call	STD_PRINTF
	;mov	dx,ONMES_PTR	;AC000; get ON pointer
	;or	bl,bl
	;jnz	short PRINTVAL
	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
	
	; 26/04/2023
	; 19/03/2023
	; MSDOS 6.0
	mov	si,ONMES_PTR
	or	bl,bl
	jnz	short PRINTVAL
	mov	si,OFFMES_PTR
PRINTVAL:
	; 19/03/2023
	; MSDOS 3.3
	;jmp	STD_PRINTF

	; 19/03/2023
	; MSDOS 6.0
	push	dx		;AN000; save offset of message block
	mov	bx,dx		;AN000; save offset value
	lodsw			;AN000; get message number of on or off
	mov	dh,util_msg_class ; -1 ; 0FFh
				;AN000; this is a utility message
	call	TSYSGETMSG	;AN000; get the address of the message
	;add	bx,5
	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
	
	mov	[bx],si		;AN000; put the offset in the message block
	pop	dx		;AN000; get message back
	call	std_printf	;AC000; go print message
	mov	word [bx],0	;AN000; zero out message pointer
	retn			;AN000; exit

; =============== S U B	R O U T	I N E =======================================

	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
VERIFY:
	call	ON_OFF
	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
	jc	short PVERIFY
	jnz	short VER_OFF
	int	21h	; DOS -	SET VERIFY FLAG
			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
	retn

; ---------------------------------------------------------------------------

VER_OFF:
	dec	al
	int	21h		; Turn off verify after write
	retn

; ---------------------------------------------------------------------------

PVERIFY:
	; 19/03/2023
	; MSDOS 6.0
	;cmp	cl,0		;AC000; is rest of line blank?
	and	cl,cl
	jnz	short CERRORJ 	; nope...

	 ;19/03/2023
	; MSDOS 3.3
	;call	MOVE_TO_FIRST_ARG
	;jnz	short CERRORJ

	mov	ah,Get_Verify_On_Write ; 54h
	int	21h		; DOS -	2+ - GET VERIFY	FLAG
				; Return: AL = 00h if flag OFF
				; AL = 01h if flag ON
	mov	bl,al
	mov	dx,VeriMes_Ptr
	jmp	short PYN

; =============== S U B	R O U T	I N E =======================================

; ****************************************************************
; *
; * ROUTINE:	 ON_OFF
; *
; * FUNCTION:	 Parse the command line for an optional ON or
; *		 OFF string for the BREAK, VERIFY, and ECHO
; *		 routines.
; *
; * INPUT:	 command line at offset 81H
; *		 PARSE_BREAK control block
; *
; * OUTPUT:	 If carry is clear
; *		    If ON is found
; *		       Zero flag set
; *		    If OFF is found
; *		       Zero flag clear
; *		 If carry set
; *		    If nothing on command line
; *		       CL set to zero
; *		    If error
; *		       CL contains error value from parse
; *
; ****************************************************************

	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
ON_OFF:
	mov	si,81h

	; 19/03/2023
	; MSDOS 3.3
	;call	SCANOFF		; scan off leading blanks & equal
	;cmp	al,0Dh		; are we at end of line?
	;je	short BAD_ONF	; yes, return error
	;lodsw
	;or	ax,2020h	; convert to lowercase
	;cmp	ax,6E6Fh ;'on'
	;je	short ON_CHECK
	;cmp	ax,666Fh ;'of'
	;jne	short BAD_ONF
	;lodsb
	;or	al,20h		; convert to lowercase		
	;cmp	al,66h	 ; 'f'
	;jne	short BAD_ONF	
	;or	al,66h ; or al,'f'
	;jmp	short OFF_CHECK
;ON_CHECK:
	;xor	al,al
;OFF_CHECK:
	;lahf
	;mov	bx,ax
	;call	SCANOFF		; scan off leading blanks & equal
	;cmp	al,0Dh		; are we at end of line?	
	;jne	short BAD_ONF	; no, return error
	;mov	ax,bx
	;sahf
	;clc
	;retn

	; 19/03/2023
	; MSDOS 6.0
scan_on_off:			;AN032; scan off leading blanks & equal
	lodsb			;AN032; get a char
	;cmp	al,blank	;AN032; if whitespace
	cmp	al,20h
	je	short scan_on_off
				;AN032;    keep scanning
	cmp	al,tab_chr	;AN032; if tab
	;cmp	al,09h
	je	short scan_on_off
				;AN032;    keep scanning
	;cmp	al,equal_chr	;AN032; if equal char
	cmp	al,'=' ; 3Dh
	je	short parse_on_off
				;AN032;    start parsing
	dec	si		;AN032; if none of above - back up

parse_on_off:			;AN032;    and start parsing
	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
	xor	cx,cx		;AN000; clear cx,dx
	xor	dx,dx		;AN000;
	call	cmd_parse	;AC000; call parser
	;cmp	ax,-1 ; 0FFFFh
	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
	je	short BADONF	;AC000; yes, return error
	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
	;cmp	ax,0
	and	ax,ax ; ax = 0 ?
	jz	short on_off_there
				;AN000; no - continue
	mov	cx,ax		;AN000; yes - set cl to error code
	jmp	short BADONF	;AN000; return error

on_off_there:
	cmp	byte [PARSE1_CODE],-1 ; 0FFh
				;AN014; was a valid positional present?
	jnz	short good_on_off
				;AN014; yes - continue
	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
	;mov	cx,10 ; 0Ah
	jmp	short BADONF	;AN014; return error

good_on_off:				;AN014;
	xor	ax,ax		;AC000; set up return code for
	or	al,[PARSE1_CODE]
				;AC000;    ON or OFF in AX
	pushf			;AN000; save flags
	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
	xor	dx,dx		;AN000;
	call	cmd_parse	;AN000; call parser
	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
	;cmp	ax,-1 ; 0FFFFh
	jne	short BADONF_flags
				;AN000; NO, return error
	popf			;AN000; restore flags
	clc			;AC000; no error
	;jmp	short on_off_end
				;AN000; return to caller
	; 26/04/2023
	retn

BADONF_flags:
	mov	cx,ax
	popf

; ---------------------------------------------------------------------------

; No discernable ON or OFF has been found. Put an error message pointer in DX
; and return the error

BADONF:
	mov	dx,bad_on_off_ptr
	stc
on_off_end:
	retn

; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
%if 0

;============================================================================
; TCMD1B.ASM, MSDOS 6.0, 1991
;============================================================================
; 02/10/2018 - Retro DOS v3.0

; Print volume ID info

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h

; ---------------------------------------------------------------------------

PRINTVOL:
	push	ax		; AX return from SEARCH_FIRST for VOL ID
	mov	al,[FCB] ; 5Ch	; get drive letter
	add	al,'@'
	cmp	al,'@'
	jnz	short DRVOK
	mov	al,[CURDRV]
	add	al,[CAPITAL_A]
DRVOK:
	mov	[VOL_DRV],al	; get drive letter into argument
	pop	ax		; get return code back
	mov	dx,NOVOL ; "has	no label" 
	or	al,al		; volume label found?
	jnz	short PRINTVOL2	; print no volume message
GOODVOL:
	; MSDOS 3.3
	mov	di,CHARBUF
	mov	dx,di
	mov	si,IS	; "is "
	call	STRCPY
	dec	di
	mov	si,DIRBUF+8
	mov	cx,11
	rep	movsb
	xor	ax,ax
	;xor	al,al  ; MSDOS 6.0
	stosb			; store a zero to terminate the string
PRINTVOL2:
	mov	[VOLNAME_ADDR],dx
	mov	dx,VOLMESPTR
	jmp	PRINTF_CRLF

	; MSDOS 6.0
;drvok:
;	mov	vol_drv,al	;AC000; get drive letter into argument
;	pop	ax		;AC000; get return code back
;	or	al,al		;AC000; volume label found?
;	jz	Get_vol_name	;AC000; volume label exists - go get it
;	mov	dx,offset trangroup:VolMes_ptr_2 
;				;AC000; set up no volume message
;	jmp	short print_serial ;AC000; go print it
;
;Get_vol_name:
;	mov	di,offset trangroup:charbuf
;	mov	dx,di
;	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
;	mov	cx,11				;AN000;  3/3/KK
;	rep	movsb				;AN000;  3/3/KK
;
;	xor	al,al		;AC000; store a zero to terminate the string
;	stosb
;	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
;
;PRINT_SERIAL:
;
;; Attempt to get the volume serial number from the disk.  If an error
;; occurs, do not print volume serial number.
;
;	push	dx		;AN000; save message offset
;	mov	ax,(GetSetMediaID SHL 8) 
;				;AC036; Get the volume serial info
;	mov	bl,DS:[FCB]	;AN000; get drive number from FCB
;	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
;	int	21h		;AN000; do the call
;	pop	dx		;AN000; get message offset back
;	jc	printvol_end	;AN000; if error, just go print label
;	call	std_printf	;AC000; go print volume message
;	mov	al,blank	;AN051; Print out a blank
;	invoke	print_char	;AN051;   before volume message
;	mov	dx,offset trangroup:VolSerMes_ptr 
;				;AN000; get serial number message
;printvol_end:
;	jmp	std_printf	;AC000; go print and exit

%endif

;============================================================================
; TUCODE.ASM, MSDOS 6.0, 1991 (2)
;============================================================================
; 02/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh

; =============== S U B	R O U T	I N E =======================================

	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
	
PRINT_DATE:
	; 20/03/2023
	; MSDOS 3.3
	;push	es
	;push	di
	;push	cs
	;pop	es
	;mov	di,ARG_BUF
	;mov	ah,Get_Date ; 2Ah
	;int	21h	; DOS -	GET CURRENT DATE
	;		; Return: DL = day,DH = month,	CX = year
	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
	;cbw
	;call	GETDATE
	;call	P_DATE
	;xor	al,al
	;stosb
	;mov	dx,ARG_BUF_PTR
	;call	STD_PRINTF
		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
	;pop	es ; !!??!! 
	;pop	di
	;retn

	; 20/03/2023
	; MSDOS 6.0
	push	es
	push	di
	push	cs
	pop	es
	call	GetDate 		; get date
	xchg	dh,dl			;AN000; switch month & day
	mov	[promptDat_yr],cx 	;AC000; put year into message control block
	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
	mov	dx,promptdat_ptr	;AC000; set up message for output
	call	std_printf
	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
	pop	di			;AC000; restore di,es
	pop	es			;AC000;
	retn

; ---------------------------------------------------------------------------

	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;GETDATE:
	; 21/03/2023
	; MSDOS 3.3
	;mov	si,ax
	;shl	si,1
	;add	si,ax
	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
	;mov	bx,cx
	;mov	cx,3
	;rep	movsb
	;mov	al,' '
	;stosb
	;retn

	; 21/03/2023
	; MSDOS 6.0

; Do GET DATE system call and set up 3 character day of week in ARG_BUF
; for output. Date will be returned in CX,DX.

GetDate:
	mov	di,Arg_Buf		;AC000; target for day of week
	mov	ah,Get_Date ;2Ah	;AC000; get current date
	int	21h			;AC000; Get date in CX:DX
	cbw				;AC000;
	push	cx			;AN000; save date returned in
	push	dx			;AN000;  CX:DX
	mov	si,ax
	shl	si,1
	add	si,ax			; SI=AX*3
	mov	cx,si			;AN000; save si
	mov	ax,[WeekTab]		;AN000; get message number of weektab
	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
	push	di			;AN000; save argument buffer
	call	TSYSGETMSG		;AN000; get the address of the message
	pop	di			;AN000; retrieve argument buffer
	add	si,cx			;AC000; get day of week
	mov	cx,3
  	rep	movsb
	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
	stosb
	pop	dx			;AN000; get back date
	pop	cx			;AN000;
	retn

; =============== S U B	R O U T	I N E =======================================

	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 6.0

; This routine determines whether the character in AL is a
; Yes or No character. On return, if AL=0, the character is
; No, if AL=1, the character is Yes.

;	assume	ds:trangroup

char_in_xlat:	; proc	near
	; 21/03/2023
	mov	dl,al			;AC000; get character into DX
	xor	dh,dh			;AC000;
	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
	mov	ax,6523h
	int	21h			;AC000;
	retn

;char_in_xlat	endp

;============================================================================
; TENV.ASM, MSDOS 6.0, 1991
;============================================================================
; 02/10/2018 - Retro DOS v3.0

;	Environment utilities and misc. routines

; MSDOS 6.0
; ****************************************************************
; *
; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
; *
; * FUNCTION:	 This routine returns the upper case equivalent of
; *		 the character in AL from the file upper case table
; *		 in DOS if character if above  ascii 128, else
; *		 subtracts 20H if between "a" and "z".
; *
; * INPUT:	 AL	      char to be upper cased
; *		 FUCASE_ADDR  set to the file upper case table
; *
; * OUTPUT:	 AL	      upper cased character
; *
; ****************************************************************
;
;assume	ds:trangroup				;AN000;
;
;upconv	proc	near				;AN000;
;
;	cmp	al,80h				;AN000;  see if char is > ascii 128
;	jb	oth_fucase			;AN000;  no - upper case math
;	sub	al,80h				;AN000;  only upper 128 chars in table
;	push	ds				;AN000;
;	push	bx				;AN000;
;	mov	ds,[resseg]			;AN000;  get resident data segment
;assume	ds:resgroup				;AN000;
;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
;	add	bx,2				;AN000;  skip over first word
;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
;	pop	bx				;AN000;
;	pop	ds				;AN000;
;assume	ds:trangroup				;AN000;
;	jmp	short upconv_end		;AN000;  we finished - exit
;
;oth_fucase:					;AN000;
;	cmp	al,small_a			;AC000; if between "a" and "z",
;	jb	upconv_end			;AC000;     subtract 20h to get
;	cmp	al,small_z			;AC000;    upper case equivalent.
;	ja	upconv_end			;AC000;
;	sub	al,20h				;AC000; Change lower-case to upper
;
;upconv_end:					;AN000;
;	ret
;
;upconv	endp					;AN000;


; =============== S U B	R O U T	I N E =======================================

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h

; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
%if 0

UPCONV:
	cmp	al,80h
	jb	short OTH_UCASE
	sub	al,80h
	push	ds
	push	bx
	mov	ds,[RESSEG]
	lds	bx,[UPPERCASETBL]
	add	bx,2
	xlat
	pop	bx
	pop	ds
	jmp	short UPCONV_RETN

OTH_UCASE:
	cmp	al,'a'
	jb	short UPCONV_RETN
	cmp	al,'z'
	ja	short UPCONV_RETN
	sub	al,20h

UPCONV_RETN:
	retn

%endif

;============================================================================
; COPY.ASM, MSDOS 6.0, 1991
;============================================================================
; 01/10/2018 - Retro DOS v3.0

;	title	COMMAND COPY routines.

;/*
; *                      Microsoft Confidential
; *                      Copyright (C) Microsoft Corporation 1991
; *                      All Rights Reserved.
; */

;***	COPY.ASM

;Source files:  copy.asm, copypr1.asm, copypr2.asm


;***	MODIFICATION HISTORY

;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
;11/02/83 EE  Commented out the code in CPARSE which added drive designators
;	     to tokens which begin with path characters so that PARSELINE
;	     will work correctly.
;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
;	     individual tokens. That distinction is no longer needed for
;	     FOR loop processing.
;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
;	     1 when Cparse is called from COPY.
;11/17/83 EE  Took out the comment chars around code described in 11/04/83
;	     mod. It now is conditional on flag like previous mod.
;11/21/83 NP  Added printf
;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
;	     be added to a token.
;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
;	     NOTE: DestHand is the destination handle. There are two
;	     special values: -1 meaning destination was never opened and
;	     0 which means that the destination has been openned and
;	     closed.
;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
;06/06/86 EG  Change to fix problem of source switches /a and /b getting
;	     lost on large and multiple file (wildcard) copies.
;06/09/86 EG  Change to use xnametrans call to verify that source and
;	     destination are not equal.
;
;06/24/90 DO  If the destination of a file concatenation is the same as
;	     first source file AND we run out of disk space before
;	     completing the concatenation, restore the first source
;	     file as best we can. See SeekEnd and CopErr. Bug #859.
;
;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
;		instead of compatibility mode. This gives lesser sharing
;		violations when files are opened for read on a copy.

; ---------------------------------------------------------------------------
;***	COPY CODE
; ---------------------------------------------------------------------------

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h

; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h

COPY:
	; 	Initialize internal variables.

	xor	ax,ax		; AX = 0
	mov	[Copy_num],ax	; # files copied (destinations) = 0
	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
	mov	[CFLAG],al	; 'destination file created' = false
	mov	[NXTADD],ax	; ptr into TPA buffer = 0
	mov	[DestSwitch],ax	; destination switches = none
	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
	mov	[DestClosed],al	; 'destination file closed' = false
	mov	[DestSiz],al	; length of destination pathname = 0
	mov	[SrcSiz],al	; length of source pathname = 0
	mov	[DestInfo],al	; destination pathname flags = none
	mov	[SrcInfo],al	; source pathname flags = none
	mov	[INEXACT],al	; 'inexact copy' = false
	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
	mov	[SrcVars],al	; 'source pathname is directory' = false
	mov	[USERDIR1],al	; saved working directory = null
	mov	[NOWRITE],al	; 'no write' (source = dest) = false
	mov	[RDEOF],al	; 'read end of file' = false
	mov	[SRCHAND],ax	; source handle = 0
	mov	[CPDATE],ax	; copy date = 0
	mov	[CPTIME],ax	; copy time = 0
	mov	[SRCISDEV],al	; 'source is device' = false
	; 23/03/2023
	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
	mov	[OFilePtr_Lo],ax
	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
	mov	[TERMREAD],al	; 'terminate read' = false
	mov	[comma],al	; '"+,," found' = false
	mov	[plus_comma],al ; '"+,," found last time' = false (?)
	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
	mov	[AllSwitch],ax	; all switches = none
	mov	[ArgC],al	; source/dest argument count = 0
	mov	[PLUS],al	; '"+" in command line' = false
	mov	[BINARY],al	; 'binary copy' = false
	mov	[ASCII],al	; 'ascii copy' = false
	mov	[FileCnt],ax	; # files copied (destinations) = 0
	mov	[WRITTEN],ax	; 'destination written to' = false
	mov	[Concat],al	; 'concatenating' = false
	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0

	;	Initialize buffers with double-nulls.

	mov	[ScanBuf],ax
	mov	[DestBuf],ax
	mov	[SrcBuf],ax
	mov	[SDIRBUF],ax
	mov	[DIRBUF],ax
	mov	[DestFcb],ax

	mov	[objcnt],al	; # CParse cmd-line objects found = 0
		
	dec	ax ; -1		; AX = 0FFFFh
	mov	[DESTHAND],ax	; destination handle = 'never opened'
	mov	[FRSTSRCH],al	; 'first search for source' = true
	mov	[FIRSTDEST],al	; 'first time for dest' = true
	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
		
	mov	si,81h		; SI = ptr to command line
	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
	; 23/03/2023
	mov	bl,'+'
	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true

	;*	Scan the command line for destination information.

DESTSCAN:
	xor	bp,bp			; BP = switch flag accumulator
	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
	; 23/03/2023
	mov	[parse_last],si		;AN018; save cmd line ptr
	call	cparse			; parse next object
	pushf				; save CParse flags
	inc	byte [objcnt]		; count object
	test	bh,80h
	jz	short NOCOPY		; no "+" delimiter
	mov	byte [PLUS],1		; "+" delimiter occurred
NOCOPY:
	test	bh,1
	jz	short TESTP2		; not a switch

	;	Found a switch.

	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 6.0
	test	bp,10h
	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
	jz	short NOT_SLASHV	;AN038; No - set the switch
	test	byte [AllSwitch],10h
	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
	jz	short NOT_SLASHV	;AN038; No - set the switch
;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
	;or	bp,FBadSwitch		;AN018; Set up bad switch
	or	bp,4000h
NOT_SLASHV:
	or	[DestSwitch],bp		; assume destination
	or	[AllSwitch],bp		; keep tabs on all switches

	; 23/03/2023
	; MSDOS 6.0
	;test	bp,not SwitchCopy	;AN018; Bad switch?
	test	bp,7FE3h ; test bp,~SwitchCopy
	jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
	popf				;AN018; fix up stack
	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
	call	setup_parse_error_msg	;AN018; setup to print the message
	jmp	cerror			;AC018; exit
NOT_BAD_SWITCH:
	popf				; restore CParse flags
	jc	short CHECKDONE		; found CR
	jmp	short DESTSCAN		; continue scanning for destination
TESTP2:
	popf				; restore CParse flags
	jc	short CHECKDONE		; found CR
	test	bh,80h
	jnz	short GOTPLUS		; found a "+pathname" argument
	inc	byte [ArgC]		; count independent pathname args
GOTPLUS:
	push	si			; save cmd line ptr
	mov	ax,[STARTEL]		; AX = ptr to last path element
	mov	si,ScanBuf		; SI = ptr to path string
	sub	ax,si			; AX = offset of last element
	mov	di,DestBuf		; DI = ptr to destination buf
	add	ax,di			; AX = ptr to last element in
					;  destination path buffer
	mov	[DestTail],ax		; save ptr to last element
	mov	[DestSiz],cl		; save path string length
	inc	cx			; CX = mov length (incl null)
	rep	movsb			; DestBuf = possible destination path
	mov	[DestInfo],bh		; save CParse info flags
	mov	word [DestSwitch],0	; clear destination switches
	pop	si			; SI = ptr into cmd line again
	jmp	short DESTSCAN		;AC018; continue scanning for dest

CHECKDONE:
	;	We reached the CR. The destination scan is finished.

	;	Disallow "copy file1+" as file overwriting itself.
	;
	;	(Note that "copy file1+file2+" will be accepted, and
	;	equivalent to "copy file1+file2".)

	;	Bugbug: it looks like "copy /x file1+" would slip
	;	through this check, since the switch would count
	;	as another object in ObjCnt.

	cmp	byte [PLUS],1		; "+" with
	jnz	short CDCONT
	cmp	byte [ArgC],1		; one arg,
	jnz	short CDCONT
	cmp	byte [objcnt],2		; two objects..
	jnz	short CDCONT
	mov	dx,OVERWR_PTR
	jmp	COPYERR			; is file overwrite

CDCONT:
	mov	al,[PLUS]		; AL = '"+" occurred'
	mov	[Concat],al		; if "+" occurred, we're concatenating
	shl	al,1
	shl	al,1
	mov	[INEXACT],al		; therefore making an inexact copy
	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
	mov	al,[ArgC]		; AL = # independent arguments

	; 23/03/2023
	; MSDOS 3.3		
	;or	al,al
	;jz	short CERROR4J
	; MSDOS 6.0
	or	al,al
	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
		
	mov	dx,extend_buf_ptr	; DX = ptr to msg block
	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
	jmp	short CERROR_PARSEJ	; take parse error exit		

	; more than 0 args; check if too many
TRY_TOO_MANY:
	cmp	al,2
	jbe	short ACOUNTOK		; <= 2 arguments - ok

	; 23/03/2023
	; MSDOS 6.0
	mov	dx,extend_buf_ptr	; DX = ptr to msg block
	mov	word [extend_buf_ptr],MoreArgs_Ptr
	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
CERROR_PARSEJ:
	mov	byte [msg_disp_class],parse_msg_class ; 2
					; parse error message	
CERROR4J:
	jmp	cerror

ACOUNTOK:
	mov	bp,DestVars		; BP = base of dest variables

	cmp	al,1
	jnz	short GOT2ARGS

	;	Only one independent pathname argument on command line.
	;	Set destination to d:*.*, where d: is current drive.

	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
	;	The two files would be appended as d:file1, rather than x:file1.

	mov	al,[CURDRV]		; AL = current drive (0 = A)
	;add	al,[CAPITAL_A]		; AL = current drive letter
	; 23/03/2023
	add	al,'A'
	mov	ah,':'			; AX = "d:"
	;mov	byte [bp+1],2
	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2

	mov	di,DestBuf		; ES:DI = ptr to dest path buf
	stosw				; store "d:"
		
	mov	word [DestSwitch],0	; clear destination switches
	;mov	byte [bp+4],2		
	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
	;mov	byte [bp+0],0		
	mov	byte [bp],0
	call	SETSTARS		; add wildcards
GOT2ARGS:
	;	If destination pathname is "d:", add full wildcard filename

	;cmp	byte [bp+1],2
	cmp	byte [bp+VARSTRUC.SIZ],2
	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
	mov	al,':'  ; 3Ah
	cmp	byte [DestBuf+1],al
	jnz	short NOTSHORTDEST	; it's just a 2-character filename
	;or	byte [bp+4],2
	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
	;mov	byte [bp+0],0		
	mov	byte [bp],0
	call	SETSTARS		; add wildcards
NOTSHORTDEST:
	;	If destination pathname ends with "\", try to make
	;	sure it's "d:\".

	;mov	di,[bp+2]
	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
	cmp	byte [di],0
	jnz	short CHKSWTCHES	; not a null, so last char not "\"

	mov	dx,badcd_ptr
	mov	al,':'
	cmp	[di-2],al
	jne	short CERROR4J		; it's not "d:\", exit with error msg
	;mov	byte [bp+0],2
	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
	mov	byte [bp],2
	;or	byte [bp+4],6
	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
					  ;  path character
	call	SETSTARS		; add wildcards
CHKSWTCHES:
	;	We have enough information about the destination for now.

	;	Turn on verify if requested. Save the current verify flag.

	; 23/03/2023
	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
	;mov	dx,BADPARMPTR
	
	mov	ax,[AllSwitch]		; AX = all switch flags

	; 23/03/2023
	; MSDOS 3.3
	;;test	ax,~SWITCHCOPY ; 7FE3h
	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
	;jnz	short CERROR4J
	
	; 23/03/2023
	; MSDOS 3.3 (& MSDOS 6.0)
	;test	ax,SwitchV ; 10h
	; 18/04/2023
	;test	ax,10h
	test	al,10h  ; test al,SwitchV
	jz	short NOVERIF		; no /v, no verify

	mov	ah,Get_Verify_On_Write ; 54h
	int	21h		; DOS -	2+ - GET VERIFY	FLAG
				; Return: AL = 00h if flag OFF
				; AL = 01h if flag ON
	push	ds
	mov	ds,[RESSEG]
	xor	ah,ah
	mov	[VerVal],ax		; save current verify flag
	pop	ds
	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
	int	21h		; DOS -	SET VERIFY FLAG
				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
NOVERIF:
	;*	Scan for first source.

	xor	bp,bp			; BP = switch flags accumulator
	mov	si,81h			; SI = ptr into command line
	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
	; 23/03/2023
	mov	bl,'+' ; 2Bh
SCANFSRC:
	mov	di,ScanBuf		; DI = ptr to pathname buf
	call	cparse			; parse first source pathname
	test	bh,1			; switch?
	jnz	short SCANFSRC		; yes, try again
	or	[DestSwitch],bp		; include copy-wide switches on dest

;	Set ascii copying mode if concatenating, unless /b is specified.

	; 23/03/2023
	test	bp,8
	;test	bp,SWITCHB
	jnz	short NOSETCASC		; /b - explicit binary copy
	cmp	byte [Concat],0
	jz	short NOSETCASC		; we're not concatenating
	mov	byte [ASCII],4
	;mov	byte [ASCII],SWITCHA	; set ascii copy
NOSETCASC:
	call	SOURCE_SET		; set source variables
	call	FRSTSRC			; set up first source copy
	jmp	FIRSTENT		; jump into the copy loop

; ---------------------------------------------------------------------------

	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
ENDCOPY:
	;*	End of the road. Close destination, display # files
	;	copied (meaning # destinations), and go back to main
	;	transient COMMAND code.

	call	CLOSEDEST
ENDCOPY2:
	mov	dx,copied_ptr
	mov	si,[FileCnt]
	mov	[Copy_num],si
	call	std_printf
	jmp	TCOMMAND		; stack could be messed up

; ---------------------------------------------------------------------------

SRCNONEXIST:
	;*	Source doesn't exist. If concatenating, ignore and continue.
	;	Otherwise, say 'file not found' and quit.

	cmp	byte [Concat],0
	jne	short NEXTSRC		; concatenating - go on to next source

	; 24/03/2023
	; MSDOS 3.3
	;mov	dx,SRCBUF
	;mov	[STRING_PTR_1],dx
	;mov	dx,STRINGBUF1PTR
	;call	STD_PRINTF
	;mov	dx,FNOTFOUNDPTR
	;jmp	COPYERR

	; 24/*03/2023
	; MSDOS 6.0
	;	Set up error message.
	mov	byte [msg_disp_class],ext_msg_class ; 1
				  	; extended error msg
	mov	dx,extend_buf_ptr	; DX = ptr to msg block
	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
					; 'file not found' msg#
	mov	word [string_ptr_2],SrcBuf
					; point at bad pathname
	mov	byte [extend_buf_sub],one_subst ; 1
					; 1 substitution
	jmp	COPYERR			; print msg and clean up

; ---------------------------------------------------------------------------

SOURCEPROC:

	;*	Preparatory processing for each source file.
	;	Called at FrstSrc for first source file.

	call	SOURCE_SET		; set source variables & ascii/binary
	cmp	byte [Concat],0
	jne	short LEAVECFLAG	; concatenating - leave CFlag alone

; ---------------------------------------------------------------------------

FRSTSRC:
	xor	ax,ax
	mov	[CFLAG],al		; 'destination not created'
	mov	[NXTADD],ax		; copy buffer ptr = 0
	mov	[DestClosed],al		; 'destination not closed'

LEAVECFLAG:
	mov	[SRCPT],si		; save cmd-line ptr
	mov	di,USERDIR1		; DI = ptr to buf for user's 
						;   current dir
	mov	bp,SrcVars		; BP = base of source variables
	call	BUILDPATH		; cd to source dir, figure
						;   out stuff about source
	mov	si,[SrcTail]		; SI = ptr to source filename
	retn

; ---------------------------------------------------------------------------

	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
NEXTSRC:
	;*	Next source. Come here after handling each pathname.
	;	We're done unless there are additional source pathnames
	;	to be appended.
	;
	;	Note that all files matching an ambiguous pathname
	;	are processed before coming here.

	cmp	byte [PLUS],0
	;jne	short MORECP		; copying "+" sources - keep going
	; 26/04/2023
;ENDCOPYJ2:
	;jmp	short ENDCOPY
	je	short ENDCOPY
MORECP:
	xor	bp,bp			; BP = switch flags accumulator
	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
	mov	bl,'+' ; 2Bh
SCANSRC:
	mov	di,ScanBuf		; DI = ptr to pathname buf
	call	cparse			; parse first source name
	;jb	short ENDCOPYJ2		; CR found - we're done
	; 26/04/2023
	jb	short ENDCOPY

	test	bh,80h
	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
	; 26/04/2023
	jz	short ENDCOPY

	test	bh,1
	jnz	short SCANSRC		; switch found - keep looking

	;	ScanBuf contains the next source pathname.

	call	SOURCEPROC		; prepare this source
	cmp	byte [comma],1		; was +,, found last time?
	jnz	short NOSTAMP		;  no - try for a file
	mov	byte [plus_comma],1	; yes - set flag
	jmp	short SRCNONEXIST	; we know we won't find it

NOSTAMP:
	mov	byte [plus_comma],0	; reset +,, flag

; ---------------------------------------------------------------------------

FIRSTENT:

;M047
; The only case we need to worry about is when the source is wildcarded and
;the destination is not. For this case, ConCat is not yet set to indicate
;concatenation. We check for this case.
;
;NB: This change has been backed out and replaced by M048. This is not the
;right place to do this check.

	;	This is where we enter the loop with the first source.

	mov	di,FCB ; 5Ch		; DI = ptr to FCB
	mov	ax,Parse_File_Descriptor*256 ; 2900h
	int	21h		; DOS -	PARSE FILENAME
				; DS:SI	-> string to parse
				; ES:DI	-> buffer to fill with unopened	FCB
				; AL = bit mask	to control parsing
	cmp	byte [si],0		; did we parse the whole thing?
	jne	short SRCHDONE		; no, error, simulate 'not found'
	mov	ax,[SrcBuf]		; AX = possible "d:"
	cmp	ah,':'
	je	short DRVSPEC1		; AX = definite "d:"
	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
DRVSPEC1:
	or	al,20h			; AL = lowercase drive letter
	sub	al,60h			; AL = drive id (0=current,1=A,..)
	;mov	[5Ch],al
	mov	[FCB],al		; put drive id in FCB

	;	FCB contains drive and filename to search.
		
	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'	
	call	SEARCH
SRCHDONE:
	pushf				; save flags from Search
	call	RestUDir1		; restore users current directory
	popf				; restore flags from search
	jz	short NEXTAMBIG0	; found the source - continue
	jmp	SRCNONEXIST		; didn't find the source

NEXTAMBIG0:
	xor	al,al
	xchg	al,[FRSTSRCH]
	or	al,al
	jz	short NEXTAMBIG
SETNMEL:
	mov	cx,12
	mov	di,SDIRBUF
	mov	si,DIRBUF
	rep	movsb			; save very first source name
NEXTAMBIG:
	xor	al,al
	mov	[NOWRITE],al		; turn off nowrite
	mov	di,[SrcTail]
	mov	si,DIRBUF+1
	call	FCB_TO_ASCZ		; SrcBuf has complete name
MELDO:
	cmp	byte [Concat],0
	jnz	short SHOWCPNAM		; concatenating - show name
	test	byte [SrcInfo],2	; wildcard - show name
	jz	short DOREAD
SHOWCPNAM:
	; 25/03/2023
	; MSDOS 3.3
	;mov	dx,SRCBUF
	;mov	[STRING_PTR_2],dx
	;mov	dx,STRINGBUF2PTR
	;call	STD_PRINTF
	;call	CRLF2
	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
	; MSDOS 6.0 (& MSDOS 5.0
	mov	dx,file_name_ptr
	call	std_printf
	call	CRLF2
DOREAD:
	call	DOCOPY
	cmp	byte [Concat],0
	jnz	short NODCLOSE		; concatenating - don't close dest

	call	CLOSEDEST		; close current destination
	jc	short NODCLOSE		; concatenating - dest not closed

	mov	byte [CFLAG],0		; 'destination not created'
NODCLOSE:
	cmp	byte [Concat],0		
	jz	short NOFLUSH

;	Concatenating - flush output between source files so LostErr
;	stuff works correctly.

	;invoke	FlshFil  ; MSDOS 6.0
	; 25/03/2023
	call	FlshFil
	;call	FLUSHFIL ; MSDOS 3.3

	test	byte [MELCOPY],0FFh
	;jz	short NOFLUSH
	;jmp	short DOMELCOPY
	; 25/03/2023
	jnz	short DOMELCOPY
NOFLUSH:
	call	SEARCHNEXT		; try next match
	jnz	short NEXTSRCJ		; not found - finished with 
					;   this source spec
	mov	byte [DestClosed],0	; 'destination not closed'
	jmp	short NEXTAMBIG		; do next ambig match

DOMELCOPY:
	cmp	byte [MELCOPY],0FFh
	je	short CONTMEL
	mov	si,[SRCPT]
	mov	[MELSTART],si
	mov	byte [MELCOPY],0FFh

CONTMEL:
	xor	bp,bp
	mov	si,[SRCPT]
	;mov	bl,[PLUS_CHR]
	; 25/03/2023
	mov	bl,'+'
SCANSRC2:
	mov	di,ScanBuf
	call	cparse
	test	bh,80h
	jz	short NEXTMEL		; no "+" - go back to start
	test	bh,1
	jnz	short SCANSRC2		; switch - keep scanning
	call	SOURCEPROC
	call	RestUDir1
	mov	di,DESTFCB2
	mov	ax,Parse_File_Descriptor*256 ; 2900h
	int	21h		; DOS -	PARSE FILENAME
				; DS:SI	-> string to parse
				; ES:DI	-> buffer to fill with unopened	FCB
				; AL = bit mask	to control parsing
	mov	bx,SDIRBUF+1
	mov	si,DESTFCB2+1
	mov	di,[SrcTail]

	call	BUILDNAME

	cmp	byte [Concat],0
	je	short MELDOJ		; not concatenating - continue

	;	Yes, turn off nowrite because this part of the code 
	;	is only reached after the first file has been dealt with.

	mov	byte [NOWRITE],0
MELDOJ:
	jmp	MELDO
NEXTSRCJ:
	jmp	NEXTSRC

NEXTMEL:
	call	CLOSEDEST
	xor	ax,ax
	mov	[CFLAG],al
	mov	[NXTADD],ax
	mov	[SPECDRV],al
	mov	si,[MELSTART]
	mov	[SRCPT],si
	call	SEARCHNEXT
	jz	short SETNMELJ
	jmp	ENDCOPY2
SETNMELJ:
	jmp	SETNMEL

; ---------------------------------------------------------------------------

SEARCHNEXT:
	mov	ah,Dir_Search_Next ; 12h
	test	byte [SrcInfo],2
	jnz	short SEARCH		; do search-next if ambig
	or	ah,ah			; reset zero flag
	retn

; ---------------------------------------------------------------------------

SEARCH:
	push	ax
	mov	ah,Set_DMA ; 1Ah
	mov	dx,DIRBUF	; put result of search in dirbuf
	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
			; DS:DX	-> disk	transfer buffer
	pop	ax		; restore search first/next command
	mov	dx,FCB ; 5Ch
	int	21h		; Do the search
	or	al,al
	retn

; ---------------------------------------------------------------------------

	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
DOCOPY:
	mov	si,SrcBuf	; do name translate of source
	mov	di,SRCXNAME	; save for name comparison
	mov	ah,xNameTrans ; 60h
	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
			; DS:SI	-> ASCIZ relative path string or directory name
			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
	mov	byte [RDEOF],0	; no EOF yet

	; MSDOS 6.0
	;mov	ax,ExtOpen shl 8	; open the file
	; 26/03/2023
	mov	ax,6C00h
;M046
; For reads, the sharing mode should be deny none so that any process can
;open this file again in any other sharing mode. This is mainly to allow
;multiple command.com's to access the same file without getting sharing
;violations
;
	;mov	bx,deny_none|read_open_mode
	mov	bx,40h			; open mode for COPY ;M046
	xor	cx,cx			; no special files
	;mov	dx,read_open_flag	; set up open flags
	mov	dx,101h
	int	21h
	; 26/03/2023
	jc	short Error_On_Source
	;jnc	short OPENOK

	;	Bogosity: IBM wants us to issue Access Denied in this case.
	;	They asked for it...

	;jmp	short Error_On_Source ;AC022; clean up and exit

	; 26/03/2023
	; MSDOS 3.3
	;mov	dx,SRCBUF
	;mov	ax,OPEN*256 ; 3D00h
	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
	;			; DS:DX	-> ASCIZ filename
	;			; AL = access mode
	;			; 0 - read
	;jnc	short OPENOK
	;call	GET_EXT_ERR_NUMBER
	;pushf
	;cmp	ax,65
	;jnz	short DOCOPY_ERR
	;mov	dx,ACCDENPTR
	;call	STD_PRINTF
;DOCOPY_ERR:
	;popf
	;retn

	; 26/03/2023
	; MSDOS 3.3 (& MSDOS 6.0)
OPENOK:
	mov	bx,ax
	mov	[SRCHAND],bx		; save handle
	mov	ax,File_Times*256 ; 5700h
	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
				; BX = file handle

	jc	short Error_On_Source ; MSDOS 6.0

	mov	[CPDATE],dx		; save date
	mov	[CPTIME],cx		; save time

	; MSDOS 6.0
	;jmp	short No_Copy_Xa 	; (xa copy code removed)
	; 26/04/2023
No_Copy_Xa:
	; 26/03/2023
	;mov	bx,[SRCHAND]		;AN022; get handle back

	; MSDOS 3.3 (& MSDOS 6.0)
	mov	ax,(IOCTL<<8) ; 4400h
	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
				; BX = file or device handle
	;and	dl,devid_ISDEV ; 80h
	; 18/04/2023
	and	dl,80h ; devid_ISDEV
	mov	[SRCISDEV],dl		; set source info
	jz	short COPYLP		; source not a device
	cmp	byte [BINARY],0
	je	short COPYLP		; ascii device ok
	mov	dx,INBDEV_PTR		; cannot do binary input
	jmp	COPYERR

Error_On_Source:			;AN022; we have a BAD error
	call	Set_Ext_Error_Msg	;AN022; set up the error message
	mov	word [string_ptr_2],SrcBuf
				;AN022; get address of failed string
	mov	byte [extend_buf_sub],one_subst ; 1
				;AN022; put number of subst in control block
	call	std_eprintf		;AN022; print it
	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
	mov	bx,[SRCHAND]
	;cmp	word [SRCHAND],0	;AN022; did we open the file?
	;je	short No_Close_Src	;AN022; no - don't close
	or	bx,bx
	jz	short No_Close_Src
	;call	CLOSESRC		;AN022; clean up
	; 26/03/2023
	call	CLOSESRC2 ; bx = [SRCHAND]
No_Close_Src:				;AN022;
	cmp	byte [CFLAG],0		;AN022; was destination created?
	je	short EndCopyJ3		;AN022; no - just cleanup and exit
	jmp	ENDCOPY			;AN022; clean up concatenation and exit
EndCopyJ3:				;AN022;
	jmp	ENDCOPY2		;AN022;

	; 26/04/2023
;No_Copy_Xa:
;	; 26/03/2023
;	;mov	bx,[SRCHAND]		;AN022; get handle back
;
;	; MSDOS 3.3 (& MSDOS 6.0)
;	mov	ax,(IOCTL<<8) ; 4400h
;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
;				; BX = file or device handle
;	;and	dl,devid_ISDEV ; 80h
;	; 18/04/2023
;	and	dl,80h ; devid_ISDEV
;	mov	[SRCISDEV],dl		; set source info
;	jz	short COPYLP		; source not a device
;	cmp	byte [BINARY],0
;	je	short COPYLP		; ascii device ok
;	mov	dx,INBDEV_PTR		; cannot do binary input
;	jmp	COPYERR

COPYLP:
	; 26/03/2023
	mov	bx,[SRCHAND] ; ? ; 26/03/2023
	mov	cx,[BYTCNT]
	mov	dx,[NXTADD]
	sub	cx,dx			; compute available space
	jnz	short GOTROOM
	call	FlshFil   ; MSDOS 6.0
	;call	FLUSHFIL  ; MSDOS 3.3
	cmp	byte [TERMREAD],0
	jne	short CLOSESRC		; give up
	mov	cx,[BYTCNT]
GOTROOM:
	push	ds
	mov	ds,[TPA]
	mov	ah,READ ; 3Fh
	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
				; BX = file handle,CX = number of bytes to read
				; DS:DX	-> buffer
	pop	ds
	;jc	short CLOSESRC	; MSDOS 3.3
	; 26/03/2023
	jc	short Error_On_Source ; MSDOS 6.0
	mov	cx,ax			; get count
	jcxz	CLOSESRC		; no more to read
	cmp	byte [SRCISDEV],0
	jne	short NOTESTA		; is a device, ascii mode
	cmp	byte [ASCII],0
	je	short BINREAD
NOTESTA:
	mov	dx,cx
	mov	di,[NXTADD]
	mov	al,1Ah
	push	es
	mov	es,[TPA]		; scan for EOF
	repne	scasb
	pop	es
	jnz	short USEALL
	inc	byte [RDEOF]
	inc	cx
USEALL:
	sub	dx,cx
	mov	cx,dx
BINREAD:
	add	cx,[NXTADD]
	mov	[NXTADD],cx
	cmp	cx,[BYTCNT]		; is buffer full?
	jb	short TESTDEV		; if not, we may have found eof
	; 26/03/2023
	call	FlshFil
	;call	FLUSHFIL
	cmp	byte [TERMREAD],0
	jne	short CLOSESRC		; give up
	jmp	short COPYLP
TESTDEV:
	cmp	byte [SRCISDEV],0	; if file then EOF
	je	short CLOSESRC
	cmp	byte [RDEOF],0
	je	short COPYLP		; on device, go till ^Z
CLOSESRC:
	mov	bx,[SRCHAND]
CLOSESRC2:
	mov	ah,CLOSE ; 3Eh
	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
				; BX = file handle
CLOSESRCDEST_RETN:
	retn

; ---------------------------------------------------------------------------

	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
CLOSEDEST:

	;	We are called to close the destination.
	;	We need to note whether or not there is any internal data left
	;	to be flushed out.

	cmp	byte [DestClosed],0
	jne	short CLOSESRCDEST_RETN	; don't double close
	mov	al,[DestSwitch]
	call	SETASC			; check for b or a switch
	jz	short BINCLOS		;   on destination
	mov	bx,[NXTADD]
;
;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
;^Z, let's always flush out. This way if the ConCat flag changes, we will
;just return without appending a ^Z incorrectly for the first file (since we
;are concatenating now). Also, in case it is a single file copy, we will
;anyway write the ^Z out separately. The only drawback is that there is a
;performance overhead on single ASCII file copies which now always involve
;2 writes instead of 1 before. Is this really that important?
;
;M048;	cmp	bx,[BYTCNT]		; is memory full?
;M048;	jne	short PutZ

	; 26/03/2023
	; MSDOS 3.3
	;cmp	bx,[BYTCNT]		; is memory full?
	;jne	short PUTZ

	; 26/03/2023
	call	TRYFLUSH		; flush (and double-check for concat)	
	jz	short NOCONC
CONCHNG:
	stc
	retn

NOCONC:	
	xor	bx,bx
PUTZ:
	push	ds
	mov	ds,[TPA]
	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
	pop	ds
	inc	word [NXTADD]	; make sure our ^z gets written	
	mov	byte [NOWRITE],0
	mov	ax,[WRITTEN]
	add	ax,[NXTADD]
	jc	short BINCLOS	; > 1
	cmp	ax,1
	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
BINCLOS:
	call	TRYFLUSH
	jnz	short CONCHNG

	; 26/04/2023
	cmp	word [WRITTEN],0
	; 26/03/2023
	jnz	short NO_FORGET
FORGETITJ:
	;jz	short FORGETIT	; never wrote nothing
	; 26/03/2023
	jmp	FORGETIT ; 18/04/2023
NO_FORGET:			; wrote something
	mov	bx,[DESTHAND]
	mov	cx,[CPTIME]
	mov	dx,[CPDATE]
	cmp	byte [INEXACT],0 ; copy not exact?
	je	short DODCLOSE	; if no, copy date & time
	mov	ah,Get_Time ; 2Ch
	int	21h		; DOS -	GET CURRENT TIME
				; Return: CH = hours,CL = minutes,DH = seconds
				; DL = hundredths of seconds
	shl	cl,1
	shl	cl,1		; left justify min in cl
	shl	cx,1
	shl	cx,1
	shl	cx,1		; hours to high 5 bits, min to 5-10
	shr	dh,1		; divide seconds by 2 (now 5 bits)
	or	cl,dh		; and stick into low 5 bits of cx
	push	cx		; save packed time
	mov	ah,Get_Date ; 2Ah
	int	21h		; DOS -	GET CURRENT DATE
				; Return: DL = day,DH = month,	CX = year
				; AL = day of the week (0=Sunday,1=Monday,etc.)
	sub	cx,1980
	xchg	ch,cl
	shl	cx,1		; year to high 7 bits
	shl	dh,1		; month to high 3 bits
	shl	dh,1
	shl	dh,1
	shl	dh,1
	shl	dh,1		; most sig bit of month in carry
	adc	ch,0		; put that bit next to year
	or	dl,dh		; or low three of month into day
	mov	dh,ch		; get year and high bit of month
	pop	cx
DODCLOSE:
	cmp	bx,0
	jle	short CLOSEDONE
	mov	ax,(File_Times<<8)|1 ; 5701h
	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
				; BX = file handle,CX = time to be set
				; DX = date to be set
	; 26/03/2023
	; MSDOS 6.0
	jc	short Cleanup_Err ;AN022; handle error

	;	See if the destination has *anything* in it.
	;	If not, just close and delete it.

	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
	xor	dx,dx
	mov	cx,dx
	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
			; AL = method: offset from end of file
	;	DX:AX is file size

	or	dx,ax
	pushf
	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
			; BX = file or device handle
	push	dx		; save them away
	mov	ah,CLOSE ; 3Eh
	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
			; BX = file handle
	pop	dx

	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 6.0
	jnc	short Close_Cont ;AN022; handle error on close
	popf			;AN022; get the flags back
Cleanup_Err: 			;AN022;
	call	CleanUpErr	;AN022; attempt to delete the target
	; 26/03/2023
	;call	DestDelete	;AN022; attempt to delete the target
	;jmp	short FILECLOSED
	;			;AN022; close the file
	; 26/03/2023
DestDel_fclosed:
	call	DestDelete
FILECLOSED:
	inc	byte [DestClosed]
RET50:
	clc
	retn
	
Close_Cont:			;AN022; no error - co
	; MSDOS 3.3 (& MSDOS 6.0)
	popf
	jnz	short CLOSEDONE
	test	dx,80h		; is the destination a device?
	;jnz	short CLOSEDONE	; yes, copy succeeded
	;call	DestDelete
	;jmp	short FILECLOSED
	; 26/03/2023
	jz	short DestDel_fclosed
CLOSEDONE:
	inc	word [FileCnt]
	; 26/03/2023
	jmp	short FILECLOSED
	
;FILECLOSED:
;	inc	byte [DestClosed]
;RET50:
	;clc
	;retn

FORGETIT:
	mov	bx,[DESTHAND]
	call	DODCLOSE	 ; close the dest	
	call	DestDelete
	mov	word [FileCnt],0 ; no files transferred
	jmp	short RET50

; ---------------------------------------------------------------------------

	; 26/03/2023
DestDelete:
	mov	dx,DestBuf
	mov	ah,Unlink ; 41h
	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
			; DS:DX	-> ASCIZ pathname of file to delete 
			;		(no wildcards allowed)
	retn

; ---------------------------------------------------------------------------

	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
SOURCE_SET:
	push	si
	mov	ax,[STARTEL]
	mov	si,ScanBuf	; adjust to copy
	sub	ax,si
	mov	di,SrcBuf
	add	ax,di
	mov	[SrcTail],ax
	mov	[SrcSiz],cl	; save its size
	inc	cx		; include the nul
	rep	movsb		; save this source
	mov	[SrcInfo],bh	; save info about it
	pop	si
	mov	ax,bp		; switches so far
	call	SETASC		; set a,b switches accordingly
	call	SWITCH		; get any more switches on this arg
	;call	SETASC		; set
	;retn
	; 26/03/2023
	jmp	SETASC

; =============== S U B	R O U T	I N E =======================================

; MSDOS 6.0

;****************************************************************
;*
;* ROUTINE:	CleanupErr
;*
;* FUNCTION:	Issues extended error message for destination
;*		if not alreay issued
;*
;* INPUT:	return from INT 21
;*
;* OUTPUT:	none
;*
;****************************************************************

	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
CleanUpErr:	; proc	near		;AN022;

	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
	call	Set_Ext_Error_Msg	;AN022; set up error message
	mov	word [string_ptr_2],DestBuf 
					;AN022; get address of failed string
	mov	byte [extend_buf_sub],one_subst ; 1 
					;AN022; put number of subst in control block
	call	std_eprintf		;AN022; issue the error message
CleanupErr_Cont:			;AN022;
	retn				;AN022; return to caller

;CleanUpErr	endp			;AN022;

;============================================================================
; COPYPR1.ASM, MSDOS 6.0, 1991
;============================================================================
; 01/10/2018 - Retro DOS v3.0

; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh

; =============== S U B	R O U T	I N E =======================================

;***	TryFlush - flush copy buffer, double-check for concatenation
;
;	EXIT	ZR set if concatenate flag unchanged

	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
TRYFLUSH:
	mov	al,[Concat]
	push	ax
	;call	FLUSHFIL
	call	FlshFil
	pop	ax
	cmp	al,[Concat]
	retn

; =============== S U B	R O U T	I N E =======================================

	; 26/03/2023
	; MSDOS 3.3
;FLUSHFIL:
	;mov	al,[BINARY]
	;mov	ah,[ASCII]
	;push	ax
	;call	FLSHFIL
	;pop	ax
	;mov	[ASCII],ah
	;mov	[BINARY],al
	;retn

; =============== S U B	R O U T	I N E =======================================

;***	Flshfil - write out any data remaining in copy buffer.
;
;	Inputs:
;	  [NXTADD] = No. of bytes to write
;	  [CFLAG] <> 0 if file has been created
;	Outputs:
;	  [NXTADD] = 0

	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
FlshFil:
	mov	byte [TERMREAD],0
	cmp	byte [CFLAG],0
	jz	short NotExists
	jmp	Exists
NotExists:
	call	BUILDDEST		; find out all about the destination
	call	COMPNAME		; source and dest. the same?
	jnz	short ProcDest		; if not, go ahead
	cmp	byte [SRCISDEV],0
	jnz	short ProcDest		; same name on device ok
	cmp	byte [Concat],0		; concatenation?
	mov	dx,OVERWR_PTR
	;je	short COPERR		; not concatenating - overwrite error
	; 26/03/2023
	jne	short No_Concat_Err
	jmp	COPYERR
	
No_Concat_Err:	; concatenating
	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
ProcDest:
	; MSDOS 6.0
	;mov	ax,(ExtOpen<<8)		; open the file
	; 26/03/2023
	mov	ax,6C00h
	mov	si,DestBuf		; get file name
;M046
; For writes, we want to deny writes by anyone else at the same time that we
;are writing to it. For instance, on a network, 2 workstations could try
;writing to the same file. Also, because we opened the source file with
;DENY NONE, it is fine if the source and destination files are the same as
;would happen when we append to an existing file.

	; 26/03/2023
	;mov	bx,deny_write|write_open_mode
	mov	bx,21h			; get open mode for copy; M046
	xor	cx,cx			; no special files
	;mov	dx,write_open_flag	; set up open flags
	mov	dx,101h	

	cmp	byte [NOWRITE],0
	jne	short DoDestOpen	; don't actually create if nowrite set
	;mov	dx,creat_open_flag	; set up create flags
	mov	dx,112h

	; 26/03/2023
	; MSDOS 3.3
	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
	;cmp	byte [NOWRITE],0
	;jne	short DODESTOPEN
	;mov	ah,CREAT ; 3Ch
	;xor	cx,cx
;DODESTOPEN:
	;mov	dx,DESTBUF
	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
	;		; CX = attributes for file
	;		; DS:DX	-> ASCIZ filename (may include drive and path)

; 26/03/2023
;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
;	;mov	dx,FULDIRPTR
;	;call	GET_EXT_ERR_NUMBER
;	;jc	short COPERR
;
;	; 01/10/2018
;	;jnc	short DEST_OPEN_OKAY
;		
;	;mov	dx,FULDIRPTR
;	;call	GET_EXT_ERR_NUMBER
;	;jmp	short COPERR
;
;	jc	short DEST_OPEN_ERROR

	; 26/03/2023
DoDestOpen:
	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
			; BH = flags
			; CX = create attribute
			; DL = action if file exists/does not exists
			; DH = 00h (reserved), DS:SI -> ASCIZ file name

;	We assume that the error is normal.
;	TriageError will correct the DX value appropriately.
	
	jnc	short Dest_Open_Okay
Xa_Set_Error:				;AN030; error occurred on XA
	call	Set_Ext_Error_Msg	;AN030; get extended error

	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
Ext_Err_Set:				;AN030;
	mov	word [string_ptr_2],DestBuf
					;AN000; get address of failed string
	mov	byte [extend_buf_sub],one_subst ; 1 
					;AN030; put number of subst in control block
CopErrJ2:				;AN030;
	jmp	COPYERR			;AN030; go issue message

;DEST_OPEN_OKAY:
	; 26/03/2023
Dest_Open_Okay:
	mov	[DESTHAND],ax		; save handle
	mov	byte [CFLAG],1		; destination now exists
	mov	bx,ax
	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
			   	; BX = file or device handle

	mov	[DESTISDEV],dl		; set dest info
	; 18/04/2023
	test	dl,80h
	;test	dl,devid_ISDEV
	jz	short Exists		; Dest not a device

;	Destination is device.

	mov	al,[DestSwitch]
	; 26/03/2023
	and	al,0Ch
	;and	al,SWITCHA+SWITCHB ; 4+8
	jnz	short TestBoth
	mov	al,[ASCII]		; neither set, use current setting
	or	al,[BINARY]
	jz	short ExSetA		; neither set, default to ascii
TestBoth:
	jpe	short Exists		; both are set, ignore
	test	al,8
	;test	al,SWITCHB
	jz	short Exists
	;mov	ax,(IOCTL shl 8) or 1
	mov	ax,(IOCTL<<8)|1 ; 4401h
	xor	dh,dh
	; 18/04/2023
	or	dl,20h
	;or	dl,devid_RAW
	mov	[DESTISDEV],dl
	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
			; BX = device handle,DH = 0
			; DL = device information to set (bits 0-7 from	function 0)
	jmp	short Exists

	; 26/03/2023
	; 01/10/2018 - Retro DOS v3.0 modification
;DEST_OPEN_ERROR:
	;mov	dx,FULDIRPTR
	;call	GET_EXT_ERR_NUMBER
;COPERR:
	; 26/03/2023
;CopyErrj:
	;jmp	short COPYERR

ExSetA:
;	What we read in may have been in binary mode, flag zapped write OK

	mov	byte [ASCII],4
	;mov	byte [ASCII],SWITCHA	; set ascii mode
	or	byte [INEXACT],4
	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
Exists:
	cmp	byte [NOWRITE],0
	jnz	short NoChecking	; if nowrite don't bother with name check
	cmp	byte [plus_comma],1	; don't check if just doing +,,
	jz	short NoChecking
	call	COMPNAME		; source and dest. the same?
	jnz	short NoChecking	; if not, go ahead
	cmp	byte [SRCISDEV],0
	jne	short NoChecking	; same name on device ok

;	At this point we know in append (would have gotten overwrite error
;	on first destination create otherwise), and user trying to specify
;	destination which has been scribbled already (if dest had been named
;	first, NoWrite would be set).

	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
	;invoke	Std_EprintF		;ac022;
	; 26/03/2023
	call	std_eprintf ; MSDOS 6.0 (& 5.0)
	;call	STD_PRINTF  ; MSDOS 3.3	
	mov	word [NXTADD],0		; set return
	inc	byte [TERMREAD]		; tell read to give up
Ret60:
	retn

NoChecking:
	mov	bx,[DESTHAND]		; get handle
	xor	cx,cx
	xchg	cx,[NXTADD]
	jcxz	Ret60			; if nothing to write, forget it
	inc	word [WRITTEN]		; flag that we wrote something
	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
	jnz	short SeekEnd
	xor	dx,dx
	push	ds
	mov	ds,[TPA]
	mov	ah,Write ; 40h
	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
			; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
	pop	ds
	mov	dx,NOSPACE_PTR
	;jc	short COPERRP		; failure
	; 26/03/2023
	; MSDOS 6.0
	jnc	short NoChecking2
	jmp	Xa_Set_Error

	; 18/04/2023
	; 26/03/2023
SeekEnd:
	xor	dx,dx
	xchg	dx,cx
	;mov	ax,(LSEEK shl 8) or 1
	mov	ax,(LSEEK<<8)|1 ; 4201h
	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
				; AL = method: offset from present location

	; 26/03/2023
	; MSDOS 6.0

;	Save the file pointer in DX:AX to restore the file
;	with in case the copy should fail.

	mov	[OFilePtr_Lo],ax
	mov	[OFilePtr_Hi],dx

	; 26/03/2023
	; MSDOS 3.3  MSDOS 6.0

	cmp	byte [RDEOF],0
	jz	short Retz60

;	^Z has been read - we must set the file size to the current
;	file pointer location

	mov	ah,Write ; 40h
	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer

	; 26/03/2023
	; MSDOS 6.0
	jc	short Xa_Set_Error_Jmp	;AC022; failure

;	Make note that ^Z was removed, in case the
;	copy should fail and we need to restore the file.

	mov	byte [OCtrlZ],1Ah
Retz60:
	retn

NoChecking2:
	sub	cx,ax
	jz	short Ret60		; wrote all supposed to
	; 18/04/2023
	test	byte [DESTISDEV],80h ; devid_ISDEV
	;test	byte [DESTISDEV],devid_ISDEV ;80h
	jz	short COPYERR		; is a file, error
	test	byte [DESTISDEV],20h  ; devid_RAW
	;test	byte [DESTISDEV],devid_RAW ; 20h
	jnz	short DevWrtErr	; is a raw device, error
	cmp	byte [INEXACT],0
	jnz	short Ret60		; inexact so ok
	dec	cx
;Retz60:
	jz	short Ret60		; wrote one byte less (the ^z)		

DevWrtErr:
	mov	dx,DEVWMES_PTR
	; 26/03/2023
COPYERR:
	;invoke	Std_EPrintF		;AC022;
	call	std_eprintf  ; MSDOS 6.0
	;call	STD_PRINTF   ; MSDOS 3.3
CopErrP:
	inc	byte [DestClosed]
	cmp	byte [CFLAG],0
	jz	short EndCopyJ		; never actually got it open
	mov	bx,[DESTHAND]
	cmp	bx,0
	jle	short NoClose

;	Check to see if we should save part of the destination file.

	; 26/03/2023
	; MSDOS 6.0
	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
			
	mov	ax,cx
	or	ax,dx
	jz	short ceClose		; null file ptr means nothing to save

;	Destination was also the first source. Do the best we can to
;	restore it. Truncate it back to the size we took from it (which
;	may have been due to a Ctrl-Z, so may not have included the whole
;	file). If a Ctrl-Z was originally read, put it back.

	mov	ax,(LSEEK<<8) ; 4200h
	int	21h

	xor	cx,cx			; CX = # bytes to write = 0
	mov	ah,Write ; 40h
	int	21h			; truncate file

	cmp	byte [OCtrlZ],0
	je	short ceClose0		; no ctrl-z removed from original
	inc	cx			; CX = # bytes to write = 1
	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
	mov	ah,Write ; 40h
	int	21h			; write ctrl-z
ceClose0:
	mov	ah,CLOSE ; 3Eh
	int	21h			; close it
;;	;mov	byte [CFLAG],0
	jmp	ENDCOPY			; and go home

	; MSDOS 3.3 (& MSDOS 6.0)
ceClose:
	mov	ah,CLOSE ; 3Eh		; close the file
	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
				; BX = file handle
NoClose:
	mov	dx,DestBuf
	mov	ah,Unlink ; 41h 	; and delete it
	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
	mov	byte [CFLAG],0
EndCopyJ:
	jmp	ENDCOPY

Xa_Set_Error_Jmp:			;AN022; go set up error message
	jmp	Xa_Set_Error

;============================================================================
; COPYPR2.ASM, MSDOS 6.0, 1991
;============================================================================
; 01/10/2018 - Retro DOS v3.0

; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh

	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h

; =============== S U B	R O U T	I N E =======================================

;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
;
;	Given switch vector in AX,
;	  Set Ascii flag if /a is set
;	  Clear Ascii flag if /b is set
;	  Binary set if /b specified
;	  Leave Ascii unchanged if neither or both are set
; 	Also sets Inexact if Ascii is ever set. 
;	AL = Ascii on exit, flags set

	; 26/03/2023
SETASC:
	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
	and	al,0Ch ; 4+8
	jpe	short LOADSW	; even parity - both or neither
	push	ax
	;and	al,SWITCHB  ; 8
	and	al,8
	mov	[BINARY],al
	pop	ax
	;and	al,SWITCHA
	and	al,4	
	mov	[ASCII],al
	or	[INEXACT],al
LOADSW:
	mov	al,[ASCII]
	or	al,al
	retn

; =============== S U B	R O U T	I N E =======================================

	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
BUILDDEST:
	cmp	byte [DestIsDir],-1 ; 0FFh
	jnz	short KNOWABOUTDEST	; figuring already done
	mov	di,USERDIR1
	mov	bp,DestVars
	call	BUILDPATH
	call	RestUDir1

;	We now know all about the destination

KNOWABOUTDEST:
	xor	al,al
	xchg	al,[FIRSTDEST]
	or	al,al
	jnz	short FIRSTDST
	jmp	NOFIRSTDEST

FIRSTDST:
;	Create an fcb of the original dest.

	mov	si,[DestTail]
	mov	di,DestFcb
	mov	ax,Parse_File_Descriptor*256 ; 2900h
	int	21h		; DOS -	PARSE FILENAME
				; DS:SI	-> string to parse
				; ES:DI	-> buffer to fill with unopened	FCB
				; AL = bit mask	to control parsing
	cmp	byte [si],0
	jz	short GOODPARSE

	; 27/03/2023	
	; MSDOS 6.0
	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
	
	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
	jmp	COPYERR			;AN052;
GOODPARSE:
	mov	ax,[DestBuf]		; AX = possible "d:"
	cmp	ah,':'
	jz	short DRVSPEC4
	mov	al,'@'  ; 40h
DRVSPEC4:
;	AX = "d:" for following FCB drive computation

	mov	cl,[ASCII]		; CL = saved Ascii flag
	or	al,20h
	sub	al,60h
	mov	[DestFcb],al		; store drive # in FCB

;*	Figure out what copy mode we're in.
;	Letters stand for unambiguous, * for ambiguous pathnames.
;	+n stands for additional sources delimited by +'s.
;
;	copy a b	not concatenating
;	copy a *	not concatenating
;	copy * a	concatenating
;	copy * *	not concatenating
;	copy a+n b	concatenating
;	copy *+n a	concatenating
;	copy *+n *	concatenating, Mel Hallerman style

;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
;		 copy a.b+*.a *.t  picks up all *.a files.

	mov	al,[DestInfo]		; AL = destination CParse flags
	mov	ah,[SrcInfo]		; AH = source CParse flags
	and	ax,202h			; AH,AL = source,dest wildcard flags
	or	al,al
	jz	short NOTMELCOPY 	; no destination wildcard

;	Destination is wildcarded.
	
	cmp	al,ah
	jnz	short NOTMELCOPY ; no source wildcard

;	Source and destination are both wildcarded.

	cmp	byte [PLUS],0
	jz	short NOTMELCOPY	; no +'s in source

;	Source and destination are wildcarded, and source includes +'s.
;	It's Mel Hallorman copy time.

	inc	byte [MELCOPY]		; 'Mel copy' = true
	xor	al,al
	jmp	short SETCONC

NOTMELCOPY:
	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
	and	al,ah
	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
					;   (implies concatenation)
SETCONC:
	or	al,[PLUS]		; "+" always infers concatenation

;	Whew. AL = 1 if concatenating, 0 if not.

	mov	[Concat],al
	shl	al,1
	shl	al,1
	mov	[INEXACT],al		; concatenation -> inexact copy
	cmp	byte [BINARY],0
	jne	short NOFIRSTDEST 	; explicit binary copy	

	mov	[ASCII],al		; otherwise, concatenate in ascii mode	
	or	cl,cl
	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly	
	or	al,al
	jz	short NOFIRSTDEST 	; Ascii flag did not change state

;	At this point there may already be binary read data in the read
;	buffer. We need to find the first ^Z (if there is one) and trim the
;	amount of data in the buffer correctly.

	mov	cx,[NXTADD]
	jcxz	NOFIRSTDEST		; no data, everything ok
	mov	al,1Ah
	push	es
	xor	di,di
	mov	es,[TPA]
	repne	scasb			; scan for EOF
	pop	es
	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
	dec	di			; point at ^z
	mov	[NXTADD],di		; new buffer length

NOFIRSTDEST:
	mov	bx,DIRBUF+1		; Source of replacement chars
	cmp	byte [Concat],0
	jz	short GOTCHRSRC		; Not a concat
	mov	bx,SDIRBUF+1		; Source of replacement chars
GOTCHRSRC:
	mov	si,DestFcb+1		; Original dest name
	mov	di,[DestTail]		; Where to put result

; --------------- S U B	R O U T	I N E --------------------------------------- 

	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
BUILDNAME:
	mov	cx,8
BUILDMAIN:
	lodsb
	cmp	al,'?'
	jne	short NOTAMBIG
	mov	al,[bx]
NOTAMBIG:
	cmp	al,' '
	je	short NOSTORE
	stosb
NOSTORE:
	inc	bx
	loop	BUILDMAIN
	mov	cl,3
	;mov	al,' ' ; 20h
	;cmp	[si],al
	; 27/03/2023
	cmp	byte [si],20h ; ' '
	je	short ENDDEST		; No extension
	;mov	al,[DOT_CHR]
	; 27/03/2023
	mov	al,'.' ; 2Eh ; dot_chr
	stosb
BUILDEXT:
	lodsb
	cmp	al,'?'
	jne	short NOTAMBIGE
	mov	al,[bx]
NOTAMBIGE:
	cmp	al,' '
	je	short NOSTOREE
	stosb
NOSTOREE:
	inc	bx
	loop	BUILDEXT
ENDDEST:
	xor	al,al
	stosb				; NUL terminate
	retn

; =============== S U B	R O U T	I N E =======================================
	
	; 28/03/2023
	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
BUILDPATH:
	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
	jnz	short NOTPFILE		; If ambig don't bother with open
	mov	dx,bp			; Set DX to spec
	add	dx,VARSTRUC.BUF 	; add dx,5

	; 27/03/2023
	; MSDOS 6.0
	push	di			;AN000;
	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
	;mov	bx,deny_none|read_open_mode
	mov	bx,40h			; open mode for COPY ;M046
	xor	cx,cx			;AN000; no special files
	mov	si,dx			;AN030; get file name offset
	;mov	dx,read_open_flag	;AN000; set up open flags
	mov	dx,101h
	INT	21h
	pop	di			;AN000;
	jnc	short PURE_FILE		;AN022; is pure file
	call	get_ext_error_number	;AN022; get the extended error
	;cmp	ax,2
	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
	jz	short NOTPFILE		;AN022;
	;cmp	ax,3
	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
	jz	short NOTPFILE		;AN022;
	;cmp	ax,5
	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
	jz	short NOTPFILE		;AN022;
	jmp	extend_setup		;AN022; exit with error

	; 27/03/2023
	; MSDOS 3.3
	;mov	ax,OPEN*256 ; 3D00h
	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
	;			; DS:DX	-> ASCIZ filename
	;			; AL = access mode
	;			; 0 - read
	;jc	short NOTPFILE

PURE_FILE:
	mov	bx,ax
	mov	ax,IOCTL*256 ; 4400h
	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
				; BX = file or device handle
	mov	ah,CLOSE ;3Eh
	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
				; BX = file handle
	; 18/04/2023
	test	dl,80h
	;test	dl,devid_ISDEV ; test dl,80h
	jnz	short ISADEV
	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
	jz	short ISADEV
NOTPFILE:
	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
	
	; 27/03/2023	
	; MSDOS 6.0
	cmp	dl,0		     	;AN034; If no drive specified, get
	je	short SET_DRIVE_SPEC	;AN034;    default drive dir

	cmp	dh,':'
	je	short DRVSPEC5
SET_DRIVE_SPEC:
	mov	dl,'@' ; 40h
DRVSPEC5:
	or	dl,20h
	sub	dl,60h		; A = 1
	call	SAVUDIR1
	
	; 27/03/2023
	; MSDOS 6.0
	jnc	short CURDIR_OK		;AN022; if error - exit
	call	get_ext_error_number	;AN022; get the extended error
	jmp	extend_setup		;AN022; exit with error

CURDIR_OK:
	mov	dx,bp
	;add	dx,5
	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
	;mov	bh,[bp+4]
	mov	bh,[bp+VARSTRUC.INFO]
	and	bh,6
	cmp	bh,6			; Ambig and path ?
	jne	short CHECKAMB		; jmp if no
	;mov	si,[bp+2]
	mov	si,[bp+VARSTRUC.TTAIL]
	mov	bl,':'
	cmp	[si-2],bl
	jne	short KNOWNOTSPEC
	;mov	byte [bp+VARSTRUC.ISDIR],2
					; Know is d:/file
	;mov	byte [bp+0],2
	mov	byte [bp],2
	jmp	short DOPCDJ
KNOWNOTSPEC:
	;mov	byte [bp+VARSTRUC.ISDIR],1
					; Know is path/file
	;mov	byte [bp+0],1		
	mov	byte [bp],1
	dec	si
DOPCDJ:
	jmp	DOPCD
CHECKAMB:
	cmp	bh,2
	jnz	short CHECKCD
ISSIMPFILE:
ISADEV:
	;mov	byte [bp+VARSTRUC.ISDIR],0
	;mov	byte [bp+0],0		
	mov	byte [bp],0
	retn
CHECKCD:
	call	SetRest1
	mov	ah,CHDir ; 3Bh
	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
	jb	short NOTPDIR
	mov	di,dx
	xor	ax,ax
	mov	cx,ax
	dec	cx
	; 14/06/2023
	;repne	scasb	 ; MSDOS 3.3

	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
	; MSDOS 6.0
Kloop:					;AN000;  3/3/KK
	mov	al,[es:di]		;AN000;  3/3/KK
	inc	di			;AN000;  3/3/KK
	or	al,al			;AN000;  3/3/KK
	jz	short DONE		;AN000;  3/3/KK
	xor	ah,ah			;AN000;  3/3/KK
	call	testkanj		;AN000;  3/3/KK
	jz	short Kloop		;AN000;  3/3/KK
	inc	di			;AN000;  3/3/KK
	inc	ah			;AN000;  3/3/KK
	jmp	short Kloop		;AN000;  3/3/KK
DONE:
	dec	di
	mov	al,[DIRCHAR]
	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
	;mov	byte [bp+0],2
	mov	byte [bp],2
	; 27/03/2023
	; MSDOS 6.0
	or	ah,ah			;AN000; 3/3/KK
	jnz	short _STORE_PCHAR	;AN000; 3/3/KK	 this is the tra
	;
	cmp	al,[di-1]
	jz	short GOTSRCSLSH
_STORE_PCHAR:
	stosb
	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
	;mov	byte [bp+0],1
	mov	byte [bp],1
GOTSRCSLSH:
	;or	byte [bp+4],6
	or 	byte [bp+VARSTRUC.INFO],6 
	call	SETSTARS
NOTPDIR_RETN:
	retn

	; 28/03/2023
NOTPDIR:
	; MSDOS 6.0
	call	get_ext_error_number	;AN022; get the extended error
	;cmp	ax,3
	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
	je	short NOTPDIR_TRY	;AN022;
	;cmp	ax,5
	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
NOTPDIR_TRY:
	; MSDOS 3.3 (& MSDOS 6.0)
	;mov	byte [bp+VARSTRUC.ISDIR],0
	;mov	byte [bp+0],0
	mov	byte [bp],0
	;mov	bh,[bp+4]
	mov	bh,[bp+VARSTRUC.INFO]
	test	bh,4
	jz	short NOTPDIR_RETN	; Know pure file, no path seps
	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
	;mov	byte [bp+0],2		
	mov	byte [bp],2
	;mov	si,[bp+2]
	mov	si,[bp+VARSTRUC.TTAIL]
	cmp	byte [si],0
	je	short BADCDERRJ2	; Trailing '/'	
	;mov	bl,[DOT_CHR]
	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 6.0 (& 5.0) COMMAND.COM
	mov	bl,'.'  ; 2Eh ; dot_chr
	cmp	[si],bl
	je	short BADCDERRJ2	; If . or .. pure cd should have worked
	mov	bl,':'  ; 3Ah
	cmp	[si-2],bl
	je	short DOPCD		; Know d:/file
	;mov	byte [bp+VARSTRUC.ISDIR],1 
					; Know path/file
	;mov	byte [bp+0],1
	mov	byte [bp],1
	dec	si			; Point at last '/'
DOPCD:
	xor	bl,bl
	xchg	bl,[si]			; Stick in a NUL
	call	SetRest1

	; 28/03/2023
	; MSDOS 6.0 (& MSDOS 5.0)
	cmp	dx,si			;AN000;  3/3/KK
	ja	short LookBack		;AN000;  3/3/KK
	push	si			;AN000;  3/3/KK
	push	cx			;AN000;  3/3/KK
	mov	cx,si			;AN000;  3/3/KK
	mov	si,dx			;AN000;  3/3/KK
Kloop2: 				;AN000;  3/3/KK
	lodsb				;AN000;  3/3/KK
	call	testkanj		;AN000;  3/3/KK
	jz	short NotKanj4		;AN000;  3/3/KK
	lodsb				;AN000;  3/3/KK
	cmp	si,cx			;AN000;  3/3/KK
	jb	short Kloop2		;AN000;  3/3/KK
	pop	cx			;AN000;  3/3/KK
	pop	si			;AN000;  3/3/KK
	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
					;		 trailing path sep
NotKanj4:				;AN000;  3/3/KK
	cmp	si,cx			;AN000;  3/3/KK
	jb	short Kloop2		;AN000;  3/3/KK
	pop	cx			;AN000;  3/3/KK
	pop	si			;AN000;  3/3/KK
LookBack:				;AN000;  3/3/KK
	; 28/03/2023
	; MSDOS 3.3 & MSDOS 6.0
	cmp	bl,[si-1]		; if double slash, then complain.
	je	short BADCDERRJ2
DoCdr:
	mov	ah,CHDir ; 3Bh
	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
				; DS:DX	-> ASCIZ directory name	(may include drive)
	xchg	bl,[si]
	jnc	short NOTPDIR_RETN
	
	; 28/03/2023
	; MSDOS 3.3
;BADCDERRJ2:
	;stc
	;jmp	BADCDERR

	; 28/03/2023
	; MSDOS 6.0 (& MSDOS 5.0)
	call	get_ext_error_number	;AN022; get the extended error
EXTEND_SETUPJ:					;AN022;
	jmp	extend_setup		;AN022; go issue the error message
BADCDERRJ2:
	jmp	badpath_err		;AC022; go issue path not found message

; =============== S U B	R O U T	I N E =======================================

	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
SETSTARS:
	;mov	[bp+2],di
	mov	[bp+VARSTRUC.TTAIL],di
	;add	byte [bp+1],12
	add	byte [bp+VARSTRUC.SIZ],12
	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
	; 28/03/2023
	; MSDOS 6.0
	mov	ax,dot_qmark ; 2E3Fh
	;mov	ax,'?.' ; dot_qmark

	mov	cx,8
	rep	stosb
	xchg	al,ah
	stosb
	xchg	al,ah
	mov	cl,3
	rep	stosb
	xor	al,al
	stosb
	retn

; =============== S U B	R O U T	I N E =======================================

	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
COMPNAME:
	mov	si,DestBuf	; do name translate of target
	mov	di,TRGXNAME	; save for name comparison
	mov	ah,xNameTrans ; 60h
	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
			; DS:SI	-> ASCIZ relative path string or directory name
			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
	mov	si,SRCXNAME	; get name translate of source
	mov	di,TRGXNAME	; get name translate of target
	;call	STRCOMP
	;retn
	; 28/03/2023
	jmp	STRCOMP

;============================================================================
; CPARSE.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/09/2018 - Retro DOS v3.0
; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;-----------------------------------------------------------------------;
; ENTRY:								;
;	DS:SI	Points input buffer					;
;	ES:DI	Points to the token buffer				;
;	BL	Special delimiter for this call 			;
;		    Always checked last 				;
;		    set it to space if there is no special delimiter	;
; EXIT: 								;
;	DS:SI	Points to next char in the input buffer 		;
;	ES:DI	Points to the token buffer				;
;	[STARTEL] Points to start of last element of path in token	;
;		points to a NUL for no element strings 'd:' 'd:/'       ;
;	CX	Character count 					;
;	BH	Condition Code						;
;			Bit 1H of BH set if switch character		;
;				Token buffer contains char after	;
;				switch character			;
;				BP has switch bits set (ORing only)	;
;			Bit 2H of BH set if ? or * in token		;
;				if * found element ? filled		;
;			Bit 4H of BH set if path sep in token		;
;			Bit 80H of BH set if the special delimiter	;
;			   was skipped at the start of this token	;
;		Token buffer always starts d: for non switch tokens	;
;	CARRY SET							;
;	    if CR on input						;
;		token buffer not altered				;
;									;
;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
; MODIFIES:								;
;	CX, SI, AX, BH, DX and the Carry Flag				;
;									;
;-----------------------------------------------------------------------;

; Modifications to cparse: recognition of right and left parentheses
; as integral tokens, and removal of automatic upper-case conversion code.
;
; Both modifications were installed in the course of adding a coherent
; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
; structure for command-line arguments. This parser relies on cparse to
; recognize individual tokens.
;
; To process for-loops correctly, parentheses must therefore be
; recognized as tokens. The upper-case conversion code was removed so
; that commands (such as for and echo) would be able to use the "original"
; text of the command line.
;
; Note also the modification to prevent the automatic conversion of colons
; into spaces WITHIN THE SOURCE TEXT!
;
; Also note that BP is also clobbered if cparse recognizes any switches
; on the command line.
;
; Alan L, OS/MSDOS				    14 August 1983

; ---------------------------------------------------------------------------

; COMEQU.ASM (MSDOS 6.0, 1991)

;FSWITCH	EQU	8000h
;FBADSWITCH	EQU	4000h

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h

; =============== S U B	R O U T	I N E =======================================
		
	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh

cparse:
	xor	ax,ax
	mov	[STARTEL],di		; No path element (Is DI correct?)
	mov	[ELPOS],al		; Start in 8 char prefix
	; MSDOS 3.3
	;mov	[SOURCE],al		
	; MSDOS 6.0
	mov	[SKPDEL], al		; No skip delimiter yet
	mov	bh,al			; Init nothing
	pushf				; save flags
	push	di			; save the token buffer addrss
	xor	cx,cx			; no chars in token buffer
	mov	[comma],cl		; reset comma flag
moredelim:
	lodsb
	call	DELIM
	jnz	short SCANCDONE
	cmp	al,' '
	jz	short moredelim
	cmp	al,9
	jz	short moredelim
	;xchg	al,[SOURCE]
	; 28/03/2023
	xchg	al,[SKPDEL]
	or	al,al
	jz	short moredelim		; One non space/tab delimiter allowed
	test	bh,80h			; has a special char been found?
	jz	short no_comma		; no - just exit
	mov	byte [comma],1		; set comma flag
no_comma:
	jmp	x_done			; Nul argument

SCANCDONE:
	; 28/03/2023
	; MSDOS 6.0
	; -----------------------------------
	; Mod to avoid upper-case conversion.
	; -----------------------------------
	; MSDOS 3.3
	;cmp	byte [CPYFLAG],1	; 3/3/KK
	;jnz	short cpcont1		; 3/3/KK
	;call	UPCONV_MAPCALL		; 3/3/KK
cpcont1:
	; -----------------------------------
	; 28/03/2023
	cmp	al,bl			; Special delimiter?
	jne	short nospec
	or	bh,80h
	jmp	short moredelim
nospec:
	cmp	al,0Dh			; a CR?
	jne	short ncperror
	jmp	cperror
ncperror:
	cmp	al,[SWITCHAR]		; is the char the switch char?
	jne	short na_switch		; yes, process...
	jmp	a_switch
na_switch:
	mov	dl,':'
	cmp	[si],dl
	jne	short anum_chard	; Drive not specified
	; 28/03/2023
	; MSDOS 6.0 
	cmp	byte [cpyflag],1	; 3/3/KK
	jne	short cpcont2		; 3/3/KK
	call	UPCONV			; 3/3/KK
cpcont2:
	call	move_char
	lodsb				; Get the ':'
	call	move_char
	mov	[STARTEL],di
	mov	byte [ELCNT],0
	jmp	anum_test
anum_chard:
	mov	[STARTEL],di
	mov	byte [ELCNT],0		; Store of this char sets it to one
	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
	jnz	short anum_char		; No, don't add drive spec.
	call	pathchrcmp		; Starts with a pathchar?
	jnz	short anum_char		; no
	push	ax
	mov	al,[CURDRV]		; Insert drive spec
	;add	al,[CAPITAL_A]
	; 28/03/2023
	; MSDOS 6.0
	add	al,'A' ; 41h
	call	move_char
	mov	al,':' ; 3Ah
	call	move_char
	pop	ax
	mov	[STARTEL],di
	mov	byte [ELCNT],0
anum_char:
	; 28/03/2023
	; MSDOS 6.0
	call	testkanj		;AC048			
	jz	short NOTKANJ		;AC048;
	call	move_char
	lodsb
	jmp	short notspecial

NOTKANJ:				;AN048; If not kanji
	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
	jne	short TESTDOT 		;AN048;
	call	UPCONV			;AN048; upper case the char
TESTDOT:
	; 28/03/2023
	;cmp	al,dot_chr  ; 2Eh
	cmp	al,'.'
	jne	short testquest
	inc	byte [ELPOS] 		; flag in extension
	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
testquest:
	cmp	al,'?'  ; 3Fh
	jnz	short testsplat
	or	bh,2
testsplat:
	;cmp	al,[STAR]
	cmp	al,star	; 2Ah
	; 27/04/2023
	;cmp	al,'*' 
	jne	short testpath
	or	bh,2
	cmp	byte [expand_star],0
	jne	short expand_filename
	jmp	short testpath

BADPERR2J:
	;jmp	BADPERR2
	; 28/03/2023
	; MSDOS 6.0
	jmp	short BADPERR2

expand_filename:
	mov	ah,7
	cmp	byte [ELPOS],0
	jz	short gotelcnt
	mov	ah,2
gotelcnt:
	mov	al,'?'
	sub	ah,[ELCNT]
	jb	short BADPERR2J
	xchg	ah,cl
	jcxz	testpathx
qmove:
	xchg	ah,cl
	call	move_char
	xchg	ah,cl
	loop	qmove
testpathx:
	xchg	ah,cl
testpath:
	call	pathchrcmp
	jnz	short notspecial
	or	bh,4
	cmp	byte [expand_star],0
	jz	short no_err_check
	test	bh,2			; If just hit a '/', cannot have ? or * yet
	jnz	short BADPERR
no_err_check:
	mov	[STARTEL],di	  	; New element
	inc	word [STARTEL]	  	; Point to char after /
	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
	mov	byte [ELPOS],0
notspecial:
	call	move_char		; just an alphanum string
anum_test:
	lodsb

	; 28/03/2023
	; MSDOS 6.0
	; -----------------------------------
	; Mod to avoid upper-case conversion.
	; -----------------------------------
	; MSDOS 3.3
	;cmp	byte [CPYFLAG],1	; 3/3/KK
	;jnz	short cpcont3		; 3/3/KK
	;call	UPCONV_MAPCALL		; 3/3/KK
cpcont3:
	; -----------------------------------

	call	DELIM
	jz	short x_done
	cmp	al,0Dh
	je	short x_done
	cmp	al,[SWITCHAR]
	je	short x_done
	cmp	al,bl
	je	short x_done
	cmp	al,':'			; ':' allowed as trailer because of devices
	; 28/03/2023
	; MSDOS 3.3
	;jnz	short ANUM_CHARJ 
	; MSDOS 6.0
	je	short FOO15
	jmp	anum_char

; Modification made for parseline.
; Why would it be necessary to change colons to spaces? In this
; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
; but so does 'echo foo:bar' yield 'echo foo bar'.

FOO15:
	cmp	byte [cpyflag],2
	jnz	short cpcont4
	call	move_char
	jmp	short anum_test
cpcont4:
	inc	si			; Skip the ':'
	jmp	short x_done

	; 28/03/2023
;ANUM_CHARJ:
	;jmp	anum_char

BADPERR2:
	mov	dx,BADCPMES_PTR
	jmp	cerror

BADPERR:
	; 28/03/2023
	;jmp	BADCDERR  ; MSDOS 3.3	
BADCDERR:
	; MSDOS 6.0
	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
	jmp	cerror			;AC022;  message
	
cperror:
	dec	si			; adjust the pointer
	pop	di			; retrive token buffer address
	popf				; restore flags
	stc				; set the carry bit
	retn

x_done:
	dec	si			; adjust for next round

; Mod to recognize right and left parens as integral tokens.
;x_done2:
	jmp	short out_token

a_switch:
	or	bh,1			; Indicate switch
	;or	bp,FSWITCH ; 8000h
	; 28/03/2023
	or	bp,8000h
	call	scanoff
	inc	si
	; 28/03/2023
	; MSDOS 6.0
	call	testkanj		;AN057; See if DBCS lead byte
	jz	short a_switch_notkanj	;AN057; no - continue processing
	call	move_char		;AN057; DBCS - store first byte
	lodsb				;AN057; get second byte
	call	move_char		;AN057; store second byte
	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
	or	bp,4000h
	jmp	short out_token 	;AN057; don't bother checking switch
a_switch_notkanj:			;AN057;
	cmp	al,0Dh
	jne	short Store_swt
	mov	al,0
	stosb
	;or	bp,FBADSWITCH ; 4000h
	or	bp,4000h
	jmp	short cperror		; Trailing switch character error
					;   BP = fSwitch but no switch
					;   bit is set (unknown switch)
Store_swt:
	call	move_char		; store the character

; This upconv call must stay. It is used to identify copy-switches
; on the command line, and won't store anything into the output buffer.

	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
	; 28/03/2023
	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
	
	push	es
	push	di
	push	cx
	push	cs
	pop	es
	; 28/03/2023
	; MSDOS 3.3
	;mov	di,SWITCH_LIST ; "VBAPW"
	; MSDOS 6.0
	mov	di,switch_list ; "?VBAPW"
	; MSDOS 3.3
	;mov	cx,SWCOUNT ; 5
	; MSDOS 6.0
	mov	cx,6  ; SWCOUNT = 6
	;or	bp,FBADSWITCH  ; 4000h
	or	bp,4000h
	repne	scasb
	jnz	short out_tokenp
	;and	bp,~FBADSWITCH ; 0BFFFh
	and	bp,0BFFFh
	mov	ax,1
	shl	ax,cl
	or	bp,ax
out_tokenp:
	pop	cx
	pop	di
	pop	es
out_token:
	mov	al,0			; null at the end
	stosb
	pop	di			; restore token buffer pointer	
	popf
	clc				; clear carry flag
	retn

; =============== S U B	R O U T	I N E =======================================

	; 28/03/2023
move_char:
	stosb				; store char in token buffer
	inc	cx			; increment char count
	inc	byte [ELCNT]		; increment element count for * substi
	retn

;============================================================================
; PARSE.ASM, MSDOS 6.0, 1991
;============================================================================
; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; -----------------------------
; (PSDATA.INC, MSDOS 6.0, 1991)
; -----------------------------

;**** Equation field
;-------- Character code definition

$P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
$P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
$P_Period	   equ	"."             ;AN020;
$P_Slash	   equ	"/"             ;AN020;
$P_Space	   equ	" "             ;AN000; SBCS blank
$P_Comma	   equ	","             ;AN000;
$P_Switch	   equ	"/"             ;AN000;
$P_Keyword	   equ	"="             ;AN000;
$P_Colon	   equ	":"             ;AN000;
$P_Plus 	   equ	"+"             ;AN000;
$P_Minus	   equ	"-"             ;AN000;
$P_Rparen	   equ	")"             ;AN000;
$P_Lparen	   equ	"("             ;AN000;
;(deleted ;AN025;) $P_SQuote	      equ  "'"
$P_DQuote	   equ	'"'             ;AN000;
$P_NULL 	   equ	0		;AN000;
$P_TAB		   equ	9		;AN000;
$P_CR		   equ	0Dh		;AN000;
$P_LF		   equ	0Ah		;AN000;
$P_ASCII80	   equ	80h		;AN000; ASCII 80h character code

$P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
$P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table

$P_error_filespec  equ  1

;----------------------------------------------------------------------------
; PARMS LABEL	BYTE
;	DW	PARMSX
;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
;	DB	" .. "          ; EXTRA DELIMITER LIST,
;				; TYPICAL ARE ";", "="
;				; "," & WHITESPACE ALWAYS
;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
;----------------------------------------------------------------------------

struc $P_PARMS_BLK			;AN000;
.$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
.$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
.$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
endstruc 				;AN000;

$P_Len_PARMS	   equ	4		;AN000;
$P_I_Use_Default   equ	0		;AN000; no extra stuff specified
$P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
$P_I_Have_EOL	   equ	2		;AN000; extra EOL specified

;----------------------------------------------------------------------------
; PARMSX LABEL	BYTE
;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
;	:				; REPEATS maxp-1 TIMES
;	DB	maxs			; # OF SWITCHES
;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
;	:				; REPEATS maxs-1 TIMES
;	DB	maxk			; # OF KEYWORD
;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
;	:				; REPEATS maxk-1 TIMES
;----------------------------------------------------------------------------

struc $P_PARMSX_BLK			;AN000;
.$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
.$P_MaxP: 	 resb 1			;AN000; Maximum positional number
.$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
endstruc				;AN000;

; 31/03/2023
;----------------------------------------------------------------------------
; << Control field definition >>
;
;CONTROL   LABEL   BYTE
;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
;				; 0010H=IGNORE ":" AT END IN MATCH
;				; 0002H=REPEATS ALLOWED
;				; 0001H=OPTIONAL
;	   DW FUNCTION_FLAGS
;				; 0001H=CAP RESULT BY FILE TABLE
;				; 0002H=CAP RESULT BY CHAR TABLE
;				; 0010H=REMOVE ":" AT END
; (tm10)			; 0020H=colon is not necessary for switch
;
;	   DW RESULT		; RESULT BUFFER
;	   DW VALUES		; VALUE LISTS
;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
;	   DB "...",0		; IF n >0, KEYWORD 1
;	   :
;
;Note:
;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
;      DATE bit simalteniously.
;
;      The parser examins each bit along with the following priority.
;
;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
;      FILE SPEC -> SIMPLE STRING.
;
;
;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
;      in the result buffer is capitalized.
;
;    - Match_Flags 0001H and 0002H have meaning only for the positional.
;
;
;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
;      switch, for example, '/A', then STRING points to;
;
;		DB    1 	; number of following synonyms
;		DB   '/A',0
;
;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
;
;		DB    1 	; number of following synonyms
;		DB   'CODEPAGE=',0
;
;
;    - "..." must consist of upper case characters only because the parser
;      performs pattern matching after converting input to upper case (by
;      using the current country upper case table)
;
;
;    - One "..." can contain only one switch or keyword. If you need, for
;      example /A and /B, the format will be;
;
;		DB    2 	; number of following synonyms
;		DB    '/A',0
;		DB    '/B',0
;----------------------------------------------------------------------------

;**** Match_Flags

$P_Num_Val	   equ	8000h		;AN000; Numeric Value
$P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
$P_Simple_S	   equ	2000h		;AN000; Simple string
$P_Date_S	   equ	1000h		;AN000; Date string
$P_Time_S	   equ	0800h		;AN000; Time string
$P_Cmpx_S	   equ	0400h		;AN000; Complex string
$P_File_Spc	   equ	0200h		;AN000; File Spec
$P_Drv_Only	   equ	0100h		;AN000; Drive Only
$P_Qu_String	   equ	0080h		;AN000; Quoted string
$P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
$P_Repeat	   equ	0002h		;AN000; Repeat allowed
$P_Optional	   equ	0001h		;AN000; Optional

;**** Function flags

$P_CAP_File	   equ	0001h		;AN000; CAP result by file table
$P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
$P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
$P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10

;-------------------------------- Control block structure
struc $P_CONTROL_BLK
.$P_Match_Flag:	   resw 1		;AN000; Controls type matched
.$P_Function_Flag: resw 1		;AN000; Function should be taken
.$P_Result_Buf:	   resw 1		;AN000; Result buffer address
.$P_Value_List:	   resw 1		;AN000; Value list address
.$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
.$P_KEYorSW:	   resb 1		;AN000; keyword or sw
endstruc

; 31/03/2023
;----------------------------------------------------------------------------
;
;VALUES LABEL	BYTE
;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
;	+-
;	| DB	nrng		; NUMBER OF RANGES
;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
;	| +DD	X,Y		; RANGE OF VALUES
;	|	:
;	| DB	nnval		; NUMBER OF CHOICES
;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
;	|	:
;	| DB	nstrval 	; NUMBER OF CHOICES
;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
;	| +DW	STRING		; SPECIFIC CHOICE IF STING
;	+-	:
;
;STRING DB	"...",0		; ASCIIZ STRING IMAGE
;
;Note:
;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
;      when no choice lists are provided.
;
;    - STRING must consist of upper case characters only because the parser
;      performs pattern matching after converting input to upper case (by
;      using the current country upper case table)
;----------------------------------------------------------------------------

$P_nval_None	equ 0		;AN000; no value list ID
$P_nval_Range	equ 1		;AN000; range list ID
$P_nval_Value	equ 2		;AN000; value list ID
$P_nval_String	equ 3		;AN000; string list ID
$P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
$P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
$P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
$P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.

struc $P_VAL_LIST
.$P_NumofList:	resb 1		;AN000; number of following choice
.$P_Val_XL:	resw 1		;AN000; lower word of value
.$P_Val_XH:	resw 1		;AN000; higher word of value
.$P_Val_YL:	resw 1		;AN000; lower word of another value
.$P_Val_YH:	resw 1		;AN000; higher word of another value
endstruc

; 31/03/2023
;----------------------------------------------------------------------------
;
;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
;	DB	type			; TYPE RETURNED: 0=RESERVED,
;					;	1=NUMBER, 2=LIST INDEX,
;					;	3=STRING, 4=COMPLEX,
;					;	5=FILESPEC, 6=DRIVE
;					;	7=DATE, 8=TIME
;					;	9=QUOTED STRING
;	DB	ITEM_TAG		; MATCHED ITEM TAG
;
;	dw	synonym@		; es:@ points to found SYNONYM if provided.
;
;       +-
;       | DD	n			; VALUE IF NUMBER
;       | or
;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
;       |				; (ES presents Segment address)
;       | or
;       |	DD STRING		; OFFSET OF STRING VALUE
;       | or
;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
;       | or
;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
;       | or
;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
;       |	DB HUNDREDTHS ;(0-99)
;       +-
;
;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
;      list.
;
;      YEAR: If the input value for the year is less than 100, parser
;	     adds 1900 to it. For example, when 87 is input to parser for
;	     the year value, he returns 1987.
;----------------------------------------------------------------------------

;-------------------------------- Result block structure
struc $P_RESULT_BLK;
.$P_Type:	 resb 1		;AN000; Type returned
.$P_Item_Tag:	 resb 1		;AN000; Matched item tag
.$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
.$P_Picked_Val:	 resb 4		;AN000; value
endstruc

;**** values for the type field in the result block

$P_EOL		 equ 0		;AN000; End of line
$P_Number	 equ 1		;AN000; Number
$P_List_Idx	 equ 2		;AN000; List Index
$P_String	 equ 3		;AN000; String
$P_Complex	 equ 4		;AN000; Complex
$P_File_Spec	 equ 5		;AN000; File Spec
$P_Drive	 equ 6		;AN000; Drive
$P_Date_F	 equ 7		;AN000; Date
$P_Time_F	 equ 8		;AN000; Time
$P_Quoted_String equ 9		;AN000; Quoted String

$P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found

;**** Return code
;
; following return code will be returned in the AX register.

$P_No_Error	 equ 0		;AN000; No error
$P_Too_Many	 equ 1		;AN000; Too many operands
$P_Op_Missing	 equ 2		;AN000; Required operand missing
$P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
$P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
$P_Out_Of_Range  equ 6		;AN000; Out of range specified
$P_Not_In_Val	 equ 7		;AN000; Not in value list provided
$P_Not_In_Str	 equ 8		;AN000; Not in string list provided
$P_Syntax	 equ 9		;AN000; Syntax error
$P_RC_EOL	 equ -1		;AN000; End of command line

;in second byte of $P_Flags, referenced as $P_Flags2:
$P_equ		 equ 01h	;AN000; "=" packed in string buffet
$P_Neg		 equ 02h	;AN000; Negative value
$P_Time12	 equ 04h	;AN000; set when PM is specified
$P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
$P_SW_Cmp	 equ 10h	;AN000; set when switch compare
$P_Extra	 equ 20h	;AN000; set when extra delimiter found
$P_SW		 equ 40h	;AN000; set when switch found (tm08)
$P_Signed	 equ 80h	;AN000; signed numeric specified

;-------- Masks
$P_Make_Lower	 equ 20h	;AN000; make lower case character
$P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character

;-------------

struc $P_DOS_TBL
.$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
.$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
.$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
endstruc

$P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
				;AN000; following parameters are set
				;AN000; to get casemap table.
$P_DOSTBL_Def	 equ -1		;AN000; get default
$P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
$P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
$P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
				; By this call following information
				; is returned.

; 03/04/2023
;-------------------------------- country dependent information

$P_DOS_Get_CDI	equ 3800h

struc $P_CDI
.$P_CDI_DateF:	resw 1		;AN000;
.$P_CDI_Money:	resb 4		;AN000;
.$P_CDI_1000:	resb 2		;AN000;
.$P_CDI_Dec:	resb 2		;AN000;
.$P_CDI_DateS:	resb 2		;AN000;
.$P_CDI_TimeS:	resb 2		;AN000;
		resb 1		;AN000;
		resb 1		;AN000;
.$P_CDI_TimeF:	resb 1		;AN000;
		resw 2		;AN000;
		resb 2		;AN000;
		resw 5		;AN000;
endstruc

$P_Date_MDY	equ 0		;AN000;
$P_Date_DMY	equ 1		;AN000;
$P_Date_YMD	equ 2		;AN000;

; ----------------------------
; (PARSE.ASM, MSDOS 6.0, 1991)
; ----------------------------

;***********************************************************************
; SysParse;
;
;  Function : Parser Entry
;
;  Input: DS:SI -> command line
;	  ES:DI -> parameter block
;	  psdata_seg -> psdata.inc
;	  CX = operand ordinal
;
;	  Note:  ES is the segment containing all the control blocks defined
;		 by the caller, except for the DOS COMMAND line parms, which
;		 is in DS.
;
;  Output: CY = 1   error of caller, means invalid parameter block or
;		    invalid value list. But this parser does NOT implement
;		    this feature. Therefore CY always zero.
;
;	   CY = 0   AX = return code
;		    BL = terminated delimiter code
;		    CX = new operand ordinal
;		    SI = set past scaned operand
;		    DX = selected result buffer
;
; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
;	$P_Chk_Sw_Control, $P_Fill_Result
;
; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
;
;-------- Modification History -----------------------------------------
;
;  4/04/87 : Created by K. K,
;  4/28/87 : $P_Val_YH assemble error (tm01)
;	   : JMP SHORT assemble error (tm02)
;  5/14/87 : Someone doesn't want to include psdata (tm03)
;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
;	     DateSW equ 1)	      (tm04)
;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
;				      (tm05) in PSDATA.INC
;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
;	     value-list block	      (tm07)
;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
;	     switch (keyword) or not. If there is, backup si for next call
;	     (tm08)
;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
;	     /+15 and /+:15 are allowed for user (tm10)
;  6/29/87 : ECS call changes DS register but it causes the address problem
;	     in user's routines. $P_Chk_DBCS (tm11)
;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
;					  (tm12)
;  7/10/87 : Invalid switch/keyword does not work correctly
;					  (tm13)
;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
;					  (tm14)
;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
;					  (tm15)
;  7/24/87 : Negative lower bound on numeric ranges cause trouble
;
;  7/24/87 : Quoted strings being returned with quotes.
;
;  7/28/87 : Kerry S (;AN018;)
;	     Non optional value on switch (match flags<>0 and <>1) not flagged
;	     as an error when missing.	Solution: return error 2.  Modules
;	     affected: $P_Chk_SW_Control.
;
;  7/29/87 : Kerry S (;AN019;)
;	     Now allow the optional bit in match flags for switches.  This
;	     allows the switch to be encountered with a value or without a
;	     value and no error is returned.
;
;
;  8/28/87 : Ed K, Kerry S (;AN020;)
;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
;	     within a date response, instead of checking just for the one
;	     character defined by the COUNTRY DEPENDENT INFO, check for
;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
;	     slashes in date strings when DateSw (assembler switch) is set.
;
;  9/1/87  : Kerry S (;AN021)
;	     In PROC $P_String_Comp, when comparing the switch or keyword on
;	     the command line with the string in the control block the
;	     comparing was stopping at a colon (switch) or equal (keyword)
;	     on the command line and assuming a match.	This allowed a shorter
;	     string on the command line than in the synonym list in the control
;	     block.  I put in a test for a null in the control block so the
;	     string in the control block must be the same length as the string
;	     preceeding the colon or equal on the command line.
;
;  8/28/87 : Kerry S (;AN022;)
;	     All references to data in PSDATA.INC had CS overrides.  This caused
;	     problems for people who included it themselves in a segment other
;	     than CS.  Added switch to allow including PSDATA.INC in any
;	     segment.
;
;  9/16/87 : Ed K (;AN023;) PTM1040
;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
;	     forced both TIME and DATE to use the delims, "-","/",".".
;	     Created FLag, in $P_time_Format PROC, to request the delim in
;	     BL be used if TIME is being parsed.
;
;  9/24/87 : Ed K
;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
;	     invocations with their normally expanded code; made comments
;	     out of the STRUC macro invocation statements to maintain readability.
;
;  9/24/87 : Ed K (;AN024;) PTM1222
;	     When no CONTROL for a keyword found, tried to fill in RESULT
;	     pointed to by non-existant CONTROL.
;
; 10/15/87 : Ed K (;AN025;) PTM1672
;	     A quoted text string can be framed only by double quote.  Remove
;	     support to frame quoted text string with single quote.
;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
;	     single quote in PROC prologues are left as is for history reasons.
;
;	     This fixes another bug, not mentioned in p1672, in that two
;	     quote chars within a quoted string is supposed to be reported as
;	     one quote character, but is reported as two quotes.  This changed
;	     two instructions in PROC $P_Quoted_Str.
;
;	     Also fixed are several JMP that caused a NOP, these changed to
;	     have the SHORT operator to avoid the unneeded NOP.
;
;	     The code and PSDATA.INC have been aligned for ease of reading.
;
; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
;	     psdata buffer should have psdata_seg.
;
; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
;	     positional missing.
;
; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
;	     as a line delimiter, should use carriage return.
;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
;
; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
;
; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
;	     endless loop since SI is returned still pointing to start
;	     of that parm.
;
; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
;	     Vector to returned string has CS instead of Psdata_Seg, but
;	     when tried to fix it on previous version, changed similar
;	     but wrong place.
;
; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
;	     delimiters between hours, minutes, seconds for time. And period
;	     and comma are valid delimiters between seconds and 100th second.
;
; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
;	     in a filespec, then flag an error.
;
; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
;	     indexed off of the psdata_seg equate instead of the DS register.
;	     Using this method, DS can point to the segment of PSP or to psdata
;  -->	     local parser data. Why were some references to local data changed
;	     to do this before, but not all ?????
;
; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
;
; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
;
; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
;
; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
;
; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
;	     separator in TIME before hundredths field.
;
; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
;			strings as keywords.
;
;***********************************************************************

	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
cmd_parse:
	;call	sysparse
	;retn

; -----------------------------------

	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h

sysparse:
	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
$P_Redo_Time:				;AN039; try to parse time again
	cld				;AN000; confirm forward direction
	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
	;mov	word [cs:$P_RC],$P_No_Error
	mov	word [cs:$P_RC],0	;AC034; Assume no error
	mov	word [cs:$P_Found_SYNONYM],0
					;AC034; initalize synonym pointer
	mov	word [cs:$P_DX],0	;AC034; (tm15)

;M029 -- Begin changes
; The table of special chars $P_FileSp_Char should be initialized on every
;entry to SysParse. This is in the non-checksum region and any program that
;corrupts this table but does not corrupt the checksum region will leave
;command.com parsing in an inconsistent state.
; NB: The special characters string has been hardcoded here. If any change
;is made to it in psdata.inc, a corresponding change needs to be made here.

	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
	mov	word [cs:$P_FileSp_Char+2], '|<'
	mov	word [cs:$P_FileSp_Char+4], '>+'
	mov 	word [cs:$P_FileSp_Char+6], '=;'

;M029 -- End of changes

	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse

;--------------------------- End of Line
	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
	mov	ax,0FFFFh
	push	bx			;AN000;
	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
	mov	bx,[es:di]		;AN000; Get the PARMSX address to
	
	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
	jae	short $P_Fin		;AN000; positional found.

	;mov	ax,2
	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
	; 27/04/2023
	clc
$P_Fin: 				;AN000;
	pop	bx			;AN000;
	;jmp	$P_Single_Exit		;AN000; return to the caller
	; 27/04/2023
	; cf = 0
	;clc
	retn

;---------------------------
$P_Start:				;AN000;
	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034;  save ptr to command line for later use by complex,
	push	bx			;AN000; quoted string or file spec.
	push	di			;AN000;
	push	bp			;AN000;
	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
	test	byte [cs:$P_Flags2],$P_Extra ; 20h
	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
$P_Pack_Loop:				;AN000;
	lodsb				;AN000; Pick a operand from buffer
	call	$P_Chk_Switch		;AN000; Check switch character
	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue

	call	$P_Chk_EOL		;AN000; Check EOL character
	je	short $P_Pack_End_BY_EOL ;AN000; need backup si

	call	$P_Chk_Delim		;AN000; Check delimiter
	jne	short $P_PL01 		;AN000; If no, process next byte

	test	byte [cs:$P_Flags2],$P_Extra ; 20h
	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
	jnz	short $P_Pack_End_backup_si
					;AN000; (tm08)
	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end

$P_Pack_End_backup_si:			;AN000; (tm08)
	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
	jz	short $P_Pack_End	;AN000; (tm08)

	dec	si			;AN000; (tm08)
	jmp	short $P_Pack_End	;AN025; (tm08)
$P_PL01:				;AN000;
	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
	;cmp	al,'='
	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
	jne	short $P_PL00 		;AN000; then

	or	byte [cs:$P_Flags2],$P_equ
	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
$P_PL00:				;AN000;
	inc	bx			;AN000; ready to see next byte
	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte

	lodsb				;AN000; if yes, store
	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
	inc	bx			;AN000; update pointer
	jmp	short $P_Pack_Loop	;AN000; process to next byte

$P_Pack_End_BY_EOL:			;AN000;
	dec	si			;AN000; backup si pointer
$P_Pack_End:				;AN000;
	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
	;mov	byte [cs:bx],0
	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
	mov	[cs:$P_Save_EOB],bx
					;AC034; 3/17/87 keep the address for later use of complex
	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
	mov	bx,[es:di]		;AN000; get PARMSX address
	lea	si,$P_STRING_BUF	;AC034;
	;cmp	byte [cs:si],'/'
	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
	je	short $P_SW_Manager	;AN000; if yes, process as switch

	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
	je	short $P_Positional_Manager
					;M005;if so, process as one!
	test	byte [cs:$P_Flags2],$P_equ
	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword

$P_Positional_Manager:			;AN000; else process as positional
	;mov	al,[es:bx+1]		;AN000; get maxp
	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
	xor	ah,ah			;AN000; ax = maxp
	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many

	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
	shl	ax,1			;AN000; ax = ax*2
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; now bx points to 1st CONTROL
	add	bx,ax			;AN000; now bx points to specified CONTROL address
	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
	call	$P_Chk_Pos_Control	;AN000; Do process for positional
	jmp	short $P_Return_to_Caller
					;AN000; and return to the caller
$P_Too_Many_Error:			;AN000;
	;mov	word [cs:$P_RC],1
	mov	word [cs:$P_RC],$P_Too_Many
					;AC034; set exit code
	jmp	short $P_Return_to_Caller
					;AN000; and return to the caller
$P_SW_Manager:				;AN000;
	;mov	al,[es:bx+1]		;AN000; get maxp
	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
	xor	ah,ah			;AN000; ax = maxp
	inc	ax			;AN000;
	shl	ax,1			;AN000; ax = (ax+1)*2
	add	bx,ax			;AN000; now bx points to maxs
	mov	cl,[es:bx]		;AN000;
	xor	ch,ch			;AN000; cx = maxs
	or	cx,cx			;AN000; at least one switch ?
	jz	short $P_SW_Not_Found 	;AN000;
	inc	bx			;AN000; now bx points to 1st CONTROL address
$P_SW_Mgr_Loop: 			;AN000;
	push	bx			;AN000;
	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
	call	$P_Chk_SW_Control	;AN000; do process for switch
	pop	bx			;AN000;
	jnc	short $P_Return_to_Caller
					;AN000; if the CONTROL is for the switch, exit
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; else bx points to the next CONTROL
	loop	$P_SW_Mgr_Loop		;AN000; and loop
$P_SW_Not_Found:			;AN000;
	;mov	word [cs:$P_RC],3
	mov	word [cs:$P_RC],$P_Not_In_SW
					;AC034; here no CONTROL for the switch has
	jmp	short $P_Return_to_Caller0
					;AN000; not been found, means error.
$P_Key_Manager: 			;AN000;
	;mov	al,[es:bx+1]		;AN000; get maxp
	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
	xor	ah,ah			;AN000; ax = maxp
	inc	ax			;AN000;
	shl	ax,1			;AN000; ax = (ax+1)*2
	add	bx,ax			;AN000; now bx points to maxs
	mov	al,[es:bx]		;AN000;
	xor	ah,ah			;AN000; ax = maxs
	shl	ax,1			;AN000;
	inc	ax			;AN000; ax = ax*2+1
	add	bx,ax			;AN000; now bx points to maxk
	mov	cl,[es:bx]		;AN000;
	xor	ch,ch			;AN000; cx = maxk
	or	cx,cx			;AN000; at least one keyword ?
	jz	short $P_Key_Not_Found	;AN000;
	inc	bx			;AN000; now bx points to 1st CONTROL
$P_Key_Mgr_Loop:			;AN000;
	push	bx			;AN000;
	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
	call	$P_Chk_Key_Control	;AN000; do process for keyword
	pop	bx			;AN000;
	jnc	short $P_Return_to_Caller
					;AN000; if the CONTROL is for the keyword, exit
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; else bx points to the next CONTROL
	loop	$P_Key_Mgr_Loop 	;AN000; and loop
$P_Key_Not_Found:			;AN000;
	;mov	word [cs:$P_RC],4
	mov	word [cs:$P_RC],$P_Not_In_Key
					;AC034; here no CONTROL for the keyword has
$P_Return_to_Caller0:
$P_Return_to_Caller:			;AN000; not been found, means error.
	pop	bp			;AN000;
	pop	di			;AN000;
	pop	bx			;AN000;
	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
	mov	ax,[cs:$P_RC]		;AC034; return exit code
	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
$P_Single_Exit: 			;AN000;
	clc				;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Chk_Pos_Control
;
; Function: Parse CONTROL block for a positional
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    None
;
; Use:	 $P_Fill_Result, $P_Check_Match_Flags
;
; Vars: $P_Ordinal(W), $P_RC(W)
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h

$P_Chk_Pos_Control:
	push	ax			;AN000;
	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
	mov	ax,[es:bx]		;AN000;
	;test	ax,2
	test	ax,$P_Repeat		;AN000; repeat allowed ?
	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL

	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
$P_CPC00:				;AN000;
	;cmp	byte [cs:si],0
	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
	jne	short $P_CPC01		;AN000;

	;test	ax,1
	test	ax,$P_Optional		;AN000; yes, then is it optional ?
	jnz	short $P_CPC02		;AN000;

	mov	word [cs:$P_RC],$P_Op_Missing
					;AC034; no, then error	 3/17/87
	jmp	short $P_CPC_Exit	;AN000;
$P_CPC02:				;AN000;
	; 27/04/2023
	;push	ax ; *			;AN000;
	;
	;;mov	al,3
	;mov	al,$P_String		;AN000; if it is optional return NULL
	;;mov	ah,0FFh
	;mov	ah,$P_No_Tag		;AN000; no item tag indication
	;31/03/2023
	mov	ax,($P_No_Tag<<8)+$P_String
	call	$P_Fill_Result		;AN000;
	; 27/04/2023
	;pop	ax ; *			;AN000;
	jmp	short $P_CPC_Exit	;AN000;
$P_CPC01:				;AN000;
	call	$P_Check_Match_Flags	;AN000;
$P_CPC_Exit:				;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Chk_Key_Control
;
; Function: Parse CONTROL block for a keyword
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
;
; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$P_Chk_Key_Control:			;AN000;
	stc				;AN000;this logic works when the KeySW
	retn				;AN000;is reset.

;***********************************************************************
; $P_Search_KEYorSW:
;
; Function: Seach specified keyword or switch from CONTROL
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Search_KEYorSW:
	push	bp			;AN000;
	push	cx			;AN000;
	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
	;mov	cl,[es:bx+8]		;AN000; Get synonym count
	xor	ch,ch			;AN000; and set it to cx
	or	cx,cx			;AN000; No synonyms specified ?
	jz	short $P_KEYorSW_Not_Found
					;AN000; then indicate not found by CY
	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
$P_KEYorSW_Loop:			;AN000;
	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
$P_KEYorSW_Not_Found:			;AN000;
	stc				;AN000; indicate not found in synonym list
	jmp	short $P_KEYorSW_Exit	;AN000; and exit
$P_KEYorSW_Found:			;AN000;
	mov	[cs:$P_Found_SYNONYM],bp
					;AC034; set synonym pointer
	; 27/04/2023
	; cf = 0
	;clc				;AN000; indicate found
$P_KEYorSW_Exit:			;AN000;
	pop	cx			;AN000;
	pop	bp			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_MoveBP_NUL
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_MoveBP_NUL:
$P_MBP_Loop:				;AN000;
	;cmp	byte [es:bp+0],0
	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
	je	short $P_MBP_Exit	;AN000; to the synomym list
	inc	bp			;AN000; until
	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
$P_MBP_Exit:				;AN000;
	inc	bp			;AN000; bp points to next to NULL
	retn				;AN000;

;***********************************************************************
; $P_Chk_SW_Control
;
; Function: Parse CONTROL block for a switch
;
; Input:     ES:BX -> CONTROL block
;	     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    CY = 1 : not match
;
; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
;
; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Chk_SW_Control:
	or	byte [cs:$P_Flags2],$P_SW_Cmp
	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL

	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
	;and	byte [cs:$P_Flags2],0EFh
					;AC034; reset the indicator previously set
	push	ax			;AN000;       /switch:
	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
	sub	ax,si			;AN000;  SI	KEYorSW
	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
	pop	ax			;AN000;

	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
	;cmp	byte [cs:si],0
	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
	jne	short $P_CSW00		;AN000; if yes, process match flags

	;cmp	byte [cs:si],':'
	cmp	byte [cs:si-1],$P_Colon
					;AN000; if no, the switch terminated by colon ?
	jne	short $P_Chk_if_data_required
					;AN000; if yes,

	mov	word [cs:$P_RC],$P_Syntax
	;mov	word [cs:$P_RC],9	;AC034; return syntax error
	jmp	short $P_Chk_SW_Exit	;AN000;

$P_Chk_if_data_required:		;AN018; no data, no colon
	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
	; 27/04/2023
	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on

	;;test	word [es:bx],1 ; $P_Optional
	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
	test	byte [es:bx],$P_Optional
					;AN019; see if no value is valid
	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell

	mov	word [cs:$P_RC],$P_Op_Missing
	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
	jmp	short $P_Chk_SW_Exit	;AN018;

$P_CSW00:				;AN000;
	call	$P_Check_Match_Flags	;AN000; process match flag
	clc				;AN000; indicate match
	;jmp	short $P_Chk_SW_Single_Exit
	retn	; 31/03/2023		;AN000;
	; 31/03/2023
;$P_Chk_SW_Err0: 			;AN000;
;	stc				;AN000; not found in switch synonym list
;	;jmp	short $P_Chk_SW_Single_Exit
;	retn	; 31/03/2023		;AN000;
	
$P_Chk_SW_Exit: 			;AN000;
	push	ax			;AN000;
	; 31/03/2023
	mov	ax,($P_No_Tag<<8)+$P_String
	;;mov	al,3
	;;mov	ah,0FFh
	;mov	al,$P_String		;AN000; set
	;mov	ah,$P_No_Tag		;AN000;    result
	call	$P_Fill_Result		;AN000; 	 buffer
	pop	ax			;AN000;
	clc				;AN000;
	; 31/03/2023
$P_Chk_SW_Err0:
$P_Chk_SW_Single_Exit:			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Fill_Result
;
; Function: Fill the result buffer
;
; Input:    AH = Item tag
;	    AL = type
;		  AL = 1: CX,DX has 32bit number (CX = high)
;		  AL = 2: DX has index(offset) into value list
;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
;		  AL = 7: DX has year, CL has month and CH has date
;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
;			  amd CH has hundredths
;		  AL = else: psdata_seg:SI points to returned string buffer
;	    ES:BX -> CONTROL block
;
; Output:   None
;
; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
;
; Vars: $P_DX(W)
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Fill_Result:
	push	di			;AN000;
	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
	;mov	di,[es:bx+4]		;AN000; di points to result buffer
	mov	[cs:$P_DX],di		;AC034; set returned result address
	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
	;;mov	[es:di],al		;AN000; store type
	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
	;;mov	[es:di+1],ah		;AN000; store item tag
	; 31/03/2023
	mov	[es:di],ax
	push	ax			;AN000;
	mov	ax,[cs:$P_Found_SYNONYM]
					;AC034; if yes,
	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
	;mov	[es:di+2],ax		;AN000;   then set it to the result
	pop	ax			;AN000;
$P_RLT04:				;AN000;
	;cmp	al,1
	cmp	al,$P_Number		;AN000; if number
	jne	short $P_RLT00		;AN000;
$P_RLT02:				;AN000;
	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
	;mov	[es:di+4],dx		;AN000; then store 32bit
	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
	;mov	[es:di+6],cx		;AN000;	number
	jmp	short $P_RLT_Exit	;AN000;
$P_RLT00:				;AN000;
	;cmp	al,2
	cmp	al,$P_List_Idx		;AN000; if list index
	jne	short $P_RLT01		;AN000;
	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
	;mov	[es:di+4],dx		;AN000; then store list index
	jmp	short $P_RLT_Exit	;AN000;
$P_RLT01:				;AN000;
	;cmp	al,7
	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
	je	short $P_RLT02		;AN000;
	;cmp	al,8
	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
	je	short $P_RLT02		;AN000;
	;cmp	al,6
	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
	jne	short $P_RLT03		;AN000;

	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
	;mov	[es:di+4],dl		;AN000; store drive number
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT03:				;AN000;
	;cmp	al,4
	cmp	al,$P_Complex		;AN000; complex format ?
	jne	short $P_RLT05		;AN000;

	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
	inc	ax			;AN000; skip left Parentheses
	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
	;mov	[es:di+4],ax		;AN000; store offset
	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
	;mov	[es:di+6],ds		;AN000; store segment
	jmp	short $P_RLT_Exit	;AN000;

$P_RLT05:				;AN000;
;------------------------  AL = 3, 5, or 9
	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF

	push	ax			;AN000;
	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
	jz	short $P_RLT_CAP00	;AN000;

	;mov	al,4
	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
	jmp	short $P_RLT_CAP02	;AN000;

$P_RLT_CAP00:				;AN000;
	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
	jz	short $P_RLT_CAP01	;AN000;

	;mov	al,2
	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
$P_RLT_CAP02:				;AN000;
	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
$P_RLT_CAP01:				;AN000;
	pop	ax			;AN000;
	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
	jz	short $P_RLT_Exit	;AN000;

	call	$P_Remove_Colon 	;AN000; then process it.
$P_RLT_Exit:				;AN000;
	pop	di			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Check_Match_Flags
;
; Function:  Check the mutch_flags and make the exit code and set the
;	     result buffer
;
;	    Check for types in this order:
;		Complex
;		Date
;		Time
;		Drive
;		Filespec
;		Quoted String
;		Simple String
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
;	     $P_Drive_Format
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Check_Match_Flags:
	mov	byte [cs:$P_err_flag],$P_NULL ; 0
					;AN033;AC034;; clear filespec error flag.
	push	ax			;AN000;
	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
	or	ax,ax			;AC035; test ax for zero
	jnz	short $P_Mat		;AN000; (tm12)
	push	ax			;AN000; (tm12)
	push	bx			;AN000; (tm12)
	push	dx			;AN000; (tm12)
	push	di			;AN000; (tm12)
	mov	word [cs:$P_RC],$P_Syntax
	;mov	word [cs:$P_RC],9	;AC034; (tm12)
	; 31/03/2023
	mov	ax,($P_No_Tag<<8)+$P_String
	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
	;mov	al,$P_String ; 3	;AN000; (tm12)
	call	$P_Fill_Result		;AN000; (tm12)
	pop	di			;AN000; (tm12)
	pop	dx			;AN000; (tm12)
	pop	bx			;AN000; (tm12)
	pop	ax			;AN000; (tm12)
	;jmp	short $P_Bridge 	;AC035; (tm12)
	; 31/03/2023
$P_Bridge:	; 18/04/2023		;AN000;
	jmp	$P_Match_Exit		;AN000; (tm02)
$P_Mat: 				;AN000; (tm12)
$P_Match01:				;AN000;
	;test	ax,1000h
	test	ax,$P_Date_S		;AN000; Date string
	jz	short $P_Match02	;AN000;
	mov	word [cs:$P_RC],$P_No_Error
	;mov	word [cs:$P_RC],0	;AC034; assume no error
	call	$P_Date_Format		;AN000; do process
	cmp	word [cs:$P_RC],$P_Syntax
	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
	; 18/04/2023
	jne	short $P_Bridge		;AN000;
$P_Match02:				;AN000;
	;test	ax,800h
	test	ax,$P_Time_S		;AN000; Time string
	jz	short $P_Match03	;AN000;
	mov	word [cs:$P_RC],$P_No_Error
	;mov	word [cs:$P_RC],0	;AC034; assume no error
	call	$P_Time_Format		;AN000; do process
	cmp	word [cs:$P_RC],$P_Syntax
	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
	;jne	short $P_Bridge		;AN000; (tm09)
	;jmp	short $P_Match03	;AN025; (tm09)
	; 31/03/2023
	jne	short $P_Match_Exit
;$P_Bridge:				;AN000;
	;jmp	short $P_Match_Exit	;AN000; (tm02)
$P_Match03:				;AN000;
	;test	ax,8000h
	test	ax,$P_Num_Val		;AN000; Numeric value
	jz	short $P_Match04	;AN000;
	mov	word [cs:$P_RC],$P_No_Error
	;mov	word [cs:$P_RC],0	;AC034; assume no error
	call	$P_Value		;AN000; do process
	cmp	word [cs:$P_RC],$P_Syntax
	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
	jne	short $P_Match_Exit	;AN000;
$P_Match04:				;AN000;
	;test	ax,4000h
	test	ax,$P_SNum_Val		;AN000; Signed numeric value
	jz	short $P_Match05	;AN000;
	mov	word [cs:$P_RC],$P_No_Error
					;AC034; assume no error
	call	$P_SValue		;AN000; do process
	cmp	word [cs:$P_RC],$P_Syntax
					;AC034; if error, examine the next type
	jne	short $P_Match_Exit	;AN000;
$P_Match05:				;AN000;
	;test	ax,100h
	test	ax,$P_Drv_Only		;AN000; Drive only
	jz	short $P_Match06	;AN000;
	mov	word [cs:$P_RC],$P_No_Error
					;AC034; assume no error
	call	$P_File_Format		;AN000; 1st, call file format
	call	$P_Drive_Format 	;AN000; check drive format, next
	cmp	word [cs:$P_RC],$P_Syntax
					;AC034; if error, examinee the next type
	jne	short $P_Match_Exit	;AN000;
$P_Match06:				;AN000;
	;test	ax,200h
	test	ax,$P_File_Spc		;AN000; File spec
	jz	short $P_Match07	;AN000;
	mov	word [cs:$P_RC],$P_No_Error
					;AC034; assume no error
	call	$P_File_Format		;AN000; do process
	cmp	word [cs:$P_RC],$P_Syntax
					;AC034; if error, examine the next type
	jne	short $P_Match_Exit	;AN000;
$P_Match07:				;AN000;
$P_Match08:				;AN000;
	;test	ax,2000h
	test	ax,$P_Simple_S		;AN000; Simple string
	jz	short $P_Match09	;AN000;
	mov	word [cs:$P_RC],$P_No_Error
					;AC034; assume no error
	call	$P_Simple_String	;AN000; do process
$P_Match09:				;AN000;
$P_Match_Exit:				;AN000;
	cmp	word [cs:$P_err_flag],$P_error_filespec
	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
	jne	short $P_Match2_Exit	;AN033; no, continue
	cmp	word [cs:$P_RC],$P_No_Error
	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
	jne	short $P_Match2_Exit	;AN033; no, continue
	mov	word [cs:$P_RC],$P_Syntax
	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
$P_Match2_Exit: 			;AN033;
	pop	ax			;AN000;
	retn

;***********************************************************************
; $P_Remove_Colon;
;
; Function: Remove colon at end
;
; Input:    psdata_seg:SI points to string buffer to be examineed
;
; Output:   None
;
; Use:	$P_Chk_DBCS
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Remove_Colon:
	push	ax			;AN000;
	push	si			;AN000;
$P_RCOL_Loop:				;AN000;
	mov	al,[cs:si]		;AN000; get character
	or	al,al			;AN000; end of string ?
	jz	short $P_RCOL_Exit	;AN000; if yes, just exit

	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
	jne	short $P_RCOL00		;AN000;

	;cmp	byte [cs:si+1],0
	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
	jne	short $P_RCOL00		;AN000; no, then next char

	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
	; 31/03/2023
	;jmp	short $P_RCOL_Exit	;AN000; and exit.
$P_RCOL_Exit:
	pop	si
	pop	ax
	retn

$P_RCOL00:				;AN000;
	call	$P_Chk_DBCS		;AN000; if not colon, then check if
	jnc	short $P_RCOL01		;AN000; DBCS leading byte.

	inc	si			;AN000; if yes, skip trailing byte
$P_RCOL01:				;AN000;
	inc	si			;AN000; si points to next byte
	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered

	; 31/03/2023
;$P_RCOL_Exit:				;AN000;
	;pop	si			;AN000;
	;pop	ax			;AN000;
	;retn

;***********************************************************************
; $P_Do_CAPS_String;
;
; Function: Perform capitalization along with the file case map table
;	    or character case map table.
;
; Input:    AL = 2 : Use character table
;	    AL = 4 : Use file table
;	    psdata_seg:SI points to string buffer to be capitalized
;
; Output:   None
;
; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Do_CAPS_String:
	push	si			;AN000;
	push	dx			;AN000;
	mov	dl,al			;AN000; save info id
$P_DCS_Loop:				;AN000;
	mov	al,[cs:si]		;AN000; load character and
	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
	jc	short $P_DCS00		;AN000; if yes, do not need CAPS

	or	al,al			;AN000; end of string ?
	jz	short $P_DCS_Exit	;AN000; then exit.

	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
	mov	[cs:si],al		;AN000; stored upper case char to buffer
	jmp	short $P_DCS01		;AN000; process nexit
$P_DCS00:				;AN000;
	inc	si			;AN000; skip DBCS leading and trailing byte
$P_DCS01:				;AN000;
	inc	si			;AN000; si point to next byte
	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
$P_DCS_Exit:				;AN000;
	pop	dx			;AN000;
	pop	si			;AN000;
	retn

;***********************************************************************
; $P_Do_CAPS_Char;
;
; Function: Perform capitalization along with the file case map table
;	    or character case map table.
;
; Input:    DL = 2 : Use character table
;	    DL = 4 : Use file table
;	    AL = character to be capitalized
;
; Output:   None
;
; Use:	INT 21h /w AH=65h
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Do_CAPS_Char:
	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
	jae	short $P_DCC_Go		;AN000;

	cmp	al,"a"  ; 61h		;AN000; if no,
	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"

	cmp	al,"z"  ; 7Ah		;AN000;
	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS

	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
	;jmp	short $P_CAPS_Ret	;AN000;
	; 18/04/2023
	retn

$P_DCC_Go:				;AN000;
	push	bx			;AN000;
	push	es			;AN000;
	push	di			;AN000;
	; 18/04/2023
	lea	di,$P_File_CAP_Ptr	;AC034;
	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
	je	short $P_DCC00		;AN000;
	; 27/04/2023
	lea	di,[$P_Char_CAP_Ptr]	;AC034; or use char CAPS table ?
$P_DCC00:				;AN000;
	cmp	[cs:di],dl		;AN000; already got table address ?
	je	short $P_DCC01		;AN000; if no,

;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
; the GET COUNTYRY INFO call. This usage of ES is required by the function
; call, regardless of what base register is currently be defined as PSDATA_SEG.

	push	ax			;AN000; get CAPS table thru DOS call
	push	cx			;AN000;
	push	dx			;AN000;
	push	cs			;AC036; pass current base seg into
					;(Note: this used to push CS. BUG...
	pop	es			;AN000;   ES reg, required for
					;get extended country information
	; 31/03/2023
	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
	;mov	ah,65h
	mov	al,dl			;AN000; upper case table
	;mov	bx,-1 ; 0FFFFh
	;mov	cx,5
	;mov	dx,-1
	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
	mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
					;DI already set to point to buffer
	int	21h			;AN000; es:di point to buffer that
					;now has been filled in with info
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;

$P_DCC01:				;AN000;

;In this next section, ES will be used as the base of the XLAT table, provided
; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
; regardless of which base reg is currently the PSDATA_SEG reg.

	mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
	;mov	bx,[cs:di+1]		;AN000; get offset of table
	mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
	;mov	es,[cs:di+3]		;AN000; get segment of table
	inc	bx			;AC035; add '2' to
	inc	bx			;AC035;  BX reg
					;AN000; skip length field
	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
	;xlat	es:[bx] 		;AN000; perform case map
	; 31/03/2023
	es	xlat

	pop	di			;AN000;
	pop	es			;AN000;
	pop	bx			;AN000;
$P_CAPS_Ret:				;AN000;
	retn

;***********************************************************************
; $P_Value / $P_SValue
;
; Function:  Make 32bit value from psdata_seg:SI and see value list
;	     and make result buffer.
;	     $P_SValue is an entry point for the signed value
;	     and this will simply call $P_Value after the handling
;	     of the sign character, "+" or "-"
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Check_OVF
;
; Vars: $P_RC(W), $P_Flags(RW)
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$P_SValue:
	push	ax			;AN000;
	;or	byte [cs:$P_Flags2],80h
	or	byte [cs:$P_Flags2],$P_Signed
					;AC034; indicate a signed numeric
	;and	byte [cs:$P_Flags2],0FDh
	and	byte [cs:$P_Flags2],0FFh-$P_Neg
					;AC034; assume positive value
	mov	al,[cs:si]		;AN000; get sign
	cmp	al,'+' ; 2Bh
	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
	je	short $P_SVal00		;AN000;

	cmp	al,'-' ; 2Dh
	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
	jne	short $P_Sval01		;AN000; else

	or	byte [cs:$P_Flags2],$P_Neg ; 2
					;AC034; set this is negative value
$P_SVal00:				;AN000;
	inc	si			;AN000; skip sign char
$P_Sval01:				;AN000;
	call	$P_Value		;AN000; and process value
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h

$P_Value:
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	xor	cx,cx			;AN000; cx = higher 16 bits
	xor	dx,dx			;AN000; dx = lower 16 bits
	push	bx			;AN000; save control pointer
$P_Value_Loop:				;AN000;
	mov	al,[cs:si]		;AN000; get character
	or	al,al			;AN000; end of line ?
	jz	short $P_Value00	;AN000;

	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
	jc	short $P_Value_Err0	;AN000;

	xor	ah,ah			;AN000;
	mov	bp,ax			;AN000; save binary number
	shl	dx,1			;AN000; to have 2*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short $P_Value_Err0	;AN000; then error, exit

	mov	bx,dx			;AN000; save low(2*x)
	mov	ax,cx			;AN000; save high(2*x)
	shl	dx,1			;AN000; to have 4*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short $P_Value_Err0	;AN000; then error, exit

	shl	dx,1			;AN000; to have 8*x
	rcl	cx,1			;AN000; shift left w/ carry
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short $P_Value_Err0	;AN000; then error, exit

	add	dx,bx			;AN000; now have 10*x
	adc	cx,ax			;AN000; 32bit ADD
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short $P_Value_Err0	;AN000; then error, exit

	add	dx,bp			;AN000; Add the current one degree decimal
	adc	cx,0			;AN000; if carry, add 1 to high 16bit
	call	$P_Check_OVF		;AN000; Overflow occurred ?
	jc	short $P_Value_Err0	;AN000; then error, exit

	inc	si			;AN000; update pointer
	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered

$P_Value_Err0:				;AN000;
	pop	bx			;AN000;
	jmp	$P_Value_Err		;AN000; Bridge

$P_Value00:				;AN000;
	pop	bx			;AN000; restore control pointer
	test	byte [cs:$P_Flags2],$P_Neg ; 2 
					;AC034; here cx,dx = 32bit value
	jz	short $P_Value01	;AN000; was it negative ?

	not	cx			;AN000; +
	not	dx			;AN000; |- Make 2's complement
	add	dx,1			;AN000; |
	adc	cx,0			;AN000; +
$P_Value01:				;AN000; / nval =0
	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
	;mov	si,[es:bx+6]		;AN000; si points to value list
	mov	al,[es:si]		;AN000; get nval
	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
	jne	short $P_Value02	;AN000;

	;mov	al,$P_Number	; 1	;AN000; Set type
	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
	; 31/03/2023
	mov	ax,($P_No_Tag<<8)+$P_Number
	jmp	short $P_Value_Exit	;AN000;

$P_Value02:				;AN000; / nval = 1
	inc	si			;AN000;
	mov	al,[es:si]		;AN000; al = number of range
	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
	je	short $P_Value03	;AN000; (tm07)

	inc	si			;AN000; si points to 1st item_tag
$P_Val02_Loop:				;AN000;
	test	byte [cs:$P_Flags2],$P_Signed ; 80h
	;test	byte [cs:$P_Flags2],80h	;AC034;
	jnz	short $P_Val02_Sign	;AN000;

	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
	jb	short $P_Val02_Next	;AN000;
	ja	short $P_Val_In		;AN000;

	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
	jb	short $P_Val02_Next	;AN000;

$P_Val_In:				;AN000;
	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
	ja	short $P_Val02_Next	;AN000;
	jb	short $P_Val_Found	;AN000;

	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
	ja	short $P_Val02_Next	;AN000;

	jmp	short $P_Val_Found	;AN000;

$P_Val02_Sign:				;AN000;
	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
	jl	short $P_Val02_Next	;AN000;
	jg	short $P_SVal_In	;AN000;

	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
	jl	short $P_Val02_Next	;AN000;

$P_SVal_In:				;AN000;
	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
	jg	short $P_Val02_Next	;AN000;
	jl	short $P_Val_Found	;AN000;

	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
	jg	short $P_Val02_Next	;AN000;

	;jmp	short $P_Val_Found	;AN000;
	; 27/04/2023
$P_Val_Found:				;AN000;
	mov	al,$P_Number ; 1	;AN000;
	mov	ah,[es:si]		;AN000; found ITEM_TAG set
	jmp	short $P_Value_Exit	;AN000;

$P_Val02_Next:				;AN000;
	add	si,$P_Len_Range ; 9 	;AN000;
	dec	al			;AN000; loop nrng times in AL
	jnz	short $P_Val02_Loop	;AN000;
					; / Not found
	mov	word [cs:$P_RC],$P_Out_Of_Range
	;mov	word [cs:$P_RC],6	;AC034;
	
	;mov	al,$P_Number ; 1	;AN000;
	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
	; 31/03/2023
	mov	ax,($P_No_Tag<<8)+$P_Number
	jmp	short $P_Value_Exit	;AN000;

	; 27/04/2023
;$P_Val_Found:				;AN000;
	;mov	al,$P_Number ; 1	;AN000;
	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
	;jmp	short $P_Value_Exit	;AN000;

$P_Value03:				;AN000; / nval = 2
$P_Value04:				;AN000; / nval = 3 or else
$P_Value_Err:				;AN000;
	mov	word [cs:$P_RC],$P_Syntax ; 9
					;AC034;
	;mov	al,$P_String ; 3	;AN000; Set type
	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	; 31/03/2023
	mov	ax,($P_No_Tag<<8)+$P_String
$P_Value_Exit:				;AN000;
	call	$P_Fill_Result		;AN000;
	pop	si			;AN000;
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Check_OVF
;
; Function:  Check if overflow is occurred with consideration of
;	     signed or un-signed numeric value
;
; Input:     Flag register
;
; Output:    CY = 1  :	Overflow
;
; Vars:     $P_Flags(R)
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$P_Check_OVF:
	pushf				;AN000;
	test	byte [cs:$P_Flags2],$P_Neg ; 2
					;AC034; is it negative value ?
	jnz	short $P_COVF		;AN000; if no, check overflow
	popf				;AN000; by the CY bit
	retn				;AN000;
$P_COVF:				;AN000;
	popf				;AN000; else,
	jo	short $P_COVF00		;AN000; check overflow by the OF
	clc				;AN000; indicate it with CY bit
	retn				;AN000; CY=0 means no overflow
$P_0099Err:	; 31/03/2023
$P_COVF00:				;AN000;
	stc				;AN000; and CY=1 means overflow
$P_0099Err2:	; 31/03/2023
	retn				;AN000;

;***********************************************************************
; $P_0099;
;
; Function:  Make ASCII 0-9 to Binary 0-9
;
; Input:     AL = character code
;
; Output:    CY = 1 : AL is not number
;	     CY = 0 : AL contains binary value
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$P_0099:
	cmp	al,"0"                  ;AN000;
	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
	; 31/03/2023
	jb	short $P_0099Err2

	cmp	al,"9"                  ;AN000;
	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9

	sub	al,"0"                  ;AN000; make char -> bin
	; 31/03/2023
	;clc				;AN000; indicate no error
	retn				;AN000;
	 ;31/03/2023
;$P_0099Err:				;AN000;
;	stc				;AN000; indicate error
;	retn				;AN000;

;***********************************************************************
; $P_Simple_String
;
; Function:  See value list for the simple string
;	     and make result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_String_Comp
;
; Vars: $P_RC(W)
;***********************************************************************

	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Simple_String:
	push	ax			;AN000;
	push	bx			;AN000;
	push	dx			;AN000;
	push	di			;AN000;
	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
	;mov	di,[es:bx+6]		;AN000; di points to value list
	mov	al,[es:di]		;AN000; get nval
	or	al,al			;AN000; no value list ?
	jnz	short $P_Sim00		;AN000; then
	; 31/03/2023
	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Sim_Exit	;AN000; and set result buffer
$P_Sim00:				;AN000;
	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
	jne	short $P_Sim01		;AN000; if no, syntax error

	inc	di			;AN000;
	mov	al,[es:di]		;AN000; al = nrng
	mov	ah,$P_Len_Range ; 9	;AN000;
	mul	ah			;AN000;  Skip nrng field
	inc	ax			;AN000; ax = (nrng*9)+1
	add	di,ax			;AN000; di points to nnval
	mov	al,[es:di]		;AN000; get nnval
	mov	ah,$P_Len_Value ; 5	;AN000;
	mul	ah			;AN000; Skip nnval field
	inc	ax			;AN000; ax = (nnval*5)+1
	add	di,ax			;AN000; di points to nstrval
	mov	al,[es:di]		;AN000; get nstrval
	inc	di			;AC035; add '2' to
	inc	di			;AC035;  DI reg
					;AN000; di points to 1st string in list
$P_Sim_Loop:				;AN000;
	mov	bp,[es:di]		;AN000; get string pointer
	call	$P_String_Comp		;AN000; compare it with operand
	jnc	short $P_Sim_Found	;AN000; found on list ?

	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
	dec	al			;AN000; loop nstval times in AL
	jnz	short $P_Sim_Loop	;AN000;
					;AN000; / Not found
	mov	word [cs:$P_RC],$P_Not_In_Str
	;mov	[cs:$P_RC],8		;AC034;
	; 31/03/2023
	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
	jmp	short $P_Sim_Exit	;AN000;
$P_Sim_Found:				;AN000;
	mov	ah,[es:di-1]		;AN000; set item_tag
	mov	al,$P_List_Idx	; 2	;AN000;
	mov	dx,[es:di]		;AN000; get address of STRING
	jmp	short $P_Sim_Exit0	;AN000;
$P_Sim01:				;AN000;
	mov	word [cs:$P_RC],$P_Syntax
	;mov	word [cs:$P_RC],9	;AC034;
$P_Sim_Exit:
	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
;$P_Sim_Exit:				;AN000;
	;mov	al,$P_String ; 3	;AN000; Set type
	; 31/03/2023
	mov	ax,($P_No_Tag<<8)+$P_String
$P_Sim_Exit0:				;AN000;
	call	$P_Fill_Result		;AN000;
	pop	di			;AN000;
	pop	dx			;AN000;
	pop	bx			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_String_Comp:
;
; Function:  Compare two string
;
; Input:     psdata_seg:SI -> 1st string
;	     ES:BP -> 2nd string  (Must be upper case)
;	     ES:BX -> CONTROL block
;
; Output:    CY = 1 if not match
;
; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
;
; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
;***********************************************************************

	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_String_Comp:
	push	ax			;AN000;
	push	bp			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
$P_SCOM_Loop:				;AN000;
	mov	al,[cs:si]		;AN000; get command character
	call	$P_Chk_DBCS		;AN000; DBCS ?
	jc	short $P_SCOM00		;AN000; yes,DBCS

	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
	
	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
					;AC034; keyword search ?
	jz	short $P_SCOM04		;AN000;

	;cmp	al,'=' ; 3Dh
	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)

	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
	jne	short $P_SCOM_Differ	;AN021;

	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list

$P_SCOM04:				;AN000;
	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
					;AC034; switch search ?
	jz	short $P_SCOM03		;AN000;

	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
	jne	short $P_SCOM03		;AN000; continue compares

	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN

$P_SCOM05:				;AN000;   found a match
	inc	si			;AN000; si points to just after "=" or ":"
	jmp	short $P_SCOM_Same	;AN000; exit

$P_SCOM03:				;AN000;
	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option

	or	al,al			;AN000; end of line
	jz	short $P_SCOM_Same	;AN000; if so, exit

	inc	si			;AN000; update operand pointer
	inc	bp			;AN000;    and synonym pointer
	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case

$P_SCOM00:				;AN000; Here al is DBCS leading byte
	cmp	al,[es:bp]		;AN000; compare leading byte
	jne	short $P_SCOM_Differ	;AN000; if not match, say different

	inc	si			;AN000; else, load next byte
	mov	al,[cs:si]		;AN000; and
	inc	bp			;AN000;
	cmp	al,[es:bp]		;AN000; compare 2nd byte
	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too

	inc	si			;AN000; else update operand pointer
	inc	bp			;AN000; 	and synonym pointer
$P_SCOM01:				;AN000;
	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case

$P_SCOM_Differ0:			;AN000;
	test	byte [cs:$P_Flags2],$P_SW ; 40h 
	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
	jz	short $P_not_applicable	;AN000;(tm10)

	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
	;;test	word [es:bx+2],20h	;AN000;(tm10)
	; 03/04/2023
	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary	
	jz	short $P_not_applicable	;AN000;(tm10)

	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
	je	short $P_SCOM_Same	;AN025;(tm10)

$P_not_applicable:			;AN000;(tm10)
	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
	; 03/04/2023
	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
	jz	short $P_SCOM_Differ	;AN000; if no, say different.

	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
	jne	short $P_SCOM02		;AN000;    subseqently

	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
	;jne	short $P_SCOM_Differ	;AN000; if no, say different
	;jmp	short $P_SCOM_Same	;AN000; else, say same
	; 01/04/2023
	je	short $P_SCOM_Same
$P_SCOM_Differ:
	stc
	jmp	short $P_SCOM_Exit

$P_SCOM02:				;AN000;
	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
	jne	short $P_SCOM_Differ	;AN000;

	;cmp	byte [es:bp],':'
	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
	;je	short $p_SCOM_Same	;AN000; else, say same
	; 01/04/2023
	jne	short $P_SCOM_Differ
;$P_SCOM_Differ: 			;AN000;
	;stc				;AN000; indicate not found
	;jmp	short $P_SCOM_Exit	;AN000;

$P_SCOM_Same:				;AN000;
	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
	; 01/04/2023
	;clc
	; cf = 0			;AN000; indicate found
$P_SCOM_Exit:				;AN000;
	pop	si			;AN000;
	pop	dx			;AN000;
	pop	bp			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Date_Format
;
; Function:  Convert a date string to DOS date format for int 21h
;	     with format validation.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
;
; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
;***********************************************************************

	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Date_Format:
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	call	$P_Set_CDI		;AN000; set country dependent information before process
	; 03/04/2023
	;pop	si			;AN000;
	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
	xor	si,si
	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
	;mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
	pop	si
	call	$P_Get_DecNum		;AN000; get 1st number
	jc	short $P_DateF_Err0	;AN000;-----------------------+
	mov	[cs:$P_1st_Val],ax	;AC034;			      |
	or	bl,bl			;AN000; end of line ?	      |
	jz	short $P_DateF_YMD	;AN000; 		      |
	call	$P_Get_DecNum		;AN000; get 2nd number	      |
	jc	short $P_DateF_Error	;AN000; 		      |
	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
	or	bl,bl			;AN000; end of line ?	      |
	jz	short $P_DateF_YMD	;AN000; 		      |
	call	$P_Get_DecNum		;AN000; get 3rd number	      |
$P_DateF_Err0:				;AN000; Bridge	  <-----------+
	jc	short $P_DateF_Error	;AN000;
	mov	[cs:$P_3rd_Val],ax	;AC034;
	or	bl,bl			;AN000; end of line ?
	jnz	short $P_DateF_Error	;AN000;
$P_DateF_YMD:				;AN000;
	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
	cmp	bx,$P_Date_YMD ; 2	;AN000;
	je	short $P_DateF00	;AN000;
	mov	ax,[cs:$P_1st_Val]	;AC034;
	or	ah,ah			;AN000;
	jnz	short $P_DateF_Error	;AN000;
	mov	cl,al			;AN000; set month
	mov	ax,[cs:$P_2nd_Val]	;AC034;
	or	ah,ah			;AN000; if overflow, error.
	jnz	short $P_DateF_Error	;AN000;
	mov	ch,al			;AN000; set date
	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
	jne	short $P_DateF01	;AN000; if it is DMY
	xchg	ch,cl			;AN000;  then swap M <-> D
$P_DateF01:				;AN000;
	jmp	short $P_DateF02	;AN000;
$P_DateF00:				;AN000; / here format = YMD
	mov	dx,[cs:$P_1st_Val]	;AC034; set year
	mov	ax,[cs:$P_2nd_Val]	;AC034;
	or	ah,ah			;AN000; if overflow, error
	jnz	short $P_DateF_Error	;AN000;

	mov	cl,al			;AN000; set month
	mov	ax,[cs:$P_3rd_Val]	;AC034;
	or	ah,ah			;AN000; if overflow, error
	jnz	short $P_DateF_Error	;AN000;
	mov	ch,al			;AN000; set date
$P_DateF02:				;AN000;
	cmp	dx,100			;AN000; year is less that 100 ?
	jae	short $P_DateF03	;AN000;
	add	dx,1900 		;AN000; set year 19xx
$P_DateF03:				;AN000;
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
	;mov	al,$P_Date_F ; 7	;AN000;   result
	; 03/04/2023
	mov	ax,($P_No_Tag<<8)+$P_Date_F
	call	$P_Fill_Result		;AN000;        buffer
	jmp	short $P_Date_Format_Exit
					;AN000;	to Date
$P_DateF_Error: 			;AN000;
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
	;mov	al,$P_String ; 3	;AN000;   result
	; 03/04/2023
	mov	ax,($P_No_Tag<<8)+$P_String
	call	$P_Fill_Result		;AN000; 	buffer
					;AN000; to string
	mov	word [cs:$P_RC],$P_Syntax ; 9
					;AC034; indicate syntax error
$P_Date_Format_Exit:			;AN000;
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Set_CDI:
;
; Function: Read CDI from DOS if it has not been read yet
;
; Input:    None
;
; Output:   psdata_seg:SI -> CDI
;
; Use:	INT 21h w/ AH = 38h
;***********************************************************************

	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$P_Set_CDI:
	; 18/04/2023
	lea	si,$P_Country_Info	;AC034;
	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
					;AN000; already read ?
	;je	short $P_Read_CDI	;AN000;
	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
	; 03/04/2023
	jne	short $P_Set_CDI_Exit
$P_Read_CDI:				;AN000; else read CDI thru DOS
	push	ds			;AN000;
	push	dx			;AN000;
	push	ax			;AN000;
	push	cs			;AC023;
	pop	ds			;AN000; set segment register
	;mov	ax,3800h
	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
	mov	dx,si			;AN000; set offset of CDI in local data area
	int	21h			;AN000;
	pop	ax			;AN000;
	pop	dx			;AN000;
	pop	ds			;AN000;
$P_Set_CDI_Exit:			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Get_DecNum:
;
; Function:  Read a chcrater code from psdata_seg:SI until specified delimiter
;	     or NULL encountered. And make a decimal number.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    BL = delimiter code or NULL
;	     AX = Decimal number
;	     SI advanced to the next number
;	     CY = 1 : Syntax error, AL = Latest examineed number
;
; Use:	$P_0099
;***********************************************************************

	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$P_Get_DecNum:
	push	cx			;AN000;
	push	dx			;AN000;
	xor	cx,cx			;AN000; cx will have final value
$P_GetNum_Loop: 			;AN000;
	mov	al,[cs:si]		;AN000; load character
	or	al,al			;AN000; end of line ?
	jz	short $P_GetNum00	;AN000; if yes, exit
	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023

; Determine which delimiter(s) to check for. Colon & period  or period only
	;cmp	bl,$P_colon_period
	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period

	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
	je	short $P_GetNum01	;AN032; ;yes, exit

	; 03/04/2023
	jmp	short $P_Do_Time_Delim1
;$P_Do_Time_Delim1:			;AN000;
	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
	;je	short $P_GetNum01	;AC023; yes, exit
	;
	;jmp	short $P_Neither_Delims ;AN023;

$P_Do_Date_Delims:			;AN000;
;Regardless of the date delimiter character specified in the country
;dependent information, check for the presence of any one of these
;three field delimiters: "-", "/", or ".".
	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
	je	short $P_GetNum01	;AN020;if yes, exit

	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
	je	short $P_GetNum01	;AN020;if yes, exit

$P_Do_Time_Delim1:  ; 03/04/2023
	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
	je	short $P_GetNum01	;AN000; if yes, exit

$P_Neither_Delims:			;AN023;
	call	$P_0099 		;AN000; convert it to binary
	jc	short $P_GetNum_Exit	;AN000; if error exit

	mov	ah,0			;AN000;
	xchg	ax,cx			;AN000;
	mov	dx,10			;AN000;
	mul	dx			;AN000; ax = ax * 10
	or	dx,dx			;AN000; overflow
	jnz	short $P_GetNum02	;AN000; then exit

	add	ax,cx			;AN000;
	jc	short $P_GetNum_Exit	;AN000;

	xchg	ax,cx			;AN000;
	inc	si			;AN000;
	jmp	short $P_GetNum_Loop	;AN000;

$P_GetNum00:				;AN000;
	mov	bl,al			;AN000; set bl to NULL
	;03/04/2023
	; cf=0
	;clc				;AN000; indicate no error
	jmp	short $P_GetNum_Exit	;AN000;

$P_GetNum01:				;AN000;
	inc	si			;AN000; si points to next number
	;03/04/2023
	; cf=0
	;clc				;AN000; indicate no error
	jmp	short $P_GetNum_Exit	;AN000;

$P_GetNum02:				;AN000;
	stc				;AN000; indicate error
$P_GetNum_Exit: 			;AN000;
	mov	ax,cx			;AN000;return value
	pop	dx			;AN000;
	pop	cx			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Time_Format
;
; Function:  Convert a time string to DOS time format for int 21h
;	     with format validation.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
;
; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
;	$P_3rd_Val(RW), $P_4th_Val(RW)
;***********************************************************************

	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Time_Format:				;AN000;
	push	ax			;AN000;
	push	cx			;AN000;
	push	dx			;AN000;
	push	si			;AN000;
	push	bx			;AN000;
	push	si			;AN000;
	call	$P_Set_CDI		;AN000; Set country independent
					; information before process
	;test	byte [cs:si+11h], 1
	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
					;AN000; 24 hour system
	pop	si			;AN000;
	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
$P_TimeF00:				;AN000;
	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
	; 03/04/2023
	xor	bx,bx
	mov	[cs:$P_1st_Val],bx ; 0
	mov	[cs:$P_2nd_Val],bx ; 0
	mov	[cs:$P_3rd_Val],bx ; 0
	mov	[cs:$P_4th_Val],bx ; 0
	;inc	bl
	;mov	[cs:$P_Got_Time],bl ; 1

	;mov	bl,$P_colon_period
	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
					; delimiters between hours,
					;  minutes,seconds
	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
	inc	bl ; bl = 1
	mov	[cs:$P_Got_Time],bl ; 1
	;
	call	$P_Get_DecNum		;AN000; get 1st number
	jc	short $P_TimeF_Err0	;AN000;
	mov	[cs:$P_1st_Val],ax	;AC034;
	or	bl,bl			;AN000; end of line ?
	jz	short $P_TimeF_Rlt	;AN000;
	call	$P_Get_DecNum		;AN000; get 2nd number
	jc	short $P_TimeF_Err0	;AC038; if OK
	mov	[cs:$P_2nd_Val],ax	;AC034;
	or	bl,bl			;AN000; end of line ?
	jz	short $P_TimeF_Rlt	;AN000;
	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
	call	$P_Get_DecNum		;AN000; get 3rd number
	jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
	mov	[cs:$P_3rd_Val],ax	;AC034;
	or	bl,bl			;AN000; end of line ?
	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
					;AN039;   GO TO 4TH NUMBER
	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
					;AN039;    BEEN REPEATED?
	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
					;AN039;   the end of line
					;AN039; no, time has not been repeated
	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
					;AN039;   in command line
	cmp	byte [si-1],$P_Comma ; ','
					;AN039; look at delimiter
					;AN039;   from command line
	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
					;AN039;  really end of line
					;AN039; is comma before hundredths,
					;AN039;   redo TIME
	mov	byte [si-1],$P_Period ; '.' 
					;AN039; change that ambiguous
					;AN039;    comma to a decimal point
					;AN039;     parse can understand
	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
	;or	byte [cs:$P_Flags1],$P_Time_Again
	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
					;AN039; is being repeated
	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
					;AN039;   OF STACK FROM SP
	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
					;AN039;   PARSE POINTER FROM SI
	jmp	$P_Redo_Time		;AN039; go try TIME again
$P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
	call	$P_Get_DecNum		;AN000; get 4th number
$P_TimeF_Err0:				;AN000; Bridge
	jc	short $P_TimeF_Error	;AN000;
	;
	mov	[cs:$P_4th_Val],ax	;AC034;
	or	bl,bl			;AN000; After hundredth, no data allowed
	jnz	short $P_TimeF_Error	;AN000; if some, then error
$P_TimeF_Rlt:				;AN000;
	mov	ax,[cs:$P_1st_Val]	;AC034;
	or	ah,ah			;AN000; if overflow then error
	jnz	short $P_TimeF_Err	;AN000;
	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
					;since "AM" was specified,
	cmp	al,12			;AN038: if hour specified as later than noon
	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
	jne	short $P_Time_notAM	;AN038; for noon exactly,
	xor	al,al			;AN038; set hour = zero
$P_Time_notAM:				;AN038;
	;test	byte [cs:$P_Flags2],$P_Time12
	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
	jz	short $P_TimeSkip00	;AN000; then
	cmp	al,12			;AN038; if 12:00 o'clock already
	je	short $P_TimeSkip00	;AN038; it is PM already
	add	al,12			;AN000; add 12 hours to make it afternoon
	jc	short $P_TimeF_Err	;AN000; if overflow then error
	cmp	al,24			;AN038; after adding 12, now cannot be >24
	ja	short $P_TimeF_Err	;AN038; if too big, error
$P_TimeSkip00:				;AN000;
	mov	dl,al			;AN000; set hour
	mov	ax,[cs:$P_2nd_Val]	;AC034;
	or	ah,ah			;AN000; if overflow then error
	jnz	short $P_TimeF_Err	;AN000;
	mov	dh,al			;AN000; set minute
	mov	ax,[cs:$P_3rd_Val]	;AC034;
	or	ah,ah			;AN000; if overflow then error
	jnz	short $P_TimeF_Err	;AN000;
	mov	cl,al			;AN000; set second
	mov	ax,[cs:$P_4th_Val]	;AC034;
	or	ah,ah			;AN000; if overflow then error
	jnz	short $P_TimeF_Err	;AN000;
	mov	ch,al			;AN000; set hundredth
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
	;mov	al,$P_Time_F ; 8 	;AN000;   result
	; 03/04/2023
	mov	ax,($P_No_Tag<<8)+$P_Time_F
	call	$P_Fill_Result		;AN000;        buffer
	jmp	short $P_Time_Format_Exit
					;AN000; to time
$P_TimeF_Error: 			;AN000;
$P_TimeF_Err:				;AN000;
	pop	bx			;AN000; recover CONTROL block
	pop	si			;AN000; recover string pointer
	;mov	ah,$P_No_Tag		;AN000; set
	;mov	al,$P_String		;AN000;     result
	; 03/04/2023
	mov	ax,($P_No_Tag<<8)+$P_String
	call	$P_Fill_Result		;AN000; 	  buffer
					;AN000; to string
	mov	word [cs:$P_RC],$P_Syntax ; 9	
					;AC034; return syntax error
$P_Time_Format_Exit:			;AN000;
	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ax			;AN000;
	retn

;***********************************************************************
; $P_Time_2412:
;
; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;
; Output:    Set $P_Time12 flag when the string is terminated by "p"
;	     or "pm"
;
; Vars:  $P_Flags(W)
;***********************************************************************

	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Time_2412:				;AN000;
	push	ax			;AN000;
	push	si			;AN000;
$P_T12_Loop:				;AN000;
	mov	al,[cs:si]		;AN000; Move
	inc	si			;AN000;     si
	or	al,al			;AN000;       to
	jnz	short $P_T12_Loop	;AN000; 	end of string

	mov	al,[cs:si-2]		;AN000; get char just before NULL
	;or	al,20h
	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
	je	short $P_T1200		;AN000;

	cmp	al,"a"                  ;AN000; only "a" of "am" ?
	je	short $P_T1201		;AN000;

	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
	jne	short $P_T12_Exit	;AN000;

	dec	si			;AN000;
	mov	al,[cs:si-2]		;AN000;
	;or	al,20h
	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
	cmp	al,"p"                  ;AN000; "p" of "pm" ?
	je	short $P_T1200		;AN000;

	cmp	al,"a"                  ;AN000; "a" of "am" ?
	;je	short $P_T1201		;AN000; go process "a"
	;jmp	short $P_T12_Exit	;AN000; no special chars found
	; 05/04/2023
	jne	short $P_T12_Exit

;$P_T1200:				;AN000; "P" found
	;;or	byte [cs:$P_Flags2],$P_Time12
	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
	;jmp	short $P_Tclr_chr	;AN038; go clear the special char

$P_T1201:				;AN000; "A" found
	;or	byte [cs:$P_Flags1],$P_Time12AM
	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
$P_Tclr_chr:				;AN038;
	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
$P_T12_Exit:				;AN000;
	pop	si			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

	; 05/04/2023
$P_T1200:				;AN000; "P" found
	;or	byte [cs:$P_Flags2],$P_Time12
	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
	jmp	short $P_Tclr_chr	;AN038; go clear the special char

;***********************************************************************
; $P_File_Format;
;
; Function:  Check if the input string is valid file spec format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
;
; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
;	$P_SaveSI_Cmpx(R)
;***********************************************************************

	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
$P_File_Format:
	push	ax			;AN000;
	push	di			;AN000;
	push	si			;AN000;
	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
	mov	al,[cs:si]		;AN000; load character
	or	al,al			;AN000; end of line ?
	je	short $P_FileF_Err	;AN000; if yes, error exit
	call	$P_FileSp_Chk		;AN000; else, check if file special character
	jne	short $P_FileF03	;AN000; if yes,
	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
					;AN033;AC034;; set error flag- bad char.
	pop	si			;AN033;
	mov	byte [cs:si],$P_NULL	;AN033;
	pop	di			;AN033;
	jmp	short $P_FileF02	;AN033;
$P_FileF_Err:				;AN000;
	pop	si			;AN000;
	mov	byte [cs:si],$P_NULL	;AN000;
	pop	di			;AN000;
	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
	;test	word [es:bx],1		;AN000; is it optional ?
	test	byte [es:bx],$P_Optional ; 1
	jnz	short $P_FileF02	;AN000;
	mov	word [cs:$P_RC],$P_Op_Missing
	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
	jmp	short $P_FileF02	;AN000;
$P_FileF03:				;AN000;
	pop	ax			;AN000; discard save si
	push	si			;AN000; save new si
$P_FileF_Loop1: 			;AN000;
	mov	al,[cs:si]		;AN000; load character (not special char)
	or	al,al			;AN000; end of line ?
	jz	short $P_FileF_RLT	;AN000;
	call	$P_FileSp_Chk		;AN000; File special character ?
	jz	short $P_FileF00	;AN000;
	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
	jnc	short $P_FileF01	;AN000;
	inc	di			;AN000; if yes, skip next byte
	inc	si			;AN000;
$P_FileF01:				;AN000;
	inc	di			;AN000;
	inc	si			;AN000;
	jmp	short $P_FileF_Loop1	;AN000;
$P_FileF00:				;AN000;
	mov	[cs:$P_Terminator],al	;AC034;
	mov	byte [cs:si],$P_NULL	;AN000; update end of string
	inc	di			;AN000;
	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
$P_FileF_RLT:				;AN000;
	pop	si			;AN000;
	pop	di			;AN000;
$P_FileF02:				;AN000;
	pop	ax			;AN000; (tm14)
	;;test	ax,200h
	;test	ax,$P_File_Spc		;AN000; (tm14)
	; 05/04/2023
	test	ah,($P_File_Spc>>8)
	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
	push	ax			;AN000; (tm14)
	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
	;mov	al,$P_File_Spec ; 5 	;AN000;    result
	; 05/04/2023
	mov	ax,($P_No_Tag<<8)+$P_File_Spec
	call	$P_Fill_Result		;AN000; 	buffer to file spec
	pop	ax			;AN000;
$P_Drv_Only_Exit:			;AN000; (tm14)
	retn				;AN000;

;***********************************************************************
; $P_FileSp_Chk
;
; Function:  Check if the input byte is one of file special characters
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     AL = character code to be examineed
;
; Output:    ZF = 1 , AL is one of special characters
;***********************************************************************

	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$P_FileSp_Chk:
	push	bx			;AN000;
	push	cx			;AN000;
	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
	lea	bx,$P_FileSp_Char
	mov	cx,$P_FileSp_Len ; 9
	;mov	cx,9			;AN000; load length of it
$P_FileSp_Loop: 			;AN000;
	cmp	al,[cs:bx]		;AN000; is it one of special character ?
	je	short $P_FileSp_Exit	;AN000;
	inc	bx			;AN000;
	loop	$P_FileSp_Loop		;AN000;
	inc	cx			;AN000; reset ZF
$P_FileSp_Exit: 			;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Drive_Format;
;
; Function:  Check if the input string is valid drive only format.
;	     And set the result buffer.
;
; Input:     psdata_seg:SI -> $P_STRING_BUF
;	     ES:BX -> CONTROL block
;
; Output:    None
;
; Use:	$P_Fill_Result, $P_Chk_DBCS
;
; Vars: $P_RC(W)
;***********************************************************************

	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$P_Drive_Format:
	push	ax			;AN000;
	push	dx			;AN000;
	mov	al,[cs:si]		;AN000;
	or	al,al			;AN000; if null string
	jz	short $P_Drv_Exit	;AN000; do nothing
	call	$P_Chk_DBCS		;AN000; is it leading byte ?
	jc	short $P_Drv_Err	;AN000;
	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
	je	short $P_DrvF00		;AN000;
	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
	;test	word [es:bx],10h	;AN000; colon can be ignored?
	test	byte [es:bx],$P_Ig_Colon ; 10h
	jz	short $P_Drv_Err	;AN000;
	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
	jne	short $P_Drv_Err	;AN000;
$P_DrvF00:				;AN000;
	or	al,$P_Make_Lower ; 20h	;AN000; lower case
	cmp	al,"a" ; 61h            ;AN000; drive letter must
	jb	short $P_Drv_Err	;AN000; in range of
	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
	ja	short $P_Drv_Err	;AN000; if no, error
	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
	mov	dl,al			;AN000; set
	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
	; 05/04/2023
	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
	call	$P_Fill_Result		;AN000; 	       to drive
	jmp	short $P_Drv_Exit	;AN000;
$P_Drv_Err:				;AN000;
	mov	word [cs:$P_RC],$P_Syntax
	;mov	word [cs:$P_RC],9	;AC034;
$P_Drv_Exit:				;AN000;
	pop	dx			;AN000;
	pop	ax			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Skip_Delim;
;
; Function: Skip delimiters specified in the PARMS list, white space
;	    and comma.
;
; Input:    DS:SI -> Command String
;	    ES:DI -> Parameter List
;
; Output:   CY = 1 if the end of line encounterd
;	    CY = 0 then SI move to 1st non-delimiter character
;	    AL = Last examineed character
;
; Use:	    $P_Chk_EOL, $P_Chk_Delim,
;
; Vars:     $P_Flags(R)
;***********************************************************************

	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Skip_Delim:				;AN000;
$P_Skip_Delim_Loop:			;AN000;
	lodsb				;AN000;
	call	$P_Chk_EOL		;AN000; is it EOL character ?
	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on

	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off

	test	byte [cs:$P_Flags2],$P_Extra
	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
	jz	short $P_Skip_Delim_Loop
					;AN000; if no, loop
	test	byte [cs:$P_Flags2],$P_SW+$P_equ
	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
	;dec	si ; *			;AN000; backup si for next call (tm08)
	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
	; 05/04/2023
	jnz	short $P_Skip_Delim_Exit ; cf = 0
$P_Exit_At_Extra:			;AN000;
	; cf = 0
	;clc				;AN000; indicate extra delim
	retn				;AN000;

$P_Skip_Delim_CY:			;AN000;
	stc				;AN000; indicate EOL
	jmp	short $P_Skip_Delim_Exit
					;AN000;
$P_Skip_Delim_NCY:			;AN000;
	clc				;AN000; indicate non delim
$P_Skip_Delim_Exit:			;AN000; in this case, need
	dec	si ; *			;AN000;  backup index pointer
	retn				;AN000;
	; 05/04/2023
;$P_Exit_At_Extra:			;AN000;
	;clc				;AN000; indicate extra delim
	;retn				;AN000;

;***********************************************************************
; $P_Chk_EOL;
;
; Function: Check if AL is one of End of Line characters.
;
; Input:    AL = character code
;	    ES:DI -> Parameter List
;
; Output:   ZF = 1 if one of End of Line characters
;***********************************************************************

	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Chk_EOL:
	push	bx			;AN000;
	push	cx			;AN000;
	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
	je	short $P_Chk_EOL_Exit 	;AN000;
	cmp	al,$P_NULL ; 0		;AN000; zero ?
	je	short $P_Chk_EOL_Exit 	;AN000;
	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
	jb	short $P_Chk_EOL_Exit 	;AN000;
	xor	bx,bx			;AN000;
	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
	cmp	byte [es:bx+di],$P_I_Use_Default
	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
	je	short $P_Chk_EOL_NZ	;AN000;
	xor	cx,cx			;AN000; Get number of extra chcracter
	mov	cl,[es:bx+di]		;AN000;
$P_Chk_EOL_Loop:			;AN000;
	inc	bx			;AN000;
	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
	je	short $P_Chk_EOL_Exit 	;AN000;
	loop	$P_Chk_EOL_Loop 	;AN000;
$P_Chk_EOL_NZ:				;AN000;
	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
$P_Chk_EOL_Exit:			;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	retn				;AN000;

;***********************************************************************
; $P_Chk_Delim;
;
; Function: Check if AL is one of delimiter characters.
;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
;	    blanks.
;
; Input:    AL = character code
;	    DS:SI -> Next Character
;	    ES:DI -> Parameter List
;
; Output:   ZF = 1 if one of delimiter characters
;	    SI points to the next character
; Vars:  $P_Terminator(W), $P_Flags(W)
;***********************************************************************

	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Chk_Delim:
	push	bx			;AN000;
	push	cx			;AN000;
	mov	byte [cs:$P_Terminator],$P_Space ; 20h
					;AC034; Assume terminated by space
	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
					;AC034;
	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
	je	short $P_Chk_Delim_Exit	;AN000;

	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
	je	short $P_Chk_Delim_Exit	;AN000;

	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
	je	short $P_Chk_Delim_Exit0
					;AN000;
$P_Chk_Delim00: 			;AN000;
	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
	jne	short $P_Chk_Delim01	;AN000;
	cmp	byte [si],20h ; $P_DBSP2
					;AN000; 2nd byte of DBCS Space ?
	jne	short $P_Chk_Delim01	;AN000;
	mov	al,$P_Space ; 20h	;AN000;
	inc	si			;AN000; make si point to next character
	cmp	al,al			;AN000; Set ZF
	jmp	short $P_Chk_Delim_Exit ;AN000;

$P_Chk_Delim01: 			;AN000;
	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
	jb	short $P_Chk_Delim_Exit	;AN000;

	xor	cx,cx			;AN000;
	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
	or	cx,cx			;AN000; No extra Delim character ?
	jz	short $P_Chk_Delim_NZ	;AN000;

	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
$P_Chk_Delim_Loop:			;AN000;
	inc	bx			;AN000;
	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
	je	short $P_Chk_Delim_Exit0
					;AN000;
	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter

$P_Chk_Delim_NZ:			;AN000;
	cmp	al,$P_Space ; 20h	;AN000; reset ZF
$P_Chk_Delim_Exit:			;AN000;
	pop	cx			;AN000;
	pop	bx			;AN000;
	retn				;AN000;

$P_Chk_Delim_Exit0:			;AN000;
	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
	test	byte [cs:$P_Flags2],$P_equ
	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit

	or	byte [cs:$P_Flags2],$P_Extra ; 20h
	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
$P_No_Set_Extra:			;AN027;
	cmp	al,al			;AN000; set ZF
	jmp	short $P_Chk_Delim_Exit ;AN000;

;***********************************************************************
; $P_Chk_Switch;
;
; Function: Check if AL is the switch character not in first position of
;	    $P_STRING_BUF
;
; Input:    AL = character code
;	    BX = current pointer within $P_String_Buf
;	    SI =>next char on command line (following the one in AL)
;
; Output:   CF = 1 (set)if AL is switch character, and not in first
;		 position, and has no chance of being part of a date string,
;		 i.e. should be treated as a delimiter.
;
;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
;		 position, or is a slash but may be part of a date string, i.e.
;		 should not be treated as a delimiter.
;
; Vars:  $P_Terminator(W)
;
; Use:	 $P_0099
;***********************************************************************

	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Chk_Switch:
	; 18/04/2023
	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing

	cmp	bx,bp			;AN000;
	je	short $P_STRUC_L2	;AN000;

	cmp     al,$P_Switch ; '/'	;AN000;
	jne	short $P_STRUC_L5	;AN000;

	stc				;AN020;not in first position and is slash, now see if might be in date string
	push	ax			;AN020;save input char
	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
	call	$P_0099 		;AN020;return carry set if not numeric
	jc	short $P_STRUC_L7	;AN000;

	mov	al,[si]			;AN020;AL=char after the current char
	call	$P_0099			;AN020;return carry set if not numeric
$P_STRUC_L7:				;AN000;
	pop	ax			;AN020;restore AL to input char
	;jmp	short $P_STRUC_L1	;AN000;
	; 18/04/2023
	retn

$P_STRUC_L5:				;AN000;
	clc				;AN020;not a slash
	;jmp	short $P_STRUC_L1	;AN000;
	 ;18/04/2023
	retn

$P_STRUC_L2:				;AN000;
	cmp     al,$P_Switch ; '/'	;AN000;
	;jne	short $P_STRUC_L12	;AN000;
	; 18/04/2023
	jne	short $P_STRUC_L5

	or	byte [cs:$P_Flags2],$P_SW
	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
	; 18/04/2023
;$P_STRUC_L12:				;AN000;
	;clc				;AN020;CF=0 indicating first char
$P_STRUC_L1:				;AN000;
	retn				;AN000;

;**************************************************************************
; $P_Chk_DBCS:
;
;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
;
;  Input:
;	  AL	= Code to be examineed
;
;  Output:
;	  If CF is on then a lead byte of DBCS
;
; Use: INT 21h w/AH=63
;
; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
;***************************************************************************

	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$P_Chk_DBCS:
	push	ds			;AN000;
	push	si			;AN000;
	push	bx			;AN000; (tm11)
	cmp	word [cs:$P_DBCSEV_SEG],0
					;AC034; ALREADY SET ?
	jne	short $P_DBCS00		;AN000;
	push	ax			;AN000;
	push	ds			;AN000; (tm11)
	push	cx			;AN000;
	push	dx			;AN000;
	push	di			;AN000;
	push	bp			;AN000;
	push	es			;AN000;
	xor	si,si			;AN000;
	mov	ds,si			;AN000;
	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
	mov	ax,6300h
	int	21h			;AN000;
	mov	bx,ds			;AN000; (tm11)
	or	bx,bx			;AN000; (tm11)
	pop	es			;AN000;
	pop	bp			;AN000;
	pop	di			;AN000;
	pop	dx			;AN000;
	pop	cx			;AN000;
	pop	ds			;AN000; (tm11)
	pop	ax			;AN000;
	jz	short $P_NON_DBCS	;AN000;
$P_DBCS02:				;AN000;
	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
$P_DBCS00:				;AN000;
	mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
	mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
$P_DBCS_LOOP:				;AN000;
	cmp	word [si],0 		;AN000; zero vector ?
	je	short $P_NON_DBCS	;AN000; then exit
	cmp	al,[si] 		;AN000;
	jb	short $P_DBCS01		;AN000; Check if AL is in
	cmp	al,[si+1]		;AN000;   range of
	ja	short $P_DBCS01		;AN000;      the vector
	stc				;AN000; if yes, indicate DBCS and exit
	jmp	short $P_DBCS_EXIT	;AN000;
$P_DBCS01:				;AN000;
	inc	si			;AC035; add '2' to
	inc	si			;AC035;  SI reg
					;AN000; get next vector
	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found

$P_NON_DBCS:				;AN000;
	; 18/04/2023
	; cf=0
	;clc				;AN000; indicate SBCS
$P_DBCS_EXIT:				;AN000;
	pop	bx			;AN000; (tm11)
	pop	si			;AN000;
	pop	ds			;AN000;
	retn				;AN000;

;============================================================================
; TPARSE.ASM, MSDOS 6.0, 1991
;============================================================================
; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; ****************************************************************
; *
; * ROUTINE:	 CMD_PARSE
; *
; * FUNCTION:	 Interface for transient COMMAND to invoke
; *		 SYSPARSE.
; *
; * INPUT:	 inputs to SYSPARSE
; *
; * OUTPUT:	 outputs from SYSPARSE
; *
; ****************************************************************

	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
;cmd_parse:
	;call	sysparse		;AN000;
	;retn				;AN000;
	; 06/04/2023
	;jmp	sysparse

append_parse:
	call	sysparse		;AN010;
	retf				;AN010;

; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
%if 0

;============================================================================
; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
;============================================================================
; 30/09/2018 - Retro DOS v3.0

; BREAK	<Message Printing Routine>

;
;	MSDOS V3.00 PRINT
;
;	Message Printing Routine
;

;PRINTF.ASM (MSDOS 3.3, LIBC)
;
;TITLE   PRINTF ROUTINE FOR MS-DOS
;
; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
;
; Characters are output to PFHandle according to the
; specifications contained in the Control String.
;
; The conversion characters are as follow:
;
;               %c - output the next argument as a character
;               %s - output the next argument as a string
;               %x - output the next argument as a hexidecimal number
;                    using abcedf
;               %X - output the next argument as a hexidecimal number
;                    using ABCDEF
;               %d - output the next argument as a decimal number
;
;
; Other format specifiers that may precede the conversion character are:
;
;               - (minus sign) - causes the field to be left-adjusted
;               + (plus sign)  - causes the field to be right-adjusted (default)
;               n - digit specifing the minimum field width (default to 1)
;               L - specifing a long integer
;
;   On entry to PRINTF the stack contains the return address and a pointer
;   to an argument list.
;
;   ____________________
;   |   Ret Addr       |      <= SP
;   --------------------
;   |  Ptr to Arg List |
;   --------------------
;
;   And the argument list contains the following:
;
;       String_ptr                  (a pointer to the control string)
;       Arg 1
;       Arg 2
;         .
;         .
;         .
;       Arg n-1
;       Arg n
;
;   If the argument is a %s or %c the arg contains a pointer to the string
;   or character.
;
;   The arguments are used in one-to-one correspondence to % specifiers.

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h

; =============== S U B	R O U T	I N E =======================================

PRINTF_INIT:
	call	STD_PRINTF
	retf

; =============== S U B	R O U T	I N E =======================================

PRINTF_CRLF:
	call	STD_PRINTF
	;call	CRLF2
	;retn
	; 07/04/2023
	jmp	CRLF2

; =============== S U B	R O U T	I N E =======================================

STD_EPRINTF:
	mov	word [cs:PRINTF_HANDLE],2
	jmp	short new_printf

; =============== S U B	R O U T	I N E =======================================

STD_PRINTF:
	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h

	mov	word [cs:PRINTF_HANDLE],1
NEW_PRINTF:				;Save the callers' registers
	cld
	push	dx
	push	bp
	mov	bp,sp
	push	cx
	push	bx
	push	ax
	push	di
	push	si
	push	es
	push	ds
	push	cs
	pop	es		;ES points to Printf segment
	mov	di,PRINTF_BUF	;DI points to the output buffer
	mov	bp,[bp+2]  ; dx ;BP points to the argument list
	;mov	si,[ds:bp+0]	;SI points to the control string
	mov	si,[ds:bp] ; bp
	add	bp,2
	xor	bx,bx
	call	CLEAR_FLAGS	; initialize the world

GET_CHAR:
	lodsb			;Get a character
	cmp	al,'%'		;Is it a conversion specifier?
	jz	short CONV_CHAR	;Yes - find out which one
	or	al,al		;Is it the end of the control string?
	jz	short PRINTF_DONE ;Yes - then we're done
PRINTF_PERCENT:				
	call	OUTCHR		;Otherwise store the character
	jmp	short GET_CHAR	;And go get another

PRINTF_DONE:
	call	FLUSH
	pop	ds
	pop	es
	pop	si
	pop	di
	pop	ax
	pop	bx
	pop	cx
	pop	bp
	pop	dx
	retn

CONV_CHAR:
	mov	byte [cs:PRINTF_LEFT],0

NXT_CONV_CHAR:	
	;Look for any format specifiers preceeding the conversion character
	lodsb
	cmp	al,'%'			;Just print the %
	jz	short PRINTF_PERCENT
	cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
	jz	short LEFT_ADJ
	cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
	jz	short CONV_CHAR
	cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
	jz	short LONG_INT
	cmp	al,[cs:char_l]	 ; "l"		
	jz	short LONG_INT
	cmp	al,'0'			;Is it a precision specification
	jb	short LOOK_CONV_CHAR
	cmp	al,'9'
	ja	short LOOK_CONV_CHAR
	cmp	al,'0'
	jnz	short NOT_PAD
	cmp	word [cs:PRINTF_WIDTH],0
	jnz	short NOT_PAD
	mov	ah,'0'
	mov	[cs:PAD_CHAR],ah
NOT_PAD:					;Adjust decimal place on precision
	push	ax
	mov	ax,[cs:PRINTF_WIDTH]
	mov	cx,10
	mul	cx
	pop	dx
	xor	dh,dh
	sub	dl,'0'
	add	ax,dx
	mov	[cs:PRINTF_WIDTH],ax	;And save the total
	jmp	short NXT_CONV_CHAR

LEFT_ADJ:
	mov	byte [cs:PRINTF_LEFT],1
	jmp	short NXT_CONV_CHAR

LONG_INT:
	or	byte [cs:PRINTF_LONG],1
	jmp	short NXT_CONV_CHAR

LOOK_CONV_CHAR:
	and	al,0DFh
	cmp	al,[cs:CHAR_X]	 ; "X"
	jz	short HEX_UP
	cmp	al,[cs:CHAR_D]	 ; "D"
	jz	short DECIMAL
	cmp	al,[cs:CHAR_C]	 ; "C"
	jz	short C_PUT_CHAR
	cmp	al,[cs:CHAR_S]	 ; "S"
	jz	short S_PUT_STRG
	call	CLEAR_FLAGS
	jmp	GET_CHAR

HEX_UP:
	mov	word [cs:PRINTF_BASE],16 ;Hex conversion
	jmp	short CONV_TO_NUM
DECIMAL:
	mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
	jmp	short CONV_TO_NUM

C_PUT_CHAR:
	call	NEXT_CHRS
	mov	al,dl
	call	OUTCHR
	call	CLEAR_FLAGS
	jmp	GET_CHAR

S_PUT_STRG:
	push	si			;Save pointer to control string
	call	NEXT_CHRS
	mov	si,dx
S_PUT_1:
	mov	cx,[cs:PRINTF_WIDTH]
	or	cx,cx
	jz	short S_PUT_2
	cmp	byte [cs:PRINTF_LEFT],0
	jnz	short S_PUT_2
	call	PAD_STRING
S_PUT_2:
	push	si
S_PUT_3:
	lodsb
	or	al,al
	jz	short S_PUT_4
	call	OUTCHR			;Put it into our buffer
	jmp	short S_PUT_3
S_PUT_4:
	pop	si
	cmp	byte [cs:PRINTF_LEFT],0
	jz	short C_S_END
	mov	cx,[cs:PRINTF_WIDTH]
	or	cx,cx
	jz	short C_S_END
	call	PAD_STRING
C_S_END:
	pop	si			;Restore control string pointer
	call	CLEAR_FLAGS
	jmp	GET_CHAR		;Go get another character	


; =============== S U B	R O U T	I N E =======================================

PAD_STRING:
	xor	dx,dx
	push	si

COUNT_LOOP:
	lodsb
	or	al,al
	jz	short COUNT_DONE
	inc	dx
	jmp	short COUNT_LOOP

COUNT_DONE:
	pop	si
	sub	cx,dx
	jbe	short COUNT_RET
	call	PAD

COUNT_RET:
	retn

; ---------------------------------------------------------------------------

CONV_TO_NUM:
	call	NEXT_CHRS
	mov	ax,dx
	xor	dx,dx
	cmp	byte [cs:PRINTF_LONG],0 
			;Is this is a short or long integer?
	jz	short NOT_LONG_INT
	call	NEXT_CHRS

NOT_LONG_INT:
	push	bx
	push	si
	mov	si,[cs:PRINTF_BASE]
	mov	cx,[cs:PRINTF_WIDTH]
	call	PNUM
	pop	si
	pop	bx
	call	PAD
	call	CLEAR_FLAGS
	jmp	GET_CHAR


; =============== S U B	R O U T	I N E =======================================

PNUM:
	dec	cx
	push	ax
	mov	ax,dx
	xor	dx,dx
	div	si
	mov	bx,ax
	pop	ax
	div	si
	xchg	bx,dx
	push	ax
	or	ax,dx
	pop	ax
	jz	short DO_PAD
	push	bx
	call	PNUM
	pop	bx
	jmp	short REM

DO_PAD:
	cmp	byte [cs:PRINTF_LEFT],0
	jnz	short REM
	call	PAD
REM:
	cmp	bl,10
	jb	short NOT_HEX
	add	bx,6
NOT_HEX:
	mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
	push	cx
	call	OUTCHR
	pop	cx
	retn

; =============== S U B	R O U T	I N E =======================================

PAD:
	or	cx,cx
	jle	short PAD_DONE
	mov	al,[cs:PAD_CHAR]
PAD_LOOP:
	push	cx
	call	OUTCHR
	pop	cx
	loop	PAD_LOOP
PAD_DONE:
	retn

; =============== S U B	R O U T	I N E =======================================

OUTCHR:
	stosb
	cmp	di,PRINTF_BUF_END ; SRCXNAME
	je	short FLUSH
OUTCHR_RETN:
	retn

; =============== S U B	R O U T	I N E =======================================

FLUSH:
	mov	cx,PRINTF_BUF
	xchg	cx,di
	sub	cx,di
	jz	short OUTCHR_RETN
WRITE_CHARS:
	push	bx
	mov	bx,[cs:PRINTF_HANDLE]
	push	ds
	push	cs
	pop	ds
	mov	dx,PRINTF_BUF
	mov	ah,Write ; 40h
	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
				; BX = file handle, CX = number	of bytes to write,
				; DS:DX -> buffer
	jnb	short FOOB2_1
	call	GET_EXT_ERR_NUMBER
	cmp	ax,6
	jz	short FOOB2_4
	jmp	short FOOB2_2

FOOB2_1:
	cmp	cx,ax
	jz	short FOOB2_4
FOOB2_2:
	mov	bx,dx
	add	bx,ax
	cmp	byte [bx],1Ah
	jz	short FOOB2_4
	pop	ds
	pop	bx
	mov	es,[cs:RESSEG]
	mov	dx,NOSPACEPTR
	test	byte [es:PIPEFLAG],0FFh
	jz	short PRINT_ERR_EXIT
	call	PIPEOFF
	mov	dx,PIPEEMESPTR
PRINT_ERR_EXIT:	
	jmp	CERROR

FOOB2_4:
	pop	ds
	pop	bx
	retn

; =============== S U B	R O U T	I N E =======================================

NEXT_CHRS:
	push	si		;Save pointer to control string
	mov	si,bx		;Get index into argument list
	add	bx,2		;Increment the index
	mov	si,[ds:bp+si]	; Get pointer to next argument
	mov	dx,[si]		; Get (address of the) next argument			
	pop	si
	retn

; =============== S U B	R O U T	I N E =======================================

CLEAR_FLAGS:
	xor	ax,ax
	mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
	mov	[cs:PRINTF_LONG],al	;Reset long flag
	mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
	mov	al,' '			
	mov	[cs:PAD_CHAR],al 	;Reset padding character
	retn

; ---------------------------------------------------------------------------
	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h

	; times 7 db 0

%endif

;============================================================================
; TPRINTF.ASM, MSDOS 6.0, 1991
;============================================================================
; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; ----------------------------
; MSDOS 6.0, MSGSERV.ASM, 1991
; ----------------------------

;; Replacable parameters are described by a sublist structure

struc $M_SUBLIST_STRUC		;;AN000;;
 .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 .$M_S_ID:	resb 1		;;AN000;; n of %n
 .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
endstruc

; ---------------------------------------------------------------------------
; ---------------------------------------------------------------------------

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh

Printf_Init:
	call	std_printf
	retf

Printf_Crlf:
	call	std_printf
	;call	CRLF2
	;retn
	; 07/04/2023
	jmp	CRLF2


;****************************************************************
;*
;* ROUTINE:	STD_PRINTF/STD_EPRINTF
;*
;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
;*		Set up substitutions if utility message.  Make
;*		sure any changes to message variables in TDATA
;*		are reset to avoid reloading the transient.
;*
;* INPUT:	Msg_Disp_Class	-  set to message class
;*		Msg_Cont_Flag	-  set to control flags
;*		DS	points to transient segment
;*
;*		if utility message:
;*		DX	points to a block with message number
;*			(word), number of substitutions (byte),
;*			followed by substitution list if there
;*			are substitutions.  If substitutions
;*			are not in transient segment they must
;*			be set.
;*		else
;*		AX	set to message number
;*
;* OUTPUT:	none
;*
;****************************************************************

std_eprintf:
	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
	jmp	short new_printf		;AC000;

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h

std_printf:
	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT

new_printf:
	push	ax				;AN000;save registers
	push	bx				;AN000;
	push	cx				;AN000;
	push	es				;AN000;get local ES
	push	ds				;AN000;
	pop	es				;AN000;
	push	di				;AN000;
	push	si				;AN000;
	push	dx				;AN000;

	; 07/04/2023
	;mov	word [print_err_flag],0		;AN000;
	xor	cx,cx
	mov	[print_err_flag],cx ; 0

	mov	si,dx				;AN000;Get offset of message number
	lodsw					;AN000;load message number
	push	ax				;AN000;save it
	lodsb					;AN000;get number of substitutions
	mov	cl,al				;AN000;set up CX as # of subst
	; 07/04/2023
	;xor	ch,ch				;AN000;SI now points to subst list
	pop	ax				;AN000;get message number back
	;cmp	cx,0				;AN000;Any substitutions?
	; 07/04/2023
	and	cx,cx
	jz	short ready_to_print		;AN000;No - continue

	mov	di,subst_buffer			;AN061; Get address of message subst buffer
	push	di				;AN061; save it
	push	cx				;AN061; save number of subst

move_subst:
	push	cx				;AN061;save number of subst
	mov	bx,si				;AN061;save start of sublist
	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
	; 07/04/2023
	mov	cl,parm_block_size ; 11
	rep	movsb				;AN061;move sublist
	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
	;test	byte [bx+7],4			;AN061;are we doing date/time?
	jz	short move_subst_cont 		;AN061;no - no need to reset
	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
	;mov	word [bx+2],0			;AN061;reset original date or time to 0
	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
	;mov	word [bx+4],0			;AN061;
	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0

move_subst_cont:				;AN061;
	pop	cx				;AN061;get number of subst back
	loop	move_subst			;AN061;move cx sublists

	pop	cx				;AN061;get number of subst
	push	ax				;AN061;save message number
	cmp	byte [msg_disp_class],util_msg_class
	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
	je	short check_fix			;AN061;YES - go see if substitutions
	;mov	byte [msg_flag],1 ; ext_msg_class
	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
	xor	ax,ax				;AN061;clear ax register
	stosw					;AN061;clear out message number
	stosb					;AN061;clear out subst count

check_fix:					;AN061;
	pop	ax				;AN061;get message number back
	pop	di				;AN061;get start of sublists
	mov	si,di				;AN061;get into SI for msgserv
	mov	bx,si				;AN061;get into BX for addressing
	push	cx				;AN061;save number of subst

set_subst:					;AN061;store the segment of the subst
	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
	;cmp	word [bx+4],0			;AN061;was it set already?
	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
	;test	byte [bx+7],4			;AN061;don't replace if date or time
	jnz	short subst_seg_set		;AN061;yes - skip it
	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
	;mov	word [bx+4],cs			;AN061;set segment value

subst_seg_set:					;AN061;
	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
	loop	set_subst			;AN061;loop CX times
	pop	cx				;AN061;get number of subst back

	mov	bx,si				;AN061;get start of sublist to BX
	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
	jne	short ready_to_print		;AN061;no - we already have address
	; 01/05/2023
	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
						;AN061;put it into the subst block
	;mov	[bx+2],dx

ready_to_print:
	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
	mov	dl,[msg_cont_flag]		;AN000;set up control flag
	mov	dh,[msg_disp_class]		;AN000;set up display class
	mov	byte [msg_cont_flag],0 ; no_cont_flag
						;AN061;reset flags to avoid
	mov	byte [msg_disp_class],util_msg_class
	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload

	push	ds				;AN026;
	push	es				;AN026;

	call	SYSDISPMSG			;AN000;call Rod

	pop	es				;AN026; restore registers
	pop	ds				;AN026;

	jnc	short print_success		;AN000; everything went okay
	mov	[print_err_flag],ax		;AN000;

print_success:
	pop	dx				;AN061;restore dx
	pop	si				;AN000;restore registers
	pop	di				;AN000;
	pop	es				;AN000;restore registers
	pop	cx				;AN000;
	pop	bx				;AN000;
	pop	ax				;AN000;
	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
	jnz	short print_err			;AN000;

	retn					;AC000;

print_err:
	push	cs
	pop	es
	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
	jne	short not_stderr		;AN026;no - continue
	jmp	TCOMMAND			;AN026;Yes - hopless - just exit

not_stderr:
	mov	ax,[print_err_flag]		;AN026;get extended error number back
	mov	es,[RESSEG]			; No, set up for error, load the
						;  right error msg, and jmp to cerror.
	test	byte [es:PipeFlag],-1 ; 0FFh
	jz	short _go_to_error
	call	PipeOff
	mov	dx,PIPEEMES_PTR
	jmp	short print_err_exit			;AC000;

_go_to_error:
	mov	byte [msg_disp_class],ext_msg_class
	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
	mov	[extend_buf_ptr],ax		;AN000; get message number in control block

print_err_exit: 				;AC000;
	push	cs
	pop	es
	jmp	cerror

;****************************************************************
;*
;* ROUTINE:	TSYSLOADMSG
;*
;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
;*		names since these routines are also used in the
;*		resident.
;*
;* INPUT:	Inputs to SYSLOADMSG
;*
;* OUTPUT:	Outputs from SYSLOADMSG
;*
;****************************************************************

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
TSYSLOADMSG:
	push	bx				;AN000;
	call	SYSLOADMSG			;AN000; call routine
	pop	bx				;AN000;
	retn					;AN000; exit

;****************************************************************
;*
;* ROUTINE:	TSYSGETMSG
;*
;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
;*		names since these routines are also used in the
;*		resident.
;*
;* INPUT:	Inputs to SYSGETMSG
;*
;* OUTPUT:	Outputs from SYSGETMSG
;*
;****************************************************************

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
TSYSGETMSG:
	push	cx				;AN000;
	call	SYSGETMSG			;AN000; call routine
	pop	cx				;AN000;
	retn					;AN000; exit

;============================================================================
; MSGSERV.ASM, MSDOS 6.0, 1991
;============================================================================
; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; ---------------------------------------------------------------------------
; MODULE NAME: MSGSERV.SAL
;
; DESCRIPTIVE NAME: Message Services SALUT file
;
; FUNCTION: This module incorporates all the messages services and
;	    is called upon at build time to INCLUDE the code requested
;	    by a utility. Code is requested using the macro MSG_SERVICES.
;
; ENTRY POINT: Since this a collection of subroutines, entry point is at
;	    requested procedure.
;
; INPUT: Since this a collection of subroutines, input is dependent on
;	    function requested.
;
; EXIT-NORMAL: In all cases, CARRY FLAG = 0
;
; EXIT-ERROR: In all cases, CARRY FLAG = 1
;
; INTERNAL REFERENCES: (list of included subroutines)
;
;	- SYSLOADMSG
;	- SYSDISPMSG
;	- SYSGETMSG
;
; EXTERNAL REFERENCES: None
;
; NOTES: At build time, some modules must be included. These are only included
;	 once using assembler switches. Other logic is included at the request
;	 of the utility.
;
;	 COMR and COMT are assembler switches to conditionally assemble code
;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
;	 storage and multiple EQUates.
;
; REVISION HISTORY: Created MAY 1987
;
;     Label: DOS - - Message Retriever
;	     (c) Copyright 1988 Microsoft
; ---------------------------------------------------------------------------

;	Revision History
;	================
;
;	M007	SR	08/24/90	Fixed bug #1818 -- changed
;				$M_DISPLAY_H_STRING to properly
;				handle Ctrl-Z being passed
;
;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
;				these routines are no longer assembled.
;
;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
;				CR-LF string also gets reinitialized
;				on every cycle.
;
;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
;				& $_MSG_NUM also in SYSLOADMSG.

; ---------------------------------------------------------------------------

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;;; Replacable parameters are described by a sublist structure
;
;struc $M_SUBLIST_STRUC		;;AN000;;
; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
; .$M_S_ID:	resb 1		;;AN000;; n of %n
; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
;endstruc

;; Each class will be defined by this structure.

struc $M_CLASS_ID		;;AN000;;
 .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 .size:
endstruc

$M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;

;; Each message will be defined by this structure.

struc $M_ID			;;AN000;;
 .$M_NUM:	resw 1		;;AN000;; Message Number
 .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 .size:	
endstruc

$M_ID_SZ	EQU  $M_ID.size	;;AN000;;

; ---------------------------
; MSDOS 6.0, SYSMSG.INC, 1991
; ---------------------------
$M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;

; --------------------------- 

; 07/04/2023
$M_NUM_CLS equ 3

;; Resident data area definition of variables

struc $M_RES_ADDRS			;;AN000;;
 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 .$M_EXT_FILE:	    resd 1		;;AN001;;
 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 .$M_EXT_TERM:	    resd 1		;;AN000;;
 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 .$M_PARSE_TERM:    resd 1		;;AN000;;
 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 .$M_CLS_TERM:	    resd 1		;;AN000;;
 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 .$M_HANDLE:	    resw 1 		;;AN000;;
 .$M_SIZE:	    resb 1		;;AN000;;
 .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 .$M_CLASS:	    resb 1		;;AN004;; Saved class
 .$M_RETURN_ADDR:   resw 1		;;AN000;;
 .$M_MSG_NUM:	    resw 1		;;AN000;;
 .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 .$M_BUF_TERM:	    resb 1		;;AN000;;
 .size:
endstruc				;;AN000;;

$M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;

;; Important fields of the Get Country Information call

struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
					;;AN000;; Go past first part of struc
 .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 .$M_CURR_SEPARA:   resb 5		;;AN000;;
 .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 .$M_CURR_FORMAT:   resb 1		;;AN000;;
 .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
endstruc				;;AN000;;

; ---------------------------------------------------------------------------

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: SYSLOADMSG
;;
;;	FUNCTION:
;;	INPUTS:
;;
;;	OUTPUTS:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h

SYSLOADMSG:
	push	ax				;;AN000;
	push	bx				;;AN000;
	push	dx				;;AN000;
	push	es				;;AN000;
	push	di				;;AN000;
	xor	cx,cx				;;AN000;  Reset to zero
	mov	es,cx				;;AN000;
	xor	di,di				;;AN000;
	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
	int	2Fh				;;AN000;; Private interface
		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
		; Return: ES:DI -> error table
	
	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
	;mov	[$M_RT+8],di			;;AN000;;

	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
	int	2Fh				;;AN000;; Private interface
		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
		; ES:DI -> error table

	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
	;mov	[$M_RT+16],di			;;AN000;;

	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
	int	2Fh				;;AN000;; Private interface
		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
		; DL = subfunction - get ??? error table
		; ES:DI -> error table

	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
	;mov	[$M_RT+32],di			;;AN000;;

	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
	int	2Fh					     ;;AN001;; Private interface
		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
		; DL = subfunction - get ??? error table
		; ES:DI -> error table

	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
	;mov	[$M_RT+4],di			;;AN001;;

	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
						;;AN000;;
	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
	;mov	[$M_RT+0],di			;;AN000;;
	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
	;mov	[$M_RT+28],di			;;AN000;;

	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)

	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
	;mov	[$M_RT+20],di			;;AN000;;

	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
	int	2Fh				;;AN001;; Private interface
		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
		; DL = subfunction - get ??? error table
		; ES:DI -> error table

	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
	;mov	[$M_RT+40],di			;;AN001;;

;M016; M020
; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.

	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
	;mov	word [$M_RT+72],0		; M020
	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10		; M020

	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
	; --------------------------
	; MSDOS 6.0 SYSMSG.INC, 1991
	; --------------------------
	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h

	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
	call    $M_CLS_3			; Get addressibility to class F
	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
	;mov	[$M_RT+44],di
	
	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector

	; 15/04/2023
	;clc					;;AN000;; Make sure carry is clear
	;jc	short $MIF20
	
	pop	di				;;AN000;; Restore REGS
	pop	es				;;AN000;;
	pop	dx				;;AN000;;
	pop	bx				;;AN000;;
	pop	ax				;;AN000;;
	;jmp	short $MEN20
	; 15/04/2023
	retn

	; 15/04/2023
;$MIF20:
	;add	sp,10				;;AN000;;
	;stc					;;AN000;; Reset carry flag
;$MEN20:
	;retn					;;AN000;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	$M_GET_DBCS_VEC
;;
;;  Function:	Get the DBCS vector and save it for later use
;;
;;  Inputs:	None
;;
;;  Outputs:	None
;;
;;  Regs Changed:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_GET_DBCS_VEC:
	push	ax				;;AN000;; Save character to check
	push	si				;;AN000;;
	push	ds				;;AN000;;
	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
	int	21h				;;AN000;; Get environment pointer
	push	ds				;;AN000;; Get environment pointer
	pop	es				;;AN000;; Get environment pointer
	pop	ds				;;AN000;; Get environment pointer
	jc	short $MIF23
	
	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
	;mov	word [$M_RT+62],es		;;AN000;;
$MIF23:
	pop	si				;;AN000;;
	pop	ax				;;AN000;; Retrieve character to check
	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	SYSGETMSG
;;
;;  Function:	The GET service returns the segment, offset and size of the
;;		message text to the caller based on a message number.
;;		The GET function will not display the message thus assumes
;;		caller will handle replaceable parameters.
;;
;;  Inputs:
;;
;;  Outputs:
;;
;;  Psuedocode:
;;		Call $M_GET_MSG_ADDRESS
;;		IF MSG_NUM exists THEN
;;		   Set DS:SI = MSG_TXT_PTR + 1
;;		   CARRY_FLAG = 0
;;		ELSE
;;		   CARRY_FLAG = 1
;;		ENDIF
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	utility_msg_class equ 0FFh ; 18/04/2023

SYSGETMSG:
	;; Save registers needed later
	push	ax				;;AN000;; Save changed regs
	push	es				;;AN000;;
	push	di				;;AN000;;
	push	bp				;;AN000;;

	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
	jc	short $MIF31
	
	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
	clc					;;AN000;;
	je	short $MIF32			;;AN000;;

	push	es				;;AN000;;
	;pop	ds				;;AN000;;
	jmp	short $MEN32
$MIF32:
	push	cs				;;AN000;;			
	;pop	ds				;;AN000;;
$MEN32:
	; 07/04/2023
	pop	ds
	mov	si,di				;;AN000;; Return message in DS:SI
$MIF31:
	pop	bp				;;AN000;; Restore changed regs
	pop	di				;;AN000;;
	pop	es				;;AN000;;
	pop	ax				;;AN000;;
	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_GET_MSG_ADDRESS
;;
;;	FUNCTION:  To scan thru classes to return pointer to the message header
;;	INPUTS:    Access to $M_RES_ADDRESSES
;;	OUTPUTS:   IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN ES:DI points to the specified message
;;	REGS CHANGED: ES,DI,CX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_GET_MSG_ADDRESS:
	push	si				;;AN000;;
	push	bx				;;AN000;;
	xor	si,si				;;AN000;; Use SI as an index
	xor	cx,cx				;;AN000;; Use CX as an size
$MDO36:
	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
	jne	short $MIF37			;;AN000;; No			
	
	; 07/04/2023
	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
	mov	bx,di				;;AN000;;
	jmp	short $MEN37
$MIF37:
	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
	jz	short $MIF39
	
	; 07/04/2023
	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
	
	; 07/04/2023
	;mov	bx,es ; *			;;AN000;;
	jmp	short $MEN39
$MIF39:
	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;

	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;

	; 07/04/2023
	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
	
	; 07/04/2023
	;mov	bx,es ; *			;;AN000;;
	jmp	short $MEN41
$MIF41:
	; 07/04/2023
	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
	
	; 07/04/2023
	;mov	bx,es ; *			;;AN000;;
$MEN41:
$MEN39:
	; 07/04/2023
	mov	bx,es ; *
$MEN37:						;;AN000;;
	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
	jne	short $MIF46			;;AN000;; No

	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
	jne	short $MIF47			;;AN000;; No
	stc		     ; **-		;;AN000;; Set the carry flag
	; 07/04/2023
	;jmp	short $MEN47 ; **-
	jmp	short $MEN36 ; **-
$MIF47:
	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],AX
	;mov	[$M_RT+72],ax			;;AN000;; Save message number
	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
	xor	si,si				;;AN000;; Reset the SI index to start again
	; 28/04/2023
	; 07/04/2023
	;clc	; **+				;;AN000;;
;$MEN47:
	;jmp	short $MEN46 ; ***
	jmp	short $MEN47 ; ***
$MIF46:
	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
	and	bx,bx ; 0 ?
	jz	short $MIF51			;;AN000;; No
	
	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
$MIF51:
	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
	; 07/04/2023
	;clc					;;AN000;;
;$MEN46:
	;jc	short $MEN36 ; **- ; **+	;;AN000;;
$MEN47:	; 07/04/2023	; **+
	or	cx,cx				;;AN000;; Was the message found?
	;jnz	short $MXL2			;;AN000;; Yes
	;jmp	short $MDO36
	; 07/04/2023
	jz	short $MDO36	
$MXL2:
$MEN36:
	pushf 					;;AN006;; Save the flag state
	
	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
	;jne	short $MIF56			;;AN006;; No
	; 28/04/2023
	jne	short $M_MYRET	

	push	dx				;;AN006;; Save all needed registers
	push	bp				;;AN006;;
	push	cx				;;AN006;;
	push	es				;;AN006;;
	push	di				;;AN006;;
	push	ax				;;AN006;;

	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
	int	2Fh				;;AN006;;
		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
		; Return: AL = 00h not installed, OK to install
		; 01h not installed, can't install
		; FFh installed

	cmp	al, 0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
	pop	ax				;;AN006;; Restore msg number
	jne	short $MIF57			;;AN006;; No (not installed)

	mov	bx,ax				;;AN006;; BX is the extended error number
	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
	int	2Fh				;;AN006;; Call IFSFUNC
		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER

	;jmp	short $MEN57			;;AN006;;
	; 28/04/2023
	jc	short $MEN57
$MIF60:
	add	sp,6				;;AN006;; Throw away old pointer
	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
$MEN60:
	pop	bp				;;AN006;; Restore other Regs
	pop	dx				;;AN006;;
$MIF56:
	; 07/04/2023
	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
	jmp	short $M_MYRET			;;AN006;; Restore the flag state

$MIF57:
	stc					;;AN006;; Carry conditon
$MEN57:
	; 28/04/2023
	;jnc	short $MIF60			;;AN006;;

	pop	di				;;AN006;;
	pop	es				;;AN006;; Restore old pointer
	pop	cx				;;AN006;;
	jmp	short $MEN60

;$MIF60:
;	add	sp,6				;;AN006;; Throw away old pointer
;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
;$MEN60:
;	pop	bp				;;AN006;; Restore other Regs
;	pop	dx				;;AN006;;
;$MIF56:
;	; 07/04/2023
;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
;	jmp	short $M_MYRET			;;AN006;; Restore the flag state

; 07/04/2023
; ---------------------------
; MSDOS 6.0, SYSMSG.INC, 1991
; ---------------------------
	; $M_POPF macro
	;jmp	short $+3
m_popf_iret:
	iret
$M_MYRET:
	push	cs
	call	m_popf_iret
	;;; end macro	
; ---------------------------

	pop	bx				;;AN000;;
	pop	si				;;AN000;;
	retn					;;AN000;; Return ES:DI pointing to the message

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$M_SET_LEN_IN_CX:			
	push	di				;;AN006;; Save position
	push	ax				;;AN006;;
	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
	xor	al,al				;;AN006;; Prepare compare register
	repne	scasb				;;AN006;; Scan for zero
	not	cx				;;AN006;; Change decrement into number
	dec	cx				;;AN006;; Don't include the zero
	pop	ax				;;AN006;;
	pop	di				;;AN006;; Restore position
	retn					;;AN006;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_FIND_SPECIFIED_MSG
;;
;;	FUNCTION:  To scan thru message headers until message is found
;;	INPUTS:    ES:DI points to beginning of msg headers
;;		   CX contains the number of messages in class
;;		   DH contains the message class
;;	OUPUTS:    IF CX = 0 THEN Message was not found
;;		   IF CX > 1 THEN ES:DI points to header of specified message
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_FIND_SPECIFIED_MSG:
	cmp	bx,1				;;AN004;; Do we have an address to CALL?
	jne	short $MIF64
	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
	jne	short $MIF64

	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
	jne	short $MIF65
	
	push	ax				;;AN004;; Reset the special message number
	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
						;;AN004;; Call the READ_DISK_PROC to get error text
	pop	ax				;;AN004;; Reset the special message number
	; 28/04/2023
	jmp	short $MEN65
	; 18/04/2023
	;jmp	short $MEN64
$MIF65:
	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
						;;AN004;; Call the READ_DISK_PROC to get error text
$MEN65:
	; 28/04/2023
	jnc	short $MIF75
	;
	jmp	short $MEN64 ; $MDO76		;;AN004;;
$MIF64:
	xor	cx,cx				;;AN002;; CX = 0 will allow us to
	cmp	dh,utility_msg_class ; -1	;;AN001;;
	je	short $MIF69
	
	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
	jmp	short $MEN69
$MIF69:
	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
	;cmp	[cs:di+0],dh
	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
	jne	short $MIF71

	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
$MIF71:						;;AN001;;
$MEN69:
	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
	; 02/05/2023
	;stc					;;AN004;; Flag that we haven't found anything yet
$MEN64:
	;jnc	short $MIF75
	; 28/04/2023
	; (or instruction clears carry flag)
	;clc					;;AN004;; No, reset carry
$MDO76:
	or	cx,cx				;;AN000;; Do we have any to check?
	jz	short $MEN76

	cmp	dh,utility_msg_class ; -1	;;AN001;;
	je	short $MIF78

	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
	cmp	ax,[es:di]
	jmp	short $MEN78
$MIF78:
	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
	cmp	ax,[cs:di]
$MEN78:
	;jne	short $MIF76
	;jmp	short $MSR76
	; 07/04/2023
	je	short $MSR76 ; *
$MIF76:
	dec	cx				;;AN000;; No, well do we have more to check?
	jz	short $MEN76

	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
	jmp	short $MDO76			;;AN000;;
$MEN76:
	stc					;;AN000;;
;$MSR76:	; 07/04/2023
	;jc	short $MIF86			;;AN000;;
	; 07/04/2023
	;jc	short $MIF91
	jmp	short $MIF91 ;*
$MSR76:	; 07/04/2023 ; *	
	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
	; 07/04/2023
	;clc					;;AN001;;
	jne	short $MIF87

	push	cs				;;AN000;;
	pop	es				;;AN000;; Return ES:DI pointing to the message
$MIF87:
	;add	di,[es:di+2]
	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
$MIF86:
;$MIF75:
	; 02/05/2023
	;jc	short $MIF91
$MIF75:	; 28/04/2023
	xor	ch,ch				;;AN000;;
	mov	cl,[es:di]			;;AN000;; Move size into CX
	inc	di				;;AN000;; Increment past length
$MIF91:
	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;  Proc Name:	SYSDISPMSG
;;
;;  Function:	The DISPLAY service will output a defined message to a handle
;;		requested by the caller. It also provides function to display
;;		messages when handles are not applicable (ie. DOS function calls
;;		00h to 0Ah) Replaceable parameters are allowed and are
;;		defined previous to entry.
;;
;;		It is assumes that a PRELOAD function has already determined
;;		the addressibilty internally to the message retriever services.
;;  Inputs:
;;
;;  Outputs:
;;
;;  Psuedocode:
;;		Save registers needed later
;;		Get address of the message requested
;;		IF Message number exists THEN
;;		  IF replacable parameters were specified THEN
;;		     Display message with replacable parms
;;		  ELSE
;;		     Display string without replacable parms
;;		  ENDIF
;;		  IF character input was requested THEN
;;		     Wait for character input
;;		  ENDIF
;;		  Clear CARRY FLAG
;;		ELSE
;;		   Set CARRY FLAG
;;		ENDIF
;;		Return
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h

SYSDISPMSG:
	;; Save registers and values needed later
	push	ax				;;AN000;; Save changed REGs
	push	bx				;;AN000;;
	push	cx				;;AN000;;
	push	bp				;;AN000;;
	push	di				;;AN000;; Save pointer to input buffer (offset)
	push	es				;;AN000;; Save pointer to input buffer (segment)
	push	dx				;;AN000;; Save Input/Class request

	mov	bp,cx				;;AN000;; Use BP to hold replace count
	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
	;mov	[$M_RT+64],bx			;;AN000;; Save handle
	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
	;mov	[$M_RT+69],dh			;;AN004;; Save class

	;; Get address of the message requested
	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
	or	cx,cx				;;AN000;; Was message found?
	jz	short $MIF93
						;;AN000;; Yes, Message address in ES:DI
	
	;; Test if replacable parameters were specified
	or	bp,bp				;;AN000;; Were replacable parameters requested
	jnz	short $MIF94

	;; Display string without replacable parms
	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
	jmp	short $MEN94
$MIF94:
	;; Display message with replacable parms
	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
$MEN94:
	jc	short $MIF97
	pop	dx				;;AN000;; Get Input/Class request
	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
	pop	es				;;AN000;; Get location of input buffer (if specified)
	pop	di				;;AN000;;
	;jmp	short $MEN97 ; ***
	; 08/04/2023
	;jmp	short $MEN93 ; **

	; 08/04/2023
;$MEN93:
	jc	short $MIF104
;$MEN97:
	pop	bp				;;AN000;;
	pop	cx				;;AN000;;
	pop	bx				;;AN000;;
	pop	ax				;;AN000;;
	retn
 
$MIF97:
	; 08/04/2023
	;add	sp,6				;;AN000;;
	;stc					;;AN000;; Reset carry flag
;$MEN97: ; ***
	;jmp	short $MEN93
	; 08/04/2023
	;jmp	short $MIF104
	; 08/04/2023
	add	sp,14 ; 6+8
	stc
	retn
$MIF93:
	; 08/04/2023
	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
	pop	es				;;AN000;; Get pointer to input buffer (segment)
	pop	di				;;AN000;; Get base pointer to first sublist (offset)
	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
	;stc	; * 				;;AN000;; Set carry flag
	; 08/04/2023
	;jmp short $MIF104 ; *

;$MEN93: ; **
;	jc	short $MIF104
;$MEN97: ; 08/04/2023
;	pop	bp				;;AN000;;
;	pop	cx				;;AN000;;
;	pop	bx				;;AN000;;
;	pop	ax				;;AN000;;
;	;jmp	short $MEN104
;	; 08/04/2023
;	retn

$MIF104: ; *
	add	sp,8				;;AN000;; Eliminate from stack
	stc					;;AN000;;
$MEN104:
	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_STRING
;;
;;	FUNCTION:  Will display or write string
;;	INPUTS:    ES:DI points to beginning of message
;;		   CX contains the length of string to write (if applicable)
;;	OUTPUTS:   None
;;	REGS Revised: None
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_DISPLAY_STRING:
	push	ax				;;AN000;;
	push	bx				;;AN000;;
	push	dx				;;AN000;;
	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
	
	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
	jne	short $MIF107

	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
	jmp	short $MEN107
$MIF107:
	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
$MEN107:
	jnc	short $MIF110
	
	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
	; 08/04/2023
	xor	bx,bx
	int	21h				;;AN000;;
		; DOS - 3+ - GET EXTENDED ERROR CODE
		; BX = version code (0000h for DOS 3.x)
	xor	ah,ah				;;AN000;; Clear AH
$MEN110: ; 08/04/2023 ; ***
	add	sp,6				;;AN000;; Clean up stack
	stc					;;AN000;; Flag that there was an error
	;jmp	short $MEN110 ; ****
	; 08/04/2023
	retn
$MIF110:
	;cmp	bx,$M_NO_HANDLE
	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
	je	short $MIF112 ; *  ; cf = 0
	cmp	ax,cx				;;AN001;; Was it ALL written?
	je	short $MIF113 ; ** ; cf = 0
	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
	;add	sp,6				;;AN001;; Clean up stack
	;stc					;;AN001;; Flag that there was an error
	; 08/04/2023
	jmp	short $MEN110 ; ***
	; 08/04/2023
;$MIF112:
;$MEN110: ; ****
	;jc	short $MIF117
$MIF112: ; 08/04/2023	; *
$MIF113:	; **
	pop	dx				;;AN000;; Restore regs
	pop	bx				;;AN000;;
	pop	ax				;;AN000;;
$MIF117:
	retn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_$_STRING
;;
;;	FUNCTION:  Will display a $ terminated string
;;	INPUTS:    ES:DI points to beginning of message text (not the length)
;;	OUTPUTS:   None
;;	REGS USED: AX,DX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_DISPLAY_$_STRING:
	push	ds				;;AN000;;
	push	es				;;AN000;;
	pop	ds				;;AN000;; Set DS to segment of message text

	; 08/04/2023
	mov	ah,2 ; DOS_DISP_CHAR

	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
	cmp	cx,1 ; $M_SINGLE_CHAR
	jne	short $MIF119			;;AN000;; No
	
	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
	mov	dl,[es:di]			;;AN000;; Get the character
	int	21h				;;AN000;; Write character
		; DOS - DISPLAY OUTPUT
		; DL = character to send to standard output
	pop	ds				;;AN000;;
	mov	al,dl				;;AN000;; Get the character in AL
	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
	push	ds				;;AN000;;
	push	es				;;AN000;;
	pop	ds				;;AN000;; Set DS to segment of message text
	jnc	short $MIF120 ; *

	mov	dl,[es:di+1]			;;AN000;; Get the next character
	int	21h				;;AN000;; Write character
		; DOS - DISPLAY OUTPUT
		; DL = character to send to standard output
	; 08/04/2023
	;clc					;;AN000;; Clear the DBCS indicator
;$MIF120:
	jmp	short $MEN119
$MIF119:
	; 08/04/2023
	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
;$MDO123:
	or	cx,cx				;;AN002;; Are there any left to display?
	;jz	short $MEN123
	; 18/04/2023
	jz	short $MIF120 ; cf = 0
$MDO123: ; 08/04/2023
	mov	dl,[es:di]			;;AN002;; Get the character
	int	21h				;;AN002;; Display the character
		; DOS - DISPLAY OUTPUT
		; DL = character to send to standard output
	inc	di				;;AN002;; Set pointer to next character
	dec	cx				;;AN002;; Count this character
	jnz	short $MDO123
;$MEN123:
$MEN119:
	clc					;;AN000;;Char functions used don't return carry as error
$MIF120: ; 08/04/2023 ; *
	pop	ds				;;AN000;;
	retn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; Scan_ctrlZ: This routine looks through the string to be printed and 
;; truncates it at the Ctrl-Z if any present.
;;
;;	ENTRY:	ds:dx = String to be displayed
;;		cx = number of chars to be displayed
;;
;;	EXIT:	cx = number of chars to be displayed
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
scan_ctrlz:
	push	di
	push	ax
	push	es
	push	bx

	mov	di,dx
	push	ds
	pop	es   			;es:di points at string

	mov	bx,cx			;save current count

	mov	al,1Ah	; Ctrl-Z
	cld
	repne	scasb			;find first Ctrl-Z
	jnz	short noCtrlZ		;no CtrlZ found in string

	sub	bx,cx
	dec	bx			;bx = new count to display
noCtrlZ:
	mov	cx,bx			;cx = actual display count

	pop	bx
	pop	es
	pop	ax
	pop	di
$MIF127:	; 08/04/2023
	retn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_H_STRING
;;
;;	FUNCTION:  Will display a string to a specified handle
;;	INPUTS:    ES:DI points to beginning of message
;;		   CX contains the number of bytes to write
;;		   BX contains the handle to write to
;;	OUPUTS:    None
;;	REGS USED: AX,DX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_DISPLAY_H_STRING:
	xor	ax,ax			;;AN002;; Set number of bytes written to 0
	or	cx,cx			;;AN002;; For performance, don't write if not necessary
	jz	short $MIF127
	
	push	ds			;;AN000;;
	push	es			;;AN000;;
	pop	ds			;;AN000;; Set DS to segment of message text
	
	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
	mov	dx,di			;;AN000;; Pointer to data to write

	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
	jne	short $MIF128		;;AN000;; No

	int	21h			;;AN000;; Write character
		; DOS - 2+ - WRITE TO FILE WITH HANDLE
		; BX = file handle, CX = number of bytes to writ

	pop	ds			;;AN000;; Set DS to segment of message text
	push	ax			;;AN000;;
	mov	al,[es:di] 		;;AN000;; Get the character
	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
	pop	ax			;;AN000;;
	push	ds			;;AN000;;
	push	es			;;AN000;;
	pop	ds			;;AN000;; Set DS to segment of message text
	jnc	short $MIF129
	
	clc				;;AN000;; Clear the DBCS indicator
	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
	inc	dx			;;AN000;; Point to next character
	int	21h			;;AN000;; Write character
		; DOS - 2+ - WRITE TO FILE WITH HANDLE
		; BX = file handle, CX = number of bytes to write, 
$MIF129:
;SR;
; If the single char happened to be a Ctrl-Z, the dos write would return
;0 chars written making the caller think there was an error writing. To 
;avoid this, we check if the single char was a Ctrl-Z and if so, return that
;the char was written, thus fooling the caller.

	pushf				;save flags
	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
	jne	short m_popf_j		;no, continue

	mov	ax,cx			;yes, fake as if it was written
m_popf_j:
	; 08/04/2023
	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
	jmp	short m_popf		;restore flags

; 07/04/2023
; ---------------------------
; MSDOS 6.0, SYSMSG.INC, 1991
; ---------------------------
	; $M_POPF macro
	;jmp	short $+3
intret:
	iret
m_popf:
	push	cs
	call	intret
	;;; end macro	
; ---------------------------

	jmp	short $MEN128

$MIF128:
;SR;
; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
;we hit a Ctrl-Z. cx will contain the number of characters to be printed.

	push	bp			; M007
	push	cx
	call	scan_ctrlz		;cx = count without Ctrl-Z
	mov	bp,cx			;store no ^Z count in bp ;M007
	pop	cx			;get old count back ;M007
	
	int	21h			;;AN000;; Write String at DS:SI to handle
	;jnc	short chk_count		;no error, adjust return count
	;jmp	short m_cnt_ok		;error, return with carry set;M007
	; 08/04/2023
	jc	short m_cnt_ok 
;M007
; If we are writing to con and there is a Ctrl-Z in the string, the
;return count will be much less and if this returns to the caller we can get
;spurious error messages. We check here if the count returned is same as
;original count or same as the count if we stop at Ctrl-Z. In the second
;case, we fake it as if all bytes have been written. If the return count
;does not match either count, then we had some other disk error (such as
;insufficient disk space) and we pass it through

chk_count:
	cmp	cx,ax			;have all bytes been written?;M007
	je	short m_cnt_ok		;there was an error writing ;M007
	cmp	bp,ax			;count = Ctrl-Z count? ;M007
	clc				;no error either way ;M007
	jne	short m_cnt_ok		;no, pass it through ;M007
	mov	ax,cx			;return old count ;M007
m_cnt_ok:				; M007
	pop	bp			; M007
$MEN128:
	pop	ds			;;AN000;;
;$MIF127: ; 08/04/2023
	retn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_GET_EXT_ERR_39
;;
;;	FUNCTION:  Will set registers for extended error #39
;;	INPUTS:    None
;;	OUPUTS:    AX,BX,CX set
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
$M_GET_EXT_ERR_39:
	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
	mov	bx,4			;AN001; Set BH=1 BL=4
	;mov	ch,LOCUS_39		;AN001; Set CH=1
	mov	ch,1			;AN001;
	retn				;AN001;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_ADD_CRLF
;;
;;	FUNCTION:  Will decide whether to display a CRLF
;;	INPUTS:    DX contains the Input/Class requested
;;	OUTPUTS:   None
;;	REGS Revised: CX,ES,DI
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_ADD_CRLF:
	;cmp	dh,0FFh
	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
	je	short $MIF134		;;AN004;; Yes
	test	dh,80h; $M_NO_CRLF_MASK	;;AN004;; Are we to supress the CR LF?
	jnz	short $MIF135
					;;AN004;; No	
	push	ds			;;AN004;;
	pop	es			;;AN004;; Set ES to data segment
	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
$MIF135:
$MIF134:
	retn				;;AN004;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_IS_IT_DBCS
;;
;;	FUNCTION:  Will decide whether character is Single or Double Byte
;;	INPUTS:    AL contains the byte to be checked
;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
;;		   Carry flag = 1 if byte IS in DBCS range
;;	REGS USED: All restored
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_IS_IT_DBCS:
	push	es			;;AN000;; Save Extra Segment register
	push	di			;;AN000;; Save DI register

	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
	;les	di,[$M_RT+60]		;;AN000;;
	or	di,di			;;AN000;; Was the DBCS vector set?
	jz	short $MIF138		;;AN000;; No
$MDO139:
	cmp	word [es:di],0 ; $M_DBCS_TERM
					;;AN000;; Is this the terminating flag?
	clc				;;AN000;;
	jz	short $MEN139
					;;AN000;; No
	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
	jnae	short $MIF141 ; jb	;;AN000;; No		
	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
	jnbe	short $MIF141 ; ja	;;AN000;; No
					;;AN000;; Yes
	stc				;;AN000;; Set carry flag
$MIF141:
	inc	di			;;AN000;;
	inc	di			;;AN000;;
	jmp	short $MDO139		;;AN000;; Go to next vector
$MEN139:
$MIF138:
	pop	di			;;AN000;; Restore DI register
	pop	es			;;AN000;; Restore Extra Segment register
	retn				;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_CONVERT2ASC
;;
;;	FUNCTION: Convert a binary number to a ASCII string
;;	INPUTS: DX:AX contains the number to be converted
;;		$M_RT_DIVISOR contains the divisor
;;	OUTPUTS: CX contains the number of characters
;;		Top of stack  --> Last character
;;				     . . .
;;		Bot of stack  --> First character
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_CONVERT2ASC:
	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
	
	xor	bx,bx				;;AN000;; Use BX as a swapping register
	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
	xchg	ax,dx				;;AN000;;	  - High Word in AX
$MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
						;;AN000;;  and save reduced High Word in BX
	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor

	cmp	dx,9				;;AN000;; Make a digit of the remainder
	jna	short $MIF146			;;AN000;; 0-9
	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
	jmp	short $MEN146
$MIF146:
	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
$MEN146:
	push	dx				;;AN000;; Save the digit on the stack
	inc	cx				;;AN000;; Count that digit
	or	ax,ax				;;AN000;; Are we done?
	jnz	short $MLL149			;;AN000;; No
	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
$MLL149:
	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
; 28/04/2023
	je	short $MIF153
;	jne	short $MIF150			;;AN000;; No
;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
;	;cmp	byte [si+0Ah],',' ; $M_COMMA
;	;jne	short $MIF151
;	; 09/04/2023
;	jne	short $MEN150
;						;;AN000;; Yes
;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
;	inc	cx				;;AN000;;
;$MIF151:
;	jmp	short $MEN150

$MIF150:
	cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
; 28/04/2023
	je	short $MIF153
;	jne	short $MIF154			;;AN000;; No
;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
;	;cmp	byte [si+0Ah],',' ; $M_COMMA
;	;jne	short $MIF155			;;AN000;; No
;	; 09/04/2023
;	jne	short $MEN154
;						;;AN000;; Yes				
;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
;	inc	cx				;;AN000;;
;$MIF155:
;	jmp	short $MEN154

$MIF154:
	cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
	jne	short $MIF158			;;AN000;; No  
; 28/04/2023
$MIF153:
	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
	;cmp	byte [si+0Ah],',' ; $M_COMMA
	jne	short $MIF159			;;AN000;; No
						;;AN000;; Yes
	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
	inc	cx				;;AN000;;
$MIF159:
$MIF158:
$MEN154:
$MEN150:					;;AN000;;
	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
						;;AN000;;  and Revised Low Word
	xor	dx,dx				;;AN000;; Reset remainder
	; 28/04/2023
	jmp	short $MDO145
;$MEN145:
	; 28/04/2023
	;xor	ax,ax				;;AN000;; Reset remainder
$MEN145: ; 09/04/2023 ; * ; ax = 0
	xor	dx,dx				;;AN000;; Reset remainder
	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DISPLAY_MESSAGE
;;
;;	FUNCTION:  Will display or write entire message (with replacable parameters)
;;	INPUTS:    ES:DI points to beginning of message
;;		   DS:SI points to first sublist structure in chain
;;		   BX contains the handle to write to (if applicable)
;;		   CX contains the length of string to write (before substitutions)
;;		   BP contains the count of replacables
;;
;;	OUTPUTS:
;;	REGS USED: All
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh

$M_DISPLAY_MESSAGE:
; $DO						;;AN000;; Note: DS:SI -> message
$MDO165:
	xor	dx,dx				;;AN000;; Set size = 0
	or	cx,cx				;;AN000;; Are we finished the message yet?
;; $IF NZ					;;AN000;; No
	jz	short $MIF166			;;AN000;; Yes
	mov	ah,"%"				;;AN000;; Prepare to scan for %
	mov	al,0				;;AN004;;
;; $DO						;;AN000;; Scan through string until %
$MDO167:
	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
;; $LEAVE E,AND					;;AN000;; No
	jne	short $MLL168
	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
;; $LEAVE NE,AND				;;AN000;; No
	je	short $MLL168

	cmp	al,ah				;;AN000;; Was the character before a %
;; $LEAVE NE					;;AN000;; No, GREAT found it
	jne	short MEN167
$MLL168:
	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
;;; $IF C					;;AN004;; Yes
	jnc	short $MIF169
	inc	di				;;AN004;; Increment past second part
;;; $ENDIF					;;AN004;;
$MIF169:
	inc	di				;;AN000;; Next character in string
	inc	dx				;;AN000;; Size = Size + 1
	dec	cx				;;AN000;; Decrement total size
;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
	jnz	short $MDO167
$MEN167:
;; $ENDIF					;;AN000;;
$MIF166:
	push	si				;;AN000;; Save beginning of sublists
	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
	or	bp,bp				;;AN000;; Do we have any replacables to do?
;; $IF NZ					;;AN000;; Yes
	jz	short $MIF173
	dec	bp				;;AN000;; Decrement number of replacables

;; Search through sublists to find applicable one

	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
;;; $IF E					;;AN000;; No
	jne	short $MIF174
;;; $SEARCH					;;AN000;;
$MDO175:
	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
	;mov	al,[si+6]
	add	al,30h				;;AN000;; Convert to ASCII
	; 28/04/2023					
	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
;;; $EXITIF E					;;AN000;;
	;jne	short $MIF175
;;; $ORELSE					;;AN000;; No
	;jmp	short $MSR175
	; 28/04/2023
	je	short $MSR175
$MIF175:
	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
;;; $LEAVE E,AND				;;AN000;; Yes
	jne	short $MLL178
	or	dx,dx				;;AN000;; Are we at the end of the message?
;;; $LEAVE Z					;;AN000;; No
	jz	short $MEN175
$MLL178:
	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
	;;add	si,[si+0]
	add	si,[si]
;;; ENDLOOP					;;AN000;; Yes
	jmp	short $MDO175
$MEN175:
	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
;;;; $IF E					;;AN004;; Yes
	jne	short $MIF180
	inc	dx				;;AN000;; Remember to display CR,LF
	inc	dx				;;AN000;;  at the end of the message
	dec	cx				;;AN000;; Adjust message length
	dec	cx				;;AN000;;
	dec	di				;;AN000;; Adjust ending address of message
	dec	di				;;AN000;;
;;;; $ELSE					;;AN004;; No
	jmp	short $MEN180
$MIF180:
	mov	dx,-1 				;;AN004;; Set special case
;;;; $ENDIF					;;AN004;;
$MEN180:
;;; $ENDSRCH					;;AN000;;
$MSR175:
;; $ENDIF					;;AN000;;
$MIF174:
; $ENDIF					;;AN000;;
$MIF173:
;; Prepare and display this part of message

	push	di				;;AN000;; Save pointer to replace number
	sub	di,cx				;;AN000;; Determine beginning of string
	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
	pop	di				;;AN000;; Get back pointer to replace number
	pop	cx				;;AN000;; Clean up stack in case error
; $LEAVE C,LONG					;;AN000;; Fail if carry was set
	;jnc	short $MXL3
	;jmp	$MEN165
	; 02/05/2023
	jc	short $MEN165
$MXL3:
	push	cx				;;AN000;;

;; Save and reset pointer registers

	mov	cx,dx				;;AN000;; Get the size of the rest of the message
	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
; $IF NE					;;AN000;; No
	je	short $MIF187			;;AN000;; Yes			
	or	cx,cx				;;AN000;; Are we finished the whole message?
;; $IF NZ					;;AN000;; No
	jz	short $MIF188			;;AN000;; Yes
	dec	cx				;;AN000;; Decrement total size (%)
	dec	cx				;;AN000;; Decrement total size (#)
	inc	di				;;AN000;; Go past %
	inc	di				;;AN000;; Go past replace number
;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
	;jmp	short $MEN188
	; 28/04/2023
	jmp	short $MEN187
$MIF188:
	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
$MEN188:
; $ELSE 					;;AN000;;
	;jmp	short $MEN187
	; 28/04/2023
	; zf = 1
	;jmp	short $MEN165 

; 28/04/2023
$MXL4:
$MLL214:
$MEN165:
	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
						;;AN000;; Reset message number to null
	retn					;;AN000;; Return

$MIF187:
	or	cx,cx				;;AN000;; Are we finished the whole message?
;; $IF Z					;;AN004;; No
	;jnz	short $MIF192
	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
;; $ELSE					;;AN000;; No
	;jmp	short $MEN192
	; 28/04/2023
	jz	short $MIF188
$MIF192:
	cmp	cx,-1				;;AN004;; Are we at the end of the message?
;;; $IF Z					;;AN004;; No
	jnz	short $MIF194
	xor	cx,cx				;;AN004;;
;;; $ENDIF					;;AN000;;
$MIF194:
	or	di,di				;;AN004;; Turn ZF off
;; $ENDIF					;;AN000;;
$MEN192:
; $ENDIF					;;AN000;; Note this will not leave because INC
$MEN187:
; $LEAVE Z					;;AN000;;
	jz	short $MEN165
	;
	push	bp				;;AN000;; Save the replace count
	push	di				;;AN000;; Save location to complete message
	push	es				;;AN000;;
	push	cx				;;AN000;; Save size of the rest of the message
	xor	cx,cx				;;AN000;; Reset CX used for character count

;; Determine what action is required on parameter

	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
; $IF E						;;AN000;;
	jne	short $MIF199

	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
	;test	byte [si+7],0Fh			;;AN000;;
;; $IF Z					;;AN000;;
	jnz	short $MIF200

;; Character type requested

	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
	;les	di,[si+2]
	call	$M_CHAR_REPLACE			;;AN000;;
;; $ELSE					;;AN000;; Get the rest of the message to display
	jmp	short $MEN200
$MIF200:
;; ENDIF					;;AN000;;
	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
	;test	byte [si+7],0Dh			;;AN000;;
;; $IF Z,OR					;;AN000;;
	jz	short $MLL202
	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
	;test	byte [si+7],0Eh			;;AN000;;
;;; $IF Z,OR					;;AN000;;
	jz	short $MLL202
	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
	;test	byte [si+7],0Ch			;;AN000;;
;;;; $IF Z 					;;AN000;;
	jnz	short $MIF202
$MLL202:

;; Numeric type requested

	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
	call	$M_BIN2ASC_REPLACE		;;AN000;;
;;;; $ELSE					;;AN000;; Get the rest of the message to display
	jmp	short $MEN202
$MIF202:
;;;; ENDIF					;;AN000;;
	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
	;test	byte [si+7],0Bh			;;AN000;;
;;;; $IF E					;;AN000;;
	jnz	short $MIF204

;; Date type requested

	call	$M_DATE_REPLACE			;;AN000;;
;;;; $ELSE					;;AN000;; Get the rest of the message to display
	jmp	short $MEN204
$MIF204:					;;AN000;;

;; Time type requested (Default if we have not matched until here)

	call	$M_TIME_REPLACE			;;AN000;;

;;;; $ENDIF					;;AN000;;
$MEN204:
;;; $ENDIF					;;AN000;;
$MEN202:
;; $ENDIF					;;AN000;;
$MEN200:

;; With the replace information of the Stack, display the replaceable field

	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace

;; None of the above - Extended/Parse replace
; $ELSE 					;;AN000;;
	jmp	short $MEN199
$MIF199:
	call	$M_EXT_PAR_REPLACE		;;AN000;;
; $ENDIF					;;AN000;;
$MEN199:

;; We must go back and complete the message after the replacable parameter if there is any left

; $IF NC					;;AN000;; IF there was an error displaying then EXIT
	jc	short $MIF211
	;
	pop	cx				;;AN000;; Get size of the rest of the message
	pop	es				;;AN000;; Get address of the rest of the message
	pop	di				;;AN000;;
	pop	bp				;;AN000;; Get replacment count
	pop	si				;;AN000;; ELSE get address of first sublist structure
; $ELSE						;;AN000;;
	jmp	short $MEN211
$MIF211:
	add	sp,10				;;AN000;; Clean up stack if error
	; 28/04/2023
	;stc					;;AN000;;
; $ENDIF					;;AN000;;
$MEN211:
	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
; $ENDDO NE,OR					;;AN000;;
	jne	short $MLL214
; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
	; 10/04/2023
	;jc	short $MXL4
	jmp	$MDO165

; 28/04/2023
;$MXL4:
;$MLL214:
;$MEN165:
;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
;						;;AN000;; Reset message number to null
;	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_EXT_PAR_REPLACE
;;
;;	FUNCTION:
;;	INPUTS:
;;	OUPUTS:
;;
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_EXT_PAR_REPLACE:
	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
	call	$M_CONVERT2ASC			;;AN000;;
$MDO215:
	pop	ax				;;AN000;; Get character in register
	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
	inc	bx				;;AN000;; Increase buffer count
	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
	jne	short $MIF216			;;AN000;; No
	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
$MIF216:
	dec	cl				;;AN000;; Have we completed replace?
	jnz	short $MDO215

	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
	inc	bx				;;AN000;; Increase buffer count
	inc	bx				;;AN000;; Increase buffer count
	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
	;retn					;;AN000::
	; 11/04/2023
	;jmp	$M_FLUSH_BUF

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_FLUSH_BUFFER
;;
;;	FUNCTION: Display the contents of the temporary buffer
;;	INPUTS: DI contains the number of bytes to display
;;	OUTPUTS: BX reset to zero
;;
;;	REGS USED:
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
	
	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h

$M_FLUSH_BUF:
	push	cx				;;AN000;; Save changed regs
	push	es				;;AN000;;
	push	di				;;AN000;;
	push	ds				;;AN000;; Set ES pointing to buffer
	pop	es				;;AN000;;
	mov	cx,bx				;;AN000;; Set number of bytes to display
	xor	bx,bx				;;AN000;; Reset buffer counter
	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
	jc	short $MIF314
	pop	di				;;AN000;; No, Restore changed regs
	pop	es				;;AN000;;
	pop	cx				;;AN000;;
	;jmp	short $MEN314
	; 11/04/2023
	retn
$MIF314:
	add	sp,6				;;AN000;; Fix stack
	stc					;;AN000;;
$MEN314:
	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h

$M_DISPLAY_REPLACE:
	xor	bx,bx				;;AN000;; Use BX for buffer count
	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
	jne	short $MIF276
	
	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
	
	inc	bx				;;AN000;; Increment count
	inc	bx				;;AN000;; Increment count
	
	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h; $M_SPACE
	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
	
	inc	bx				;;AN000;; Increment count
	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
$MIF276:
	pop	bp				;;AN000;; Remember the return address
	xor	bx,bx				;;AN000;; Use BX for buffer count
	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack

	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
	;mov	[$M_RT+66],cl
	
	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
	;mov	al,[si+9]
	
	cmp	al,cl				;;AN000;; Do we need pad chars added?
	jna	short $MIF278
	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
	mov	dh,al				;;AN000;; Save the number of pad characters
	
	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
	jz	short $MIF279			;;AN000;; No
$MDO280:
	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
	;mov	al,[si+0Ah]
	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
	
	inc	bx				;;AN000;;
	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
	jne	short $MIF281
	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
$MIF281:
	dec	dh				;;AN000;; Have we filled with enough pad chars?
	jnz	short $MDO280
$MIF279:
$MIF278:
	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
	je	short $MIF286
	
	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
	;;cmp	byte [si+8],cl
	jnb	short $MIF287

	; 03/05/2023
	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
	;;sub	cl,[si+8]
	mov	dl,cl				;;AN000;; Remember how many chars to pop off
	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
	;;mov	cl,[si+8]
	; 03/05/2023
	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
	sub	dl,cl
$MIF287:
$MIF286:
	or	cx,cx				;;AN000;;
	jz	short $MIF290			;;AN000;;
$MDO291:
	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
	;test	byte [si+7],0Fh			;;AN000;;
	jnz	short $MIF292

	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
	jz	short $MIF292			;;AN000;; No

	mov	al,[es:di]			;;AN000;; Get first character from string
	inc	di				;;AN000;; Next character in string
	jmp	short $MEN292
$MIF292:
	pop	ax				;;AN000;; Get character in register
$MEN292:
	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
	; 03/05/2023
	inc	bx				;;AN000;; Increase buffer count
	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
	jne	short $MIF295			;;AN000;;
	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
$MIF295:
	dec	cl				;;AN000;; Have we completed replace?
	jnz	short $MDO291
$MIF290:
	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
	jnz	short $MIF299			;;AN000;; Yes
	or	dh,dh				;;AN000;; Do we need pad chars added?
	jz	short $MIF300
$MDO301:
	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
	;mov	al,[si+0Ah]

	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
	; 03/05/2023
	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char

	inc	bx				;;AN000;;
	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
	jne	short $MIF302			;;AN000;; No
						;;AN000;; Yes
	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
$MIF302:
	dec	dh				;;AN000;; Have we filled with enough pad chars?
	jnz	short $MDO301			;;AN000;;
$MIF300:
$MIF299:
	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
	;test	byte [si+7],0Fh			;;AN000;;
	jnz	short $MIF307
	
	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
	; 11/04/2023
	;jz	short $MIF307			;;AN000;;
	;jmp	short $MEN307			;;AN000;;
	jnz	short $MEN307
$MIF307:
	or	dl,dl				;;AN000;;
	jz	short $MIF309			;;AN000;;
$MDO310:
	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
	dec	dl				;;AN000;; Are we done?
	jnz	short $MDO310
$MIF309:
$MEN307:
	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
	push	bp				;;AN000;; Restore the return address
	retn					;;AN000;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_CHAR_REPLACE
;;
;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI contains the VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;
;;	OTHER REGS Revised: AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_CHAR_REPLACE:
	pop	bp				;;AN000;; Save return address
	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
	;test	byte [si+7],30h			;;AN000;; Was Character specified?
	jnz	short $MIF317			;;AN000;; No
	mov	al,[es:di]			;;AN000;; Get the character
	push	ax				;;AN000;; Put it on the stack
	inc	cx				;;AN000;; Increase the count
	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
	jnc	short $MIF318
	mov	al,[es:di+1]			;;AN000;; Get the next character
	push	ax				;;AN000;; Put it on the stack
	clc					;;AN000;; Clear the carry
$MIF318:
	jmp	short $MEN317
$MIF317:
$MDO321:
	mov	al,[es:di]			;;AN000;; Get the character
	or	al,al				;;AN000;; Is it the NULL?
	jz	short $MEN321			;;AN000;; Yes
	inc	di				;;AN000;; Next character
	inc	cx				;;AN000;; Increment the count
	jmp	short $MDO321
$MEN321:
	sub	di,cx				;;AN000;; Set DI at the beginning of the string
$MEN317:
	push	bp				;;AN000;; Restore return address
	retn					;;AN000;;	

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_BIN2ASC_REPLACE
;;
;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
;;		  and prepare to display
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI contains the VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;	OTHER REGS Revised: BX,DX,AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

$M_BIN2ASC_REPLACE:
	pop	bp				;;AN000;; Save return address
	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor

	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)

	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
	jnz	short $MIF325			;;AN000;; No
	
	mov	al,[es:di]			;;AN000;; Setup byte in AL

	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
	jnz	short $MIF326			;;AN000;; No
			 
	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
	jz	short $MIF327			;;AN000;; No
						;;AN000;; Yes				
	; 12/04/2023
	;inc	bx				;;AN000;; Remember that it was negative
	and	al,01111111b			;;AN000;; Make it positive

	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
	;jmp	short $MIF327
	jmp	short $MIF350 ; inc bx

; 12/04/2023
%if 0

$MIF327:
$MIF335:	; 12/04/2023
	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10		;;AN000;;
$MIF326:
	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
	jnz	short $MIF330			;;AN000;; No
						;;AN000;; Yes
	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10		;;AN000;;
$MIF330:
	jmp	short $MEN325

%endif

$MIF325:
	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
	jnz	short $MIF333			;;AN000;; No
						;;AN000;; Yes
	mov	ax,[es:di]			;;AN000;; Setup byte in AL

	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
	jnz	short $MIF334			;;AN000;; No
						;;AN000;; Yes
	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
	jz	short $MIF335			;;AN000;; No
						;;AN000;; Yes
	; 12/04/2023
	;inc	bx				;;AN000;; Remember that it was negative
	and	ah,01111111b			;;AN000;; Make it positive

	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
	;jmp	short $MIF335
	jmp	short $MIF350 ; inc bx

; 12/04/2023
%if 0

$MIF335:
	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10		;;AN000;;
$MIF334:
	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
	jnz	short $MIF338

	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
	jnz	short $MIF338			;;AN000;; No
						;;AN000;; Yes
	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10		;;AN000;;
$MIF338:
	jmp	short $MEN333			;;AN000;;
%endif

$MIF333:
	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
	mov	dx,[es:di+2]			;;AN000;;

	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
	jnz	short $MIF341			;;AN000;; No
						;;AN000;; Yes
	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
	jz	short $MIF342			;;AN000;; No
						;;AN000;; Yes
	; 12/04/2023
	;inc	bx				;;AN000;; Remember that it was negative
	and	dh,01111111b			;;AN000;; Make it positive
	
	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
$MIF350:
	inc	bx
$MIF342:
	; 12/04/2023
$MIF327:
$MIF335:
	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10		;;AN000;;
$MIF341:
$MIF326:
	; 18/04/2023
$MIF334:
	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
	jnz	short $MIF345			;;AN000;; No
						;;AN000;; Yes
	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10		;;AN000;;
$MIF345:
$MEN333:
$MEN325:
	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string

	or	bx,bx				;;AN000;; Was number negative?
	jz	short $MIF349			;;AN000;; No
						;;AN000;; Yes
	xor	dx,dx				;;AN000;;
	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
	push	dx				;;AN000;;
$MIF349:
	push	bp				;;AN000;; Restore return address
	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_DATE_REPLACE
;;
;;	FUNCTION: Convert a date to a decimal ASCII string using current
;;		  country format and prepare to display
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI points at VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;	OTHER REGS Revised: DX,AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$M_DATE_REPLACE:
	pop	bp				;;AN000;; Save return address

	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
	
	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
						;;AN000;; All O.K.?
	xor	dx,dx				;;AN000;; Reset DX value
	; 12/04/2023
	;xor	ax,ax				;;AN000;; Reset AX value
	
	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
	;jne	short $MIF351
	; 12/04/2023
	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
	or	ax,ax
	jnz	short $MIF351

	call	$M_YEAR				;;AN000;; Get Year
	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string

	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
	;push	word [$M_RT+87]			;;AN000;;
	
	inc	cx				;;AN000;; Increment count
	xor	ax,ax				;;AN000;; Reset AX value

	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
	;mov	al,[si+5]			;;AN000;; Get Day
	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
	
	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
	;push	word [$M_RT+87]			;;AN000;;

	inc	cx				;;AN000;; Increment count
	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
	;mov	al,[si+4]			;;AN000;; Get Month
	; 12/04/2023
	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
	jmp	short $MIF354 ; **
$MIF351:
	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
	;jne	short $MIF353
	; 12/04/2023
	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
	dec	ax 
	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1

	call	$M_YEAR				;;AN000;; Get Year
	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string

	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
	;push	word [$M_RT+87]			;;AN000;;
	
	inc	cx				;;AN000;; Increment count
	xor	ax,ax				;;AN000;; Reset AX

	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
	;mov	al,[si+4]			;;AN000;; Get Month
	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string

	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
	;push	word [$M_RT+87]			;;AN000;;

	inc	cx				;;AN000;;
	      
	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
	;mov	al,[si+5]			;;AN000;; Get Day

	; 12/04/2023
	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
	jmp	short $MIF354 ; **
	; 12/04/2023
$MIF352:
	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
	dec	ax
	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
	;xor	ax,ax
	;jmp	short $MIF355
	; 12/04/2023
	jnz	short $MIF355
$MIF353:
	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
	;jne	short $MIF355

	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
	;mov	al,[si+5]			;;AN000;; Get Day
	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
	
	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
	;push	word [$M_RT+87]			;;AN000;;

	inc	cx				;;AN000;;

	 mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
	;mov	al,[si+4]			;;AN000;; Get Month
	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
	
	 push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
	;push	word [$M_RT+87]			;;AN000;;
	
	inc	cx				;;AN000;;

	call	$M_YEAR				;;AN000;; Get Year
	; 12/04/2023
$MIF354:
	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
$MIF355:
	push	bp				;;AN000;; Restore return address
	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$M_GET_DATE:
	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
	;mov	al,0 				;;AN000;; Get current country info
	; 12/04/2023
	mov	ax,3800h
	;
	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
	int	21h				;;AN000;;
	jnc	short $MIF357
	;
	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
$MIF357:
	retn					;;AN000;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$M_YEAR:
	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
	;mov	ax,[si+2]			;;AN000;; Get Year

	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
	jnz	short $MIF359			;;AN000;; No
						;;AN000;; Yes
	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
	jna	short $MIF360			;;AN000;;
	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
$MIF360:
$MIF359:
	retn					;;AN000;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$M_CONVERTDATE:
$M_CONVERTTIME: ; *!*!  ; 12/04/2023
	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
	;pop	word [$M_RT+76]			;;AN000;; Save return address
	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
	dec	cx				;;AN000;; Test if size only grew by 1
	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
	jne	short $MIF363			;;AN000;; No
	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
	push	ax				;;AN000;; Save it
	inc	cx				;;AN000;; Count it
$MIF363:
	inc	cx				;;AN000;; Restore CX
	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
	;push	word [$M_RT+76]			;;AN000;; Restore return address
	retn

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;	PROC NAME: $M_TIME_REPLACE
;;
;;	FUNCTION: Convert a time to a decimal ASCII string
;;		  and prepare to display
;;	INPUTS: DS:SI points at corresponding SUBLIST
;;		ES:DI points at VALUE from SUBLIST
;;	OUTPUTS: CX contains number of characters on stack
;;		 Top of stack  --> Last character
;;					. . .
;;		 Bot of stack  --> First character
;;	REGS USED: BP,CX,AX
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM							     ;;
$M_TIME_REPLACE:
	pop	bp				;;AN000;; Save return address

	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor

	call	$M_GET_TIME			;;AN000;; All O.K.?

	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
	jz	short $MIF365			;;AN000;; No
						;;AN000;; Yes
	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
	jne	short $MIF366			;;AN000;; No
						;;AN000;; Yes
	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
	;mov	al,[si+2]			;;AN000;; Get Hours
	cmp	al,12				;;AN000;; Is hour 12 or less?
	jl	short $MLL367 ; jnge		;;AN000;; Yes	
	cmp	al,23				;;AN000;; Is hour 24 or greater?
	jng	short $MIF367 ; jle		;;AN000;; No
$MLL367:
	mov	al,'a'	; $M_AM			;;AN000;;
	;push	ax				;;AN000;; Push an "a" to represent AM.
	;inc	cx				;;AN000;;
	;jmp	short $MEN367			;;AN000;;
	; 12/04/2023
	jmp	short $MEN367 ; *
$MIF367:
	mov	al,'p'	; $M_PM			;;AN000;;
$MEN367:	; * ; 12/04/2023
	push	ax				;;AN000;; Push an "p" to represent PM.
	inc	cx				;;AN000;;
;$MEN367:
$MIF366:
$MIF365:					;;AN000;;
	xor	ax,ax				;;AN000;;
	xor	dx,dx				;;AN000;;
	
	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
	jz	short $MIF372			;;AN000;;

	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
	;mov	al,[si+5]			;;AN000;; Get Hundreds
	call	$M_CONVERTTIME			;;AN000;;

	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
	;push	word [$M_RT+85]			;;AN000;;
	inc	cx				;;AN000;;
$MIF372:
	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
	jnz	short $MLL374			;;AN000;; No

	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
	jz	short $MIF374			;;AN000;; No
$MLL374:
	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
	;mov	al,[si+4]			;;AN000;; Get Seconds
	call	$M_CONVERTTIME			;;AN000;;

	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
	;push	word [$M_RT+89]			;;AN000;;
	inc	cx				;;AN000;;
$MIF374:	;;  Do Hour/Min (12 Hour)
	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
	;mov	al,[si+3]			;;AN000;; Get Minutes
	call	$M_CONVERTTIME			;;AN000;;

	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
	;push	word [$M_RT+89]			;;AN000;;
	inc	cx				;;AN000;;

	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
	;mov	al,[si+2]			;;AN000;; Get Hours

	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
	jz	short $MIF376			;;AN000;; No

	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
	jne	short $MIF377			;;AN000;; No

	cmp	al,13				;;AN000;; Is hour less than 12?
	jnge	short $MIF378 ; jl
	sub	al,12				;;AN000;; Set to a 12 hour value
$MIF378:
	;cmp	al,0				;;AN000;; Is hour less than 12?
	;jne	short $MIF380			;;AN000;; No
	; 12/04/2023
	and	al,al
	jnz	short $MIF380	
	mov	al,12				;;AN000;; Set to a 12 hour value
$MIF380:
$MIF377:
$MIF376:
	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
	push	bp				;;AN000;; Restore return address
	retn					;;AN000;; Return

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
$M_GET_TIME:
	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
	;mov	al,0 				;;AN000;; Get current country info
	; 12/04/2023
	mov	ax,3800h
	;
	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
	int	21h				;;AN000;;
	jnc	short $MIF384

	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
$MIF384:
	retn					;;AN000;;

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; 12/04/2023 
;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
%if 0
$M_CONVERTTIME:
$M_CONVERTDATE: ; *!*!  ; 12/04/2023
	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
	;pop	word [$M_RT+76]			;;AN000;; Save return address
	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
	dec	cx				;;AN000;; Test if size only grew by 1
	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
	jne	short $MIF386			;;AN000;; No
	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
	push	ax				;;AN000;; Save it
	inc	cx				;;AN000;; Count itount it
$MIF386:
	inc	cx				;;AN000;; Restore CX
	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
	;push	word [$M_RT+76]			;;AN000;; Restore return address
	retn
%endif

; ----------------------------
; MSDOS 6.0, TPRINTF.ASM, 1991
; ----------------------------
; include msgdcl.inc
; ----------------------------

;============================================================================
; LOADHIGH.ASM, MSDOS 6.0, 1991
;============================================================================
; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; This is a new module added to support loading programs into UMBs provided
; by DOS 5.0. 
; ---------------------------------------------------------------------------
; Usage:
;
; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
;
; <filespec> has to be a filename that is not wildcarded.

; ---------------------------------------------------------------------------
;
;	Revision History
;	================
;
;	M009	SR	08/01/90	Set flags to indicate that we are
;				loading and high and also remember
;				current UMB state.
;
;	M016	SR	08/09/90	Give special error message on attempt
;				to loadhigh batch files and invalid
;				filename on Loadhigh command line.
;
;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
;				after the program name also as part
;				of the command line being passed to
;				the program to be invoked.
;
; ---------------------------------------------------------------------------

; ---------------------------------------------------------------------------
;
;	include highload.inc		; Grab code for ParseVar and such

iCmdLine	equ	81h		; PSP:81h points to command-line

;
; ---------------------------------------------------------------------------

;****	LoadHigh -- Main routine for Loadhigh command
;
;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
;		CS = DS = SS = TRANGROUP
;
;	EXIT	None
;
;	USED	ax, bx, cx, dx, si, di, es
;
;	ERROR EXITS
;		Message pointers are setup at the error locations and then
;	we jump back to CERROR which is the transient error recycle point.
;	Apart from parse errors, the other errors handled are too many
;	switches anf invalid filenames.
;
;	EFFECTS
;		The allocation strategy and the state of the arena chain are
;	put in the requested state according to the given options. If a 
;	filename is also given, it is executed as well.
; ---------------------------------------------------------------------------

	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
LoadHigh:
	push	ds
	pop	es

	call	SkipLhDelims

;Get command tail to be passed to the program. This includes any whitespace
;chars between the program name and its parameters as well.
;On return, ds:si points at the start of the command tail.

	push	si
	call	ParseLhCmd
	pop	si
	jc	short LhErr
	
	call	SetupCmdLine		;setup pgm's command line

	call	SetupPath		;setup path for file
	jc	short LhErr		;file not found

;Set allocation strategy to HighFirst and link in UMBs for exec. This will
;be reset after return from the Exec
;We will also set a resident flag to indicate that UMBs were activated for
;the Exec. On return from the Exec, this flag will be used to deactivate UMBs

	call	HideUMBs		;prepare upper-memory for load

	jmp	LH_EXECUTE		;go and exec file ;M051

LhErr:
;The error message has been setup at this stage

	jmp	cerror			;print error message and recycle 

; ---------------------------------------------------------------------------
					
;*** 	ParseLhCmd - parses any command-line options
;
;	ENTRY	None
;
;	EXIT	Carry clear -- command line parsed successfully
;		Carry set -- appropriate error message setup
;
;	USED	ax, si
;
;	EFFECTS
;		Options set up (see highvar.inc)
;		Filename to be executed setup
;
;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
;	then calls ParseVar itself to actually parse the commmand-line.  On
;	return from ParseVar, DS:SI will point to the beginning of the child
;	module's name on the command-line; thus it calls LhCopyFilename to
;	prepare the command-line for that program.
; ---------------------------------------------------------------------------

	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
	; 11/06/2023
ParseLhCmd:
	;mov	si,81h
	mov	si,iCmdLine	;ds:si points at command line

	mov	word [COMSW],0
	mov	di,Parse_LoadHi
	xor	cx,cx
	call	Parse_With_Msg

	; 11/06/2023
	;cmp	ax,0FFFFh ; -1
	;jz	short PLhCmd2
	;cmp	ax,0
	;jnz	short PLhCmd1
	; 11/06/2023
	inc	ax ; cmp ax,-1
	jz	short PLhCmd2 ; 0FFFFh -> 0
	dec	ax ; cmp ax,0
	jnz	short PLhCmd1 ; 1 -> 0
	; ax = 0

	mov	bx,dx
	; 14/04/2023
	;call	LhCopyFilename
	;; 13/04/2023
	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
	;;jmp	short PLhCmd2
	;retn
	; 14/04/2023
	jmp	short LhCopyFilename
PLhCmd1:
	stc
PLhCmd2:
	retn

; ---------------------------------------------------------------------------

	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; ---------------------------------------------------------------------------
; HIGHlOAD.INC, MSDOS 6.0, 1992
; ---------------------------------------------------------------------------

	; 13/04/2023
	; MSDOS 5.0 COMMAND.COM only !
	; (Procedure names are not from original Microsoft source code!)
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
;set_strategy:
	;mov	ax,5800h	; DOS_CHECK_STRATEGY
	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
	;		; AL = function code: get allocation strategy
	;mov	bx,ax
	;or	bx,80h
	;mov	ax,5801h	; DOS_SET_STRATEGY
	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
	;		; AL = function code: set allocation strategy
	;retn

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
;set_umblink:
	;mov	ax,5803h	; DOS_SET_UMBLINK
	;mov	bx,1
	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
	;		; AL = function code: (DOS 5beta) set UMB link state
	;retn

; ---------------------------------------------------------------------------

;***	LhCopyFilename -- copy filename from command line to buffer
;
;	ENTRY	ds:si points at primary argument (filename)
;
;	EXIT	Carry set -- filename has wildcards.  In this event, DX will
;				already contain an appropriate error number.
;		Carry clear -- filename has been copied as needed; DS:SI
;				points to first character (most likely space)
;				after filename.
;
;	USED	ax, si
;
;	EFFECTS
;		ExecPath contains the filename
;
; If there are any wildcards in the filename, then we have an error
; ---------------------------------------------------------------------------

	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
LhCopyFilename:
	push	ds
	push	si
	push	di
	lds	si,[bx+4]
	mov	di,EXECPATH
lhcpfn1:
	lodsb
	cmp	al,2Ah ; '*'
	jz	short lhfilerr
	cmp	al,3Fh ; '?'
	jz	short lhfilerr
	stosb
	or	al,al
	jnz	short lhcpfn1
	; 14/04/2023
	; cf = 0
	;clc
lhfilerr2:
	pop	di
	pop	si
	pop	ds
	retn
lhfilerr:
	mov	dx,LhInvFil_Ptr
	stc
	jmp	short lhfilerr2

; ---------------------------------------------------------------------------
	
	; 14/04/2023
	; 13/04/2023
	; MSDOS 5.0 COMMAND.COM only !
	; (Procedure name is not from original Microsoft source code!)
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
set_strategy:
	mov	ax,5800h	; DOS_CHECK_STRATEGY
	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
			; AL = function code: get allocation strategy
	mov	bx,ax
	or	bx,80h
	mov	ax,5801h	; DOS_SET_STRATEGY
	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
			; AL = function code: set allocation strategy
	retn

; ---------------------------------------------------------------------------

	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
	; MSDOS 5.0 COMMAND.COM only !
	; (Procedure name is not from original Microsoft source code!)
SkipLhDelims:
	mov	si,81h
	call	scanoff
stfn1:
	lodsb
	call	DELIM
	jz	short stfn2
	cmp	al,0Dh
	jz	short stfn2
	cmp	al,[SWITCHAR]
	jnz	short stfn1
stfn2:
	dec	si
	retn

; ---------------------------------------------------------------------------

;***	SetupCmdLine -- prepare command line for the program
;
;	ENTRY	{es/ds}:si = points just after the end of the child program
;
;	EXIT	None
;
;	USED
;
;	EFFECTS		
;		The rest of the command line following the pgm name is 
;	moved to the top of the command line buffer (at TRANGROUP:81h)
;	and a new command line length is put in
; ---------------------------------------------------------------------------

	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
SetupCmdLine:
	;mov	di,81h
	mov	di,iCmdLine
	xor	cl,cl
	dec	cl			;just CR means count = 0
SetCmdL1:
	lodsb
	stosb
	inc	cl			;update count
	; 14/04/2023
	; * ; MSDOS 6.0 only !
	;or	al,al	; *
	;jz	short SetCmdL2 ; *
	cmp	al,0Dh			;carriage return?
	jnz	short SetCmdL1		;no, continue storing
SetCmdL2:
	mov	[es:80h],cl		;store new cmd line length
	retn

; ---------------------------------------------------------------------------

;***	LhSetupErrMsg -- Sets up error messages
;
;	ENTRY	ax = error message number
;
;	EXIT	None
;
;	USED	dx
;
;	EFFECTS
;		Everything setup to display error message
; ---------------------------------------------------------------------------
	
	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
LhSetupErrMsg:
	mov	byte [msg_disp_class],ext_msg_class ; 1
	mov	dx,extend_buf_ptr
	mov	[extend_buf_ptr],ax
	retn

; ---------------------------------------------------------------------------

	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
	; MSDOS 5.0 COMMAND.COM only !
	; (Procedure name is not from original Microsoft source code!)
check_umblink:
	mov	ax,5800h	; DOS_CHECK_STRATEGY
	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
			 ; AL = function code: get allocation strategy
	mov	bl,al
	mov	ax,5802h	; DOS_CHECK_UMBLINK
	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
			; AL = function code: (DOS 5beta) get UMB link state
	mov	bh,al
	xchg	ax,bx
	rol	al,1
	and	al,1
	shl	ah,1
	or	al,ah
	retn

; ---------------------------------------------------------------------------

	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
HideUMBs:
	push	ds
	call	check_umblink
	mov	ds,[RESSEG]
	mov	[fInHigh],al
	or	byte [fInHigh],80h
	pop	ds
	call	set_strategy
	;call	set_umblink
	;retn
	; 14/04/023
	;jmp	short set_ubmlink

; ---------------------------------------------------------------------------

	; 14/04/2023
	; 13/04/2023
	; MSDOS 5.0 COMMAND.COM only !
	; (Procedure name is not from original Microsoft source code!)
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
set_umblink:
	mov	ax,5803h	; DOS_SET_UMBLINK
	mov	bx,1
	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
			; AL = function code: (DOS 5beta) set UMB link state
	retn

; ---------------------------------------------------------------------------

;***	SetupPath -- Do path search for the file to be executed
;
;	ENTRY	None
;
;	EXIT	Carry set if file not found or not executable file
;
;	EFFECTS
;		ExecPath contains the full path of the file to be executed
; ---------------------------------------------------------------------------

	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
SetupPath:

;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
;because the path search routine that we are about to invoke expects the
;filename to search for to be argv[0].
;
;If our new argv[0] starts with a switcharacter, it's an option... skip right
;over it by doing the whole move again (smaller, of course, this time).


	;mov	ax,arg.argvcnt		;total number of arguments
	; 14/04/2023
	;mov	ax,[ARG_ARGVCNT]
	mov	ax,[ARG+ARG_UNIT.argvcnt]

	dec	ax			;less one - skip "LoadHigh"
	;mov	bx,SIZE Argv_ele
	mov	bx,ARGV_ELE.SIZE ; 11
	;mov	bx,11
	mul	bx			;dx:ax = size of argument lists

	; 14/04/2023
	mov	cx,ax			;size to move

	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
	mov	di,ARG	
	mov	si,di			;
	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
	add	si,ARGV_ELE.SIZE ; 11
	
	; 14/04/2023
	;mov	cx,ax

	cld
	rep	movsb			;Move the argument list
	
	;dec	arg.argvcnt		;Fake one less argument, and
	;dec	word [ARG_ARGVCNT]
	dec	word [ARG+ARG_UNIT.argvcnt]
	
; Done moving... argv[0] is now the child program's name, and [1] its first arg

	call	path_search		;look in the path

;ax = 0, no file found
;ax < 4, batch file found -- cant be executed
;ax = 4,8 => .com or .exe file found

	or	ax,ax			;any file found?
	jz	short no_exec_file	;no, error

	cmp	ax,4			;executable file?
	;jl	short no_exec_bat	;no, indicate fail ; M016
	;clc
	;retn
	; 14/04/2023
	jb	short no_exec_bat
	retn 

no_exec_bat:
	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
	jmp	short lhsp_errret	;return error; M016

no_exec_file:
	mov	ax,ERROR_FILE_NOT_FOUND ; 2
	call	LhSetupErrMsg		;setup error message
lhsp_errret:				; M016
	stc
	retn

;============================================================================
; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
;============================================================================
; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h

; ---------------------------------------------------------------------------
; Class 3 message table/structure
; ---------------------------------------------------------------------------

$M_CLASS_3_STRUC:
	db 0FFh			; $M_CLASS_ID (Class identifer)
	dw 5			; $M_COMMAND_VER (COMMAND.COM version)
	db 162			; Total number of messages
$M_ID_3_1:
	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
	dw 1020			; Message Number = 1020
	dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
$M_ID_3_2:
	dw 1015			; Message Number = 1015
	dw MSG_1015-$+2 ; 294h  ; Message offset from message number (5A4Ch+0294h=5CE0h)
$M_ID_3_3:	; 26/04/2023
	dw 1004,MSG_1004-$ ; 692
	dw 1026,MSG_1026-$ ; 714
	dw 1031,MSG_1031-$ ; 730
	dw 1035,MSG_1035-$ ; 741
	dw 1062,MSG_1062-$ ; 752
	dw 1028,MSG_1028-$ ; 763
	dw 1045,MSG_1045-$ ; 793
	dw 1041,MSG_1041-$ ; 818
	dw 1042,MSG_1042-$ ; 848
$M_ID_3_12:
	dw 1043,MSG_1043-$ ; 871
	dw 1002,MSG_1002-$ ; 899
	dw 1003,MSG_1003-$ ; 935
	dw 1007,MSG_1007-$ ; 959
	dw 1008,MSG_1008-$ ; 982
	dw 1009,MSG_1009-$ ; 1000
	dw 1010,MSG_1010-$ ; 1017
	dw 1011,MSG_1011-$ ; 1045
	dw 1014,MSG_1014-$ ; 1068
	dw 1016,MSG_1016-$ ; 1081
	dw 1017,MSG_1017-$ ; 1119
	dw 1018,MSG_1018-$ ; 1152
$M_ID_3_24:
	dw 1019,MSG_1019-$ ; 1168
	dw 1021,MSG_1021-$ ; 1176
	dw 1022,MSG_1022-$ ; 1202
	dw 1023,MSG_1023-$ ; 1237
	dw 1024,MSG_1024-$ ; 1277
	dw 1025,MSG_1025-$ ; 1296
	dw 1027,MSG_1027-$ ; 1316
	dw 1029,MSG_1029-$ ; 1345
	dw 1030,MSG_1030-$ ; 1359
	dw 1032,MSG_1032-$ ; 1370
	dw 1033,MSG_1033-$ ; 1390
	dw 1034,MSG_1034-$ ; 1408
	dw 1036,MSG_1036-$ ; 1426
	dw 1037,MSG_1037-$ ; 1443
	dw 1038,MSG_1038-$ ; 1456
	dw 1039,MSG_1039-$ ; 1471
$M_ID_3_40:
	dw 1040,MSG_1040-$ ; 1528
	dw 1044,MSG_1044-$ ; 1545
	dw 1046,MSG_1046-$ ; 1561
	dw 1047,MSG_1047-$ ; 1612
	dw 1048,MSG_1048-$ ; 1633
	dw 1049,MSG_1049-$ ; 1647
	dw 1050,MSG_1050-$ ; 1653
	dw 1051,MSG_1051-$ ; 1680
	dw 1052,MSG_1052-$ ; 1693
	dw 1053,MSG_1053-$ ; 1712
	dw 1054,MSG_1054-$ ; 1746
$M_ID_3_51:
	dw 1055,MSG_1055-$ ; 1781
	dw 1056,MSG_1056-$ ; 1791
	dw 1057,MSG_1057-$ ; 1802
	dw 1059,MSG_1059-$ ; 1811
	dw 1060,MSG_1060-$ ; 1812
	dw 1061,MSG_1061-$ ; 1812
	dw 1063,MSG_1063-$ ; 1834
	dw 1064,MSG_1064-$ ; 1833
	dw 1065,MSG_1065-$ ; 1832
	dw 1066,MSG_1066-$ ; 1831
	dw 1067,MSG_1067-$ ; 1830
	dw 1068,MSG_1068-$ ; 1828
	dw 1069,MSG_1069-$ ; 1835
	dw 1070,MSG_1070-$ ; 1835
	dw 1071,MSG_1071-$ ; 1834
	dw 1072,MSG_1072-$ ; 1833
$M_ID_3_67:
	dw 1073,MSG_1073-$ ; 1838
	dw 1074,MSG_1074-$ ; 1843
	dw 1075,MSG_1075-$ ; 1848
	dw 1076,MSG_1076-$ ; 1850
	dw 1077,MSG_1077-$ ; 1849
	dw 1078,MSG_1078-$ ; 1853
	dw 1079,MSG_1079-$ ; 1876
	dw 1080,MSG_1080-$ ; 1883
	dw 1081,MSG_1081-$ ; 1901
	dw 1084,MSG_1084-$ ; 1940
	dw 1090,MSG_1090-$ ; 1952
	dw 1091,MSG_1091-$ ; 1962
	dw 1092,MSG_1092-$ ; 1972
	dw 1093,MSG_1093-$ ; 1982
	dw 1094,MSG_1094-$ ; 1999
	dw 1095,MSG_1095-$ ; 2024
	dw 1096,MSG_1096-$ ; 2049
$M_ID_3_84:
	dw 1200,MSG_1200-$ ; 2094
	dw 1300,MSG_1300-$ ; 2091
	dw 1320,MSG_1320-$ ; 2222
	dw 1321,MSG_1321-$ ; 2282
	dw 1340,MSG_1340-$ ; 2391
	dw 1341,MSG_1341-$ ; 2479
	dw 1342,MSG_1342-$ ; 2574
	dw 1360,MSG_1360-$ ; 2716
	dw 1400,MSG_1400-$ ; 2740
	dw 1401,MSG_1401-$ ; 2882
	dw 1402,MSG_1402-$ ; 2983
	dw 1403,MSG_1403-$ ; 3098
	dw 1404,MSG_1404-$ ; 3160
	dw 1420,MSG_1420-$ ; 3292
	dw 1440,MSG_1440-$ ; 3427
	dw 1441,MSG_1441-$ ; 3469
$M_ID_3_100:
	dw 1460,MSG_1460-$ ; 3597
	dw 1461,MSG_1461-$ ; 3694
	dw 1462,MSG_1462-$ ; 3822
	dw 1480,MSG_1480-$ ; 3898
	dw 1481,MSG_1481-$ ; 4057
	dw 1482,MSG_1482-$ ; 4147
	dw 1483,MSG_1483-$ ; 4241
	dw 1484,MSG_1484-$ ; 4360
	dw 1485,MSG_1485-$ ; 4548
	dw 1486,MSG_1486-$ ; 4700
	dw 1487,MSG_1487-$ ; 4847
	dw 1488,MSG_1488-$ ; 4946
$M_ID_3_112:
	dw 1500,MSG_1500-$ ; 5089
	dw 1520,MSG_1520-$ ; 5148
	dw 1540,MSG_1540-$ ; 5206
	dw 1541,MSG_1541-$ ; 5296
	dw 1542,MSG_1542-$ ; 5400
	dw 1560,MSG_1560-$ ; 5456
	dw 1561,MSG_1561-$ ; 5508
	dw 1562,MSG_1562-$ ; 5629
	dw 1563,MSG_1563-$ ; 5673
	dw 1564,MSG_1564-$ ; 5712
	dw 1565,MSG_1565-$ ; 5770
	dw 1566,MSG_1566-$ ; 5819
	dw 1567,MSG_1567-$ ; 5860
	dw 1568,MSG_1568-$ ; 5978
	dw 1580,MSG_1580-$ ; 6051
$M_ID_3_127:
	dw 1600,MSG_1600-$ ; 6119
	dw 1601,MSG_1601-$ ; 6144
	dw 1602,MSG_1602-$ ; 6224
	dw 1620,MSG_1620-$ ; 6298
	dw 1621,MSG_1621-$ ; 6382
	dw 1622,MSG_1622-$ ; 6508
	dw 1640,MSG_1640-$ ; 6580
	dw 1641,MSG_1641-$ ; 6629
	dw 1660,MSG_1660-$ ; 6757
	dw 1680,MSG_1680-$ ; 6824
	dw 1700,MSG_1700-$ ; 6858
	dw 1720,MSG_1720-$ ; 7032
	dw 1740,MSG_1740-$ ; 7111
	dw 1741,MSG_1741-$ ; 7199
	dw 1760,MSG_1760-$ ; 7310
	dw 1780,MSG_1780-$ ; 7383
$M_ID_3_143:
	dw 1800,MSG_1800-$ ; 7487
	dw 1801,MSG_1801-$ ; 7561
	dw 1820,MSG_1820-$ ; 7645
	dw 1821,MSG_1821-$ ; 7713
	dw 1840,MSG_1840-$ ; 7848
	dw 1860,MSG_1860-$ ; 7919
	dw 1861,MSG_1861-$ ; 8006
	dw 1862,MSG_1862-$ ; 8073
	dw 1863,MSG_1863-$ ; 8195
	dw 1864,MSG_1864-$ ; 8354
	dw 1865,MSG_1865-$ ; 8453
	dw 1866,MSG_1866-$ ; 8556
	dw 1880,MSG_1880-$ ; 8656
	dw 1881,MSG_1881-$ ; 8772
	dw 1882,MSG_1882-$ ; 8894
	dw 1883,MSG_1883-$ ; 8977
	dw 1900,MSG_1900-$ ; 9136
	dw 1920,MSG_1920-$ ; 9156
	dw 1921,MSG_1921-$ ; 9200
$M_ID_3_162:
	dw 1922			; Message Number = 1922
	dw MSG_1922-$ ; 9285	; Message offset from message number (5CCCh+2445h=8111h)

; ---------------------------------------------------------------------------
; Class 3 messages
; ---------------------------------------------------------------------------
	
	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h

MSG_1020:	; COMMON4
	db 15	; (MSG_1015-MSG_1020)-1
	db '%1 bytes free',0Dh,0Ah
MSG_1015:	; COMMON18
	db 35
	db 'File cannot be copied onto itself',0Dh,0Ah
MSG_1004:	; COMMON20
	db 25
	db 'Insufficient disk space',0Dh,0Ah
MSG_1026:	; COMMON22
	db 19
	db 'Invalid code page',0Dh,0Ah
MSG_1031:	; COMMON23
	db 14
	db 'Invalid date',0Dh,0Ah
MSG_1035:	; COMMON24
	db 14
	db 'Invalid time',0Dh,0Ah
MSG_1062:	; COMMON25
	db 14
	db 'Invalid path',0Dh,0Ah
MSG_1028:	; COMMON28
	db 33
	db 'Press any key to continue . . .',0Dh,0Ah
MSG_1045:	; COMMON32
	db 28
	db 'Unable to create directory',0Dh,0Ah
MSG_1041:	; COMMON33
	db 33
	db 'Volume in drive %1 has no label',0Dh,0Ah
MSG_1042:	; COMMON34
	db 26
	db 'Volume in drive %1 is %2',0Dh,0Ah
MSG_1043:	; COMMON36
	db 31  ; (MSG_1002-MSG_1043)-1
	db 'Volume Serial Number is %1-%2',0Dh,0Ah
MSG_1002:
        db 39
	db 'Duplicate file name or file not found',0Dh,0Ah
MSG_1003:
	db 27
	db 'Invalid path or file name',0Dh,0Ah
MSG_1007:
	db 26
	db 'Out of environment space',0Dh,0Ah
MSG_1008:
	db 21
	db 'File creation error',0Dh,0Ah
MSG_1009:
	db 20  ; (MSG_1010-MSG_1009)-1
	db 'Batch file missing',0Dh,0Ah
MSG_1010:
	db 31
	db 0Dh,0Ah
	db 'Insert disk with batch file',0Dh,0Ah
MSG_1011:
	db 26
	db 'Bad command or file name',0Dh,0Ah
MSG_1014:	; EXTEND5
	db 16
	db 'Access denied ',0Dh,0Ah
MSG_1016:
	db 41
	db 'Content of destination lost before copy',0Dh,0Ah
MSG_1017:
	db 36
	db 'Invalid filename or file not found',0Dh,0Ah
MSG_1018:
	db 19
	db '%1 file(s) copied',0Dh,0Ah
MSG_1019:
	db 11
	db '%1 file(s) '
MSG_1021:	; EXTEND15
	db 29
	db 'Invalid drive specification',0Dh,0Ah
MSG_1022:
	db 38
	db 'Code page %1 not prepared for system',0Dh,0Ah
MSG_1023:
	db 43
	db 'Code page %1 not prepared for all devices',0Dh,0Ah
MSG_1024:
	db 22
	db 'Active code page: %1',0Dh,0Ah
MSG_1025:
	db 23
	db 'NLSFUNC not installed',0Dh,0Ah
MSG_1027:
	db 32
	db 'Current drive is no longer valid'
MSG_1029:
	db 17
	db 'Label not found',0Dh,0Ah
MSG_1030:
	db 14
	db 'Syntax error',0Dh,0Ah
MSG_1032:
	db 23
	db 'Current date is %1 %2',0Dh,0Ah
MSG_1033:
	db 21
	db 'SunMonTueWedThuFriSat'
MSG_1034:
	db 21
	db 'Enter new date (%1): '
MSG_1036:
	db 20
	db 'Current time is %1',0Dh,0Ah
MSG_1037:
	db 16
	db 'Enter new time: '
MSG_1038:
        db 18
	db ',    Delete (Y/N)?'
MSG_1039:
        db 60
	db 'All files in directory will be deleted!',0Dh,0Ah
	db 'Are you sure (Y/N)?'
MSG_1040:
	db 20
	db 'MS-DOS Version %1.%2'
MSG_1044:
	db 19
	db 'Invalid directory',0Dh,0Ah
MSG_1046:
	db 54
	db 'Invalid path, not directory,',0Dh,0Ah
	db 'or directory not empty',0Dh,0Ah
MSG_1047:
	db 24
	db 'Must specify ON or OFF',0Dh,0Ah
MSG_1048:
	db 17
	db 'Directory of %1',0Dh,0Ah
MSG_1049:
	db 9
	db 'No Path',0Dh,0Ah
MSG_1050:
	db 30
	db 'Invalid drive in search path',0Dh,0Ah
MSG_1051:
	db 16
	db 'Invalid device',0Dh,0Ah
MSG_1052:
	db 22
	db 'FOR cannot be nested',0Dh,0Ah
MSG_1053:
	db 37
	db 'Intermediate file error during pipe',0Dh,0Ah
MSG_1054:
	db 38
	db 'Cannot do binary reads from a device',0Dh,0Ah

	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
MSG_1055:
	db 13
	db 'BREAK is %1',0Dh,0Ah
MSG_1056:
	db 14
	db 'VERIFY is %1',0Dh,0Ah
MSG_1057:
	db 12
	db 'ECHO is %1',0Dh,0Ah
MSG_1059:
	db 4
	db 'off',0
MSG_1060:
	db 3
	db 'on',0
MSG_1061:
	db 25
	db 'Error writing to device',0Dh,0Ah
MSG_1063:
	db 2
	db '%1'
MSG_1064:
	db 2
	db '%1'
MSG_1065:
	db 2
	db '%1'
MSG_1066:
	db 2
	db '%1'
MSG_1067:
	db 1
	db 9
MSG_1068:
	db 10
	db ' <DIR>    '
MSG_1069:
	db 3
	db 8, 20h, 8
MSG_1070:	; CRLF		
	db 2
	db 0Dh
	db 0Ah
MSG_1071:
	db 2
	db '%1'
MSG_1072:
	db 8
	db 'mm-dd-yy'
MSG_1073:
	db 8
	db 'dd-mm-yy'
MSG_1074:
	db 8
	db 'yy-mm-dd'
MSG_1075:
	db 5
	db '%1 %2'
MSG_1076:
	db 2
	db '%1'
MSG_1077:
	db 7
	db ' %1  %2'
MSG_1078:
	db 26
	db 'Directory already exists',0Dh,0Ah
MSG_1079:
	db 10
	db '%1 bytes',0Dh,0Ah
MSG_1080:
	db 21
	db 'Total files listed:',0Dh,0Ah
MSG_1081:
	db 42
	db '(Error occurred in environment variable)',0Dh,0Ah
MSG_1084:
	db 15
	db '(continuing %1)'
MSG_1090:
	db 13
	db 'Revision %1',0Dh,0Ah
MSG_1091:
	db 13
	db 'DOS is in ROM'
MSG_1092:
	db 13
	db 'DOS is in HMA'
MSG_1093:
	db 20
	db 'DOS is in low memory'
MSG_1094:
	db 28
	db 'Cannot Loadhigh batch file',0Dh,0Ah
MSG_1095:
	db 28
	db 'LoadHigh: Invalid filename',0Dh,0Ah
MSG_1096:
	db 48
	db 'Cannot open specified country information file',0Dh,0Ah

	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
MSG_1200:
	db 0	; /? unimplemented
	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C3h)
MSG_1300:
	db 134
	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
	db 0Dh,0Ah
	db 'BREAK [ON | OFF]',0Dh,0Ah
	db 0Dh,0Ah
	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
MSG_1320:
	db 63
	db 'Displays or sets the active code page number.',0Dh,0Ah
	db 0Dh,0Ah
	db 'CHCP [nnn]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1321:
	db 112
	db '  nnn   Specifies a code page number.',0Dh,0Ah
	db 0Dh,0Ah
	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
MSG_1340:
	db 91
	db 'Displays the name of or changes the current directory.',0Dh,0Ah
	db 0Dh,0Ah
	db 'CHDIR [drive:][path]',0Dh,0Ah
	db 'CHDIR[..]',0Dh,0Ah
MSG_1341:
	db 98
	db 'CD [drive:][path]',0Dh,0Ah
	db 'CD[..]',0Dh,0Ah
	db 0Dh,0Ah
	db '  ..   Specifies that you want to change to the parent directory.'
	db 0Dh,0Ah
	db 0Dh,0Ah
MSG_1342:
	db 145
	db 'Type CD drive: to display the current directory in the specified '
	db 'drive.',0Dh,0Ah
	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
MSG_1360:
	db 27
	db 'Clears the screen.',0Dh,0Ah
	db 0Dh,0Ah
	db 'CLS',0Dh,0Ah
MSG_1400:
	db 145
	db 'Copies one or more files to another location.',0Dh,0Ah
	db 0Dh,0Ah
	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
	db '  [/A | /B]] [/V]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1401:
	db 104
	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
MSG_1402:
	db 118
	db '  /B           Indicates a binary file.',0Dh,0Ah
	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
MSG_1403:	
	db 65
	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
	db 0Dh,0Ah
MSG_1404:
	db 135
	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
MSG_1420:
	db 138
	db 'Changes the terminal device used to control your system.',0Dh,0Ah
	db 0Dh,0Ah
	db 'CTTY device',0Dh,0Ah
	db 0Dh,0Ah
	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
MSG_1440:
	db 45
	db 'Displays or sets the date.',0Dh,0Ah
	db 0Dh,0Ah
	db 'DATE [date]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1441:
	db 131
	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
MSG_1460:	
	db 100
	db 'Deletes one or more files.',0Dh,0Ah
	db 0Dh,0Ah
	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1461:
	db 131
	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
	db '                          files by using wildcards.',0Dh,0Ah
MSG_1462:
	db 79
	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
MSG_1480:
	db 162
	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
	db 0Dh,0Ah
	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1481:
	db 93
	db '  [drive:][path][filename]',0Dh,0Ah
	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
MSG_1482:
	db 97
	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
	db '  /W          Uses wide list format.',0Dh,0Ah
MSG_1483:	
	db 122
	db '  /A          Displays files with specified attributes.',0Dh,0Ah
	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
MSG_1484:
	db 191
	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
	db '  /O          List by files in sorted order.',0Dh,0Ah
MSG_1485:
	db 155
	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
MSG_1486:
	db 150
	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
MSG_1487:
	db 102
	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
	db '  /L          Uses lowercase.',0Dh,0Ah
	db 0Dh,0Ah
MSG_1488:
	db 146
	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
MSG_1500:
	db 62
	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
	db 0Dh,0Ah
	db 'EXIT',0Dh,0Ah
MSG_1520:
	db 61
	db 'Creates a directory.',0Dh,0Ah
	db 0Dh,0Ah
	db 'MKDIR [drive:]path',0Dh,0Ah
	db 'MD [drive:]path',0Dh,0Ah
MSG_1540:
	db 93
	db 'Displays or sets a search path for executable files.',0Dh,0Ah
	db 0Dh,0Ah
	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
	db 'PATH ;',0Dh,0Ah
	db 0Dh,0Ah
MSG_1541:
	db 107
	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
	db 'only in the current directory.',0Dh,0Ah
MSG_1542:	
	db 59
	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
MSG_1560:
	db 55
	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
	db 0Dh,0Ah
	db 'PROMPT [text]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1561:	
	db 124
	db '  text    Specifies a new command prompt.',0Dh,0Ah
	db 0Dh,0Ah
	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
	db 0Dh,0Ah
MSG_1562:
	db 47
	db '  $Q   = (equal sign)',0Dh,0Ah
	db '  $$   $ (dollar sign)',0Dh,0Ah
MSG_1563:
	db 42
	db '  $T   Current time',0Dh,0Ah
	db '  $D   Current date',0Dh,0Ah
MSG_1564:
	db 61
	db '  $P   Current drive and path',0Dh,0Ah
	db '  $V   MS-DOS version number',0Dh,0Ah
MSG_1565:
	db 52
	db '  $N   Current drive',0Dh,0Ah
	db '  $G   > (greater-than sign)',0Dh,0Ah
MSG_1566:
	db 44
	db '  $L   < (less-than sign)',0Dh,0Ah
	db '  $B   | (pipe)',0Dh,0Ah
MSG_1567:
	db 121
	db '  $H   Backspace (erases previous character)',0Dh,0Ah
	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
	db '  $_   Carriage return and linefeed',0Dh,0Ah
	db 0Dh,0Ah
MSG_1568:
	db 76
	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
MSG_1580:
	db 71
	db 'Removes (deletes) a directory.',0Dh,0Ah
	db 0Dh,0Ah
	db 'RMDIR [drive:]path',0Dh,0Ah
	db 'RD [drive:]path',0Dh,0Ah
MSG_1600:
	db 28
	db 'Renames a file or files.',0Dh,0Ah
	db 0Dh,0Ah
MSG_1601:
	db 83
	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
	db 0Dh,0Ah
MSG_1602:
	db 77
	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
MSG_1620:
	db 87
	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
	db 0Dh,0Ah
	db 'SET [variable=[string]]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1621:
	db 129
	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
	db 0Dh,0Ah
MSG_1622:
	db 75
	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
MSG_1640:
	db 52
	db 'Displays or sets the system time.',0Dh,0Ah
	db 0Dh,0Ah
	db 'TIME [time]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1641:
	db 131
	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
MSG_1660:
	db 70
	db 'Displays the contents of a text file.',0Dh,0Ah
	db 0Dh,0Ah
	db 'TYPE [drive:][path]filename',0Dh,0Ah
MSG_1680:
	db 37
	db 'Displays the MS-DOS version.',0Dh,0Ah
	db 0Dh,0Ah
	db 'VER',0Dh,0Ah
MSG_1700:
	db 177
	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
	db 'disk.',0Dh,0Ah
	db 0Dh,0Ah
	db 'VERIFY [ON | OFF]',0Dh,0Ah
	db 0Dh,0Ah
	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
MSG_1720:              
	db 82
	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
	db 0Dh,0Ah
	db 'VOL [drive:]',0Dh,0Ah
MSG_1740:
	db 91
	db 'Calls one batch program from another.',0Dh,0Ah
	db 0Dh,0Ah
	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1741:
	db 114
	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
	db '                     batch program.',0Dh,0Ah
MSG_1760:	
	db 76
	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
	db 0Dh,0Ah
	db 'REM [comment]',0Dh,0Ah
MSG_1780:
	db 107
	db 'Suspends processing of a batch program and displays the message "'
	db 'Press any',0Dh,0Ah
	db 'key to continue...."',0Dh,0Ah
	db 0Dh,0Ah
	db 'PAUSE',0Dh,0Ah
MSG_1800:
	db 77
	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
	db 0Dh,0Ah
	db '  ECHO [ON | OFF]',0Dh,0Ah
MSG_1801:
	db 87
	db '  ECHO [message]',0Dh,0Ah
	db 0Dh,0Ah
	db 'Type ECHO without parameters to display the current echo setting.'
	db 0Dh,0Ah
MSG_1820:
	db 71
	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
	db 0Dh,0Ah
	db 'GOTO label',0Dh,0Ah
	db 0Dh,0Ah
MSG_1821:
	db 138
	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
	db 0Dh,0Ah
	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
MSG_1840:
	db 74
	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
	db 0Dh,0Ah
	db 'SHIFT',0Dh,0Ah
MSG_1860:
	db 90
	db 'Performs conditional processing in batch programs.',0Dh,0Ah
	db 0Dh,0Ah
	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
MSG_1861:
	db 70
	db 'IF [NOT] string1==string2 command',0Dh,0Ah
	db 'IF [NOT] EXIST filename command',0Dh,0Ah
	db 0Dh,0Ah
MSG_1862:
	db 125
	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
	db '                    if the condition is false.',0Dh,0Ah
MSG_1863:
	db 162
	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
	db '                    '
	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
MSG_1864:
	db 102
	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
	db '                    met.',0Dh,0Ah
MSG_1865:
	db 106
	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
	db '                    match.',0Dh,0Ah
MSG_1866:
	db 103
	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
	db '                    exists.',0Dh,0Ah
MSG_1880:
	db 119
	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
	db 0Dh,0Ah
	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1881:
	db 125
	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
MSG_1882:
	db 86
	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
	db '  command-parameters',0Dh,0Ah
MSG_1883:
	db 162
	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
	db 0Dh,0Ah
	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
	db '%variable.',0Dh,0Ah
MSG_1900:
	db 23
	db 'Reserved command name',0Dh,0Ah
MSG_1920:
	db 47
	db 'Loads a program into the upper memory area.',0Dh,0Ah
	db 0Dh,0Ah
MSG_1921:
	db 88
	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
	db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
	db 0Dh,0Ah
MSG_1922:
	db 113
	db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
	db '               program you want to load.',0Dh,0Ah

; ---------------------------------------------------------------------------

	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h

; --------------- S U B R O U T I N E ---------------------------------------

$M_CLS_3:
	push	cs		; CLASS_F
	pop	es
	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
	; 15/04/2023
	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
	retn

	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh

; ---------------------------------------------------------------------------
; Class 1 messages
; ---------------------------------------------------------------------------
	
$M_CLASS_1_STRUC:
	db 1			; $M_CLASS_ID
	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
	db 4			; Class_1_MessageCount
$M_ID_1_1:
	dw 2			; Message Number = 2
	dw EXTEND2-$+2 ; 10h	; Message offset from message number
$M_ID_1_2:
	dw 3			; Message Number = 3
	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
$M_ID_1_3:
	dw 8			; Message Number = 8
	dw EXTEND8-$+2 ; 26h	; Message offset from message number
$M_ID_1_4:
	dw 0FFFFh		; Message Number = -1
	dw EXTEND999-$+2 ; 36h	; Message offset from message number

; ---------------------------------------------------------------------------

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
EXTEND2:
	db 14
	db 'File not found'
EXTEND3:
	db 14
	db 'Path not found'
EXTEND8:
	db 19
	db 'Insufficient memory'
EXTEND999:
	db 17
	db 'Extended Error %1'

	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h

; --------------- S U B R O U T I N E ---------------------------------------
$M_MSGSERV_1:
	push	cs
	pop	es
	lea	di,$M_CLASS_1_STRUC
	; 15/04/2023
	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
	retn

	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h

; ---------------------------------------------------------------------------
; Class 2 messages
; ---------------------------------------------------------------------------
	
$M_CLASS_2_STRUC:
	db 2			; $M_CLASS_ID
	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
	db 1			; Class_2_MessageCount
$M_ID_2_1:
	dw 0FFFFh		; Message Number = -1
	dw PARSE999-$+2 ; 4	; Message offset from message number
; ---------------------------------------------------------------------------

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
PARSE999:
	db 14
	db 'Parse Error %1'

	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h

; --------------- S U B R O U T I N E ---------------------------------------
$M_MSGSERV_2:
	push	cs
	pop	es
	lea	di,$M_CLASS_2_STRUC
	; 15/04/2023
	;add	cx,29	; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
	retn

;============================================================================
; TRANMSG.ASM, MSDOS 6.0, 1991
;============================================================================
; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h

;****************************************************
;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
;****************************************************

msg_disp_class:
	db	util_msg_class ; 0FFh
msg_cont_flag:
	db	no_cont_flag ; 0

;  extended error string output
extend_buf_ptr:
	dw	0			;AN000;set to no message
extend_buf_sub:
	db	0			;AN000;set to no substitutions
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
extend_buf_off:
	dw	string_ptr_2		;AN000;offset of arg
extend_buf_seg:
	dw	0			;AN000;segment of arg
	db	0			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	0			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Duplicate file name or file not found"
RENERR_PTR:
	dw	1002			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Invalid path or file name"
BADCPMES_PTR:
	dw	1003			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Insufficient disk space"
NOSPACE_PTR:
	dw	1004			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Out of environment space"
ENVERR_PTR:
	dw	1007			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "File creation error"
FULLDIR_PTR:
	dw	1008			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Batch file missing",13,10
BADBAT_PTR:
	dw	1009			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Insert disk with batch file",13,10
NEEDBAT_PTR:
	dw	1010			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Bad command or file name",13,10
BADNAM_PTR:
	dw	1011			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Access denied",13,10
ACCDEN_PTR:
	dw	1014			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "File cannot be copied onto itself",13,10
OVERWR_PTR:
	dw	1015			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Content of destination lost before copy",13,10
LOSTERR_PTR:
	dw	1016			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Invalid filename or file not found",13,10
INORNOT_PTR:
	dw	1017			;AN000;message number
	db	no_subst		;AN000;number of subst

;  "%1 File(s) copied",13,10
copied_ptr:
	dw	1018			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	Copy_num		;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0A1h ; Right_Align+Unsgn_Bin_Word
					;AN000;binary to decimal
	db	9			;AN000;maximum width
	db	9			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "%1 File(s) "
dirmes_ptr:
	dw	1019			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	Dir_Num			;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0A1h ; Right_Align+Unsgn_Bin_Word
					;AN000;binary to decimal
	db	9			;AN000;maximum width
	db	9			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "%1 bytes free",13,10
bytmes_ptr:
	dw	1020			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	Bytes_Free		;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0B1h ; Right_Align+Unsgn_Bin_DWord
					;AN000;long binary to decimal
	db	28			;AN000;maximum width
	db	28			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Invalid drive specification",13,10
baddrv_ptr:
	dw	1021			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Code page %1 not prepared for system",13,10
cp_not_set_ptr:
	dw	1022			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	system_cpage		;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0A1h ; Right_Align+Unsgn_Bin_Word
					;AN000;binary to decimal
	db	5			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Code page %1 not prepared for all devices",13,10
cp_not_all_ptr:
	dw	1023			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11 	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	system_cpage		;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0A1h ; Right_Align+Unsgn_Bin_Word
					;AN000;binary to decimal
	db	5			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Active code page: %1",13,10
cp_active_ptr:
	dw	1024			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	system_cpage		;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0A1h ; Right_Align+Unsgn_Bin_Word
					;AN000;binary to decimal
	db	5			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "NLSFUNC not installed",13,10
NLSFUNC_PTR:
	dw	1025			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Invalid code page",13,10
INV_CODE_PAGE:
	dw	1026			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Current drive is no longer valid"
BADCURDRV:
	dw	1027			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Press any key to continue"
PAUSEMES_PTR:
	dw	1028			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Label not found",13,10
BADLAB_PTR:
	dw	1029			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Syntax error",13,10
SYNTMES_PTR:
	dw	1030			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Invalid date",13,10
BADDAT_PTR:
	dw	1031			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Current date is %1 %2",13,10
CurDat_Ptr:
	dw	1032			;AN000;message number
	db	2			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	Arg_Buf			;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	3			;AN000;maximum width
	db	3			;AN000;minimum width
 	db	blank ; 20h		;AN000;pad character
	db	parm_block_size 	;AN000;size of sublist
	db	0			;AN000;reserved
CurDat_yr:
	dw	0			;AN000;year
CurDat_mo_day:
	dw	0			;AN000;month,day
	db	2			;AN000;second subst
	db	34h ; DATE_MDY_4	;AN000;date
	db	10			;AN000;maximum width
	db	10			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "SunMonTueWedThuFriSat"
WeekTab:
	dw	1033			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Enter new date (%1):"

NewDat_Ptr:
	dw	1034			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
NewDat_Format:
	dw	0			;AN000;offset of replacement
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	8			;AN000;maximum width
	db	8			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Invalid time",13,10

BadTim_Ptr:
	dw	1035			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Current time is %1",13,10
CurTim_Ptr:
	dw	1036			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size 	;AN000;size of sublist
	db	0			;AN000;reserved
CurTim_hr_min:
	dw	0			;AN000;hours,minutes
CurTim_Sec_hn:
	dw	0			;AN000;seconds,hundredths
	db	1			;AN000;first subst
	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
					;AC059;time
	db	12			;AC059;maximum width
	db	12			;AC059;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Enter new time:"
NewTim_Ptr:
	dw	1037			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  ",    Delete (Y/N)?",13,10
Del_Y_N_Ptr:
	dw	1038			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "All files in directory will be deleted!",13,10
;  "Are you sure (Y/N)?",13,10
SureMes_Ptr:
	dw	1039			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Microsoft DOS Version %1.%2",13,10
VerMes_Ptr:
	dw	1040			;AN000;message number
	db	2			;AN000;number of subst
	db	parm_block_size ; 11 	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	Major_Ver_Num		;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0A1h ; Right_Align+Unsgn_Bin_Word
					;AN000;binary to decimal
	db	1			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	Minor_Ver_Num	;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	2			;AN000;second subst
	db	0A1h ; Right_Align+Unsgn_Bin_Word
					;AN000;binary to decimal
	db	2			;AN000;maximum width
	db	2			;AN000;minimum width
	db	'0' ; 30h		;AN000;pad character

;  "Volume in drive %1 has no label",13,10
VolMes_Ptr_2:
	dw	1041			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11  	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	vol_drv			;AN000;offset of drive
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0 ; Char_field_Char 	;AN000;character
	db	128			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Volume in drive %1 is %2",13,10
VolMes_Ptr:
	dw	1042			;AN000;message number
	db	2			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	vol_drv			;AN000;offset of drive
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	00000000b		;AN000;character
	db	128			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	CHARBUF			;AN000;offset of string
	dw	0			;AN000;segment of arg
	db	2			;AN000;second subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Volume Serial Number is %1-%2",13,10
VolSerMes_Ptr:
	dw	1043			;AN000;message number
	db	2			;AN000;number of subst
	db	parm_block_size ; 11  	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	vol_serial+2		;AN000;offset of serial
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0A3h ; Right_Align+Bin_Hex_Word 
					;AN000;binary to hex
	db	4			;AN000;maximum width
	db	4			;AN000;minimum width
	db	'0' ; 30h		;AN000;pad character
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	vol_serial		;AN000;offset of serial
	dw	0			;AN000;segment of arg
	db	2			;AN000;second subst
	db	0A3h ; Right_Align+Bin_Hex_Word
					;AN000;binary to hex
	db	4			;AN000;maximum width
	db	4			;AN000;minimum width
	db	'0' ; 30h		;AN000;pad character

;  "Invalid directory",13,10
badcd_ptr:
	dw	1044			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Unable to create directory",13,10
badmkd_ptr:
	dw	1045			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Invalid path, not directory,",13,10
;  "or directory not empty",13,10
badrmd_ptr:
	dw	1046			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Must specify ON or OFF",13,10
bad_on_off_ptr:
	dw	1047			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Directory of %1",13,10
dirhead_ptr:
	dw	1048			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11 	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	BWDBUF			;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	0			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "No Path",13,10
NULLPATH_PTR:
	dw	1049			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Invalid drive in search path",13,10
BADPMES_PTR:
	dw	1050			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Invalid device",13,10
BADDEV_PTR:
	dw	1051			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "FOR cannot be nested",13,10
FORNESTMES_PTR:
	dw	1052			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Intermediate file error during pipe",13,10
PIPEEMES_PTR:
	dw	1053			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Cannot do binary reads from a device",13,10
INBDEV_PTR:
	dw	1054			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "BREAK is %1",13,10
CtrlcMes_Ptr:
	dw	1055			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	0			;AN000;offset of on/off (new)
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "VERIFY is %1",13,10
VeriMes_Ptr:
	dw	1056			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	0			;AN000;offset of on/off (new)
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "ECHO is %1",13,10
EchoMes_Ptr:
	dw	1057			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	0			;AN000;offset of on/off (new)
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	1			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "off"
OFFMES_PTR:
	dw	1059			;AN000;message number
	db	no_subst		;AN000;number of subst

;  "on"
ONMES_PTR:
	dw	1060			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Error writing to device",13,10
DEVWMES_PTR:
	dw	1061			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "Invalid path",13,10
INVAL_PATH_PTR:
	dw	1062			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  unformatted string output
arg_buf_ptr:
	dw	1063			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	Arg_Buf 		;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	0			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  file name output
file_name_ptr:
	dw	1064			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	SrcBuf			;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	0			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  file size output for dir
disp_file_size_ptr:
	dw	1065			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11 	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	File_Size_Low		;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	0B1h ; Right_Align+Unsgn_Bin_DWord
					;AN000;long binary to decimal
	db	10			;AN000;maximum width
	db	10			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  unformatted string output
; %s
string_buf_ptr:
	dw	1066			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size 	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	string_ptr_2		;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	0			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character
	db	0			;AN000;

;  tab character
tab_ptr:
	dw	1067			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  " <DIR>   "
dmes_ptr:
	dw	1068			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  destructive back space
dback_ptr:
	dw	1069			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  carriage return / line feed
acrlf_ptr:
	dw	1070			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "mm-dd-yy"
usadat_ptr:
	dw	1072			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "dd-mm-yy"
eurdat_ptr:
	dw	1073			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  "yy-mm-dd"
japdat_ptr:
	dw	1074			;AN000;message number
	db	no_subst ; 0		;AN000;number of subst

;  date string for prompt
promptdat_ptr:
	dw	1075			;AN000;message number
	db	2			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	Arg_Buf			;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ ;AN000;character string
	db	3			;AN000;maximum width
	db	3			;AN000;minimum width
 	db	blank ; 20h		;AN000;pad character
	db	parm_block_size  ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
promptDat_yr:
	dw	0			;AN000;year
promptDat_moday:
	dw	0			;AN000;month,day
	db	2			;AN000;second subst
 	db	34h ; DATE_MDY_4	;AN000;date
	db	10			;AN000;maximum width
	db	8			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  Time for prompt
promtim_ptr:
	dw	1076			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
PromTim_hr_min:
	dw	0			;AN000;hours,minutes
PromTim_Sec_hn:
	dw	0			;AN000;seconds,hundredths
	db	1			;AN000;first subst
	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
					;AC013;time
	db	11			;AN000;maximum width
	db	11			;AC013;minimum width
	db	blank ; 20h		;AN000;pad character

;  Date and time for DIR
dirdattim_ptr:
	dw	1077			;AN000;message number
	db	2			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
DirDat_Yr:
	dw	0			;AN000;year
DirDat_Mo_Day:
	dw	0			;AN000;month,day
	db	1			;AN000;first subst
	db	0A4h ; Right_Align+DATE_MDY_2
					;AN000;date
	db	10			;AN000;maximum width
	db	8			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
DirTim_Hr_Min:
	dw	0			;AN000;hours,minutes
DirTim_Sec_hn:
	dw	0			;AN000;seconds,hundredths
	db	2			;AN000;second subst
	db	85h ; Right_align+TIME_HHMM_Cty
					;AN000;time
	db	6			;AN000;maximum width
	db	6			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Directory already exists"
MD_EXISTS_PTR:
	dw	1078			;AN000;message number
	db	no_subst		;AN000;number of subst

;  "%1 bytes",13,10
bytes_ptr:
	dw	1079			; message number
	db	1			; number of subst
        db	parm_block_size ; 11	; size of sublist
        db	0			; reserved
        dw	FileSiz			; offset of arg
        dw	0			; segment of arg
        db	1			; first subst
        db	0B1h ; Right_Align+Unsgn_Bin_DWord
					; long binary to decimal
        db	10			; maximum width
        db	10			; minimum width
        db	blank ; 20h		; pad character

;  "Total:",13,10
total_ptr:
	dw	1080			; message number
	db	no_subst ; 0		; number of subst

;  "Error parsing environment variable:",13,10
errparsenv_ptr:
	dw	1081			; message number
	db	no_subst ; 0		; number of subst

;  "(continuing %1)",13,10
dircont_ptr:
	dw	1084			;AN000;message number
	db	1			;AN000;number of subst
	db	parm_block_size ; 11	;AN000;size of sublist
	db	0			;AN000;reserved
	dw	BWDBUF			;AN000;offset of arg
	dw	0			;AN000;segment of arg
	db	1			;AN000;first subst
	db	10h ; Char_field_ASCIIZ	;AN000;character string
	db	128			;AN000;maximum width
	db	0			;AN000;minimum width
	db	blank ; 20h		;AN000;pad character

;  "Revision %1",CR,LF
dosrev_ptr:
	dw	1090
	db	1			; one substitution
	db	parm_block_size ; 11
	db	0
	dw	One_Char_Val		; ptr to char
	dw	0			; segment addr?
	db	1			; 1st substitution
	db	0 ; CHAR_FIELD_CHAR	; character
	db	1			; max width
	db	1			; min width
	db	blank ; 20h		; pad char

;  "DOS is in ROM"
DosRom_Ptr:
	dw	1091
	db	no_subst ; 0		

;  "DOS is in HMA"
DosHma_Ptr:
	dw	1092
	db	no_subst ; 0		

;  "DOS is in low memory"
DosLow_Ptr:
	dw	1093
	db	no_subst ; 0		

;  "Cannot Loadhigh batch file" ;M016
NoExecBat_Ptr:
	dw	1094			; M016
	db	no_subst ; 0		; M016

;  "LoadHigh: Invalid filename" ; M016
LhInvFil_Ptr:
	dw	1095			; M016
	db	no_subst ; 0		; M016

;  "Could not open specified country information file" ; M045
NoCntry_Ptr:
	dw	1096			; M045
	db	no_subst ; 0		; M045

; 15/04/2023
; MSDOS 6.0 COMMAND.COM only !
%if 0

;* The next four errors emulate those reported by the normal parse
;  mechanism, with a little more accurate wording; that parser has been
;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
;  These errors aren't normally generated by LoadHigh except by the normal
;  parser, so they've been added here.

;  "LoadHigh: Invalid argument"
LhInvArg_Ptr:
	dw	1097
	db	no_subst ; 0		

;  "Required parameter missing"
ReqParmMiss:
	dw	1098
	db	no_subst ; 0		

;  "Unrecognized switch"
LhInvSwt_Ptr:
	dw	1099
	db	no_subst ; 0		

;  "A bad UMB number has been specified"
LhBadUMB_Ptr:
	dw	1100
	db	no_subst ; 0
%endif		

	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
; ---------------------------------------------------------------------------

PATH_TEXT:
	db	"PATH="
PROMPT_TEXT:
	db	"PROMPT="
COMSPECSTR:
	db	"COMSPEC="
DirEnvVar:
	db	"DIRCMD="		; DIR's environment variable

; 15/04/2023
%if 0

;============================================================================
; TDATA.ASM, MSDOS 6.0, 1991
;============================================================================
; 30/09/2018 - Retro DOS v3.0

; TITLE	COMMAND Transient Initialized DATA

;The TRANDATA segment contains data that is assumed to have predefined
;initial values at the beginning of each command cycle. It is
;included in the transient checksum area. If values in TRANDATA
;change, the transient will be reloaded for the next command cycle.

align 16
		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h

PRINTF_TABLE:	db '0123456789ABCDEF'
_3740h:		db '%S',0
ARG_BUF_PTR:	dw _3740h
		dw _3747h
_3747h:		dw ARG_BUF ; _43E8h
_3749h:		db '%S ',0
STRINGBUF1PTR:	dw _3749h
		dw STRING_PTR_1 ; _4468h
_3751h:		db '%9ld',0
FSIZEMESPTR:	dw _3751h
		dw FILESIZE_L ; _446Ah
		dw FILESIZE_H ; _446Ch
_375Ch:		db '%S',0
STRINGBUF2PTR:	dw _375Ch
		dw STRING_PTR_2 ; _446Eh
_3763h:		db 9,0
TABPTR:		dw _3763h
_3767h:		db 0Dh,0Ah
		db 'Batch file missing',0Dh,0Ah,0
BADPATHPTR:	dw _3767h
_3780h:		db 0Dh,0Ah
		db 'Insert disk with batch file',0Dh,0Ah
		db 'and press any key when ready',0Dh,0Ah,0
INSERTDSKPTR:	dw _3780h
_37C0h:		db 'Bad command or file name',0Dh,0Ah,0
BADNAMPTR:	dw _37C0h
_37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
RENERRPTR:	dw _37DDh
_3807h:		db 'File not found',0Dh,0Ah,0
FNOTFOUNDPTR:	dw _3807h
_381Ah:		db 'Path not found',0Dh,0Ah,0
PNOTFOUNDPTR:	dw _381Ah
_382Dh:		db 'Access denied',0Dh,0Ah,0
ACCDENPTR:	dw _382Dh
_383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
NOSPACEPTR:	dw _383Fh
_385Bh:		db 'Out of environment space',0Dh,0Ah,0
ENVERRPTR:	dw _385Bh
_3878h:		db 'File creation error',0Dh,0Ah,0
FULDIRPTR:	dw 3878h
_3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
OVERWRPTR:	dw _3890h
_38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
LOSTERRPTR:	dw _38B6h
_38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
INORNOTPTR:	dw _38E2h
_3909h:		db '%9d File(s) copied',0Dh,0Ah,0
COPIEDPTR:	dw _3909h
		dw COPY_NUM ; _4470h
_3922h:		db '%9d File(s) ',0
DIRMESPTR:	dw _3922h
		dw DIR_NUM  ; _4477h
_3933h:		db '%9ld bytes free',0Dh,0Ah,0
BYTEMESPTR:	dw _3933h
		dw BYTES_FREE   ; _4479h
		dw BYTES_FREE+2 ; _447Bh
_394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
BADDRVPTR:	dw _394Bh
_396Bh:		db 0Dh,0Ah
		db 'Code page %5d not prepared for system',0Dh,0Ah,0
CPNOTSETPTR:	dw _396Bh
		dw SYSTEM_CPAGE ; _3F2Fh
_3999h:		db 0Dh,0Ah
		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
CPNOTALLPTR:	dw _3999h
		dw SYSTEM_CPAGE ; _3F2Fh
_39CCh:		db 0Dh,0Ah
		db 'Active code page: %5d',0Dh,0Ah,0
CPACTIVEPTR:	dw _39CCh
		dw SYSTEM_CPAGE ; _3F2Fh
_39EAh:		db 'Current drive is no longer valid',0
BADCURDRVPTR:	dw _39EAh
_3A0Dh:		db 'Strike a key when ready . . . ',0
PAUSEMESPTR:	dw _3A0Dh
_3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
BADPARMPTR:	dw _3A2Eh
WEEKTAB:	db 'SunMonTueWedThuFriSat'
_3A59h:		db 0Dh,0Ah
		db 'Invalid date',0
BADDATPTR:	dw _3A59h
_3A6Ah:		db 'Current date is ',0
CURDATPTR:	dw _3A6Ah
_3A7Dh:		db 0Dh,0Ah
		db 'Enter new date ',0
NEWDATPTR:	dw _3A7Dh
_3A91h:		db '(mm-dd-yy): ',0
USADATPTR:	dw _3A91h
_3AA0h:		db '(dd-mm-yy): ',0
EURDATPTR:	dw _3AA0h
_3AAFh:		db '(yy-mm-dd): ',0
JAPDATPTR:	dw _3AAFh
_3ABEh:		db 0Dh,0Ah
		db 'Invalid time ',0
BADTIMPTR:	dw _3ABEh
_3AD0h:		db 'Current time is ',0
CURTIMPTR:	dw _3AD0h
_3AE3h:		db 0Dh,0Ah
		db 'Enter new time: ',0
NEWTIMPTR:	dw _3AE3h
_3AF8h:		db 'Are you sure (Y/N)?',0
SUREMESPTR:	dw _3AF8h
_3B0Eh:		db ' <DIR>   ',0
DMESPTR:	dw _3B0Eh
_3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
VERMESPTR:	dw _3B1Ah
		dw MAJOR_VER_NUM ; _447Dh
		dw MINOR_VER_NUM ; _447Fh
_3B4Dh:		db '%C',0
ONECHRVALPTR:	dw _3B4Dh
		dw ONE_CHAR_VAL	; _4481h
_3B54h:		db ' Volume in drive %c %s',0
VOLMESPTR:	dw _3B54h
		dw VOL_DRV ; _4484h
		dw VOLNAME_ADDR ; _4482h
IS:		db 'is ',0
NOVOL:		db 'has no label',0
_3B82h:		db 'Invalid directory',0Dh,0Ah,0
BADCDPTR:	dw _3B82h
_3B98h:		db 'Unable to create directory',0Dh,0Ah,0
BADMKDPTR:	dw _3B98h
_3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
		db 'or directory not empty',0Dh,0Ah,0
BADRMDPTR:	dw _3BB7h
_3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
BADONOFFPTR:	dw _3BF0h
_3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
DIRHEADPTR:	dw _3C0Bh
		dw VOL_DIR ; _4485h
_3C23h:		db 'No Path',0
NULLPATHPTR:	dw _3C23h
PATH_TEXT:	db 'PATH='
PROMPT_TEXT:	db 'PROMPT='
COMSPEC_TEXT:	db 'COMSPEC='
_3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
BADPMESPTR:	dw _3C41h
_3C62h:		db 'Invalid device',0Dh,0Ah,0
BADDEVPTR:	dw _3C62h
_3C75h:		db 'Label not found',0Dh,0Ah,0
BADLABPTR:	dw _3C75h
_3C89h:		db 'Syntax error',0Dh,0Ah,0
SYNTMESPTR:	dw _3C89h
_3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
FORNESTMESTR:	dw _3C9Ah
_3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
INSFMEMMESPTR:	dw _3CB4h
_3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
PIPEEMESPTR:	dw _3CCCh
_3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
INBDEVPTR:	dw _3CF4h
_3D1Dh:		db 'BREAK is ',0
CTRLMESPTR:	dw _3D1Dh
_3D29h:		db 'VERIFY is ',0
VERIMESPTR:	dw _3D29h
_3D36h:		db 'ECHO is ',0
ECHOMESPTR:	dw _3D36h
_3D41h:		db 'off',0Dh,0Ah,0
OFFMESPTR:	dw _3D41h
_3D49h:		db 'on',0Dh,0Ah,0
ONMESPTR:	dw _3D49h
_3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
BADCPMESPTR:	dw _3D50h
_3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
BADARGSPTR:	dw _3D6Eh
_3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
DEVWMESPTR:	dw _3D8Fh
_3DABh:		db 0Dh,0Ah,0
ACRLFPTR:	dw _3DABh
_3DB0h:		db 8
		db 20h
		db 8
		db 0
DBACKPTR:	dw _3DB0h
small_y:	db 'y'
small_n:	db 'n'
CAPITAL_Y:	db 'Y'
CAPITAL_N:	db 'N'
CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
PROMPT_TABLE:
		db 'B' ; 42h
		dw PRINT_B
		db 'D' ; 44h
		dw PRINT_DATE
		db 'E' ; 45h
		dw PRINT_ESC
		db 'G' ; 47h
		dw PRINT_G
		db 'H' ; 48h
		dw PRINT_BACK
		db 'L' ; 4Ch
		dw PRINT_L
		db 'N' ; 4Eh
		dw PRINT_DRIVE
		db 'P' ; 50h
		dw BUILD_DIR_FOR_PROMPT
		db 'Q' ; 51h
		dw PRINT_EQ
		db 'T' ; 54h
		dw PRINT_TIME
		db 'V' ; 56h
		dw PRINT_VERSION
		db '_' ; 5Fh
		dw CRLF2
		db '$' ; 24h
		dw PRINT_CHAR
		db 0

		; Table of IF conditionals
IFTAB:
		db 3	; First byte is count
		db 'NOT'
		dw IFNOT
		db 10
		db 'ERRORLEVEL'
		dw IFERLEV
		db 5
		db 'EXIST'
		dw IFEXISTS
		db 0

		; Table for internal command names

COMTAB:		db 3
		db 'DIR'
		db 3
		dw CATALOG
		db 4
		db 'CALL'
		db 2
		dw _$CALL
		db 4
		db 'CHCP'
		db 2
		dw CHCP
		db 6
		db 'RENAME'
		db 1
		dw CRENAME
		db 3
		db 'REN'
		db 1
		dw CRENAME
		db 5
		db 'ERASE'
		db 1
		dw ERASE
		db 3
		db 'DEL'
		db 1
		dw ERASE
		db 4
		db 'TYPE'
		db 1
		dw TYPEFIL
		db 3
		db 'REM'
		db 2
		dw TCOMMAND
		db 4
		db 'COPY'
		db 3
		dw COPY
		db 5
		db 'PAUSE'
		db 2
		dw PAUSE
		db 4
		db 'DATE'
		db 2
		dw DATE
		db 4
		db 'TIME'
		db 0
		dw CTIME
		db 3
		db 'VER'
		db 0
		dw VERSION
		db 3
		db 'VOL'
		db 1
		dw VOLUME
		db 2
		db 'CD'
		db 1
		dw _$CHDIR
		db 5
		db 'CHDIR'
		db 1
		dw _$CHDIR
		db 2
		db 'MD'
		db 1
		dw _$MKDIR
		db 5
		db 'MKDIR'
		db 1
		dw _$MKDIR
		db 2
		db 'RD'
		db 1
		dw _$RMDIR
		db 5
		db 'RMDIR'
		db 1
		dw _$RMDIR
		db 5
		db 'BREAK'
		db 0
		dw CNTRLC
		db 6
		db 'VERIFY'
		db 0
		dw VERIFY
		db 3
		db 'SET'
		db 2
		dw ADD_NAME_TO_ENVIRONMENT
		db 6
		db 'PROMPT'
		db 2
		dw ADD_PROMPT
		db 4
		db 'PATH'
		db 2
		dw PATH
		db 4
		db 'EXIT'
		db 0
		dw _$EXIT
		db 4
		db 'CTTY'
		db 3
		dw CTTY
		db 4
		db 'ECHO'
		db 2
		dw _ECHO
		db 4
		db 'GOTO'
		db 2
		dw _GOTO
		db 5
		db 'SHIFT'
		db 2
		dw _SHIFT
		db 2
		db 'IF'
		db 2
		dw _$IF
		db 3
		db 'FOR'
		db 2
		dw _$FOR
		db 3
		db 'CLS'
		db 0
		dw CLS
		db 0

CAPITAL_A:	db 'A'
VBAR:		db '|'
LABRACKET:	db '<' ; 3Ch
RABRACKET:	db '>' ; 3Eh
DOLLAR:		db '$'
LPAREN:		db '('
RPAREN:		db ')'
NULLRPAREN:	db ')' ; 29h
		db 0
IN_WORD:	db 'I','N'
DO_WORD	:	db 'D','O'
STAR:		db '*'
CHAR_SUB:	db '-' 
PLUS_CHR:	db '+'
CHAR_L:		db 'L'
char_l:		db 'l'
small_a:	db 'a'
small_z:	db 'z'
CHAR_D:		db 'D'
CHAR_C:		db 'C'
CHAR_S:		db 'S'
CHAR_X:		db 'X'
DOT_CHR:	db '.' 
DOT_QMARK:	dw '?.'  ; dw 2E3Fh
		db ','
TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
MNCHR:		db 'p'
SYSTEM_CPAGE:	db 0
		db 0

COMEXT:		db '.COM'
EXEEXT:		db '.EXE'
BATEXT:		db '.BAT'
SWITCH_LIST:	db 'VBAPW'
BATBUFLEN:	dw BATLEN ; 32

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h

TRANDATAEND:

%endif

;============================================================================
; TDATA.ASM, MSDOS 6.0, 1991
;============================================================================
; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; 15/04/2023
	db	0
align 2

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
; ---------------------------------------------------------------------------
	db 0
; Lists of help message numbers for internal commands and /?

;;NoHelpMsgs:
	dw	1200,0		;M014
BreakHelpMsgs:
	dw	1300,0
ChcpHelpMsgs:
	dw	1320,1321,0
CdHelpMsgs:
	dw	1340,1341,1342,0
ClsHelpMsgs:
	dw	1360,0
CopyHelpMsgs:
	dw	1400,1401,1402,1403,1404,0
CttyHelpMsgs:
	dw	1420,0
DateHelpMsgs:
	dw	1440,1441,0
DelHelpMsgs:
	dw	1460,1461,1462,0
DirHelpMsgs:
	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
	; MSDOS 6.0 COMMAND.COM
	;dw	1489,1490,1491,1492
	dw	0
ExitHelpMsgs:
	dw	1500,0
MdHelpMsgs:
	dw	1520,0
PathHelpMsgs:
	dw	1540,1541,1542,0
PromptHelpMsgs:
	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
RdHelpMsgs:
	dw	1580,0
RenHelpMsgs:
	dw	1600,1601,1602,0
SetHelpMsgs:
	dw	1620,1621,1622,0
TimeHelpMsgs:
	dw	1640,1641,0
TypeHelpMsgs:
	dw	1660,0
VerHelpMsgs:
	dw	1680,0
VerifyHelpMsgs:
	dw	1700,0
VolHelpMsgs:
	dw	1720,0
CallHelpMsgs:
	dw	1740,1741,0	;M014
RemHelpMsgs:
	dw	1760,0		;M014
PauseHelpMsgs:
	dw	1780,0		;M014
EchoHelpMsgs:
	dw	1800,1801,0	;M014
GotoHelpMsgs:
	dw	1820,1821,0	;M014
ShiftHelpMsgs:
	dw	1840,0		;M014
IfHelpMsgs:
	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
ForHelpMsgs:
	dw	1880,1881,1882,1883,0 ;M014
TruenameHelpMsgs:
	 dw	1900,0		;M014
LoadhighHelpMsgs:
	dw	1920,1921,1922
	; MSDOS 6.0 COMMAND.COM
	;dw	1923,1924,1925,1926,1927 ;M014
	dw	0

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
CLSSTRING:
	db	4,01Bh,"[2J"		; ANSI Clear screen

PROMPT_TABLE:
	db	"B"
	dw	Print_B
	db	"D"
	dw	PRINT_DATE
	db	"E"
	dw	PRINT_ESC
	db	"G"
	dw	PRINT_G
	db	"H"
	dw	PRINT_BACK
	db	"L"
	dw	PRINT_L
	db	"N"
	dw	PRINT_DRIVE
	db	"P"
	dw	build_dir_for_prompt
	db	"Q"
	dw	PRINT_EQ
	db	"T"
	dw	PRINT_TIME
	db	"V"
	dw	PRINT_VERSION
	db	"_"
	dw	CRLF2
	db	"$"
	dw	PRINT_CHAR
	db	0			; NUL TERMINATED

; Table of IF conditionals
IFTAB:
	db	3,"NOT"			; First byte is count
	dw	IFNOT
	db	10,"ERRORLEVEL"
	dw	IFERLEV
	db	5,"EXIST"
	dw	IFEXISTS
	db	0

; Table for internal command names
COMTAB:
	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
	dw	CATALOG			; In TCMD1.ASM
	dw	DirHelpMsgs

	db	4,"CALL",fSwitchAllowed	; 2
	dw	_$CALL			; In TBATCH2.ASM
	dw	CallHelpMsgs

	db	4,"CHCP",fSwitchAllowed ; 2
	dw	CHCP			; In TCMD2B.ASM
	dw	ChcpHelpMsgs

	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
	dw	CRENAME			; In TCMD1.ASM
	dw	RenHelpMsgs

	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
	dw	CRENAME			; In TCMD1.ASM
	dw	RenHelpMsgs
	
	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
	dw	ERASE			; In TCMD1.ASM
	dw	DelHelpMsgs
	
	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
	dw	ERASE			; In TCMD1.ASM
	dw	DelHelpMsgs
	
	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
	dw	TYPEFIL			; In TCMD1.ASM
	dw	TypeHelpMsgs
	
	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
	dw	TCOMMAND		; In TCODE.ASM
	dw	RemHelpMsgs
	
	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
	dw	COPY			; In COPY.ASM
	dw	CopyHelpMsgs
	
	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
	dw	PAUSE			; In TCMD1.ASM
	dw	PauseHelpMsgs
	
	db	4,"DATE",fSwitchAllowed	; 2
	dw	DATE			; In TPIPE.ASM
	dw	DateHelpMsgs
	
	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
	dw	CTIME			; In TPIPE.ASM
	dw	TimeHelpMsgs
	
	db	3,"VER",fSwitchAllowed ; 2
	dw	VERSION			; In TCMD2.ASM
	dw	VerHelpMsgs
	
	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
	dw	VOLUME			; In TCMD1.ASM
	dw	VolHelpMsgs
	
	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
	dw	_$CHDIR			; In TENV.ASM
	dw	CdHelpMsgs
	
	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
	dw	_$CHDIR			; In TENV.ASM
	dw	CdHelpMsgs
	
	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
	dw	_$MKDIR			; In TENV.ASM
	dw	MdHelpMsgs
	
	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
	dw	_$MKDIR			; In TENV.ASM
	dw	MdHelpMsgs
	
	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
	dw	_$RMDIR			; In TENV.ASM
	dw	RdHelpMsgs
	
	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
	dw	_$RMDIR			; In TENV.ASM
	dw	RdHelpMsgs
	
	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
	dw	CNTRLC			; In TUCODE.ASM
	dw	BreakHelpMsgs
	
	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
	dw	VERIFY			; In TUCODE.ASM
	dw	VerifyHelpMsgs
	
	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
	dw	SetHelpMsgs
	
	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
	dw	ADD_PROMPT		; In TENV.ASM
	dw	PromptHelpMsgs
	
	db	4,"PATH",fSwitchAllowed ; 2
	dw	PATH			; In TCMD2.ASM
	dw	PathHelpMsgs
	
	db	4,"EXIT",0
	dw	_$EXIT			; In TCMD2.ASM
	dw	ExitHelpMsgs
	
	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
	dw	CTTY			; In TCMD2.ASM
	dw	CttyHelpMsgs
	
	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
	dw	_ECHO			; In TUCODE.ASM
	dw	EchoHelpMsgs
	
	db	4,"GOTO",fSwitchAllowed+fLimitHelp
	dw	_GOTO			; In TBATCH.ASM
	dw	GotoHelpMsgs
	
	db	5,"SHIFT",fSwitchAllowed ; 2
	dw	_SHIFT			; In TBATCH.ASM
	dw	ShiftHelpMsgs
	
	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
	dw	_$IF			; In TBATCH.ASM
	dw	IfHelpMsgs
	
	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
	dw	_$FOR			; In TBATCH.ASM
	dw	ForHelpMsgs
	
	db	3,"CLS",0
	dw	CLS			; In TCMD2.ASM
	dw	ClsHelpMsgs
	
	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
	dw	TRUENAME		;AN000;
	dw	TruenameHelpMsgs
	
	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
	dw	LoadHigh		; In loadhi.asm ; M003
	dw	LoadhighHelpMsgs	; M003
	
	db	2,"LH",fSwitchAllowed ; 2	; Short form; M003
	dw	LoadHigh		; In loadhi.asm ; M003
	dw	LoadhighHelpMsgs	; M003
	
	db	0			; Terminate command table

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h

comext:	db	".COM"
exeext:	db	".EXE"
batext:	db	".BAT"

switch_list:
	db	"?VBAPW"		; flags we can recognize

AttrLtrs:
	db	"RHSvDA"		; attribute letters for DIR

;	Attribute letters in AttrLtrs must appear in the order that
;	attribute bits occur in the attribute byte returned by
;	directory searches, starting with bit 0.
;	The volume label attribute is lowercased to keep it from
;	being matched (by an uppercase comparison).

OrderLtrs:
	db	"NEDSG"			; sort order letters for DIR
	; MSDOS 6.0 COMMAND.COM
	;db	"NEDSGC"		; sort order letters for DIR

;	Sort order letters stand for file name, extension,
;	date/time, size, grouped (directory files before others),
;	and compression ratio. DIR routines rely on the specific
;	order of the letters in this list.

comspec_flag:
	db	0                       ;AN071;

BATBUFLEN:
	dw	BatLen ; 32

; *****************************************************
; EMG 4.00
; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
; *****************************************************

; COMMON PARSE BLOCKS

; Indicates no value list for PARSE.

NO_VALUES:
	dw	0			;AN000;  no values

NULL_VALUE_LIST:  ; for unvalidated value
 	db	0                       ; no value lists

	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h

; PARSE control block for a required file specification (upper cased)

FILE_REQUIRED:
	dw	0200h			;AN000;  filespec - required
	dw	1			;AN000;  capitalize - file table
	dw	PARSE1_OUTPUT		;AN000;  result buffer
	dw	NO_VALUES		;AN000;
	db	0			;AN000;  no keywords

; PARSE control block for an optional file specification (upper cased)
; or drive number

FILE_OPTIONAL:
	dw	0301h			;AN000;  filespec or drive number
					;	 optional
	dw	1			;AN000;  capitalize - file table
	dw	PARSE1_OUTPUT		;AN000;  result buffer
	dw	NO_VALUES		;AN000;
	db	0			;AN000;  no keywords

; PARSE control block for an optional file specification (upper cased)

FILE_OPTIONAL2:
	dw	0201h                   ;AN000;  filespec optional
	dw	1                       ;AN000;  capitalize - file table
	dw	PARSE1_OUTPUT		;AN000;  result buffer
	dw	NO_VALUES		;AN000;
	db	0			;AN000;  no keywords

; PARSE control block for an optional /P switch

SLASH_P_SWITCH:
	dw	0			;AN000;  no match flags
	dw	2			;AN000;  capitalize - char table
	dw	PARSE1_OUTPUT		;AN000;  result buffer
	dw	NO_VALUES		;AN000;
	db	1			;AN000;  1 keyword
SLASH_P_SYN:
	db	"/P",0                  ;AN000;  /P switch

; PARSE BLOCK FOR BREAK, VERIFY, ECHO

; The following parse control block can be used for any command which
; needs only the optional "ON" and "OFF" keywords as operands. Allows
; the equal sign as an additional delimiter. Returns verified result
; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
; internal commands.

PARSE_BREAK:
	dw	BREAK_PARMS		;AN000;
	db	0			;AN032; no extra delimiter

BREAK_PARMS:
	db	0,1			;AN000;  1 positional parm
	dw	BREAK_CONTROL1		;AN000;
	db	0			;AN000;  no switches
	db	0			;AN000;  no keywords

BREAK_CONTROL1:
	dw	2001h			;AN000;  string value - optional
	dw	2			;AN000;  capitalize - char table
	dw	PARSE1_OUTPUT		;AN000;  result buffer
	dw	BREAK_VALUES		;AN000;
	db	0			;AN000;  no keywords

BREAK_VALUES:
	db	3			;AN000;
	db	0			;AN000;  no ranges
	db	0			;AN000;  no numeric values
	db	2			;AN000;  2 string values
	db	0			;AN000;  returned if ON
	dw	BREAK_ON		;AN000;  point to ON string
	db	'f'                     ;AN000;  returned if OFF
	dw	BREAK_OFF		;AN000;  point to OFF string

BREAK_ON:
	db	"ON",0                  ;AN000;
BREAK_OFF:
	db	"OFF",0                 ;AN000;

	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h

; PARSE BLOCK FOR CHCP

; The following parse control block can be used for any command which
; needs only one optional three digit decimal parameter for operands.
; Returns verified result in PARSE1_OUTPUT. Currently used for the
; CHCP internal command.

CHCP_MINVAL	EQU	100			;AN000;
CHCP_MAXVAL	EQU	999			;AN000;

PARSE_CHCP:
	dw	CHCP_PARMS			;AN000;
	db	0				;AN000;  no extra delimiter
CHCP_PARMS:
	db	0,1				;AN000;  1 positional parm
	dw	CHCP_CONTROL1			;AN000;
	db	0				;AN000;  no switches
	db	0				;AN000;  no keywords

CHCP_CONTROL1:
	dw	8001h				;AN000;  numeric value - optional
	dw	0				;AN000;  no function flags
	dw	PARSE1_OUTPUT			;AN000;  result buffer
	dw	CHCP_VALUES			;AN000;
	db	0				;AN000;  no keywords

CHCP_VALUES:
	db	1				;AN000;
	db	1				;AN000;  1 range
	db	1				;AN000;  returned if result
	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
	db	0				;AN000;  no numeric values
	db	0				;AN000;  no string values

; PARSE BLOCK FOR DATE

; The following parse control block can be used for any command which
; needs only an optional date string as an operand. Returns unverified
; result in DATE_OUTPUT. Currently used for the DATE internal command.

PARSE_DATE:
	dw	DATE_PARMS			;AN000;
	db	0				;AN000;  no extra delimiter
DATE_PARMS:
	db	0,1				;AN000;  1 positional parm
	dw	DATE_CONTROL1			;AN000;
	db	0				;AN000;  no switches
	db	0				;AN000;  no keywords

DATE_CONTROL1:
	dw	1001h				;AN000;  date - optional
	dw	0				;AN000;  no function flags
	dw	DATE_OUTPUT			;AN000;  result buffer
	dw	NO_VALUES			;AN000;
	db	0				;AN000;  no keywords

; PARSE BLOCK FOR TIME

; The following parse control block can be used for any command which
; needs only an optional time string as an operand. Returns unverified
; result in TIME_OUTPUT. Currently used for the TIME internal command.

PARSE_TIME:
	dw	TIME_PARMS			;AN000;
	db	0				;AN000;  no extra delimiter
TIME_PARMS:
	db	0,1				;AN000;  1 positional parm
	dw	TIME_CONTROL1			;AN000;
	db	0				;AN000;  no switches
	db	0				;AN000;  no keywords

TIME_CONTROL1:
	dw	0801h				;AN000;  TIME - optional
	dw	0				;AN000;  no function flags
	dw	TIME_OUTPUT			;AN000;  result buffer
	dw	NO_VALUES			;AN000;
	db	0				;AN000;  no keywords

; PARSE BLOCK FOR VOL

; The following parse control block can be used for any command which
; needs only an optional drive letter as an operand.  Returns unverified
; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
; internal command.

PARSE_VOL:
	dw	VOL_PARMS			;AN000;
	db	0				;AN000;  no extra delimiter
VOL_PARMS:
	db	0,1				;AN000;  1 positional parm
	dw	DRIVE_CONTROL1			;AN000;
	db	0				;AN000;  no switches
	db	0				;AN000;  no keywords

DRIVE_CONTROL1:
	dw	0101h				;AN000;  DRIVE - optional
	dw	1				;AN000;  capitalize - file table
	dw	DRIVE_OUTPUT			;AN000;  result buffer
	dw	NO_VALUES			;AN000;
	db	0				;AN000;  no keywords

; PARSE BLOCK FOR MKDIR, RMDIR, TYPE

; The following parse control block can be used for any command which
; needs only one required file specification as an operand. Returns a
; pointer to the unverified string in PARSE1_OUTPUT. Currently used
; for the MKDIR, RMDIR, and TYPE internal commands.

PARSE_MRDIR:
	dw	MRDIR_PARMS			;AN000;
	db	0				;AN000;  no extra delimiter
MRDIR_PARMS:
	db	1,1				;AN000;  1 positional parm
	dw	FILE_REQUIRED			;AN000;
	db	0				;AN000;  no switches
	db	0				;AN000;  no keywords

; PARSE BLOCK FOR CHDIR, TRUENAME

; The following parse control block can be used for any command which
; needs only one optional file specification an operand. Returns a
; pointer to the unverified string in PARSE1_OUTPUT. Currently used
; for the CHDIR and TRUENAME internal commands.

PARSE_CHDIR:
	dw	CHDIR_PARMS			;AN000;
	db	0				;AN000;  no extra delimiter
CHDIR_PARMS:
	db	0,1				;AN000;  1 positional parm
	dw	FILE_OPTIONAL			;AN000;
	db	0				;AN000;  no switches
	db	0				;AN000;  no keywords

; PARSE BLOCK FOR ERASE

; The following parse control block is used for the DEL/ERASE internal
; commands. This command has one required file specification and an
; optional switch (/p) as operands. The verified switch or unverified
; file specification is returned in PARSE1_OUTPUT.

PARSE_ERASE:
	dw	ERASE_PARMS			;AN000;
	db	0				;AN000;  no extra delimiter

ERASE_PARMS:
	db	1,1				;AN000;  1 positional parm
	dw	FILE_REQUIRED			;AN000;
	db	1				;AN000;  1 switch
	dw	SLASH_P_SWITCH			;AN000;
	db	0				;AN000;  no keywords

; PARSE BLOCK FOR DIR

; The following parse control block is used for the DIR internal command.
; This command has one optional file specification and several optional
; switches. Switches, switch values, and the filespec are returned in 
; PARSE1_OUTPUT.
;
; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
; do not require colons, and are not checked against a value list.
;
; Switch /h has been removed from the DIR command	;M008
; Switch /? is no longer handled internally		;M008
;
; A list of pointers to all the switch synonyms is provided here to
; help identify which switch has been matched.

	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h

PARSE_DIR:
	dw	DIR_PARMS
	db	0			; no extra delimiters
DIR_PARMS:
	db	0,1			; 1 optional positional param
	dw	FILE_OPTIONAL2
	db	2			; 2 kinds of switches
	dw	DIR_SW_VALUED
	dw	DIR_SW_UNVALUED
	db	0			; no keywords

DIR_SW_VALUED:
	dw	2001h			; optional string value
	dw	21h			; optional colon; capitalize 
	dw	PARSE1_OUTPUT		; result buffer
	dw	NULL_VALUE_LIST		; don't validate value

	db	2

; MSDOS 6.0 COMMAND.COM
;ifdef DBLSPACE_HOOKS
;	db	3		; 3 'synonyms'
;else
;	db	2		; 2 'synonyms'
;endif

DIR_SW_A:
	db	"/A",0
DIR_SW_O:
	db	"/O",0

; MSDOS 6.0 COMMAND.COM
;ifdef DBLSPACE_HOOKS
;DIR_SW_C	db	"/C",0
;endif

DIR_SW_UNVALUED:
	dw	0			; no value
	dw	0			; no format functions
	dw	PARSE1_OUTPUT		; result buffer
	dw	NO_VALUES

	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
	;db	12
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
	db	14		; 14 'synonyms' !?

; MSDOS 6.0 COMMAND.COM
;ifdef DBLSPACE_HOOKS
;	db	13		; 13 'synonyms'
;else
;	db	12		; 12 'synonyms'
;endif

DIR_SW_NEG_A:
	db	"/-A",0
DIR_SW_NEG_O:
	db	"/-O",0
DIR_SW_S:
	db	"/S",0
DIR_SW_NEG_S:
	db	"/-S",0
DIR_SW_B:
	db	"/B",0
DIR_SW_NEG_B:
	db	"/-B",0
DIR_SW_W:
	db	"/W",0
DIR_SW_NEG_W:
	db	"/-W",0
DIR_SW_P:
	db	"/P",0
DIR_SW_NEG_P:
	db	"/-P",0
DIR_SW_L:
	db	"/L",0		;M010
DIR_SW_NEG_L:
	db	"/-L",0 	;M010
; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
;DIR_SW_NEG_C:
;	db	"/-C",0

; Here's a list of pointers to DIR's switch synonyms, for easier
; identification. Order is critical - DIR routines rely on the
; specific order in this list. Negated options appear at odd 
; positions in the list, and simple on/off options appear first.

Dir_Sw_Ptrs:
	; MSDOS 5.0 COMMAND.COM
	dw	DIR_SW_NEG_W 
Dir_Sw_Ptrs_2:			; list of ptrs to switch synonyms
	; MSDOS 6.0 COMMAND.COM
	;dw	DIR_SW_NEG_C
	;dw	DIR_SW_C
	;dw	DIR_SW_NEG_W
	
	dw	DIR_SW_W
	dw	DIR_SW_NEG_P
	dw	DIR_SW_P
	dw	DIR_SW_NEG_S
	dw	DIR_SW_S
	dw	DIR_SW_NEG_B
	dw	DIR_SW_B
	dw	DIR_SW_NEG_L	;M010
	dw	DIR_SW_L	;M010
	dw	DIR_SW_NEG_O
	dw	DIR_SW_O
	dw	DIR_SW_NEG_A
	dw	DIR_SW_A

; PARSE BLOCK FOR RENAME

; The following parse control block can be used for any command which
; needs only two required file specifications as operands. Returns
; pointers to the unverified string in PARSE1_OUTPUT.
; Currently used for the RENAME internal command.

PARSE_RENAME:
	dw	RENAME_PARMS		;AN000;
	db	0			;AN000;  no extra delimiter
RENAME_PARMS:
	db	2,2			;AN000;  2 positional parms
	dw	FILE_REQUIRED		;AN000;
	dw	FILE_REQUIRED		;AN000;
	db	0			;AN000;  no switches
	db	0			;AN000;  no keywords

; PARSE BLOCK FOR CTTY

; The following parse control block can be used for any command which
; needs one required device name as an operand. Returns a pointer to
; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
; internal command.

PARSE_CTTY:
	dw	CTTY_PARMS		;AN000;
	db	0			;AN000;  no extra delimiter
CTTY_PARMS:
	db	1,1			;AN000;  1 positional parm
	dw	CTTY_CONTROL1		;AN000;
	db	0			;AN000;  no switches
	db	0			;AN000;  no keywords
CTTY_CONTROL1:
	dw	2000h			;AN000;  string value - required
	dw	11h			;AN000;  capitalize - file table
					;AN000;  remove colon at end
	dw	PARSE1_OUTPUT		;AN000;  result buffer
	dw	NO_VALUES		;AN000;
	db	0			;AN000;  no keywords

; PARSE BLOCK FOR VER

; The following parse control block can be used for any command which
; needs an optional switch "/debug". Currently used for the VER command.

PARSE_VER:
	dw	VER_PARMS
	db	0			; no extra delimiters
VER_PARMS:
	db	0,0			; no positional parameters
	db	1			; one switch
	dw	SLASH_R
	db	0			; no keywords
SLASH_R:
	dw	0			; no values
	dw	2			; capitalize by filename table
	dw	PARSE1_OUTPUT		; result buffer
	dw	NO_VALUES		; no values
	db	1			; one synonym
SLASH_R_SYN:
	db	"/R",0

; M003 ; Start of changes for LoadHigh support

;Parse Control Block for LOADHIGH command

Parse_LoadHi:
	dw	LoadHi_Parms		;extended parm table
	db	0			;no extra delimiters

LoadHi_Parms:
	db	1,1			;min. 1 parm, max. 1 parm
	dw	FILE_REQUIRED		;control struc for filename
	db	0			;no switches
	db	0			;no keywords

; M003 ; End of changes for LoadHigh support

TempVarName:
	db	"TEMP=",0

	; 16/04/2023
TRANDATAEND:		; TRANGROUP:88C2h

;============================================================================
; PSDATA.INC, MSDOS 6.0, 1991
;============================================================================
; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

; 18/04/2023
TRANSPACESTART:

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h

;********************** Local Data *************************************

$P_ORDINAL:
	dw	0		;AN000; Operand ordinal save area
$P_RC:
	dw	0		;AN000; Return code from parser
$P_SI_Save:
	dw	0		;AN000; Pointer of command buffer
$P_DX:
	dw	0		;AN000; Return result buffer address
$P_Terminator:
	db	0		;AN000; Terminator code (ASCII)
$P_DBCSEV_OFF:
	dw	0		;AN000; Offset of DBCS EV
$P_DBCSEV_SEG:
	dw	0		;AN000; Segment of DBCS EV
$P_Flags:			;AN000; Parser internal flags
$P_Flags1:
	db	0		;AN038; to reference first byte flags
$P_Flags2:
	db	0		;AN038; to reference second byte flags only
$P_SaveSI_Cmpx:
	dw	0		;AN000; save si for later use by complex
$P_KEYorSW_Ptr:
	dw	0		;AN000; points next to "=" or ":" code
$P_Save_EOB:
	dw	0		;AN000; save pointer to EOB
$P_Found_SYNONYM:
	dw	0		;AN000; es:@ points to found synonym
$P_STRING_BUF:
	times  128 db 0		;AN000; Pick a operand from command line
$P_ORIG_ORD:
	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
$P_ORIG_STACK:
	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
$P_ORIG_SI:
	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
$P_Got_Time:
	db	0		;AN023; if 1, use Time delimiters
$P_Country_Info:
	dw	-1 ; 0FFFFh
	times	32 db 0	
$P_1st_Val:
	dw	0		;AN000; used when process date or time
$P_2nd_Val:
	dw	0		;AN000; used when process date or time
$P_3rd_Val:
	dw	0		;AN000; used when process date or time
$P_4th_Val:
	dw	0		;AN000; used when process date or time
$P_Char_CAP_Ptr:
	db	0FFh		;AN000; info id
	dw	0		;AN000; offset	of char case map table
	dw	0		;AN000; segment of char case map table
$P_File_CAP_Ptr:
	db	0FFh		;AN000; info id
	dw	0		;AN000; offset	of file case map table
	dw	0		;AN000; segment of file case map table

	; 18/04/2023
;M029
;!!!WARNING!!!
; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
;hardcoded strings. If the chars in the string are changed here, corresponding
;changes need to be made in SYSPARSE

$P_FileSp_Char:
	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
$P_FileSp_Len equ $-$P_FileSp_Char ;AN000;

;filespec error flag
$P_err_flag:
	db	0		;AN033; flag set if filespec parsing error
				;AN033;  was detected.

;============================================================================
; MSGSERV.ASM, MSDOS 6.0, 1991
;============================================================================
; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh

;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
;;
;; STRUCTURE: $M_RES_ADDRS
;;
;; Resident data area definition of variables
;;
;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;

$M_RT:
	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0

;============================================================================
; COPYRIGHT.INC, MSDOS 6.0, 1993
;============================================================================
; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
; ---------------------------------------------------------------------------
;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
;;M031 - changed copyright to 1991
;;9/16 - changed verison to 6.0 and copyright to 1992
;;9/21 - Added international translations, language passed through COUNTRY macro
;;B49,50 - changed version to 6 and copyright to 1993
; ---------------------------------------------------------------------------

;;ifdef USA
;MsDosVer6_CCopy:
;	db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
;	db	"Licensed Material - Property of Microsoft "
;	db	"All rights reserved "
;endif

; 15/04/2023
MsDosVer5_CCopy:
	db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
	db	"Licensed Material - Property of Microsoft "
	db	"All rights reserved "
; ---------------------------------------------------------------------------
; 15/04/2023
	; 16/04/2023 - 21/04/2023
	;db 	0
	;db	0Dh,0Ah
	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
	;db	0
	;db	'by Erdogan Tan - 05/05/2023'
	;db	0

;============================================================================
; TPRINTF.ASM, MSDOS 6.0, 1991
;============================================================================
; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

PRINTF_HANDLE:
	dw	0		;AC000;

; 15/047/2023
%if 0

;============================================================================
; TSPC.ASM, MSDOS 6.0, 1991
;============================================================================
; 29/09/2018 - Retro DOS v3.0

;TITLE	COMMAND Transient Uninitialized DATA

;The TRANSPACE segment contains variable data that is considered
;volatile between command cycles, and therefore is not included in the
;transient checksum area. Contents of these variables MUST be
;initialized before use, and must not be relied upon from command
;cycle to command cycle.
;
;No constant data values should be stored here.

; ---------------------------------------------------------------------------
; START OF UNITIALIZED DATA
; ---------------------------------------------------------------------------

;	times 12 db 0

align 16

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h

PRINTF_LEFT:	db 0
PRINTF_LONG:	db 0
PRINTF_HEX:	db 0
TABLE_INDEX:	db 0
PRINTF_WIDTH:	dw 0
PRINTF_BASE:	dw 0
PAD_CHAR:	db 0
PRINTF_HANDLE:	dw 0
PRINTF_BUF: times 100 db 0
PRINTF_BUF_END: ; 30/09/2018

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh

SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection

; Variables passed up from resident	; in the Resident portion: (initial values)	
HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
TPA:		dw 0			; LTPA	    (dw 0)	
SWITCHAR:	db 0			; RSWITCHAR (db '-')
DIRCHAR:	db 0			; RDIRCHAR  (db '/')
EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
					; MYSEG1    (dw 0)	
RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
					; MYSEG2    (dw 0)	
		dw 0			; RESTEST   (dw 0)	
TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	

CHKDRV:		db 0
IFNOTFLAG:
FILTYP:
RDEOF:		db 0			; Misc flags
CURDRV:		db 0
PARM1:
Concat:		db 0
PARM2:
ArgC:		db 0
COMSW:		dw 0			; Switches between command and 1st arg
ARG1S:		dw 0			; Switches between 1st and 2nd arg
ARG2S:					; Switches after 2nd arg		
DestSwitch:	dw 0
ARGTS:
AllSwitch:	dw 0			; ALL switches except for COMSW
CFLAG:		db 0
DestClosed:
SPECDRV:	db 0
BYTCNT:		dw 0			; Size of buffer between RES and TRANS
NXTADD:		dw 0
FRSTSRCH:	db 0
;LeftOnLine:	db 0			; entries left on line u.b. DIR
;PerLine:	db 0			; entries/line u.b. DIR
LINCNT:		db 0
LINLEN:		db 0
;LeftOnPage:	dw 0			; lines left on page u.b. DIR
FILECNT:	dw 0			; file count u.b. DIR
;FileSiz:	dd 0			; file size u.b. DIR

;		Note:  keep FileCntTotal through csecUsedTotal together!
;
;FileCntTotal:	dd 0			; total file count u.b. DIR
;FileSizTotal:	dd 0			; total file size u.b. DIR

	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh

CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
DESTFCB2:
IDLEN:		db 0
ID:	  times	8  db 0
COM:	  times	3  db 0 
DEST:	  times 37 db 0
DESTNAME: times 11 db 0
DESTDIR:
DestFcb:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
GOTOLEN:	; word
BWDBUF: 	; byte
EXEFCB: 	; word
DIRBUF:	times DIRSTRLEN+3 db 0 ; 70

DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
DIRBUF_FTIME   equ DIRBUF+30  ; word
DIRBUF_FDATE   equ DIRBUF+32  ; word	
DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
DIRBUF_FSIZ_H  equ DIRBUF+38  ; word

SDIRBUF:  times 12 db 0	
_BITS:		dw 0
PATHCNT:	dw 0
PATHPOS:	dw 0
PATHSW:		dw 0
;AttrSpecified:	db 0			; attribute bits u.b. DIR
;AttrSelect:	db 0			; attribute bits u.b. DIR
LINPERPAG:	db 0
		db 0
COMMA:		db 0			; flag set if +,, occurs
PLUS_COMMA:	db 0			; flag set if +,, occurs

;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
;parse_last:	dw 0			;AN018; used to hold parsing position
;system_cpage:	dw 0			;AC001; used for CHCP variable

ARG_BUF:  times 128 db 0   ; _43E8h	
STRING_PTR_1:	dw 0	   ; _4468h	
FILESIZE_L:	dw 0	   ; _446Ah		
FILESIZE_H:	dw 0	   ; _446Ch	
STRING_PTR_2:	dw 0	   ; _446Eh	

COPY_NUM:	dw 0
	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
CPYFLAG:	db 0
DIR_NUM:	dw 0
BYTES_FREE:	dw 0
		dw 0
MAJOR_VER_NUM:	dw 0
MINOR_VER_NUM:	dw 0
ONE_CHAR_VAL:	db 0
		;db 0
VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
VOL_DRV:	db 0
VOL_DIR:	dw 0 ; MSDOS 3.3

ROM_CALL:	db 0			; flag for rom function
ROM_IP:		dw 0
ROM_CS:		dw 0

DestVars:
DestIsDir:	db 0
DestSiz:	db 0
DestTail:	dw 0
DestInfo:	db 0
DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
ENDDESTBUF:

DESTHAND:	dw 0
DESTISDEV:	db 0
FIRSTDEST:	db 0
MELCOPY:	db 0
MELSTART:	dw 0

SrcVars:
SrcIsDir:	db 0
SrcSiz:		db 0
SrcTail:	dw 0
SrcInfo:	db 0
SrcBuf:   times	DIRSTRLEN+20 db 0 ; 87

SRCHAND:	dw 0
SRCISDEV:	db 0

SCANBUF:  times DIRSTRLEN+20 db 0 ; 87

SRCPT:		dw 0
INEXACT:	db 0
		db 0 ; MSDOS 3.3 
NOWRITE:	db 0
BINARY:		db 0
WRITTEN:	dw 0
TERMREAD:	db 0
ASCII:		db 0
PLUS:		db 0
OBJCNT:		db 0			; Used in copy
CPDATE:		dw 0
CPTIME:		dw 0

;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
;OFilePtr_Hi:	dw 0			; 1st source is also destination
;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto

BATHAND:	dw 0			; Batch handle
STARTEL:	dw 0
ELCNT:		db 0
ELPOS:		db 0
; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
MSDOS 5.0
SKPDEL:
SOURCE:   times	11 db 0

ext_entered:	db 0			;AN005;

;display_ioctl	db 0			;AN000; info level
;		db 0			;AN000; reserved
;		dw crt_ioctl_ln		;AN000; length of data
;		dw 0			;AN000; control flags
;display_mode:	db 0			;AN000; display mode, colors
;		db 0			;AN000; reserved
;		dw 0			;AN023; colors
;		dw 0			;AN000; display width (PELS)
;		dw 0			;AN000; display length (PELS)
;display_width:	dw 0			;AN000; display width
;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
;
;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
;		dw 0			;AN000; info level
;vol_serial:	dd 0			;AN000; volume serial number
;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
;	    times 8  db 20h ; " "       ;AN000; file system type

EXPAND_STAR:	db 0

;msg_flag:	db 0			;AN022; flag set if non-utility message issued
;msg_numb:	dw 0			;AN022; set with extended error message issued
;append_exec:	db 0			;AN041; set if internal append executed
;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
;subst_buffer: times parm_block_size*2 db 0 ;AN061;

COMSPEC_FLAG:	db 0 ; MSDOS 3.3

; Data declarations taken out of parse.asm

; MSDOS 6.0
;arg	arg_unit	<>		; pointers, arg count, string buffer
;argbufptr	dw	?		; index for argv[].argpointer
;tpbuf		db	128   DUP (?)	; temporary buffer
;LAST_ARG	dw	?		; point at which to accumulate switch info
;comptr		dw	?		; ptr into combuf

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
ARG:
ARG_ARGV:
ARGV0_ARGPOINTER: dw 0	; ARGV[0]
ARGV0_ARG_FLAGS:  db 0
ARGV0_ARGSTARTEL: dw 0
ARGV0_ARGLEN:	  dw 0
ARGV0_ARGSW_WORD: dw 0
ARGV0_OCOMPTR:	  dw 0

ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
	  times 5 db 0
ARGV1_ARGSW_WORD: dw 0
		  dw 0

ARGV2_ARGPOINTER: dw 0	; ARGV[2]
	  times 5 db 0
ARGV2_ARGSW_WORD: dw 0
		  dw 0

	times 671 db 0  ; ARGV[3] to ARGV[63]
	
ARG_ARGVCNT:	dw 0
ARG_ARGSWINFO:	dw 0

ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh

ARGBUFPTR:	dw 0			; index for argv[].argpointer
TPBUF:    times 128 db 0		; temporary buffer
LASTARG:	dw 0			; point at which to accumulate switch info
COMPTR:		dw 0			; ptr into combuf

; Data declarations taken out of path.asm
;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
;psep_char	DB	?			; '/' or '\'
;search_best	DB	(?)			; best code, best filename so far
;fname_max_len	equ	13
;search_best_buf DB	fname_max_len DUP (?)
;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
;search_error	DW	(?)			; address of error message to be printed

FINDBUFLEN equ FIND_BUF.size ; 43

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h

FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
PATHINFO:
PATHINFO_0:	dw 0
PATHINFO_2:	dw 0
PATHINFO_4:	dw 0
PSEP_CHAR:	db 0
SEARCH_BEST:	db 0
;FNAME_MAX_LEN equ 13
SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
SEARCH_CURDIR_BUF: times 64 db 0
SEARCH_ERROR:	dw 0

; Data declarations taken out of tbatch.asm

;if_not_count	DW	?
;
;zflag		db	?		; Used by typefil to indicate ^Z's
;
;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled

; 31/03/2023
STACK:		;LABEL	WORD

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h

IF_NOT_COUNT:	dw 0
ZFLAG:		db 0
	  times 256 db 0 	
STACK:

;INTERNATVARS	internat_block <>
;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
;
;;		Buffer for DOS function 64h (Get extended country information)
;;		subfunctions 2, 4, 6, or 7:
;
;CountryPtrInfo	label	byte
;CountryPtrId	db	?
;CountryPtr	dd	?
;		.erre	(($ - CountryPtrInfo) GE 5)

		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h

INTERNATVARS:	
DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
DATE_SEP:	db 0,0			; Date separator 2 bytes
TIME_SEP:	db 0,0			; Time separator 2 bytes	
BIT_FIELD:	db 0			; Bit values
					;   Bit 0 = 0 if currency symbol first
					;	  = 1 if currency symbol last
					;   Bit 1 = 0 if No space after currency symbol
					;	  = 1 if space after currency symbol
CURRENCY_CENTS:	db 0			; Number of places after currency dec point
TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
					;  in pieces.
DATA_SEP:	db 0,0			; Data list separator character		

		times 8 db 0
;
; Max size of the block returned by the INTERNATIONAL call
;
INTERNAT_BLOCK_SIZE EQU	32

BATLEN equ 32
		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		

BATBUFPOS:	dw 0			; integer position in buffer of next byte

BATBUF:	  times	BATLEN db 0 ; times 32 db 0

BATBUFEND:	dw 0

;TypeFilSiz:	dd 0			; stores size of file to be typed

TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion

; 18/04/2023
; ----------------------------------------------------------------------------
; 09/01/2023
;TRANSPACEEND	equ $ - TRANSIENTSTART ; 18/04/2023

%endif

;============================================================================
; TSPC.ASM, MSDOS 6.0, 1991
;============================================================================
; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM

;TITLE	COMMAND Transient Uninitialized DATA

;The TRANSPACE segment contains variable data that is considered
;volatile between command cycles, and therefore is not included in the
;transient checksum area. Contents of these variables MUST be
;initialized before use, and must not be relied upon from command
;cycle to command cycle.
;
;No constant data values should be stored here.

; ---------------------------------------------------------------------------
; START OF UNITIALIZED DATA
; ---------------------------------------------------------------------------

	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h

SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection

; Variables passed up from resident	; in the Resident portion: (initial values)	
HEADCALL:
	dw 0			; TRANVARS  (dw THEADFIX)
RESSEG:	dw 0			; MYSEG     (dw 0) 	 	
TPA:	dw 0			; LTPA	    (dw 0)	
SWITCHAR:
	db 0			; RSWITCHAR (db '-')
DIRCHAR:
	db 0			; RDIRCHAR  (db '/')
EXEC_ADDR:
	dd 0			; 	    (dw EXT_EXEC)	 
				; MYSEG1    (dw 0)	
RCH_ADDR:
	dd 0			;	    (dw TREMCHECK) 	
				; MYSEG2    (dw 0)	
	dw 0			; RESTEST   (dw 0)	
TRAN_TPA:
	dw 0			; RES_TPA   (dw 0)	

CHKDRV:	db 0
IFNOTFLAG:
FILTYP:
RDEOF:	db 0			; Misc flags
CURDRV:	db 0
PARM1:
Concat:	db 0
PARM2:
ArgC:	db 0
COMSW:	dw 0			; Switches between command and 1st arg
ARG1S:	dw 0			; Switches between 1st and 2nd arg
ARG2S:				; Switches after 2nd arg		
DestSwitch:
	dw 0
ARGTS:
AllSwitch:
	dw 0			; ALL switches except for COMSW
CFLAG:	db 0
DestClosed:
SPECDRV:
	db 0
BYTCNT:	dw 0			; Size of buffer between RES and TRANS
NXTADD:	dw 0
FRSTSRCH:
	db 0
; 15/04/2023
LeftOnLine:
	db 0			; entries left on line u.b. DIR
PerLine:
	db 0			; entries/line u.b. DIR
LINCNT:	db 0
LINLEN:	db 0
LeftOnPage:
	dw 0			; lines left on page u.b. DIR
FileCnt:
	dw 0			; file count u.b. DIR
FileSiz:
	dd 0			; file size u.b. DIR

; Note: keep FileCntTotal through csecUsedTotal together!

FileCntTotal:
	dd 0			; total file count u.b. DIR
FileSizTotal:
	dd 0			; total file size u.b. DIR

	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
CHARBUF:
	times	80 db 0		;line byte character buffer for xenix write
DESTFCB2:
IDLEN:	db 0
ID:	times	8  db 0
COM:	times	3  db 0 
DEST:	times	37 db 0
DESTNAME:
	times	11 db 0
DESTDIR:
DestFcb:
	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
GOTOLEN: ; word
BWDBUF:  ; byte
EXEFCB:  ; word
DIRBUF:	times DIRSTRLEN+3 db 0 ; 70

DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
DIRBUF_FTIME   equ DIRBUF+30  ; word
DIRBUF_FDATE   equ DIRBUF+32  ; word	
DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
DIRBUF_FSIZ_H  equ DIRBUF+38  ; word

	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
SDIRBUF:
	times 12 db 0	
_Bits:
	dw 0
PathCnt:
	dw 0
PathPos:
	dw 0
PathSw:	dw 0
AttrSpecified:
	db 0			; attribute bits u.b. DIR
AttrSelect:
	db 0			; attribute bits u.b. DIR
comma:	db 0			; flag set if +,, occurs
plus_comma:
	db 0			; flag set if +,, occurs
DirFlag:
 	db 0			;AN015; set when pathcrunch called from DIR
parse_last:
	dw 0			;AN018; used to hold parsing position
system_cpage:
	dw 0			;AC001; used for CHCP variable
Arg_Buf:
	times 128 db 0	
File_Size_Low:
	dw 0	
File_Size_High:
	dw 0		
string_ptr_2:
	dw 0	
Copy_num:
	dw 0
cpyflag:
	db 0
Dir_Num:
	dw 0
Bytes_Free:
	dd 0

Major_Ver_Num:
	dw 0
Minor_Ver_Num:
	dw 0

One_Char_Val:
	db 0
	db 0
vol_drv:
	db 0
ROM_CALL:
	db 0			; flag for rom function
ROM_IP:	dw 0
ROM_CS:	dw 0

DestVars:
DestIsDir:
	db 0
DestSiz:
	db 0
DestTail:
	dw 0
DestInfo:
	db 0
DestBuf:
	times DIRSTRLEN+20 db 0 ; 87
EndDestBuf:
DESTHAND:
	dw 0
DESTISDEV:
	db 0
FIRSTDEST:
	db 0
MELCOPY:
	db 0
MELSTART:
	dw 0
SrcVars:
SrcIsDir:
	db 0
SrcSiz:	db 0
SrcTail:
	dw 0
SrcInfo:
	db 0
SrcBuf:
	times DIRSTRLEN+20 db 0 ; 87
SRCHAND:
	dw 0
SRCISDEV:
	db 0
ScanBuf:
	times DIRSTRLEN+20 db 0 ; 87

SRCPT:	dw 0
INEXACT:
	db 0
NOWRITE:
	db 0
BINARY:
	db 0
WRITTEN:
	dw 0
TERMREAD:
	db 0
ASCII:	db 0
PLUS:	db 0
objcnt:	db 0			; Used in copy
CPDATE:	dw 0
CPTIME:	dw 0

OFilePtr_Lo:
	dw 0			; original file ptr for COPY when
OFilePtr_Hi:
	dw 0			; 1st source is also destination
OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
BATHAND:
	dw 0			; Batch handle
STARTEL:
	dw 0
ELCNT:	db 0
ELPOS:	db 0

; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
; MSDOS 5.0
SKPDEL:
SOURCE:	times 11 db 0

ext_entered:
	db 0			;AN005;

; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh

Display_Ioctl:
	db 0			;AN000; info level
	db 0			;AN000; reserved
	dw crt_ioctl_ln		;AN000; length of data
	dw 0			;AN000; control flags
display_mode:
	db 0			;AN000; display mode, colors
	db 0			;AN000; reserved
	dw 0			;AN023; colors
	dw 0			;AN000; display width (PELS)
	dw 0			;AN000; display length (PELS)
display_width:
	dw 0			;AN000; display width
LinPerPag:
	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)

vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
	dw 0			;AN000; info level
vol_serial:
	dd 0			;AN000; volume serial number
vol_label:
	times 11 db 20h ; " "	;AN000; volume label - init to blanks
	times 8  db 20h ; " "	;AN000; file system type

expand_star:
	db 0

msg_flag:
	db 0			;AN022; flag set if non-utility message issued
Msg_Numb:
	dw 0			;AN022; set with extended error message issued
append_exec:
	db 0			;AN041; set if internal append executed
print_err_flag:
	dw 0			;AN000; flag set if error during sysdispmsg
subst_buffer:
	times parm_block_size*2 db 0 ; times 22 db 0 
				;AN061;
; 15/04/2023
KPARSE:	db 0	; 3/3/KK	

; Data declarations taken out of parse.asm

; MSDOS 6.0
;arg	arg_unit	<>		; pointers, arg count, string buffer
;argbufptr	dw	?		; index for argv[].argpointer
;tpbuf		db	128 DUP (?)	; temporary buffer
;LAST_ARG	dw	?		; point at which to accumulate switch info
;comptr		dw	?		; ptr into combuf

	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
ARG:
ARG_ARGV:
ARGV0_ARGPOINTER:
	dw 0	; ARGV[0]
ARGV0_ARG_FLAGS:
	db 0
ARGV0_ARGSTARTEL:
	dw 0
ARGV0_ARGLEN:
	dw 0
ARGV0_ARGSW_WORD:
	dw 0
ARGV0_OCOMPTR:
	dw 0
ARGV1_ARGPOINTER:
	dw 0	; ARGV[1]	
	times 5 db 0
ARGV1_ARGSW_WORD:
	dw 0
	dw 0
ARGV2_ARGPOINTER:
	dw 0	; ARGV[2]
	times 5 db 0
ARGV2_ARGSW_WORD:
	dw 0
	dw 0
	times 671 db 0  ; ARGV[3] to ARGV[63]
ARG_ARGVCNT:
	dw 0
ARG_ARGSWINFO:
	dw 0
ARG_ARGBUF:
	times 256 dw 0	; times ARGBLEN dw 0 
ARG_ARGFORCOMBUF:
	times 128 db 0  ; times COMBUFLEN db 0 

	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
ARGBUF_PTR:
	dw 0			; index for argv[].argpointer
TPBUF:	times 128 db 0		; temporary buffer
LASTARG:
	dw 0			; point at which to accumulate switch info
COMPTR:	dw 0			; ptr into combuf

; Data declarations taken out of path.asm
;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
;psep_char	DB	?		; '/' or '\'
;search_best	DB	(?)		; best code, best filename so far
;fname_max_len	equ	13
;search_best_buf DB	fname_max_len DUP (?)
;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
;search_error	DW	(?)		; address of error message to be printed

FINDBUFLEN equ FIND_BUF.size ; 43

	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh

FBUF:	times FINDBUFLEN db 0	; times 43 db 0
FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
pathinfo:
;pathinfo_0:
	dw 0
;pathinfo_2:
	dw 0
;pathinfo_4:
	dw 0
psep_char:
	db 0
search_best:
	db 0
FNAME_MAX_LEN equ 13
search_best_buf:
	times FNAME_MAX_LEN db 0 ; times 13 db 0
search_curdir_buf:
	times 64 db 0
search_error:
	dw 0

; Data declarations taken out of tbatch.asm

;if_not_count	DW	?
;
;zflag		db	?		; Used by typefil to indicate ^Z's
;
;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled

; 31/03/2023
;STACK:	;LABEL	WORD

	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h

IF_NOT_COUNT:
	dw 0
zflag:	db 0
	times 256 db 0 
	; 16/04/2023
	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
STACK:

;INTERNATVARS	internat_block <>
;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)

	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
INTERNATVARS:
		; (24+8 = 32 bytes)
DATE_TIME_FORMAT:
	dw 0			; 0-USA, 1-EUR, 2-JAP
CURRENCY_SYM:
	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
THOUS_SEP:
	db 0,0			; Thousands separator 2 bytes
DECIMAL_SEP:
	db 0,0			; Decimal separator 2 bytes
DATE_SEP:
	db 0,0			; Date separator 2 bytes
TIME_SEP:
	db 0,0			; Time separator 2 bytes	
BIT_FIELD:
	db 0			; Bit values
				;   Bit 0 = 0 if currency symbol first
				;	  = 1 if currency symbol last
				;   Bit 1 = 0 if No space after currency symbol
				;	  = 1 if space after currency symbol
CURRENCY_CENTS:
	db 0			; Number of places after currency dec point
TIME_24:
	db 0			; 1 if 24 hour time, 0 if 12 hour time
MAP_CALL:
	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
				;  in pieces.
DATA_SEP:
	db 0,0			; Data list separator character		

	times 8 db 0

; Max size of the block returned by the INTERNATIONAL call

INTERNAT_BLOCK_SIZE EQU	32

;;	Buffer for DOS function 64h (Get extended country information)
;;	subfunctions 2, 4, 6, or 7:
;
;CountryPtrInfo	label	byte
;CountryPtrId	db	?
;CountryPtr	dd	?
;		.erre	(($ - CountryPtrInfo) GE 5)
	
	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
CountryPtrInfo:
CountryPtrId:	
	db 0
CountryPtr:
	dd 0

OldCtrlCHandler:
	dd 0			; previous int 23 vector		

BATLEN equ 32

BATBUFPOS:
	dw 0			; integer position in buffer of next byte

BATBUF:	times BATLEN db 0 ; times 32 db 0
BATBUFEND:
	dw 0
TypeFilSiz:
	dd 0			; stores size of file to be typed

; *****************************************************
; EMG 4.00
; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
; *****************************************************
;
; COMMON PARSE OUTPUT BLOCKS

; Common output blocks for PARSE number, complex, or string values.

PARSE1_OUTPUT:
PARSE1_TYPE:
	db 0			;AN000;  type
PARSE1_CODE:
	db 0			;AN000;  return value
PARSE1_SYN:
	dw 0			;AN000;  es offset of synonym
PARSE1_ADDR:
	dd 0			;AN000;  numeric value / address
				;	 of string value

;  Common output block for PARSE date strings.

DATE_OUTPUT:
DATE_TYPE:
	db 0			;AN000;  type
	db 0			;AN000;  return value
	dw 0			;AN000;  es offset of synonym
DATE_YEAR:
	dw 0			;AN000;  year
DATE_MONTH:
	db 0			;AN000;  month
DATE_DAY:
	db 0			;AN000;  day

;  Common output block for PARSE time strings.

TIME_OUTPUT:
TIME_TYPE:
	db 0			;AN000;  type
	db 0			;AN000;  return value
	dw 0			;AN000;  es offset of synonym
TIME_HOUR:
	db 0			;AN000;  hour
TIME_MINUTES:
	db 0			;AN000;  minutes
TIME_SECONDS:
	db 0			;AN000;  seconds
TIME_FRACTION:
	db 0			;AN000;  hundredths

;  Common output block for PARSE drive specifier (one based drive number).

DRIVE_OUTPUT:
DRIVE_TYPE:
	db 0			;AN000;  type
DRIVE_VALUE:
	db 0			;AN000;  return value
	dw 0			;AN000;  es offset of synonym
DRIVE_NUMBER:
	db 0			;AN000;  drive number
	db 0,0,0		;AN000;  reserved

	; 18/04/2023
	; 16/04/2023
;TRANSPACEEND: ; 98C5h ; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion

; ----------------------------------------------------------------------------
; 20/04/2023
TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
