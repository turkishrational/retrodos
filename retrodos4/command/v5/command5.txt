     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 5.0 Command Interpreter) - RETRO DOS v4.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 05/05/2023 (v5.0) ((Previous: 20/10/2018 COMMAND.COM v3.3))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15 (2.11)
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm command5.s -l command5.lst -o COMMAND.COM)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    13                                  ; by Microsoft, 18/08/1983
    14                                  ; ****************************************************************************
    15                                  ; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
    16                                  ; in NASM syntax (by Erdogan Tan), 20/10/2018
    17                                  ; ----------------------------------------------------------------------------
    18                                  ;; 11/09/2018 - Erdogan Tan
    19                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    20                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    21                                  ; ----------------------------------------------------------------------------
    22                                  ; MSDOS 6.0 source files:
    23                                  ;;============================================================================
    24                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    25                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    26                                  ;;============================================================================
    27                                  ;
    28                                  ; COMMAND.COM v6.0 source files:
    29                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    30                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    31                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    32                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    33                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    34                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    35                                  ;
    36                                  ; COMMAND.COM v2.11 source files:
    37                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    38                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    39                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    40                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    41                                  ;
    42                                  ; ----------------------------------------------------------------------------
    43                                  ; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)
    44                                  
    45                                  ;============================================================================
    46                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    47                                  ;============================================================================
    48                                  ; 21/09/2018 - Retro DOS v3.0
    49                                  
    50                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    51                                  ;BREAK <system call definitions>
    52                                  
    53                                  ;
    54                                  ;	Microsoft Confidential
    55                                  ;	Copyright (C) Microsoft Corporation 1991
    56                                  ;	All Rights Reserved.
    57                                  ;
    58                                  
    59                                  ;SUBTTL	system call definitions
    60                                  ;PAGE
    61                                  
    62                                  Abort				EQU 0	;  0	  0
    63                                  STD_CON_INPUT			EQU 1	;  1	  1
    64                                  Std_Con_Output			EQU 2	;  2	  2
    65                                  Std_Aux_Input			EQU 3	;  3	  3
    66                                  Std_Aux_Output			EQU 4	;  4	  4
    67                                  Std_Printer_Output		EQU 5	;  5	  5
    68                                  Raw_Con_IO			EQU 6	;  6	  6
    69                                  RAW_CON_INPUT			EQU 7	;  7	  7
    70                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    71                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    72                                  Std_Con_String_Input		EQU 10	; 10	  A
    73                                  Std_Con_Input_Status		EQU 11	; 11	  B
    74                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    75                                  DISK_RESET			EQU 13	; 13	  D
    76                                  Set_Default_Drive		EQU 14	; 14	  E
    77                                  FCB_Open			EQU 15	; 15	  F
    78                                  FCB_Close			EQU 16	; 16	 10
    79                                  Dir_Search_First		EQU 17	; 17	 11
    80                                  Dir_Search_Next 		EQU 18	; 18	 12
    81                                  FCB_Delete			EQU 19	; 19	 13
    82                                  FCB_Seq_Read			EQU 20	; 20	 14
    83                                  FCB_Seq_Write			EQU 21	; 21	 15
    84                                  FCB_Create			EQU 22	; 22	 16
    85                                  FCB_Rename			EQU 23	; 23	 17
    86                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    87                                  Set_DMA 			EQU 26	; 26	 1A
    88                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    89                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    90                                  ;									   ;
    91                                  Get_Default_DPB 		EQU 31	; 31	 1F
    92                                  ;									   ;
    93                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    94                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    95                                  FCB_Random_Read 		EQU 33	; 33	 21
    96                                  FCB_Random_Write		EQU 34	; 34	 22
    97                                  Get_FCB_File_Length		EQU 35	; 35	 23
    98                                  Get_FCB_Position		EQU 36	; 36	 24
    99                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   100                                  Create_Process_Data_Block	EQU 38	; 38	 26
   101                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   102                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   103                                  Parse_File_Descriptor		EQU 41	; 41	 29
   104                                  Get_Date			EQU 42	; 42	 2A
   105                                  Set_Date			EQU 43	; 43	 2B
   106                                  Get_Time			EQU 44	; 44	 2C
   107                                  Set_Time			EQU 45	; 45	 2D
   108                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   109                                  ; Extended functionality group
   110                                  Get_DMA 			EQU 47	; 47	 2F
   111                                  GET_VERSION			EQU 48	; 48	 30
   112                                  Keep_Process			EQU 49	; 49	 31
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   115                                  ;									   ;
   116                                  Get_DPB 			EQU 50	; 50	 32
   117                                  ;									   ;
   118                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   119                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   120                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   121                                  Get_InDOS_Flag			EQU 52	; 52	 34
   122                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   123                                  Get_Drive_Freespace		EQU 54	; 54	 36
   124                                  CHAR_OPER			EQU 55	; 55	 37
   125                                  International			EQU 56	; 56	 38
   126                                  ;   Directory Group
   127                                  MKDir				EQU 57	; 57	 39
   128                                  RMDir				EQU 58	; 58	 3A
   129                                  CHDir				EQU 59	; 59	 3B
   130                                  ;   File Group
   131                                  Creat				EQU 60	; 60	 3C
   132                                  OPEN				EQU 61	; 61	 3D
   133                                  CLOSE				EQU 62	; 62	 3E
   134                                  READ				EQU 63	; 63	 3F
   135                                  Write				EQU 64	; 64	 40
   136                                  Unlink				EQU 65	; 65	 41
   137                                  LSEEK				EQU 66	; 66	 42
   138                                  CHMod				EQU 67	; 67	 43
   139                                  IOCTL				EQU 68	; 68	 44
   140                                  XDUP				EQU 69	; 69	 45
   141                                  XDup2				EQU 70	; 70	 46
   142                                  Current_Dir			EQU 71	; 71	 47
   143                                  ;    Memory Group
   144                                  ALLOC				EQU 72	; 72	 48
   145                                  DEALLOC				EQU 73	; 73	 49
   146                                  SETBLOCK			EQU 74	; 74	 4A
   147                                  ;    Process Group
   148                                  Exec				EQU 75	; 75	 4B
   149                                  EXIT				EQU 76	; 76	 4C
   150                                  WAITPROCESS			EQU 77	; 77	 4D
   151                                  Find_First			EQU 78	; 78	 4E
   152                                  ;   Special Group
   153                                  Find_Next			EQU 79	; 79	 4F
   154                                  ; SPECIAL SYSTEM GROUP
   155                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   156                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   157                                  ;									   ;
   158                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   159                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   160                                  Get_In_Vars			EQU 82	; 82	 52
   161                                  SetDPB				EQU 83	; 83	 53
   162                                  ;									   ;
   163                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   164                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   165                                  Get_Verify_On_Write		EQU 84	; 84	 54
   166                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   167                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   168                                  ;									   ;
   169                                  Dup_PDB 			EQU 85	; 85	 55
   170                                  ;									   ;
   171                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   172                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   173                                  Rename				EQU 86	; 86	 56
   174                                  File_Times			EQU 87	; 87	 57
   175                                  AllocOper			EQU 88	; 88	 58
   176                                  ; Network extention system calls
   177                                  GetExtendedError		EQU 89	; 89	 59
   178                                  CreateTempFile			EQU 90	; 90	 5A
   179                                  CreateNewFile			EQU 91	; 91	 5B
   180                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   181                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;									   ;
   184                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   185                                  					;	    CloseByName, CloseUser,
   186                                  					;	    CloseUserProcess,
   187                                  					;	    GetOpenFileList
   188                                  ;									   ;
   189                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   190                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   191                                  UserOper			EQU 94	; 94	 5E Get and Set
   192                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   193                                  xNameTrans			EQU 96	; 96	 60
   194                                  PathParse			EQU 97	; 97	 61
   195                                  GetCurrentPSP			EQU 98	; 98	 62
   196                                  Hongeul 			EQU 99	; 99	 63
   197                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   198                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   199                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   200                                  ;									   ;
   201                                  Set_Printer_Flag		EQU 100 ; 100	 64
   202                                  ;									   ;
   203                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   204                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   205                                  GetExtCntry			EQU 101 ; 101	 65
   206                                  GetSetCdPg			EQU 102 ; 102	 66
   207                                  ExtHandle			EQU 103 ; 103	 67
   208                                  Commit				EQU 104 ; 104	 68
   209                                  GetSetMediaID			EQU 105 ; 105	 69
   210                                  IFS_IOCTL			EQU 107 ; 107	 6B
   211                                  ExtOpen 			EQU 108 ; 108	 6C
   212                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   213                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   214                                  ;                                                                          ;
   215                                  ;ifdef ROMEXEC
   216                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   217                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   218                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
   219                                  ;endif
   220                                  ;                                                                          ;
   221                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   222                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   223                                  ;
   224                                  ;
   225                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   226                                  OEM_C1				EQU 249 ; 249	 F9
   227                                  OEM_C2				EQU 250 ; 250	 FA
   228                                  OEM_C3				EQU 251 ; 251	 FB
   229                                  OEM_C4				EQU 252 ; 252	 FC
   230                                  OEM_C5				EQU 253 ; 253	 FD
   231                                  OEM_C6				EQU 254 ; 254	 FE
   232                                  OEM_C7				EQU 255 ; 255	 FF
   233                                  
   234                                  ;============================================================================
   235                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   236                                  ;============================================================================
   237                                  ; 21/09/2018 - Retro DOS v3.0
   238                                  
   239                                  ;BREAK <Control character definitions>
   240                                  
   241                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   242                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   243                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   244                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   245                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   246                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   247                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   248                                  c_HT	    EQU     09h 	; ^I ASCII tab
   249                                  
   250                                  ;============================================================================
   251                                  ; DIRENT.INC, MSDOS 6.0, 1991
   252                                  ;============================================================================
   253                                  ; 21/09/2018 - Retro DOS v3.0
   254                                  
   255                                  ;Break <Directory entry>
   256                                  
   257                                  ;	NOTE:  These offsets are also used in the DTA for
   258                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   259                                  ;	with the FCB filename field, and the rest of the
   260                                  ;	DIR_ENTRY fields follow. -DavidOls
   261                                  
   262                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   263                                  ;
   264                                  ;	+---------------------------+
   265                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   266                                  ;	+---------------------------+
   267                                  ;	|     (BYTE) attributes     |	    11	    B
   268                                  ;	+---------------------------+
   269                                  ;	|    (10 BYTE) reserved     |	    12	    C
   270                                  ;	+---------------------------+
   271                                  ;	| (WORD) time of last write |	    22	    16
   272                                  ;	+---------------------------+
   273                                  ;	| (WORD) date of last write |	    24	    18
   274                                  ;	+---------------------------+
   275                                  ;	|   (WORD) First cluster    |	    26	    1A
   276                                  ;	+---------------------------+
   277                                  ;	|     (DWORD) file size     |	    28	    1C
   278                                  ;	+---------------------------+
   279                                  ;
   280                                  ;   First byte of filename  = E5 -> free directory entry
   281                                  ;			    = 00 -> end of allocated directory
   282                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   283                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   284                                  ;
   285                                  
   286                                  STRUC DIR_ENTRY
   287 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   288 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   289 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   290 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   291 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   292 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   293 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   294 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   295 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   296 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   297 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   298                                  .size:
   299                                  
   300                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   301                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   302                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   303                                  ;	    this field is zero for subdirectory files.
   304                                  
   305                                  ENDSTRUC
   306                                  
   307                                  ATTR_READ_ONLY	equ	 1h
   308                                  ATTR_HIDDEN	equ	 2h
   309                                  ATTR_SYSTEM	equ	 4h
   310                                  ATTR_VOLUME_ID	equ	 8h
   311                                  ATTR_DIRECTORY	equ	10h
   312                                  ATTR_ARCHIVE	equ	20h
   313                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   314                                  				;   NO directory entry on a disk EVER
   315                                  				;   has this bit set. It is set non-zero
   316                                  				;   when a device is found by GETPATH
   317                                  
   318                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   319                                  				; OR of hard attributes for FINDENTRY
   320                                  
   321                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   322                                  				; ignore this(ese) attribute(s) during
   323                                  				; search first/next
   324                                  
   325                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   326                                  				; changeable via CHMOD
   327                                  
   328                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   329                                  
   330                                  ;============================================================================
   331                                  ; ERROR.INC, MSDOS 6.0, 1991
   332                                  ;============================================================================
   333                                  ; 21/09/2018 - Retro DOS v3.0
   334                                  
   335                                  ;**	ERROR.INC - DOS Error Codes
   336                                  ;
   337                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   338                                  ;    return error codes through AX.	If an error occurred then
   339                                  ;    the carry bit will be set and the error code is in AX.	If no error
   340                                  ;    occurred then the carry bit is reset and AX contains returned info.
   341                                  ;
   342                                  ;    Since the set of error codes is being extended as we extend the operating
   343                                  ;    system, we have provided a means for applications to ask the system for a
   344                                  ;    recommended course of action when they receive an error.
   345                                  ;
   346                                  ;    The GetExtendedError system call returns a universal error, an error
   347                                  ;    location and a recommended course of action.	The universal error code is
   348                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   349                                  ;    is issued.
   350                                  
   351                                  
   352                                  ;	2.0 error codes
   353                                  
   354                                  error_invalid_function		EQU	1
   355                                  ERROR_FILE_NOT_FOUND		EQU	2
   356                                  ERROR_PATH_NOT_FOUND		EQU	3
   357                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   358                                  ERROR_ACCESS_DENIED		EQU	5
   359                                  error_invalid_handle		EQU	6
   360                                  error_arena_trashed		EQU	7
   361                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   362                                  error_invalid_block		EQU	9
   363                                  error_bad_environment		EQU	10
   364                                  ERROR_BAD_FORMAT		EQU	11
   365                                  error_invalid_access		EQU	12
   366                                  ERROR_INVALID_DATA		EQU	13
   367                                  ;**** reserved			EQU	14	; *****
   368                                  error_invalid_drive		EQU	15
   369                                  error_current_directory 	EQU	16
   370                                  error_not_same_device		EQU	17
   371                                  ERROR_NO_MORE_FILES		EQU	18
   372                                  
   373                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   374                                  
   375                                  ERROR_WRITE_PROTECT		EQU	19
   376                                  error_bad_unit			EQU	20
   377                                  error_not_ready 		EQU	21
   378                                  error_bad_command		EQU	22
   379                                  error_CRC			EQU	23
   380                                  error_bad_length		EQU	24
   381                                  error_Seek			EQU	25
   382                                  error_not_DOS_disk		EQU	26
   383                                  error_sector_not_found		EQU	27
   384                                  error_out_of_paper		EQU	28
   385                                  error_write_fault		EQU	29
   386                                  error_read_fault		EQU	30
   387                                  ERROR_GEN_FAILURE		EQU	31
   388                                  
   389                                  ;	the new 3.0 error codes reported through INT 24
   390                                  
   391                                  error_sharing_violation 	EQU	32
   392                                  error_lock_violation		EQU	33
   393                                  error_wrong_disk		EQU	34
   394                                  ERROR_FCB_UNAVAILABLE		EQU	35
   395                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   396                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   397                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   398                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   399                                  
   400                                  ;	New OEM network-related errors are 50-79
   401                                  
   402                                  error_not_supported		EQU	50
   403                                  
   404                                  error_net_access_denied		EQU	65	;M028
   405                                  
   406                                  ;	End of INT 24 reportable errors
   407                                  
   408                                  error_file_exists		EQU	80
   409                                  error_DUP_FCB			EQU	81	; *****
   410                                  error_cannot_make		EQU	82
   411                                  error_FAIL_I24			EQU	83
   412                                  
   413                                  ;	New 3.0 network related error codes
   414                                  
   415                                  error_out_of_structures 	EQU	84
   416                                  error_Already_assigned		EQU	85
   417                                  error_invalid_password		EQU	86
   418                                  error_invalid_parameter 	EQU	87
   419                                  error_NET_write_fault		EQU	88
   420                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   421                                  
   422                                  ;============================================================================
   423                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   424                                  ;============================================================================
   425                                  ; 22/09/2018 - Retro DOS v3.0
   426                                  
   427                                  ;**	DevSym.inc - Device Symbols
   428                                  
   429                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   430                                  
   431                                  STRUC SYSDEV
   432 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   433 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   434 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   435 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   436 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   437                                  .size:
   438                                  ENDSTRUC
   439                                  
   440                                  ; 24/09/2018
   441                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   442                                  
   443                                  ;============================================================================
   444                                  ; CURDIR.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 21/09/2018 - Retro DOS v3.0
   447                                  
   448                                  DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings
   449                                  
   450                                  ;============================================================================
   451                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   452                                  ;============================================================================
   453                                  ; 21/09/2018 - Retro DOS v3.0
   454                                  
   455                                  ;/*
   456                                  ; *                      Microsoft Confidential
   457                                  ; *                      Copyright (C) Microsoft Corporation 1991
   458                                  ; *                      All Rights Reserved.
   459                                  ; */
   460                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   461                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   462                                  ;*************************************
   463                                  ; COMMAND EQUs which are not switch dependant
   464                                  
   465                                  ;		include	curdir.inc	; to get DIRSTRLEN
   466                                  ;		Note dossym.inc must already have been included!
   467                                  
   468                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   469                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   470                                  
   471                                  SYM		EQU	">"
   472                                  
   473                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   474                                  
   475                                  NORMPERLIN	EQU	1
   476                                  WIDEPERLIN	EQU	5
   477                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   478                                  BatLen		EQU	32		; buffer for batch files
   479                                  YES_ECHO	EQU	1		; echo line
   480                                  NO_ECHO 	EQU	0		; don't echo line
   481                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   482                                  call_in_progress EQU	1		; indicate we're in the CALL command
   483                                  length_call	EQU	4		; length of CALL
   484                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   485                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   486                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   487                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   488                                  nullcommand	EQU     1		; no command on command line
   489                                  END_OF_LINE	EQU    -1		;AN000; end of line return from parser
   490                                  END_OF_LINE_OUT EQU	0		;AN000; end of line for output
   491                                  END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
   492                                  result_number	EQU	1		;AN000; number returned from parser
   493                                  result_string	EQU	3		;AN000; string returned from parser
   494                                  RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
   495                                  result_drive	EQU	6		;AN000; drive returned from parser
   496                                  result_date	EQU	7		;AN000; date returned from parser
   497                                  result_time	EQU	8		;AN000; time returned from parser
   498                                  RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
   499                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   500                                  util_msg_class	EQU	-1		;AN000; message class for utility
   501                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   502                                  parse_msg_class EQU	2		;AN000; message class for parse error
   503                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   504                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   505                                  colon_char	EQU	":"             ;AN000; colon character
   506                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   507                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   508                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   509                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   510                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   511                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   512                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   513                                  shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
   514                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   515                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   516                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   517                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   518                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   519                                  parm_block_size equ	11		;AN000; size of message subst block
   520                                  blank		equ	" "             ;AN000; blank character
   521                                  no_subst	equ	0		;AN000; no substitutions for messages
   522                                  one_subst	equ	1		;AN000; one substitution for messages
   523                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   524                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   525                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   526                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   527                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   528                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   529                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   530                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   531                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   532                                  capital_A	equ	'A'             ;AC000;
   533                                  vbar		equ	'|'             ;AC000;
   534                                  labracket	equ	'<'             ;AC000;
   535                                  rabracket	equ	'>'             ;AC000;
   536                                  dollar		equ	'$'             ;AC000;
   537                                  lparen		equ	'('             ;AC000;
   538                                  rparen		equ	')'             ;AC000;
   539                                  nullrparen	equ	29h		;AC000;
   540                                  in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
   541                                  do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
   542                                  star		equ	'*'             ;AC000;
   543                                  plus_chr	equ	'+'             ;AC000;
   544                                  small_a 	equ	'a'             ;AC000;
   545                                  small_z 	equ	'z'             ;AC000;
   546                                  dot_chr 	equ	'.'             ;AC000;
   547                                  tab_chr 	equ	9		;AN032;
   548                                  equal_chr	equ	'='             ;AN032;
   549                                  semicolon	equ	';'             ;AN049;
   550                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   551                                  dot_colon	equ	2e3ah		;AC000; '.:'
   552                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   553                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   554                                  AppendInstall	equ	0B700H		;AN020; append install check
   555                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   556                                  AppendGetState	equ	0B706H		;AN020; append get current state
   557                                  AppendSetState	equ	0B707H		;AN020; append set current state
   558                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   559                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   560                                  
   561                                  ;*************************************
   562                                  ;* PARSE ERROR MESSAGES
   563                                  ;*************************************
   564                                  
   565                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   566                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   567                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   568                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   569                                  
   570                                  ;*************************************
   571                                  ;* EQUATES FOR MESSAGE RETRIEVER
   572                                  ;*************************************
   573                                  
   574                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   575                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   576                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   577                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   578                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   579                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   580                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   581                                  
   582                                  ;*********************************
   583                                  ;* EQUATES FOR INT 10H
   584                                  ;*********************************
   585                                  
   586                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   587                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   588                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   589                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   590                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   591                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   592                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   593                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   594                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   595                                  
   596                                  AltPipeChr	equ	"|"             ; alternate pipe character
   597                                  
   598                                  FCB		equ	5Ch
   599                                  
   600                                  STRUC VARSTRUC
   601 00000000 ??                      .ISDIR:		RESB	1
   602 00000001 ??                      .SIZ:		RESB	1
   603 00000002 ????                    .TTAIL:		RESW	1
   604 00000004 ??                      .INFO:		RESB	1
   605 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   606                                  .size:
   607                                  ENDSTRUC
   608                                  ;
   609                                  ; Flags for internal command parsing
   610                                  ;
   611                                  fCheckDrive	equ	00000001b	; validate drive letter
   612                                  fSwitchAllowed	equ	00000010b	; switches allowed
   613                                  fLimitHelp	equ	00000100b	; /? must appear alone
   614                                  
   615                                  ;
   616                                  ; Test switches
   617                                  ;
   618                                  fParse		EQU	0001h		; display results of parseline
   619                                  
   620                                  ;
   621                                  ; Batch segment structure
   622                                  ;
   623                                  ;   BYTE    type of segment
   624                                  ;   BYTE    echo state of parent on entry to batch file
   625                                  ;   WORD    segment of last batch file
   626                                  ;   WORD    segment for FOR command
   627                                  ;   BYTE    FOR flag state on entry to batch file
   628                                  ;   DWORD   offset for next line
   629                                  ;   10 WORD pointers to parameters. -1 is empty parameter
   630                                  ;   ASCIZ   file name (with . and ..)
   631                                  ;   BYTES   CR-terminated parameters
   632                                  ;   BYTE    0 flag to indicate end of parameters
   633                                  ;
   634                                  
   635                                  BATCHTYPE   equ 0
   636                                  
   637                                  STRUC BATCHSEGMENT
   638 00000000 ??                      .BatType:	RESB	1		; signature
   639 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   640                                  ; MSDOS 5.0 (& 6.0) - 11/01/2023
   641 00000002 ??                      .BatchEOF:	RESB	1		; records if EOF reached on file
   642 00000003 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   643 00000005 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   644 00000007 ??                      .BatForFlag:	RESB	1		; G state of FOR
   645 00000008 ????????                .BatSeek:	RESD	1		; lseek position of next char
   646 0000000C <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   647 00000020 ??                      .BatFile:	RESB	1		; beginning of batch file name
   648                                  .SIZE:
   649                                  ENDSTRUC
   650                                  
   651                                  ANULL		equ	0		; terminates an argv string
   652                                  ARGMAX		equ	64		; max args on a command line
   653                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   654                                  tplen		equ	64		; max size of one argument
   655                                  arg_cnt_error	equ	1		; number of args > MAXARG
   656                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   657                                  
   658                                  STRUC ARGV_ELE				; elements in the argv array
   659 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   660 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   661 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   662 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   663 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   664 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   665                                  .SIZE:
   666                                  ENDSTRUC
   667                                  
   668                                  STRUC ARG_UNIT
   669 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   670 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   671 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   672 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   673 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   674                                  .SIZE:
   675                                  ENDSTRUC
   676                                  
   677                                  ; Equates for initialization
   678                                  ;
   679                                  INITINIT	equ	01h		; initialization in progress
   680                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   681                                  INITCTRLC	equ	04h		; already in ^C handler
   682                                  
   683                                  ;============================================================================
   684                                  ;  INTNAT.INC, MSDOS 6.0, 1991
   685                                  ;============================================================================
   686                                  ; 16/04/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 
   687                                  
   688                                  ; Current structure of the data returned by the international call
   689                                  
   690                                  struc INTERNAT_BLOCK
   691 00000000 ????                    .date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
   692 00000002 ??????????              .currency_sym:	resb 5			; Currency Symbol 5 bytes
   693 00000007 ????                    .thous_sep:	resb 2			; Thousands separator 2 bytes
   694 00000009 ????                    .decimal_sep:	resb 2			; Decimal separator 2 bytes
   695 0000000B ????                    .date_sep:	resb 2			; Date separator 2 bytes
   696 0000000D ????                    .time_sep:	resb 2			; Decimal separator 2 bytes
   697 0000000F ??                      .bit_field:	resb 1			; Bit values
   698                                  					;   Bit 0 = 0 if currency symbol first
   699                                  					;	  = 1 if currency symbol last
   700                                  					;   Bit 1 = 0 if No space after currency symbol
   701                                  					;	  = 1 if space after currency symbol
   702                                  .currency_cents:
   703 00000010 ??                      		resb 1			; Number of places after currency dec point
   704 00000011 ??                      .time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
   705 00000012 ????????                .map_call:	resw 2			; Address of case mapping call (DWORD)
   706                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   707                                  					;  in pieces.
   708 00000016 ??                      .data_sep:	resb 1			; Data list separator character
   709 00000017 ??                      		resb 1
   710                                  endstruc
   711                                  
   712                                  ; Max size of the block returned by the INTERNATIONAL call
   713                                  
   714                                  internat_block_max equ 32
   715                                  
   716                                  ;============================================================================
   717                                  ; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
   718                                  ;============================================================================
   719                                  ; 13/10/2018 - Retro DOS v3.0
   720                                  ; 16/02/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 
   721                                  
   722                                  ;Break	<find first/next buffer>
   723                                  
   724                                  	; MSDOS 3.3 & MSDOS 6.0
   725                                  
   726                                  struc FIND_BUF
   727 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   728 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   729 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   730 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   731 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   732 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   733 00000015 ??                      .ATTR:	    resb 1	; attribute found
   734 00000016 ????                    .TIMR:	    resw 1	; time
   735 00000018 ????                    .DATE:	    resw 1	; date
   736 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   737 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   738 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   739                                  .size:
   740                                  endstruc
   741                                  
   742                                  ;=============================================================================
   743                                  ; PDB.INC, MSDOS 6.0, 1991
   744                                  ;=============================================================================
   745                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   746                                  
   747                                  ;**	Process data block (otherwise known as program header)
   748                                  
   749                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   750                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   751                                  ;	for use.
   752                                  
   753                                  FILPERPROC	EQU     20
   754                                  
   755                                  struc PDB	; Process_data_block
   756 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   757 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   758 00000004 ??                                      resb 1
   759 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   760 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   761 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   762 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   763 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   764 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   765 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   766 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   767 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   768 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   769 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   770 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   771 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   772 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   773 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   774 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   775 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   776 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   777                                  				;  an extended FCB
   778                                  ;endstruc 	; MSDOS 3.3
   779                                  	  	; MSDOS 6.0
   780 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   781 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   782 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   783 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   784                                  endstruc
   785                                  
   786                                  ;=============================================================================
   787                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   788                                  ;=============================================================================
   789                                  ; 24/09/2018 - Retro DOS v3.0
   790                                  
   791                                  ;major_version	equ 6		; Major DOS version
   792                                  ;minor_version	equ 0		; Minor DOS Version
   793                                  
   794                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   795                                  
   796                                  ; MSDOS 3.3 COMMAND.COM
   797                                  ;MAJOR_VERSION	EQU 3
   798                                  ;MINOR_VERSION	EQU 30
   799                                  
   800                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
   801                                  MAJOR_VERSION	EQU 5		; Major DOS version
   802                                  MINOR_VERSION	EQU 0		; Minor DOS version
   803                                  
   804                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   805                                  
   806                                  ;-----------------------------------------------------------------------------
   807                                  ; 21/09/2018
   808                                  ;-----------------------------------------------------------------------------
   809                                  ; Retro DOS v3.0 NOTE:  
   810                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   811                                  ;	with minor modifications which are done by me (Erdogan Tan).
   812                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   813                                  ;	source code files (written by using MASM syntax).
   814                                  ;-----------------------------------------------------------------------------
   815                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   816                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   817                                  ;----------------------------------------------------------------------------- 	
   818                                  
   819                                  ;=============================================================================
   820                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   821                                  ;=============================================================================
   822                                  ; 21/09/2018 - Retro DOS v3.0
   823                                  
   824                                  ;	page ,132
   825                                  ;	title	COMMAND - resident code for COMMAND.COM
   826                                  ;	name	COMMAND
   827                                  
   828                                  ;/*
   829                                  ; *                      Microsoft Confidential
   830                                  ; *                      Copyright (C) Microsoft Corporation 1991
   831                                  ; *                      All Rights Reserved.
   832                                  ; */
   833                                  
   834                                  ;*****************************************************************************
   835                                  ;
   836                                  ; MODULE:	       COMMAND.COM
   837                                  ;
   838                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   839                                  ;
   840                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   841                                  ;		       parts.  First is the resident portion, which includes
   842                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   843                                  ;		       error), and 2EH (command line execute); it also has
   844                                  ;		       code to test and, if necessary, reload the transient
   845                                  ;		       portion. Following the resident is the init code, which
   846                                  ;		       is overwritten after use.  Then comes the transient
   847                                  ;		       portion, which includes all command processing (whether
   848                                  ;		       internal or external).  The transient portion loads at
   849                                  ;		       the end of physical memory, and it may be overlayed by
   850                                  ;		       programs that need as much memory as possible. When the
   851                                  ;		       resident portion of command regains control from a user
   852                                  ;		       program, a check sum is performed on the transient
   853                                  ;		       portion to see if it must be reloaded.  Thus programs
   854                                  ;		       which do not need maximum memory will save the time
   855                                  ;		       required to reload COMMAND when they terminate.
   856                                  ;
   857                                  ; ENTRY POINT:	       PROGSTART
   858                                  ;
   859                                  ; INPUT:	       command line at offset 81H
   860                                  ;
   861                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   862                                  ;		       from a secondary command processor via the EXIT
   863                                  ;		       internal command.
   864                                  ;
   865                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   866                                  ;		       hang the system.
   867                                  ;
   868                                  ; INTERNAL REFERENCES:
   869                                  ;
   870                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   871                                  ;		       (COMMAND.DOC)
   872                                  ;
   873                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   874                                  ;		       (COMMAND.DOC)
   875                                  ;
   876                                  ; EXTERNAL REFERENCES:
   877                                  ;
   878                                  ;      ROUTINES:       none
   879                                  ;
   880                                  ;      DATA AREAS:     none
   881                                  ;
   882                                  ;*****************************************************************************
   883                                  ;
   884                                  ;			      REVISION HISTORY
   885                                  ;			      ----------------
   886                                  ;
   887                                  ; DOS 1.00 to DOS 3.30
   888                                  ; --------------------------
   889                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   890                                  ;
   891                                  ; REV 1.17
   892                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   893                                  ;	       resident since the EXELOAD may have overwritten the transient.
   894                                  ;
   895                                  ; REV 1.18
   896                                  ;    05/21/82  IBM version always looks on drive A
   897                                  ;	       MSVER always looks on default drive
   898                                  ;
   899                                  ; REV 1.19
   900                                  ;    06/03/82  Drive spec now entered in command line
   901                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   902                                  ;	       (print volume label)
   903                                  ;
   904                                  ; REV 1.20
   905                                  ;    06/09/82  Prints "directory" after directories
   906                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   907                                  ;
   908                                  ; REV 1.50
   909                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   910                                  ;	       do it right.
   911                                  ;
   912                                  ; REV 1.70
   913                                  ;	       EXEC used to fork off new processes
   914                                  ;
   915                                  ; REV 1.80
   916                                  ;	       C switch for single command execution
   917                                  ;
   918                                  ; REV 1.90
   919                                  ;	       Batch uses XENIX
   920                                  ;
   921                                  ; Rev 2.00
   922                                  ;	       Lots of neato stuff
   923                                  ;	       IBM 2.00 level
   924                                  ;
   925                                  ; Rev 2.01
   926                                  ;	       'D' switch for date time suppression
   927                                  ;
   928                                  ; Rev 2.02
   929                                  ;	       Default userpath is NUL rather than BIN
   930                                  ;		       same as IBM
   931                                  ;	       COMMAND split into pieces
   932                                  ;
   933                                  ; Rev 2.10
   934                                  ;	       INTERNATIONAL SUPPORT
   935                                  ;
   936                                  ; Rev 2.50
   937                                  ;	       all the 2.x new stuff -MU
   938                                  ;
   939                                  ; Rev 3.30     (Ellen G)
   940                                  ;	       CALL internal command (TBATCH2.ASM)
   941                                  ;	       CHCP internal command (TCMD2B.ASM)
   942                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   943                                  ;	       @ sign suppression of batch file line
   944                                  ;	       Replaceable environment value support in batch files
   945                                  ;	       INT 2FH calls for APPEND
   946                                  ;	       Lots of PTR fixes!
   947                                  ;
   948                                  ; Beyond 3.30 to forever  (Ellen G)
   949                                  ; ----------------------
   950                                  ;
   951                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   952                                  ;			Use Message Retriever services
   953                                  ;			/MSG switch for resident extended error msg
   954                                  ;			Convert to new capitalization support
   955                                  ;			Better error recovery on CHCP command
   956                                  ;			Code page file tag support
   957                                  ;			TRUENAME internal command
   958                                  ;			Extended screen line support
   959                                  ;			/P switch on DEL/ERASE command
   960                                  ;			Improved file redirection error recovery
   961                                  ;	(removed)	Improved batch file performance
   962                                  ;			Unconditional DBCS support
   963                                  ;			Volume serial number support
   964                                  ;	(removed)	COMMENT=?? support
   965                                  ;
   966                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   967                                  ;
   968                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   969                                  ;			require delimiters.
   970                                  ;
   971                                  ; A003	PTM P5,P9,P111	Included in A000 development
   972                                  ;
   973                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   974                                  ;			executing
   975                                  ;
   976                                  ; A005	DCR D17 	If user specifies an extension on the command
   977                                  ;			line search for that extension only.
   978                                  ;
   979                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   980                                  ;			exists"
   981                                  ;
   982                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   983                                  ;
   984                                  ; A008	PTM P182	Change COPY to set default if invalid function
   985                                  ;			returned from code page call.
   986                                  ;
   987                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   988                                  ;
   989                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   990                                  ;			transient COMMAND.
   991                                  ;
   992                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   993                                  ;			before appending to a file.
   994                                  ;
   995                                  ; A012	PTM P189	Fix redirection error recovery.
   996                                  ;
   997                                  ; A013	PTM P330	Change date format
   998                                  ;
   999                                  ; A014	PTM P455	Fix echo parsing
  1000                                  ;
  1001                                  ; A015	PTM P517	Fix DIR problem with * vs *.
  1002                                  ;
  1003                                  ; A016	PTM P354	Fix extended error message addressing
  1004                                  ;
  1005                                  ; A017	PTM P448	Fix appending to 0 length files
  1006                                  ;
  1007                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
  1008                                  ;			the parser fails on. Fail on duplicate switches.
  1009                                  ;
  1010                                  ; A019	PTM P542	Fix device name to be printed correctly during
  1011                                  ;			critical error
  1012                                  ;
  1013                                  ; A020	DCR D43 	Set append state off while in DIR
  1014                                  ;
  1015                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
  1016                                  ;
  1017                                  ; A022	DCR D209	Enhanced error recovery
  1018                                  ;
  1019                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
  1020                                  ;
  1021                                  ; A024	PTM P899	Fix EXTOPEN open modes.
  1022                                  ;
  1023                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
  1024                                  ;
  1025                                  ; A026	DCR D191	Change redirection error recovery support.
  1026                                  ;
  1027                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
  1028                                  ;			with a carriage return.
  1029                                  ;
  1030                                  ; A028	PTM P1076	Print a blank line before printing invalid
  1031                                  ;			date and invalid time messages.
  1032                                  ;
  1033                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
  1034                                  ;			and TIME.
  1035                                  ;
  1036                                  ; A030	DCR D201	New extended attribute format.
  1037                                  ;
  1038                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
  1039                                  ;
  1040                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
  1041                                  ;
  1042                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
  1043                                  ;
  1044                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
  1045                                  ;
  1046                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
  1047                                  ;			do a read to determine eof.
  1048                                  ;
  1049                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
  1050                                  ;			so that ASSIGN works correctly.
  1051                                  ;
  1052                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
  1053                                  ;
  1054                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
  1055                                  ;
  1056                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
  1057                                  ;
  1058                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
  1059                                  ;			specified.
  1060                                  ;
  1061                                  ; A041	PTM P1705	Close redirected files after internal APPEND
  1062                                  ;			executes.
  1063                                  ;
  1064                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
  1065                                  ;			files causing loss of batch file.
  1066                                  ;
  1067                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1068                                  ;			CALL'ed batch files.
  1069                                  ;
  1070                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1071                                  ;			as an end of line character
  1072                                  ;
  1073                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1074                                  ;			and extended message pointers when we EXIT if
  1075                                  ;			COMMAND /P is the top level process.
  1076                                  ;
  1077                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1078                                  ;			"File not found - fn"
  1079                                  ;
  1080                                  ; A047	PTM P2819	Fix transient reload prompt message
  1081                                  ;
  1082                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1083                                  ;			when DBCS code was added.
  1084                                  ;
  1085                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1086                                  ;			on line.
  1087                                  ;
  1088                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1089                                  ;
  1090                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1091                                  ;
  1092                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1093                                  ;
  1094                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1095                                  ;
  1096                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1097                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1098                                  ;
  1099                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1100                                  ;			problems with breaking out of INT 24h
  1101                                  ;
  1102                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1103                                  ;
  1104                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1105                                  ;			before the "string".  EX: COMMAND /CDIR
  1106                                  ;
  1107                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1108                                  ;			DBCS switch.
  1109                                  ;
  1110                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1111                                  ;			the time.
  1112                                  ;
  1113                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1114                                  ;			messages to be disk based.  Only keep them if /MSG
  1115                                  ;			is used.
  1116                                  ;
  1117                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1118                                  ;			out of internal commands, due to substitution blocks
  1119                                  ;			not being reset.
  1120                                  ;
  1121                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1122                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1123                                  ;			secondary copy of environment.	Change default slash in
  1124                                  ;			default comspec string to backslash.
  1125                                  ;
  1126                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1127                                  ;			text for critical error messages.
  1128                                  ;
  1129                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1130                                  ;	5/20/88 	with Microsoft product already shipped.
  1131                                  ;
  1132                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1133                                  ;	 5/20/88	with Microsoft product already shipped.
  1134                                  ;
  1135                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1136                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1137                                  ;			header and space remaining.
  1138                                  ;
  1139                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1140                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1141                                  ;			environment was putting a "Z block" marker in the old
  1142                                  ;			environment.  The fix is to move to the old environment
  1143                                  ;			to the new environment before doing the SETBLOCK.
  1144                                  ;
  1145                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1146                                  ;        09/19/88       because the check for APPEND needed to be performed
  1147                                  ;                       before the DIR's findfirst.
  1148                                  ;
  1149                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1150                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1151                                  ;                       loading trans w/new comspec with no user change comspec.
  1152                                  ;
  1153                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1154                                  ;        11/05/88       Expansion of environment variables into batch line of
  1155                                  ;                       128 chars was not being counted and "%" which should be
  1156                                  ;                       ignored were being counted.
  1157                                  ;
  1158                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1159                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1160                                  ;                       ing included in checksum and was being overwritten by
  1161                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1162                                  ;                       Also removed fix A069 (because flag now protected).
  1163                                  ;
  1164                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1165                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1166                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1167                                  ;
  1168                                  ;***********************************************************************************
  1169                                  
  1170                                  ;
  1171                                  ;	Revision History
  1172                                  ;	================
  1173                                  ;
  1174                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1175                                  ;					at init time (date/time prompt)
  1176                                  ;
  1177                                  
  1178                                  ;
  1179                                  ;.xcref
  1180                                  ;.xlist
  1181                                  ;	include dossym.inc		; basic DOS symbol set
  1182                                  ;	include syscall.inc		; DOS function names
  1183                                  ;	include comsw.asm		; build version info
  1184                                  ;	include comequ.asm		; common command.com symbols
  1185                                  ;	include resmsg.equ		; resident message names
  1186                                  ;
  1187                                  ;	include comseg.asm		;segment ordering
  1188                                  ;.list
  1189                                  ;.cref
  1190                                  
  1191                                  ;CODERES segment public byte
  1192                                  ;CODERES ends
  1193                                  ;
  1194                                  ;DATARES 	segment public byte
  1195                                  ;		extrn	AccDen:byte
  1196                                  ;		extrn	Batch:word
  1197                                  ;		extrn	EchoFlag:byte
  1198                                  ;		extrn	ExeBad:byte
  1199                                  ;		extrn	ExecEMes:byte
  1200                                  ;		extrn	ExecErrSubst:byte
  1201                                  ;		extrn	ExtCom:byte
  1202                                  ;		extrn	ForFlag:byte
  1203                                  ;		extrn	IfFlag:byte
  1204                                  ;		extrn	InitFlag:BYTE
  1205                                  ;		extrn	Nest:word
  1206                                  ;		extrn	PipeFlag:byte
  1207                                  ;		extrn	RBadNam:byte
  1208                                  ;		extrn	RetCode:word
  1209                                  ;		extrn	SingleCom:word
  1210                                  ;		extrn	TooBig:byte
  1211                                  ;
  1212                                  ;		extrn	OldDS:word
  1213                                  ;
  1214                                  ;DATARES 	ends
  1215                                  ;
  1216                                  ;
  1217                                  ;INIT		segment public para
  1218                                  ;		extrn	ConProc:near
  1219                                  ;		extrn	Init_Contc_SpecialCase:near
  1220                                  ;INIT		ends
  1221                                  
  1222                                  ; 09/01/2023 - Erdogan Tan - Istanbul
  1223                                  ; --------------------------------------
  1224                                  ; 'command5.s' source code reference(s):
  1225                                  
  1226                                  ;	1) MSDOS 6.0 COMMAND.COM source files
  1227                                  ;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
  1228                                  ;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
  1229                                  ; ----------------------------------------------------------------------				 	 	
  1230                                  
  1231                                  ; ----------------------------------------------------------------------------
  1232                                  ; START OF RESIDENT PORTION
  1233                                  ; ----------------------------------------------------------------------------
  1234                                  ; SEGMENT - DATARES
  1235                                  ; ----------------------------------------------------------------------------
  1236                                  
  1237                                  section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 
  1238                                  
  1239                                  ; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)
  1240                                  
  1241                                  ; ----------------------------------------------------------------------------
  1242                                  ; STUB.ASM - MSDOS 6.0 - 1991
  1243                                  ; ----------------------------------------------------------------------------
  1244                                  
  1245                                  ;This file contains the low memory stub for command.com which hooks all the
  1246                                  ;entry points into the resident command.com and directs the calls to the
  1247                                  ;appropriate routines in the resident code which may be located in HIMEM. 
  1248                                  ;
  1249                                  ;The stub has been made part of the resident data and will always
  1250                                  ;be duplicated on every invocation of command.com. However, the only stubs
  1251                                  ;that actually hook the interrupt vectors belong to either the first 
  1252                                  ;command.com or to any other command.com executed with the /p switch. 
  1253                                  ;
  1254                                  ;The stub also keeps track of the current active data segment. The 
  1255                                  ;INIT code of each command.com updates this variable via an int 2fh mechanism
  1256                                  ;with its own data segment. The INIT code also updates a pointer in its data
  1257                                  ;segment to the previous resident data segment. Whenever a command.com exits,
  1258                                  ;the exit code picks up the previous data segment pointer from the current
  1259                                  ;data segment and patches it into the CurResDataSeg variable in the stub.
  1260                                  ;
  1261                                  ;Right now the stub does not bother about A20 switching. We assume
  1262                                  ;A20 is always on. It just does a far jump to the resident code with the 
  1263                                  ;value of the current data segment in one of the registers. A20 toggle 
  1264                                  ;support maybe added as a future enhancement, if the need is felt.
  1265                                  
  1266                                  	; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1267                                  
  1268                                  	[ORG 100H]
  1269                                  
  1270                                  	; 21/09/2018 - Retro DOS v3.0
  1271                                  StartCode:
  1272 00000000 E91D14                  	jmp	ConProc	; 10/01/2023 
  1273                                  
  1274                                  	; 09/01/2023
  1275                                  
  1276                                  ; Make following table word-aligned, and at the same time, provide a
  1277                                  ; signature that sysinit can use to (attempt to) validate the interpreter
  1278                                  
  1279                                  	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
  1280 00000003 50                      	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  1281                                  
  1282                                  ;All the entry points declared below are patched in at INIT time with the
  1283                                  ;proper segment and offset values after the resident code segment has been
  1284                                  ;moved to its final location
  1285                                  
  1286                                  ;!!!WARNING!!!
  1287                                  ; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
  1288                                  ;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
  1289                                  ;in the correct segments and offsets
  1290                                  
  1291                                  Int2f_Entry:
  1292 00000004 [3313]                  	dw	MsgInt2fHandler		; Address of int 2fh handler
  1293 00000006 0000                    	dw	0
  1294                                  Int2e_Entry:
  1295 00000008 [860D]                  	dw	Int_2e			; Address of int 2eh handler
  1296 0000000A 0000                    	dw	0
  1297                                  Ctrlc_Entry:
  1298 0000000C [430C]                  	dw	ContC			; Address of Ctrl-C handler
  1299 0000000E 0000                    	dw	0
  1300                                  CritErr_Entry:
  1301 00000010 [4710]                  	dw	DSKERR			; Address of critical error handler
  1302 00000012 0000                    	dw	0
  1303                                  
  1304                                  Exec_Entry:
  1305 00000014 00000000                	dd	0			; Entry from transient to Ext_Exec
  1306                                  RemCheck_Entry:
  1307 00000018 00000000                	dd	0			; Entry from transient to TRemCheck
  1308                                  TrnLodCom1_Entry:
  1309 0000001C 00000000                	dd	0			; Entry from transient to LodCom1
  1310                                  LodCom_Entry:
  1311 00000020 00000000                	dd	0			; Entry after exit from command.com
  1312                                  MsgRetrv_Entry:
  1313 00000024 00000000                	dd	0			; Entry from external to MsgRetriever
  1314                                  HeadFix_Entry:
  1315 00000028 00000000                	dd	0			; Entry from trans to HeadFix
  1316                                  UMBOff_Entry:
  1317 0000002C 00000000                	dd	0			; Entry from here to UMBOff routine; M003
  1318                                  XMMCallAddr:
  1319 00000030 00000000                	dd	0			; Call address for XMM functions
  1320                                  ComInHMA:
  1321 00000034 00                      	db	0			; Flags if command.com in HMA
  1322                                  
  1323                                  Int2f_Trap:
  1324                                  	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
  1325 00000035 E86400                  	call	CheckA20
  1326 00000038 1E                      	push	ds			; push current ds value
  1327 00000039 0E                      	push	cs			; push resident data segment value
  1328                                  	;jmp	cs:Int2f_Entry
  1329 0000003A 2EFF2E[0400]            	jmp	far [cs:Int2f_Entry]
  1330                                  
  1331                                  Int2e_Trap:
  1332 0000003F FB                      	sti
  1333 00000040 E85900                  	call	CheckA20
  1334 00000043 1E                      	push	ds			; push current ds value
  1335 00000044 0E                      	push	cs			; push resident data segment value
  1336                                  	;jmp	cs:Int2e_Entry
  1337 00000045 2EFF2E[0800]            	jmp	far [cs:Int2e_Entry]
  1338                                  
  1339                                  Ctrlc_Trap:
  1340 0000004A FB                      	sti
  1341 0000004B E84E00                  	call	CheckA20
  1342 0000004E 1E                      	push	ds			; push current ds value
  1343 0000004F 0E                      	push	cs			; push resident data segment value
  1344                                  	;jmp	cs:Ctrlc_Entry
  1345 00000050 2EFF2E[0C00]            	jmp	far [cs:Ctrlc_Entry]
  1346                                  
  1347                                  CritErr_Trap:
  1348 00000055 FB                      	sti
  1349 00000056 E84300                  	call	CheckA20
  1350 00000059 1E                      	push	ds			; push current ds value
  1351 0000005A 0E                      	push	cs			; push resident data segment value
  1352                                  	;jmp	cs:CritErr_Entry
  1353 0000005B 2EFF2E[1000]            	jmp	far [cs:CritErr_Entry]
  1354                                  
  1355                                  Exec_Trap:
  1356 00000060 E83900                  	call	CheckA20
  1357 00000063 1E                      	push	ds			; push current ds value
  1358 00000064 0E                      	push	cs			; push resident data segment value
  1359                                  	;jmp	cs:Exec_Entry
  1360 00000065 2EFF2E[1400]            	jmp	far [cs:Exec_Entry]
  1361                                  
  1362                                  RemCheck_Trap:
  1363 0000006A E82F00                  	call	CheckA20
  1364 0000006D 1E                      	push	ds			; push current ds value
  1365 0000006E 0E                      	push	cs			; push resident data segment value
  1366                                  	;jmp	cs:RemCheck_Entry
  1367 0000006F 2EFF2E[1800]            	jmp	far [cs:RemCheck_Entry]
  1368                                  
  1369                                  TrnLodCom1_Trap:
  1370 00000074 E82500                  	call	CheckA20
  1371 00000077 1E                      	push	ds			; push current ds value
  1372 00000078 0E                      	push	cs			; push resident data segment value
  1373                                  	;jmp	cs:TrnLodCom1_Entry
  1374 00000079 2EFF2E[1C00]            	jmp	far [cs:TrnLodCom1_Entry]
  1375                                  
  1376                                  LodCom_Trap:
  1377 0000007E E81B00                  	call	CheckA20
  1378 00000081 1E                      	push	ds			; push current ds value
  1379 00000082 0E                      	push	cs			; push resident data segment value
  1380                                  	;jmp	cs:LodCom_Entry
  1381 00000083 2EFF2E[2000]            	jmp	far [cs:LodCom_Entry]
  1382                                  
  1383                                  MsgRetrv_Trap:
  1384 00000088 E81100                  	call	CheckA20
  1385 0000008B 1E                      	push	ds			; push current ds value
  1386 0000008C 0E                      	push	cs			; push resident data segment value
  1387                                  	;jmp	cs:MsgRetrv_Entry
  1388 0000008D 2EFF2E[2400]            	jmp	far [cs:MsgRetrv_Entry]
  1389                                  
  1390                                  HeadFix_Trap:
  1391 00000092 E80700                  	call	CheckA20
  1392 00000095 1E                      	push	ds			; push current ds value
  1393 00000096 0E                      	push	cs			; push resident data segment value
  1394                                  	;jmp	cs:HeadFix_Entry
  1395 00000097 2EFF2E[2800]            	jmp	far [cs:HeadFix_Entry]
  1396                                  
  1397                                  ; ----------------------------------------------------------------------------
  1398                                  
  1399                                  	; 09/01/2023
  1400                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh
  1401                                  
  1402                                  CheckA20:
  1403 0000009C 9C                      	pushf				; save current flags
  1404 0000009D 2E803E[3400]00          	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1405 000000A3 7408                    	jz	short A20_on		; no, jump to resident
  1406                                  
  1407 000000A5 E80C00                  	call	QueryA20
  1408 000000A8 7303                    	jnc	short A20_on		; A20 is on, jump to resident
  1409                                  
  1410 000000AA E81800                  	call	EnableA20		; turn A20 on
  1411                                  A20_on:
  1412 000000AD 9D                      	popf				; flags have to be unchanged
  1413 000000AE C3                      	retn
  1414                                  
  1415                                  ; ----------------------------------------------------------------------------
  1416                                  
  1417                                  ; M005; This is a far jump to the actual int 2fh entry point. The renormalized
  1418                                  ; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
  1419                                  ; M005; handler. Note that we have to hardcode a jump and we cannot use any
  1420                                  ; M005; pointers because our cs is going to be different. The segment to
  1421                                  ; M005; jump to is patched in at init time. (in init.asm)
  1422                                  
  1423                                  Carousel_i2f_Hook:			; M005
  1424 000000AF EA                      	db	0EAh			; far jump opcode; M005
  1425 000000B0 [3500]                  	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
  1426 000000B2 0000                    	dw	0			; int 2fh segment; M005
  1427                                  
  1428                                  ; ----------------------------------------------------------------------------
  1429                                  
  1430                                  XMM_QUERY_A20 equ 7 ; 09/01/2023
  1431                                  
  1432                                  QueryA20:
  1433 000000B4 53                      	push	bx
  1434 000000B5 50                      	push	ax
  1435                                  	;mov	ah,7
  1436 000000B6 B407                    	mov	ah,XMM_QUERY_A20
  1437                                  	;call	cs:XMMCallAddr
  1438 000000B8 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1439 000000BD 09C0                    	or	ax,ax
  1440 000000BF 58                      	pop	ax
  1441 000000C0 5B                      	pop	bx
  1442                                  	; 16/04/2023
  1443 000000C1 7501                    	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON
  1444                                  
  1445 000000C3 F9                      	stc					; OFF
  1446                                  	;retn
  1447                                  QA20_ON:
  1448                                  	;clc					; ON
  1449 000000C4 C3                      	retn
  1450                                  
  1451                                  ; ----------------------------------------------------------------------------
  1452                                  
  1453                                  XMM_LOCAL_ENABLE_A20 equ 5
  1454                                  
  1455                                  EnableA20:
  1456 000000C5 53                      	push	bx
  1457 000000C6 50                      	push	ax
  1458                                  	;mov	ah,5
  1459 000000C7 B405                    	mov	ah,XMM_LOCAL_ENABLE_A20
  1460                                  	;call	cs:XMMCallAddr
  1461 000000C9 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1462 000000CE 09C0                    	or	ax,ax
  1463 000000D0 7403                    	jz	short XMMerror			; AX = 0 fatal error
  1464 000000D2 58                      	pop	ax
  1465 000000D3 5B                      	pop	bx
  1466 000000D4 C3                      	retn
  1467                                  
  1468                                  ;If we get an error, we just loop forever
  1469                                  
  1470                                  XMMerror:
  1471 000000D5 EBFE                    	jmp	short XMMerror
  1472                                  
  1473                                  ; -----------------------------------------------------------------------------
  1474                                  
  1475                                  HV_Extern   equ	1
  1476                                  HV_LoadHigh equ	1
  1477                                  HV_Stub	    equ	1
  1478                                  
  1479                                  	; 09/01/2023 - Retro DOS v4.0 (& 4.1)
  1480                                  
  1481                                  ;The Exec call has to be issued from the data segment. The reason for this 
  1482                                  ;is TSRs. When a TSR does a call to terminate and stay resident, the call
  1483                                  ;returns with all registers preserved and so all our segment registers are
  1484                                  ;still set up. However, if the TSR unloads itself later on, it still 
  1485                                  ;comes back here. In this case the segment registers and the stack are
  1486                                  ;not set up and random things can happen. The only way to setup all the 
  1487                                  ;registers is to use the cs value and this can only be done when we are in
  1488                                  ;the data segment ourselves. So, this piece of code had to be moved from
  1489                                  ;the code segment to the data segment.
  1490                                  
  1491                                  Issue_Exec_Call:
  1492 000000D7 CD21                    	int 	21h
  1493                                  
  1494                                  ;We disable interrupts while changing the stack because there is a bug in 
  1495                                  ;some old 8088 processors where interrupts are let through while ss & sp
  1496                                  ;are being changed.
  1497                                  
  1498 000000D9 FA                      	cli
  1499 000000DA 0E                      	push	cs
  1500 000000DB 17                      	pop	ss
  1501                                  	;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
  1502                                  	;mov	sp,offset DATARES:RStack ; stack is set up
  1503 000000DC BC[3804]                	mov	sp,RStack		; stack is set up
  1504                                  	
  1505                                  	; 20/04/2023
  1506                                  	;sti
  1507                                  	;push	cs
  1508                                  	;pop	ds			; ds = DATARES
  1509                                  
  1510                                  ; M009; Restore UMB state to that before Exec
  1511                                  
  1512                                  	;pushf				;    This call frees HIDDEN umb's,
  1513                                  	;call	UnHideUMBs		; <- restores the memory-allocation
  1514                                  	;popf				;    strategy and link state, as app.
  1515                                  
  1516                                  	; 09/01/2023 - Retro DOS v4.0
  1517                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
  1518                                  	; ----------------------
  1519 000000DF FB                      	sti
  1520                                  	
  1521 000000E0 0E                      	push    cs
  1522 000000E1 1F                      	pop     ds
  1523 000000E2 9C                      	pushf
  1524                                  	;mov	al,[cs:fInHigh]
  1525                                  	; 18/04/2023
  1526 000000E3 A0[3A04]                	mov	al,[fInHigh]
  1527 000000E6 A880                    	test	al,80h
  1528 000000E8 7406                    	jz      short uhu10
  1529 000000EA 247F                    	and     al,7Fh
  1530                                  	;;call	cs:UMBOff_Entry
  1531                                  	;call	far [cs:UMBOff_Entry]
  1532 000000EC FF1E[2C00]              	call	far [UMBOff_Entry]
  1533                                  uhu10:
  1534                                  	;and	byte [cs:fInHigh],7Fh
  1535                                  	; 18/04/2023
  1536 000000F0 8026[3A04]7F            	and	byte [fInHigh],7Fh
  1537 000000F5 9D                      	popf
  1538                                  	; ----------------------
  1539                                  
  1540                                  ;We now jump to the stub trap which returns us to the resident code. All
  1541                                  ;flags are preserved by the stub code.
  1542                                  
  1543 000000F6 E967FF                  	jmp	Exec_Trap
  1544                                  
  1545                                  ; ----------------------------------------------------------------------------
  1546                                  ; RDATA.ASM, MSDOS 6.0, 1992
  1547                                  ; ----------------------------------------------------------------------------
  1548                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1549                                  
  1550                                  ;***	Message substitution blocks
  1551                                  
  1552                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)
  1553                                  
  1554                                  ;BlkDevErrSubst	label	byte
  1555                                  ;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
  1556                                  ;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter
  1557                                  
  1558 000000F9 02                      BlkDevErrSubst: db	2
  1559 000000FA 0000                    BlkDevErrRw:	dw	0
  1560 000000FC 01                      		db	1
  1561 000000FD [FF00]                  		dw	DrvLet
  1562                                  
  1563 000000FF 41                      DrvLet		db	'A'			; drive letter
  1564                                  
  1565                                  
  1566                                  ;CharDevErrSubst label	byte
  1567                                  ;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
  1568                                  ;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name
  1569                                  
  1570 00000100 02                      CharDevErrSubst: db	2
  1571 00000101 0000                    CharDevErrRw:	dw	0
  1572 00000103 02                      		db	2
  1573 00000104 [0601]                  		dw	DevName
  1574                                  
  1575 00000106 00<rep 8h>              DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
  1576 0000010E 00                      		db	0
  1577                                  
  1578                                  ;NeedVolSubst	label	byte
  1579                                  ;		subst	<STRING,DATARES:VolName> ; volume name
  1580                                  ;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
  1581                                  ;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #
  1582                                  
  1583 0000010F 02                      NeedVolSubst:	db	2
  1584 00000110 [1801]                  		dw	VolName
  1585 00000112 03                      		db	3
  1586 00000113 [2601]                  		dw	VolSer+2
  1587 00000115 03                      		db	3
  1588 00000116 [2401]                  		dw	VolSer
  1589                                  
  1590                                  	; NOTE:	VolName and VolSer must be adjacent
  1591 00000118 00<rep Bh>              VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
  1592 00000123 00                      		db	0
  1593 00000124 00000000                VolSer:		dd	0			; volume serial #
  1594                                  
  1595 00000128 00                      CDevAt:		db	0
  1596                                  
  1597                                  ;BadFatSubst	label	byte
  1598                                  ;		subst	<CHAR,DATARES:DrvLet>	; drive letter
  1599                                  
  1600 00000129 01                      BadFatSubst:	db	1
  1601 0000012A [FF00]                  		dw	DrvLet
  1602                                  
  1603                                  ;PutBackSubst	label	byte
  1604                                  ;PutBackComSpec	subst	<STRING,>		  ; comspec string
  1605                                  ;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in
  1606                                  
  1607 0000012C 02                      PutBackSubst:	db	2
  1608 0000012D 0000                    PutBackComSpec:	dw	0
  1609 0000012F 01                      		db	1
  1610 00000130 [3201]                  		dw	PutBackDrv
  1611                                  
  1612 00000132 20                      PutBackDrv	db	' '			; drive letter
  1613                                  
  1614                                  ;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>
  1615                                  
  1616 00000133 02                      ExecErrSubst:	db	2
  1617 00000134 [6303]                  		dw	SafePathBuffer
  1618                                  
  1619 00000136 00000000                NeedVol:	dd	0	; ptr to volume name from get ext err
  1620 0000013A 00                      ErrType: 	db	0	; critical error message style, 0=old, 1=new
  1621                                  
  1622 0000013B 00000000                Int_2e_Ret:	dd	0	; magic command executer return address
  1623 0000013F 0000                    Save_Pdb:	dw	0
  1624 00000141 0000                    Parent:		dw	0
  1625 00000143 00000000                OldTerm:	dd	0
  1626 00000147 0000                    ErrCd_24:	dw	0
  1627 00000149 0000                    Handle01:	dw	0
  1628 0000014B 00                      Loading:	db	0
  1629 0000014C 0000                    Batch:		dw	0	; assume no batch mode initially
  1630                                  
  1631                                  ;;;;SR;
  1632                                  ;;;; This flag has been added for a gross hack introduced in batch processing. 
  1633                                  ;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
  1634                                  ;;;;we need to fake the CR-LF for the line to be properly processed
  1635                                  ;;;;
  1636                                  ;;;BatchEOF:	db	0
  1637                                  
  1638                                  	; Bugbug: ComSpec should be 64+3+12+1?
  1639                                  	; What's this comspec_end about?
  1640 0000014E 00<rep 40h>             ComSpec:	times 64 db 0 ; db 64 dup (0)
  1641 0000018E 0000                    ComSpec_End:	dw	0
  1642                                  
  1643                                  ;Trans		label	dword
  1644                                  ;		dw	TRANGROUP:Command
  1645                                  
  1646                                  Trans:		;dw	12Ch
  1647                                  		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
  1648 00000190 [2C01]                  		dw	COMMAND ; 16/04/2023
  1649 00000192 0000                    TrnSeg:		dw	0
  1650                                  
  1651 00000194 00                      TrnMvFlg:	db	0	; set if transient portion has been moved
  1652                                  
  1653 00000195 00                      In_Batch:	db	0	; set if we are in batch processing mode
  1654 00000196 00                      Batch_Abort:	db	0	; set if user wants to abort from batch mode
  1655                                  
  1656 00000197 00                      ComDrv:		db	0	; drive spec to load autoexec and command
  1657 00000198 0000                    MemSiz:		dw	0
  1658 0000019A 0000                    Sum:		dw	0
  1659 0000019C 01                      ExtCom:		db	1	; for init, pretend just did an external
  1660 0000019D 0000                    RetCode: 	dw	0
  1661 0000019F 00                      Crit_Err_Info:	db	0	; hold critical error flags for r,i,f
  1662                                  
  1663                                  
  1664                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  1665                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  1666                                  
  1667 000001A0 01                      EchoFlag:	db	00000001b ; low bit true => echo commands
  1668 000001A1 01                      Suppress:	db	1	; used for echo, 1=echo line
  1669 000001A2 0000                    Io_Save: 	dw	0
  1670 000001A4 00                      RestDir: 	db	0
  1671 000001A5 00                      PermCom: 	db	0	; true => permanent command
  1672                                  ;SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
  1673                                  				; true => semi-permanent command (/K)
  1674 000001A6 0000                    SingleCom:	dw	0	; true => single command version
  1675 000001A8 FFFF                    VerVal:		dw	-1
  1676 000001AA 00                      fFail:		db	0	; true => fail all int 24s
  1677 000001AB 00                      IfFlag:		db	0	; true => IF statement in progress
  1678                                  
  1679 000001AC 00                      ForFlag: 	db	0	; true => FOR statement in progress
  1680 000001AD 0000                    ForPtr:		dw	0
  1681                                  
  1682 000001AF 0000                    Nest:		dw	0	; nested batch file counter
  1683 000001B1 00                      Call_Flag:	db	0	; no CALL (batch command) in progress
  1684 000001B2 00                      Call_Batch_Flag: db	0
  1685 000001B3 0000                    Next_Batch:	dw	0	; address of next batch segment
  1686 000001B5 00                      NullFlag:	db	0	; flag if no command on command line
  1687 000001B6 00<rep 5h>              FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
  1688                                  				; buffer for file ucase address
  1689                                  ; Bugbug: don't need crit_msg_ anymore?
  1690                                  
  1691 000001BB 0000                    Crit_Msg_Off:	dw	0	; saved critical error message offset
  1692 000001BD 0000                    Crit_Msg_Seg:	dw	0	; saved critical error message segment
  1693 000001BF 0000                    Dbcs_Vector_Addr: dw	0	; DBCS vector offset
  1694 000001C1 0000                    		 dw	0	; DBCS vector segment
  1695 000001C3 0000                    Append_State:	dw	0	; current state of append
  1696                                  				;  (if Append_Flag is set)
  1697 000001C5 00                      Append_Flag:	db	0	; set if append state is valid
  1698 000001C6 00                      Re_Out_App:	db	0
  1699 000001C7 00<rep 50h>             Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)
  1700                                  
  1701                                  ; We flag the state of COMMAND in order to correctly handle the ^Cs at
  1702                                  ; various times. Here is the breakdown:
  1703                                  ;
  1704                                  ;   INITINIT	We are in the init code.
  1705                                  ;   INITSPECIAL We are in the date/time prompt
  1706                                  ;   INITCTRLC	We are handling a ^C already.
  1707                                  ;
  1708                                  ; If we get a ^C in the initialization but not in the date/time prompt, we
  1709                                  ; ignore the ^C. This is so the system calls work on nested commands.
  1710                                  ;
  1711                                  ; If we are in the date/time prompt at initialization, we stuff the user's
  1712                                  ; input buffer with a CR to pretend an empty response.
  1713                                  ;
  1714                                  ; If we are already handling a ^C, we set the carry bit and return to the user
  1715                                  ; (ourselves). We can then detect the carry set and properly retry the
  1716                                  ; operation.
  1717                                  
  1718                                  InitFlag:	;db	1
  1719 00000217 01                      		db	INITINIT
  1720                                  
  1721                                  ; Note: these two bytes are referenced as a word
  1722 00000218 00                      PipeFlag:	db	0
  1723 00000219 00                      PipeFiles:	db	0
  1724                                  
  1725                                  ; (rdata.asm, msdos 6.0, 1992)
  1726                                  ; ----------------------------------------------------------------------------
  1727                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)
  1728                                  
  1729                                  
  1730                                  ;;SR
  1731                                  ;; Pipe1 & Pipe2 now need to store full-fledged pathnames
  1732                                  ;;
  1733                                  ;
  1734                                  ;; Bugbug: can we find any way around maintaining these
  1735                                  ;; large buffers?
  1736                                  ;
  1737                                  ;Pipe1		db	67+12 dup (?)
  1738                                  ;Pipe2		db	67+12 dup (?)
  1739                                  ;
  1740                                  ;PipePtr 	dw	?
  1741                                  ;
  1742                                  ;PipeStr 	db	129 dup (?)
  1743                                  ;
  1744                                  ;EndPipe	label	byte	; marks end of buffers; M004
  1745                                  ;
  1746                                  ;;SR;
  1747                                  ;; We can move our EndInit code into above buffers. This way, the code will
  1748                                  ;;automatically be discarded after init.
  1749                                  ;;
  1750                                  ;; M004; We overlap our code with the Pipe buffers located above by changing
  1751                                  ;; M004; the origin.
  1752                                  ;;
  1753                                  ;	ORG	Pipe1	; M004
  1754                                  ;
  1755                                  ;; Bugbug: really need a procedure header for EndInit, describing
  1756                                  ;; what it expects, what it does.
  1757                                  ;
  1758                                  
  1759                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  1760                                  
  1761                                  Pipe1	equ	EndInit
  1762                                  Pipe2	equ	Pipe1+67+12
  1763                                  PipePtr	equ	Pipe2+67+12
  1764                                  PipeStr	equ	PipePtr+2
  1765                                  EndPipe	equ	PipeStr+129	; EndInit+289
  1766                                  
  1767                                  ; Bugbug: really need a procedure header for EndInit, describing
  1768                                  ; what it expects, what it does.
  1769                                  
  1770                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h 
  1771                                  
  1772                                  EndInit:
  1773 0000021A 1E                      	push	ds
  1774 0000021B 06                      	push	es		; save segments
  1775 0000021C 0E                      	push	cs
  1776 0000021D 1F                      	pop	ds		
  1777                                  	;assume	ds:RESGROUP
  1778                                  
  1779                                  ; M004; Save size of transient here before INIT segment is deallocated
  1780                                  
  1781 0000021E 8B16[BF1C]              	mov	dx,[TrnSize]		; M004
  1782                                  ;M027
  1783                                  ; These variables are also defined in the INIT segment and need to be saved
  1784                                  ;before we resize
  1785                                  ;
  1786 00000222 A1[B31C]                	mov	ax,[OldEnv]	; Old Environment seg ;M027
  1787 00000225 8B1E[AF1C]              	mov	bx,[EnvSiz]	; Size of new environment ;M027
  1788 00000229 8B0E[B51C]              	mov	cx,[UsedEnv]	; Size of old environment ;M027
  1789 0000022D 50                      	push	ax		; Save all these values ;M027
  1790 0000022E 53                      	push	bx		; M027
  1791 0000022F 51                      	push	cx		; M027
  1792                                  
  1793                                  
  1794                                  ; Bugbug: push ds, pop es here.
  1795                                  	;mov	bx,ds
  1796                                  	;mov	es,bx		; es = RESGROUP
  1797                                  	; 09/01/2023
  1798 00000230 1E                      	push	ds
  1799 00000231 07                      	pop	es
  1800                                  
  1801                                  ;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  1802                                  ; code + data for low COMMAND
  1803                                  
  1804 00000232 8B1E[B903]              	mov	bx,[ResSize]	; Total size of resident
  1805 00000236 B44A                    	mov	ah,4Ah
  1806                                  	;mov	ah,SETBLOCK
  1807 00000238 CD21                    	int	21h		; Set block to resident size
  1808                                  
  1809                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  1810                                  		; ES = segment address of block to change
  1811                                  		; BX = new size in paragraphs
  1812                                  
  1813                                  ;We check if this is for autoexec.bat (PermCom = 1). If so, we then
  1814                                  ;allocate a new batch segment, copy the old one into new batchseg and free
  1815                                  ;the old batchseg. Remember that the old batchseg was allocated on top of the
  1816                                  ;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
  1817                                  ;
  1818                                  ; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
  1819                                  	
  1820 0000023A 803E[A501]01            	cmp	byte [PermCom],1 ; permanent command.com?
  1821 0000023F 7530                    	jne	short adjust_env ; no, do not free batchseg
  1822                                  
  1823 00000241 833E[4C01]00            	cmp	word [Batch],0	 ; was there a valid batchseg?
  1824 00000246 7429                    	je	short adjust_env ; no, dont juggle
  1825                                  
  1826                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ; batchseg size
  1827                                  	; 21/01/2023
  1828 00000248 BB0400                  	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  1829                                  	;mov	bx,4	; 09/01/2023
  1830                                  			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
  1831 0000024B B448                    	mov	ah,48h
  1832                                  	;mov	ah,ALLOC
  1833 0000024D CD21                    	int	21h
  1834                                  
  1835                                  		; DOS - 2+ - ALLOCATE MEMORY
  1836                                  		; BX = number of 16-byte paragraphs desired
  1837                                  
  1838                                  ; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
  1839                                  ; a hole, the batch segment COULD already be in the ideal place. We
  1840                                  ; could be making it worse! We're second-guessing where memory
  1841                                  ; allocations go, which might not be such a great idea. Is there
  1842                                  ; a strategy, short of doing something even worse like diddling
  1843                                  ; arena headers, where we can minimize the possibility of fragmentation
  1844                                  ; under all cases? Hmm..
  1845                                  	
  1846 0000024F 7220                    	jc	short adjust_env ; no memory, use old batchseg
  1847                                  
  1848 00000251 8EC0                    	mov	es,ax		 ; es = New batch segment
  1849 00000253 31FF                    	xor	di,di
  1850 00000255 31F6                    	xor	si,si
  1851                                  
  1852 00000257 1E                      	push	ds
  1853 00000258 8E1E[4C01]              	mov	ds,[Batch]	 ; ds = Old Batch Segment
  1854                                  	;assume	ds:nothing
  1855                                  	;mov	cx,SIZE BatchSegment
  1856                                  	; 23/01/2023
  1857                                  	;mov	cx,BATCHSEGMENT.SIZE
  1858                                  	;;mov	cx,33	; 09/01/2023
  1859                                  	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
  1860                                  	;
  1861                                  	;add	cx,16		 ; for the filename
  1862                                  	; 20/04/2023
  1863 0000025C B93100                  	mov	cx,BATCHSEGMENT.SIZE+16 
  1864                                  
  1865                                  	; Bugbug: 16? Shouldn't this be a common equate or something?
  1866                                  	; It's sure be bad if we copied more bytes than the batch segment
  1867                                  	; holds!
  1868                                  	
  1869 0000025F FC                      	cld
  1870 00000260 F3A4                    	rep	movsb
  1871 00000262 1F                      	pop	ds
  1872                                  	;assume	ds:RESGROUP
  1873                                  
  1874 00000263 8CC1                    	mov	cx,es		; save new batch segment 
  1875 00000265 8E06[4C01]              	mov	es,[Batch]
  1876 00000269 B449                    	mov	ah,49h
  1877                                  	;mov	ah,DEALLOC
  1878 0000026B CD21                    	int	21h		; free the old batch segment
  1879                                  
  1880                                  	; Bugbug: should we check for error?
  1881                                  
  1882 0000026D 890E[4C01]              	mov	[Batch],cx	; store new batch segment address
  1883                                  
  1884                                  adjust_env:
  1885 00000271 59                      	pop	cx		; cx = size of old env ;M027
  1886 00000272 5B                      	pop	bx		; bx = size of new env needed ;M027
  1887 00000273 5D                      	pop	bp		; bp = old env seg ;M027
  1888                                  
  1889                                  ;Allocate the correct size for the environment
  1890                                  
  1891 00000274 B448                    	mov	ah,48h
  1892                                  	;mov	ah,ALLOC
  1893 00000276 CD21                    	int	21h		; get memory
  1894 00000278 7264                    	jc	short nomem_err	; out of memory,signal error
  1895                                  	
  1896                                  	; Bugbug: why not continue, leaving environment where it is?
  1897                                  
  1898 0000027A A3[3F03]                	mov	[EnvirSeg],ax	; Store new environment segment
  1899                                  	;;mov	[ds:2Ch],ax
  1900                                  	;mov	[2Ch],ax
  1901                                  	;mov	[PDB_Environ],ax ; Put new env seg in PSP
  1902 0000027D A32C00                  	mov	[PDB.ENVIRON],ax
  1903 00000280 8EC0                    	mov	es,ax		; es = address of allocated memory
  1904                                  	;assume	es:nothing
  1905                                  
  1906                                  ;Copy the environment to the newly allocated segment
  1907                                  
  1908 00000282 1E                      	push	ds
  1909 00000283 8EDD                    	mov	ds,bp		; ds = Old environment segment
  1910                                  	;assume	ds:nothing
  1911                                  
  1912 00000285 31F6                    	xor	si,si
  1913 00000287 89F7                    	mov	di,si		; Start transfer from 0
  1914                                  
  1915 00000289 FC                      	cld
  1916 0000028A F3A4                    	rep	movsb		; Do the copy
  1917                                  
  1918 0000028C 1F                      	pop	ds		; ds = RESGROUP
  1919                                  	;assume	ds:RESGROUP
  1920                                  
  1921                                  ; We have to free the old environment block if it was allocated by INIT
  1922                                  
  1923                                  ; Bugbug: is this only for the case when we were NOT passed an environment,
  1924                                  ; or does it also apply to passed environments?
  1925                                  
  1926                                  ;M036
  1927                                  ; Free up old env segment always because this is a copy passed by Exec and
  1928                                  ; takes up memory that is never used
  1929                                  
  1930                                  ;M044
  1931                                  ; Go back to the old strategy of not freeing the environment. Freeing it leaves
  1932                                  ; a hole behind that Ventura does not like. Basically, Ventura gives strange
  1933                                  ; errors if it gets a memory alloc that it is below its load segment. The
  1934                                  ; freed environment creates a large enough hole for some of its allocs to fit
  1935                                  ; in
  1936                                  
  1937                                  	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
  1938                                          ;je	short no_free	    ; no, do not free it
  1939                                  	; 21/01/2023
  1940                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
  1941 0000028D 803E[931C]00            	cmp	byte [AllocedEnv],0 ; flag - old environment segment	
  1942 00000292 7506                    	jne	short no_free 
  1943                                  
  1944 00000294 8EC5                    	mov	es,bp
  1945 00000296 B449                    	mov	ah,49h
  1946                                  	;mov	ah,DEALLOC	
  1947 00000298 CD21                    	int	21h		    ; Free it
  1948                                  no_free:
  1949                                  
  1950                                  ; M004; Start of changes 
  1951                                  
  1952                                  ; Move the transient now. We will allocate the biggest block available
  1953                                  ; now and move the transient to the top of the block. We will then
  1954                                  ; deallocate this block. When the resident starts executing, it will
  1955                                  ; hopefully allocate this block again and find the transient intact.
  1956                                  
  1957 0000029A C606[9401]01            	mov	byte [TrnMvFlg],1   ; Indicate that transient has been moved
  1958 0000029F 06                      	push	es
  1959                                  	;;mov	si,offset ResGroup:TranStart
  1960                                  	; 09/01/2023
  1961                                  	;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
  1962 000002A0 BE4022                  	mov	si,TRANSTART	    ; (End of the resident portion)
  1963                                  	;mov	di,0
  1964 000002A3 31FF                    	xor	di,di ; 0
  1965                                  	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
  1966                                  	;mov	cx,98C5h
  1967 000002A5 B92F96                  	mov	cx,TRANSPACEEND
  1968                                  	
  1969                                  ; Find the largest block available
  1970                                  
  1971 000002A8 BBFFFF                  	mov	bx,0FFFFh
  1972 000002AB B448                    	mov	ah,48h
  1973                                  	;mov	ah,ALLOC
  1974 000002AD CD21                    	int	21h
  1975                                  
  1976                                  ; dx = size of transient saved previously 
  1977                                  
  1978 000002AF 39D3                    	cmp	bx,dx		; enough memory?
  1979 000002B1 722B                    	jb	short nomem_err	; not enough memory for transient
  1980                                  
  1981 000002B3 B448                    	mov	ah,48h
  1982                                  	;mov	ah,ALLOC
  1983 000002B5 CD21                    	int	21h		; get the largest block
  1984 000002B7 7225                    	jc	short nomem_err	; something is really screwed up
  1985                                  
  1986 000002B9 50                      	push	ax		; save memory address
  1987 000002BA 01D8                    	add	ax,bx		; ax = top of my memory block
  1988 000002BC 29D0                    	sub	ax,dx		; less size of transient
  1989 000002BE A3[9201]                	mov	[TrnSeg],ax	; save transient segment
  1990 000002C1 8EC0                    	mov	es,ax		;
  1991 000002C3 58                      	pop	ax		; restore our seg addr
  1992                                  
  1993                                  ; Everything is set for a move. We need to move in the reverse direction to
  1994                                  ; make sure we dont overwrite ourselves while copying
  1995                                  
  1996 000002C4 01CE                    	add	si,cx
  1997 000002C6 4E                      	dec	si
  1998 000002C7 01CF                    	add	di,cx
  1999 000002C9 4F                      	dec	di
  2000 000002CA FD                      	std
  2001 000002CB F3A4                    	rep	movsb
  2002 000002CD FC                      	cld
  2003                                  
  2004                                  ; Now we have to free up this block so that resident can get hold of it
  2005                                  
  2006 000002CE 8EC0                    	mov	es,ax
  2007 000002D0 B449                    	mov	ah,49h
  2008                                  	;mov	ah,DEALLOC
  2009 000002D2 CD21                    	int	21h		; release the memory block
  2010                                  
  2011                                  ; M004; End of changes
  2012                                  
  2013                                  	;mov	InitFlag,FALSE	; indicate INIT is done
  2014                                  	; 09/01/2023
  2015 000002D4 C606[1702]00            	mov	byte [InitFlag],0	
  2016                                  
  2017 000002D9 07                      	pop	es
  2018 000002DA 1F                      	pop	ds
  2019                                  	;assume	ds:nothing
  2020                                  	
  2021                                  	; Bugbug: did we need to save & restore seg reg's during EndInit?
  2022                                  	
  2023 000002DB E9A0FD                  	jmp	LodCom_Trap	; allocate transient
  2024                                  
  2025                                  nomem_err:
  2026                                  
  2027                                  ;We call the error routine which will never return. It will either exit
  2028                                  ;with an error ( if not the first COMMAND ) or just hang after an error 
  2029                                  ;message ( if first COMMAND )
  2030                                  
  2031 000002DE E91E19                  	jmp	Alloc_error
  2032                                  
  2033                                  ;EndCodeInit:	; label	byte		; M004
  2034                                  
  2035                                  	; 16/04/2023
  2036                                  	EndCodeInit equ $
  2037                                  
  2038                                  ;; M004; Check if the EndInit code will fit into the Pipe buffers above.
  2039                                  ;; M004; If not, we signal an assembly error
  2040                                  ;
  2041                                  ;IF2
  2042                                  ;	IF ($ GT EndPipe)
  2043                                  ;		.err
  2044                                  ;		%out	"ENDINIT CODE TOO BIG"
  2045                                  ;	ENDIF
  2046                                  ;ENDIF
  2047                                  
  2048                                  ;; M004; Set the origin back to what it was at the end of the buffers
  2049                                  ;;
  2050                                  ;		ORG	EndPipe		; M004
  2051                                  
  2052                                  ; 09/01/2023
  2053                                  
  2054                                  ; MSDOS 5.0 COMMAND.COM - COMDERES:03EDh
  2055                                  ;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)
  2056                                  
  2057                                  ; 16/04/2023
  2058                                  	FillBytes equ EndPipe - EndCodeInit			
  2059                                  
  2060                                  ;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
  2061                                  ; 16/04/2023
  2062                                  %if FillBytes>0
  2063                                  	;times EndPipe - EndCodeInit db 0
  2064 000002E1 00<rep 5Ah>             	times FillBytes db 0   
  2065                                  %endif
  2066                                  
  2067                                  ; 09/01/2023 - Retrodos v4.0 (& v4.1)
  2068                                  ; MSDOS 5.0 COMMAND.COM - COMDERES:0441h ; EndInit+289 
  2069                                  
  2070                                  ;InPipePtr	dw	offset DATARES:Pipe1	; 320h 
  2071                                  ;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh
  2072                                  
  2073 0000033B [1A02]                  InPipePtr:	dw	Pipe1 ; 320h for MSDOS 5.0 COMMAND.COM
  2074 0000033D [6902]                  OutPipePtr:	dw	Pipe2 ; 36Fh for MSDOS 5.0 COMMAND.COM
  2075                                  
  2076                                  Exec_Block:	; label	byte	; the data block for exec calls
  2077 0000033F 0000                    EnvirSeg:	dw	0
  2078                                  Com_Ptr:	; label	dword
  2079 00000341 8000                    		dw	80h	; point at unformatted parameters
  2080 00000343 0000                    		dw	0
  2081                                  Com_Fcb1:	; label	dword
  2082 00000345 5C00                    		dw	5Ch
  2083 00000347 0000                    		dw	0
  2084                                  Com_Fcb2:	; label	dword
  2085 00000349 6C00                    		dw	6Ch
  2086 0000034B 0000                    		dw	0
  2087                                  
  2088                                  ; variables passed to transient
  2089                                  TranVars:	; label	byte			
  2090                                  		;dw	offset DATARES:HeadFix_Trap
  2091 0000034D [9200]                  		dw	HeadFix_Trap
  2092 0000034F 0000                    MySeg:		dw	0	; put our own segment here
  2093 00000351 0000                    LTpa:		dw	0	; will store tpa segment here
  2094 00000353 2F                      RSwitChar:	db	"/"
  2095 00000354 5C                      RDirChar:	db	"\"
  2096                                  		;dw	offset DATARES:Issue_Exec_Call
  2097 00000355 [D700]                  		dw	Issue_Exec_Call
  2098 00000357 0000                    MySeg1:		dw	0
  2099                                  		;dw	offset DATARES:RemCheck_Trap
  2100 00000359 [6A00]                  		dw	RemCheck_Trap
  2101 0000035B 0000                    MySeg2:		dw	0
  2102 0000035D 0000                    ResTest: 	dw	0
  2103 0000035F 0000                    Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
  2104                                  TranVarEnd:	; label	byte
  2105                                  
  2106 00000361 0000                    OldErrNo:	dw	0
  2107                                  
  2108                                  ;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
  2109                                  ;  MsgBuffer is only used while a command is being executed.
  2110                                  ;  SafePathBuffer is no longer needed, since it is used for
  2111                                  ;  unsuccessful program launches.
  2112                                  
  2113                                  MsgBuffer:	; label	byte	; buffer for messages from disk
  2114                                  SafePathBuffer: ; label	byte	; resident pathname for EXEC
  2115                                  	;Bugbug: Why so big a buffer?
  2116                                  		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
  2117 00000363 00<rep 50h>             		times	64+3+13 db 0		
  2118                                  
  2119                                  LENMSGORPATHBUF	equ $ - MsgBuffer
  2120                                  
  2121 000003B3 00000000                Int2fHandler:	dd	0	; address of next int 2f handler
  2122 000003B7 0000                    ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)
  2123                                  
  2124                                  ;SR;
  2125                                  ; The three vars below have been added for a pure COMMAND.COM
  2126                                  
  2127 000003B9 0000                    ResSize:	dw	0
  2128                                  
  2129                                  ;SR;
  2130                                  ; Moved the stack here from the code segment
  2131                                  ;
  2132                                  ; bugbug: Why this odd stack size? And what should stack size be?
  2133                                  	
  2134                                  		;db	(80h - 3) dup (?)
  2135 000003BB 90                      align 2
  2136 000003BC 00<rep 7Ch>             		times	124 db 0		
  2137                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
  2138                                  RStack:		; label	word
  2139 00000438 0000                    OldDS:		dw	0	; keeps old ds value when jumping to
  2140                                  				; resident code segments
  2141                                  ;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003
  2142                                  
  2143                                  ; include highvar.inc		; Add variables for 6.0 loadhigh functionality
  2144                                  ; -------------------------------
  2145                                  
  2146                                  ; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
  2147                                  ; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
  2148                                  ; SegLoad  - Segment address for first UMB specified; set automatically.
  2149                                  ; UmbLoad  - The load UMB number; for example, this is 3 if the user has
  2150                                  ;            given a command-line like "/L:3,500;4"
  2151                                  ; UmbUsed  - An array of characters, each of which is 1 iff the UMB
  2152                                  ;            matching its index number was specified on the command-line;
  2153                                  ;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  2154                                  ;            will be set to 1.  All others will be set to 0.
  2155                                  ; UmbSize  - An array of words, each of which is interpereted as a size
  2156                                  ;            specified by the user for a UMB (in the above example, all
  2157                                  ;            elements would be zero save UmbSize[3], which would be 500.
  2158                                  ; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
  2159                                  ; fm_strat - Set to the old memory-allocation strategy (0$00000???)
  2160                                  ; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  2161                                  ;            for details).
  2162                                  
  2163                                  ; - MSDOS 6.0 COMMAND.COM -
  2164                                  ;; To keep track of which UMBs were specified on the DH/LH command lines, and
  2165                                  ;; to keep track of the minimum sizes given for each, there're two arrays kept
  2166                                  ;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  2167                                  ;; big. 16 should be around 14 too many for most users, so there's no expected
  2168                                  ;; space problem (it's just such a nice round number, eh?).
  2169                                  
  2170                                  ;MAXUMB	equ	16
  2171                                  
  2172                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2173                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)
  2174                                  
  2175 0000043A 00                      fInHigh:	db	0
  2176                                  
  2177                                  ; MSDOS 6.0 COMMAND.COM
  2178                                  ;fUmbTiny:	db	0
  2179                                  ;SegLoad:	dw	0
  2180                                  ;UmbLoad:	db	0
  2181                                  ;UmbUsed:	db	times MAXUMB db 0 ; db MAXUMB dup (?)
  2182                                  ;UmbSize:	dw	times MAXUMB dw 0 ; dw MAXUMB dup (?)
  2183                                  ;fm_umb:	db	0
  2184                                  ;fm_strat:	db	0
  2185                                  ;fm_argc:	db	0
  2186                                  
  2187                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  2188                                  ; UmbLoad is set to the UMB number given.
  2189                                  
  2190                                  ;*** MESSAGES
  2191                                  ;    and other translatable text
  2192                                  
  2193                                  ; include comrmsg.inc	; M00
  2194                                  ; ------------------------------
  2195                                  
  2196                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2197                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)
  2198                                  
  2199 0000043B 41                      ABORT_CHAR:	db 'A'
  2200 0000043C 52                      RETRY_CHAR:	db 'R'
  2201 0000043D 49                      IGNORE_CHAR:	db 'I'
  2202 0000043E 46                      FAIL_CHAR:	db 'F'
  2203 0000043F 59                      YES_CHAR:	db 'Y'
  2204 00000440 4E                      NO_CHAR:	db 'N'
  2205 00000441 05                      REQ_ABORT:	db 5
  2206 00000442 41626F7274              		db 'Abort'
  2207 00000447 07                      REQ_RETRY:	db 7
  2208 00000448 2C205265747279          		db ', Retry'
  2209 0000044F 08                      REQ_IGNORE:	db 8
  2210 00000450 2C2049676E6F7265        		db ', Ignore'
  2211 00000458 06                      REQ_FAIL:	db 6
  2212 00000459 2C204661696C            		db ', Fail'
  2213 0000045F 01                      REQ_END:	db 1
  2214 00000460 3F                      		db '?'
  2215 00000461 08                      MREAD:		db 8
  2216 00000462 72656164696E6700        		db 'reading', 0
  2217 0000046A 08                      MWRITE:		db 8
  2218 0000046B 77726974696E6700        		db 'writing', 0
  2219 00000473 0E                      MDRIVE:		db 14
  2220 00000474 202531206472697665-     		db ' %1 drive %2',0Dh,0Ah
  2220 0000047D 2025320D0A         
  2221 00000482 0F                      MDEVICE:	db 15
  2222 00000483 202531206465766963-     		db ' %1 device %2',0Dh,0Ah
  2222 0000048C 652025320D0A       
  2223 00000492 26                      MVOLSERIAL:	db 38
  2224 00000493 506C6561736520696E-     		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
  2224 0000049C 7365727420766F6C75-
  2224 000004A5 6D6520253120736572-
  2224 000004AE 69616C2025322D2533-
  2224 000004B7 0D0A               
  2225 000004B9 25                      BADFATMSG:	db 37
  2226 000004BA 46696C6520616C6C6F-     		db 'File allocation table bad, drive %1',0Dh,0Ah
  2226 000004C3 636174696F6E207461-
  2226 000004CC 626C65206261642C20-
  2226 000004D5 64726976652025310D-
  2226 000004DE 0A                 
  2227 000004DF 15                      COMBAD:		db 21
  2228 000004E0 496E76616C69642043-     		db 'Invalid COMMAND.COM',0Dh,0Ah
  2228 000004E9 4F4D4D414E442E434F-
  2228 000004F2 4D0D0A             
  2229 000004F5 21                      PUTBACKMSG:	db 33
  2230 000004F6 496E73657274206469-     		db 'Insert disk with %1 in drive %2',0Dh,0Ah
  2230 000004FF 736B20776974682025-
  2230 00000508 3120696E2064726976-
  2230 00000511 652025320D0A       
  2231 00000517 21                      PROMPT:		db 33
  2232 00000518 507265737320616E79-     		db 'Press any key to continue . . .',0Dh,0Ah
  2232 00000521 206B657920746F2063-
  2232 0000052A 6F6E74696E7565202E-
  2232 00000533 202E202E0D0A       
  2233 00000539 1C                      ENDBATMES:	db 28
  2234 0000053A 0D0A                    		db 0Dh,0Ah
  2235 0000053C 5465726D696E617465-     		db 'Terminate batch job (Y/N)?'
  2235 00000545 206261746368206A6F-
  2235 0000054E 622028592F4E293F   
  2236 00000556 13                      EXECEMES:	db 19
  2237 00000557 43616E6E6F74206578-     		db 'Cannot execute %1',0Dh,0Ah
  2237 00000560 65637574652025310D-
  2237 00000569 0A                 
  2238 0000056A 13                      EXEBAD:		db 19
  2239 0000056B 4572726F7220696E20-     		db 'Error in EXE file',0Dh,0Ah
  2239 00000574 4558452066696C650D-
  2239 0000057D 0A                 
  2240 0000057E 22                      TOOBIG:		db 34
  2241 0000057F 50726F6772616D2074-     		db 'Program too big to fit in memory',0Dh,0Ah
  2241 00000588 6F6F2062696720746F-
  2241 00000591 2066697420696E206D-
  2241 0000059A 656D6F72790D0A     
  2242 000005A1 16                      NOHANDMES:	db 22
  2243 000005A2 0D0A                    		db 0Dh,0Ah
  2244 000005A4 4E6F20667265652066-     		db 'No free file handles'
  2244 000005AD 696C652068616E646C-
  2244 000005B6 6573               
  2245 000005B8 1A                      RBADNAM:	db 26
  2246 000005B9 42616420436F6D6D61-     		db 'Bad Command or file name',0Dh,0Ah
  2246 000005C2 6E64206F722066696C-
  2246 000005CB 65206E616D650D0A   
  2247                                  ACCDENIED:	; 14/01/2023
  2248                                  		; 10/01/2023
  2249 000005D3 0E                      ACCDEN:		db 14
  2250 000005D4 416363657373206465-     		db 'Access denied '
  2250 000005DD 6E69656420         
  2251 000005E2 19                      BMEMMES:	db 25
  2252 000005E3 0D0A4D656D6F727920-     		db 0Dh,0Ah,'Memory allocation error'
  2252 000005EC 616C6C6F636174696F-
  2252 000005F5 6E206572726F72     
  2253 000005FC 26                      HALTMES:	db 38
  2254 000005FD 0D0A                    		db 0Dh,0Ah
  2255 000005FF 43616E6E6F74206C6F-     		db 'Cannot load COMMAND, system halted',0Dh,0Ah
  2255 00000608 616420434F4D4D414E-
  2255 00000611 442C2073797374656D-
  2255 0000061A 2068616C7465640D0A 
  2256 00000623 21                      FRETMES:	db 33
  2257 00000624 0D0A                    		db 0Dh,0Ah,
  2258 00000626 43616E6E6F74207374-     		db 'Cannot start COMMAND, exiting',0Dh,0Ah
  2258 0000062F 61727420434F4D4D41-
  2258 00000638 4E442C206578697469-
  2258 00000641 6E670D0A           
  2259 00000645 2E                      PATRICIDE:	db 46
  2260 00000646 0D0A                    		db 0Dh,0Ah
  2261 00000648 546F70206C6576656C-     		db 'Top level process aborted, cannot continue'
  2261 00000651 2070726F6365737320-
  2261 0000065A 61626F727465642C20-
  2261 00000663 63616E6E6F7420636F-
  2261 0000066C 6E74696E7565       
  2262 00000672 0D0A                    		db 0Dh,0Ah
  2263 00000674 02                      NEWLINE:	db 2
  2264 00000675 0D0A                    		db 0Dh, 0Ah
  2265                                  
  2266                                  ; 10/01/2023
  2267                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh
  2268                                  
  2269 00000677 [5B0B]                  MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
  2270 00000679 0100                    		dw 1
  2271 0000067B [1609]                  		dw PARSMSGPTRS		; parse	error messages
  2272 0000067D 0100                    		dw 1
  2273 0000067F [5B0B]                  		dw EXTMSGPTRS		; critical error messages
  2274 00000681 0100                    		dw 1
  2275 00000683 0000                    		dw 0			; File system error messages
  2276 00000685 0000                    		dw 0			; are not supported.
  2277 00000687 [8800]                  		dw MsgRetrv_Trap	; disk retriever routine
  2278 00000689 0000                    MySeg3:		dw 0			; segment of retriever routine
  2279                                  
  2280                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0791h
  2281                                  
  2282 0000068B 13                      CRMSG0:		db 19
  2283 0000068C 57726974652070726F-     		db 'Write protect error'
  2283 00000695 74656374206572726F-
  2283 0000069E 72                 
  2284 0000069F 0C                      CRMSG1:		db 12
  2285 000006A0 496E76616C69642075-     		db 'Invalid unit'
  2285 000006A9 6E6974             
  2286 000006AC 09                      CRMSG2:		db 9
  2287 000006AD 4E6F74207265616479      		db 'Not ready'
  2288 000006B6 16                      CRMSG3:		db 22
  2289 000006B7 496E76616C69642064-     		db 'Invalid device request'
  2289 000006C0 657669636520726571-
  2289 000006C9 75657374           
  2290 000006CD 0A                      CRMSG4:		db 10
  2291 000006CE 44617461206572726F-     		db 'Data error'
  2291 000006D7 72                 
  2292 000006D8 21                      CRMSG5:		db 33
  2293 000006D9 496E76616C69642064-     		db 'Invalid device request parameters'
  2293 000006E2 657669636520726571-
  2293 000006EB 756573742070617261-
  2293 000006F4 6D6574657273       
  2294 000006FA 0A                      CRMSG6:		db 10
  2295 000006FB 5365656B206572726F-     		db 'Seek error'
  2295 00000704 72                 
  2296 00000705 12                      CRMSG7:		db 18
  2297 00000706 496E76616C6964206D-     		db 'Invalid media type'
  2297 0000070F 656469612074797065 
  2298 00000718 10                      CRMSG8:		db 16
  2299 00000719 536563746F72206E6F-     		db 'Sector not found'
  2299 00000722 7420666F756E64     
  2300 00000729 1A                      CRMSG9:		db 26
  2301 0000072A 5072696E746572206F-     		db 'Printer out of paper error'
  2301 00000733 7574206F6620706170-
  2301 0000073C 6572206572726F72   
  2302 00000744 11                      CRMSG10:	db 17
  2303 00000745 577269746520666175-     		db 'Write fault error'
  2303 0000074E 6C74206572726F72   
  2304 00000756 10                      CRMSG11:	db 16
  2305 00000757 52656164206661756C-     		db 'Read fault error'
  2305 00000760 74206572726F72     
  2306 00000767 0F                      CRMSG12:	db 15
  2307 00000768 47656E6572616C2066-     		db 'General failure'
  2307 00000771 61696C757265       
  2308 00000777 11                      CRMSG13:	db 17
  2309 00000778 53686172696E672076-     		db 'Sharing violation'
  2309 00000781 696F6C6174696F6E   
  2310 00000789 0E                      CRMSG14:	db 14
  2311 0000078A 4C6F636B2076696F6C-     		db 'Lock violation'
  2311 00000793 6174696F6E         
  2312 00000798 13                      CRMSG15:	db 19
  2313 00000799 496E76616C69642064-     		db 'Invalid disk change'
  2313 000007A2 69736B206368616E67-
  2313 000007AB 65                 
  2314 000007AC 0F                      CRMSG16:	db 15
  2315 000007AD 46434220756E617661-     		db 'FCB unavailable'
  2315 000007B6 696C61626C65       
  2316 000007BC 19                      CRMSG17:	db 25
  2317 000007BD 53797374656D207265-     		db 'System resource exhausted'
  2317 000007C6 736F75726365206578-
  2317 000007CF 68617573746564     
  2318 000007D6 12                      CRMSG18:	db 18
  2319 000007D7 436F64652070616765-     		db 'Code page mismatch'
  2319 000007E0 206D69736D61746368 
  2320 000007E9 0C                      CRMSG19:	db 12
  2321 000007EA 4F7574206F6620696E-     		db 'Out of input'
  2321 000007F3 707574             
  2322 000007F6 17                      CRMSG20:	db 23
  2323 000007F7 496E73756666696369-     		db 'Insufficient disk space'
  2323 00000800 656E74206469736B20-
  2323 00000809 7370616365         
  2324                                  
  2325                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0914h
  2326                                  
  2327 0000080E [8B06]                  CRITMSGPTRS:	dw CRMSG0
  2328 00000810 [9F06]                  		dw CRMSG1
  2329 00000812 [AC06]                  		dw CRMSG2
  2330 00000814 [B606]                  		dw CRMSG3
  2331 00000816 [CD06]                  		dw CRMSG4
  2332 00000818 [D806]                  		dw CRMSG5
  2333 0000081A [FA06]                  		dw CRMSG6
  2334 0000081C [0507]                  		dw CRMSG7
  2335 0000081E [1807]                  		dw CRMSG8
  2336 00000820 [2907]                  		dw CRMSG9
  2337 00000822 [4407]                  		dw CRMSG10
  2338 00000824 [5607]                  		dw CRMSG11
  2339 00000826 [6707]                  		dw CRMSG12
  2340 00000828 [7707]                  		dw CRMSG13
  2341 0000082A [8907]                  		dw CRMSG14
  2342 0000082C [9807]                  		dw CRMSG15
  2343 0000082E [AC07]                  		dw CRMSG16
  2344 00000830 [BC07]                  		dw CRMSG17
  2345 00000832 [D607]                  		dw CRMSG18
  2346 00000834 [E907]                  		dw CRMSG19
  2347 00000836 [F607]                  		dw CRMSG20
  2348                                  
  2349                                  		; 14/01/2023
  2350                                  DataresEnd:	; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)
  2351                                  
  2352 00000838 13                      PAERRMSG0:	db 19
  2353 00000839 546F6F206D616E7920-     		db 'Too many parameters'
  2353 00000842 706172616D65746572-
  2353 0000084B 73                 
  2354 0000084C 1A                      PAERRMSG1:	db 26
  2355 0000084D 526571756972656420-     		db 'Required parameter missing'
  2355 00000856 706172616D65746572-
  2355 0000085F 206D697373696E67   
  2356 00000867 0E                      PAERRMSG2:	db 14
  2357 00000868 496E76616C69642073-     		db 'Invalid switch'
  2357 00000871 7769746368         
  2358 00000876 0F                      PAERRMSG3:	db 15
  2359 00000877 496E76616C6964206B-     		db 'Invalid keyword'
  2359 00000880 6579776F7264       
  2360 00000886 01                      PAERRMSG4:	db 1
  2361 00000887 20                      		db 20h
  2362 00000888 24                      PAERRMSG5:	db 36
  2363 00000889 506172616D65746572-     		db 'Parameter value not in allowed range'
  2363 00000892 2076616C7565206E6F-
  2363 0000089B 7420696E20616C6C6F-
  2363 000008A4 7765642072616E6765 
  2364                                  PAERRMSG6:	; 10/01/2023
  2365 000008AD 1B                      PAERRMSG7:	db 27
  2366 000008AE 506172616D65746572-     		db 'Parameter value not allowed'
  2366 000008B7 2076616C7565206E6F-
  2366 000008C0 7420616C6C6F776564 
  2367                                  ;PAERRMSG7:	db 27
  2368                                  ;		db 'Parameter value not allowed'
  2369 000008C9 1C                      PAERRMSG8:	db 28
  2370 000008CA 506172616D65746572-     		db 'Parameter format not correct'
  2370 000008D3 20666F726D6174206E-
  2370 000008DC 6F7420636F72726563-
  2370 000008E5 74                 
  2371 000008E6 11                      PAERRMSG9:	db 17
  2372 000008E7 496E76616C69642070-     		db 'Invalid parameter'
  2372 000008F0 6172616D65746572   
  2373 000008F8 1D                      PAERRMSG10:	db 29
  2374 000008F9 496E76616C69642070-     		db 'Invalid parameter combination'
  2374 00000902 6172616D6574657220-
  2374 0000090B 636F6D62696E617469-
  2374 00000914 6F6E               
  2375                                  
  2376                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h
  2377                                  
  2378 00000916 [3808]                  PARSMSGPTRS:	dw PAERRMSG0
  2379 00000918 [4C08]                  		dw PAERRMSG1
  2380 0000091A [6708]                  		dw PAERRMSG2
  2381 0000091C [7608]                  		dw PAERRMSG3
  2382 0000091E [8608]                  		dw PAERRMSG4
  2383 00000920 [8808]                  		dw PAERRMSG5
  2384 00000922 [AD08]                  		dw PAERRMSG6
  2385 00000924 [AD08]                  		dw PAERRMSG7
  2386 00000926 [C908]                  		dw PAERRMSG8
  2387 00000928 [E608]                  		dw PAERRMSG9
  2388 0000092A [F808]                  		dw PAERRMSG10
  2389                                  ; 21/04/2023
  2390                                  NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023
  2391                                  
  2392 0000092C 10                      INVLFUNCT:	db 16
  2393 0000092D 496E76616C69642066-     		db 'Invalid function'
  2393 00000936 756E6374696F6E     
  2394 0000093D 0E                      FNOTFOUND:	db 14
  2395 0000093E 46696C65206E6F7420-     		db 'File not found'
  2395 00000947 666F756E64         
  2396 0000094C 0E                      PNOTFOUND:	db 14
  2397 0000094D 50617468206E6F7420-     		db 'Path not found'
  2397 00000956 666F756E64         
  2398 0000095B 13                      TOOMANYOF:	db 19
  2399 0000095C 546F6F206D616E7920-     		db 'Too many open files'
  2399 00000965 6F70656E2066696C65-
  2399 0000096E 73                 
  2400                                  ; 14/01/2023
  2401                                  ;ACCDEN:	; 10/01/2023
  2402                                  ;ACCDENIED:	db 14
  2403                                  ;		db 'Access denied '
  2404 0000096F 0E                      INVHANDLE:	db 14
  2405 00000970 496E76616C69642068-     		db 'Invalid handle'
  2405 00000979 616E646C65         
  2406 0000097E 1F                      MEMCBDEST:	db 31
  2407 0000097F 4D656D6F727920636F-     		db 'Memory control blocks destroyed'
  2407 00000988 6E74726F6C20626C6F-
  2407 00000991 636B73206465737472-
  2407 0000099A 6F796564           
  2408 0000099E 13                      INSUFFMEM:	db 19
  2409 0000099F 496E73756666696369-     		db 'Insufficient memory'
  2409 000009A8 656E74206D656D6F72-
  2409 000009B1 79                 
  2410 000009B2 1C                      INVMEMBLA:	db 28
  2411 000009B3 496E76616C6964206D-     		db 'Invalid memory block address'
  2411 000009BC 656D6F727920626C6F-
  2411 000009C5 636B20616464726573-
  2411 000009CE 73                 
  2412 000009CF 13                      INVENVIRO:	db 19
  2413 000009D0 496E76616C69642045-     		db 'Invalid Environment'
  2413 000009D9 6E7669726F6E6D656E-
  2413 000009E2 74                 
  2414 000009E3 0E                      INVFORMAT:	db 14
  2415 000009E4 496E76616C69642066-     		db 'Invalid format'
  2415 000009ED 6F726D6174         
  2416 000009F2 1A                      INVFNPARM:	db 26
  2417 000009F3 496E76616C69642066-     		db 'Invalid function parameter'
  2417 000009FC 756E6374696F6E2070-
  2417 00000A05 6172616D65746572   
  2418 00000A0D 0C                      INVLDDATA:	db 12
  2419 00000A0E 496E76616C69642064-     		db 'Invalid data'
  2419 00000A17 617461             
  2420 00000A1A 1B                      INVDRVSPC:	db 27
  2421 00000A1B 496E76616C69642064-     		db 'Invalid drive specification'
  2421 00000A24 726976652073706563-
  2421 00000A2D 696669636174696F6E 
  2422 00000A36 23                      ATRCURDIR:	db 35
  2423 00000A37 417474656D70742074-     		db 'Attempt to remove current directory'
  2423 00000A40 6F2072656D6F766520-
  2423 00000A49 63757272656E742064-
  2423 00000A52 69726563746F7279   
  2424 00000A5A 0F                      NOTSAMDEV:	db 15
  2425 00000A5B 4E6F742073616D6520-     		db 'Not same device'
  2425 00000A64 646576696365       
  2426 00000A6A 0D                      NOMOREFIL:	db 13
  2427 00000A6B 4E6F206D6F72652066-     		db 'No more files'
  2427 00000A74 696C6573           
  2428 00000A78 0B                      FILEXISTS:	db 11
  2429 00000A79 46696C652065786973-     		db 'File exists'
  2429 00000A82 7473               
  2430 00000A84 1B                      CANTMKDIR:	db 27
  2431 00000A85 43616E6E6F74206D61-     		db 'Cannot make directory entry'
  2431 00000A8E 6B6520646972656374-
  2431 00000A97 6F727920656E747279 
  2432 00000AA0 0E                      FAILINT24:	db 14
  2433 00000AA1 4661696C206F6E2049-     		db 'Fail on INT 24'
  2433 00000AAA 4E54203234         
  2434 00000AAF 15                      TOOMANYRD:	db 21
  2435 00000AB0 546F6F206D616E7920-     		db 'Too many redirections'
  2435 00000AB9 726564697265637469-
  2435 00000AC2 6F6E73             
  2436 00000AC5 15                      DUPLREDIR:	db 21
  2437 00000AC6 4475706C6963617465-     		db 'Duplicate redirection'
  2437 00000ACF 207265646972656374-
  2437 00000AD8 696F6E             
  2438 00000ADB 10                      INVPASSWD:	db 16
  2439 00000ADC 496E76616C69642070-     		db 'Invalid password'
  2439 00000AE5 617373776F7264     
  2440 00000AEC 11                      INVLDPARM:	db 17
  2441 00000AED 496E76616C69642070-     		db 'Invalid parameter'
  2441 00000AF6 6172616D65746572   
  2442 00000AFE 12                      NETDATFAU:	db 18
  2443 00000AFF 4E6574776F726B2064-     		db 'Network data fault'
  2443 00000B08 617461206661756C74 
  2444 00000B11 21                      FNOSUPNET:	db 33
  2445 00000B12 46756E6374696F6E20-     		db 'Function not supported by network'
  2445 00000B1B 6E6F7420737570706F-
  2445 00000B24 72746564206279206E-
  2445 00000B2D 6574776F726B       
  2446 00000B33 27                      RSCNOTINS:	db 39
  2447 00000B34 526571756972656420-     		db 'Required system component not installed'
  2447 00000B3D 73797374656D20636F-
  2447 00000B46 6D706F6E656E74206E-
  2447 00000B4F 6F7420696E7374616C-
  2447 00000B58 6C6564             
  2448                                  
  2449                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch
  2450                                  
  2451 00000B5B [2C09]                  EXTMSGPTRS:	dw INVLFUNCT
  2452 00000B5D [3D09]                  		dw FNOTFOUND
  2453 00000B5F [4C09]                  		dw PNOTFOUND
  2454 00000B61 [5B09]                  		dw TOOMANYOF
  2455 00000B63 [D305]                  		dw ACCDENIED
  2456 00000B65 [6F09]                  		dw INVHANDLE
  2457 00000B67 [7E09]                  		dw MEMCBDEST
  2458 00000B69 [9E09]                  		dw INSUFFMEM
  2459 00000B6B [B209]                  		dw INVMEMBLA
  2460 00000B6D [CF09]                  		dw INVENVIRO
  2461 00000B6F [E309]                  		dw INVFORMAT
  2462 00000B71 [F209]                  		dw INVFNPARM
  2463 00000B73 [0D0A]                  		dw INVLDDATA
  2464 00000B75 0000                    		dw 0
  2465 00000B77 [1A0A]                  		dw INVDRVSPC
  2466 00000B79 [360A]                  		dw ATRCURDIR
  2467 00000B7B [5A0A]                  		dw NOTSAMDEV
  2468 00000B7D [6A0A]                  		dw NOMOREFIL
  2469 00000B7F [8B06]                  		dw CRMSG0
  2470 00000B81 [9F06]                  		dw CRMSG1
  2471 00000B83 [AC06]                  		dw CRMSG2
  2472 00000B85 [B606]                  		dw CRMSG3
  2473 00000B87 [CD06]                  		dw CRMSG4
  2474 00000B89 [D806]                  		dw CRMSG5
  2475 00000B8B [FA06]                  		dw CRMSG6
  2476 00000B8D [0507]                  		dw CRMSG7
  2477 00000B8F [1807]                  		dw CRMSG8
  2478 00000B91 [2907]                  		dw CRMSG9
  2479 00000B93 [4407]                  		dw CRMSG10
  2480 00000B95 [5607]                  		dw CRMSG11
  2481 00000B97 [6707]                  		dw CRMSG12
  2482 00000B99 [7707]                  		dw CRMSG13
  2483 00000B9B [8907]                  		dw CRMSG14
  2484 00000B9D [9807]                  		dw CRMSG15
  2485 00000B9F [AC07]                  		dw CRMSG16
  2486 00000BA1 [BC07]                  		dw CRMSG17
  2487 00000BA3 [D607]                  		dw CRMSG18
  2488 00000BA5 [E907]                  		dw CRMSG19
  2489 00000BA7 [F607]                  		dw CRMSG20
  2490 00000BA9 0000<rep 28h>           		times 40 dw 0	; db 80 dup(0)
  2491 00000BF9 [780A]                  		dw FILEXISTS
  2492 00000BFB 0000                    		dw 0
  2493 00000BFD [840A]                  		dw CANTMKDIR
  2494 00000BFF [A00A]                  		dw FAILINT24
  2495 00000C01 [AF0A]                  		dw TOOMANYRD
  2496 00000C03 [C50A]                  		dw DUPLREDIR
  2497 00000C05 [DB0A]                  		dw INVPASSWD
  2498 00000C07 [EC0A]                  		dw INVLDPARM
  2499 00000C09 [FE0A]                  		dw NETDATFAU
  2500 00000C0B [110B]                  		dw FNOSUPNET
  2501 00000C0D [330B]                  		dw RSCNOTINS
  2502                                  ; ----------------------------------------------------------------------------
  2503                                  	; 17/04/2023
  2504                                  ExtMsgEnd:
  2505                                  
  2506                                  ; 21/04/2023
  2507                                  NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023
  2508                                  
  2509                                  ; ----------------------------------------------------------------------------
  2510                                  
  2511                                  ; 20/04/2023
  2512                                  
  2513 00000C0F 90                      align 16
  2514                                  
  2515                                  ; ----------------------------------------------------------------------------
  2516                                  
  2517                                  ; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2518                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)
  2519                                  
  2520                                  ; ----------------------------------------------------------------------------
  2521                                  ; SEGMENT - CODERES
  2522                                  ; ----------------------------------------------------------------------------
  2523                                  
  2524                                  ; 11/01/2023
  2525                                  RCODE_START:	
  2526                                  
  2527                                  ; ----------------------------------------------------------------------------
  2528                                  ;***	EXEC error handling
  2529                                  ;
  2530                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  2531                                  ;	We examine the error code and select an appropriate message.
  2532                                  ; --------------------------
  2533                                  ;	Bugbug:	optimize reg usage in following code? Careful of DX!
  2534                                  ;	Condense the error scan?
  2535                                  ;	RBADNAM is checked by transient, no need here?
  2536                                  ;	Move below Ext_Exec.
  2537                                  ; ----------------------------------------------------------------------------
  2538                                  
  2539                                  Exec_Err:
  2540                                  ;SR;
  2541                                  ; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
  2542                                  ; in order here
  2543                                  
  2544                                  ;	Bugbug:	can we use byte compares here?
  2545                                  ;	Might be able to use byte msg#s, too.
  2546                                  
  2547                                  ;	Store errors in a 3 or 4 byte table. Msg #s in another.
  2548                                  ;	Speed not high priority here.
  2549                                  
  2550                                  ;	Move this to transient.
  2551                                  
  2552                                  	; 10/01/2023
  2553                                  
  2554                                  	;mov	bx,RBADNAM	; offset DATARES:RBadNam
  2555 00000C10 BA[B805]                	mov	dx,RBADNAM
  2556 00000C13 3C02                    	cmp	al,ERROR_FILE_NOT_FOUND ; 2
  2557 00000C15 741B                    	je	short GotExecEMes		; bad command
  2558                                  	;mov	bx,TOOBIG	; offset DATARES:TooBig
  2559 00000C17 BA[7E05]                	mov	dx,TOOBIG
  2560 00000C1A 3C08                    	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
  2561 00000C1C 7414                    	je	short GotExecEMes		; file not found
  2562                                  	;mov	bx,EXEBAD	; offset DATARES:ExeBad
  2563 00000C1E BA[6A05]                	mov	dx,EXEBAD
  2564 00000C21 3C0B                    	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
  2565 00000C23 740D                    	je	short GotExecEMes		; bad exe file
  2566                                  	;mov	bx,ACCDEN	; offset DATARES:AccDen
  2567 00000C25 BA[D305]                	mov	dx,ACCDEN
  2568 00000C28 3C05                    	cmp	al,ERROR_ACCESS_DENIED ; 5
  2569 00000C2A 7406                    	je	short GotExecEMes		; access denied
  2570                                  
  2571                                  Default_Message:
  2572                                  	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
  2573 00000C2C BA[5605]                	mov	dx,EXECEMES
  2574                                  						; default message
  2575 00000C2F BE[3301]                	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
  2576                                  						; get address of subst block
  2577                                  GotExecEMes:
  2578                                  	;mov	dx,bx				; DX = ptr to msg
  2579 00000C32 E85C06                  	call	RPrint ; invoke	RPrint
  2580 00000C35 EB09                    	jmp	short NoExec
  2581                                  
  2582                                  ; ----------------------------------------------------------------------------
  2583                                  ;***	EXEC call
  2584                                  ;
  2585                                  ;	The transient has set up everything for an EXEC system call.
  2586                                  ;	For cleanliness, we issue the EXEC here in the resident 
  2587                                  ;	so that we may be able to recover cleanly upon success.
  2588                                  ;
  2589                                  ;	CS,DS,ES,SS = DATARES seg addr
  2590                                  ; ----------------------------------------------------------------------------
  2591                                  
  2592                                  Ext_Exec:
  2593                                  ;SR;
  2594                                  ; The words put on the stack by the stub will be popped off when we finally
  2595                                  ;jump to LodCom (by LodCom).
  2596                                  
  2597                                  	; 10/01/2023
  2598                                  	;int	21h			; do the exec
  2599                                  	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
  2600                                  Exec_Ret:
  2601 00000C37 72D7                    	jc	short Exec_Err		; exec failed
  2602                                  
  2603                                  ;	The exec has completed. Retrieve the exit code.
  2604                                  
  2605                                  Exec_Wait:
  2606 00000C39 B44D                    	mov	ah,4Dh
  2607                                  	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  2608 00000C3B CD21                    	int	21h			; get the return code
  2609                                  	;mov	[cs:RetCode],ax
  2610                                  	; 11/01/2023
  2611 00000C3D A3[9D01]                	mov	[RetCode],ax
  2612                                  
  2613                                  ;	See if we can reload the transient. The external command
  2614                                  ;	may have overwritten part of the transient.
  2615                                  
  2616                                  NoExec:
  2617                                  ;SR;
  2618                                  ; ds = es = ss = DATARES when we jump to LodCom
  2619                                  ;
  2620 00000C40 E97A01                  	jmp	LodCom
  2621                                  
  2622                                  ; ----------------------------------------------------------------------------
  2623                                  ;***	Int 23 (ctrl-c) handler
  2624                                  ;
  2625                                  ;	This is the default system INT 23 handler. All processes
  2626                                  ;	(including COMMAND) get it by default. There are some
  2627                                  ;	games that are played: We ignore ^C during most of the
  2628                                  ;	INIT code. This is because we may perform an ALLOC and
  2629                                  ;	diddle the header! Also, if we are prompting for date/time
  2630                                  ;	in the init code, we are to treat ^C as empty responses.
  2631                                  ; ---------------------------
  2632                                  ;	Bugbug:	put init ctrl-c handling in init module.
  2633                                  ; ----------------------------------------------------------------------------
  2634                                  
  2635                                  ;SR;
  2636                                  ;The stub has pushed the previous ds and DATARES onto the stack. We get
  2637                                  ;both these values off the stack now
  2638                                  ;
  2639                                  ;ContC	proc	far
  2640                                  
  2641                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2642                                  
  2643                                  	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
  2644                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
  2645                                  ContC:
  2646 00000C43 1F                      	pop	ds			; ds = DATARES
  2647                                  ;	assume	ds:DATARES
  2648                                  ;;	pop	word [OldDS]		; OldDS = old ds
  2649                                  
  2650 00000C44 F606[1702]01            	test	byte [InitFlag],INITINIT ; 1
  2651                                  	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  2652 00000C49 740D                    	jz	short NotAtInit		; no
  2653 00000C4B F606[1702]02            	test	byte [InitFlag],INITSPECIAL ; 2 
  2654                                  	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  2655 00000C50 7404                    	jz	short CmdIret		; no, ignore ^C
  2656 00000C52 1F                      	pop	ds			; restore before jumping; M021
  2657                                  	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
  2658 00000C53 E9140E                  	jmp	init_contc_specialcase
  2659                                  CmdIret:
  2660                                  ;SR;
  2661                                  ; Restore ds to its previous value
  2662                                  ;
  2663                                  
  2664                                  ;;	mov	ds,[OLdDS]		;
  2665 00000C56 1F                      	pop	ds
  2666 00000C57 CF                      	iret				; yes, ignore the ^C
  2667                                  
  2668                                  NotAtInit:
  2669 00000C58 F606[1702]04            	test	byte [InitFlag],INITCTRLC ; 4
  2670                                  	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  2671 00000C5D 7412                    	jz	short NotInit 		; nope too.
  2672                                  
  2673                                  ;*	We are interrupting ourselves in this ^C handler. We need
  2674                                  ;	to set carry and return to the user sans flags only if the
  2675                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  2676                                  
  2677 00000C5F 80FC01                  	cmp	ah,1
  2678 00000C62 72F2                    	jb	short CmdIret
  2679 00000C64 80FC0C                  	cmp	ah,12
  2680 00000C67 77ED                    	ja	short CmdIret
  2681                                  
  2682 00000C69 1F                      	pop	ds			;restore ds to old value
  2683 00000C6A 83C406                  	add	sp,6			; remove int frame
  2684 00000C6D F9                      	stc
  2685                                  
  2686                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  2687 00000C6E CA0200                  	retf	2			; remove those flags...
  2688                                  
  2689                                  NotInit:
  2690                                  
  2691                                  ;*	We have now received a ^C for some process (maybe ourselves
  2692                                  ;	but not at INIT).
  2693                                  ;	
  2694                                  ;	Note that we are running on the user's stack!!! Bad news if
  2695                                  ;	any of the system calls below go and issue another INT
  2696                                  ;	24... Massive stack overflow! Another bad point is that
  2697                                  ;	SavHand will save an already saved handle, thus losing a
  2698                                  ;	possible redirection...
  2699                                  ;	
  2700                                  ;	All we need to do is set the flag to indicate nested ^C. 
  2701                                  ;	The above code will correctly flag the ^C diring the
  2702                                  ;	message output and prompting while ignoring the ^C the rest
  2703                                  ;	of the time.
  2704                                  ;	
  2705                                  ;	Clean up: flush disk. If we are in the middle of a batch
  2706                                  ;	file, we ask if he wants to terminate it. If he does, then
  2707                                  ;	we turn off all internal flags and let the DOS abort.
  2708                                  
  2709 00000C71 800E[1702]04            	or	byte [InitFlag],INITCTRLC ; 4
  2710                                  	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  2711 00000C76 FB                      	sti
  2712                                  
  2713                                  ;	push	cs			; el yucko! change the user's ds!!
  2714                                  ;	pop	ds
  2715                                  
  2716                                  ;	assume	ds:RESGROUP
  2717                                  
  2718 00000C77 58                      	pop	ax			; discard the old ds value
  2719                                  
  2720 00000C78 A1[A601]                	mov	ax,[SingleCom]
  2721 00000C7B 09C0                    	or	ax,ax
  2722 00000C7D 7506                    	jnz	short NoReset
  2723 00000C7F 50                      	push	ax
  2724 00000C80 B40D                    	mov	ah,DISK_RESET ; 0Dh
  2725 00000C82 CD21                    	int	21h			; reset disks in case files were open
  2726 00000C84 58                      	pop	ax
  2727                                  
  2728                                  NoReset:
  2729                                  
  2730                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  2731                                  ;	walk the entire active list and free each segment. Here,
  2732                                  ;	we just free the single batch segment.
  2733                                  
  2734 00000C85 F706[4C01]FFFF          	test	word [Batch],-1 ; 0FFFFh
  2735 00000C8B 7453                    	jz	short ContCTerm
  2736 00000C8D 09C0                    	or	ax,ax
  2737 00000C8F 754F                    	jnz	short ContCTerm
  2738 00000C91 E88602                  	call	SavHand
  2739 00000C94 E89403                  	call	AskEnd			; ask if user wants to end batch
  2740                                  
  2741                                  ;	If the carry flag is clear, we do NOT free up the batch file
  2742                                  
  2743 00000C97 7341                    	jnc	short ContBatch
  2744 00000C99 8A0E[A001]              	mov	cl,[EchoFlag]		; get current echo flag
  2745 00000C9D 53                      	push	bx
  2746                                  
  2747                                  ClearBatch:
  2748 00000C9E 8E06[4C01]              	mov	es,[Batch]		; get batch segment
  2749                                  	;mov	di,20h
  2750 00000CA2 8B3E2000                	mov	di,[BATCHSEGMENT.BatFile] ; get offset of batch file name
  2751                                  	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
  2752                                  	;mov	bx,es:BatForPtr		; get old FOR segment
  2753 00000CA6 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
  2754                                  	; MSDOS 3.3 ([ES:4])
  2755                                  	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  2756                                  	;
  2757 00000CAB 83FB00                  	cmp	bx,0			; is a FOR in progress
  2758 00000CAE 7408                    	je	short No_Bat_For	; no - don't deallocate
  2759 00000CB0 06                      	push	es			;
  2760 00000CB1 8EC3                    	mov	es,bx			; yes - free it up...
  2761 00000CB3 B449                    	mov	ah,49h
  2762                                  	;mov	ah,DEALLOC ; 49h	;
  2763 00000CB5 CD21                    	int	21h			;
  2764 00000CB7 07                      	pop	es			; restore to batch segment
  2765                                  
  2766                                  No_Bat_For:
  2767                                  	;mov	cl,[es:1]
  2768 00000CB8 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  2769                                  	;mov	bx,[es:3]
  2770 00000CBD 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  2771 00000CC2 B449                    	mov	ah,49h
  2772                                  	;mov	ah,DEALLOC ; 49h	; free it up...
  2773 00000CC4 CD21                    	int	21h
  2774 00000CC6 891E[4C01]              	mov	[Batch],bx		; get ready to deallocate next batch
  2775 00000CCA FF0E[AF01]              	dec	word [Nest]		; is there another batch file?
  2776 00000CCE 75CE                    	jnz	short ClearBatch	; keep going until no batch file
  2777                                  
  2778                                  ;	We are terminating a batch file; restore the echo status
  2779                                  
  2780                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  2781 00000CD0 5B                      	pop	bx
  2782 00000CD1 880E[A001]              	mov	[EchoFlag],cl		; reset echo status
  2783                                  	; 29/05/2018
  2784 00000CD5 C606[1802]00            	mov	byte [PipeFlag],0	; turn off pipeflag
  2785                                  
  2786                                  ContBatch:
  2787 00000CDA E8B105                  	call	crlf			; print out crlf before returning
  2788 00000CDD E86302                  	call	RestHand
  2789                                  
  2790                                  ;	Yes, we are terminating. Turn off flags and allow the DOS to abort.
  2791                                  
  2792                                  ContCTerm:
  2793 00000CE0 31C0                    	xor	ax,ax			; indicate no read
  2794 00000CE2 89C5                    	mov	bp,ax
  2795                                  
  2796                                  ;	The following resetting of the state flags is good for the
  2797                                  ;	generalized batch processing.
  2798                                  
  2799 00000CE4 A2[AB01]                	mov	[IfFlag],al		; turn off iffing
  2800 00000CE7 A2[AC01]                	mov	[ForFlag],al		; turn off for processing
  2801 00000CEA E81C00                  	call	ResPipeOff
  2802 00000CED 3906[A601]              	cmp	[SingleCom],ax		; see if we need to set SingleCom
  2803 00000CF1 7406                    	jz	short NoSetSing
  2804 00000CF3 C706[A601]FFFF          	mov	word [SingleCom],-1	; cause termination on 
  2805                                  					;  pipe, batch, for
  2806                                  NoSetSing:
  2807                                  
  2808                                  ;	If we are doing an internal command, go through the reload process.
  2809                                  ;	If we are doing an external, let DOS abort the process.
  2810                                  ;	In both cases, we are now done with the ^C processing.
  2811                                  
  2812 00000CF9 8026[1702]FB            	and	byte [InitFlag],~INITCTRLC ; 0FBh
  2813 00000CFE 3806[9C01]              	cmp	[ExtCom],al
  2814 00000D02 7503                    	jnz	short DoDAb		; internal ^c
  2815 00000D04 E94501                  	jmp	LodCom1
  2816                                  DoDAb:
  2817 00000D07 F9                      	stc				; tell dos to abort
  2818                                  
  2819                                  ;SR;
  2820                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  2821                                  ;by setting carry and leaving flags on the stack
  2822                                  
  2823 00000D08 CB                      	retf				; Leave flags on stack
  2824                                  
  2825                                  ;ContC	endp
  2826                                  
  2827                                  ;SR;
  2828                                  ;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  2829                                  ;both have ds = DATARES
  2830                                  
  2831                                  	; 11/01/2023
  2832                                  ResPipeOff:
  2833 00000D09 50                      	push	ax
  2834 00000D0A 31C0                    	xor	ax,ax
  2835                                  	;xchg	al,[cs:PIPEFLAG]
  2836 00000D0C 8606[1802]              	xchg	al,[PipeFlag]
  2837 00000D10 08C0                    	or	al,al
  2838 00000D12 7404                    	jz	short NoPipePop
  2839                                  	;shr	byte [cs:ECHOFLAG],1
  2840 00000D14 D02E[A001]              	shr	byte [EchoFlag],1
  2841                                  NoPipePop:
  2842 00000D18 58                      	pop	ax
  2843 00000D19 C3                      	retn
  2844                                  
  2845                                  ;CODERES ends
  2846                                  
  2847                                  ;=============================================================================
  2848                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  2849                                  ;=============================================================================
  2850                                  ; 21/09/2018 - Retro DOS v3.0
  2851                                  
  2852                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  2853                                  ;	name	COMMAND2
  2854                                  
  2855                                  ;/*
  2856                                  ; *                      Microsoft Confidential
  2857                                  ; *                      Copyright (C) Microsoft Corporation 1991
  2858                                  ; *                      All Rights Reserved.
  2859                                  ; */
  2860                                  
  2861                                  ;
  2862                                  ;	Revision History
  2863                                  ;	================
  2864                                  ;
  2865                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  2866                                  ;			reserve memory by changing int 12h and then give it
  2867                                  ;			back to DOS by changing arenas in autoexec.bat.
  2868                                  ;			This makes command.com reload transient and this
  2869                                  ;			cannot be done at this stage.
  2870                                  ;
  2871                                  
  2872                                  ;CODERES segment public byte
  2873                                  
  2874                                  ;*	If we cannot allocate enough memory for the transient or there
  2875                                  ;	was some other allocation error, we display a message and
  2876                                  ;	then die.
  2877                                  
  2878                                  ;SR;
  2879                                  ; We will have to make sure that at this entry point and at FatalC, 
  2880                                  ;ds = DATARES. All jumps to these points are made from only within this file
  2881                                  ;and so we should be able to do this
  2882                                  
  2883                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2884                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)
  2885                                  
  2886                                  	;assume	ds:DATARES
  2887                                  BadMemErr:
  2888 00000D1A BA[E205]                	mov	dx,BMEMMES			; DX = ptr to msg
  2889                                  FatalC:
  2890                                  	; 12/01/2023
  2891                                  ;;	push	cs
  2892                                  ;;	pop	ds
  2893                                  ;;	assume	ds:ResGroup
  2894                                  ;	invoke	RPrint
  2895                                  
  2896                                  	; 12/01/2023
  2897                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2898 00000D1D E87105                  	call	RPrint
  2899                                  
  2900                                  	; MSDOS 3.3
  2901                                  	;call	RDISPMSG
  2902                                  
  2903                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  2904                                  ;	we can't do anything else!
  2905                                  
  2906 00000D20 803E[A501]00            	cmp	byte [PermCom],0
  2907 00000D25 7410                    	je	short FatalRet
  2908                                  
  2909                                  ;	We are a permanent command. If we are in the process of the
  2910                                  ;	magic interrupt (Singlecom) then exit too.
  2911                                  
  2912 00000D27 833E[A601]00            	cmp	word [SingleCom],0		; if PermCom and SingleCom
  2913 00000D2C 7509                    	jne	short FatalRet			; must take int_2e exit
  2914                                  
  2915                                  ;	Permanent command. We can't do ANYthing except halt.
  2916                                  
  2917 00000D2E BA[FC05]                	mov	dx,HALTMES			; DX = ptr to msg
  2918                                  	;invoke	RPrint
  2919                                  	; 12/01/2023	
  2920                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2921 00000D31 E85D05                  	call	RPrint	
  2922                                  	; MSDOS 3.3
  2923                                  	;call	RDISPMSG
  2924 00000D34 FB                      	sti
  2925                                  Stall:
  2926 00000D35 EBFE                    	jmp	short Stall			; crash the system nicely
  2927                                  
  2928                                  FatalRet:
  2929 00000D37 BA[2306]                	mov	dx,FRETMES			; DX = ptr to msg
  2930                                  	;call	RDISPMSG
  2931                                  	; 12/01/2023	
  2932 00000D3A E85405                  	call	RPrint	
  2933                                  FatalRet2:
  2934 00000D3D 803E[A501]00            	cmp	byte [PermCom],0		; if we get here and PermCom,
  2935 00000D42 7517                    	jne	short Ret_2e			; must be int_2e
  2936                                  
  2937                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  2938                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  2939                                  ;	case we decide to do that.)
  2940                                  
  2941 00000D44 A1[4101]                	mov	ax,[Parent]
  2942                                  	;mov	[16h],ax
  2943 00000D47 A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  2944 00000D4A A1[4301]                	mov	ax,[OldTerm]
  2945                                  	;mov	[0Ah],ax
  2946 00000D4D A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  2947 00000D50 A1[4501]                	mov	ax,[OldTerm+2]
  2948                                  	;mov	[0Ch],ax
  2949 00000D53 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  2950 00000D56 B8004C                  	mov	ax,4C00h
  2951                                  	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  2952 00000D59 CD21                    	int	21h
  2953                                  Ret_2e:
  2954                                  ;SR;
  2955                                  ; We will ensure that ds = DATARES for all entries to this place
  2956                                  ;
  2957                                  
  2958                                  ;;	push	cs
  2959                                  ;;	pop	ds
  2960                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  2961                                    	
  2962                                  ;	assume	ds:DATARES
  2963                                  
  2964                                  	;PUSH	CS
  2965                                  	;POP	DS
  2966                                  
  2967 00000D5B C706[A601]0000          	mov	word [SingleCom],0	; turn off SingleCom
  2968 00000D61 8E06[5F03]              	mov	es,[Res_Tpa]
  2969                                  	;mov	ah,49h	; 12/01/2023
  2970 00000D65 B449                    	mov	ah,DEALLOC
  2971 00000D67 CD21                    	int	21h			; free up space used by transient
  2972 00000D69 8B1E[3F01]              	mov	bx,[Save_Pdb]
  2973 00000D6D B450                    	mov	ah,50h
  2974                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  2975 00000D6F CD21                    	int	21h			; current process is user
  2976 00000D71 A1[9D01]                	mov	ax,[RetCode]
  2977 00000D74 803E[9C01]00            	cmp	byte [ExtCom],0
  2978 00000D79 7502                    	jne	short GotECode
  2979 00000D7B 31C0                    	xor	ax,ax			; internals always return 0
  2980                                  GotECode:
  2981 00000D7D C606[9C01]01            	mov	byte [ExtCom],1		; force external
  2982                                  
  2983                                  ;SR; This is actually returning to the caller. However, the old code had
  2984                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  2985                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  2986                                  
  2987                                  	; 12/01/2023
  2988 00000D82 FF2E[3B01]              	jmp	far [Int_2e_Ret]	; "iret"
  2989                                  
  2990                                  ;***	Int_2e, magic command executer
  2991                                  
  2992                                  Int_2e:
  2993                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  2994                                  ;SR;
  2995                                  ;We are going to come here from the stub with the old ds and DATARES value
  2996                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  2997                                  
  2998                                  	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
  2999                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)
  3000                                  
  3001 00000D86 1F                      	pop	ds			; ds = DATARES
  3002                                  	;assume	ds:DATARES
  3003 00000D87 58                      	pop	ax
  3004                                  ;	;pop	ds:OldDS 		; Save old value of ds
  3005                                  
  3006                                  	;pop	word [cs:Int_2e_Ret]
  3007                                  	;pop	word [cs:Int_2e_Ret+2]	; store return address
  3008                                  	;pop	ax			; chuck flags
  3009 00000D88 8F06[3B01]              	pop	word [Int_2e_Ret]
  3010 00000D8C 8F06[3D01]              	pop	word [Int_2e_Ret+2]
  3011                                  	
  3012 00000D90 83C402                  	add	sp,2
  3013                                  
  3014                                  ;;	push	cs
  3015                                  ;;	pop	es
  3016                                  
  3017 00000D93 1E                      	push	ds
  3018 00000D94 07                      	pop	es			; es = DATARES
  3019                                  ;	;mov	ds,OldDS
  3020 00000D95 8ED8                    	mov	ds,ax
  3021                                  	;assume	ds:nothing		; ds = old value
  3022                                  
  3023 00000D97 BF8000                  	mov	di,80h
  3024 00000D9A B94000                  	mov	cx,64
  3025                                  ;	Bugbug:	cld
  3026 00000D9D F3A5                    	rep	movsw
  3027 00000D9F B451                    	mov	ah,51h
  3028                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3029 00000DA1 CD21                    	int	21h			; get user's header
  3030                                  	; 12/01/2023
  3031 00000DA3 26891E[3F01]            	mov	[es:Save_Pdb],bx
  3032                                  	;mov	[cs:Save_Pdb],bx
  3033 00000DA8 B450                    	mov	ah,50h
  3034                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3035                                  
  3036                                  ;;	mov	bx,cs
  3037                                  ;SR;
  3038                                  ;Set ds = DATARES because BadMemErr expects this
  3039                                  
  3040                                  	; 12/01/2023
  3041 00000DAA 06                      	push	es
  3042 00000DAB 1F                      	pop	ds
  3043                                  	;assume	ds:DATARES
  3044                                  
  3045 00000DAC 8CDB                    	mov	bx,ds			; es = our PSP now
  3046                                  	;mov	bx,cs
  3047                                  
  3048 00000DAE CD21                    	int	21h			; current process is me
  3049                                  	;mov	word [cs:SingleCom],81h
  3050                                  	;mov	byte [cs:ExtCom],1	; make sure this case forced
  3051                                  	; 12/01/2023
  3052 00000DB0 C706[A601]8100          	mov	word [SingleCom],81h
  3053 00000DB6 C606[9C01]01            	mov	byte [ExtCom],1		; make sure this case forced
  3054                                  
  3055                                  ;SR;
  3056                                  ;We can enter LodCom directly after a command shell is terminated or we
  3057                                  ;can fall thru from above. When we enter directly from the stub, the stack
  3058                                  ;has the old ds value and the data seg value on the stack, so that ds can
  3059                                  ;be properly set. To fake this, we push dummy values here.
  3060                                  
  3061                                  	; 12/01/2023
  3062 00000DBB 1E                      	push	ds			; old value of ds
  3063 00000DBC 1E                      	push	ds			; data seg value, ds = DATARES
  3064                                  LodCom: 				; termination handler
  3065 00000DBD 1F                      	pop	ds			; ds = DATARES
  3066                                  	;assume	ds:DATARES
  3067 00000DBE 83C402                  	add	sp,2
  3068                                  ;	;pop	OldDS			; store old ds
  3069                                  	;cmp	ExtCom,0
  3070 00000DC1 803E[9C01]00            	cmp	byte [ExtCom],0
  3071                                  	;cmp	byte [cs:ExtCom],0
  3072                                  	;jne	short @f	 	; internal cmd - memory allocated
  3073                                  	; 16/04/2023
  3074 00000DC6 7503                    	jne	short LodCom0 ; 24/09/2018
  3075 00000DC8 E98100                  	jmp	LodCom1
  3076                                  	;je	short LodCom1 ; 25/09/2018	
  3077                                  ;@@:
  3078                                  LodCom0: ; 24/09/2018
  3079 00000DCB BBFFFF                  	mov	bx,0FFFFh
  3080 00000DCE B448                    	mov	ah,48h	; 12/01/2023
  3081                                  	;mov	ah,ALLOC ; 48h	
  3082 00000DD0 CD21                    	int	21h		; DOS - 2+ - ALLOCATE MEMORY
  3083                                  				; BX = number of 16-byte paragraphs desired
  3084 00000DD2 E80A00                  	call	SetSize
  3085 00000DD5 83C020                  	add	ax,20h
  3086 00000DD8 39C3                    	cmp	bx,ax
  3087 00000DDA 730B                    	jnb	short MemOk		; > 512 byte buffer - good enough
  3088                                  BadMemErrJ:
  3089 00000DDC E93BFF                  	jmp	BadMemErr		; not enough memory
  3090                                  
  3091                                  ;***	SetSize - get transient size in paragraphs
  3092                                  
  3093                                  SetSize:
  3094                                  	; 12/01/2023
  3095                                  	;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
  3096                                  	;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
  3097 00000DDF B83E96                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
  3098 00000DE2 B104                    	mov	cl,4
  3099 00000DE4 D3E8                    	shr	ax,cl
  3100 00000DE6 C3                      	retn
  3101                                  
  3102                                  MemOk:
  3103                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  3104                                  
  3105 00000DE7 B448                    	mov	ah,48h
  3106                                  	;mov	ah,ALLOC  ; 48h
  3107 00000DE9 CD21                    	int	21h
  3108 00000DEB 72EF                    	jc	short BadMemErrJ	; memory arenas probably trashed
  3109                                  	;mov	byte [cs:ExtCom],0
  3110                                  	;mov	[cs:Res_Tpa],ax
  3111                                  	; 12/01/2023
  3112 00000DED C606[9C01]00            	mov	byte [ExtCom],0		; flag not to alloc again
  3113 00000DF2 A3[5F03]                	mov	[Res_Tpa],ax		; save current tpa segment
  3114                                  
  3115 00000DF5 2500F0                  	and	ax,0F000h
  3116 00000DF8 050010                  	add	ax,1000h		; round up to next 64k boundary
  3117 00000DFB 7212                    	jc	short Bad_Tpa		; memory wrap if carry set
  3118                                  
  3119                                  ;	Make sure that new boundary is within allocated range
  3120                                  
  3121                                  	;mov	dx,[cs:Res_Tpa]
  3122                                  	; 12/01/2023
  3123 00000DFD 8B16[5F03]              	mov	dx,[Res_Tpa]
  3124 00000E01 01DA                    	add	dx,bx			; compute maximum address
  3125 00000E03 39C2                    	cmp	dx,ax			; is 64k address out of range?
  3126 00000E05 7608                    	jbe	short Bad_Tpa
  3127                                  
  3128                                  ;	Must have 64K of usable space.
  3129                                  
  3130 00000E07 29C2                    	sub	dx,ax			; compute the usable space
  3131 00000E09 81FA0010                	cmp	dx,1000h		; is space >= 64k ?
  3132 00000E0D 7303                    	jae	short LTpaSet
  3133                                  Bad_Tpa:
  3134                                  	;mov	ax,[cs:Res_Tpa]
  3135                                  	; 12/01/2023
  3136 00000E0F A1[5F03]                	mov	ax,[Res_Tpa]
  3137                                  LTpaSet:
  3138                                  	;mov	[cs:LTPA],ax
  3139                                  	;mov	ax,[cs:Res_Tpa]
  3140                                  	; 12/01/2023
  3141 00000E12 A3[5103]                	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
  3142 00000E15 A1[5F03]                	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
  3143 00000E18 01C3                    	add	bx,ax
  3144                                  	;mov	[cs:MemSiz],bx
  3145 00000E1A 891E[9801]              	mov	[MemSiz],bx
  3146 00000E1E E8BEFF                  	call	SetSize
  3147 00000E21 29C3                    	sub	bx,ax
  3148                                  
  3149                                  	; MSDOS 6.0
  3150                                  
  3151                                  ;M038; Start of changes
  3152                                  ;Changes for Novell RPL. These guys reserve memory for themselves by
  3153                                  ;reducing int 12h size and add this memory to the system at autoexec time by
  3154                                  ;running a program that changes arenas. This changes the largest block that
  3155                                  ;command.com gets and so changes the transient segment. So, command.com does
  3156                                  ;a checksum at the wrong address and thinks that the transient is destroyed
  3157                                  ;and tries to reload it. At this point, no Comspec is defined and so the
  3158                                  ;reload fails, hanging the system. To get around this we just copy the
  3159                                  ;transient from the previous address to the new address(if changed) and
  3160                                  ;then let command.com do the checksum. So, if the transient area is not
  3161                                  ;corrupted, there will not be any reload. In Novell's case, the transient
  3162                                  ;is not really corrupted and so this should work.
  3163                                  
  3164                                  	; 12/01/2023
  3165                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)
  3166                                  
  3167 00000E23 3B1E[9201]              	cmp	bx,[TrnSeg]		; Segment still the same?
  3168 00000E27 7423                    	je	short LodCom1		; yes, dont copy
  3169                                  
  3170                                  ;Check if the new segment is above or below the current move. If the new
  3171                                  ;segment is above (i.e new block is larger than previous block), then we
  3172                                  ;have to move in the reverse direction
  3173                                  
  3174                                  	;mov	cx,98C5h
  3175 00000E29 B92F96                  	mov	cx,TRANSPACEEND		; cx = length to move
  3176 00000E2C 7707                    	ja	short mov_down		; new seg > old seg, reverse move
  3177 00000E2E 31F6                    	xor	si,si			; normal move
  3178 00000E30 89F7                    	mov	di,si
  3179 00000E32 FC                      	cld
  3180 00000E33 EB06                    	jmp	short copy_trans
  3181                                  mov_down:
  3182 00000E35 89CE                    	mov	si,cx			; reverse move, start from end
  3183 00000E37 4E                      	dec	si
  3184 00000E38 89F7                    	mov	di,si
  3185 00000E3A FD                      	std
  3186                                  copy_trans:
  3187 00000E3B 1E                      	push	ds
  3188 00000E3C 06                      	push	es
  3189 00000E3D 8EC3                    	mov	es,bx			; dest segment
  3190 00000E3F 8E1E[9201]              	mov	ds,[TrnSeg]		; source segment
  3191                                  	;assume	ds:nothing
  3192                                  
  3193 00000E43 F3A4                    	rep	movsb			; copy transient
  3194 00000E45 FC                      	cld
  3195 00000E46 07                      	pop	es
  3196 00000E47 1F                      	pop	ds
  3197                                  	;assume	ds:DATARES
  3198                                  
  3199                                  ;M038; End of changes
  3200                                  
  3201                                  	;mov	[cs:TrnSeg],bx		; new location of transient
  3202                                  	; 12/01/2023
  3203 00000E48 891E[9201]              	mov	[TrnSeg],bx
  3204                                  
  3205                                  LodCom1:
  3206                                  ;;	mov	ax,cs
  3207                                  ;;	mov	ss,ax
  3208                                  ;SR; At this point ds = DATARES which is where the stack is located
  3209                                  
  3210                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3211                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3212 00000E4C 8CD8                    	mov	ax,ds
  3213 00000E4E 8ED0                    	mov	ss,ax
  3214                                  	;assume	ss:DATARES
  3215                                  	;;mov	sp,offset DATARES:RStack
  3216                                  	;mov	sp,53Eh
  3217 00000E50 BC[3804]                	mov	sp,RStack
  3218                                  
  3219                                  ;;	mov	ds,ax
  3220                                  
  3221                                  	;assume	ds:DATARES
  3222                                  	
  3223                                  	; MSDOS 3.3
  3224                                  	;mov	ax,cs
  3225                                  	;mov	ss,ax
  3226                                  	;mov	sp,RSTACK
  3227                                  	;mov	ds,ax
  3228                                  
  3229 00000E53 E87B00                  	call	HeadFix			; close files, restore stdin, stdout
  3230 00000E56 31ED                    	xor	bp,bp			; flag command ok
  3231 00000E58 B8FFFF                  	mov	ax,-1
  3232 00000E5B 8706[A801]              	xchg	ax,[VerVal]
  3233 00000E5F 83F8FF                  	cmp	ax,-1
  3234 00000E62 7404                    	je	short NoSetVer
  3235 00000E64 B42E                    	mov	ah,2Eh
  3236                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  3237 00000E66 CD21                    	int	21h 		; DOS - SET VERIFY FLAG
  3238                                  				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  3239                                  NoSetVer:
  3240 00000E68 833E[A601]FF            	cmp	word [SingleCom],-1
  3241 00000E6D 7503                    	jne	short NoSng
  3242 00000E6F E9CBFE                  	jmp	FatalRet2		; we have finished the single command
  3243                                  NoSng:
  3244 00000E72 E87201                  	call	ChkSum			; check the transient
  3245                                  	;cmp	dx,[Sum]
  3246                                  	;je	short HavCom		; transient ok
  3247                                  	; 12/01/2023
  3248 00000E75 7412                    	jz	short HavCom
  3249                                  Bogus_Com:
  3250 00000E77 C606[4B01]01            	mov	byte [Loading],1	; flag DskErr routine
  3251 00000E7C E81E01                  	call	LoadCom
  3252                                  ChkSame:
  3253 00000E7F E86501                  	call	ChkSum
  3254                                  	;cmp	dx,[Sum]
  3255                                  	;je	short HavCom		; same command
  3256                                  	; 12/01/2023
  3257 00000E82 7405                    	jz	short HavCom
  3258                                  Also_Bogus:
  3259 00000E84 E85801                  	call	WrongCom
  3260 00000E87 EBF6                    	jmp	short ChkSame
  3261                                  
  3262                                  	; 12/01/2023
  3263                                  ;HavCom:
  3264                                  ;	; 25/09/2018
  3265                                  ;	mov     ax,(CHAR_OPER*256) ; 3700h
  3266                                  ;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3267                                  ;			; Return: AL = FFh unsupported subfunction
  3268                                  ;			; DL = current switch character
  3269                                  ;	mov     [RSWITCHAR],dl
  3270                                  ;	cmp     dl,'/'
  3271                                  ;	jnz     short USESLASH
  3272                                  ;	;mov	cl,'\'
  3273                                  ;	;mov	[RDIRCHAR],cl
  3274                                  ;	mov	byte [RDIRCHAR],'\'
  3275                                  ;USESLASH:
  3276                                  
  3277                                  HavCom:
  3278                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3279 00000E89 C606[4B01]00            	mov	byte [Loading],0		; flag to DskErr
  3280                                  	;;mov	si,offset DATARES:TranVars
  3281                                  	;mov	si,453h		; MSDOS 5.0 COMMAND.COM
  3282 00000E8E BE[4D03]                	mov	si,TranVars
  3283                                  	;;mov	di,offset TRANGROUP:HeadCall
  3284                                  	;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
  3285 00000E91 BF[DE8A]                	mov	di,HEADCALL
  3286 00000E94 8E06[9201]              	mov	es,[TrnSeg]
  3287 00000E98 FC                      	cld
  3288                                  	;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
  3289 00000E99 B9[6103]                	mov	cx,TranVarEnd
  3290 00000E9C 29F1                    	sub	cx,si
  3291 00000E9E F3A4                    	rep	movsb			; transfer info to transient
  3292 00000EA0 A1[9801]                	mov	ax,[MemSiz]
  3293 00000EA3 A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  3294                                  
  3295                                  ;***	TJmp - jump-off to transient
  3296                                  ;
  3297                                  ;	Public label so debugger can find this spot.
  3298                                  
  3299                                  TJmp:	; 12/01/2023
  3300 00000EA6 FF2E[9001]              	jmp	far [Trans]		; jmp dword ptr Trans
  3301                                  
  3302                                  ;***	TRemCheck - far version of RemCheck for transient
  3303                                  
  3304                                  TRemCheck:
  3305                                  	; 12/01/2023
  3306 00000EAA 1F                      	pop	ds			; ds = DATARES
  3307 00000EAB 83C402                  	add	sp,2			; discard old value of ds
  3308                                  
  3309 00000EAE E80100                  	call	RemCheck
  3310 00000EB1 CB                      	retf
  3311                                  
  3312                                  ;***	RemCheck
  3313                                  ;
  3314                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  3315                                  ;
  3316                                  ;	EXIT	ZR set if removeable media
  3317                                  ;		ZR clear if fixed media
  3318                                  ;
  3319                                  ;	USED	none
  3320                                  
  3321                                  	; 12/01/2023
  3322                                  RemCheck:
  3323 00000EB2 50                      	push	ax
  3324 00000EB3 53                      	push	bx
  3325 00000EB4 89C3                    	mov	bx,ax
  3326 00000EB6 B80844                  	mov	ax,4408h
  3327                                  	;mov	ax,(IOCTL<<8)+8 ; 4408h
  3328 00000EB9 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  3329 00000EBB 7304                    	jnc	short rcCont		
  3330                                  
  3331                                  ;	If an error occurred, assume the media is non-removable.
  3332                                  ;	AX contains the non-zero error code from the int 21, so
  3333                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  3334                                  ;	appear to be non-removable.				
  3335                                  					
  3336 00000EBD 09C0                    	or	ax,ax			
  3337 00000EBF EB05                    	jmp	short ResRegs
  3338                                  rcCont:
  3339 00000EC1 83E001                  	and	ax,1
  3340 00000EC4 F7D0                    	not	ax
  3341                                  ResRegs:
  3342 00000EC6 5B                      	pop	bx
  3343 00000EC7 58                      	pop	ax
  3344 00000EC8 C3                      	retn
  3345                                  
  3346                                  ;***	THeadFix
  3347                                  ;
  3348                                  ;	Far version of HeadFix, called from transient.
  3349                                  
  3350                                  THeadFix:
  3351                                  	; 12/01/2023
  3352 00000EC9 1F                      	pop	ds			; ds = DATARES
  3353 00000ECA 83C402                  	add	sp,2			; discard old ds value on stack
  3354                                  
  3355 00000ECD E80100                  	call	HeadFix
  3356 00000ED0 CB                      	retf
  3357                                  
  3358                                  ;***	HeadFix
  3359                                  
  3360                                  	; 12/01/2023
  3361                                  HeadFix:
  3362 00000ED1 E83101                  	call	SetVect			; set vectors to our values
  3363                                  
  3364                                  ;	Clean up header
  3365                                  
  3366                                  ;	Bugbug:	optimize:
  3367                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  3368                                  
  3369 00000ED4 31DB                    	xor	bx,bx			; BX = handle = 0
  3370 00000ED6 8B0E[A201]              	mov	cx,[Io_Save]		; CX = original stdin, stdout
  3371                                  	;mov	dx,[18h] 
  3372 00000EDA 8B161800                	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
  3373 00000EDE 38D1                    	cmp	cl,dl
  3374 00000EE0 7408                    	je	short Chk1		; stdin matches
  3375 00000EE2 B43E                    	mov	ah,3Eh
  3376                                  	;mov	ah,CLOSE  ; 3Eh
  3377 00000EE4 CD21                    	int	21h			; close stdin
  3378                                  	;mov	[18h],cl
  3379 00000EE6 880E1800                	mov	[PDB.JFN_TABLE],cl	; restore stdin
  3380                                  Chk1:
  3381 00000EEA 43                      	inc	bx			; BX = handle = 1
  3382 00000EEB 38F5                    	cmp	ch,dh			
  3383 00000EED 7408                    	je	short ChkOtherHand	; stdout matches
  3384 00000EEF B43E                    	mov	ah,3Eh
  3385                                  	;mov	ah,CLOSE
  3386 00000EF1 CD21                    	int	21h			; close stdout
  3387                                  	;mov	[19h],ch
  3388 00000EF3 882E1900                	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
  3389                                  ChkOtherHand:
  3390 00000EF7 83C304                  	add	bx,4			; skip handles 2,3,4
  3391 00000EFA B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  3392                                  					; (handles 0-4 already done)
  3393                                  CloseLoop:
  3394 00000EFD B43E                    	mov	ah,3Eh
  3395                                  	;mov	ah,CLOSE ; 3Eh
  3396 00000EFF CD21                    	int	21h			; close each handle
  3397 00000F01 43                      	inc	bx			; BX = next handle
  3398 00000F02 E2F9                    	loop	CloseLoop
  3399                                  
  3400                                  	; MSDOS 6.0
  3401                                  ;	Bugbug:	since this is for transient code, move it there
  3402                                  	
  3403                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3404                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)
  3405                                  
  3406                                  ;	M012: remove this CS -> DS. Must've been missed during
  3407                                  ;	purification.
  3408                                  ;;	push	ds			; save data segment
  3409                                  ;;	push	cs			; get local segment into DS
  3410                                  ;;	pop	ds			;
  3411 00000F04 803E[C501]FF            	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
  3412 00000F09 750E                    	jne	short Append_Fix_End	; no - just exit
  3413 00000F0B B807B7                  	mov	ax,0B707h
  3414                                  	;mov	ax,AppendSetState	; set the state of Append
  3415 00000F0E 8B1E[C301]              	mov	bx,[Append_State] 	; back to the original state
  3416 00000F12 CD2F                    	int	2Fh			;
  3417 00000F14 C606[C501]00            	mov	byte [Append_Flag],0	; set append flag to invalid
  3418                                  Append_Fix_End: 			;
  3419                                  ;;	pop	ds			; get data segment back
  3420 00000F19 C3                      	retn
  3421                                  
  3422                                  	; MSDOS 3.3
  3423                                  	;retn
  3424                                  
  3425                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  3426                                  ;
  3427                                  ;	ENTRY	nothing
  3428                                  ;
  3429                                  ;	EXIT	nothing
  3430                                  ;
  3431                                  ;	USED	flags
  3432                                  ;
  3433                                  ;	EFFECTS
  3434                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  3435                                  ;	  current program's stdin,stdout set to our stderr
  3436                                  ;
  3437                                  
  3438                                  ;SR;
  3439                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  3440                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  3441                                  
  3442                                  SavHand:
  3443                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  3444                                  
  3445                                  	; 12/01/2023
  3446                                  	;push	ds ; MSDOS 3.3
  3447                                  
  3448 00000F1A 53                      	push	bx			;preserve registers
  3449 00000F1B 50                      	push	ax
  3450                                  	; 12/01/2023
  3451 00000F1C 06                      	push	es
  3452 00000F1D 1E                      	push	ds			; save DATARES value
  3453                                  
  3454 00000F1E B451                    	mov	ah,51h
  3455                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3456 00000F20 CD21                    	int	21h			; BX = user's header seg addr
  3457 00000F22 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  3458                                  	;lds	bx,[34h]	
  3459 00000F24 C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
  3460 00000F28 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  3461                                  	; 12/01/2023
  3462 00000F2A 07                      	pop	es			; es = DATARES
  3463 00000F2B 06                      	push	es			; save it back on stack
  3464 00000F2C 26A3[4901]              	mov	[es:Handle01],ax	; save user's stdin, stdout
  3465                                  	;mov	[cs:HANDLE01],ax
  3466                                  
  3467                                  ;SR;
  3468                                  ; Use es to address Handle01 & our JFN_Table
  3469                                  
  3470                                  	; 12/01/2023
  3471                                  	;mov	al,[es:1Ah]
  3472 00000F30 26A01A00                	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
  3473                                  	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  3474 00000F34 88C4                    	mov	ah,al			; AH = COMMAND stderr
  3475 00000F36 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  3476                                  	; 12/01/2023
  3477 00000F38 1F                      	pop	ds			; restore registers
  3478 00000F39 07                      	pop	es
  3479 00000F3A 58                      	pop	ax
  3480 00000F3B 5B                      	pop	bx
  3481                                  	;pop	ds ; MSDOS 3.3
  3482 00000F3C C3                      	retn
  3483                                  
  3484                                  	;assume	ds:DATARES
  3485                                  GetComDsk2:
  3486 00000F3D E81F00                  	call	GetComDsk
  3487 00000F40 E909FF                  	jmp	LodCom1			; memory already allocated
  3488                                  
  3489                                  RestHand:
  3490 00000F43 1E                      	push	ds
  3491 00000F44 53                      	push	bx			; restore stdin, stdout to user
  3492 00000F45 50                      	push	ax
  3493                                  	; 12/01/2023
  3494 00000F46 B451                    	mov	ah,51h
  3495                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3496 00000F48 CD21                    	int	21h			; point to user's header
  3497 00000F4A A1[4901]                	mov	ax,[Handle01]
  3498 00000F4D 8EDB                    	mov	ds,bx
  3499                                  	;assume ds:NOTHING
  3500                                  	;lds	bx,[34h] 
  3501 00000F4F C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
  3502 00000F53 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  3503 00000F55 58                      	pop	ax
  3504 00000F56 5B                      	pop	bx
  3505 00000F57 1F                      	pop	ds
  3506 00000F58 C3                      	retn
  3507                                  
  3508                                  	;assume ds:DATARES,ss:DATARES
  3509                                  Hopeless:
  3510 00000F59 BA[DF04]                	mov	dx,COMBAD
  3511 00000F5C E9BEFD                  	jmp	FatalC
  3512                                  
  3513                                  GetComDsk:
  3514 00000F5F A0[9701]                	mov	al,[ComDrv]
  3515 00000F62 E84DFF                  	call	RemCheck
  3516 00000F65 75F2                    	jnz	short Hopeless		; non-removable media
  3517                                  GetComDsk3:
  3518 00000F67 81FA[DF04]              	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
  3519 00000F6B 7503                    	jne	short GetComDsk4
  3520                                  	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
  3521                                  	; 12/01/2023
  3522                                  	;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
  3523                                  	;invoke	RPrint			; say COMMAND is invalid
  3524 00000F6D E82103                  	call	RPrint
  3525                                  	;call	RDISPMSG
  3526                                  
  3527                                  GetComDsk4:
  3528                                  
  3529                                  ;	Bugbug:	there's always a drive here? No need to check?
  3530                                  
  3531 00000F70 803E[3201]00            	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
  3532 00000F75 7509                    	jne	short Users_Drive	; yes - use it
  3533 00000F77 B419                    	mov	ah,19h
  3534                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  3535 00000F79 CD21                    	int	21h
  3536 00000F7B 0441                    	add	al,"A"                  ; convert to ascii
  3537 00000F7D A2[3201]                	mov	[PutBackDrv],al		; put in message to print out
  3538                                  
  3539                                  Users_Drive:
  3540                                  	; 12/01/2023
  3541                                  	; MSDOS 6.0
  3542 00000F80 BA[F504]                	mov	dx,PUTBACKMSG		; prompt for diskette
  3543                                  	;mov	si,offset DATARES:PutBackSubst
  3544                                  	;invoke	RPrint
  3545 00000F83 BE[2C01]                	mov	si,PutBackSubst		; containing COMMAND
  3546 00000F86 E80803                  	call	RPrint
  3547                                  	;mov	dx,offset DATARES:Prompt
  3548                                  	;invoke	RPrint
  3549 00000F89 BA[1705]                	mov	dx,PROMPT		; "Press any key"
  3550 00000F8C E80203                  	call	RPrint
  3551                                  
  3552                                  	; MSDOS 3.3
  3553                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  3554                                  	;call	RDISPMSG
  3555                                  	;mov	dx,[PUTBACKSUBSTPTR]
  3556                                  	;mov	si,[COMSPEC_END]
  3557                                  	;mov	byte [si+1],'$'
  3558                                  	;call	RDISPMSG
  3559                                  	;mov	byte [si+1],0
  3560                                  	;mov	dx,PROMPT
  3561                                  	;call	RDISPMSG
  3562                                  
  3563                                  	;call	GetRawFlushedByte
  3564                                  	;retn
  3565                                  	; 12/01/2023
  3566                                  	;jmp	short GetRawFlushedByte
  3567                                  
  3568                                  ;***	GetRawFlushedByte - flush world and get raw input
  3569                                  
  3570                                  GetRawFlushedByte:
  3571                                  	; 12/01/2023
  3572 00000F8F B8070C                  	mov	ax,0C07h
  3573                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  3574 00000F92 CD21                    	int	21h			; get char without testing or echo
  3575 00000F94 B8000C                  	mov	ax,0C00h
  3576                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  3577 00000F97 CD21                    	int	21h
  3578                                  
  3579                                  ;	Bugbug:	get rid of this return and the following retz.
  3580                                  
  3581                                  LoadCom_retn:
  3582 00000F99 C3                      	retn
  3583                                  
  3584                                  	; 21/04/2023
  3585                                  TryDoOpen:
  3586 00000F9A E8C2FF                  	call	GetComDsk
  3587                                  	;jmp	short LoadCom
  3588                                  
  3589                                  ;***	LoadCom - load in transient
  3590                                  
  3591                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3592                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)
  3593                                  
  3594                                  LoadCom:
  3595                                  	;assume	ds:DATARES
  3596                                  	
  3597 00000F9D 45                      	inc	bp				; flag command read
  3598                                  
  3599 00000F9E BA[4E01]                	mov	dx,ComSpec
  3600 00000FA1 B8003D                  	mov	ax,3D00h
  3601                                  	;mov	ax,OPEN<<8	; 3D00h
  3602 00000FA4 CD21                    	int	21h				; open command.com
  3603 00000FA6 730B                    	jnc	short ReadCom
  3604                                  	;cmp	ax,4
  3605 00000FA8 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  3606 00000FAB 75ED                    	jnz	short TryDoOpen
  3607 00000FAD BA[A105]                	mov	dx,NOHANDMES
  3608 00000FB0 E96AFD                  	jmp	FatalC				; will never find a handle
  3609                                  
  3610                                  	; 21/04/2023
  3611                                  ;TryDoOpen:
  3612                                  	;call	GetComDsk
  3613                                  	;jmp	short LoadCom
  3614                                  
  3615                                  ReadCom:
  3616 00000FB3 89C3                    	mov	bx,ax				; BX = handle
  3617                                  	;mov	dx,offset RESGROUP:TranStart
  3618 00000FB5 BA4022                  	mov	dx,TRANSTART
  3619 00000FB8 31C9                    	xor	cx,cx				; CX:DX = seek loc
  3620 00000FBA B80042                  	mov	ax,4200h
  3621                                  	;mov	ax,LSEEK<<8	; 4200h
  3622 00000FBD CD21                    	int	21h
  3623 00000FBF 7210                    	jc	short WrongCom1
  3624                                  	; 12/01/2023
  3625                                  	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
  3626                                  	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
  3627 00000FC1 B92F95                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  3628 00000FC4 1E                      	push	ds
  3629 00000FC5 8E1E[9201]              	mov	ds,[TrnSeg]
  3630                                  	;assume	ds:NOTHING
  3631 00000FC9 BA0001                  	mov	dx,100h
  3632 00000FCC B43F                    	mov	ah,3Fh
  3633                                  	;mov	ah,READ	; 3Fh	
  3634 00000FCE CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  3635                                  			; BX = file handle, CX = number of bytes to read
  3636                                  			; DS:DX -> buffer
  3637 00000FD0 1F                      	pop	ds
  3638                                  	;assume	ds:DATARES
  3639                                  WrongCom1:
  3640 00000FD1 9C                      	pushf
  3641 00000FD2 50                      	push	ax
  3642 00000FD3 B43E                    	mov	ah,3Eh
  3643                                  	;mov	ah,CLOSE ; 3Eh
  3644 00000FD5 CD21                    	int	21h			; close command.com
  3645 00000FD7 58                      	pop	ax
  3646 00000FD8 9D                      	popf
  3647 00000FD9 7204                    	jc	short WrongCom		; error on read
  3648 00000FDB 39C8                    	cmp	ax,cx
  3649                                  	;retz				; size matched
  3650 00000FDD 74BA                    	jz	short LoadCom_retn
  3651                                  WrongCom:
  3652 00000FDF BA[DF04]                	mov	dx,COMBAD
  3653 00000FE2 E87AFF                  	call	GetComDsk
  3654 00000FE5 EBB6                    	jmp	short LoadCom		; try again
  3655                                  
  3656                                  ;***	ChkSum - compute transient checksum
  3657                                  
  3658                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3659                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
  3660                                  ChkSum:
  3661 00000FE7 1E                      	push	ds
  3662 00000FE8 8E1E[9201]              	mov	ds,[TrnSeg]
  3663 00000FEC BE0001                  	mov	si,100h
  3664                                  	;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
  3665                                  	;mov	cx,87C2h
  3666 00000FEF B9[2B85]                	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
  3667                                  Check_Sum:
  3668 00000FF2 FC                      	cld
  3669 00000FF3 D1E9                    	shr	cx,1
  3670 00000FF5 31D2                    	xor	dx,dx
  3671                                  Chk:
  3672 00000FF7 AD                      	lodsw
  3673 00000FF8 01C2                    	add	dx,ax
  3674 00000FFA 83D200                  	adc	dx,0
  3675 00000FFD E2F8                    	loop	Chk
  3676                                  
  3677                                  	; 04/05/2023
  3678 00000FFF 1F                      	pop	ds
  3679                                  
  3680                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3681 00001000 3B16[9A01]              	cmp	dx,[Sum]
  3682                                  
  3683                                  	;pop	ds ; 04/05/2023
  3684 00001004 C3                      	retn
  3685                                  
  3686                                  ;***	SetVect - set interrupt vectors
  3687                                  
  3688                                  SetVect:
  3689                                  	;mov	dx,offset DATARES:LodCom_Trap 
  3690                                  	; 12/01/2023
  3691 00001005 BA[7E00]                	mov	dx,LodCom_Trap
  3692                                  	;mov	dx,LODCOM ; MSDOS 3.3
  3693 00001008 B82225                  	mov	ax,2522h
  3694                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  3695 0000100B 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  3696 0000100F 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  3697 00001013 CD21                    	int	21h
  3698                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  3699 00001015 BA[4A00]                	mov	dx,Ctrlc_Trap
  3700                                  	;mov	dx,CONTC ; MSDOS 3.3
  3701 00001018 FEC0                    	inc	al	; 23h
  3702 0000101A CD21                    	int	21h
  3703                                  	;mov	dx,offset DATARES:CritErr_Trap
  3704 0000101C BA[5500]                	mov	dx,CritErr_Trap
  3705                                  	;mov	dx,CRITERR ; MSDOS 3.3
  3706 0000101F FEC0                    	inc	al	; 24h
  3707 00001021 CD21                    	int	21h
  3708 00001023 C3                      	retn
  3709                                  
  3710                                  	; MSDOS 6.0
  3711                                  ;;SR;
  3712                                  ;We have this to take care of the extra values pushed on the stack by 
  3713                                  ;the stub before jumping to LodCom1. We set up ds here and then jump to
  3714                                  ;Lodcom1
  3715                                  
  3716                                  ;public	TrnLodCom1
  3717                                  	; 12/01/2023
  3718                                  TrnLodCom1:
  3719 00001024 1F                      	pop	ds			; ds = DATARES
  3720 00001025 83C402                  	add	sp,2
  3721                                  ;	pop	ds:OldDS
  3722 00001028 E921FE                  	jmp	LodCom1
  3723                                  
  3724                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3725                                  
  3726                                  %if 0
  3727                                  
  3728                                  ;***	EndInit - end up initialization sequence
  3729                                  ;
  3730                                  ;	Move the environment to a newly allocated segment.
  3731                                  
  3732                                  	; MSDOS 3.3
  3733                                  ENDINIT:
  3734                                  	push	ds			; save segments
  3735                                  	push	es			;
  3736                                  	push	cs			; get resident segment to DS
  3737                                  	pop	ds			;
  3738                                  	;assume	ds:RESGROUP
  3739                                  	mov	cx,[USEDENV]		; get number of bytes to move
  3740                                  	mov	es,[ENVIRSEG]		; get target environment segment
  3741                                  	;assume	es:NOTHING
  3742                                  
  3743                                  	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  3744                                  	jne	short NO_RESET 		; no - we already did it
  3745                                  	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  3746                                  	push	es			; save environment - just to be sure
  3747                                  	mov	ah,SETBLOCK  ; 4Ah	;
  3748                                  	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  3749                                  				; ES = segment address of block to change
  3750                                  				; BX = new size in paragraphs
  3751                                  	pop	es
  3752                                  
  3753                                  NO_RESET:
  3754                                  	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  3755                                  	mov	ds,[OLDENV]		; source environment segment
  3756                                  	;assume	ds:NOTHING
  3757                                  	xor	si,si			; set up offsets to start of segments
  3758                                  	xor	di,di
  3759                                  	cld
  3760                                  	rep	movsb			; move it
  3761                                  	xor	ax,ax
  3762                                  	stosb				; make sure it ends with double-null
  3763                                  
  3764                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  3765                                  	pop	es
  3766                                  	pop	ds
  3767                                  	jmp	LODCOM			; allocate transient
  3768                                  
  3769                                  	; MSDOS 6.0
  3770                                  
  3771                                  ;The init code has been changed to take care of the new way in which the
  3772                                  ;environment segment is allocated.
  3773                                  ;NB: We can use all the init variables at this point because they are all in
  3774                                  ;RESGROUP
  3775                                  ;Bugbug: The above approach will not work for ROMDOS
  3776                                  
  3777                                  ;IF 0
  3778                                  ;
  3779                                  ;EndInit:
  3780                                  ;	push	ds
  3781                                  ;	push	es			;save segments
  3782                                  ;	push	cs
  3783                                  ;	pop	ds		
  3784                                  ;	assume	ds:RESGROUP
  3785                                  ;;
  3786                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  3787                                  ;;
  3788                                  ;	mov	bx,ds
  3789                                  ;	mov	es,bx			;es = RESGROUP
  3790                                  ;;
  3791                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  3792                                  ;; code + data for low COMMAND
  3793                                  ;;
  3794                                  ;	mov	bx,ResSize		;Total size of resident
  3795                                  ;	mov	ah,SETBLOCK
  3796                                  ;	int	21h			;Set block to resident size
  3797                                  ;;
  3798                                  ;;Allocate the correct size for the environment
  3799                                  ;;
  3800                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  3801                                  ;	mov	ah,ALLOC
  3802                                  ;	int	21h			;get memory
  3803                                  ;	jc	nomem_err		;out of memory,signal error
  3804                                  ;
  3805                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  3806                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  3807                                  ;	mov	es,ax			;es = address of allocated memory
  3808                                  ;	assume	es:nothing
  3809                                  ;
  3810                                  ;;
  3811                                  ;;Copy the environment to the newly allocated segment
  3812                                  ;;
  3813                                  ;	mov	cx,UsedEnv		;number of bytes to move
  3814                                  ;
  3815                                  ;	push	ds
  3816                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  3817                                  ;	assume	ds:nothing
  3818                                  ;
  3819                                  ;	xor	si,si
  3820                                  ;	mov	di,si			;Start transfer from 0
  3821                                  ;
  3822                                  ;	cld
  3823                                  ;	rep	movsb			;Do the copy
  3824                                  ;
  3825                                  ;	xor	ax,ax			
  3826                                  ;	stosb				;Make it end with double-null
  3827                                  ;
  3828                                  ;	pop	ds			;ds = RESGROUP
  3829                                  ;	assume	ds:RESGROUP
  3830                                  ;;
  3831                                  ;;We have to free the old environment block if it was allocated by INIT
  3832                                  ;;
  3833                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  3834                                  ;	je      no_free                 ;no, do not free it
  3835                                  ;
  3836                                  ;	mov	ax,OldEnv		;Get old environment
  3837                                  ;	mov	es,ax
  3838                                  ;	mov	ah,DEALLOC	
  3839                                  ;	int	21h			;Free it
  3840                                  ;no_free:
  3841                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  3842                                  ;	
  3843                                  ;	pop	es
  3844                                  ;	pop	ds
  3845                                  ;	assume	ds:nothing
  3846                                  ;	
  3847                                  ;	jmp	LodCom			;allocate transient
  3848                                  ;
  3849                                  ;nomem_err:
  3850                                  ;;
  3851                                  ;;We call the error routine which will never return. It will either exit
  3852                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  3853                                  ;;message ( if first COMMAND )
  3854                                  ;;
  3855                                  ;
  3856                                  ;	call	Alloc_error
  3857                                  ;ENDIF
  3858                                  ;
  3859                                  ;CODERES ends
  3860                                  
  3861                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3862                                  ;	the resident group which is the location where the transient
  3863                                  ;	segments will be loaded initial.
  3864                                  
  3865                                  ;TAIL		segment public para
  3866                                  ;
  3867                                  ;		org	0
  3868                                  ;TranStart	label	word
  3869                                  ;		public	TranStart
  3870                                  ;
  3871                                  ;TAIL		ends
  3872                                  ;
  3873                                  
  3874                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3875                                  ;	the transient group which is the location where the exec
  3876                                  ;	segments will be loaded initial.
  3877                                  ;
  3878                                  ;	Bugbug:	Is TRANTAIL used anymore?
  3879                                  
  3880                                  ;TRANTAIL	segment public para
  3881                                  ;
  3882                                  ;		org	0
  3883                                  ;ExecStart   	label   word
  3884                                  ;
  3885                                  ;TRANTAIL    	ends
  3886                                  
  3887                                  %endif ; 12/01/2023
  3888                                  
  3889                                  ;=============================================================================
  3890                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  3891                                  ;=============================================================================
  3892                                  ; 22/09/2018 - Retro DOS v3.0
  3893                                  
  3894                                  ;	title	Localizable code for resident COMMAND
  3895                                  
  3896                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  3897                                  
  3898                                  ; ----------------------------------------------------------------------------
  3899                                  ;***	AskEnd - ask user to confirm batch file termination
  3900                                  ;
  3901                                  ;	Confirm with user before freeing batch ...
  3902                                  ;
  3903                                  ;	ENTRY	nothing
  3904                                  ;
  3905                                  ;	EXIT	CY = set if batch termination is confirmed
  3906                                  ;
  3907                                  ;		CY = clear if batch should continue
  3908                                  ;
  3909                                  ;	USED	AX,DX,...
  3910                                  ;
  3911                                  ;	Bugbug:	move this to transient, copy to batch segment.
  3912                                  ;	Bugbug:	or move it to command1 1st.
  3913                                  ;
  3914                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  3915                                  ; ----------------------------------------------------------------------------
  3916                                  
  3917                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3918                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)
  3919                                  
  3920                                  AskEnd:
  3921                                  	;assume	ds:DATARES
  3922                                  
  3923 0000102B BA[3905]                	mov	dx,ENDBATMES			; DX = message #
  3924 0000102E E86002                  	call	RPrint
  3925                                  	;call	RDISPMSG  ; MSDOS 3.3
  3926 00001031 B8010C                  	mov	ax,0C01h
  3927                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  3928 00001034 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  3929                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  3930 00001036 E8F102                  	call	CharToUpper			; change to upper case
  3931 00001039 3A06[4004]              	cmp	al,[NO_CHAR]
  3932 0000103D 7407                    	je	short aeRet			; answer is no (CY is clear)
  3933 0000103F 3A06[3F04]              	cmp	al,[YES_CHAR]
  3934 00001043 75E6                    	jne	short AskEnd			; invalid response, try again
  3935 00001045 F9                      	stc					; answer is yes
  3936                                  aeRet:	
  3937 00001046 C3                      	retn
  3938                                  
  3939                                  ; ----------------------------------------------------------------------------
  3940                                  ;***	DskErr - critical error handler
  3941                                  ;
  3942                                  ;	Default critical error handler unless user intercepts int 24h.
  3943                                  ;
  3944                                  ;	ENTRY	int 24h
  3945                                  ;
  3946                                  ;	EXIT
  3947                                  ;
  3948                                  ;	USED
  3949                                  ;
  3950                                  ;	EFFECTS
  3951                                  ; ----------------------------------------------------------------------------
  3952                                  
  3953                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3954                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)
  3955                                  
  3956                                  ;SR; 
  3957                                  ;The stub is going to push the old ds value and the resident data segment
  3958                                  ;onto the stack in that order. Get it off the stack
  3959                                  
  3960                                  ;DskErr	proc	far
  3961                                  DSKERR:
  3962                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  3963                                  	; 12/01/2023
  3964 00001047 1F                      	pop	ds			; ds = DATARES
  3965                                  	;assume ds:DATARES
  3966 00001048 8F06[3804]              	pop	word [OldDS]		; save old ds value
  3967                                  
  3968                                  ;CRITERR: ; MSDOS 3.3
  3969 0000104C FB                      	sti
  3970                                  	; 12/01/2023
  3971                                  	;push	ds ; 25/09/2018
  3972 0000104D 06                      	push	es
  3973 0000104E 56                      	push	si
  3974 0000104F 51                      	push	cx
  3975 00001050 57                      	push	di
  3976 00001051 51                      	push	cx
  3977 00001052 50                      	push	ax
  3978                                  
  3979 00001053 1E                      	push	ds			;save our data segment
  3980                                  	;push	cs ; 25/09/2018
  3981 00001054 07                      	pop	es			;es = DATARES
  3982                                  
  3983 00001055 8EDD                    	mov	ds,bp
  3984                                  	;assume	ds:nothing
  3985                                  
  3986                                  	;mov	ax,[si].SDEVATT
  3987 00001057 8B4404                  	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
  3988 0000105A 268826[2801]            	mov	[es:CDevAt],ah
  3989                                  
  3990                                  	;push	cs
  3991                                  	;pop	es
  3992                                  
  3993 0000105F BF[0601]                	mov	di,DevName
  3994 00001062 B90800                  	mov	cx,8
  3995                                  	;add	si,SDEVNAME  ; add si,10
  3996 00001065 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  3997                                  				
  3998 00001068 FC                      	cld
  3999 00001069 F3A4                    	rep	movsb
  4000 0000106B 58                      	pop	ax
  4001 0000106C 59                      	pop	cx
  4002 0000106D 5F                      	pop	di
  4003                                  
  4004                                  ;	Stack still contains DS and ES.
  4005                                  
  4006                                  ;SR;
  4007                                  ;We need ds = DATARES for SavHand
  4008                                  
  4009                                  	 ;12/01/2023
  4010 0000106E 06                      	push	es
  4011 0000106F 1F                      	pop	ds
  4012                                  	;assume	ds:DATARES
  4013                                  
  4014                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  4015 00001070 E8A7FE                  	call	SavHand
  4016                                  
  4017                                  	; 12/01/2023
  4018                                  	; 25/09/2018
  4019                                  	;;push	cs
  4020                                  	;push	es
  4021                                  	;pop	ds		; set up local data segment
  4022                                  	;assume	ds:resgroup
  4023                                  
  4024 00001073 52                      	push	dx
  4025 00001074 E81702                  	call	crlf
  4026 00001077 5A                      	pop	dx
  4027                                  
  4028                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  4029                                  
  4030 00001078 8826[9F01]              	mov	[Crit_Err_Info],ah	; save critical error flags
  4031                                  
  4032                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  4033                                  
  4034 0000107C 0441                    	add	al,'A'
  4035 0000107E A2[FF00]                	mov	[DrvLet],al
  4036                                  
  4037                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  4038                                  
  4039 00001081 F6C480                  	test	ah,80h
  4040 00001084 740A                    	jz	short NoHardE		; it's a disk-device error
  4041 00001086 F606[2801]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4042 0000108B 7503                    	jnz	short NoHardE		; it's a character device
  4043 0000108D E9F101                  	jmp	FatErr			; it's a FAT error
  4044                                  
  4045                                  NoHardE:
  4046 00001090 BE[6104]                	mov	si,MREAD		; SI = "read" msg #
  4047 00001093 F6C401                  	test	ah,1
  4048 00001096 7403                    	jz	short SavMes		; it's a read error
  4049 00001098 BE[6A04]                	mov	si,MWRITE		; SI = "write" msg #
  4050                                  SavMes:
  4051 0000109B 893E[6103]              	mov	[OldErrNo],di		; save critical error code
  4052                                  
  4053                                  ;	Bugbug:	don't need to save/restore all here?
  4054                                  
  4055 0000109F 06                      	push	es
  4056 000010A0 1E                      	push	ds			; GetExtendedError likes to STOMP
  4057                                  	; 12/01/2023
  4058                                  	; (all registers are changed -in dos service- except bp) *
  4059                                  	;push	bp
  4060 000010A1 56                      	push	si
  4061 000010A2 52                      	push	dx
  4062 000010A3 51                      	push	cx
  4063 000010A4 53                      	push	bx
  4064 000010A5 B43B                    	mov	ah,59 ; *
  4065                                  	;mov	ah,GetExtendedError ; 59h ; get extended error info
  4066 000010A7 CD21                    	int	21h
  4067 000010A9 5B                      	pop	bx
  4068 000010AA 59                      	pop	cx
  4069 000010AB 5A                      	pop	dx
  4070 000010AC 5E                      	pop	si
  4071                                  	; 12/01/2023
  4072                                  	;pop	bp
  4073 000010AD 1F                      	pop	ds
  4074 000010AE 893E[3601]              	mov	[NeedVol],di		; save possible ptr to volume label
  4075 000010B2 8C06[3801]              	mov	[NeedVol+2],es
  4076 000010B6 07                      	pop	es
  4077                                  
  4078                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  4079                                  
  4080 000010B7 30E4                    	xor	ah,ah
  4081 000010B9 89C7                    	mov	di,ax			; DI = error code
  4082                                  
  4083                                  ; Bugbug: somewhat obsolete documentation?
  4084                                  ;
  4085                                  ; DI is now the correct error code. Classify things to see what we are
  4086                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  4087                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  4088                                  ; the like) are contiguous.
  4089                                  
  4090                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  4091                                  ;	Check use of ErrCd_24, though.
  4092                                  
  4093 000010BB 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  4094 000010BE 7303                    	jae	short HavCod
  4095                                  
  4096                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  4097                                  ;	even though it's not a critical error?
  4098                                  
  4099 000010C0 BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  4100                                  
  4101                                  ; DI now has the mapped error code. Old style errors are:
  4102                                  ;   FOOBAR <read|writ>ing drive ZZ.
  4103                                  ; New style errors are:
  4104                                  ;   FOOBAR
  4105                                  ; We need to figure out which the particular error belongs to.
  4106                                  
  4107                                  HavCod:
  4108 000010C3 C606[3A01]00            	mov	byte [ErrType],0	; assume old style
  4109 000010C8 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  4110 000010CB 7405                    	je	short SetStyle
  4111 000010CD 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4112 000010D0 7504                    	jne	short GotStyle
  4113                                  
  4114                                  SetStyle:
  4115                                  ;	Bugbug:	use INC
  4116                                  	;mov	byte [ErrType],1		; must be new type
  4117 000010D2 FE06[3A01]              	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  4118                                  
  4119                                  GotStyle:
  4120 000010D6 893E[4701]              	mov	[ErrCd_24],di
  4121                                  	; 12/01/2023
  4122                                  	; 25/09/2018
  4123                                  	; MSDOS 6.0
  4124 000010DA 83FF14                  	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  4125                                  	; MSDOS 3.3
  4126                                  	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4127                                  
  4128                                  						; If the error message is unknown
  4129 000010DD 7642                    	jbe	short NormalError		;  redirector, continue. Otherwise,
  4130                                  
  4131                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  4132                                  ; how to handle things
  4133                                  
  4134                                  ;input to IFSFUNC:    AL=1
  4135                                  ;		      BX=extended error number
  4136                                  ;
  4137                                  ;output from IFSFUNC: AL=error type (0 or 1)
  4138                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  4139                                  ;			   Abort, Retry, Ignore
  4140                                  ;			 1=<message>
  4141                                  ;			   Abort, Retry, Ignore
  4142                                  ;		      ES:DI=pointer to message text
  4143                                  ;		      carry set=>no message
  4144                                  
  4145 000010DF 89C7                    	mov	di,ax			; retrieve correct extended error...
  4146 000010E1 B80005                  	mov	ax,0500h		; is the redir there?
  4147 000010E4 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  4148                                  			; Return: AL = 00h not installed, OK to install
  4149                                  			; 01h not installed, can't install
  4150                                  			; FFh installed
  4151 000010E6 3CFF                    	cmp	al,0FFh
  4152 000010E8 752A                    	jne	short NoHandler		; no, go to NoHandler
  4153                                  
  4154                                  	; 12/01/2023
  4155                                  	; MSDOS 6.0
  4156 000010EA 53                      	push	bx
  4157 000010EB 89FB                    	mov	bx,di			; get ErrType and ptr to error msg
  4158 000010ED B80105                  	mov	ax,0501h
  4159 000010F0 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4160 000010F2 5B                      	pop	bx 
  4161 000010F3 721F                    	jc	short NoHandler
  4162                                  	
  4163                                  	; MSDOS 3.3
  4164                                  	;mov     ax,di
  4165                                  	;mov     ah,5
  4166                                  	;int     2Fh	; Multiplex - DOS 3+ CRITIChhgdffdAL ERROR HANDLER -
  4167                                  	;jc      short NOHANDLER
  4168                                  
  4169                                  ;	Bugbug:	need to record error type?
  4170                                  
  4171 000010F5 A2[3A01]                	mov	[ErrType],al
  4172                                  
  4173 000010F8 1E                      	push	ds
  4174 000010F9 06                      	push	es
  4175 000010FA 1F                      	pop	ds
  4176 000010FB 89FA                    	mov	dx,di
  4177 000010FD B9FFFF                  	mov	cx,-1			; find end of msg
  4178 00001100 30C0                    	xor	al,al
  4179                                  
  4180 00001102 FC                      	cld
  4181 00001103 F2AE                    	repnz	scasb
  4182                                  
  4183                                  ;	Bugbug:	we can do better than this.
  4184                                  
  4185 00001105 C645FF24                	mov	byte [di-1],'$'
  4186                                  	
  4187                                  	;CALL	RDISPMSG ; MSDOS 3.3
  4188                                  	
  4189 00001109 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  4190 0000110B CD21                    	int	21h
  4191                                  
  4192 0000110D C645FF00                	mov	byte [di-1],0			; restore terminal byte
  4193                                  
  4194 00001111 1F                      	pop	ds				; clean up and continue
  4195 00001112 EB15                    	jmp	short CheckErrType
  4196                                  
  4197                                  ;*	Redir isn't available or doesn't recognize the error.
  4198                                  ;	Restore regs to unextended error.
  4199                                  
  4200                                  NoHandler:
  4201 00001114 C606[3A01]00            	mov	byte [ErrType],0
  4202                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  4203 00001119 8B3E[6103]              	mov	di,[OldErrNo]
  4204 0000111D 893E[4701]              	mov	[ErrCd_24],di
  4205                                  
  4206                                  NormalError:
  4207                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4208                                  	; MSDOS 6.0
  4209 00001121 83C713                  	add	di,ERROR_WRITE_PROTECT
  4210 00001124 87FA                    	xchg	di,dx			; may need dx later
  4211 00001126 E88101                  	call	RPrintCrit		; print error type
  4212                                  
  4213                                  	; MSDOS 3.3
  4214                                  	;shl     di,1
  4215                                  	;mov     di,[CRMSGTBL+di]
  4216                                  	;xchg    di,dx
  4217                                  	;call    RDISPMSG
  4218                                  
  4219                                  CheckErrType:
  4220 00001129 803E[3A01]00            	cmp	byte [ErrType],0	; Check error style...
  4221 0000112E 7405                    	je	short ContOld
  4222 00001130 E85B01                  	call	crlf			; if new style then done printing
  4223 00001133 EB31                    	jmp	short Ask
  4224                                  
  4225                                  ContOld:
  4226                                  	; 12/01/2023
  4227                                  	; MSDOS 6.0
  4228 00001135 46                      	inc	si			; DS:SI = ptr to asciiz string
  4229                                  
  4230                                  ;	Bugbug:	combine some of the following two sections?
  4231                                  
  4232                                  	; 12/01/2023
  4233 00001136 F606[2801]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4234                                  	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
  4235 0000113B 740F                    	jz	short BlkErr
  4236                                  	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
  4237                                  	;mov	dx,ChardevErr
  4238 0000113D BA[8204]                	mov	dx,MDEVICE
  4239                                  	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
  4240 00001140 8936[0101]              	mov	[CharDevErrRw],si
  4241                                  	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  4242 00001144 BE[0001]                	mov	si,CharDevErrSubst
  4243                                  
  4244 00001147 E84701                  	call	RPrint				; print the message
  4245 0000114A EB1A                    	jmp	short Ask			; don't ralph on command
  4246                                  
  4247                                  	; 12/01/2023
  4248                                  	; MSDOS 3.3
  4249                                  	;mov	dx,ERRMES
  4250                                  	;call	RDISPMSG
  4251                                  	;mov	dx,si
  4252                                  	;call	RDISPMSG
  4253                                  	;
  4254                                  	;test	byte [CDevAt],80h
  4255                                  	;jz	short BLKERR
  4256                                  	;mov	dx,CHARDEVERR	; " device "
  4257                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4258                                  	;int	21h		; DOS - PRINT STRING
  4259                                  	;			; DS:DX -> string terminated by "$"
  4260                                  	;jmp	short ASK
  4261                                  
  4262                                  BlkErr:
  4263                                  	; 12/01/2023
  4264                                  	; MSDOS 6.0
  4265                                  	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
  4266                                  	;mov	dx,BlkDevErr
  4267 0000114C BA[7304]                	mov	dx,MDRIVE
  4268                                  	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
  4269 0000114F 8936[FA00]              	mov	[BlkDevErrRw],si
  4270                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  4271 00001153 BE[F900]                	mov	si,BlkDevErrSubst
  4272 00001156 E83801                  	call	RPrint
  4273                                  
  4274                                  	; MSDOS 3.3
  4275                                  	;mov	dx,BLKDEVERR
  4276                                  	;call	RDISPMSG
  4277                                  
  4278 00001159 803E[4B01]00            	cmp	byte [Loading],0
  4279 0000115E 7406                    	jz	short Ask
  4280 00001160 E8E0FD                  	call	RestHand
  4281 00001163 E9D7FD                  	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
  4282                                  Ask:
  4283 00001166 833E[4701]0F            	cmp	word [ErrCd_24],15	; error 15 has an extra message
  4284 0000116B 751E                    	jne	short Not15		; not error 15
  4285                                  
  4286                                  ;*	For error 15, tell the user which volume/serial # are needed.
  4287                                  
  4288 0000116D 51                      	push	cx
  4289                                  
  4290                                  ;	Bugbug:	does this push/pop need to be done?
  4291                                  
  4292 0000116E 1E                      	push	ds
  4293 0000116F 07                      	pop	es
  4294 00001170 C536[3601]              	lds	si,[NeedVol]
  4295                                  	;assume	ds:NOTHING
  4296 00001174 57                      	push	di
  4297 00001175 BF[1801]                	mov	di,VolName
  4298                                  	; 12/01/2023
  4299                                  	; MSDOS 6.0
  4300 00001178 B91000                  	mov	cx,16			; copy volume name & serial #
  4301                                  	; MSDOS 3.3
  4302                                  	;mov	cx,11			; copy volume name
  4303 0000117B FC                      	cld
  4304 0000117C F3A4                    	rep	movsb
  4305 0000117E 5F                      	pop	di
  4306 0000117F 06                      	push	es
  4307 00001180 1F                      	pop	ds
  4308 00001181 59                      	pop	cx
  4309                                  	;assume	ds:DATARES
  4310                                  	; 12/01/2023
  4311                                  	; MSDOS 6.0
  4312                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  4313                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  4314                                  	;mov	dx,NeedVolMsg
  4315 00001182 BA[9204]                	mov	dx,MVOLSERIAL
  4316 00001185 BE[0F01]                	mov	si,NeedVolSubst
  4317 00001188 E80601                  	call	RPrint
  4318                                  
  4319                                  	; MSDOS 3.3
  4320                                  	;mov	dx,NEEDVOLMSG
  4321                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4322                                  	;int	21h		; DOS - PRINT STRING
  4323                                  	;			; DS:DX -> string terminated by "$"
  4324                                  Not15:
  4325                                  ;*	Print abort, retry, ignore, fail message.
  4326                                  ;	Print only options that are valid.
  4327                                  
  4328                                  ;	Bugbug:	sizzle this.
  4329                                  
  4330                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4331 0000118B BA[4104]                	mov	dx,REQ_ABORT
  4332 0000118E E80001                  	call	RPrint
  4333                                  	;call	RDISPMSG
  4334 00001191 F606[9F01]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
  4335 00001196 7406                    	jz	short Try_Ignore
  4336 00001198 BA[4704]                	mov	dx,REQ_RETRY
  4337 0000119B E8F300                  	call	RPrint
  4338                                  	;call	RDISPMSG
  4339                                  Try_Ignore:
  4340 0000119E F606[9F01]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
  4341 000011A3 7406                    	jz	short Try_Fail
  4342 000011A5 BA[4F04]                	mov	dx,REQ_IGNORE
  4343 000011A8 E8E600                  	call	RPrint
  4344                                  	;call	RDISPMSG
  4345                                  Try_Fail:
  4346 000011AB F606[9F01]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
  4347 000011B0 7406                    	jz	short Term_Question
  4348 000011B2 BA[5804]                	mov	dx,REQ_FAIL
  4349 000011B5 E8D900                  	call	RPrint
  4350                                  	;call	RDISPMSG
  4351                                  Term_Question:
  4352 000011B8 BA[5F04]                	mov	dx,REQ_END
  4353 000011BB E8D300                  	call	RPrint
  4354                                  	;call	RDISPMSG
  4355                                  
  4356                                  ;	If the /f switch was given, we fail all requests.
  4357                                  
  4358 000011BE F606[AA01]FF            	test	byte [fFail],-1
  4359 000011C3 741B                    	jz	short DoPrompt
  4360 000011C5 B403                    	mov	ah,3				; signal fail
  4361 000011C7 E9A800                  	jmp	EExit
  4362                                  
  4363                                  	; 16/04/2023
  4364                                  Abort_Process:
  4365 000011CA F606[1702]01            	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
  4366 000011CF 745D                    	jz	short AbortCont			; no, handle it normally
  4367 000011D1 803E[A501]00            	cmp	byte [PermCom],0		; are we top level process?
  4368 000011D6 744B                    	jz	short JustExit			; yes, just exit
  4369                                  
  4370 000011D8 BA[4506]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  4371                                  	; 12/01/2023
  4372 000011DB E8B300                  	call	RPrint				; print it
  4373                                  	;call	RDISPMSG
  4374                                  DeadInTheWater:
  4375 000011DE EBFE                    	jmp	short DeadInTheWater		; loop until the user reboots
  4376                                  
  4377                                  DoPrompt:
  4378                                  	; 12/01/2023
  4379 000011E0 B8010C                  	mov	ax,0C01h
  4380                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  4381 000011E3 CD21                    	int	21h				; get response
  4382                                  
  4383 000011E5 E8A600                  	call	crlf
  4384 000011E8 E83F01                  	call	CharToUpper			; convert to upper case
  4385 000011EB B400                    	mov	ah,0				; return code for ignore
  4386 000011ED F606[9F01]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  4387 000011F2 7406                    	jz	short User_Retry
  4388 000011F4 3A06[3D04]              	cmp	al,[IGNORE_CHAR]		; ignore?
  4389                                  	;jz	short EExitJ
  4390                                  	; 16/04/2023
  4391 000011F8 7478                    	jz	short EExit
  4392                                  
  4393                                  ;	Bugbug:	optimize following code.
  4394                                  
  4395                                  User_Retry:
  4396 000011FA FEC4                    	inc	ah				; return code for retry
  4397 000011FC F606[9F01]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
  4398 00001201 7406                    	jz	short User_Abort
  4399 00001203 3A06[3C04]              	cmp	al,[RETRY_CHAR]			; retry?
  4400                                  	;jz	short EExitJ
  4401                                  	; 16/04/2023
  4402 00001207 7469                    	jz	short EExit
  4403                                  User_Abort:
  4404 00001209 FEC4                    	inc	ah				; return code for abort
  4405                                  						;  (abort always allowed)
  4406 0000120B 3A06[3B04]              	cmp	al,[ABORT_CHAR]			; abort?
  4407 0000120F 74B9                    	jz	short Abort_Process		; exit user program
  4408 00001211 FEC4                    	inc	ah				; return code for fail
  4409 00001213 F606[9F01]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
  4410 00001218 7406                    	jz	short AskJ
  4411 0000121A 3A06[3E04]              	cmp	al,[FAIL_CHAR]			; fail?
  4412                                  	;jz	short EExitJ
  4413                                  	; 16/04/2023
  4414 0000121E 7452                    	jz	short EExit
  4415                                  AskJ:
  4416 00001220 E943FF                  	jmp	Ask
  4417                                  
  4418                                  	; 12/01/2023
  4419                                  ;EExitJ:
  4420                                  	;jmp	short EExit
  4421                                  
  4422                                  JustExit:
  4423                                  	;assume	ds:DATARES
  4424                                  	; 12/01/2023
  4425 00001223 A1[4101]                	mov	ax,[Parent]			; load real parent pid
  4426                                  	;mov	[16h],ax
  4427 00001226 A31600                  	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
  4428 00001229 B8FF4C                  	mov	ax,4CFFh
  4429                                  	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
  4430 0000122C CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  4431                                  				; AL = exit code
  4432                                  AbortCont:
  4433 0000122E F606[9501]FF            	test	byte [In_Batch],-1		; Are we accessing a batch file?
  4434 00001233 7405                    	jz	short Not_Batch_Abort
  4435 00001235 C606[9601]01            	mov	byte [Batch_Abort],1		; set flag for abort
  4436                                  
  4437                                  Not_Batch_Abort:
  4438 0000123A 8A16[1802]              	mov	dl,[PipeFlag]
  4439 0000123E E8C8FA                  	call	ResPipeOff
  4440 00001241 08D2                    	or	dl,dl
  4441 00001243 740D                    	je	short CheckForA
  4442 00001245 833E[A601]00            	cmp	word [SingleCom],0
  4443 0000124A 7406                    	je	short CheckForA
  4444 0000124C C706[A601]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4445                                  
  4446                                  CheckForA:
  4447 00001252 833E[4701]00            	cmp	word [ErrCd_24],0		; write protect?
  4448 00001257 7407                    	je	short abortfor
  4449 00001259 833E[4701]02            	cmp	word [ErrCd_24],2		; drive not ready?
  4450 0000125E 7512                    	jne	short EExit			; don't abort the FOR
  4451                                  
  4452                                  abortfor:
  4453 00001260 C606[AC01]00            	mov	byte [ForFlag],0		; abort a FOR in progress
  4454 00001265 833E[A601]00            	cmp	word [SingleCom],0
  4455 0000126A 7406                    	je	short EExit
  4456 0000126C C706[A601]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4457                                  
  4458                                  EExit:
  4459 00001272 88E0                    	mov	al,ah
  4460 00001274 89FA                    	mov	dx,di
  4461                                  RestHd:
  4462 00001276 E8CAFC                  	call    RestHand
  4463 00001279 59                      	pop	cx
  4464 0000127A 5E                      	pop	si				; restore registers
  4465 0000127B 07                      	pop	es
  4466                                  
  4467                                  	; 12/01/2023	
  4468                                  	; MSDOS 6.0
  4469                                  ;;	pop	ds
  4470                                  ;SR;
  4471                                  ;ds has to be got from the variable we saved it in
  4472                                  
  4473 0000127C 8E1E[3804]               	mov	ds,[OldDS]			; restore old value of ds
  4474                                  
  4475                                  ;	pop	ds
  4476                                  ;	assume	ds:nothing
  4477                                  
  4478                                  	; MSDOS 3.3
  4479                                  	;pop	ds
  4480                                  
  4481 00001280 CF                      	iret
  4482                                  
  4483                                  FatErr:
  4484                                  	; 12/01/2023
  4485                                  	; MSDOS 6.0
  4486                                  	;mov	dx,offset DATARES:BadFatMsg
  4487                                  	;mov	si,offset DATARES:BadFatSubst
  4488 00001281 BA[B904]                	mov	dx,BADFATMSG
  4489 00001284 BE[2901]                	mov	si,BadFatSubst
  4490 00001287 E80700                  	call	RPrint
  4491                                  
  4492                                  	; MSDOS 3.3
  4493                                  	;mov	dx,BADFATMSG
  4494                                  	;call	RDISPMSG
  4495                                  	;mov	dx,BLKDEVERR
  4496                                  	;call	RDISPMSG
  4497                                  
  4498 0000128A B002                    	mov	al,2				; abort
  4499 0000128C EBE8                    	jmp	short RestHd
  4500                                  
  4501                                  ;DskErr	endp
  4502                                  
  4503                                  	; MSDOS 6.0
  4504                                  ; ----------------------------------------------------------------------------
  4505                                  ;***	RPrint - print message
  4506                                  ;***	Crlf - display cr/lf
  4507                                  ;
  4508                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  4509                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  4510                                  ;		variable fields related to substitution blocks are set
  4511                                  ;
  4512                                  ;	EXIT	nothing
  4513                                  ;
  4514                                  ;	USED	flags
  4515                                  ;
  4516                                  ;	EFFECTS
  4517                                  ;	  Message is displayed on stdout.
  4518                                  ;
  4519                                  ;	NOTE
  4520                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  4521                                  ;	  be greater than number of substition blocks present.
  4522                                  ; ----------------------------------------------------------------------------
  4523                                  
  4524                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4525                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)
  4526                                  
  4527                                  crlf: 
  4528                                  	;mov	dx,offset DATARES:Newlin ; cheap newline
  4529                                  	; 14/01/2023
  4530 0000128E BA[7406]                	mov	dx,NEWLINE
  4531                                  
  4532                                  ;RPrint	proc
  4533                                  ;
  4534                                  ;	assume	ds:DATARES,ss:DATARES
  4535                                  ;
  4536                                  	; 14/01/2023
  4537                                  RPrint:
  4538                                  
  4539                                  ;	Bugbug:	do we need to save all reg's?
  4540                                  
  4541 00001291 56                      	push	si			; preserve registers
  4542 00001292 50                      	push	ax
  4543 00001293 53                      	push	bx
  4544 00001294 51                      	push	cx
  4545 00001295 52                      	push	dx
  4546                                  
  4547 00001296 89F3                    	mov	bx,si			; DS:BX = ptr to subst block
  4548 00001298 89D6                    	mov	si,dx			; DS:SI = ptr to count byte
  4549 0000129A AC                      	lodsb				; AL = message length
  4550                                  					; DS:SI = ptr to message text
  4551 0000129B 31C9                    	xor	cx,cx
  4552 0000129D 88C1                    	mov	cl,al			; CX = message length
  4553 0000129F E303                    	jcxz	rpRet
  4554                                  
  4555 000012A1 E81900                  	call	RDispMsg
  4556                                  
  4557 000012A4 5A                      rpRet:	pop	dx
  4558 000012A5 59                      	pop	cx
  4559 000012A6 5B                      	pop	bx
  4560 000012A7 58                      	pop	ax
  4561 000012A8 5E                      	pop	si
  4562 000012A9 C3                      	retn
  4563                                  
  4564                                  ;RPrint	endp
  4565                                  
  4566                                  	; 14/01/2023
  4567                                  ;	; MSDOS 3.3
  4568                                  ;CRLF:
  4569                                  ;	mov     dx,NEWLIN
  4570                                  ;
  4571                                  ;RDISPMSG: ; Display message/text
  4572                                  ;	; DS:DX = ($ terminated) Message/Text address 
  4573                                  ;	push    ax
  4574                                  ;	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4575                                  ;	clc
  4576                                  ;	int     21h             ; DOS - PRINT STRING
  4577                                  ;				; DS:DX -> string terminated by "$"
  4578                                  ;	pop     ax
  4579                                  ;	retn
  4580                                  
  4581                                  
  4582                                  	; MSDOS 6.0
  4583                                  ; ----------------------------------------------------------------------------
  4584                                  ;***	RPrintCrit - print critical error message
  4585                                  ;
  4586                                  ;	ENTRY	DX = extended error # (19-39)
  4587                                  ;
  4588                                  ;	EXIT	nothing
  4589                                  ;
  4590                                  ;	USED	flags
  4591                                  ;
  4592                                  ;	EFFECTS
  4593                                  ;	  Message is displayed on stdout
  4594                                  ; ----------------------------------------------------------------------------
  4595                                  
  4596                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4597                                  
  4598                                  ;RPrintCrit	proc
  4599                                  ;	assume	ds:DATARES,ss:DATARES
  4600                                  
  4601                                  	; 14/01/2023
  4602                                  RPrintCrit:
  4603 000012AA 52                      	push	dx			; preserve DX
  4604 000012AB 87DA                    	xchg	bx,dx			; BX = extended error #
  4605                                  					; DX = saved BX
  4606 000012AD 83EB13                  	sub	bx,19			; BX = critical error index, from 0
  4607 000012B0 D1E3                    	shl	bx,1			; BX = offset in word table
  4608 000012B2 8B9F[0E08]              	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
  4609 000012B6 87DA                    	xchg	bx,dx			; DX = ptr to error msg
  4610                                  					; BX = restored
  4611 000012B8 E8D6FF                  	call	RPrint			; print the message
  4612 000012BB 5A                      	pop	dx			; restore DX
  4613 000012BC C3                      	retn
  4614                                  
  4615                                  ;RPrintCrit	endp
  4616                                  
  4617                                  ; ----------------------------------------------------------------------------
  4618                                  ;***	RDispMsg - display message
  4619                                  ;
  4620                                  ;	Display message, with substitutions, for RPrint.
  4621                                  ;
  4622                                  ;	ENTRY	DS:SI = ptr to message text
  4623                                  ;		CX = message length
  4624                                  ;		DS:BX = ptr to substitution block, if any
  4625                                  ;
  4626                                  ;	EXIT	nothing
  4627                                  ;
  4628                                  ;	USED	AX,CX,DX,SI
  4629                                  ; ----------------------------------------------------------------------------
  4630                                  
  4631                                  ;RDispMsg	proc
  4632                                  ;	assume	ds:DATARES,ss:DATARES
  4633                                  
  4634                                  RDispMsg:
  4635                                  	; 14/01/2023
  4636                                  rdNextChar:
  4637 000012BD AC                      	lodsb				; AL = next char
  4638 000012BE 3C25                    	cmp	al,'%'
  4639 000012C0 7511                    	jne	short rdOutChar		; not a substitution
  4640 000012C2 8A14                    	mov	dl,[si]			; DL = possible '1' - '9'
  4641 000012C4 80EA31                  	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  4642 000012C7 80FA09                  	cmp	dl,9
  4643 000012CA 7307                    	jae	short rdOutChar		; not a substitution
  4644                                  
  4645                                  ;*	A substitution code %1 - %9 has been encountered.
  4646                                  ;	DL = 0-8, indicating %1-%9
  4647                                  ;	DS:BX = ptr to substitution block
  4648                                  
  4649 000012CC E80D00                  	call	SubstMsg		; display the substitution
  4650 000012CF 46                      	inc	si			; SI = ptr past %n
  4651 000012D0 49                      	dec	cx			; count extra character in %n
  4652 000012D1 EB06                    	jmp	short rdCharDone
  4653                                  
  4654                                  ;*	Normal character output.
  4655                                  
  4656                                  rdOutChar:
  4657 000012D3 88C2                    	mov	dl,al			; DL = char
  4658 000012D5 B402                    	mov	ah,2			; AH = DOS Character Output code
  4659 000012D7 CD21                    	int	21h			; call DOS
  4660                                  rdCharDone:
  4661 000012D9 E2E2                    	loop	rdNextChar
  4662 000012DB C3                      	retn
  4663                                  
  4664                                  ;RDispMsg	endp
  4665                                  
  4666                                  ; ----------------------------------------------------------------------------
  4667                                  ;***	SubstMsg - display message substitution
  4668                                  ;
  4669                                  ;	Display a substitution string within a message.
  4670                                  ;	Substitution can be a char, an ASCIIZ string, or
  4671                                  ;	a word to be displayed as hex digits.
  4672                                  ;
  4673                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  4674                                  ;		DS:BX = ptr to substitution block
  4675                                  ;
  4676                                  ;	EXIT	nothing
  4677                                  ;
  4678                                  ;	USED	AX,DX
  4679                                  ; ----------------------------------------------------------------------------
  4680                                  
  4681                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4682                                  
  4683                                  ;SubstMsg	proc
  4684                                  ;	assume	ds:DATARES,ss:DATARES
  4685                                  	
  4686                                  	; 14/01/2023
  4687                                  SubstMsg:
  4688 000012DC 53                      	push	bx			; preserve BX
  4689 000012DD 51                      	push	cx			; preserve CX
  4690                                  
  4691                                  	;mov	al,size SUBST		; AL = size of substitution block
  4692 000012DE B003                    	mov	al,3
  4693 000012E0 F6E2                    	mul	dl			; AX = offset of desired subst block
  4694 000012E2 01C3                    	add	bx,ax			; DS:BX = ptr to desired subst block
  4695                                  
  4696                                  	;mov	al,[bx].SubstType	; AX = substitution type flag
  4697 000012E4 8A07                    	mov	al,[bx]
  4698                                  	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  4699 000012E6 8B5F01                  	mov	bx,[bx+1]
  4700                                  
  4701                                  ;	AL = 1, 2, or 3 for char, string, or hex type
  4702                                  
  4703 000012E9 FEC8                    	dec	al
  4704 000012EB 7428                    	jz	short smChar
  4705 000012ED FEC8                    	dec	al
  4706 000012EF 742C                    	jz	short smStr
  4707                                  
  4708                                  ;*	Hex number substitution.
  4709                                  
  4710                                  	;mov	ax,ds:[bx]		; AX = word value
  4711 000012F1 8B07                    	mov	ax,[bx]
  4712 000012F3 B90400                  	mov	cx,4			; CX = # digits to display
  4713                                  smDigit:
  4714 000012F6 D1C0                    	rol	ax,1
  4715 000012F8 D1C0                    	rol	ax,1
  4716 000012FA D1C0                    	rol	ax,1
  4717 000012FC D1C0                    	rol	ax,1			; AL<3:0> = next digit
  4718                                  
  4719 000012FE 50                      	push	ax			; save other digits
  4720 000012FF 240F                    	and	al,0Fh			; AL = binary digit
  4721 00001301 0430                    	add	al,'0'			; AL = ascii digit if 0-9
  4722 00001303 3C39                    	cmp	al,'9'
  4723 00001305 7602                    	jbe	short smDigit09		; it's 0-9
  4724                                  	;add	al,7
  4725 00001307 0407                    	add	al,('A' - '0') - 10	; AL = ascii digit A-F
  4726                                  smDigit09:
  4727 00001309 88C2                    	mov	dl,al			; DL = ascii digit
  4728 0000130B B402                    	mov	ah,2
  4729 0000130D CD21                    	int	21h			; output the ascii digit
  4730 0000130F 58                      	pop	ax			; restore all digits
  4731                                  
  4732 00001310 E2E4                    	loop	smDigit
  4733                                  	;jmp	short smRet
  4734                                  	; 14/01/2023
  4735                                  smRet:	
  4736 00001312 59                      	pop	cx
  4737 00001313 5B                      	pop	bx
  4738 00001314 C3                      	retn
  4739                                  
  4740                                  ;*	Char substitution.
  4741                                  
  4742                                  smChar:
  4743                                  	;mov	dl,ds:[bx]		; DL = char to output
  4744 00001315 8A17                    	mov	dl,[bx]
  4745 00001317 B402                    	mov	ah,2
  4746 00001319 CD21                    	int	21h
  4747 0000131B EBF5                    	jmp	short smRet
  4748                                  
  4749                                  ;*	String substitution.
  4750                                  
  4751                                  smStr:
  4752                                  	;mov	dl,ds:[bx]		; DL = next char
  4753 0000131D 8A17                    	mov	dl,[bx]
  4754 0000131F 08D2                    	or	dl,dl
  4755 00001321 74EF                    	jz	short smRet		; null char - we're done
  4756 00001323 B402                    	mov	ah,2
  4757 00001325 CD21                    	int	21h			; display char
  4758 00001327 43                      	inc	bx			; DS:BX = ptr to next char
  4759 00001328 EBF3                    	jmp	short smStr
  4760                                  
  4761                                  ;smRet:	pop	cx
  4762                                  ;	pop	bx
  4763                                  ;	retn
  4764                                  
  4765                                  ;SubstMsg	endp
  4766                                  
  4767                                  	; MSDOS 6.0
  4768                                  ; ----------------------------------------------------------------------------
  4769                                  ;***	CharToUpper - convert character to uppercase
  4770                                  ;
  4771                                  ;	ENTRY	AL = char
  4772                                  ;
  4773                                  ;	EXIT	AL = uppercase char
  4774                                  ;
  4775                                  ;	USED	AX
  4776                                  ; ----------------------------------------------------------------------------
  4777                                  
  4778                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4779                                  
  4780                                  ;CharToUpper	proc
  4781                                  ;	assume	ds:DATARES
  4782                                  CharToUpper:
  4783 0000132A 50                      	push	ax		; put char on stack as arg to int 2F
  4784 0000132B B81312                  	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  4785 0000132E CD2F                    	int	2Fh
  4786 00001330 44                      	inc	sp		; throw away old char on stack
  4787 00001331 44                      	inc	sp
  4788 00001332 C3                      	retn
  4789                                  
  4790                                  ;CharToUpper	endp
  4791                                  
  4792                                  	; 14/01/2023
  4793                                  ;	; MSDOS 3.3
  4794                                  ;CHARTOUPPER:
  4795                                  ;	cmp	al,80h
  4796                                  ;	jb	short CHARTOUPPER1
  4797                                  ;	sub	al,80h
  4798                                  ;	push	ds
  4799                                  ;	push	bx
  4800                                  ;	lds	bx,[UPPERCASETBL]
  4801                                  ;	add	bx,2
  4802                                  ;	xlat
  4803                                  ;	pop	bx
  4804                                  ;	pop	ds
  4805                                  ;	jmp	short CHARTOUPPER_RETN
  4806                                  ;CHARTOUPPER1:
  4807                                  ;	cmp	al,'a'
  4808                                  ;	jb	short CHARTOUPPER_RETN
  4809                                  ;	cmp	al,'z'
  4810                                  ;	ja	short CHARTOUPPER_RETN
  4811                                  ;	sub	al,20h
  4812                                  ;CHARTOUPPER_RETN:
  4813                                  ;	retn
  4814                                  
  4815                                  ;public	EndCode
  4816                                  ;EndCode label byte
  4817                                  
  4818                                  	; MSDOS 6.0
  4819                                  ; ----------------------------------------------------------------------------
  4820                                  ;***	MsgInt2fHandler - int 2f handler for message retrieval
  4821                                  ;
  4822                                  ;	ENTRY	If we handle it -
  4823                                  ;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
  4824                                  ;		  DL = operation =
  4825                                  ;		     0 = get extended error messages
  4826                                  ;		     1 = set extended error messages
  4827                                  ;		     2 = get parse error messages
  4828                                  ;		     3 = set parse error messages
  4829                                  ;		     4 = get critical error messages
  4830                                  ;		     5 = set critical error messages
  4831                                  ;		     6 = get file system error messages
  4832                                  ;		     7 = set file system error messages
  4833                                  ;		     8 = get disk retriever routine
  4834                                  ;		     9 = set disk retriever routine
  4835                                  ;		  ES:DI = address for 'set' operations
  4836                                  ;
  4837                                  ;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
  4838                                  ;
  4839                                  ;	NOTE
  4840                                  ;	  This handler replaces the one that used to reside in DOS.
  4841                                  ;	  'Set' operations are ignored.
  4842                                  ;	  'File system error messages' are not supported.
  4843                                  ; ----------------------------------------------------------------------------
  4844                                  
  4845                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4846                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
  4847                                  ;SR;
  4848                                  ;At the int 2fh entry point we push the old ds value and the resident data
  4849                                  ;segment address. Get them off the stack
  4850                                  
  4851                                  ;MsgInt2fHandler proc	far
  4852                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4853                                  
  4854                                  	 ;14/01/2023
  4855                                  MsgInt2fHandler:
  4856 00001333 1F                      	pop	ds			; ds = DATARES
  4857                                  	;assume	ds:DATARES
  4858                                  ;	pop	word [OldDS]		; save old value of ds
  4859                                  
  4860 00001334 3D2E12                  	cmp	ax,122Eh
  4861                                  	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
  4862                                  	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
  4863 00001337 742A                    	je	short miOurs		; it's ours
  4864                                  
  4865                                  ;ifndef ROMDOS
  4866                                  	;cmp	ax,5500h
  4867 00001339 3D0055                  	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
  4868                                  ;else
  4869                                  ;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
  4870                                  ;endif	;ROMDOS
  4871 0000133C 741C                    	je	short fcOurs
  4872                                  
  4873                                  ;SR;
  4874                                  ;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
  4875                                  ;onto the stack and do a far return to jump to the next 2fh handler. 
  4876                                  ;Our old ds is on the stack. We need to restore it but we cannot lose the
  4877                                  ;current value of ds as it points at the data segment. So we do some kinky
  4878                                  ;stack manipulations.
  4879                                  
  4880 0000133E 50                      	push	ax
  4881 0000133F 50                      	push	ax			; create 2 words on stack for retf
  4882                                  
  4883 00001340 55                      	push	bp
  4884 00001341 50                      	push	ax
  4885                                  
  4886 00001342 89E5                    	mov	bp,sp			; bp can be used to address stack
  4887                                  
  4888                                  ;Swap the old ds value with the second dummy word on the stack. Now, we can
  4889                                  ;do a 'pop ds' at the end to restore our ds
  4890                                  
  4891 00001344 8B4608                  	mov	ax,[bp+8]		; ax = old ds value
  4892 00001347 894604                  	mov	[bp+4],ax
  4893                                  	
  4894                                  	;mov	ax,word ptr ds:Int2fHandler+2
  4895 0000134A A1[B503]                	mov	ax,[Int2fHandler+2]
  4896 0000134D 894608                  	mov	[bp+8],ax		; put segment address
  4897                                  	;mov	ax,word ptr ds:Int2fHandler
  4898 00001350 A1[B303]                	mov	ax,[Int2fHandler]
  4899 00001353 894606                  	mov	[bp+6],ax		; put offset address
  4900                                  
  4901 00001356 58                      	pop	ax
  4902 00001357 5D                      	pop	bp
  4903 00001358 1F                      	pop	ds
  4904                                  
  4905 00001359 CB                      	retf				; chain on to next handler
  4906                                  
  4907                                  ;;	jmp	Int2fHandler		; hand off to next 2f handler
  4908                                  
  4909                                  fcOurs:
  4910                                  
  4911                                  ;We have to clear ax, and return in ds:si a pointer to the stub jump table
  4912                                  
  4913 0000135A 58                      	pop	ax			; discard ds currently on stack
  4914 0000135B 1E                      	push	ds			; store our data segment
  4915                                  
  4916                                  	;mov	si,offset DATARES:Int2f_Entry ; start of table
  4917 0000135C BE[0400]                	mov	si,Int2f_Entry
  4918                                  
  4919 0000135F 31C0                    	xor	ax,ax			; indicate COMMAND present
  4920 00001361 EB11                    	jmp	short miRet		; return to caller
  4921                                  
  4922                                  miOurs:
  4923 00001363 F6C201                  	test	dl,1
  4924 00001366 750C                    	jnz	short miRet		; ignore 'set' operations
  4925                                  
  4926 00001368 53                      	push	bx			; preserve BX
  4927 00001369 89D3                    	mov	bx,dx
  4928 0000136B 30FF                    	xor	bh,bh			; BX = index in word table
  4929 0000136D D1E3                    	shl	bx,1			; BX = index in dword table
  4930                                  	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
  4931 0000136F C4BF[7706]              	les	di,[bx+MsgPtrLists]
  4932 00001373 5B                      	pop	bx			; restore BX
  4933                                  miRet:
  4934                                  ;	mov	ds,[OldDS]		; restore ds
  4935 00001374 1F                      	pop	ds
  4936                                  	;assume	ds:nothing
  4937                                  
  4938 00001375 CF                      	iret
  4939                                  
  4940                                  ;MsgInt2fHandler endp
  4941                                  
  4942                                  	; MSDOS 6.0
  4943                                  ; ----------------------------------------------------------------------------
  4944                                  ;***	MsgRetriever - message retrieval routine for utilities
  4945                                  ;
  4946                                  ;	Address of this routine is passed to utility programs via 
  4947                                  ;	message services int 2f. We try to find the desired message
  4948                                  ;	in memory or in our disk image.
  4949                                  ;
  4950                                  ;	ENTRY	AX = message #
  4951                                  ;		DI = offset in RESGROUP of msg ptr list
  4952                                  ;		ComSpec = asciiz pathname to our disk image
  4953                                  ;
  4954                                  ;	EXIT	CY clear for success
  4955                                  ;		ES:DI = ptr to count byte, followed by message text
  4956                                  ;
  4957                                  ;		CY set for failure
  4958                                  ;		ES,DI undefined
  4959                                  ;
  4960                                  ;	USED	flags
  4961                                  ;
  4962                                  ;	NOTE
  4963                                  ;	  The message # in AX is used to compute an offset into
  4964                                  ;	  the message ptr list pointed to by DI. The lists must
  4965                                  ;	  start with message # 1 and proceed through consecutive
  4966                                  ;	  message #'s.  
  4967                                  ;
  4968                                  ;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
  4969                                  ;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
  4970                                  ;	  valid message #.  ;M033
  4971                                  ;
  4972                                  ;	  List positions with no corresponding message text are
  4973                                  ;	  indicated by null pointers, which this routine detects.
  4974                                  ; ----------------------------------------------------------------------------
  4975                                  
  4976                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4977                                  
  4978                                  ;SR; This routine will be called directly by the utilities. So, we have
  4979                                  ; trap for it in the stub. The stub pushes the old value of ds and the 
  4980                                  ; DATARES value on the stack. We get them off the stack to setup ds here
  4981                                  
  4982                                  ;MsgRetriever	proc	far
  4983                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4984                                  
  4985                                  	; 14/01/2023
  4986                                  MsgRetriever:
  4987 00001376 1F                      	pop	ds			; ds = DATARES
  4988                                  	;assume	ds:DATARES
  4989                                  ;	pop	word [OldDS]		; save old ds
  4990                                  
  4991 00001377 50                      	push	ax			; preserve registers
  4992 00001378 53                      	push	bx
  4993 00001379 51                      	push	cx
  4994 0000137A 52                      	push	dx
  4995 0000137B 56                      	push	si
  4996                                  
  4997                                  ;;	push	ds
  4998                                  ;;	push	cs
  4999                                  ;;	pop	ds			; DS = DATARES seg addr
  5000                                  ;;	assume	ds:RESGROUP
  5001                                  ;;	push	cs
  5002                                  
  5003 0000137C 1E                      	push	ds			; get es from ds
  5004 0000137D 07                      	pop	es			; ES = DATARES seg addr
  5005                                  
  5006                                  ;	Begin modification M033.
  5007                                  
  5008                                  ;	Make sure msg # is valid.
  5009                                  ;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.
  5010                                  
  5011                                  	;mov	bx,11
  5012 0000137E BB0B00                  	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
  5013                                  	;cmp	di,offset DATARES:ParsMsgPtrs
  5014 00001381 81FF[1609]              	cmp	di,PARSMSGPTRS
  5015 00001385 7403                    	je	short chkmsgnum		; it's ParsMsgPtrs
  5016                                  	;mov	bx,90
  5017 00001387 BB5A00                  	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
  5018                                  chkmsgnum:
  5019 0000138A 39C3                    	cmp	bx,ax
  5020 0000138C 725A                    	jc	short mrRet		; msg # too high, return carry
  5021                                  
  5022                                  ;	Msg # is valid.
  5023                                  
  5024                                  ;	End modification M033.
  5025                                  
  5026 0000138E 48                      	dec	ax
  5027 0000138F D1E0                    	shl	ax,1			; AX = offset into msg ptr list
  5028 00001391 01C7                    	add	di,ax			; DI = ptr to msg ptr
  5029                                  
  5030 00001393 81FF[B703]              	cmp	di,ResMsgEnd
  5031 00001397 7247                    	jb	short mrInMem		; ptr (and message) in memory
  5032                                  
  5033                                  ;*	Retrieve message from disk (or ROM) image.
  5034                                  ;	Read once to get the ptr to the message, then again for the message.
  5035                                  
  5036                                  ;ifndef	ROMDOS
  5037                                  	; 14/01/2023
  5038                                  	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
  5039 00001399 BE[4E01]                	mov	si,ComSpec
  5040 0000139C BA0100                  	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
  5041 0000139F BB0020                  	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
  5042 000013A2 B8006C                  	mov	ax,6C00h
  5043                                  	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
  5044 000013A5 CD21                    	int	21h				; call DOS
  5045 000013A7 723F                    	jc	short mrRet			; return failure
  5046                                  
  5047 000013A9 89C3                    	mov	bx,ax				; BX = file handle
  5048 000013AB 89FA                    	mov	dx,di				; DX = ptr to msg ptr
  5049 000013AD 31F6                    	xor	si,si				; SI = read count
  5050                                  mrRead:
  5051 000013AF 81EA0001                	sub	dx,100h				; DX = LSW of file offset
  5052 000013B3 31C9                    	xor	cx,cx				; CX = MSW of file offset
  5053 000013B5 B80042                  	mov	ax,4200h
  5054                                  	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
  5055 000013B8 CD21                    	int	21h				; call DOS
  5056 000013BA 721A                    	jc	short mrCloseFile		; handle error
  5057                                  
  5058                                  	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
  5059 000013BC BA[6303]                	mov	dx,MsgBuffer
  5060 000013BF B94000                  	mov	cx,64				; CX = # bytes to read
  5061 000013C2 B43F                    	mov	ah,3Fh
  5062                                  	;mov	ah,READ				; AH = 'Read File'
  5063 000013C4 CD21                    	int	21h				; call DOS
  5064 000013C6 720E                    	jc	short mrCloseFile		; handle error
  5065                                  
  5066 000013C8 09F6                    	or	si,si				; (CY cleared)
  5067 000013CA 750A                    	jnz	short mrCloseFile		; 2nd time thru - we're done
  5068 000013CC 46                      	inc	si				; mark one read done
  5069 000013CD 8B16[6303]              	mov	dx,[MsgBuffer]			; DX = ptr to message
  5070 000013D1 09D2                    	or	dx,dx
  5071 000013D3 75DA                    	jnz	short mrRead			; go read the message
  5072 000013D5 F9                      	stc					; null ptr found- no msg
  5073                                  
  5074                                  mrCloseFile:
  5075 000013D6 9C                      	pushf				; save success/failure (CY)
  5076 000013D7 B43E                    	mov	ah,3Eh
  5077                                  	;mov	ah,CLOSE		; AH = 'Close File'
  5078 000013D9 CD21                    	int	21h			; call DOS
  5079                                  ;	Bugbug: should we avoid this popf?
  5080 000013DB 9D                      	popf				; CY = success/failure
  5081 000013DC 89D7                    	mov	di,dx			; ES:DI = ptr to msg, if successful
  5082 000013DE EB08                    	jmp	short mrRet		; we're done
  5083                                  
  5084                                  ;else	;ROMDOS
  5085                                  ;
  5086                                  ;;	DI = ptr to msg ptr
  5087                                  ;
  5088                                  ;	mov	si,di			; SI = ptr to msg ptr
  5089                                  ;	sub	si,100h			; SI = offset into image of msg ptr
  5090                                  ;	mov	cx,2			; CX = # bytes to copy from image
  5091                                  ;
  5092                                  ;;	ASSUME ES:NOTHING is still in effect.
  5093                                  ;
  5094                                  ;	push	ds
  5095                                  ;	pop	es				; ES = DATARES seg addr
  5096                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
  5097                                  ;	invoke	LoadFromROM			; copy msg ptr from ROM
  5098                                  ;	mov	si,word ptr MsgBuffer		; SI = ptr to message
  5099                                  ;	or	si,si
  5100                                  ;	jz	mrNoMsg			; null ptr- no message text
  5101                                  ;
  5102                                  ;	sub	si,100h			; SI = offset into image of msg
  5103                                  ;	mov	cx,64			; CX = # bytes to copy from image
  5104                                  ;	mov	di,offset DATARES:MsgBuffer
  5105                                  ;	invoke	LoadFromROM
  5106                                  ;	clc					; success
  5107                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
  5108                                  ;	jmp	short mrRet
  5109                                  ;
  5110                                  ;mrNoMsg:
  5111                                  ;	stc
  5112                                  ;	jmp	short mrRet
  5113                                  ;
  5114                                  ;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
  5115                                  ;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
  5116                                  ;	assume	es:NOTHING
  5117                                  ;
  5118                                  ;endif	;ROMDOS
  5119                                  
  5120                                  ;*	Message ptr is in memory.
  5121                                  ;	If ptr is in memory, assume message is in memory (/msg).
  5122                                  
  5123                                  mrInMem:
  5124                                  	; 14/01/2023
  5125 000013E0 268B3D                  	mov	di,[es:di]		; ES:DI = ptr to msg
  5126 000013E3 09FF                    	or	di,di			; (CY cleared)
  5127 000013E5 7501                    	jnz	short mrRet		; found message
  5128 000013E7 F9                      	stc				; null ptr found - no message
  5129                                  mrRet:	
  5130 000013E8 5E                      	pop	si			; restore all registers
  5131 000013E9 5A                      	pop	dx
  5132 000013EA 59                      	pop	cx
  5133 000013EB 5B                      	pop	bx
  5134 000013EC 58                      	pop	ax
  5135                                  
  5136                                  ;	mov	ds,[OldDS]		; restore ds
  5137 000013ED 1F                      	pop	ds
  5138                                  	;assume	ds:nothing
  5139                                  
  5140 000013EE CB                      	retf	; 21/04/2023
  5141                                  
  5142                                  ;MsgRetriever endp
  5143                                  
  5144                                  ; M003; Start of changes for UMB support
  5145                                  
  5146                                  ; ----------------------------------------------------------------------------
  5147                                  ;***	Lh_OffUnlink -- Restore allocation strat and link state
  5148                                  ;
  5149                                  ;	ENTRY	al = Saved alloc strat and link state
  5150                                  ;			b0 = 1 if alloc strat to restore is HighFirst
  5151                                  ;			b1 = 1 if link state to restore is Linked
  5152                                  ;
  5153                                  ;	EXIT	None
  5154                                  ;
  5155                                  ;	USED	ax, bx, cx
  5156                                  ; ----------------------------------------------------------------------------
  5157                                  
  5158                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5159                                  
  5160                                  ;public	Lh_OffUnlink
  5161                                  Lh_OffUnlink:	; proc	far
  5162                                  	; 14/01/2023
  5163 000013EF 88C5                    	mov	ch,al
  5164 000013F1 88C1                    	mov	cl,al
  5165                                  	;;mov	ax,(ALLOCOPER shl 8) OR 0
  5166                                  	;mov	ax,(ALLOCOPER<<8)
  5167 000013F3 B80058                  	mov	ax,5800h
  5168 000013F6 CD21                    	int	21h
  5169 000013F8 89C3                    	mov	bx,ax
  5170 000013FA D0C9                    	ror	cl,1				; b7 = HighFirst bit
  5171 000013FC 80E180                  	and	cl,80h				; mask off b6-b0
  5172 000013FF 80E37F                  	and	bl,7fh				; mask off HighFirst bit
  5173 00001402 08CB                    	or	bl,cl				; set HighFirst bit state
  5174                                  	;;mov	ax,(ALLOCOPER shl 8) OR 1
  5175                                  	;mov	ax,(ALLOCOPER<<8)|1
  5176 00001404 B80158                  	mov	ax,5801h
  5177 00001407 CD21                    	int	21h				; set alloc strat
  5178                                  
  5179 00001409 88EB                    	mov	bl,ch
  5180 0000140B D0EB                    	shr	bl,1
  5181 0000140D 30FF                    	xor	bh,bh				; bx = linkstate
  5182                                  	;mov	ax,(ALLOCOPER shl 8) OR 3
  5183                                  	;mov	ax,(ALLOCOPER<<8)|3
  5184 0000140F B80358                  	mov	ax,5803h
  5185 00001412 CD21                    	int	21h				; set linkstate
  5186                                  
  5187 00001414 CB                      	retf
  5188                                  
  5189                                  ;Lh_OffUnlink endp
  5190                                  
  5191                                  ; M003; End of changes for UMB support
  5192                                  
  5193                                  ;public	EndCode
  5194                                  ; 14/01/2023
  5195                                  ;EndCode: ; label byte
  5196                                  ; 16/04/2023
  5197                                  EndCode equ ($-StartCode)+100h
  5198                                  
  5199                                  ;CODERES ends
  5200                                  ;	end
  5201                                  
  5202                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5203                                  
  5204 00001415 00<rep Bh>              	times	(((EndCode+15)>>4)<<4)-EndCode db 0
  5205                                  
  5206                                  ;align 16
  5207                                  
  5208                                  ;=============================================================================
  5209                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  5210                                  ;=============================================================================
  5211                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  5212                                  
  5213                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  5214                                  
  5215                                  ;TITLE   COMMAND Initialization
  5216                                  
  5217                                  ;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
  5218                                  ;ENVIRONSIZ2 EQU 092H
  5219                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  5220                                  
  5221                                  ; UINIT.ASM, MSDOS 6.0, 1991
  5222                                  ; 23/09/2018
  5223                                  ENVBIG	EQU 32768		;AN000; maximum environment size
  5224                                  ; 14/01/2023
  5225                                  ;ENVSML	EQU 160			;AN000; minimum environment size
  5226                                  
  5227                                  ; ----------------------------------------------------------------------------
  5228                                  
  5229                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5230                                  
  5231                                  ; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
  5232                                  ENVIRONSIZ equ 160
  5233                                  ENVSML	equ 256	; minimum environment size
  5234                                  ;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
  5235                                  MAX_COMSPEC equ 146
  5236                                  ECOMSPEC equ 14
  5237                                  
  5238                                  ; 14/01/2023
  5239                                  TAB_CHAR equ 09h
  5240                                  SPACE_CHAR equ 20h	
  5241                                  
  5242                                  ; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
  5243                                  ;ENVIRONSIZ equ 181	; SIZE Environment 
  5244                                  
  5245                                  ;----------------------------------------------------
  5246                                  ; MSDOS 6.0 - ENVDATA.ASM - 1991
  5247                                  ;----------------------------------------------------
  5248                                  ;Environment Struc	; Default COMMAND environment
  5249                                  ;
  5250                                  ;Env_PathString  db	"path="
  5251                                  ;Env_PathSpec	 db	"c:\msdos"
  5252                                  ;                db	0
  5253                                  ;Env_PrmptString db	"prompt="
  5254                                  ;Env_PrmptSpec   db	"$p$g"
  5255                                  ;                db	0
  5256                                  ;Env_ComString   db	"comspec="
  5257                                  ;Env_ComSpec     db	"\command.com"
  5258                                  ;		 db	134 dup (0)
  5259                                  ;
  5260                                  ;Environment ends
  5261                                  ;----------------------------------------------------
  5262                                  
  5263                                  ;-----------------------------------------------------------------------------
  5264                                  
  5265                                  ;-----------------------------------------------------------------------------
  5266                                  ; START OF INIT PORTION
  5267                                  ; This code is deallocated after initialization.
  5268                                  ;-----------------------------------------------------------------------------
  5269                                  
  5270                                  ;INIT	SEGMENT PUBLIC PARA
  5271                                  
  5272                                  ; 	EXTRN   HEADER:BYTE
  5273                                  ;	EXTRN   BADCOMLKMES:BYTE
  5274                                  
  5275                                  ;	PUBLIC  CONPROC
  5276                                  
  5277                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  5278                                  
  5279                                          ;ORG 0
  5280                                  ;ZERO = $
  5281                                  	; 23/09/2018
  5282                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  5283                                  
  5284                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5285                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
  5286                                  ConProc:
  5287                                  	;mov	sp,offset ResGroup:RStack	; must be first instruction
  5288 00001420 BC[3804]                	mov	sp,RStack
  5289                                  
  5290                                  ; We need to set the PSP to us right at start because Carousel needs
  5291                                  ; to be lied to and it does not set PSP when it transfers control to
  5292                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  5293                                  ; command.com is also not lied to.
  5294                                  
  5295                                  	; 14/01/2023
  5296                                  	; MSDOS 6.0
  5297 00001423 B450                            mov	ah,50h
  5298                                  	;mov	ah,SET_CURRENT_PDB
  5299 00001425 8CC3                            mov	bx,es
  5300 00001427 CD21                            int	21h
  5301                                  
  5302                                  	; 14/01/2023
  5303 00001429 B430                            mov	ah,30h 
  5304                                  	;mov	ax,GET_VERSION<<8 ; 30h
  5305 0000142B CD21                    	int	21h
  5306                                  	;;cmp	ax,EXPECTED_VERSION ; 1E03h
  5307                                  	;cmp	ax,5
  5308 0000142D 83F805                  	cmp	ax,EXPECTED_VERSION ; 0005h
  5309 00001430 7411                    	je	short okdos			; DOS version is ok
  5310                                  
  5311 00001432 BA[5A1D]                	mov	dx,BADVERMSG			; DX = ptr to msg
  5312 00001435 E859FE                  	call	RPrint
  5313                                  
  5314                                  	; MSDOS 3.3
  5315                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  5316                                  	;int	21h             ; DOS - PRINT STRING
  5317                                  				; DS:DX -> string terminated by "$"
  5318 00001438 8CC0                    	mov	ax,es
  5319 0000143A 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  5320                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  5321                                  Here:	
  5322 0000143F 74FE                    	jz	short Here			;  loop forever
  5323                                  	
  5324 00001441 CD20                    	int	20h				; otherwise, exit
  5325                                  okdos:
  5326                                  	; 23/09/2018
  5327                                  
  5328                                  ;  Calculate and save the end of the INIT segment (which is also
  5329                                  ;  the beginning of TRANGROUP).
  5330                                  
  5331                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5332                                  	; MSDOS 3.3
  5333                                  	;mov	ah,65h
  5334                                  	;mov	al,2
  5335                                  	;mov	dx,-1
  5336                                  	;mov	bx,-1
  5337                                  	;mov	cx,5
  5338                                  	;mov	di,UCASE_ADDR
  5339                                  	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  5340                                  	;		; AL = 02h : Get pointer to character translation table
  5341                                  	;		; BX = code page (-1 = current global code page)
  5342                                  	;		; DX = country ID (-1 = current country)
  5343                                  	;		; CX = amount of data to return
  5344                                  	;; ES:DI = pointer to output buffer
  5345                                  	;; Buffer offset :
  5346                                  	;;	00h -  byte,  country Id
  5347                                  	;;  	01h -  dword, pointer to uppercase table	
  5348                                  
  5349                                  	; 14/01/2023
  5350                                  	; MSDOS 6.0 (& MSDOS 3.3)
  5351                                    	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
  5352 00001443 BA4F22                  	mov	dx,TRANSTART+15			; get end of init code
  5353                                  	; 27/09/2018
  5354                                  	;mov	dx,TRANSTART ; (paragraph aligned address)
  5355 00001446 B104                    	mov	cl,4				; change to paragraphs
  5356 00001448 D3EA                            shr	dx,cl				;
  5357 0000144A 8CC8                            mov     ax,cs                           ; get current segment
  5358 0000144C 01D0                            add     ax,dx                           ; calculate segment of end of init
  5359 0000144E A3[BD1C]                        mov     [initend],ax			; save this
  5360                                  
  5361                                  	; 14/01/2023
  5362                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 
  5363                                  
  5364                                  ;  Check for /? on the command line. If found, display help text and exit.
  5365                                  ;  NOTE: this routine may terminate the program, never returning.
  5366                                  
  5367 00001451 E88606                  	call	CheckHelp
  5368                                  
  5369                                  ; We have to patch the segment values for the various interrupt entry points.
  5370                                  ; This is because we need to have the default addresses of the handlers in our
  5371                                  ; stub before the relocation is done. These values will then be changed once
  5372                                  ; the resident is relocated
  5373                                  
  5374 00001454 E8C607                  	call	patch_segs
  5375                                  
  5376                                  ;  Turn APPEND off during initialization processing
  5377                                  
  5378                                  	; 14/01/2023
  5379 00001457 B800B7                  	mov     ax,0B700h
  5380                                  	;mov	ax,APPENDINSTALL                ; see if append installed
  5381 0000145A CD2F                    	int	2Fh				;
  5382                                  	;cmp	al,0				; append installed?
  5383 0000145C 08C0                    	or	al,al
  5384 0000145E 7418                    	jz	short set_msg_addr		; no - continue
  5385                                  	
  5386 00001460 B802B7                  	mov	ax,0B702h
  5387                                  	;mov	ax,APPENDDOS			; see if append DOS version right
  5388 00001463 CD2F                    	int	2Fh				;
  5389                                  	;cmp	ax,-1				; append version correct?
  5390                                  	;jne	short set_msg_addr		; no - continue
  5391 00001465 40                      	inc	ax ; -1 -> 0
  5392 00001466 7510                    	jnz	short set_msg_addr        
  5393                                  	
  5394 00001468 B806B7                  	mov     ax,0B706h
  5395                                  	;mov	ax,APPENDGETSTATE               ; Get the state of Append
  5396 0000146B CD2F                    	int	2Fh				;
  5397 0000146D 891E[C301]                      mov     [Append_State],bx		; save append state
  5398                                         
  5399 00001471 31DB                    	xor	bx,bx                           ; clear out state
  5400 00001473 B807B7                  	mov	ax,0B707h
  5401                                  	;mov	ax,APPENDSETSTATE               ; Set the state of Append
  5402 00001476 CD2F                    	int	2Fh				; set everything off
  5403                                  
  5404                                  set_msg_addr:
  5405                                  	; 14/01/2023
  5406                                  	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
  5407                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
  5408                                  	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
  5409 00001478 BF[3808]                	mov	di,DataresEnd
  5410 0000147B 893E[B703]              	mov	[ResMsgEnd],di			; save it
  5411                                  
  5412 0000147F E8AD07                          call    get_XMMAddr                     ; get XMM call address
  5413                                  
  5414                                  ; Check if this is the first instance of command.com. If not, we just exit
  5415                                  ; this routine without moving any code.
  5416                                  ; After the int 2fh, ds:si points at the resident jump table in the previous
  5417                                  ; stub. We just have to copy this over
  5418                                  	
  5419                                  ;ifndef ROMDOS
  5420 00001482 B80055                  	mov	ax,5500h
  5421                                  	;mov	ax,GET_COMMAND_STATE	
  5422                                  ;else
  5423                                  ;	mov	ax,GET_ROMCOMMAND_STATE	
  5424                                  ;endif ; ROMDOS
  5425                                  
  5426 00001485 CD2F                    	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
  5427                                  	;assume	ds:nothing
  5428                                  
  5429                                  	; 03/05/2023
  5430                                  	; Return:
  5431                                  	;   AX = 0000h if an instance of COMMAND.COM is already running
  5432                                  	;   DS:SI -> entry point table
  5433                                  
  5434                                  	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))
  5435                                  
  5436 00001487 09C0                    	or	ax,ax
  5437 00001489 750C                    	jnz	short first_com			; this is the first instance
  5438                                  
  5439                                  	; 14/01/2023
  5440 0000148B 268936[FE20]            	mov	[es:ResJmpTable],si		; save old stub jump table
  5441 00001490 268C1E[0021]            	mov	[es:ResJmpTable+2],ds
  5442 00001495 EB06                    	jmp	short init_cntry
  5443                                  
  5444                                  first_com:
  5445 00001497 26C606[0221]01          	mov	byte [es:FirstCom],1		; indicate first command.com
  5446                                  
  5447                                  init_cntry:
  5448                                  	; 14/01/2023
  5449 0000149D 06                      	push	es
  5450 0000149E 1F                      	pop	ds
  5451                                  	;assume	ds:RESGROUP
  5452                                  
  5453 0000149F B465                    	mov	ah,65h
  5454                                  	;mov	ah,GETEXTCNTRY			; get extended country info
  5455 000014A1 B004                    	mov	al,4				; get file ucase table
  5456 000014A3 BAFFFF                  	mov	dx,-1				;
  5457                                  	;mov	bx,-1				;
  5458 000014A6 89D3                    	mov	bx,dx
  5459 000014A8 B90500                  	mov	cx,5				; number of bytes we want
  5460                                  	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
  5461 000014AB BF[B601]                	mov	di,FUCase_Addr
  5462 000014AE CD21                    	int	21h
  5463                                  		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  5464                                  		; AL = function -
  5465                                  
  5466                                  ;	Bugbug:	conditionalize dbcs_vector stuff?
  5467                                  
  5468 000014B0 1E                      	push	ds				;
  5469 000014B1 B80063                  	mov	ax,6300h
  5470                                  	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
  5471 000014B4 CD21                    	int	21h				;
  5472                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  5473                                  			
  5474 000014B6 8CDB                    	mov	bx,ds				; get segment to bx
  5475 000014B8 1F                      	pop	ds				;
  5476 000014B9 8936[BF01]              	mov	[Dbcs_Vector_Addr],si		; save address of
  5477 000014BD 891E[C101]              	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector
  5478                                  
  5479                                  	;mov	ax,[16h]
  5480 000014C1 A11600                  	mov	ax,[PDB.PARENT_PID]
  5481                                  				; mov ax,ds:16h	; Init PARENT so we can exit
  5482 000014C4 A3[4101]                	mov	[Parent],ax			;  correctly.
  5483 000014C7 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  5484 000014CA A3[4301]                	mov	[OldTerm],ax
  5485 000014CD A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  5486 000014D0 A3[4501]                	mov	[OldTerm+2],ax
  5487                                  
  5488                                  	; 14/01/2023
  5489                                  	;;;mov	ax,offset ResGroup:EndCode + 15
  5490                                  	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
  5491                                  	;mov	ax,EndCode+15
  5492                                  	;;mov	ax,INITSTART+15 ; 24/09/2018
  5493                                  	; 14/01/2023
  5494                                  	;mov	cl,4				; ax = size of resident part of
  5495                                  	;shr	ax,cl				;  command in paragraphs. Add
  5496                                  	;mov	cx,cs				;  this to CS and you get the
  5497                                  	;add	ax,cx				;  segment of the TPA.
  5498                                  
  5499 000014D3 8CC8                    	mov	ax,cs
  5500 000014D5 055201                  	add	ax,(EndCode+15)>>4
  5501                                  	
  5502 000014D8 A3[5F03]                	mov     [Res_Tpa],ax			; Temporarily save the TPA segment
  5503 000014DB 2500F0                  	and     ax,0F000h
  5504 000014DE 050010                  	add     ax,1000h			; Round up to next 64K boundary
  5505 000014E1 7303                    	jnc     short TpaSet			; Memory wrap if carry set
  5506 000014E3 A1[5F03]                	mov     ax,[Res_Tpa]
  5507                                  TpaSet:
  5508 000014E6 A3[5103]                	mov	[LTpa],ax			; Good enough for the moment
  5509                                  	;mov	ax,[2]
  5510 000014E9 A10200                  	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command
  5511                                  
  5512 000014EC 8C1E[5703]              	mov	[MySeg1],ds			; These 3 variables are used as part of
  5513 000014F0 8C1E[5B03]              	mov	[MySeg2],ds			;  3 long ptrs that the transient will
  5514 000014F4 8C1E[4F03]              	mov	[MySeg],ds			;  use to call resident routines.
  5515                                  	; 19/04/2023
  5516                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
  5517 000014F8 8C1E[8906]              	mov	[MySeg3],ds			; segment of msg retriever routine 
  5518                                  
  5519 000014FC A3[9801]                	mov	[MemSiz],ax			; Needed for execing other programs
  5520                                  
  5521                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5522                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h
  5523                                  
  5524                                  ; First reallocate the COMMAND size to its memory image
  5525                                  	
  5526 000014FF 50                      	push	ax    
  5527                                    	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
  5528                                  	;;mov	bx,offset RESGROUP:TranStart    ;
  5529                                  	;mov	bx,TRANSTART
  5530                                  	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
  5531                                          ;add	bx,offset TRANGROUP:TranSpaceEnd;
  5532                                  	;add	bx,15 ; *			; round up the size
  5533                                  
  5534                                  	; 03/05/2023
  5535                                  	;mov	bx,TRANSTART+15 ; * ; 14/01/2023
  5536                                  	;add	bx,TRANSPACEEND
  5537 00001500 BB7EB8                  	mov	bx,TRANSTART+TRANSPACEEND+15 
  5538                                  
  5539 00001503 B104                            mov     cl,4				;
  5540 00001505 D3EB                            shr     bx,cl				; size of command.com
  5541                                  	
  5542 00001507 B44A                    	mov	ah,4Ah
  5543                                  	;mov	ah,SETBLOCK			; free all memory above pgm
  5544 00001509 CD21                            int     21h				;
  5545 0000150B 58                              pop     ax				;
  5546                                  	
  5547                                  ; Compute maximum size of environment
  5548                                  
  5549                                  	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  5550                                          ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  5551                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5552                                  	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
  5553                                  	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
  5554 0000150C C706[B11C]4D00          	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
  5555                                  ;
  5556                                  ; Compute minimum size of environment
  5557                                  ;
  5558                                  	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
  5559                                  	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
  5560 00001512 C706[AF1C]1000          	mov	word [EnvSiz],ENVSML/16 ; 256/16
  5561                                  
  5562                                  	;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  5563                                  	;mov	dx,98D4h	 ; MSDOS 5.0 COMMAND.COM
  5564 00001518 BA3E96                  	mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  5565 0000151B B104                    	mov	cl,4				;  in paragraphs.
  5566 0000151D D3EA                    	shr	dx,cl
  5567 0000151F 8916[BF1C]                      mov     [TrnSize],dx			; save size of transient in paragraphs
  5568                                  
  5569 00001523 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  5570 00001525 A3[9201]                	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
  5571                                  	;mov	ax,[2Ch]
  5572 00001528 A12C00                  	mov	ax,[PDB.ENVIRON]		; ax = environment segment
  5573                                  
  5574                                  	; 14/01/2023
  5575                                          ; MSDOS 6.0
  5576                                  	;mov	[EnvirSeg],ax
  5577                                          
  5578                                  	; 21/01/2023
  5579 0000152B 09C0                    	or	ax,ax				; if there is no environment segment,
  5580 0000152D 7406                    	jz	short buildenv			; make one
  5581                                    
  5582                                  	; 21/01/2023
  5583                                  	; MSDOS 3.3 & MSDOS 5.0
  5584                                  	;inc	byte [CHUCKENV]
  5585 0000152F FE06[931C]              	inc	byte [AllocedEnv]		; Flag - old environment segment
  5586                                  	
  5587                                  	; MSDOS 3.3 & MSDOS 5.0
  5588 00001533 EB03                    	jmp	short environpassed
  5589                                  	; MSDOS 6.0
  5590                                          ;cmp	byte [FirstCom],0		; if this is the first command.com,
  5591                                  	;je	short environpassed		; do a merge job (make sure COMSPEC exists)
  5592                                  
  5593                                  	; MSDOS 6.0
  5594                                  
  5595                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  5596                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  5597                                  ; size and free this buffer. We need this buffer because we no longer have an
  5598                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  5599                                  ; given on the command line before we know the environment size. This routine
  5600                                  ; will not return in case of an allocation error. It will either exit or hang
  5601                                  ; depending on whether or not this is the first COMMAND.COM or not.
  5602                                  
  5603                                  	; 14/01/2023
  5604                                  buildenv:
  5605 00001535 E88B06                  	call	alloc_env                       ; try to allocate buffer
  5606                                  environpassed:
  5607                                  	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
  5608 00001538 A3[3F03]                	mov	[EnvirSeg],ax
  5609                                  	;
  5610 0000153B 8EC0                    	mov	es,ax                           ; and it load into es.
  5611                                  	;assume	es:nothing
  5612                                  
  5613                                  gottheenvir:
  5614                                  
  5615                                  ; Initialize the command drive
  5616                                  
  5617                                  ; 14/01/2023
  5618                                  %if 0
  5619                                  	; MSDOS 3.3
  5620                                  BUILDENV:
  5621                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  5622                                  	mov	ax,PATHSTRING ; "PATH="
  5623                                  	mov	cl,4
  5624                                  	shr	ax,cl
  5625                                  	mov	dx,ds
  5626                                  	add	ax,dx
  5627                                  ENVIRONPASSED:
  5628                                          mov	[ENVIRSEG],ax
  5629                                          MOV     es,ax
  5630                                  
  5631                                          ;mov	ax,CHAR_OPER<<8
  5632                                          mov	ax,CHAR_OPER*256 ; 3700h
  5633                                  	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  5634                                  			; Return: AL = FFh unsupported subfunction
  5635                                  			; DL = current switch character
  5636                                          mov	[RSWITCHAR],dl
  5637                                  
  5638                                          ;CMP	dl,'/'
  5639                                  	cmp	dl,[slash_chr]
  5640                                          jnz	short IUSESLASH
  5641                                  
  5642                                  	;mov	al,'\'
  5643                                   	mov	al,[bslash_chr]
  5644                                  	mov	[COMSPECT],al
  5645                                  
  5646                                  	cmp	byte [CHUCKENV],0
  5647                                  	jnz	short IUSESLASH
  5648                                  
  5649                                          ;mov	ES:[ECOMSPEC-10h],'\'
  5650                                  	; 30/04/2018
  5651                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  5652                                  	; 23/09/2018
  5653                                  	mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  5654                                  gottheenvir:
  5655                                  IUSESLASH:
  5656                                  
  5657                                  ; Initialize the command drive
  5658                                  
  5659                                  %endif
  5660                                  	; 14/01/2023
  5661                                  	; MSDOS 3.3 & MSDOS 6.0
  5662 0000153D B419                    	mov	ah,19h
  5663                                  	;mov	ah,GET_DEFAULT_DRIVE	; 19h
  5664 0000153F CD21                    	int	21h
  5665 00001541 FEC0                    	inc	al
  5666 00001543 A2[9701]                	mov	[ComDrv],al
  5667                                  
  5668                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  5669 00001546 A05C00                          mov	al,[FCB]
  5670 00001549 08C0                    	or	al,al
  5671 0000154B 7426                    	jz	short nocomdrv		; no drive specified
  5672                                  
  5673 0000154D B43A                    	mov	ah,':'
  5674 0000154F A2[9701]                	mov	[ComDrv],al
  5675 00001552 0440                    	add	al,40h			; convert number to uppercase character
  5676                                  
  5677 00001554 FD                      	std
  5678                                  
  5679                                  	; MSDOS 6.0
  5680                                  	;cmp	byte [AllocedEnv],0	; if a new environment is being built,
  5681                                  	;je	short notwidenv		;  move the default comspec string in it
  5682                                  	; 14/01/2023
  5683                                  	; MSDOS 5.0 COMMAND.COM
  5684                                  	;mov	di,[ComspOffset]
  5685                                          ;cmp	byte [es:di+1],':'	; drive specifier already exist?
  5686                                          ;je	short notwidenv		; yes, must have been inherited that way
  5687                                  
  5688                                  	; MSDOS 3.3
  5689                                  	;cmp	byte [CHUCKENV],0
  5690                                  	;jne	short NOTWIDENV
  5691                                  	; 21/01/2021
  5692                                  	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
  5693 00001555 803E[931C]00             	cmp	byte [AllocedEnv],0
  5694 0000155A 7713                    	ja	short notwidenv
  5695                                  
  5696 0000155C 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  5697 0000155D 06                      	push	es			;  the drivespec is in ax and is copied
  5698 0000155E 1F                      	pop	ds			;  on to the front of the string.
  5699                                  
  5700                                  	; MSDOS 6.0
  5701                                          ;lea	si,[di+MAX_COMSPEC-3]	
  5702                                          ;lea	di,[di+MAX_COMSPEC-1]
  5703                                  
  5704                                  	; 21/01/2023
  5705                                  	; 14/01/2023
  5706                                  	; MSDOS 5.0 COMMAND.COM
  5707                                  	; MSDOS 3.3
  5708                                  	; 23/09/2018
  5709                                  	; 30/04/2018
  5710                                  	;mov	di,159
  5711                                  	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  5712                                  	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  5713 0000155F BF9F00                  	mov	di,ENVIRONSIZ-1 ; 21/01/2023
  5714                                  	;mov	si,157
  5715                                  	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  5716                                          ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  5717 00001562 BE9D00                  	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
  5718                                  	;mov	cx,144
  5719                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  5720 00001565 B99000                          mov	cx,MAX_COMSPEC-2 ; 144
  5721                                  
  5722 00001568 F3A4                    	rep	movsb
  5723 0000156A 1F                      	pop	ds
  5724                                  
  5725                                  	; MSDOS 6.0
  5726                                  	;mov	word ptr es:[di-1],ax
  5727                                  
  5728                                  	; MSDOS 3.3
  5729                                  	;mov	[es:0Eh],ax
  5730                                  	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  5731                                  	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  5732                                  	; 14/01/2023
  5733 0000156B 26A30E00                	mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax
  5734                                  
  5735                                  	; MSDOS 3.3 & MSDOS 6.0
  5736                                  notwidenv:
  5737 0000156F FC                      	cld
  5738 00001570 A3[751C]                	mov	[AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  5739                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5740                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
  5741                                  	;mov	[KAUTOBAT],ax
  5742                                  nocomdrv:
  5743 00001573 E88FFA                  	call	SetVect        ; Set the vectors
  5744                                  
  5745                                  ; parsing starts here
  5746                                  
  5747                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5748                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C9h)
  5749                                  	; MSDOS 6.0
  5750 00001576 0E                      	push	cs
  5751 00001577 0E                      	push	cs
  5752 00001578 1F                      	pop	ds
  5753 00001579 07                      	pop	es
  5754                                  	;assume ds:ResGroup,es:ResGroup
  5755                                  
  5756                                  ; 14/01/2023
  5757                                  %if 0	
  5758                                  	; MSDOS 3.3
  5759                                  	mov	si,80h		; get command line
  5760                                  	lodsb			; get length of line
  5761                                  	mov	cl,al
  5762                                  	xor	ch,ch		; cx = length of command line
  5763                                  
  5764                                  ; insure that the command line correctly ends with a cr
  5765                                  
  5766                                  	add	si,cx		; go to end of command line	
  5767                                  	mov	byte [si], 0Dh	; insert a carriage return
  5768                                  
  5769                                  	mov	si,81h		; Start of parms
  5770                                  CHKARG:
  5771                                          jcxz	COMRETURNSJ     ; No parameters
  5772                                          dec	cx
  5773                                  	lodsb
  5774                                  CHECKSWITCHCHR:
  5775                                  	;cmp	al,' '
  5776                                  	cmp	al,[SPACE_CHR]	 ;Skip blank spaces
  5777                                  	jz	short CHKARG
  5778                                  	cmp	al,9		; Skip TAB characters
  5779                                  	jz	short CHKARG
  5780                                  	cmp	al,[RSWITCHAR]	; Switch?
  5781                                  	jz	short PARSE_CONT ; Yes, get the char after the switch
  5782                                  	jmp	CHKOTHERARGS	; No
  5783                                  
  5784                                  %endif
  5785                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5786                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16CDh - CODERES:098Dh)
  5787                                  	; MSDOS 6.0
  5788                                  
  5789 0000157A BE8000                  	mov	si,80h				; get command line
  5790 0000157D AC                      	lodsb					; get length of line
  5791 0000157E 89F7                    	mov	di,si				; get line position in di
  5792 00001580 30E4                    	xor	ah,ah				; ax = length of command line
  5793                                  
  5794                                  ; insure that the command line correctly ends with a cr
  5795                                  
  5796 00001582 01C7                    	add	di,ax				; go to end of command line
  5797 00001584 C6050D                          mov	byte [di],0Dh			; insert a carriage return
  5798 00001587 31C9                    	xor	cx,cx				; clear cx
  5799 00001589 890E[561D]                      mov	[num_positionals],cx		; initialize positionals
  5800                                  
  5801                                  ; Scan the command line looking for the parameters
  5802                                  
  5803                                  Parse_command_line:
  5804                                  	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
  5805 0000158D BF[C81C]                	mov	di,PARSE_COMMAND
  5806 00001590 8B0E[561D]              	mov	cx,[num_positionals]		; Get number of positionals
  5807 00001594 31D2                    	xor	dx,dx				; clear dx
  5808 00001596 8936[581D]                      mov	[old_parse_ptr],si		; save position before calling parser
  5809                                  	;call	dword ptr Init_Parse
  5810 0000159A FF1E[BB1C]              	call	far [Init_Parse]		; call parser
  5811 0000159E 890E[561D]                      mov     [num_positionals],cx		; Save number of positionals
  5812                                  	; 29/01/2023
  5813                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
  5814 000015A2 83F8FF                          cmp	ax,-1
  5815 000015A5 7503                    	jne	short t1
  5816 000015A7 E9FC01                          jmp     ArgsDone                        ; yes - exit
  5817                                  t1:	
  5818                                  	;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
  5819                                  	;cmp	ax,0
  5820 000015AA 21C0                    	and	ax,ax
  5821 000015AC 7447                    	jz	short parse_cont		; no - continue
  5822                                  
  5823                                  ; Before issuing error message - make sure switch is not /C
  5824                                  
  5825                                  parse_line_error:
  5826                                  	; 14/01/2023
  5827                                  	;push	si				; save line position
  5828                                  	;push	ax				; save error number
  5829                                  	;cmp	ax,3
  5830 000015AE 83F803                  	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
  5831                                          ;jnz	short parse_line_error_disp	; No - just issue message
  5832 000015B1 752A                    	jne	short parse_line_error_disp2
  5833 000015B3 56                      	push	si ; **				; save line position
  5834 000015B4 50                      	push	ax ; *				; save error number
  5835 000015B5 89F7                    	mov	di,si				; Get terminating pointer in DI
  5836 000015B7 8B36[581D]                      mov     si,[old_parse_ptr]		; Get starting pointer in SI
  5837                                  
  5838                                  init_chk_delim:
  5839 000015BB 39FE                    	cmp	si,di				; at end of parsed parameter?
  5840 000015BD 741C                            je	short parse_line_error_disp	; Yes - just display message
  5841 000015BF AC                      	lodsb					;
  5842 000015C0 3C20                    	cmp	al,20h ; ' ' ; 16/04/2023
  5843                                  	;cmp	al,space_chr ; 14/01/2023
  5844                                  	;;cmp	al,[space]			; Skip blank spaces
  5845 000015C2 74F7                    	je	short init_chk_delim		;
  5846                                  	;cmp	al,9
  5847 000015C4 3C09                    	cmp	al,tab_chr ; 9			; Skip tab characters
  5848 000015C6 74F3                    	je	short init_chk_delim		;
  5849                                  
  5850 000015C8 3A06[5303]              	cmp	al,[RSwitChar]	; '/'		; Switch?
  5851 000015CC 750D                            jne	short parse_line_error_disp	; No - just issue message
  5852 000015CE AC                      	lodsb					; Get the char after the switch
  5853                                  
  5854 000015CF E87904                  	call	iupconv 			; upper case it
  5855                                  
  5856                                  	;cmp	al,[scswitch]	; 'C'		; it is /C?
  5857                                          ;jne	short check_k_too ; MSDOS 6.0	;
  5858                                  	;16/04/2023
  5859 000015D2 3C43                    	cmp	al,'C' ; scswitch
  5860 000015D4 7505                    	jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
  5861 000015D6 5A                      	pop	dx ; *				; even up stack
  5862 000015D7 5A                      	pop	dx ; **				; even up stack
  5863 000015D8 E99800                  	jmp	SetSSwitch			; Yes - go set COMMAND /C
  5864                                  
  5865                                  	; MSDOS 6.0
  5866                                  ;check_k_too:
  5867                                  	;cmp	al,[Skswitch]	; 'K'		; it is /K?
  5868                                          ;jne	short parse_line_error_disp	;
  5869                                  	;pop	dx ; *				; even up stack
  5870                                  	;pop	dx ; **				; even up stack
  5871                                          ;jmp	SetKSwitch			; Yes - go set COMMAND /K
  5872                                  
  5873                                  parse_line_error_disp:
  5874                                  	; 14/01/2023
  5875 000015DB 58                      	pop	ax ; *				; restore error number
  5876 000015DC 5E                      	pop	si ; **				; restore line position
  5877                                  parse_line_error_disp2:
  5878 000015DD 89C2                    	mov	dx,ax				; get message number
  5879 000015DF E80D04                  	call	RPrintParse
  5880 000015E2 E8A9FC                  	call	crlf
  5881 000015E5 EBA6                            jmp     short Parse_command_line        ; continue parsing
  5882                                  
  5883                                  ; 16/04/2023
  5884                                  %if 1
  5885                                  SetMSwitch:
  5886                                          ;cmp	byte [ext_msg],1
  5887 000015E7 803E[C31C]01            	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  5888                                  	; 16/04/2023
  5889                                  	;jnz	short setMswitchok		; no - set it
  5890                                  	;;mov	ax,1
  5891                                  	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  5892                                  	;jmp	parse_line_error                ; go issue error message
  5893                                  	; 16/04/2023
  5894 000015EC 744F                    	je	short parse_line_error_j
  5895                                  setMswitchok:
  5896                                          ;mov	byte [ext_msg],1
  5897 000015EE C606[C31C]01            	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  5898 000015F3 EB98                    	jmp	Parse_command_line              ; keep parsing
  5899                                  %endif
  5900                                  
  5901                                  parse_cont:
  5902                                  
  5903                                  ; 15/01/2023
  5904                                  %if 0
  5905                                  	; MSDOS 3.3
  5906                                  
  5907                                  ; See if a switch was entered
  5908                                  
  5909                                  	jcxz	COMRETURNSJ
  5910                                  	dec	cx
  5911                                  	lodsb
  5912                                  	or	al,20h		; Lower case
  5913                                  	cmp	al,'f'		; FAIL switch
  5914                                  	jnz     short CHECKPSWITCH
  5915                                  %endif
  5916                                  
  5917                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5918                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
  5919                                  	; MSDOS 6.0
  5920                                  
  5921                                  ; See if a switch was entered
  5922                                  ;
  5923                                  ; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare
  5924                                  
  5925 000015F5 813E[4F1D][FF1C]        	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
  5926 000015FB 742A                    	je	short SetFSwitch		; yes go set fail switch
  5927 000015FD 813E[4F1D][F31C]        	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
  5928 00001603 7431                    	Je	short SetPSwitch		; yes go set up PERMCOM
  5929 00001605 813E[4F1D][0B1D]        	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
  5930 0000160B 7453                    	je	short SetDSwitch		; yes go set date switch
  5931 0000160D 813E[4F1D][301D]        	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
  5932 00001613 745E                    	je	short SetSSwitch		; yes go set up SINGLECOM
  5933                                  	; MSDOS 6.0 only!
  5934                                  	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
  5935                                          ;je	short SetKSwitch		; yes go set up SINGLECOM
  5936 00001615 813E[4F1D][171D]        	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
  5937 0000161B 7467                    	je	short SetESwitch		; yes go set up environment
  5938 0000161D 813E[4F1D][3C1D]        	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
  5939                                  	;je	short SetMSwitchjmp		; yes go set up message flag
  5940                                  	; 15/01/2023
  5941 00001623 74C2                    	je	short SetMSwitch 
  5942 00001625 EB7B                    	jmp	ChkOtherArgs		; Must be something else
  5943                                  
  5944                                  	; MSDOS 6.0
  5945                                  ;SetMSwitchjmp:
  5946                                  	;jmp	SetMSwitch
  5947                                  	
  5948                                  	; MSDOS 6.0
  5949                                  SetFSwitch:
  5950 00001627 803E[AA01]FF            	cmp	byte [fFail],-1		; has fail switch been set?
  5951                                  	; 16/04/2023
  5952                                  	;jne	short failok		; no - set it
  5953                                  	;;mov	ax,1
  5954                                  	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
  5955                                          ;jmp	parse_line_error        ; go issue error 
  5956                                  	; 16/04/2023
  5957 0000162C 740F                    	je	short parse_line_error_j
  5958                                  
  5959                                  	; MSDOS 3.3 & MSDOS 6.0
  5960                                  failok:
  5961 0000162E C606[AA01]FF            	mov	byte [fFail],-1		; fail all INT 24s.
  5962                                  	; MSDOS 3.3
  5963                                  	;jmp	short CHKARG
  5964                                  	; MSDOS 6.0
  5965 00001633 E957FF                  	jmp	Parse_command_line
  5966                                  
  5967                                  ;CHECKPSWITCH:
  5968                                  	;;cmp	al,'p'			; Permanent COMMAND switch
  5969                                  	;cmp	al,[letter_p]
  5970                                          ;jnz	short CHECKDSWITCH
  5971                                  
  5972                                  SetPSwitch:
  5973                                  
  5974                                  ; We have a permanent COMMAND switch /P. Flag this and stash the
  5975                                  ; termination address.
  5976                                  
  5977                                  	; MSDOS 6.0
  5978 00001636 803E[A501]00            	cmp	byte [PermCom],0	; has /p switch been set?
  5979 0000163B 7406                    	jz	short permcomok		; no - set it
  5980                                  	; 16/04/2023
  5981                                  parse_line_error_j:
  5982                                          ;mov	ax,1
  5983 0000163D B80100                  	mov	ax,MoreArgs_Ptr		; set up too many arguments
  5984 00001640 E96BFF                          jmp	parse_line_error	; go issue error 
  5985                                  
  5986                                  permcomok:
  5987                                  	; MSDOS 3.3 & MSDOS 6.0
  5988 00001643 FE06[A501]              	inc	byte [PermCom]
  5989                                  	;mov	word [OLDTERM],LODCOM
  5990 00001647 C706[4301][7E00]        	mov	word [OldTerm],LodCom_Trap
  5991                                  	;mov	[OLDTERM+2],ds
  5992 0000164D 8C1E[4501]              	mov	[OldTerm+2],ds
  5993                                  
  5994                                  ; make sure that we display the date and time. if the flag was not
  5995                                  ; initialized, set it to indicate yes, do prompt.
  5996                                  
  5997                                  	; MSDOS 3.3
  5998                                  	;cmp	byte [PRDATTM],-1
  5999                                  	;jnz	short CHKARG
  6000                                  	;mov	byte [PRDATTM],0
  6001                                  	;jmp	short CHKARG
  6002                                  
  6003                                  	; MSDOS 6.0
  6004 00001651 803E[861C]FF            	cmp	byte [PRDATTM],-1
  6005 00001656 7505                    	jne	short Parse_command_line_jmp
  6006 00001658 C606[861C]00            	mov	byte [PRDATTM],0
  6007                                  Parse_command_line_jmp:
  6008 0000165D E92DFF                  	jmp     Parse_command_line	; keep parsing
  6009                                  
  6010                                  ;COMRETURNSJ:
  6011                                  ;	; MSDOS 3.3
  6012                                  ;	JMP	ARGSDONE
  6013                                  
  6014                                  ;CHECKDSWITCH:
  6015                                  	;;cmp	al,'d'
  6016                                          ;cmp	al,[letter_d]
  6017                                  	;jnz	short CHECKCSWITCH
  6018                                  
  6019                                  SetDSwitch:
  6020                                  
  6021                                  ; Flag no date/time prompting.
  6022                                  
  6023                                  	; MSDOS 6.0
  6024 00001660 803E[C51C]00            	cmp	byte [dswitch],0	; has /D switch been set?
  6025                                  	; 16/04/2023
  6026                                  	;jz	short setdateok		; no - set it
  6027                                          ;;mov	ax,1
  6028                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6029                                          ;jmp	parse_line_error	; go issue error message
  6030                                  	; 16/04/2023
  6031 00001665 75D6                    	jnz	short parse_line_error_j
  6032                                  setdateok:
  6033 00001667 FE06[C51C]              	inc	byte  [dswitch]		; indicate /D entered
  6034                                  
  6035                                  	; MSDOS 3.3 & MSDOS 6.0
  6036 0000166B C606[861C]01                    mov	byte [PRDATTM],1	; User explicitly says no date time
  6037                                  	; MSDOS 3.3
  6038                                  	;jmp	short CHKARG
  6039                                  	; MSDOS 6.0
  6040 00001670 E91AFF                  	jmp     Parse_command_line	; continue parsing
  6041                                  
  6042                                  	; 15/01/2023
  6043                                  	; MSDOS 6.0 
  6044                                  ;SetKSwitch:
  6045                                  	;mov	byte [SemiPermCom],0
  6046                                  	;jmp	short SetSorKSwitch
  6047                                  
  6048                                  ;CHECKCSWITCH:
  6049                                  	;;cmp	al,'c'
  6050                                  	;cmp	al,[letter_c]
  6051                                          ;jnz	short CHECKESWITCH
  6052                                  
  6053                                  SetSSwitch:
  6054                                  ;SETCSWITCH:
  6055                                  
  6056                                  ; Set up pointer to command line, flag no date/time and turn off SingleCom.
  6057                                  
  6058 00001673 C606[A501]00            	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
  6059                                  ;SetSorKSwitch:
  6060 00001678 8936[A601]              	mov	[SingleCom],si		; Point to the rest of the command line
  6061 0000167C C606[861C]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  6062                                  ;COMRETURNSJ: ; 24/09/2018
  6063 00001681 E92201                  	jmp     ArgsDone
  6064                                  
  6065                                  ;CHECKESWITCH:
  6066                                  	;cmp	al,'e'
  6067                                  	;jnz	short CHKARG
  6068                                  
  6069                                  ; Look for environment-size setting switch
  6070                                  
  6071                                  ; The environment size is represented in decimal bytes and is
  6072                                  ; converted into paragraphs (rounded up to the next paragraph).
  6073                                  
  6074                                  SetESwitch:
  6075                                  	; MSDOS 6.0
  6076 00001684 803E[C41C]00            	cmp	byte [eswitch],0	; has environment size switch been set?
  6077                                  	; 16/04/2023
  6078                                  	;jz	short eswitchok		; no - set it
  6079                                  	;;mov	ax,1
  6080                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6081                                          ;jmp	parse_line_error	; go issue error message
  6082                                  	; 16/04/2023
  6083 00001689 75B2                    	jnz	short parse_line_error_j
  6084                                  eswitchok:
  6085 0000168B FE06[C41C]              	inc	byte [eswitch]		; indicate /E entered 	
  6086                                  
  6087                                  ; 15/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6088                                  %if 0
  6089                                  	; 23/09/2018 - Retro DOS v3.0
  6090                                  
  6091                                  	; MSDOS 3.3
  6092                                  	; (COMMAND.COM offset 0FC5h)
  6093                                  ESWITCHOK:
  6094                                  	jcxz    CHKARG
  6095                                  	dec     cx
  6096                                  	lodsb
  6097                                  	cmp     al,':'
  6098                                  	jnz     short CHECKSWITCHCHR
  6099                                  	xor     bx,bx
  6100                                  	mov     ax,bx
  6101                                  GETENVSIZE:
  6102                                  	jcxz    SETENVSIZE
  6103                                  	dec     cx
  6104                                  	lodsb
  6105                                  	cmp     al,'0'
  6106                                  	jb      short NOTDECIMALCHR
  6107                                  	cmp     al,'9'
  6108                                  	ja      short NOTDECIMALCHR
  6109                                  	sub     al,'0'
  6110                                  	mov     dx,bx
  6111                                  	shl     dx,1
  6112                                  	shl     dx,1   ; dx = 4*bx	
  6113                                  	add     bx,dx  ; bx = 5*bx
  6114                                  	shl     bx,1   ; bx = 10*bx	
  6115                                  	add     bx,ax
  6116                                  	jmp     short GETENVSIZE
  6117                                  
  6118                                  NOTDECIMALCHR:
  6119                                  	;cmp	al,' '
  6120                                  	cmp	al,[SPACE_CHAR]
  6121                                  	jz      short CHECKENVSIZE
  6122                                  	;cmp	al,'/'
  6123                                  	cmp     al,[RSWITCHAR]
  6124                                  	jz      short CHECKENVSIZE
  6125                                  
  6126                                  CHECKNEXTECHR:
  6127                                  	jcxz    INVENVSIZE
  6128                                  	dec     cx
  6129                                  	lodsb
  6130                                  	;cmp	al,' '
  6131                                  	cmp     al,[SPACE_CHR]
  6132                                  	jz      short ENVSIZESPC
  6133                                  	;cmp	al,'/'
  6134                                  	cmp     al,[RSWITCHAR]
  6135                                  	jnz     short CHECKNEXTECHR
  6136                                  
  6137                                  ENVSIZESPC:
  6138                                  	dec     si
  6139                                  	inc     cx
  6140                                  	jmp     short INVENVSIZE
  6141                                  	
  6142                                  	;nop
  6143                                  
  6144                                  CHECKENVSIZE: 
  6145                                  	dec     si
  6146                                  	inc     cx
  6147                                  
  6148                                  SETENVSIZE:
  6149                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  6150                                  	mov	word [ENVSIZ],ENVBIG/16
  6151                                  	cmp     bx,32768
  6152                                  	ja      short INVENVSIZE
  6153                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  6154                                  	mov	word [ENVSIZ],ENVSML/16
  6155                                  	cmp     bx,160
  6156                                  	jb      short INVENVSIZE
  6157                                  	add     bx,15
  6158                                  	shr     bx,1
  6159                                  	shr     bx,1
  6160                                  	shr     bx,1
  6161                                  	shr     bx,1
  6162                                  	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  6163                                  	jmp     short NEXTCH2
  6164                                  
  6165                                  	;nop
  6166                                  
  6167                                  INVENVSIZE:
  6168                                  	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  6169                                  	mov     ah,STD_CON_STRING_OUTPUT ; 9
  6170                                  	int     21h             ; DOS - PRINT STRING
  6171                                  				; DS:DX -> string terminated by "$"
  6172                                  NEXTCH2:
  6173                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  6174                                  	jmp     CHKARG
  6175                                  
  6176                                  	;jmp	ARGSDONE
  6177                                  
  6178                                  %endif
  6179                                  	; 15/01/2023
  6180                                  	; MSDOS 6.0
  6181                                  	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
  6182 0000168F BF[511D]                        mov	di,COMND1_ADDR
  6183 00001692 8B1D                    	mov     bx,[di]				; into bx
  6184                                  
  6185 00001694 83C30F                  	add	bx,0Fh				; Round up to next paragraph
  6186 00001697 B104                    	mov	cl,4				; convert to pargraphs
  6187 00001699 D3EB                    	shr	bx,cl				; by right 4
  6188                                  
  6189 0000169B 891E[AF1C]              	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
  6190 0000169F E9EBFE                  	jmp	Parse_command_line		; continue parsing command line
  6191                                  
  6192                                  ; 16/04/2023
  6193                                  %if 0
  6194                                  SetMSwitch:
  6195                                          ;cmp	byte [ext_msg],1
  6196                                  	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6197                                  	jnz	short setMswitchok		; no - set it
  6198                                  	;mov	ax,1
  6199                                  	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6200                                  	jmp	parse_line_error                ; go issue error message
  6201                                  setMswitchok:
  6202                                          ;mov	byte [ext_msg],1
  6203                                  	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6204                                  	jmp	Parse_command_line              ; keep parsing
  6205                                  %endif
  6206                                  
  6207                                  ;ArgsDoneJ:
  6208                                  	;jmp	ArgsDone
  6209                                  
  6210                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6211                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
  6212                                  	
  6213                                  ChkOtherArgs:
  6214                                  
  6215                                  ; We have a non-switch character here.
  6216                                  
  6217                                  	; MSDOS 6.0
  6218 000016A2 1E                      	push	ds ; ****			;
  6219 000016A3 56                      	push	si ; *** 			; save place in command line
  6220 000016A4 C536[511D]              	lds	si,[COMND1_ADDR]		; get address of filespec
  6221                                  	;assume	ds:nothing			;
  6222                                  
  6223 000016A8 89F2                    	mov	dx,si				; put in dx also
  6224 000016AA B8023D                  	mov	ax,3D02h
  6225                                  	;mov	ax,(OPEN shl 8) or 2            ; Read and write
  6226 000016AD CD21                    	int	21h
  6227 000016AF 7260                    	jc	short ChkSrchSpec		; Wasn't a file
  6228 000016B1 89C3                    	mov	bx,ax
  6229 000016B3 B80044                  	mov	ax,4400h
  6230                                  	;mov	ax,IOCTL shl 8
  6231 000016B6 CD21                    	int	21h
  6232 000016B8 F6C280                  	test	dl,80h
  6233 000016BB 7506                    	jnz	short IsaDevice
  6234                                  BadSetCon:
  6235 000016BD B43E                    	mov	ah,3Eh
  6236                                  	;mov	ah,CLOSE		; Close initial handle, wasn't a device
  6237 000016BF CD21                    	int	21h
  6238 000016C1 EB4E                    	jmp	short ChkSrchSpec
  6239                                  
  6240                                  ; 15/01/2023
  6241                                  %if 0
  6242                                  	; MSDOS 3.3
  6243                                  	; (COMMAND.COM offset 1047h)
  6244                                          dec	si
  6245                                  	inc	cx
  6246                                  	mov	dx,si
  6247                                  	push	cx ; **
  6248                                  	push	si ; *
  6249                                  CONTRLOOP:
  6250                                  	lodsb
  6251                                  	dec	cx
  6252                                  	;cmp	al,' '
  6253                                  	cmp	al,[SPACE_CHR]
  6254                                  	jz	short SETCDEV
  6255                                  	cmp	al,9
  6256                                  	jz	short SETCDEV
  6257                                  	jcxz	SETCDEVA
  6258                                  	jmp	short CONTRLOOP
  6259                                  
  6260                                  SETCDEVA:
  6261                                          inc	si
  6262                                  SETCDEV:
  6263                                  	mov	byte [SI-1],0
  6264                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  6265                                          mov	ax,(OPEN*256) | 2 ; 3D02h
  6266                                          int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  6267                                  			; DS:DX -> ASCIZ filename
  6268                                  			; AL = access mode
  6269                                  			; 2 - read & write
  6270                                          jc	short CHKSRCHSPEC	; Wasn't a file
  6271                                          mov	bx,ax
  6272                                          ;mov	ax,IOCTL shl 8
  6273                                          mov     ax,IOCTL*256 ; 4400h
  6274                                  	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  6275                                  			; BX = file or device handle
  6276                                          test	dl,80H
  6277                                  	jnz	short ISADEVICE
  6278                                  BADSETCON: ; MSDOS 6.0
  6279                                  	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  6280                                          int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  6281                                  			; BX = file handle
  6282                                          JMP     short CHKSRCHSPEC
  6283                                  %endif
  6284                                  	;nop
  6285                                  
  6286                                  	; 15/01/2023
  6287                                  IsaDevice:
  6288                                  	; MSDOS 3.3 & MSDOS 6.0
  6289 000016C3 30F6                    	xor	dh,dh
  6290 000016C5 80CA03                  	or	dl,3				; Make sure has CON attributes
  6291                                  	;mov	ax,(IOCTL shl 8) or 1
  6292 000016C8 B80144                  	mov	ax,(IOCTL*256)|1 ; 4401h
  6293 000016CB CD21                    	int	21h
  6294                                  	;
  6295                                  	; 15/01/2023
  6296 000016CD 72EE                    	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
  6297                                  	; 25/09/2018
  6298                                  	;pop	dx ; *
  6299                                  	;pop	dx ; **
  6300                                  	;
  6301                                  	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  6302                                  	
  6303 000016CF 89DA                    	mov	dx,bx				; Save new handle
  6304                                  
  6305                                  	; MSDOS 6.0
  6306 000016D1 26803E[0321]01          	cmp	byte [es:DevFlag],1
  6307 000016D7 742A                    	jz	short DevErr
  6308                                  
  6309                                  	; MSDOS 3.3
  6310                                          ;pop	bx ; *				; Throw away saved SI
  6311                                          ;pop	bx ; **				; Throw away saved CX
  6312                                  
  6313                                  	; MSDOS 3.3 & MSDOS 6.0
  6314 000016D9 51                      	push	cx ; **
  6315 000016DA B90300                  	mov	cx,3
  6316 000016DD 31DB                    	xor	bx,bx
  6317                                  
  6318                                  	; 15/01/2023
  6319                                  rcclloop:
  6320 000016DF B43E                    	mov	ah,3Eh
  6321                                  	;mov	ah,CLOSE ; 3Eh
  6322 000016E1 CD21                    	int	21h
  6323 000016E3 43                      	inc	bx
  6324 000016E4 E2F9                    	loop	rcclloop
  6325                                  
  6326 000016E6 89D3                    	mov	bx,dx				; New device handle
  6327 000016E8 B445                    	mov	ah,45h
  6328                                  	;mov	ah,XDUP ; 45h
  6329 000016EA CD21                    	int	21h				; Dup to 0
  6330 000016EC B445                    	mov	ah,45h
  6331                                  	;mov	ah,XDUP
  6332 000016EE CD21                    	int	21h				; Dup to 1
  6333 000016F0 B445                    	mov	ah,45h
  6334                                  	;mov	ah,XDUP
  6335 000016F2 CD21                    	int	21h				; Dup to 2
  6336 000016F4 B43E                    	mov	ah,3Eh
  6337                                  	;mov	ah,CLOSE
  6338 000016F6 CD21                    	int	21h				; Close initial handle
  6339                                  	
  6340 000016F8 59                      	pop	cx ; **
  6341                                  	
  6342                                  	; MSDOS 6.0
  6343 000016F9 5E                      	pop	si ; ***			; restore position of command line
  6344 000016FA 1F                      	pop	ds ; ****			;
  6345                                  
  6346                                  ; Register the fact that we already have redirected the output
  6347                                  ; and can not do it again
  6348                                  
  6349 000016FB 26FE06[0321]            	inc	byte [es:DevFlag]		
  6350 00001700 E98AFE                  	jmp	Parse_command_line		; continue parsing
  6351                                  
  6352                                  	; MSDOS 3.3
  6353                                  	;jcxz	ARGSDONEJ2
  6354                                  	;jmp	CHKARG
  6355                                  
  6356                                  	; MSDOS 6.0
  6357                                  DevErr:
  6358 00001703 5E                      	pop	si ; ***
  6359 00001704 1F                      	pop	ds ; ****
  6360 00001705 BA0100                  	mov	dx,1
  6361 00001708 E8E402                          call	RPrintParse                     ; "Too many parameters"
  6362 0000170B E880FB                          call	crlf
  6363 0000170E E97CFE                  	jmp	Parse_command_line
  6364                                  
  6365                                  ChkSrchSpec:				; Not a device, so must be directory spec
  6366                                  	; MSDOS 6.0
  6367 00001711 26803E[0421]01                  cmp	byte [es:PathFlag],1		; already set COMSPEC?
  6368 00001717 74EA                            jz	short DevErr			; yes, error
  6369                                  	
  6370 00001719 26FE06[0421]                    inc	byte [es:PathFlag]		; mark that we have a path
  6371                                  
  6372                                  ; We have to override the passed environment. Allocate a buffer for use now.
  6373                                  ; This buffer will later be replaced by a proper environment
  6374                                  
  6375                                  	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
  6376                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
  6377 0000171E 36A1[3F03]              	mov	ax,[ss:EnvirSeg]
  6378                                  	
  6379                                  	; MSDOS 6.0
  6380                                  	;call	alloc_env                       ; environment buffer
  6381                                  
  6382                                  	; 15/01/2023
  6383                                  	; MSDOS 5.0
  6384 00001722 36803E[931C]01          	cmp	byte [ss:AllocedEnv],1
  6385 00001728 36C606[931C]00          	mov	byte [ss:AllocedEnv],0
  6386 0000172E 7507                    	jne     short env_alloced
  6387 00001730 E89004                  	call	alloc_env
  6388 00001733 36A3[3F03]              	mov	[ss:EnvirSeg],ax
  6389                                  
  6390                                  env_alloced:
  6391                                  	; MSDOS 5.0 & MSDOS 6.0
  6392 00001737 8EC0                    	mov	es,ax
  6393                                  	;assume	es:nothing
  6394 00001739 56                      	push	si ; **				; remember location of file
  6395 0000173A 31C9                    	xor	cx,cx				; clear cx for counting
  6396                                  	
  6397                                  	; 15/01/2023
  6398                                  countloop:
  6399 0000173C AC                      	lodsb					; get a character
  6400 0000173D 41                      	inc	cx				; increment counter
  6401                                          ;;cmp	al,0
  6402                                  	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  6403                                  	;jne	short countloop			; no - keep counting
  6404 0000173E 08C0                    	or	al,al	
  6405 00001740 75FA                    	jnz	short countloop
  6406                                  
  6407                                  	;;;;mov	al,[Space]
  6408                                  	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
  6409                                  	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6410                                  	; 16/04/2023
  6411                                  	;mov	al,20h ; ' ' 
  6412 00001742 4E                      	dec	si				; move back one
  6413                                          ;mov	[si],al				; put a space at end of line
  6414 00001743 C60420                  	mov	byte [si],20h ; ' ' ; space_chr
  6415                                  
  6416                                  ; We now know how long the new pathspec for command.com is. Time to
  6417                                  ; figure out how long the current COMSPEC setting is, and then to move
  6418                                  ; all the environment data up, throwing that COMSPEC setting away, and
  6419                                  ; preparing to append the new COMSPEC. ComspOffset (the offset of
  6420                                  ; where the filespec exists in the environment) is updated as well.
  6421                                  
  6422                                  	; MSDOS 6.0 COMMAND.COM
  6423                                  	;push	cx                              ;
  6424                                          ;mov	cx,ENVBIG                       ;
  6425                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  6426                                          ;mov	al,0                            ;
  6427                                          ;repne	scasb                           ; find the end of COMSPEC
  6428                                          ;mov	si,di                           ;
  6429                                  ;comp_endenv:                                   ;
  6430                                          ;scasb                                  ; end of env?
  6431                                          ;je	got_endenv                      ; yes
  6432                                          ;repne	scasb                           ;
  6433                                          ;jmp	comp_endenv                     ;
  6434                                  ;got_endenv:                                    ;
  6435                                          ;mov    cx,di                           ;
  6436                                          ;sub    cx,si                           ;
  6437                                          ;mov    di,ComspOffset                  ;
  6438                                          ;sub    di,ComspStrLen                  ;
  6439                                          ;push   ds                              ;
  6440                                          ;push   es                              ;
  6441                                          ;pop    ds                              ;
  6442                                          ;rep    movsb                           ;
  6443                                          ;dec    di                              ; copy in new COMSPEC=
  6444                                          ;push   cs                              ;
  6445                                          ;pop    ds                              ;
  6446                                          ;assume ds:ResGroup                     ;
  6447                                          ;mov    si,offset RESGROUP:ComspString  ;
  6448                                          ;mov    cx,ComspStrLen                  ;
  6449                                          ;rep    movsb                           ;
  6450                                          ;mov    ComspOffset,di                  ;
  6451                                          ;pop    ds                              ;
  6452                                          ;assume ds:nothing                      ;
  6453                                          ;pop    cx                              ;
  6454                                  	;
  6455                                          ;pop    si                              ; get new comspec location back
  6456                                  
  6457                                  	; MSDOS 3.3 COMMAND.COM
  6458                                  	;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
  6459                                  	;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
  6460                                  	;mov	cl,4
  6461                                  	;shr	ax,cl
  6462                                  	;mov	dx,ds
  6463                                  	;add	ax,dx
  6464                                  	;mov	[ENVIRSEG],ax
  6465                                  	;mov	es,ax
  6466                                  	;;mov	al,' '
  6467                                  	;mov	al,[SPACE_CHR]
  6468                                  	;mov	[si-1],al
  6469                                  	;pop	si ; **				; Remember location
  6470                                  	;pop	cx ; *				; and count
  6471                                  	;;mov	di,[ECOMLOC]
  6472                                  	;mov	di,[COMSPOFFSET]
  6473                                  
  6474                                  	; 15/01/2023
  6475                                  	; MSDOS 5.0 COMMAND.COM
  6476 00001746 5E                      	pop	si ; **
  6477                                  	;mov	di,14
  6478 00001747 BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6479                                  
  6480                                  ComtrLoop:
  6481                                  	; MSDOS 3.3 & MSDOS 6.0
  6482 0000174A AC                      	lodsb
  6483 0000174B 49                      	dec	cx
  6484                                  	;;;;cmp	al,' '
  6485                                  	;;;cmp	al,[space_chr]
  6486                                  	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
  6487                                  	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6488                                  	; 16/04/2023
  6489 0000174C 3C20                    	cmp	al,20h ; ' ' ; space_chr
  6490 0000174E 7405                    	je	short SetComsr
  6491                                  	; MSDOS 3.3
  6492                                  	;cmp	al,9
  6493                                  	;je	short SetComsr
  6494                                  	; MSDOS 3.3 & MSDOS 6.0
  6495 00001750 AA                      	stosb
  6496 00001751 E302                    	jcxz	SetComsr
  6497 00001753 EBF5                    	jmp	short ComtrLoop
  6498                                  
  6499                                  SetComsr:
  6500                                  	; 15/01/2023
  6501                                  	; MSDOS 6.0
  6502 00001755 51                      	push	cx ; **
  6503 00001756 0E                      	push	cs				; Get local segment
  6504 00001757 1F                      	pop	ds				;
  6505                                  	;assume	ds:ResGroup			;
  6506 00001758 1E                      	push	ds ; *
  6507                                  	;mov	si,offset ResGroup:ComSpect
  6508 00001759 BE[671C]                	mov	si,COMSPECT
  6509 0000175C B90E00                  	mov	cx,14
  6510 0000175F 268A45FF                	mov	al,[es:di-1]
  6511 00001763 3A06[5403]              	cmp	al,[RDirChar]
  6512 00001767 7502                    	jne	short iNotRoot
  6513 00001769 46                      	inc	si				; Don't make a double /
  6514 0000176A 49                      	dec	cx
  6515                                  	
  6516                                  	; MSDOS 3.3
  6517                                  	;push	si
  6518                                  	;push	cx
  6519                                  	;push	ds
  6520                                  	;mov	si,COMSPECT ; "/COMMAND.COM"
  6521                                  	;mov	cx,14
  6522                                  	;mov	al,[es:di-1]
  6523                                  	;call	PATHCHRCMPR
  6524                                  	;jnz	short INOTROOT			
  6525                                  	;inc	si				; Don't make a double /
  6526                                  	;dec	cx
  6527                                  
  6528                                  iNotRoot:
  6529                                  	; MSDOS 3.3 & MSDOS 6.0
  6530 0000176B F3A4                    	rep	movsb
  6531                                  
  6532                                  	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  6533                                          ;mov	dx,[ComspOffset] ; [COMSPOFFSET]
  6534                                  	; 15/01/2023
  6535                                  	;mov	dx,14
  6536 0000176D BA0E00                  	mov	dx,ECOMSPEC ; mov dx,0Eh
  6537                                  
  6538 00001770 06                      	push	es
  6539 00001771 1F                      	pop	ds
  6540                                  	;;mov	ax,OPEN shl 8
  6541                                  	;mov	ax,OPEN*256 ; 3D00h
  6542 00001772 B8003D                  	mov	ax,3D00h ; 15/01/2023
  6543 00001775 CD21                    	int	21h				; Open COMMAND.COM
  6544 00001777 1F                      	pop	ds ; *
  6545 00001778 720E                    	jc	short SetComsrBad		; No COMMAND.COM here
  6546 0000177A 89C3                    	mov	bx,ax				; Handle
  6547 0000177C B43E                    	mov	ah,3Eh ; 15/01/2023
  6548                                  	;mov	ah,CLOSE ; 3Eh
  6549 0000177E CD21                    	int	21h				; Close COMMAND.COM
  6550                                  SetComsrRet:
  6551                                  	; 15/01/2023
  6552 00001780 59                      	pop	cx ; **
  6553 00001781 5E                      	pop	si ; ***
  6554                                  
  6555                                  	; MSDOS 6.0
  6556 00001782 1F                      	pop	ds ; ****			;
  6557                                  	;assume	ds:ResGroup			;
  6558                                  	;
  6559 00001783 0E                      	push	cs				; Make sure local ES is
  6560 00001784 07                      	pop	es				;  restored
  6561 00001785 E905FE                  	jmp	Parse_command_line		; continue parsing command line
  6562                                  
  6563                                  	; MSDOS 3.3
  6564                                  ;ARGSDONEJ2:
  6565                                  	;jcxz	ARGSDONE
  6566                                  	;jmp	CHKARG
  6567                                  
  6568                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6569                                  SetComsrBad:
  6570                                  	; MSDOS 3.3 & MSDOS 6.0
  6571                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  6572 00001788 BA[EC1D]                	mov	dx,BADCOMLKMES
  6573                                  
  6574                                  ;	Note: we're about to make a near call to TriageError, which
  6575                                  ;	lives in a different segment and group. Some linkers will
  6576                                  ;	generate a warning like "Possible fix-up overflow". We're
  6577                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  6578                                  ;	we're still all together.
  6579                                  
  6580                                  	; 16/01/2023
  6581                                  	TRIAGEERROR equ TRANSTART+TriageError
  6582                                  	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)
  6583                                  
  6584                                  	;call	50B2h
  6585 0000178B E8(EB4E)                	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  6586                                  				; in original MSDOS 3.3 COMMAND.COM
  6587                                  
  6588                                  			; TriageError procedure is at offset 50B2h
  6589                                  			; in original MSDOS 5.0 COMMAND.COM	
  6590 0000178E 83F841                  	cmp	ax,65
  6591 00001791 7503                    	jne	short doprt
  6592                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  6593 00001793 BA[151E]                	mov	dx,BADCOMACCMSG
  6594                                  doprt:
  6595 00001796 E8F8FA                  	call	RPrint
  6596                                  	;mov	si,offset ResGroup:ComSpect
  6597 00001799 BE[671C]                	mov     si,COMSPECT ; "\COMMAND.COM"
  6598                                  	;;mov	di,[ECOMLOC]
  6599                                  	;mov	di,[COMSPOFFSET] ; [ComspOffset]
  6600                                  	; 16/01/2023
  6601 0000179C BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6602 0000179F B90E00                  	mov	cx,14
  6603 000017A2 F3A4                    	rep	movsb				; get my default back
  6604                                  
  6605 000017A4 EBDA                    	jmp	short SetComsrRet
  6606                                  
  6607                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6608                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
  6609                                  ArgsDone:
  6610                                  	; MSDOS 6.0
  6611 000017A6 8E06[3F03]              	mov	es,[EnvirSeg]			; get environment back
  6612                                  	;assume	es:nothing			;
  6613                                  
  6614                                  	; MSDOS 3.3 & MSDOS 6.0
  6615 000017AA 803E[A501]00                    cmp	byte [PermCom],0
  6616 000017AF 742E                            jz	short ComReturns
  6617                                  
  6618 000017B1 06                      	push	es				; Save environment pointer
  6619 000017B2 B450                    	mov	ah,50h
  6620                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  6621 000017B4 8CDB                    	mov	bx,ds
  6622 000017B6 8EC3                    	mov	es,bx
  6623 000017B8 CD21                    	int	21h				; current process is me
  6624 000017BA BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  6625                                  	;;mov	ax,offset RESGROUP:LODCOM
  6626                                  	;mov	ax,LODCOM
  6627                                  	; 16/01/2023
  6628 000017BD B8[7E00]                	mov	ax,LodCom_Trap
  6629 000017C0 AB                              stosw
  6630 000017C1 8CD8                            mov	ax,ds
  6631 000017C3 AB                              stosw
  6632                                  	;;mov	ax,offset RESGROUP:CONTC
  6633                                  	;mov	ax,CONTC
  6634                                  	; 16/01/2023
  6635 000017C4 B8[4A00]                	mov	ax,Ctrlc_Trap
  6636 000017C7 AB                              stosw
  6637 000017C8 8CD8                            mov	ax,ds
  6638 000017CA AB                              stosw
  6639                                  	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  6640                                  	;mov	ax,CRITERR
  6641                                  	; 16/01/2023
  6642 000017CB B8[5500]                	mov	ax,CritErr_Trap
  6643 000017CE AB                      	stosw
  6644 000017CF 8CD8                    	mov     ax,ds
  6645 000017D1 AB                      	stosw
  6646                                  	;;mov	word ptr ds:16h,ds
  6647                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  6648 000017D2 8C1E1600                	mov	[PDB.PARENT_PID],ds
  6649                                          ;;mov	dx,offset RESGROUP:Int_2e
  6650                                  	;mov	dx,Int_2e
  6651                                          ; 16/01/2023
  6652 000017D6 BA[3F00]                	mov	dx,Int2e_Trap
  6653 000017D9 B82E25                  	mov	ax,252Eh
  6654                                  	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  6655                                  	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  6656 000017DC CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  6657                                  			; AL = interrupt number
  6658                                  			; DS:DX = new vector to be used for specified interrupt
  6659 000017DE 07                              pop	es				; Remember environment
  6660                                  	
  6661                                  ComReturns:
  6662                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  6663 000017DF A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  6664                                  	; 16/01/2023
  6665 000017E2 A3[4101]                	mov	[Parent],ax			; Save parent
  6666                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  6667 000017E5 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  6668                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  6669 000017E9 A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
  6670 000017EC A3[A201]                        mov	[Io_Save],ax		; Get the default stdin and out
  6671 000017EF 8C1E[4303]                      mov	[Com_Ptr+2],ds		; Set all these to resident
  6672 000017F3 8C1E[4703]                      mov	[Com_Fcb1+2],ds
  6673 000017F7 8C1E[4B03]              	mov	[Com_Fcb2+2],ds
  6674                                          ;mov	di,offset ResGroup:ComSpec
  6675 000017FB BF[4E01]                        mov	di,ComSpec
  6676                                  
  6677                                  	;;mov	si,[ECOMLOC]
  6678                                  	; 16/01/2023
  6679                                  	;mov	si,[ComspOffset]
  6680 000017FE BE0E00                  	mov	si,ECOMSPEC ; mov si,0Eh
  6681 00001801 803E[931C]00            	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
  6682                                          ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  6683                                  	
  6684 00001806 8CD8                    	mov	ax,ds				; Xchg es,ds
  6685 00001808 06                      	push	es
  6686 00001809 1F                      	pop	ds
  6687 0000180A 8EC0                    	mov	es,ax
  6688                                  
  6689                                  	;jne	short CopyComsp ; MSDOS 6.0
  6690                                  	; 16/01/2023	
  6691 0000180C 7417                    	je	short CopyComsp ; MSDOS 5.0
  6692                                  	;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  6693                                  
  6694 0000180E 0E                              push	cs
  6695 0000180F 1F                              pop	ds
  6696                                  
  6697                                          ;mov	si,offset ResGroup:ComspString
  6698 00001810 BE[9A1C]                	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6699 00001813 06                      	push	es
  6700 00001814 57                      	push	di
  6701 00001815 E8E801                  	call	IfindE
  6702 00001818 89FE                    	mov	si,di
  6703 0000181A 06                      	push	es
  6704 0000181B 1F                      	pop	ds
  6705 0000181C 5F                      	pop	di
  6706 0000181D 07                      	pop	es
  6707 0000181E 7305                            jnc	short CopyComsp
  6708                                  
  6709                                  	; MSDOS 6.0
  6710                                  ComSpecNofnd:
  6711                                  	;mov	si,offset ResGroup:ComspString
  6712                                  	;add	si,ComspStrLen
  6713                                  	;push	cs
  6714                                  	;pop	ds
  6715                                  
  6716                                  	; 21/01/2023
  6717                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
  6718                                  	;mov	si,0Eh
  6719 00001820 BE0E00                  	mov	si,ECOMSPEC
  6720 00001823 0E                      	push	cs
  6721 00001824 1F                      	pop	ds	
  6722                                  
  6723                                  	; 21/01/2023
  6724                                  ;COMSPECNOFND:
  6725                                  	; MSDOS 3.3
  6726                                          ;;mov	si,[es:ECOMLOC]
  6727                                          ;mov	si,[es:COMSPOFFSET]
  6728                                  	;;add	si,offset RESGROUP:PATHSTRING
  6729                                          ;add	si,PATHSTRING ; "PATH="
  6730                                  	;push	cs
  6731                                  	;pop	ds
  6732                                  
  6733                                  CopyComsp:
  6734                                  	; 21/01/2023
  6735                                  ;COPYCOMSP:
  6736                                  	; MSDOS 3.3 & MSDOS 6.0
  6737                                  	;;mov	es:PutBackComSpec.SubstPtr,di
  6738                                  	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  6739 00001825 26893E[2D01]            	mov	[es:PutBackComSpec],di
  6740 0000182A 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  6741 0000182E 7506                    	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
  6742                                  	;;add	es:PutBackComSpec.SubstPtr,2
  6743                                  	;add	word [es:PUTBACKSUBSTPTR],2
  6744 00001830 268306[2D01]02          	add	word [es:PutBackComSpec],2
  6745                                  CopyComspLoop:
  6746 00001836 AC                      	lodsb
  6747 00001837 AA                      	stosb
  6748 00001838 08C0                    	or	al,al
  6749 0000183A 75FA                    	jnz	short CopyComspLoop
  6750                                  
  6751 0000183C 26893E[8E01]            	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
  6752 00001841 26FF0E[8E01]            	dec	word [es:ComSpec_End]
  6753 00001846 268A26[9701]            	mov	ah,[es:ComDrv]
  6754 0000184B 80C440                  	add	ah,'A'-1 ; 40h
  6755 0000184E 268826[3201]            	mov	[es:PutBackDrv],ah		; save drive letter
  6756                                  
  6757                                  	; -------------------------------
  6758                                  
  6759                                  ; 21/01/2023 - Retro DOS v4.0 COMMAND.COM
  6760                                  %if 0
  6761                                  
  6762                                  	; MSDOS 3.3
  6763                                  	push	cs
  6764                                          pop	ds
  6765                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  6766                                  	mov	bx,DATARESEND+15
  6767                                          mov	cl,4
  6768                                          shr	bx,cl
  6769                                          MOV     AH,SETBLOCK ; 4Ah
  6770                                          int	21h			; Shrink me to the resident only
  6771                                  
  6772                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  6773                                  
  6774                                  	mov	byte [TRNMVFLG], 1
  6775                                  	push	es ; *
  6776                                  	mov	si,TRANSTART
  6777                                  	mov	di,0
  6778                                  	mov	es,[TrnSeg]
  6779                                  	;mov	cx,4D5Ch
  6780                                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  6781                                  	push	cx
  6782                                  	mov	ax,cx
  6783                                  	add	ax,si
  6784                                  	mov	cl,4
  6785                                  	shr	ax,cl
  6786                                  	inc	ax
  6787                                  	mov	cx,ds
  6788                                  	add	ax,cx
  6789                                  	cmp	ax,[TrnSeg]
  6790                                  	pop	cx
  6791                                  	jb	short MOV_DOWN
  6792                                  
  6793                                  	call	LOADCOM
  6794                                  	jmp	short ICHKSUM
  6795                                  
  6796                                  MOV_DOWN:
  6797                                  	add     si,cx
  6798                                  	dec     si
  6799                                  	add     di,cx
  6800                                  	dec     di
  6801                                  	std
  6802                                  	rep	movsb
  6803                                  	cld
  6804                                  
  6805                                  ICHKSUM:
  6806                                  	; 24/09/2018
  6807                                  ;
  6808                                  ; Compute checksum right now before we can get corrupted and save it
  6809                                  ;
  6810                                  	; MSDOS 6.0
  6811                                  	;mov	si,offset RESGROUP:TranStart
  6812                                  	;add	si,100h
  6813                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6814                                  	;
  6815                                  	;cld
  6816                                  	;shr	cx,1
  6817                                  	;xor	dx,dx
  6818                                  ;Ichksum:
  6819                                  	;lodsw
  6820                                  	;add	dx,ax
  6821                                  	;adc	dx,0
  6822                                  	;loop	Ichksum
  6823                                  	;
  6824                                          ;mov	Sum,dx			; store checksum
  6825                                  
  6826                                  	; MSDOS 3.3
  6827                                  	pop     es ; *
  6828                                  	call    CHKSUM
  6829                                  	mov     [SUM],dx
  6830                                  
  6831                                  	; MSDOS 3.3 & MSDOS 6.0
  6832                                          cmp     byte [PRDATTM],0	;
  6833                                          jnz     short NOBATCHSEG	; don't do autoexec or date time
  6834                                  ;
  6835                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6836                                  ;
  6837                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  6838                                  	;mov	bx,3
  6839                                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  6840                                          mov     ah,ALLOC ; 48h		;
  6841                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6842                                  			; BX = number of 16-byte paragraphs desired
  6843                                  	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  6844                                          mov     [BATCH],ax		; save batch segment
  6845                                  
  6846                                  NOBATCHSEG:
  6847                                  
  6848                                  %endif
  6849                                  	; -------------------------------
  6850                                  
  6851                                  	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
  6852                                  	
  6853                                  	; MSDOS 6.0
  6854 00001853 E82102                  	call	setup_for_messages		; set up parse and extended error messages
  6855                                  
  6856                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  6857                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  6858                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  6859                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  6860                                  ; the data otherwise it is just the data.
  6861                                   
  6862 00001856 E8BB02                  	call	Setup_res_end			; put resident size in ResSize
  6863                                  
  6864 00001859 0E                      	push	cs
  6865 0000185A 1F                      	pop	ds
  6866                                  	;assume	ds:RESGROUP
  6867                                  
  6868                                  ;Public EnvMaximum
  6869                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6870                                  EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh
  6871                                  
  6872                                  	; 21/01/2023
  6873                                  	; MSDOS 6.0
  6874                                  	;;mov	si,offset RESGROUP:TranStart
  6875                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
  6876                                  	;mov	si,TRANSTART
  6877                                  	;add	si,100h
  6878                                  	; 23/04/2023
  6879 0000185B BE4023                  	mov	si,TRANSTART+100h
  6880                                  
  6881                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6882                                  	;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
  6883 0000185E B9[2B85]                	mov	cx,TRANDATAEND-100h
  6884                                  
  6885 00001861 FC                      	cld
  6886 00001862 D1E9                    	shr	cx,1
  6887 00001864 31D2                    	xor	dx,dx
  6888                                  Ichksum:
  6889 00001866 AD                      	lodsw
  6890 00001867 01C2                    	add	dx,ax
  6891 00001869 83D200                  	adc	dx,0
  6892 0000186C E2F8                    	loop	Ichksum
  6893                                  
  6894 0000186E 8916[9A01]                      mov	[Sum],dx			; store checksum
  6895                                  
  6896 00001872 803E[861C]00                    cmp     byte [PRDATTM],0
  6897 00001877 750C                            jne	short NoBatchSeg		; don't do autoexec or date time
  6898                                  	
  6899                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6900                                  
  6901                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
  6902                                  	; 21/01/2023
  6903                                  	;mov	bx,4
  6904 00001879 BB0400                          mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  6905 0000187C B448                    	mov	ah,48h
  6906                                  	;mov	ah,ALLOC                        ;
  6907 0000187E CD21                            int	21h                             ;
  6908 00001880 7203                    	jc	short NoBatchSeg		; didn't allocate - pretend no batch
  6909 00001882 A3[4C01]                        mov	[Batch],ax			; save batch segment
  6910                                  
  6911                                  NoBatchSeg:
  6912                                  
  6913                                  ; 21/01/2023
  6914                                  %if 0
  6915                                  	; MSDOS 3.3
  6916                                  	mov     bx,0FFFFh ; 65535
  6917                                  	mov     ah,ALLOC ; 48h
  6918                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6919                                  			; BX = number of 16-byte paragraphs desired
  6920                                  	sub     bx,[TRNSIZE]
  6921                                  	sub     bx,128
  6922                                  	mov     [ENVMAX],bx
  6923                                  
  6924                                  	cmp     bx,4096
  6925                                  	jb      short ALLOCENVIRSEG
  6926                                  	mov     bx,4096-1		; max. allowed environment size
  6927                                  	mov     [ENVMAX],bx
  6928                                  
  6929                                  ALLOCENVIRSEG:
  6930                                  	mov     ah,ALLOC ; 48h
  6931                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6932                                  			; BX = number of 16-byte paragraphs desired
  6933                                  	mov     bx,[ENVIRSEG]		; get old environment segment
  6934                                  	mov     [OLDENV],bx		; save it	
  6935                                  	mov     word [USEDENV],0	; initialize environment size counter
  6936                                  	mov     ds,bx
  6937                                  	mov     [ss:ENVIRSEG], ax	; save new environment segment
  6938                                  	mov     es,ax
  6939                                  	xor     si,si
  6940                                  	mov     di,si
  6941                                  	mov     bx,[ss:ENVMAX]
  6942                                  	shl     bx,1
  6943                                  	shl     bx,1
  6944                                  	shl     bx,1
  6945                                  	shl     bx,1
  6946                                  	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  6947                                  	dec     bx			; dec by one to leave room for double 0
  6948                                  	xor     dx,dx			; use dx to indicate that there was
  6949                                  					; no environment size error.
  6950                                  
  6951                                  NXSTR:
  6952                                  	call    GETSTRLEN		; get the size of the current env string
  6953                                  
  6954                                  	push    ds
  6955                                  	push    cs
  6956                                  	pop     ds
  6957                                  	add     [USEDENV],cx		; add the string length to env size
  6958                                  	pop     ds
  6959                                  	cmp     cx,1			; end of environment was encountered.
  6960                                  	je      short ENVEXIT
  6961                                  	sub     bx,cx
  6962                                  	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  6963                                  	inc     dx			; out of env space msg must be displayed
  6964                                  	jmp     short ENVEXIT
  6965                                  
  6966                                  	;nop
  6967                                  
  6968                                  OKCPYSTR:
  6969                                  	jmp     short NXSTR
  6970                                  
  6971                                  ENVEXIT: 
  6972                                  	push    cs
  6973                                  	pop     ds
  6974                                  	or      dx, dx			; dx will be non-zero if error
  6975                                  	jz      short ENVNOERR
  6976                                  	mov     dx,OUTENVMSG		; dx = ptr to msg
  6977                                  	call    RPRINT
  6978                                  
  6979                                  %endif
  6980                                  
  6981                                  	; 21/01/2023
  6982                                  	; MSDOS 6.0 (& MSDOS 5.0)
  6983 00001885 8B1E[3F03]              	mov	bx,[EnvirSeg]			; get old environment segment
  6984 00001889 891E[B31C]              	mov	[OldEnv],bx			; save it
  6985 0000188D C706[B51C]0000          	mov	word [UsedEnv],0		; initialize env size counter
  6986 00001893 8EDB                    	mov	ds,bx
  6987                                  	;assume	ds:nothing
  6988                                  	
  6989 00001895 31F6                    	xor	si,si
  6990 00001897 89F7                    	mov	di,si
  6991                                  
  6992                                  ; This is the maximum allowed size for the environment
  6993                                  
  6994                                  	; 21/01/2023
  6995                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
  6996                                  	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
  6997                                  	;;mov	[ss:EnvMax],bx
  6998                                  	;shl	bx,1
  6999                                  	;shl	bx,1
  7000                                  	;shl	bx,1
  7001                                  	;shl	bx,1
  7002 00001899 BBF0FF                  	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
  7003 0000189C 36891E[B11C]            	mov	[ss:EnvMax], bx			; convert envmax to bytes
  7004 000018A1 4B                      	dec	bx				; dec by one to leave room for double 0
  7005 000018A2 31D2                    	xor	dx,dx				; use dx to indicate that there was
  7006                                  						; no environment size error.
  7007                                  ;public NxtStr
  7008                                  NxtStr:
  7009 000018A4 E82B01                  	call	GetStrLen			; get the size of the current env string
  7010                                  
  7011                                  ;Bugbug: Can use ss here to address UsedEnv
  7012                                  
  7013 000018A7 1E                      	push	ds                              ; get addressability to environment
  7014 000018A8 0E                              push	cs                              ;                       counter
  7015 000018A9 1F                              pop	ds                              ;
  7016                                  	;assume	ds:ResGroup
  7017 000018AA 010E[B51C]                      add	[UsedEnv],cx			; add the string length to env size
  7018 000018AE 1F                      	pop	ds                              ;
  7019                                  	;assume	ds:nothing
  7020                                  	
  7021 000018AF 83F901                  	cmp	cx,1				; end of environment was encountered.
  7022 000018B2 7405                    	je	short EnvExit
  7023 000018B4 29CB                    	sub	bx,cx
  7024                                  	;jae	short OkCpyStr			; can't fit in all of enviroment.
  7025                                  	; 21/01/2023
  7026 000018B6 73EC                    	jae	short NxtStr
  7027 000018B8 42                      	inc	dx				; out of env space msg must be displayed
  7028                                  	;jmp	short EnvExit
  7029                                  
  7030                                  ;OkCpyStr:
  7031                                  	;jmp	short NxtStr
  7032                                  
  7033                                  EnvExit:
  7034 000018B9 0E                      	push	cs
  7035 000018BA 1F                      	pop	ds
  7036                                  	;assume	ds:ResGroup
  7037 000018BB 09D2                    	or	dx,dx				; dx will be non-zero if error
  7038 000018BD 7406                    	jz	short EnvNoErr
  7039                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  7040 000018BF BA[721D]                	mov	dx,OUTENVMSG
  7041 000018C2 E8CCF9                  	call 	RPrint
  7042                                  EnvNoErr:
  7043 000018C5 A1[AF1C]                	mov	ax,[EnvSiz]			; env size previously set
  7044 000018C8 B104                    	mov	cl,4
  7045 000018CA D3E0                    	shl	ax,cl				; get size in bytes
  7046 000018CC 3B06[B51C]              	cmp	ax,[UsedEnv]			; is it a new env?
  7047 000018D0 7706                    	ja	short st_envsize		; yes, store the size
  7048 000018D2 A1[B51C]                	mov	ax,[UsedEnv]
  7049 000018D5 83C00F                  	add	ax,15				; round up
  7050                                  st_envsize:	
  7051 000018D8 D3E8                    	shr	ax,cl
  7052 000018DA A3[AF1C]                	mov	[EnvSiz],ax			; store env size needed(paras)
  7053                                  
  7054                                  ;if MSVER
  7055                                  	;cmp	SingleCom,0
  7056                                  	;jnz	nophead 			; don't print header if SingleCom
  7057                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7058                                  	;call	RPrint
  7059                                  ;nophead:
  7060                                  ;endif
  7061                                  
  7062                                  ; 21/01/2023
  7063                                  %if 0
  7064                                  	; MSDOS 3.3
  7065                                  ENVNOERR:
  7066                                  	mov     cx,[ENVMAX]
  7067                                  	sub     cx,bx			; current environment size in bytes
  7068                                  	add     cx,16			; add memory arena to the size
  7069                                  	shr     cx,1
  7070                                  	shr     cx,1
  7071                                  	shr     cx,1
  7072                                  	shr     cx,1			; convert current env size to paragraphs
  7073                                  	cmp     cx,[ENVSIZ]		; compare with env size previously set
  7074                                  	;jb	short SET_ENVSIZE
  7075                                  	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  7076                                  	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  7077                                  
  7078                                  SET_ENVSIZE:
  7079                                  	mov     bx,[ENVSIZ]
  7080                                  	mov     ax,es
  7081                                  	add     ax,bx			; get end segment of environemnt
  7082                                  	cmp     ax,[INITEND]		; compare with init code end segment
  7083                                  	ja      short NOPHEAD
  7084                                  					; free unused paragraghs		
  7085                                  	mov     ax,es
  7086                                  	mov     bx,[INITEND]
  7087                                  	sub     bx,ax
  7088                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  7089                                  	mov	word [RESETENV],1	; environment segment reset sign
  7090                                  
  7091                                  NOPHEAD:
  7092                                  	; MSDOS 3.3
  7093                                  	mov     ah,SETBLOCK ; 4Ah
  7094                                  	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7095                                  			; ES = segment address of block to change
  7096                                  			; BX = new size in paragraphs
  7097                                  %endif
  7098                                  	; 21/01/2023
  7099                                  
  7100                                  	; MSDOS 3.3 & 6.0
  7101 000018DD 833E[4C01]00            	cmp     word [Batch],0		; did we set up a batch segment?
  7102 000018E2 7503                    	jnz     short DoDate		; yes - go initialize it
  7103 000018E4 E99B00                  	jmp     NoDttm			; don't do autoexec or date time
  7104                                  
  7105                                  DoDate:
  7106                                  
  7107                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  7108                                  
  7109 000018E7 A1[4C01]                	mov	ax,[Batch]		; get batch segment
  7110 000018EA C606[A001]03            	mov	byte [EchoFlag],3	; set batch echo
  7111 000018EF C706[AF01]0100          	mov	word [Nest],1		; set nest flag to 1 batch
  7112 000018F5 8EC0                    	mov	es,ax
  7113                                  
  7114                                  ; initialize the segment
  7115                                  
  7116 000018F7 31FF                    	xor	di,di
  7117                                  	;mov	al,0
  7118 000018F9 B000                    	mov	al,BATCHTYPE ; 0
  7119 000018FB AA                      	stosb
  7120 000018FC B001                    	mov	al,1			; initialize echo for batch exit
  7121 000018FE AA                      	stosb
  7122                                  
  7123                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  7124                                  
  7125 000018FF 31C0                    	xor	ax,ax			; initialize to zero
  7126                                  	; 21/01/2023
  7127 00001901 AA                      	stosb	; MSDOS 6.0 		; clear out BatchEOF
  7128                                  
  7129 00001902 AB                      	stosw				; batch segment of last job - batlast
  7130 00001903 AB                      	stosw				; segment for FOR
  7131 00001904 AA                      	stosb				; FOR flag
  7132 00001905 AB                      	stosw				; position in file - batseek
  7133 00001906 AB                      	stosw
  7134                                  
  7135                                  ; clean out the parameters
  7136                                  
  7137 00001907 B8FFFF                  	mov	ax,-1			; initialize to no parameters
  7138 0000190A B90A00                  	mov	cx,10
  7139 0000190D F3AB                    	rep	stosw
  7140                                  
  7141                                  ; decide whether we should grab the default drive
  7142                                  
  7143 0000190F 803E[751C]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  7144 00001914 7509                    	jne	short NoAutSet
  7145 00001916 B419                    	mov	ah,19h	; 21/01/2023
  7146                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  7147 00001918 CD21                    	int	21h
  7148                                  	;;add	al,'A'
  7149                                  	;add	al,[letter_A] ; Ucasea
  7150                                  	;add	al,[ucasea] ; 21/01/2023
  7151                                  	; 21/01/2023
  7152 0000191A 0441                    	add	al,'A'
  7153 0000191C A2[751C]                	mov	[AUTOBAT],al
  7154                                  	; 21/01/2023
  7155                                  	;mov	[KAUTOBAT],al
  7156                                  NoAutSet:
  7157                                  
  7158                                  ; copy in the batch file name (including nul)
  7159                                  
  7160                                  	;mov	si,offset ResGroup:AutoBat
  7161 0000191F BE[751C]                	mov	si,AUTOBAT
  7162 00001922 B90800                  	mov	cx,8
  7163 00001925 F3A5                    	rep	movsw
  7164                                  	; 23/04/2023
  7165 00001927 A4                      	movsb	; MSDOS 6.0		; move in carriage return to terminate string
  7166                                  
  7167                                  	;mov	dx,offset ResGroup:AutoBat
  7168 00001928 BA[751C]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  7169                                  
  7170                                  	;;mov	ax,OPEN shl 8
  7171 0000192B B8003D                  	mov	ax,3D00h ; 21/01/2023
  7172                                  	;mov	ax,OPEN*256 ; 3D00h  ; open for read
  7173 0000192E CD21                    	int	21h			; see if autoexec.bat exists
  7174 00001930 7208                    	jc	short noabat
  7175 00001932 89C3                    	mov	bx,ax
  7176 00001934 B43E                    	mov	ah,3Eh ; 21/01/2023
  7177                                  	;mov	ah,CLOSE  ; 3Eh
  7178 00001936 CD21                    	int	21h
  7179 00001938 EB55                    	jmp	short Drv0		; go process autoexec
  7180                                  
  7181                                  noabat:
  7182 0000193A 50                      	push	ax
  7183 0000193B E89D00                  	call	Setup_Seg
  7184 0000193E A3[911C]                	mov	[triage_add+2],ax
  7185 00001941 58                      	pop	ax
  7186 00001942 FF1E[8F1C]              	call	far [triage_add]	; get extended error
  7187 00001946 83F841                  	cmp	ax,65			; network access denied?
  7188                                  	;jne	short OPENERR		; no - go deallocate batch
  7189                                  	; 21/01/2023
  7190                                  	;je	short AccDenErr
  7191 00001949 7506                    	jne	short OpenErr 
  7192                                  
  7193                                  	; 21/01/2023
  7194                                  ;_ACCDENERROR:					; yes - put out message
  7195                                  ;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7196                                  ;	mov	dx,ACCDENERR
  7197                                  ;	call	RPRINT
  7198                                  
  7199                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7200                                  
  7201                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7202                                  
  7203                                  ; 21/01/2023
  7204                                  %if 0
  7205                                  
  7206                                  ; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
  7207                                  ; by Ellen to check only when in Korea. The country information
  7208                                  ; returned will overlay the old parse data area, but we don't care
  7209                                  ; since we won't need the parse information or country information.
  7210                                  ; We only care about the country code returned in BX.
  7211                                  
  7212                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h
  7213                                  
  7214                                  	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
  7215                                  	mov	dx,INTERNAT_INFO
  7216                                  	mov	ax,3800h
  7217                                  	;mov	ax,INTERNATIONAL<<8
  7218                                  	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
  7219                                  	int	21h				;
  7220                                  	jc	short NoKabat 			; error - don't bother with it
  7221                                  	cmp	bx,52h
  7222                                  	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
  7223                                  	jnz	short OpenErr 			; no, don't check for kautoexe
  7224                                  
  7225                                  	;mov	di,BatFile			; 3/3/kk
  7226                                  	mov	di,20h
  7227                                  	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
  7228                                  	mov	si,KAUTO.BAT
  7229                                  	mov	cx,8				; auto execution for the 3/3/kk
  7230                                  	rep	movsw				; non-english country	3/3/kk
  7231                                  	movsb					; move in carraige return to terminate string
  7232                                  	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
  7233                                  	mov	dx,KAUTOBAT
  7234                                  	mov	ax,3D00h
  7235                                  	;mov	ax,OPEN<<8
  7236                                  	;;mov	ax,OPEN shl 8			; 3/3/kk
  7237                                  	int	21h				; see if kautoexe.bat exists  3/3/kk
  7238                                  	jc	short NoKabat 			; 3/3/kk
  7239                                  	mov	bx,ax				; 3/3/kk
  7240                                  	mov	ah,3Eh
  7241                                  	;mov	ah,CLOSE			; 3/3/kk
  7242                                  	int	21h				; 3/3/kk
  7243                                  	jmp	short Drv0			; 3/3/kk
  7244                                  
  7245                                  NoKabat:					; 3/3/kk
  7246                                  	call	far [Triage_Add]		; get extended error
  7247                                  	cmp	ax,65				; network access denied?
  7248                                  	jnz	short OpenErr 			; no - go deallocate batch
  7249                                  
  7250                                  %endif
  7251                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7252                                  
  7253                                  AccDenErr:					; yes - put out message
  7254                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7255 0000194B BA[D305]                	mov	dx,ACCDEN
  7256 0000194E E840F9                  	call	RPrint
  7257                                  OpenErr:
  7258                                  ;OPENERR:
  7259 00001951 8E06[4C01]              	mov	es,[Batch]		; not found--turn off batch job
  7260 00001955 B449                    	mov	ah,49h
  7261                                  	;mov	ah,DEALLOC ; 49h
  7262 00001957 CD21                    	int	21h
  7263 00001959 C706[4C01]0000          	mov	word [Batch],0		; after dealloc in case of ^c
  7264 0000195F C606[A001]01            	mov	byte [EchoFlag],1
  7265 00001964 C706[AF01]0000          	mov	word [Nest],0		; indicate no batch in progress
  7266                                  
  7267                                  ;DoDttm:
  7268                                  	;mov	ax,offset TranGroup:Datinit
  7269 0000196A B8[922E]                	mov	ax,DATINIT
  7270 0000196D A3[871C]                	mov	[INITADD],ax
  7271                                  
  7272                                  	; MSDOS 6.0
  7273                                  ;;M004;;mov	ax,TrnSeg	
  7274                                  ;
  7275                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  7276                                  ; M004; the transient starts on a para boundary at the label TranStart.
  7277                                  ; M004; We use TranStart to get the start of the transient segment.
  7278                                  
  7279                                  	; 21/01/2023
  7280                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  7281                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7282 00001970 B84022                  	mov	ax,TRANSTART
  7283 00001973 B104                    	mov	cl,4				; M004
  7284 00001975 D3E8                    	shr	ax,cl				; get relative seg ; M004
  7285 00001977 8CC9                    	mov	cx,cs
  7286 00001979 01C8                    	add	ax,cx				; ax = transient seg ; M004
  7287                                  
  7288                                  	; 21/01/2023
  7289                                  	; MSDOS 3.3
  7290                                  	; 25/09/2018
  7291                                  	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  7292                                  
  7293                                  	; MSDOS 3.3 & MSDOS 6.0
  7294 0000197B A3[891C]                	mov	[INITADD+2],ax
  7295                                  	;call	dword ptr InitAdd
  7296 0000197E FF1E[871C]              	call	far [INITADD]
  7297                                  
  7298                                  NoDttm:
  7299                                  	; MSDOS 6.0
  7300                                  	; 21/01/2023
  7301                                  ;Copyright:
  7302                                  	;public	Copyright
  7303                                  ;	Bugbug:	remove Copyright label.
  7304                                  
  7305                                  ;if IBMVER
  7306 00001982 833E[A601]00            	cmp	word [SingleCom],0
  7307 00001987 7506                    	jnz	short Drv0			; don't print header if SingleCom
  7308                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7309 00001989 BA[8D1D]                	mov	dx,COPYRIGHTMSG
  7310 0000198C E802F9                  	call	RPrint
  7311                                  ;endif
  7312                                  	; 21/01/2023
  7313                                  	; MSDOS 3.3
  7314                                  	;cmp	word [SingleCom],0	; don't print header if SingleCom
  7315                                  	;jnz	short DRV0
  7316                                  	;mov	dx,HEADERPTR	; dx = ptr to msg
  7317                                  	;call	RPRINT
  7318                                  ;DRV0:
  7319                                  	; MSDOS 3.3
  7320                                  	;mov	byte [INITFLAG],0
  7321                                  	;jmp	ENDINIT
  7322                                  
  7323                                  	; 21/01/2023
  7324                                  	; MSDOS 6.0
  7325                                  Drv0:						; Reset APPEND state
  7326 0000198F 1E                      	push	ds				; save data segment
  7327 00001990 0E                      	push	cs				; Get local segment into DS
  7328 00001991 1F                      	pop	ds				;
  7329 00001992 B807B7                  	mov	ax,0B707h ; 21/01/2023
  7330                                  	;mov	ax,APPENDSETSTATE		; Set the state of Append
  7331 00001995 8B1E[C301]              	mov	bx,[Append_State] 		;  back to the original state
  7332 00001999 CD2F                    	int	2Fh				;
  7333 0000199B 1F                      	pop	ds				; get data segment back
  7334                                  
  7335                                  ;Check FirstCom set previously to see if this is the first instance of
  7336                                  ;command.com. If not, we do not move command.com. Instead, we copy over the
  7337                                  ;jump table from the previous stub to the current stub.
  7338                                  
  7339 0000199C 803E[0221]01            	cmp	byte [FirstCom],1		; first command.com?
  7340 000019A1 7429                    	jz	short move_code			; yes, move it
  7341                                  
  7342 000019A3 06                      	push	es
  7343 000019A4 1E                      	push	ds
  7344                                  
  7345 000019A5 1E                      	push	ds
  7346 000019A6 07                      	pop	es
  7347                                  	;mov	di,offset DATARES:Int2f_Entry
  7348 000019A7 BF[0400]                	mov	di,Int2f_Entry	
  7349                                  
  7350 000019AA 268E1E[0021]            	mov	ds,[es:ResJmpTable+2]		; get segment address
  7351 000019AF 268B36[FE20]            	mov	si,[es:ResJmpTable]		; get offset address
  7352                                  
  7353                                  	;mov	cx,11
  7354                                  	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
  7355                                  	;shl	cx,1
  7356                                  	;shl	cx,1				; size of table in bytes
  7357                                  	; 21/01/2023
  7358 000019B4 B92C00                  	mov	cx,44				; size of table in bytes
  7359                                  
  7360 000019B7 FC                      	cld
  7361 000019B8 F3A4                    	rep	movsb				; copy the jump table
  7362                                  
  7363                                  ;Check if the resident code is in HMA. We assume that it is in HMA if its 
  7364                                  ;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  7365                                  
  7366 000019BA 26817DFE00F0            	cmp	word [es:di-2],0F000h		; is resident code in HMA?
  7367 000019C0 7206                    	jb	short res_low			; no, dont set flag
  7368                                  
  7369 000019C2 26C606[3400]01          	mov	byte [es:ComInHMA],1		; indicate code in HMA
  7370                                  res_low:
  7371 000019C8 1F                      	pop	ds
  7372 000019C9 07                      	pop	es
  7373 000019CA EB03                    	jmp	short finish_init
  7374                                  
  7375                                  ;Now, we can move the resident code to its final location, either to HIMEM
  7376                                  ;or to overlay the messages in the data segment if the user has not used the
  7377                                  ;/msg switch.
  7378                                  
  7379                                  move_code:
  7380 000019CC E88E01                  	call	Move_res_code			; move the code
  7381                                  
  7382                                  finish_init:
  7383                                  	;jmp	RESGROUP:EndInit 		; finish initializing
  7384 000019CF E948E8                  	jmp	EndInit
  7385                                  
  7386                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7387                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)
  7388                                  
  7389                                  GetStrLen:
  7390                                  ;	Get length of string pointed to by DS:SI. Length includes NULL.
  7391                                  ;	Length is returned in CX
  7392                                  
  7393                                  	; MSDOS 3.3 & MSDOS 6.0
  7394 000019D2 31C9                    	xor	cx,cx
  7395                                  NxtChar:
  7396 000019D4 AC                      	lodsb
  7397 000019D5 41                      	inc	cx
  7398 000019D6 08C0                    	or	al,al
  7399 000019D8 75FA                    	jnz	short NxtChar
  7400 000019DA C3                      	retn
  7401                                  
  7402                                  	; 29/01/2023
  7403                                  Setup_Seg:
  7404                                  
  7405                                  ; If the transient has been loaded in TranSeg, then we need to use that
  7406                                  ; segment for calls to routines in the transient area. Otherwise, the current
  7407                                  ; code segment is used
  7408                                  ; Segment returned in AX.
  7409                                  
  7410                                  	; MSDOS 3.3 & MSDOS 6.0
  7411 000019DB A1[9201]                	mov	ax,[TrnSeg]
  7412 000019DE 803E[9401]01            	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
  7413 000019E3 7409                    	je	short setup_end
  7414 000019E5 53                      	push	bx
  7415 000019E6 8CCB                    	mov	bx,cs
  7416                                  	;mov	ax,offset ResGroup:TranStart
  7417                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM	
  7418                                  	;mov	ax,TRANSTART
  7419                                  	;shr	ax,1
  7420                                  	;shr	ax,1
  7421                                  	;shr	ax,1
  7422                                  	;shr	ax,1
  7423                                  	; 29/01/2023
  7424 000019E8 B82402                  	mov	ax,TRANSTART>>4
  7425 000019EB 01D8                    	add	ax,bx
  7426 000019ED 5B                      	pop	bx
  7427                                  setup_end:
  7428 000019EE C3                      	retn
  7429                                  
  7430                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7431                                  ;RPRINT:
  7432                                  	; MSDOS 3.3
  7433                                  	;push    ax
  7434                                  	;call    SETUP_SEG
  7435                                  	;mov     [PRINTADD+2], ax
  7436                                  	;;call	dword ptr PRINTADD
  7437                                  	;call	far [PRINTADD]
  7438                                  	;pop     ax
  7439                                  	;retn
  7440                                  
  7441                                  	; 29/01/2023
  7442                                  	; MSDOS 6.0
  7443                                  ;***	RPrintParse - display parse error message
  7444                                  ;
  7445                                  ;	ENTRY	DX = parse error #
  7446                                  ;
  7447                                  ;	EXIT	nothing
  7448                                  ;
  7449                                  ;	USED	flags
  7450                                  ;
  7451                                  ;	EFFECTS
  7452                                  ;	  Message is displayed on stdout.
  7453                                  
  7454                                  RPrintParse:	;proc
  7455                                  	;assume	ds:ResGroup,ss:ResGroup
  7456                                  
  7457 000019EF 52                      	push	dx				; preserve DX
  7458 000019F0 87DA                    	xchg	bx,dx				; bx = parse error #
  7459                                  						; dx = saved BX
  7460 000019F2 4B                      	dec	bx				; bx = parse error index, from 0
  7461 000019F3 D1E3                    	shl	bx,1				; bx = offset in word table
  7462                                  	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  7463 000019F5 8B9F[1609]              	mov	bx,[bx+PARSMSGPTRS]
  7464 000019F9 87DA                    	xchg	bx,dx				; dx = ptr to error msg
  7465                                  						; bx = restored
  7466 000019FB E893F8                  	call	RPrint				; print the message
  7467 000019FE 5A                      	pop	dx				; restore DX
  7468 000019FF C3                      	retn
  7469                                  
  7470                                  ;RPrintParse	endp
  7471                                  
  7472                                  	; 29/01/2023
  7473                                  ;PATHCHRCMPR:
  7474                                  	; MSDOS 3.3
  7475                                  	;push	dx
  7476                                  	;mov	dl,[slash_chr]
  7477                                  	;;cmp	byte [RSWITCHAR],'/'
  7478                                          ;cmp	[RSWITCHAR],dl
  7479                                  	;je	short RNOSLASHT
  7480                                  	;;cmp	al,'/'
  7481                                  	;cmp	al,dl
  7482                                  	;je	short RET41 ; zf = 1 
  7483                                  ;RNOSLASHT:
  7484                                          ;;cmp	al,'\'
  7485                                  	;cmp	al,[bslash_chr]
  7486                                  ;RET41:
  7487                                  	;pop	dx
  7488                                  	;retn
  7489                                  
  7490                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7491                                  IfindE:
  7492                                  	; MSDOS 3.3 & MSDOS 6.0
  7493 00001A00 E80300                  	call	ifind				; find the name
  7494                                  	;jc	short ifind2			; carry means not found
  7495                                  	;jmp	short Iscasb1 			; scan for = sign
  7496                                  	; 29/01/2023
  7497 00001A03 733A                    	jnc	short Iscasb1
  7498                                  ifind2:
  7499 00001A05 C3                      	retn
  7500                                  
  7501                                  	; 29/01/2023
  7502                                  
  7503                                  ; on return of find1, es:di points to beginning of name
  7504                                  
  7505                                  ifind:
  7506 00001A06 FC                      	cld
  7507 00001A07 E82700                  	call	Icount0				; cx = length of name
  7508 00001A0A 8E06[3F03]              	mov	es,[EnvirSeg]
  7509 00001A0E 31FF                    	xor	di,di
  7510                                  ifind1:
  7511 00001A10 51                      	push	cx
  7512 00001A11 56                      	push	si
  7513 00001A12 57                      	push	di
  7514                                  ifind11:
  7515 00001A13 AC                      	lodsb
  7516 00001A14 E83400                  	call	iupconv
  7517 00001A17 47                      	inc	di
  7518 00001A18 263A45FF                	cmp	al,[es:di-1]
  7519 00001A1C 7502                    	jnz	short ifind12
  7520 00001A1E E2F3                    	loop	ifind11
  7521                                  ifind12:
  7522 00001A20 5F                      	pop	di
  7523 00001A21 5E                      	pop	si
  7524 00001A22 59                      	pop	cx
  7525 00001A23 74E0                    	jz	short ifind2
  7526 00001A25 51                      	push	cx
  7527 00001A26 E81A00                  	call	Iscasb2 			; scan for a nul
  7528 00001A29 59                      	pop	cx
  7529                                  	;cmp	byte [es:di],0
  7530                                  	;jnz	short ifind1
  7531                                  	;stc					; indicate not found
  7532 00001A2A 26803D01                	cmp	byte [es:di],1
  7533 00001A2E 73E0                    	jnb	short ifind1
  7534                                  	; cf=1					; indicate not found
  7535                                  ;ifind2:
  7536 00001A30 C3                      	retn
  7537                                  
  7538                                  	; 29/01/2023
  7539                                  Icount0:
  7540 00001A31 1E                      	push	ds
  7541 00001A32 07                      	pop	es
  7542 00001A33 89F7                    	mov	di,si
  7543                                  
  7544 00001A35 57                      	push	di				; count number of chars until "="
  7545 00001A36 E80600                  	call	Iscasb1
  7546                                  	; 25/09/2018
  7547                                  	;jmp	short Icountx
  7548                                  	;push	di				; count number of chars until nul
  7549                                  	;call	Iscasb2
  7550                                  ;Icountx:
  7551 00001A39 59                      	pop	cx
  7552 00001A3A 29CF                    	sub	di,cx
  7553 00001A3C 87F9                    	xchg	di,cx
  7554 00001A3E C3                      	retn
  7555                                  
  7556                                  Iscasb1:
  7557                                  	; 29/01/2023
  7558 00001A3F B03D                    	mov	al,"="
  7559                                  	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
  7560 00001A41 EB02                    	jmp	short Iscasbx
  7561                                  Iscasb2:
  7562 00001A43 30C0                    	xor	al,al				; scan for a nul
  7563                                  Iscasbx:
  7564 00001A45 B90001                  	mov	cx,256 ; 100h
  7565 00001A48 F2AE                    	repnz	scasb
  7566 00001A4A C3                      	retn
  7567                                  
  7568                                  	; 29/01/2023
  7569                                  ;IUPCONV:
  7570                                  	; MSDOS 3.3
  7571                                          ;;cmp	al,"a"
  7572                                  	;cmp	al,[letter_a]
  7573                                          ;jb	short IRET22
  7574                                          ;;cmp	al,"z"
  7575                                          ;cmp	al,[letter_z]
  7576                                  	;ja	short IRET22
  7577                                          ;sub	al,20h			; Lower-case changed to upper-case
  7578                                  ;IRET22:
  7579                                  	;retn
  7580                                  
  7581                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7582                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h
  7583                                  
  7584                                  	; MSDOS 6.0
  7585                                  ; *****************************************************************
  7586                                  ; *
  7587                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  7588                                  ; *
  7589                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7590                                  ; *		 the character in AL from the file upper case table
  7591                                  ; *		 in DOS if character if above ascii 128, else
  7592                                  ; *		 subtracts 20H if between "a" and "z".
  7593                                  ; *
  7594                                  ; * INPUT:	 DS	      set to resident
  7595                                  ; *		 AL	      char to be upper cased
  7596                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7597                                  ; *
  7598                                  ; * OUTPUT:	 AL	      upper cased character
  7599                                  ; *
  7600                                  ; *****************************************************************
  7601                                  
  7602                                  iupconv:	;proc	near				
  7603                                  	;assume	ds:ResGroup			;
  7604                                  
  7605 00001A4B 3C80                    	cmp	al,80h				; see if char is > ascii 128
  7606 00001A4D 7210                    	jb	short other_fucase		; no - upper case math
  7607 00001A4F 2C80                    	sub	al,80h				; only upper 128 chars in table
  7608 00001A51 1E                      	push	ds				;
  7609 00001A52 53                      	push	bx				;
  7610                                  	;lds	bx,dword ptr FUCase_Addr+1	; get table address
  7611 00001A53 C51E[B701]              	lds     bx,[FUCase_Addr+1]
  7612 00001A57 83C302                  	add	bx,2				; skip over first word
  7613                                  	;xlat	ds:byte ptr [bx]		; convert to upper case
  7614 00001A5A D7                      	xlat
  7615 00001A5B 5B                      	pop	bx				;
  7616 00001A5C 1F                      	pop	ds				;
  7617 00001A5D EB0A                    	jmp	short iupconv_end		; we finished - exit
  7618                                  
  7619                                  other_fucase:					;
  7620                                  	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
  7621 00001A5F 3C61                    	cmp	al,'a'
  7622 00001A61 7206                    	jb	short iupconv_end		;     subtract 20h to get
  7623                                  	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
  7624 00001A63 3C7A                    	cmp	al,'z'
  7625 00001A65 7702                    	ja	short iupconv_end		;
  7626 00001A67 2C20                    	sub	al,20h				; Change lower-case to upper
  7627                                  iupconv_end:					;
  7628 00001A69 C3                      	retn
  7629                                  
  7630                                  ;iupConv endp
  7631                                  
  7632                                  	; 29/01/2023
  7633                                  init_contc_specialcase:
  7634                                  	; MSDOS 3.3 & MSDOS 6.0
  7635                                  						; This routine is called if control-C
  7636 00001A6A 83C406                  	add	sp,6				;  is type during the date/time prompt
  7637 00001A6D 56                      	push	si				;  at initialization time.  The desired
  7638 00001A6E 89D6                    	mov	si,dx				;  response is to make it look like the
  7639 00001A70 C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  7640 00001A75 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  7641 00001A76 CF                      	iret					;  a <CR> in the user's buffer, and
  7642                                  						;  returning directly to the user.
  7643                                  						; In this case the user is TCODE.
  7644                                  
  7645                                  ; ----------------------------------------------------------------------------
  7646                                  
  7647                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7648                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)
  7649                                  
  7650                                  	; MSDOS 6.0
  7651                                  ; ****************************************************************
  7652                                  ; *
  7653                                  ; * ROUTINE:	 Setup_for_messages
  7654                                  ; *
  7655                                  ; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
  7656                                  ; *		 messages as follows:
  7657                                  ; *
  7658                                  ; *		 IF /P and /MSG are entered
  7659                                  ; *		    keep PARSE and EXTENDED ERRORS in memory
  7660                                  ; *		 ELSE IF /P is entered
  7661                                  ; *		    use PARSE and EXTENDED ERRORS on disk
  7662                                  ; *		    remove PARSE ERRORS from memory
  7663                                  ; *		 ELSE
  7664                                  ; *		    remove PARSE ERRORS from memory
  7665                                  ; *		 ENDIF
  7666                                  ; *
  7667                                  ; * INPUT:	 PERMCOM	Set up with user input
  7668                                  ; *		 EXT_MSG	Set up with user input
  7669                                  ; *		 System set up to retain PARSE ERRORS
  7670                                  ; *
  7671                                  ; * OUTPUT:	 registers unchanged
  7672                                  ; *
  7673                                  ; ****************************************************************
  7674                                  
  7675                                  setup_for_messages: ;proc near		
  7676                                  
  7677 00001A77 53                      	push	bx
  7678 00001A78 1E                      	push	ds				; save data segment
  7679 00001A79 06                      	push	es				; save environment segment
  7680 00001A7A 50                      	push	ax				;
  7681 00001A7B 52                      	push	dx				;
  7682 00001A7C 57                      	push	di				;
  7683 00001A7D 8CC8                    	mov	ax,cs				; get local segment to ES and DS
  7684 00001A7F 8ED8                    	mov	ds,ax				;
  7685 00001A81 8EC0                    	mov	es,ax				;
  7686                                  
  7687 00001A83 803E[A501]00            	cmp	byte [PermCom],0		; was permcom set?
  7688 00001A88 743C                    	jz	short no_permcom		; No - don't worry about messages
  7689                                  
  7690                                  ;*	We're permanent. Install our message services int 2f handler.
  7691                                  
  7692 00001A8A 06                      	push	es
  7693                                  	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
  7694 00001A8B B82F35                  	mov	ax,352Fh
  7695 00001A8E CD21                    	int	21h
  7696                                  			; DOS - 2+ - GET INTERRUPT VECTOR
  7697                                  			; AL = interrupt number
  7698                                  			; Return: ES:BX = value of interrupt vector
  7699 00001A90 891E[B303]              	mov	[Int2fHandler],bx
  7700 00001A94 8C06[B503]              	mov	[Int2fHandler+2],es
  7701 00001A98 07                      	pop	es
  7702                                  
  7703                                  ;	DS = RESGROUP seg addr
  7704                                  
  7705                                  ; M005; We will not hook int 2fh on any command.com other than the first.
  7706                                  ; M005; Carousel loads as a permanent command.com and when we exit Carousel,
  7707                                  ; M005; it just wipes our arena out. So, int 2fh is still hooked and the
  7708                                  ; M005; first int 2fh call after exit from Carousel (from the DOS terminate
  7709                                  ; M005; call) goes off into space.
  7710                                  
  7711 00001A99 803E[0221]00            	cmp	byte [FirstCom],0		; M005
  7712 00001A9E 7416                    	je	short no_msg_hook		; M005
  7713                                  ;
  7714                                  ; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
  7715                                  ; M005; Carousel plays around with the interrupt vector tables. He saves it
  7716                                  ; M005; before loading a new command.com. Then, it takes hold of the current
  7717                                  ; M005; command.com's PSP and then looks at all interrupt vectors whose
  7718                                  ; M005; segment matches the command.com PSP and then updates these segments
  7719                                  ; M005; to the new command.com's PSP in his saved vector table. Whenever we
  7720                                  ; M005; we pop into his menu, he puts this saved table into the vector table.
  7721                                  ; M005; If we now quit, Carousel just wipes out command.com's arena and then
  7722                                  ; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
  7723                                  ; M005; the command.com that was wiped out and so the next int 2fh call will
  7724                                  ; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
  7725                                  ; M005; renormalize our int 2fh pointer so that its cs is not the same as the
  7726                                  ; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
  7727                                  ; M005; remains nice and happy. The renormalized pointer points at a far 
  7728                                  ; M005; jump to the actual int 2fh entry point.
  7729                                  ;
  7730 00001AA0 1E                      	push	ds				; M005
  7731                                  	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
  7732 00001AA1 BA[AF00]                	mov     dx,Carousel_i2f_Hook
  7733 00001AA4 83EA10                  	sub	dx,10h				; renormalize offset; M005
  7734 00001AA7 8CD8                    	mov	ax,ds				; M005
  7735 00001AA9 40                      	inc	ax				; Relocated cs ; M005
  7736 00001AAA 8ED8                    	mov	ds,ax				; M005
  7737                                  	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
  7738 00001AAC B82F25                  	mov	ax,252Fh
  7739 00001AAF CD21                    	int	21h
  7740                                  			; DOS - SET INTERRUPT VECTOR
  7741                                  			; AL = interrupt number
  7742                                  			; DS:DX = new vector to be used for specified interrupt
  7743 00001AB1 1F                      	pop	ds				; M005
  7744                                  	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
  7745 00001AB2 8C1E[B200]              	mov	[Carousel_i2f_Hook+3],ds
  7746                                  						; patch in the cs for jump
  7747                                  no_msg_hook:					; M005
  7748 00001AB6 803E[C31C]01            	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
  7749 00001ABB 7516                    	jne	short permcom_end		; no /msg - exit
  7750                                  
  7751                                  permcom_slash_msg:				; Keep messages in memory
  7752                                  	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
  7753 00001ABD BF[0F0C]                	mov     di,ExtMsgEnd
  7754 00001AC0 893E[B703]              	mov	[ResMsgEnd],di			; save it
  7755 00001AC4 EB0D                    	jmp	short permcom_end		; exit
  7756                                  
  7757                                  no_permcom:					
  7758                                  	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
  7759 00001AC6 803E[C31C]01            	cmp	byte [ext_msg],1
  7760 00001ACB 7506                    	jne	short permcom_end		; no - no error
  7761                                  	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
  7762 00001ACD BA0200                  	mov	dx,2
  7763 00001AD0 E81CFF                  	call	RPrintParse
  7764                                  
  7765                                  permcom_end:
  7766 00001AD3 5F                      	pop	di				;
  7767 00001AD4 5A                      	pop	dx				;
  7768 00001AD5 58                      	pop	ax				;
  7769 00001AD6 07                      	pop	es				; get environment back
  7770 00001AD7 1F                      	pop	ds				;
  7771 00001AD8 5B                      	pop	bx
  7772                                  
  7773 00001AD9 C3                      	retn					;
  7774                                  
  7775                                  ;setup_for_messages	endp
  7776                                  
  7777                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7778                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h
  7779                                  
  7780                                  	; MSDOS 6.0
  7781                                  
  7782                                  ;***	CheckHelp - print help text and exit if /? is on command line
  7783                                  ;
  7784                                  ;	ENTRY	command-line tail at 81h
  7785                                  ;
  7786                                  ;	EXIT	return if /? not found
  7787                                  ;		terminate if /? found
  7788                                  ;
  7789                                  ;	USED	AX,BX,CX,DX,SI,DI
  7790                                  ;
  7791                                  ;	EFFECTS	Help text displayed if /? found on command line
  7792                                  
  7793                                  CheckHelp:	; proc
  7794                                  	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP
  7795                                  
  7796 00001ADA BE8100                  	mov	si,81h			; DS:SI = ptr to command-line tail
  7797                                  	;mov	di,offset RESGROUP:Parse_Command
  7798 00001ADD BF[C81C]                	mov	di,PARSE_COMMAND
  7799                                  					; ES:DI = ptr to primary parse block
  7800 00001AE0 31C9                    	xor	cx,cx			; CX = # positional param's found
  7801 00001AE2 31D2                    	xor	dx,dx			; DX will be ptr to result buffer
  7802                                  chParse:
  7803                                  	;call	dword ptr Init_Parse
  7804 00001AE4 FF1E[BB1C]              	call	far [Init_Parse]	; call system parser
  7805                                  
  7806                                  	;cmp	ax,END_OF_LINE
  7807 00001AE8 83F8FF                  	cmp	ax, -1 ; 0FFFFh	
  7808 00001AEB 7414                    	je	short chRet		; end of command line, no /? found
  7809                                  	;cmp	ax,RESULT_NO_ERROR
  7810                                  	;cmp	ax,0
  7811                                  	;je	short chWhich		; valid syntax element found
  7812                                  	;jmp	short chParse		; go parse more
  7813 00001AED 21C0                    	and	ax,ax ; cmp ax,0
  7814 00001AEF 75F3                    	jnz	short chParse ; jne 
  7815                                  chWhich:
  7816                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
  7817 00001AF1 813E[4F1D][4A1D]        	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
  7818 00001AF7 7409                    	je	short chHelp		; /? found - display help & exit
  7819                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
  7820 00001AF9 813E[4F1D][301D]        	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
  7821                                  	;je	short chRet		; /c found - ignore rest of line
  7822                                  	; 29/01/2023
  7823 00001AFF 75E3                    	jne	short chParse
  7824                                  	; MSDOS 6.0
  7825                                          ;;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
  7826                                        	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
  7827                                  	;je	short chRet		; /k found - ignore rest of line
  7828                                  	;jmp	short chParse		; anything else - ignore, keep looking
  7829                                  chRet:
  7830 00001B01 C3                      	retn
  7831                                  chHelp:
  7832                                  	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
  7833 00001B02 BE[D420]                	mov	si,HelpMsgs
  7834                                  chHelpNext:
  7835 00001B05 AD                      	lodsw					; AX = ptr to msg
  7836 00001B06 09C0                    	or	ax,ax
  7837 00001B08 7407                    	jz	short chHelpDone		; end of list - all done
  7838 00001B0A 89C2                    	mov	dx,ax				; DX = ptr to msg
  7839 00001B0C E882F7                  	call	RPrint				; display msg
  7840 00001B0F EBF4                    	jmp	short chHelpNext		; go do next msg
  7841                                  
  7842                                  chHelpDone:
  7843 00001B11 CD20                    	int	20h				; terminate program
  7844                                  ;chRet:
  7845 00001B13 C3                      	retn
  7846                                  
  7847                                  ;CheckHelp	endp
  7848                                  
  7849                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7850                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h
  7851                                  
  7852                                  	; MSDOS 6.0
  7853                                  
  7854                                  ;***** Setup_res_end -- This routine determines the resident size of COMMAND.
  7855                                  ;
  7856                                  ; It determines based on 2 factors:
  7857                                  ;	1. Is this is the first COMMAND?
  7858                                  ;	2. Is COMMAND to be loaded into HIMEM?
  7859                                  ;   The strategy works as follows:
  7860                                  ;
  7861                                  ;	if (First COMMAND)
  7862                                  ;	then if (COMMAND in HIMEM)
  7863                                  ;		ResSize = resident_data;
  7864                                  ;	     else
  7865                                  ;		ResSize = resident_data + resident_code;
  7866                                  ;	else
  7867                                  ;	   ResSize = resident_data;
  7868                                  ;
  7869                                  ; Int 2fh calls have been added to determine whether or not we are the first
  7870                                  ; COMMAND and whether DOS is in HIMEM.
  7871                                  ;
  7872                                  ;	ENTRY: ResMsgEnd = resident size of data in paras
  7873                                  ;
  7874                                  ;	EXIT:  ResSize = resident size in low memory
  7875                                  ;
  7876                                  ;	REGISTERS AFFECTED: ax,cx,dx
  7877                                  ;
  7878                                  
  7879                                  GET_HMA_ADDR	equ	4A02h
  7880                                  
  7881                                  Setup_res_end:	;proc near
  7882                                  	
  7883 00001B14 1E                      	push	ds
  7884 00001B15 8CC8                    	mov	ax,cs
  7885 00001B17 8ED8                    	mov	ds,ax				;ds = RESGROUP
  7886                                  	;assume	ds:RESGROUP
  7887                                  
  7888 00001B19 8B0E[B703]              	mov	cx,[ResMsgEnd]			;set resident size = data
  7889                                  
  7890                                  ;ifndef	ROMDOS
  7891                                  
  7892                                  ;M042 -- Begin changes
  7893                                  ;If messages are to be kept behind, we need to round up the messages to
  7894                                  ;the next para boundary. This is because we have a dummy segment between the
  7895                                  ;data and the resident code segment so that the code segment starts on a
  7896                                  ;para boundary
  7897                                  
  7898                                  	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
  7899 00001B1D 81F9[0F0C]              	cmp	cx,ExtMsgEnd
  7900 00001B21 7506                    	jne	short calc_res			;no, continue
  7901 00001B23 83C10F                  	add	cx,15				;round up
  7902 00001B26 83E1F0                  	and	cx,0FFF0h
  7903                                  calc_res:
  7904                                  
  7905                                  ;M042 -- End changes
  7906                                  
  7907 00001B29 31C0                    	xor	ax,ax
  7908 00001B2B 803E[0221]01                   	cmp	byte [FirstCom],1		;is it first command.com?
  7909 00001B30 7518                    	jne	short not_first			;no, do not keep code
  7910                                  
  7911                                  ;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
  7912                                  ;bit 4 of dh is set
  7913                                  
  7914 00001B32 53                      	push	bx
  7915 00001B33 51                      	push	cx
  7916                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
  7917 00001B34 B80633                  	mov	ax,3306h
  7918 00001B37 CD21                    	int	21h
  7919                                  		; DOS - 5+ Get TRUE Version Number
  7920                                  		; (BL major, BH minor, DL revision, DH flags)
  7921 00001B39 59                      	pop	cx
  7922                                  
  7923                                  ;bugbug: remove version check after testing
  7924                                  
  7925 00001B3A 80FB05                  	cmp	bl,5				;bl has true version ; M013
  7926 00001B3D 7207                    	jb	short oldver
  7927                                  
  7928 00001B3F 31C0                    	xor	ax,ax
  7929 00001B41 80E610                  	and	dh,10h				;is DOS in HMA ; M013
  7930                                  	;pop	bx
  7931                                  	;jnz	short not_first			;DOS in HIMEM, code not
  7932                                  						;	resident
  7933                                  	; 29/01/2023
  7934 00001B44 7503                    	jnz	short not_first_pop
  7935                                  oldver:
  7936                                  	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  7937                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  7938                                  	; 29/01/2023
  7939                                  	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
  7940                                  	; 03/05/2023
  7941 00001B46 B8(0509)                	mov	ax,EndCode-RCODE_START
  7942                                  
  7943                                  not_first_pop:
  7944                                  	; 29/01/2023
  7945 00001B49 5B                      	pop	bx
  7946                                  
  7947                                  not_first:
  7948                                  
  7949                                  ;Note that ax = 0(side effect of int 2fh), if the code is not to be retained
  7950                                  
  7951 00001B4A 01C1                    	add	cx,ax
  7952                                  
  7953                                  ;endif	;not ROMDOS
  7954                                  
  7955 00001B4C 83C10F                  	add	cx,15				;round up to next para
  7956 00001B4F D1E9                    	shr	cx,1
  7957 00001B51 D1E9                    	shr	cx,1
  7958 00001B53 D1E9                    	shr	cx,1
  7959 00001B55 D1E9                    	shr	cx,1				;ax = para size of res code
  7960 00001B57 890E[B903]              	mov	[ResSize],cx			;store resident size
  7961                                  
  7962 00001B5B 1F                      	pop	ds
  7963                                  	;assume	ds:nothing
  7964 00001B5C C3                      	retn
  7965                                  
  7966                                  ;ifndef	ROMDOS
  7967                                  
  7968                                  ;bugbug: remove this code (for version independent COMMAND) after testing
  7969                                  
  7970                                  	; 29/01/2023
  7971                                  ;oldver:
  7972                                  ;	pop	bx
  7973                                  ;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  7974                                  ;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  7975                                  ;	; 29/01/2023
  7976                                  ;	mov	ax,EndCode-RCODE_START
  7977                                  ;	jmp	short not_first
  7978                                  
  7979                                  ;endif	;not ROMDOS
  7980                                  
  7981                                  ;setup_res_end	endp
  7982                                  
  7983                                  ;ifndef	ROMDOS
  7984                                  
  7985                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7986                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  7987                                  
  7988                                  	; MSDOS 6.0
  7989                                  ;*** Move_res_code -- This routine moves the resident code to its final 
  7990                                  ; location. We check if DOS is in HIMEM. If so, we try to load ourselves
  7991                                  ; in HIMEM. If we fail, then we remain low and update ResSize to reflect
  7992                                  ; the correct resident size. When remaining low, we have to check if we 
  7993                                  ; need to overlay the messages part of the data segment which is determined
  7994                                  ; by the /msg switch.
  7995                                  ;
  7996                                  ;	ENTRY: ResMsgEnd = end of resident data
  7997                                  ;
  7998                                  ;	EXIT:  The resident code is either up high or in its final location
  7999                                  ;		down low.
  8000                                  ;
  8001                                  ;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
  8002                                  	
  8003                                  Move_res_code:	;proc near
  8004                                  
  8005 00001B5D 1E                      	push	ds
  8006 00001B5E 06                      	push	es
  8007                                  
  8008 00001B5F 8CC8                    	mov	ax,cs
  8009 00001B61 8ED8                    	mov	ds,ax
  8010                                  	;assume	ds:RESGROUP
  8011                                  
  8012                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
  8013 00001B63 B80633                  	mov	ax,3306h
  8014 00001B66 CD21                    	int	21h				;DOS in HIMEM?
  8015                                  		; DOS - 5+ Get TRUE Version Number
  8016                                  		; (BL major, BH minor, DL revision, DH flags)
  8017                                  
  8018 00001B68 80E610                  	and	dh,10h				; M013
  8019 00001B6B 750E                    	jnz	short move_high			;yes, move code high
  8020                                  
  8021                                  ;Check if messages have been discarded or not
  8022                                  
  8023                                  load_low:
  8024 00001B6D 1E                      	push	ds
  8025 00001B6E 07                      	pop	es				;es = RESGROUP
  8026 00001B6F 8B3E[B703]              	mov	di,[ResMsgEnd]			;end offset in DATARES
  8027                                  	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
  8028                                  	;mov	bx,ExtMsgEnd
  8029                                  	; 29/01/2023
  8030 00001B73 81FF[0F0C]              	cmp	di,ExtMsgEnd
  8031                                  	;cmp	di,bx				;are messages to be kept?
  8032 00001B77 7431                    	je	short no_move			;yes, dont move code
  8033                                  
  8034 00001B79 EB37                    	jmp	short setup_move		;es:di points at dest.
  8035                                  
  8036                                  move_high:
  8037                                  
  8038                                  ;We have to call DOS to get the load address in HIMEM for COMMAND
  8039                                  ;We pass in bx the number of bytes we need
  8040                                  
  8041                                  	;mov	bx,offset CODERES:EndCode
  8042                                  	; 29/01/2023
  8043                                  	;;mov	bx,81Ah ; MSDOS 5.0 COMMAND.COM
  8044                                  	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8045                                  	; 03/05/2023
  8046 00001B7B BB(0509)                	mov	bx,EndCode-RCODE_START
  8047                                  
  8048                                  ;M030;
  8049                                  ; Set di=0ffffh so that we load low in case no one answers this int 2fh
  8050                                  
  8051 00001B7E BFFFFF                  	mov	di,0FFFFh			;DT - in case no-one handles
  8052                                  						;this ; M030
  8053 00001B81 B8024A                  	mov	ax,GET_HMA_ADDR ; 4A02h
  8054 00001B84 CD2F                    	int	2Fh
  8055                                  
  8056                                  ;If the offset = 0xffff, then no HMA available
  8057                                  
  8058 00001B86 83FFFF                  	cmp	di,0FFFFh			;HMA available?
  8059 00001B89 C606[3400]01            	mov	byte [ComInHMA],1		;assume command.com in HMA
  8060 00001B8E 7522                    	jne	short setup_move		;no error, es:di = memory
  8061                                  
  8062                                  	;mov	byte [ComInHMA],0		;could not load in HMA
  8063                                  	; 29/01/2023	
  8064 00001B90 FE0E[3400]              	dec	byte [ComInHMA] ; 1 -> 0
  8065                                  
  8066                                  ;Zero means that we do not have enough HIMEM. Remain low and update
  8067                                  ;ResSize to reflect this
  8068                                  
  8069 00001B94 8B0E[B703]              	mov	cx,[ResMsgEnd]			;size of data in bytes
  8070                                  	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8071                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8072                                  	;mov	ax,EndCode-RCODE_START
  8073                                  	;add	cx,ax
  8074                                  	; 29/01/2023
  8075                                  	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 
  8076                                  	;;add	cx,15				;round up to next para
  8077                                  	; 03/05/2023
  8078 00001B98 81C1(1409)              	add	cx,(EndCode-RCODE_START)+15
  8079 00001B9C D1E9                    	shr	cx,1
  8080 00001B9E D1E9                    	shr	cx,1
  8081 00001BA0 D1E9                    	shr	cx,1
  8082 00001BA2 D1E9                    	shr	cx,1				;ax = para size of res code
  8083 00001BA4 890E[B903]              	mov	[ResSize],cx			;store resident size
  8084 00001BA8 EBC3                    	jmp	short load_low			;let code remain low
  8085                                  
  8086                                  no_move:
  8087                                  	; 05/05/2023
  8088                                  	;mov	cl,4
  8089 00001BAA 83C70F                  	add	di,0Fh
  8090 00001BAD 83E7F0                  	and	di,0FFF0h			;round it to a para offset
  8091 00001BB0 EB0B                    	jmp	short patch_up
  8092                                  
  8093                                  setup_move:
  8094                                  	;mov	si,offset RESGROUP:StartCode
  8095                                  	; 03/05/2023
  8096 00001BB2 BE[100C]                	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
  8097                                  				; 0D40h for MSDOS 5.0 COMMAND.COM
  8098                                  	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
  8099                                  	;;mov	cx,81Ah ; MSDOS 5.0 COMMAND.COM
  8100                                  	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8101                                  	; 03/05/2023
  8102 00001BB5 B9(0509)                	mov	cx,EndCode-RCODE_START
  8103                                  
  8104 00001BB8 FC                      	cld
  8105 00001BB9 57                      	push	di				;need di for patching offset
  8106 00001BBA F3A4                    	rep	movsb
  8107 00001BBC 5F                      	pop	di
  8108                                  
  8109                                  patch_up:
  8110 00001BBD E84200                  	call	patch_stub
  8111 00001BC0 07                      	pop	es
  8112 00001BC1 1F                      	pop	ds
  8113                                  	;assume	ds:nothing
  8114 00001BC2 C3                      	retn
  8115                                  
  8116                                  ;Move_res_code endp
  8117                                  
  8118                                  ;else	;ROMDOS
  8119                                  ;
  8120                                  ;;***	Move_res_code - ROMDOS version - locate ROM resident
  8121                                  ;
  8122                                  ;Move_res_code	proc
  8123                                  ;
  8124                                  ;	push	es
  8125                                  ;
  8126                                  ;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
  8127                                  ;	call	patch_stub
  8128                                  ;
  8129                                  ;	pop	es
  8130                                  ;	ret
  8131                                  ;
  8132                                  ;Move_res_code	endp
  8133                                  ;
  8134                                  ;	assume	ds:NOTHING		; to match ending assume above
  8135                                  ;
  8136                                  ;endif	;ROMDOS
  8137                                  
  8138                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8139                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8140                                  
  8141                                  	; MSDOS 6.0
  8142                                  ;*** Alloc_env -- This routine allocates the temporary environment for the
  8143                                  ; Init code to initialize the COMSPEC. This is not a complete environment. 
  8144                                  ; Later on, at EndInit time, a proper sized environment is allocated and
  8145                                  ; the contents of this temporary environment are copied to it. This routine
  8146                                  ; will not be called in case a valid environment is passed to command.com
  8147                                  ;
  8148                                  ;       ENTRY:  FirstCom and initial EnvirSeg set
  8149                                  ;
  8150                                  ;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
  8151                                  ;
  8152                                  ;       REGISTERS AFFECTED: ax,bx,cx,dx
  8153                                  
  8154                                  alloc_env:	;proc near
  8155                                  	;assume ds:nothing
  8156                                  	
  8157 00001BC3 1E                              push    ds
  8158 00001BC4 06                      	push	es
  8159 00001BC5 56                      	push	si
  8160 00001BC6 57                      	push	di
  8161                                  
  8162                                  ; 29/01/2023 - MSDOS 6.0 COMMAND.COM
  8163                                  %if 0
  8164                                          push    ss
  8165                                          pop     ds
  8166                                  	;assume ds:RESGROUP
  8167                                  
  8168                                          mov     ax,[EnvirSeg]
  8169                                  
  8170                                          cmp	byte [AllocedEnv],0
  8171                                          je	short alloc_cont
  8172                                          jmp     alloc_done
  8173                                  
  8174                                  alloc_cont:
  8175                                          sub     di,di                           ; default start
  8176                                          ;mov	bx,SIZE Environment             ; default size needed
  8177                                  	; 29/01/2023
  8178                                  	mov	bx,ENVIRONSIZ
  8179                                  
  8180                                          cmp	byte [FirstCom],0		; first COMMAND.COM?
  8181                                          je	short alloc_seg			; no
  8182                                  
  8183                                  ;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
  8184                                  ;   Record their respective locations and do not add the default vars.
  8185                                  
  8186                                  	or      ax,ax
  8187                                  	jz	short alloc_new			; no previous environment
  8188                                  
  8189                                          mov     es,ax
  8190                                  	;assume es:nothing
  8191                                  
  8192                                  _find_path:
  8193                                          mov     al,0
  8194                                          sub     di,di
  8195                                  comp_path:
  8196                                          scasb                                   ; end of env?
  8197                                  	je	short _find_prompt		; yes
  8198                                          dec     di
  8199                                          mov     cx,PathStrLen ; mov cx,5 ; "PATH="
  8200                                          ;mov	si,offset RESGROUP:PathString
  8201                                  	mov	si,PathString	
  8202                                          repe    cmpsb
  8203                                          je	short got_path
  8204                                          mov	cx,256
  8205                                          repne   scasb                           ; find next NULL
  8206                                          jmp     short comp_path
  8207                                  
  8208                                  got_path:
  8209                                          mov	byte [PathString],0		; don't add it
  8210                                  
  8211                                  _find_prompt:
  8212                                          sub     di,di
  8213                                  comp_prompt:
  8214                                  	scasb                                   ; end of env?
  8215                                  	je	short find_comspec		; yes
  8216                                  	dec     di
  8217                                  	mov     cx,PrmptStrLen2 ; mov cx,7
  8218                                  	;mov	si,offset RESGROUP:PrmptString
  8219                                  	mov	si,PrmptString
  8220                                          repe    cmpsb
  8221                                          je	short got_prompt
  8222                                          mov     cx,256
  8223                                          repne   scasb                           ; find next NULL
  8224                                          jmp	short comp_prompt
  8225                                  
  8226                                  got_prompt:
  8227                                  	mov	byte [PrmptString],0		; don't add it
  8228                                  
  8229                                  find_comspec:
  8230                                          sub     di,di
  8231                                  comp_comspec:
  8232                                          scasb                                   ; end of env?
  8233                                          je	short got_envend		; yes
  8234                                          dec     di
  8235                                          mov	cx,ComspStrLen ; mov cx,8
  8236                                  	;mov	si,offset RESGROUP:ComspString
  8237                                  	mov	si,ComspString
  8238                                          repe    cmpsb
  8239                                          je	short got_comspec
  8240                                          mov     cx,256
  8241                                          repne   scasb                           ; find next NULL
  8242                                          jmp	short comp_comspec
  8243                                  
  8244                                  got_comspec:
  8245                                          mov     [ComspOffset],di
  8246                                  
  8247                                  find_envend:
  8248                                          sub     di,di
  8249                                          mov     cx,ENVBIG                       ; max env size
  8250                                  comp_envend:
  8251                                          dec     cx                              ;
  8252                                          scasb                                   ; end of env?
  8253                                          je	short got_envend		; yes
  8254                                          repne   scasb
  8255                                          jmp	short comp_envend
  8256                                  
  8257                                  got_envend:
  8258                                          dec     di
  8259                                          lea     bx,[di+SIZE Environment]        ; add room for the basics
  8260                                  
  8261                                  ;   We want to fall through to alloc_new and set up default
  8262                                  ;   path and prompt ONLY IF this is the first process;  in all other
  8263                                  ;   cases, we assume it is a bad idea to try editing the user's environment
  8264                                  
  8265                                          push    ds
  8266                                          ;mov	ds,ds:[PDB_Parent_Pid]
  8267                                          mov	ds,[PDB.PARENT_PID]
  8268                                  	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
  8269                                  	cmp	word [PDB.PARENT_PID],0
  8270                                  	pop     ds
  8271                                          jne	short alloc_seg			; no, we're not the first process
  8272                                                                                  ; so don't muck with the env.
  8273                                  alloc_new:
  8274                                  	inc	byte [AllocedEnv]		; note we have virgin env.
  8275                                  
  8276                                  alloc_seg:
  8277                                  
  8278                                  ; Allocate default environment size
  8279                                  
  8280                                          mov     cx,bx                           ; save byte-granular size in CX
  8281                                          add     bx,15
  8282                                          shr     bx,1
  8283                                          shr     bx,1
  8284                                          shr     bx,1
  8285                                          shr     bx,1                            ; BX = # paras
  8286                                  	mov	ah,ALLOC
  8287                                  	int	21h
  8288                                          jnc	short init_ok
  8289                                          jmp     init_nomem                      ; insufficient memory, error
  8290                                  
  8291                                  ; If a previous environment existed (ie, DI != 0), then copy it into
  8292                                  ; the new buffer
  8293                                  
  8294                                  init_ok:
  8295                                  	mov	es,ax
  8296                                  	;assume	es:nothing                      ; es = temp env segment
  8297                                  
  8298                                  	or      di,di
  8299                                          jz	short copy_path
  8300                                  
  8301                                          push    cx
  8302                                          push    ds
  8303                                          mov     ds,[EnvirSeg]
  8304                                          ;assume ds:nothing
  8305                                          sub     si,si
  8306                                          mov     cx,di
  8307                                          sub     di,di
  8308                                          rep     movsb
  8309                                          pop     ds
  8310                                          ;assume ds:RESGROUP
  8311                                          pop     cx
  8312                                          sub     cx,di
  8313                                  
  8314                                  copy_path:
  8315                                  
  8316                                  ; First clear out (the rest of) the buffer
  8317                                  
  8318                                          push    di
  8319                                          sub     ax,ax
  8320                                          rep     stosb
  8321                                          pop     di
  8322                                  
  8323                                  ; Initialize the path string (PATH=) first
  8324                                  
  8325                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8326                                  	mov	si,PathString
  8327                                          cmp     byte [si],al			; add it?
  8328                                          je	short init_prompt		; no
  8329                                  	;mov	cx,PathStrLen+1                 ;
  8330                                  	mov	cx,6 ; db "PATH=",0
  8331                                          rep     movsb                           ;
  8332                                          cmp     [AllocedEnv],al			; virgin env?
  8333                                          je	short init_prompt		; no
  8334                                  
  8335                                  ; Establish a more reasonable default for the PATH
  8336                                  
  8337                                  	;mov	ah,GET_DEFAULT_DRIVE
  8338                                  	mov	ah,19h
  8339                                  	int	21h
  8340                                          add     al,'A'                          ; convert to letter
  8341                                          mov     [DefPathString],al              ;
  8342                                          mov     [DefPath2String],al             ; now our default paths are complete
  8343                                  
  8344                                          mov     dl,0                            ; get dir for default drive
  8345                                          push    ds                              ;
  8346                                          push    es                              ;
  8347                                          pop     ds                              ;
  8348                                          mov     byte [di],'\'			;
  8349                                          lea     si,[di+1]                       ; set DS:SI -> available space
  8350                                  	;mov	ah,Current_Dir                  ;
  8351                                          mov	ah,47h
  8352                                  	int     21h                             ;
  8353                                          pop     ds                              ;
  8354                                  
  8355                                  	;mov	cx,DefPathStrLen+1              ;
  8356                                  	mov	cx,9 ; db "C:\MSDOS",0
  8357                                  	;mov	dx,offset RESGROUP:DefPathString
  8358                                  	mov	dx,DefPathString 
  8359                                  	mov	si,dx                           ;
  8360                                          ;mov	ah,CHDir                        ;
  8361                                          mov	ah,3Bh
  8362                                  	int     21h                             ;
  8363                                          jnc	short init_setpath		; DefPathString exists!
  8364                                  
  8365                                  	;mov	cx,DefPath2StrLen+1		;
  8366                                          mov	cx,7 ; db "C:\DOS",0
  8367                                  	;mov	dx,offset RESGROUP:DefPath2String
  8368                                  	mov	dx,DefPath2String
  8369                                          mov     si,dx                           ;
  8370                                          ;mov	ah,CHDir                        ;
  8371                                          mov	ah,3Bh
  8372                                          int     21h                             ;
  8373                                          jc	short init_prompt		; DefPath2String doesn't exist
  8374                                  
  8375                                  init_setpath:
  8376                                          mov     dx,di                           ; success
  8377                                          push    ds                              ; so restore prev dir
  8378                                          push    es                              ;
  8379                                          pop     ds                              ; DS:DX -> prev dir
  8380                                          ;mov	ah,CHDir                        ;
  8381                                          mov	ah,3Bh
  8382                                          int     21h                             ;
  8383                                          pop     ds                              ;
  8384                                  
  8385                                          dec     di                              ; then copy in DefPathString
  8386                                          rep     movsb                           ; DS:SI -> "C:\\DOS\0"
  8387                                  
  8388                                  ; Initialize the default prompt
  8389                                  
  8390                                  init_prompt:
  8391                                          push    di                              ;
  8392                                          sub     ax,ax                           ;
  8393                                          mov     cx,64                           ; insure any data read in
  8394                                          rep     stosb                           ; from Current_Dir is zapped
  8395                                          pop     di                              ;
  8396                                  
  8397                                  	cmp	[AllocedEnv],al			; virgin env?
  8398                                          je	short init_comspec		; no
  8399                                          ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
  8400                                          mov	si,PrmptString
  8401                                  	cmp     [si],al				; add it?
  8402                                          je      short init_comspec		; no
  8403                                  	;mov	cx,PrmptStrLen+1                ;
  8404                                          mov	cl,12  ; db "PROMPT=$P$G",0
  8405                                  	rep     movsb                           ;
  8406                                  
  8407                                  ; Initialize the Comspec string
  8408                                  
  8409                                  init_comspec:
  8410                                          cmp	[ComspOffset],ax		; add it?
  8411                                          jne	short init_done			; no
  8412                                          lea     ax,[di+ComspStrLen]             ;
  8413                                          mov	[ComspOffset],ax		;
  8414                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8415                                          mov	si,ComspString
  8416                                  	;mov	cx,ComspStrLen2+1               ;
  8417                                          mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
  8418                                  	rep     movsb                           ;
  8419                                  
  8420                                  init_done:
  8421                                          mov     ax,es                           ; return env seg in ax
  8422                                          mov     [EnvirSeg],ax			; save env seg
  8423                                          inc	byte [AllocedEnv]		; remember that *we* alloced it
  8424                                  %endif
  8425                                  
  8426                                  ; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
  8427                                  %if 1
  8428                                  	;mov	bx,10
  8429 00001BC7 BB0A00                  	mov	bx,ENVIRONSIZ>>4 ; 160/16
  8430 00001BCA B448                    	mov	ah,48h
  8431 00001BCC CD21                    	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
  8432                                  			; BX = number of 16-byte paragraphs desired
  8433 00001BCE 722C                    	jc	short init_nomem
  8434                                  
  8435                                  init_ok:
  8436 00001BD0 8EC0                    	mov	es,ax
  8437                                  	;assume	es:nothing                      ; es = temp env segment
  8438                                  
  8439 00001BD2 31FF                    	xor	di,di
  8440 00001BD4 89F8                    	mov	ax,di
  8441                                  	;mov	cx,160	
  8442 00001BD6 B9A000                          mov     cx,ENVIRONSIZ
  8443 00001BD9 F3AA                            rep	stosb
  8444                                  
  8445                                  init_pathstr:
  8446                                  
  8447                                  ; Initialize the path string (PATH=) first
  8448                                  
  8449 00001BDB 16                      	push	ss
  8450 00001BDC 1F                      	pop	ds
  8451                                  
  8452                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8453 00001BDD BE[941C]                	mov	si,PathString
  8454 00001BE0 BF0000                  	mov	di,0
  8455                                  init_cp_pathstr:
  8456 00001BE3 AC                      	lodsb
  8457 00001BE4 AA                      	stosb
  8458 00001BE5 08C0                    	or	al,al
  8459 00001BE7 75FA                    	jnz	short init_cp_pathstr
  8460                                  
  8461                                  ; Initialize the Comspec string
  8462                                  
  8463                                  init_comspec:
  8464                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8465 00001BE9 BE[9A1C]                        mov	si,ComspString
  8466                                  	; 05/05/2023
  8467 00001BEC BF0600                  	mov	di,6
  8468                                  init_cp_compstr:
  8469 00001BEF AC                      	lodsb
  8470 00001BF0 AA                      	stosb
  8471 00001BF1 08C0                    	or	al,al
  8472 00001BF3 75FA                    	jnz	short init_cp_compstr
  8473                                  
  8474                                  init_done:
  8475 00001BF5 8CC0                            mov     ax,es                           ; return env seg in ax
  8476                                          ;mov	[EnvirSeg],ax			; save env seg
  8477                                          ;inc	byte [AllocedEnv]		; remember that *we* alloced it
  8478                                  %endif	
  8479                                  
  8480                                  	; 29/01/2023
  8481                                  alloc_done:
  8482 00001BF7 5F                      	pop	di
  8483 00001BF8 5E                      	pop	si
  8484 00001BF9 07                      	pop	es
  8485 00001BFA 1F                              pop     ds
  8486                                  	;assume	ds:nothing
  8487 00001BFB C3                      	retn
  8488                                  
  8489                                  	; 29/01/2023
  8490                                  init_nomem:
  8491                                  
  8492                                  ;We call the error routine from here. This routine never returns. It either
  8493                                  ;terminates COMMAND with error( if it is not the first invocation ) or hangs
  8494                                  ;the system ( if it is the first COMMAND.COM ).
  8495                                  
  8496 00001BFC E80000                  	call	Alloc_error
  8497                                  
  8498                                  ;Alloc_env	endp
  8499                                  
  8500                                  ;*** Alloc_error: This routine just jumps to the actual label where we 
  8501                                  ; check if this is a permanent or secondary command.com and take the 
  8502                                  ; appropriate action.
  8503                                  ;
  8504                                  ;	ENTRY:	ds = RESGROUP = DATARES
  8505                                  ;
  8506                                  ;	EXIT:	None - does not return
  8507                                  ;
  8508                                  ;	REGISTERS AFFECTED: Does not matter
  8509                                  ;
  8510                                  
  8511                                  ;public Alloc_error
  8512                                  Alloc_error:	;proc	near
  8513                                  
  8514                                  	;jmp	RESGROUP:BadMemErr
  8515                                  	; 29/01/2023
  8516 00001BFF E918F1                  	jmp	BadMemErr	
  8517                                  	
  8518                                  ;Alloc_error	endp
  8519                                  
  8520                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8521                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh
  8522                                  
  8523                                  	; MSDOS 6.0
  8524                                  ;*** Patch_stub -- This routine patches in the segment and offset values in
  8525                                  ; the stub table of the various entry points in the resident code segment.
  8526                                  ; Some of them are interrupt entry points and some of them are entries from
  8527                                  ; the transient to the resident code segment.
  8528                                  ;
  8529                                  ;	ENTRY:	ds = RESGROUP
  8530                                  ;		es:di = segment:offset of final location of resident code
  8531                                  ;
  8532                                  ;	EXIT:	All segments and offsets patched into the stub table
  8533                                  ;
  8534                                  ;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
  8535                                  
  8536                                  patch_stub:	;proc near
  8537                                  	;assume	ds:RESGROUP
  8538                                  	
  8539 00001C02 06                      	push	es
  8540                                  
  8541 00001C03 8CC3                    	mov	bx,es			;bx = resident code segment
  8542 00001C05 89FA                    	mov	dx,di
  8543                                  	;mov	di,offset DATARES:Int2f_Entry
  8544 00001C07 BF[0400]                	mov	di,Int2f_Entry
  8545                                  	;mov	si,offset RESGROUP:Reloc_Table
  8546 00001C0A BE[E820]                	mov	si,Reloc_Table
  8547 00001C0D 1E                      	push	ds
  8548 00001C0E 07                      	pop	es			;es = RESGROUP = DATARES
  8549                                  
  8550                                  ;bx:dx = segment:offset of resident code segment
  8551                                  ;es:di = entry point table in stub
  8552                                  ;ds:si = offset table in INIT segment -- offsets of code entry points now
  8553                                  
  8554                                  	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
  8555 00001C0F B90B00                  	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
  8556                                  patchlp:
  8557 00001C12 AD                      	lodsw				;get current offset
  8558 00001C13 01D0                    	add	ax,dx			;offset it by code seg location 
  8559 00001C15 AB                      	stosw				;store offset
  8560 00001C16 89D8                    	mov	ax,bx			
  8561 00001C18 AB                      	stosw				;store segment 
  8562 00001C19 E2F7                    	loop	patchlp
  8563                                  
  8564 00001C1B 07                      	pop	es
  8565 00001C1C C3                      	retn
  8566                                  
  8567                                  ;Patch_stub	endp
  8568                                  
  8569                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8570                                  
  8571                                  	; MSDOS 6.0
  8572                                  ;*** Patch_segs -- This routine patches the segment values in the dword 
  8573                                  ; pointers that the stub uses to jump to the actual handler. These values 
  8574                                  ; are temporarily needed to handle these interrupts if they occur before
  8575                                  ; the resident is relocated to its final position and all the addresses of
  8576                                  ; the handlers have been updated.
  8577                                  ;
  8578                                  ;	ENTRY:	es = PSP segment = code segment
  8579                                  ;
  8580                                  ;	EXIT:	Current segment values patched into the jump table in the
  8581                                  ;		stub.
  8582                                  ;
  8583                                  ;	REGISTERS AFFECTED: ax, cx, di
  8584                                  
  8585                                  patch_segs:	;proc near
  8586                                  
  8587                                  	;mov	di,offset RESGROUP:Int2f_Entry
  8588 00001C1D BF[0400]                	mov	di,Int2f_Entry 
  8589 00001C20 B90400                  	mov	cx,4			;we have to patch 4 handlers
  8590 00001C23 83C702                  	add	di,2
  8591 00001C26 8CC0                    	mov	ax,es
  8592                                  pseglp:
  8593 00001C28 AB                      	stosw				;store the segment value
  8594 00001C29 83C702                  	add	di,2			;skip the next offset value
  8595 00001C2C E2FA                    	loop	pseglp
  8596                                  
  8597 00001C2E C3                      	retn
  8598                                  
  8599                                  ;Patch_segs	endp
  8600                                  
  8601                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8602                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch
  8603                                  
  8604                                  	; MSDOS 6.0
  8605                                  ;*** get_XMMAddr -- This routine gets the call address for the XMM driver
  8606                                  ; by issuing the appropriate int 2fh. This is stored in a stub variable 
  8607                                  ; and is used by the stub when we have to jump to the resident in HMA
  8608                                  ;
  8609                                  ;	ENTRY:	ds = RESGROUP
  8610                                  ;
  8611                                  ;	EXIT:	XMMCallAddr = XMM driver far call address
  8612                                  ;
  8613                                  ;	REGISTERS AFFECTED:
  8614                                  ;
  8615                                  
  8616                                  get_XMMAddr:	;proc near
  8617                                  	;assume	ds:RESGROUP
  8618                                  
  8619 00001C2F 06                      	push	es
  8620                                  
  8621                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
  8622 00001C30 B80043                  	mov	ax,4300h
  8623 00001C33 CD2F                    	int	2Fh
  8624                                  		; - Multiplex - XMS - INSTALLATION CHECK
  8625                                  		; Return: AL = 80h XMS driver installed
  8626                                  		; AL <> 80h no driver
  8627 00001C35 3C80                    	cmp	al,80h			; Q: installed
  8628 00001C37 750D                    	jne	short cXMMexit		; N: set error, quit
  8629                                  ;
  8630                                  ; get the XMM control functions entry point, save it, we
  8631                                  ; need to call it later.
  8632                                  ;
  8633                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
  8634 00001C39 B81043                  	mov	ax,4310h
  8635 00001C3C CD2F                    	int	2Fh
  8636                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  8637                                  		; Return: ES:BX -> driver entry point
  8638                                  
  8639 00001C3E 891E[3000]              	mov	[XMMCallAddr], bx
  8640 00001C42 8C06[3200]              	mov	[XMMCallAddr+2],es
  8641                                  cXMMexit:
  8642 00001C46 07                      	pop	es
  8643 00001C47 C3                      	retn				; done
  8644                                  
  8645                                  ;get_XMMAddr	endp
  8646                                  
  8647                                  ;=============================================================================
  8648                                  ; UNINIT.ASM, MSDOS 6.0, 1991
  8649                                  ;=============================================================================
  8650                                  ; 24/09/2018 - Retro DOS v3.0
  8651                                  
  8652                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  8653                                  
  8654                                  ; TITLE	COMMAND Initialization messages
  8655                                  
  8656                                  ;INIT	SEGMENT PUBLIC PARA
  8657                                  
  8658                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8659                                  
  8660                                  	; 25/09/2018
  8661                                  	; (15 bytes filler)
  8662 00001C48 00                      	db 0
  8663                                  	;db "25/9/2018 ETAN"
  8664                                  	; 30/01/2023
  8665 00001C49 33302F312F32303233-     	db "30/1/2023 ETAN"	
  8665 00001C52 204554414E         
  8666 00001C57 00                      	db 0
  8667                                  
  8668                                  ; 30/01/2023
  8669                                  %if 0
  8670                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  8671                                  	;dw 0
  8672                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  8673                                  	db 0Dh,0Ah
  8674                                  	db 0Dh,0Ah
  8675                                  	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  8676                                  	db 0Dh,0Ah
  8677                                  	db '             (C)Copyright Microsoft Corp 1981-1987               '
  8678                                  	db ' ',0Dh,0Ah
  8679                                  	db '                                                   ',
  8680                                  	db 0Dh,0Ah,0
  8681                                  
  8682                                  	times	43 db 20h
  8683                                  
  8684                                  _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  8685                                  BADCOMLKMES:
  8686                                  	dw _152Fh
  8687                                  
  8688                                  _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  8689                                  BADCOMACCMSG:
  8690                                  	dw _155Ah
  8691                                  
  8692                                  _1593h:	db 'Access denied',0Dh,0Ah,0
  8693                                  ACCDENERR:
  8694                                  	dw _1593h
  8695                                  
  8696                                  _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  8697                                  OUTENVMSG:
  8698                                  	dw _15A5h
  8699                                  
  8700                                  BADVERMSG:
  8701                                  	db 'Incorrect DOS version',0Dh,0Ah,'$'
  8702                                  
  8703                                  BADENVSIZMSG:
  8704                                  	db 'Invalid environment size specified',0Dh,0Ah,'$'
  8705                                  
  8706                                  HEADERPTR:
  8707                                  	dw COPYRIGHTMSG
  8708                                  %endif
  8709                                  
  8710                                  ; 30/01/2023
  8711                                  ;align 16
  8712                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8713                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
  8714                                  ICONDEV:
  8715 00001C58 2F4445562F                      db '/DEV/'
  8716 00001C5D 434F4E000000000000      	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
  8717                                  BADCSPFL:
  8718 00001C66 00                      	db 0
  8719                                  COMSPECT:
  8720 00001C67 5C434F4D4D414E442E-     	db '\COMMAND.COM',0
  8720 00001C70 434F4D00           
  8721 00001C74 00                      	db 0
  8722                                  AUTOBAT:
  8723 00001C75 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0,0Dh
  8723 00001C7E 45432E424154000D   
  8724                                  ;KAUTOBAT:
  8725                                  	;db 0,':\KAUTOEXEC.BAT',0,0Dh 
  8726                                  PRDATTM:
  8727 00001C86 FF                      	db -1 ; 0FFh		; Init not to prompt for date time
  8728                                  INITADD:
  8729 00001C87 00000000                	dd 0
  8730                                  print_add:
  8731 00001C8B [314E]                  	dw Printf_Init
  8732 00001C8D 0000                    	dw 0
  8733                                  triage_add:
  8734 00001C8F [D22C]                  	dw Triage_Init
  8735 00001C91 0000                    	dw 0
  8736                                  ;CHUCKENV:
  8737                                  AllocedEnv:
  8738 00001C93 00                      	db 0
  8739                                  
  8740                                  ; 30/01/2023 - MSDOS 3.3
  8741                                  ;COMSPOFFSET:
  8742                                  ;ECOMLOC:
  8743                                  ;	;dw 0Eh
  8744                                  ;	;dw offset ENVIRONMENT:ECOMSPEC-10h
  8745                                  ;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  8746                                  ;COMSPSTRING:
  8747                                  ;	db 'COMSPEC='
  8748                                  
  8749                                  ; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
  8750                                  PathString:
  8751 00001C94 504154483D00            	db 'PATH=',0
  8752                                  PathStrLen equ $-PathString-1
  8753                                  ; MSDOS 6.0
  8754                                  ;DefPathString:
  8755                                  ;	db 'C:\MSDOS',0
  8756                                  ;DefPathStrLen equ  $-DefPathString-1
  8757                                  ;DefPath2String:
  8758                                  ;	db 'C:\DOS',0
  8759                                  ;DefPath2StrLen equ $-DefPath2String-1
  8760                                  ;
  8761                                  ;PrmptString:
  8762                                  ;	db 'PROMPT=$P$G',0
  8763                                  ;PrmptStrLen equ $-PrmptString-1
  8764                                  ;PrmptStrLen2 equ 7		; length of PROMPT=
  8765                                  ;ComspOffset:
  8766                                  ;	dw 0
  8767                                  ComspString:
  8768 00001C9A 434F4D535045433D5C-     	db 'COMSPEC=\COMMAND.COM',0
  8768 00001CA3 434F4D4D414E442E43-
  8768 00001CAC 4F4D00             
  8769                                  ComspStrLen equ 8		; length of COMSPEC=
  8770                                  ComspStrLen2 equ $-ComspString-1
  8771                                  				; length of full COMSPEC
  8772                                  	; 29/01/2023
  8773                                  ;equal_sign:
  8774                                  ;equalsign:
  8775                                  ;	db '='
  8776                                  ;letter_a:
  8777                                  ;lcasea:
  8778                                  ;	db 'a'
  8779                                  ;letter_z:
  8780                                  ;lcasez:
  8781                                  ;	db 'z'
  8782                                  	; 30/01/2023
  8783                                  ;;slash_chr:
  8784                                  ;;	db '/'
  8785                                  ;;bslash_chr:
  8786                                  ;;	db '\'
  8787                                  ;space_chr:
  8788                                  ;;space:
  8789                                  ;	db 20h
  8790                                  ;;letter_p:
  8791                                  ;;	db 'p'
  8792                                  ;;letter_d:
  8793                                  ;;	db 'd'
  8794                                  ;;letter_c:
  8795                                  ;;	db 'c'
  8796                                  	; 16/04/2023
  8797                                  ; MSDOS 5.0 & MSDOS 6.0
  8798                                  ;scswitch:
  8799                                  ;	db 'C'		; Single command
  8800                                  ;;skswitch:
  8801                                  ;	db 'K' ; MSDOS 6.0
  8802                                  ;;letter_A:
  8803                                  ;ucasea: ; 21/01/2023 
  8804                                  ;	db 'A'
  8805                                  
  8806                                  	; 30/01/2023
  8807                                  EnvSiz:
  8808 00001CAF 0000                    	dw 0		; size user wants to allocate
  8809                                  EnvMax:
  8810 00001CB1 0000                    	dw 0		; maximum size allowed
  8811                                  OldEnv:
  8812 00001CB3 0000                    	dw 0		; envirseg at initialization
  8813                                  UsedEnv:
  8814 00001CB5 0000                    	dw 0		; amount of envirseg used
  8815                                  	; MSDOS 5.0 & MSDOS 6.0
  8816                                  PARS_MSG_OFF:
  8817 00001CB7 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
  8818                                  PARS_MSG_SEG:
  8819 00001CB9 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT
  8820                                  
  8821                                  ;Do not separate the following two words. Used to call transient PARSE routine
  8822                                  
  8823                                  Init_Parse:
  8824                                  	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
  8825                                  init_p:
  8826 00001CBB [2D4E]                  	dw append_parse
  8827                                  initend:
  8828 00001CBD 0000                    	dw 0		; segment address of end of init
  8829                                  TrnSize:
  8830 00001CBF 0000                    	dw 0		; size of transient in paragraphs
  8831                                  resetenv:
  8832 00001CC1 0000                    	dw 0		; set if we need to setblck env at endinit
  8833                                  
  8834                                  ext_msg:
  8835 00001CC3 00                      	db 0		; set if /MSG switch entered
  8836                                  eswitch:
  8837 00001CC4 00                      	db 0		; set if /e was entered
  8838                                  dswitch:
  8839 00001CC5 00                      	db 0		; set if /d was entered
  8840                                  parsemes_ptr:
  8841 00001CC6 0000                    	dw 0		; word to store parse error number
  8842                                  
  8843                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8844                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h 
  8845                                  
  8846                                  	; MSDOS 6.0 (UINIT.ASM, 1991)
  8847                                  ;  The following parse control block is used for COMMAND. This block is
  8848                                  ;  used for parsing during initialization. The syntax for COMMAND is:
  8849                                  ;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
  8850                                  ;
  8851                                  ;  Anything on the command line after the /C switch will be passed to the
  8852                                  ;  executable command, so if /C is used, it must be specified last. The
  8853                                  ;  /MSG switch can only be specified if the /P switch is specified.
  8854                                  ;
  8855                                  ;  The /? switch causes help text to be displayed. Any other options
  8856                                  ;  on the command line are ignored. Command.com will not load if /?
  8857                                  ;  is specified.
  8858                                  
  8859                                  INTERNAT_INFO:		; used for country info after parsing is completed
  8860                                  PARSE_COMMAND:
  8861 00001CC8 [CB1C]                  	dw COMMAND_PARMS
  8862 00001CCA 00                      	db 0			; no extra delimiter
  8863                                  COMMAND_PARMS:
  8864 00001CCB 0002                    	db 0,2			; 1 positional parm
  8865 00001CCD [E11C]                  	dw COMMAND_FILE
  8866 00001CCF [E11C]                  	dw COMMAND_FILE
  8867                                          ; MSDOS 5.0
  8868 00001CD1 07                      	db 7			; 7 switches
  8869                                  	; MSDOS 6.0
  8870                                  	;db 8 			; 8 switches
  8871 00001CD2 [EA1C]                  	dw COMMAND_SWITCH1
  8872 00001CD4 [F61C]                  	dw COMMAND_SWITCH2
  8873 00001CD6 [021D]                  	dw COMMAND_SWITCH3
  8874 00001CD8 [0E1D]                  	dw COMMAND_SWITCH4
  8875 00001CDA [271D]                  	dw COMMAND_SWITCH5
  8876 00001CDC [331D]                  	dw COMMAND_SWITCH6
  8877 00001CDE [411D]                  	dw COMMAND_SWITCH7
  8878                                  	;dw COMMAND_SWITCH8 ; MSDOS 6.0
  8879 00001CE0 00                      	db 0			; no keywords
  8880                                  
  8881                                  COMMAND_FILE:
  8882 00001CE1 0102                    	dw 0201h		; filespec - optional
  8883 00001CE3 0100                    	dw 1			; capitalize - file table
  8884 00001CE5 [4D1D]                  	dw COMND1_OUTPUT	; result buffer
  8885 00001CE7 [551D]                  	dw NO_VAL 		;
  8886 00001CE9 00                      	db 0			; no keywords
  8887                                  
  8888                                  COMMAND_SWITCH1:
  8889 00001CEA 0000                    	dw 0			; no match flags
  8890 00001CEC 0200                    	dw 2			; capitalize by char table
  8891 00001CEE [4D1D]                  	dw COMND1_OUTPUT	; result buffer
  8892 00001CF0 [551D]                  	dw NO_VAL 		;
  8893 00001CF2 01                      	db 1			; 1 keyword
  8894                                  COMMAND_P_SYN:
  8895 00001CF3 2F5000                  	db '/P',0		; /P switch
  8896                                  
  8897                                  COMMAND_SWITCH2:
  8898 00001CF6 0000                    	dw 0			; no match flags
  8899 00001CF8 0200                    	dw 2			; capitalize by char table
  8900 00001CFA [4D1D]                  	dw COMND1_OUTPUT	; result buffer
  8901 00001CFC [551D]                  	dw NO_VAL 		;
  8902 00001CFE 01                      	db 1			; 1 keyword
  8903                                  COMMAND_F_SYN:
  8904 00001CFF 2F4600                  	db '/F',0		; /F switch
  8905                                  
  8906                                  COMMAND_SWITCH3:
  8907 00001D02 0000                    	dw 0			; no match flags
  8908 00001D04 0200                    	dw 2			; capitalize by char table
  8909 00001D06 [4D1D]                  	dw COMND1_OUTPUT	; result buffer
  8910 00001D08 [551D]                  	dw NO_VAL 		;
  8911 00001D0A 01                      	db 1			; 1 keyword
  8912                                  COMMAND_D_SYN:
  8913 00001D0B 2F4400                  	db '/D',0		; /D switch
  8914                                  
  8915                                  COMMAND_SWITCH4:
  8916 00001D0E 0080                    	dw 8000h		; numeric value - required
  8917 00001D10 0000                    	dw 0			; no function flags
  8918 00001D12 [4D1D]                  	dw COMND1_OUTPUT	; result buffer
  8919 00001D14 [1A1D]                  	dw COMMAND_E_VAL	; pointer to value list
  8920 00001D16 01                      	db 1			; 1 keyword
  8921                                  COMMAND_E_SYN:
  8922 00001D17 2F4500                  	db '/E',0		; /E switch
  8923                                  
  8924                                  COMMAND_E_VAL:
  8925 00001D1A 01                      	db 1			;
  8926 00001D1B 01                      	db 1			; 1 range
  8927 00001D1C 01                      	db 1			; returned if result
  8928                                  	;dd ENVSML,ENVBIG	; minimum & maximum value
  8929                                  	; MSDOS 5.0 COMMAND.COM
  8930                                  	; (RESGROUP:1F2Bh)
  8931 00001D1D A0000000                	dd 160	 ; ENVSML
  8932 00001D21 00800000                	dd 32768 ; ENVBIG
  8933 00001D25 00                      	db 0			; no numeric values
  8934 00001D26 00                      	db 0			; no string values
  8935                                  
  8936                                  COMMAND_SWITCH5:
  8937 00001D27 0000                    	dw 0			; no match flags
  8938 00001D29 0200                    	dw 2			; capitalize by char table
  8939 00001D2B [4D1D]                  	dw COMND1_OUTPUT	; result buffer
  8940 00001D2D [551D]                  	dw NO_VAL 		;
  8941 00001D2F 01                      	db 1			; 1 keyword
  8942                                  COMMAND_C_SYN:
  8943 00001D30 2F4300                  	db '/C',0		; /C switch
  8944                                  
  8945                                  COMMAND_SWITCH6:
  8946 00001D33 0000                    	dw 0			; no match flags
  8947 00001D35 0200                    	dw 2			; capitalize by char table
  8948 00001D37 [4D1D]                  	dw COMND1_OUTPUT	; result buffer
  8949 00001D39 [551D]                  	dw NO_VAL 		;
  8950 00001D3B 01                      	db 1			; 1 keyword
  8951                                  COMMAND_M_SYN:
  8952 00001D3C 2F4D534700              	db '/MSG',0		; /MSG switch
  8953                                  
  8954                                  COMMAND_SWITCH7:
  8955 00001D41 0000                    	dw 0			; no match flags
  8956 00001D43 0200                    	dw 2			; capitalize by char table
  8957 00001D45 [4D1D]                  	dw COMND1_OUTPUT	; result buffer
  8958 00001D47 [551D]                  	dw NO_VAL 		;
  8959 00001D49 01                      	db 1			; 1 keyword
  8960                                  COMMAND_?_SYN:
  8961 00001D4A 2F3F00                  	db '/?',0 		; /? switch
  8962                                  
  8963                                  	; MSDOS 6.0
  8964                                  ;COMMAND_SWITCH8:
  8965                                  ;	dw 0			; no match flags
  8966                                  ;	dw 2			; capitalize by char table
  8967                                  ;	dw COMND1_OUTPUT	; result buffer
  8968                                  ;	dw NO_VAL 		;
  8969                                  ;	db 1			; 1 keyword
  8970                                  ;COMMAND_K_SYN:
  8971                                  ;	db '/K',0		; /K switch
  8972                                  
  8973                                  COMND1_OUTPUT:
  8974                                  COMND1_TYPE:
  8975 00001D4D 00                      	db 0			; type
  8976                                  COMND1_CODE:
  8977 00001D4E 00                      	db 0			; return value
  8978                                  COMND1_SYN:
  8979 00001D4F 0000                    	dw 0			; synonym pointer
  8980                                  COMND1_ADDR:
  8981 00001D51 00000000                	dd 0			; numeric value / address
  8982                                  					; of string value
  8983                                  NO_VAL:
  8984 00001D55 00                      	db 0			; no values
  8985                                  num_positionals:
  8986 00001D56 0000                    	dw 0			; counter for positionals
  8987                                  old_parse_ptr:
  8988 00001D58 0000                    	dw 0			; SI position before calling parser
  8989                                  
  8990                                  	; 30/01/2023
  8991                                  ;***	INITIALIZATION MESSAGES
  8992                                  ;	-------------------------
  8993                                  ;	include	comimsg.inc	;M00
  8994                                  ;-----------------------------------------------------------------------------	
  8995                                  
  8996                                  BADVERMSG:
  8997 00001D5A 17                      	db 23
  8998 00001D5B 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah
  8998 00001D64 20444F532076657273-
  8998 00001D6D 696F6E0D0A         
  8999                                  OUTENVMSG:
  9000 00001D72 1A                      	db 26
  9001 00001D73 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
  9001 00001D7C 7669726F6E6D656E74-
  9001 00001D85 2073706163650D0A   
  9002                                  COPYRIGHTMSG:
  9003 00001D8D 5E                      	db 94
  9004 00001D8E 0D0A                    	db 0Dh,0Ah
  9005 00001D90 0D0A                    	db 0Dh,0Ah
  9006 00001D92 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
  9006 00001D9B 285229204D532D444F-
  9006 00001DA4 532852292056657273-
  9006 00001DAD 696F6E20352E30300D-
  9006 00001DB6 0A                 
  9007 00001DB7 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
  9007 00001DC0 20202020284329436F-
  9007 00001DC9 70797269676874204D-
  9007 00001DD2 6963726F736F667420-
  9007 00001DDB 436F72702031393831-
  9007 00001DE4 2D313939312E0D0A   
  9008                                  BADCOMLKMES:
  9009 00001DEC 28                      	db 40
  9010 00001DED 537065636966696564-     	db 'Specified COMMAND search directory bad',0Dh,0Ah
  9010 00001DF6 20434F4D4D414E4420-
  9010 00001DFF 736561726368206469-
  9010 00001E08 726563746F72792062-
  9010 00001E11 61640D0A           
  9011                                  BADCOMACCMSG:
  9012 00001E15 36                      	db 54
  9013 00001E16 537065636966696564-     	db 'Specified COMMAND search directory bad '
  9013 00001E1F 20434F4D4D414E4420-
  9013 00001E28 736561726368206469-
  9013 00001E31 726563746F72792062-
  9013 00001E3A 616420             
  9014 00001E3D 616363657373206465-     	db 'access denied',0Dh,0Ah
  9014 00001E46 6E6965640D0A       
  9015                                  HELPMSG1:
  9016 00001E4C 3C                      	db 60
  9017 00001E4D 537461727473206120-     	db 'Starts a new instance of the MS-DOS command interpreter.',0Dh,0Ah
  9017 00001E56 6E657720696E737461-
  9017 00001E5F 6E6365206F66207468-
  9017 00001E68 65204D532D444F5320-
  9017 00001E71 636F6D6D616E642069-
  9017 00001E7A 6E7465727072657465-
  9017 00001E83 722E0D0A           
  9018 00001E87 0D0A                    	db 0Dh,0Ah
  9019                                  HELPMSG2:
  9020 00001E89 46                      	db 70
  9021 00001E8A 434F4D4D414E44205B-     	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
  9021 00001E93 5B64726976653A5D70-
  9021 00001E9C 6174685D205B646576-
  9021 00001EA5 6963655D205B2F453A-
  9021 00001EAE 6E6E6E6E6E5D205B2F-
  9021 00001EB7 505D205B2F43207374-
  9021 00001EC0 72696E675D205B2F4D-
  9021 00001EC9 53475D             
  9022 00001ECC 0D0A                    	db 0Dh,0Ah
  9023 00001ECE 0D0A                    	db 0Dh,0Ah
  9024                                  HELPMSG3:
  9025 00001ED0 48                              db 72
  9026 00001ED1 20205B64726976653A-     	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
  9026 00001EDA 5D7061746820202020-
  9026 00001EE3 537065636966696573-
  9026 00001EEC 207468652064697265-
  9026 00001EF5 63746F727920636F6E-
  9026 00001EFE 7461696E696E672043-
  9026 00001F07 4F4D4D414E442E434F-
  9026 00001F10 4D20               
  9027 00001F12 66696C652E0D0A          	db 'file.',0Dh,0Ah
  9028                                  HELPMSG4:
  9029 00001F19 4D                      	db 77
  9030 00001F1A 202064657669636520-     	db '  device          Specifies the device to use for command input and '
  9030 00001F23 202020202020202020-
  9030 00001F2C 537065636966696573-
  9030 00001F35 207468652064657669-
  9030 00001F3E 636520746F20757365-
  9030 00001F47 20666F7220636F6D6D-
  9030 00001F50 616E6420696E707574-
  9030 00001F59 20616E6420         
  9031 00001F5E 6F75747075742E0D0A      	db 'output.',0Dh,0Ah
  9032                                  HELPMSG5:
  9033 00001F67 45                      	db 69
  9034 00001F68 20202F453A6E6E6E6E-     	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
  9034 00001F71 6E2020202020202020-
  9034 00001F7A 536574732074686520-
  9034 00001F83 696E697469616C2065-
  9034 00001F8C 6E7669726F6E6D656E-
  9034 00001F95 742073697A6520746F-
  9034 00001F9E 206E6E6E6E6E206279-
  9034 00001FA7 7465732E           
  9035 00001FAB 0D0A                    	db 0Dh,0Ah
  9036                                  HELPMSG6:
  9037 00001FAD 4D                      	db 77
  9038 00001FAE 20202F502020202020-     	db '  /P              Makes the new command interpreter permanent '
  9038 00001FB7 202020202020202020-
  9038 00001FC0 4D616B657320746865-
  9038 00001FC9 206E657720636F6D6D-
  9038 00001FD2 616E6420696E746572-
  9038 00001FDB 707265746572207065-
  9038 00001FE4 726D616E656E7420   
  9039 00001FEC 2863616E2774206578-     	db '(can',27h,'t exit).',0Dh,0Ah
  9039 00001FF5 6974292E0D0A       
  9040                                  HELPMSG7:
  9041 00001FFB 50                      	db 80
  9042 00001FFC 20202F432073747269-     	db '  /C string       Carries out the command specified by string, and '
  9042 00002005 6E6720202020202020-
  9042 0000200E 43617272696573206F-
  9042 00002017 75742074686520636F-
  9042 00002020 6D6D616E6420737065-
  9042 00002029 636966696564206279-
  9042 00002032 20737472696E672C20-
  9042 0000203B 616E6420           
  9043 0000203F 7468656E2073746F70-     	db 'then stops.',0Dh,0Ah
  9043 00002048 732E0D0A           
  9044                                  HELPMSG8:
  9045 0000204C 4E                      	db 78
  9046 0000204D 20202F4D5347202020-     	db '  /MSG            Specifies that all error messages be stored in '
  9046 00002056 202020202020202020-
  9046 0000205F 537065636966696573-
  9046 00002068 207468617420616C6C-
  9046 00002071 206572726F72206D65-
  9046 0000207A 737361676573206265-
  9046 00002083 2073746F7265642069-
  9046 0000208C 6E20               
  9047 0000208E 6D656D6F72792E2059-     	db 'memory. You',0Dh,0Ah
  9047 00002097 6F750D0A           
  9048                                  HELPMSG9:
  9049 0000209B 38                      	db 56
  9050 0000209C 202020202020202020-     	db '                  need to specify /P with this switch.',0Dh,0Ah
  9050 000020A5 202020202020202020-
  9050 000020AE 6E65656420746F2073-
  9050 000020B7 706563696679202F50-
  9050 000020C0 207769746820746869-
  9050 000020C9 73207377697463682E-
  9050 000020D2 0D0A               
  9051                                  HelpMsgs:
  9052 000020D4 [4C1E]                          dw HELPMSG1
  9053 000020D6 [891E]                  	dw HELPMSG2
  9054 000020D8 [D01E]                  	dw HELPMSG3
  9055 000020DA [191F]                  	dw HELPMSG4
  9056 000020DC [671F]                  	dw HELPMSG5
  9057 000020DE [AD1F]                  	dw HELPMSG6
  9058 000020E0 [FB1F]                  	dw HELPMSG7
  9059 000020E2 [4C20]                  	dw HELPMSG8
  9060 000020E4 [9B20]                  	dw HELPMSG9
  9061                                  
  9062                                  	; 23/04/2023
  9063 000020E6 0000                    	dw 0
  9064                                  
  9065                                  ;-----------------------------------------------------------------------------
  9066                                  
  9067                                  ;SR;
  9068                                  ; This table of offsets is used by the init code to calculate the new offsets
  9069                                  ;for these labels after the resident code has been relocated
  9070                                  
  9071                                  ;Reloc_Table:
  9072                                  	;dw offset CODERES:MsgInt2fHandler
  9073                                  	;dw offset CODERES:Int_2e
  9074                                  	;dw offset CODERES:ContC
  9075                                  	;dw offset CODERES:DskErr
  9076                                  	;dw offset CODERES:Exec_Ret
  9077                                  	;dw offset CODERES:TRemCheck
  9078                                  	;dw offset CODERES:TrnLodCom1
  9079                                  	;dw offset CODERES:LodCom
  9080                                  	;dw offset CODERES:MsgRetriever
  9081                                  	;dw offset CODERES:THeadFix
  9082                                  	;dw offset CODERES:Lh_OffUnlink	; M003
  9083                                  
  9084                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9085                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h
  9086                                  
  9087                                  Reloc_Table:			          ; MSDOS 5.0 CODERES address
  9088 000020E8 2307                    	dw MsgInt2fHandler - RCODE_START  ; 738h
  9089 000020EA 7601                    	dw Int_2e - RCODE_START		  ; 177h	
  9090 000020EC 3300                    	dw ContC - RCODE_START		  ; 035h
  9091 000020EE 3704                    	dw DSKERR - RCODE_START		  ; 445h
  9092 000020F0 2700                    	dw Exec_Ret - RCODE_START	  ; 029h
  9093 000020F2 9A02                    	dw TRemCheck - RCODE_START	  ; 2A3h
  9094 000020F4 1404                    	dw TrnLodCom1 - RCODE_START	  ; 422h
  9095 000020F6 AD01                    	dw LodCom - RCODE_START		  ; 1AEh
  9096 000020F8 6607                    	dw MsgRetriever - RCODE_START	  ; 77Bh
  9097 000020FA B902                    	dw THeadFix - RCODE_START	  ; 2C2h
  9098 000020FC DF07                    	dw Lh_OffUnlink - RCODE_START	  ; 7F4h
  9099                                  
  9100                                  NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2
  9101                                  
  9102                                  ResJmpTable:
  9103 000020FE 00000000                	dd 0			; stores prev stub jump table addr
  9104                                  FirstCom:
  9105 00002102 00                      	db 0			; flag set if first command.com
  9106                                  DevFlag:
  9107 00002103 00                      	db 0
  9108                                  PathFlag:
  9109 00002104 00                      	db 0
  9110                                  
  9111                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
  9112                                  	;times 13 db 0
  9113                                  
  9114                                  ; 30/01/2023
  9115                                  coderes_end equ $
  9116                                  
  9117                                  ;INIT	ENDS
  9118                                  
  9119                                  ;	END
  9120                                  
  9121                                  ;-----------------------------------------------------------------------------
  9122                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  9123                                  ;-----------------------------------------------------------------------------
  9124                                  
  9125                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  9126                                  	; 30/01/2023
  9127 00002105 00                      db	0
  9128 00002106 526574726F20444F53-     db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"		
  9128 0000210F 2076342E3020434F4D-
  9128 00002118 4D414E442E434F4D20-
  9128 00002121 6279204572646F6761-
  9128 0000212A 6E2054616E205B3230-
  9128 00002133 32335D             
  9129 00002136 00                      db	0
  9130                                  
  9131                                  ;-----------------------------------------------------------------------------
  9132                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  9133                                  ;-----------------------------------------------------------------------------
  9134                                  
  9135                                  ;TAIL    SEGMENT PUBLIC PARA
  9136                                  ;        ORG     0
  9137                                  ;TRANSTART LABEL WORD
  9138                                  ;TAIL    ENDS
  9139                                  
  9140                                  ;ALIGN 16  ; 25/09/2018
  9141                                  
  9142                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9143                                  
  9144                                  numbertodiv equ ($-StartCode)+100h ; 16/04/2023
  9145                                  numbertomod equ (numbertodiv % 16)
  9146                                  
  9147                                  %if numbertomod>0 & numbertomod<16
  9148 00002137 00<rep 9h>              	times (16-numbertomod) db 0
  9149                                  %endif
  9150                                  
  9151                                  ; 30/01/2023
  9152                                  ;TRANSTART:
  9153                                  
  9154                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  9155                                  ;	times	128 db 0	
  9156                                  
  9157                                  ;-----------------------------------------------------------------------------
  9158                                  ; SEGMENT - TRANSCODE
  9159                                  ;-----------------------------------------------------------------------------
  9160                                  
  9161                                  ;TRANGROUP: ; 21/04/2018
  9162                                  
  9163                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9164                                  ;-----------------------------------------------------------------------------
  9165                                  
  9166                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  9167                                  
  9168                                  ; 21/04/2018 - Retro DOS v2.0
  9169                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  9170                                  ; (these values must be changed when transcom.s source code is changed
  9171                                  ; and data offsets are changed)
  9172                                  ;
  9173                                  ; 30/04/2018
  9174                                  ; 29/04/2018
  9175                                  
  9176                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9177                                  ;COMMAND      EQU  012CH
  9178                                  ;DATINIT      EQU  2091H
  9179                                  ;HEADCALL     EQU  428FH
  9180                                  ;TRANSPACEEND EQU  4D5CH
  9181                                  ;TRANDATAEND  EQU  3F44H
  9182                                  
  9183                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9184                                  ;TRIAGE_INIT  EQU  1F15H
  9185                                  ;PRINTF_INIT  EQU  34E0H 
  9186                                  
  9187                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  9188                                  
  9189                                  ;TPA	EQU  4293H
  9190                                  ;TRNLEN	EQU  04D6H
  9191                                  
  9192                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  9193                                  ;COMMAND      EQU  012CH
  9194                                  ;DATINIT      EQU  206FH
  9195                                  ;HEADCALL     EQU  426FH
  9196                                  ; 09/01/2023
  9197                                  ;TRANSPACEEND EQU  4D3CH
  9198                                  ;TRANDATAEND  EQU  3F24H
  9199                                  ;TRIAGE_INIT  EQU  1EF3H
  9200                                  ;PRINTF_INIT  EQU  34BFH 
  9201                                  ;
  9202                                  ;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  9203                                  
  9204                                  ;-----------------------------------------------------------------------------
  9205                                  ; ARENA.INC, MSDOS 6.0, 1991
  9206                                  ;-----------------------------------------------------------------------------
  9207                                  ; 13/10/2018 - Retro DOS 3.0
  9208                                  ; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9209                                  
  9210                                  ;BREAK <Memory arena structure>
  9211                                  
  9212                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  9213                                  
  9214                                  ; arena item
  9215                                  
  9216                                  struc ARENA
  9217 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
  9218 00000001 ????                      .owner:	resw 1		; owner of arena item
  9219 00000003 ????                      .size:	resw 1		; size in paragraphs of item
  9220                                  endstruc
  9221                                  
  9222                                  ;-----------------------------------------------------------------------------
  9223                                  ;START OF TRANSIENT PORTION
  9224                                  ;This code is loaded at the end of memory and may be overwritten by
  9225                                  ;memory-intensive user programs.
  9226                                  ;-----------------------------------------------------------------------------
  9227                                  
  9228                                  ; 16/04/2023
  9229                                  TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
  9230                                  ; 29/09/2018
  9231                                  ; 31/01/2023 
  9232                                  ;TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  9233                                  			; 09/01/2023
  9234                                  			; Offset 2320h in original MSDOS 5.0 COMMAND.COM
  9235                                  
  9236                                  ; 25/09/2018
  9237                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  9238                                  ;
  9239                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  9240                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  9241                                  ;
  9242                                  ;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  9243                                  ;
  9244                                  ;
  9245                                  ;COMTRANS:
  9246                                  ;
  9247                                  ; 20/10/2018 - Retro DOS v3.0	
  9248                                  ;INCBIN	"TRANCOM3.BIN"
  9249                                  ;
  9250                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  9251                                  ;
  9252                                  ; 29/04/2018
  9253                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  9254                                  ;
  9255                                  ;TIMES BSS_SIZE db 0
  9256                                  ;
  9257                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  9258                                  
  9259                                  ;COMMANDCOMSIZE equ $ - 100h
  9260                                  
  9261                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9262                                  ; ============================================================================
  9263                                  ; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
  9264                                  ; ============================================================================
  9265                                  
  9266                                  ; ----------------------------------------------------------------------------
  9267                                  ; START OF TRANSIENT PORTION
  9268                                  ; ----------------------------------------------------------------------------
  9269                                  ; SEGMENT - TRANSCODE
  9270                                  ; ----------------------------------------------------------------------------
  9271                                  
  9272                                  ; 18/04/2023
  9273                                  section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 
  9274                                  
  9275                                  ; 18/04/2023
  9276                                  ;-----------------------------------------------------------------------------
  9277                                  ; TRANSCODE segment offset 0
  9278                                  TRANSIENTSTART:
  9279                                  
  9280                                  	; 31/01/2023
  9281 00000000 00<rep 100h>            	times 256 db 0		; Allow for 100H parameter area
  9282                                  
  9283                                  ;============================================================================
  9284                                  ; TCODE.ASM, MSDOS 6.0, 1991
  9285                                  ;============================================================================
  9286                                  ; 12/10/2018 - Retro DOS v3.0
  9287                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1)
  9288                                  
  9289                                  ;[ORG 100h]
  9290                                  
  9291                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  9292                                  
  9293                                  ; ---------------------------------------------------------------------------
  9294                                  		
  9295                                  		; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9296                                  		; (TRANGROUP:0100h)
  9297                                  SETDRV:
  9298 00000100 B40E                    	mov	ah,0Eh
  9299                                  	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  9300 00000102 CD21                    	int	21h	; DOS -	SELECT DISK
  9301                                  			; DL = new default drive number
  9302                                  			;		(0 = A, 1 = B, ..)
  9303                                  			; Return: AL = number of logical drives
  9304                                  
  9305                                  ; ---------------------------------------------------------------------------
  9306                                  
  9307                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  9308                                  ; No registers (CS:IP) no flags, nothing.
  9309                                  
  9310                                  TCOMMAND:
  9311 00000104 2E8E1E[E08A]            	mov	ds,[cs:RESSEG]
  9312 00000109 B8FFFF                  	mov	ax,-1
  9313 0000010C 8706[A801]              	xchg	ax,[VerVal]
  9314 00000110 83F8FF                  	cmp	ax,-1
  9315 00000113 7404                    	je	short NOSETVER2
  9316 00000115 B42E                    	mov	ah,2Eh
  9317                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  9318 00000117 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
  9319                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  9320                                  NOSETVER2:
  9321 00000119 2EFF1E[DE8A]            	call	far [cs:HEADCALL]   ; Make sure header fixed
  9322 0000011E 31ED                    	xor	bp,bp		    ; Flag transient not read
  9323 00000120 833E[A601]FF            	cmp	word [SingleCom],-1
  9324 00000125 7505                    	jne	short COMMAND
  9325                                  _$EXITPREP:
  9326 00000127 0E                      	push	cs
  9327 00000128 1F                      	pop	ds
  9328 00000129 E94520                  	jmp	_$EXIT		; Have finished the single command
  9329                                  
  9330                                  ; ---------------------------------------------------------------------------
  9331                                  ;
  9332                                  ; Main entry point from resident portion.
  9333                                  ;
  9334                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  9335                                  ;   just beginning the processing of another command.
  9336                                  ;
  9337                                  ; ---------------------------------------------------------------------------
  9338                                  
  9339                                  ; We are not always sure of the state of the world at this time. We presume
  9340                                  ; worst case and initialize the relevant registers: segments and stack.
  9341                                  
  9342                                  COMMAND:
  9343 0000012C FC                      	cld
  9344 0000012D 8CC8                    	mov	ax,cs
  9345 0000012F FA                      	cli
  9346 00000130 8ED0                    	mov	ss,ax
  9347                                  	;mov	sp,offset TRANGROUP:STACK
  9348 00000132 BC[BE95]                	mov	sp,STACK
  9349 00000135 FB                      	sti
  9350                                  		
  9351 00000136 8EC0                    	mov	es,ax
  9352                                  		
  9353                                  	; MSDOS 6.0
  9354 00000138 8ED8                    	mov	ds,ax		;AN000; set DS to transient
  9355                                  	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  9356                                  	;invoke	TSYSLOADMSG	;AN000; preload messages
  9357                                  	; 31/01/2023
  9358 0000013A E8E74D                  	call	TSYSLOADMSG
  9359 0000013D C606[558E]00            	mov	byte [append_exec],0 ;AN041; set internal append state off
  9360                                  
  9361                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9362                                  	;mov	ds,[ss:RESSEG]
  9363                                  	; 31/01/2023
  9364 00000142 8E1E[E08A]              	mov	ds,[RESSEG]
  9365 00000146 36C606[BC88]80          	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  9366 0000014C 36C606[3F89]80          	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  9367                                  
  9368                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  9369                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  9370                                  ; I guess not: the only circumstances in which we reload the command processor
  9371                                  ; is after a transient program execution. In this case, we let the current
  9372                                  ; directory lie where it may.
  9373                                  
  9374 00000152 09ED                    	or	bp,bp		; See if just read
  9375 00000154 7409                    	jz	short TESTRDIR	; Not read, check user directory
  9376 00000156 36C706[BD88]010D        	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  9377 0000015D EB17                    	jmp	short NOSETBUF
  9378                                  TESTRDIR:
  9379 0000015F 803E[A401]00            	cmp	byte [RestDir],0
  9380 00000164 7410                    	jz	short NOSETBUF	; User directory OK
  9381 00000166 1E                      	push	ds
  9382                                  
  9383                                  ; We have an unusual situation to handle. The user *may* have changed his
  9384                                  ; directory as a result of an internal command that got aborted. Restoring it
  9385                                  ; twice may not help us: the problem may never go away. We just attempt it
  9386                                  ; once and give up.
  9387                                  
  9388 00000167 C606[A401]00            	mov	byte [RestDir],0 ; Flag users dirs OK
  9389                                  
  9390                                  	; Restore users directory
  9391 0000016C 0E                      	push	cs
  9392 0000016D 1F                      	pop	ds
  9393 0000016E BA[C289]                	mov	dx,USERDIR1
  9394 00000171 B43B                    	mov	ah,3Bh
  9395                                  	;mov	ah,CHDir ; 3Bh
  9396 00000173 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  9397                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
  9398 00000175 1F                      	pop	ds
  9399                                  NOSETBUF:
  9400 00000176 803E[1902]00            	cmp	byte [PipeFiles],0
  9401 0000017B 740A                    	jz	short NOPCLOSE	; Don't bother if they don't exist
  9402 0000017D 803E[1802]00            	cmp	byte [PipeFlag],0
  9403 00000182 7503                    	jnz	short NOPCLOSE	; Don't del if still piping
  9404 00000184 E8972B                  	call	PIPEDEL
  9405                                  NOPCLOSE:
  9406                                  	;mov	byte [0BE9h],0	; MSDOS 3.3
  9407                                  	; 31/01/2023
  9408 00000187 C606[9C01]00            	mov	byte [ExtCom],0 ; Flag internal command
  9409 0000018C 8CC8                    	mov	ax,cs		; Get segment we're in
  9410 0000018E 8ED8                    	mov	ds,ax
  9411 00000190 50                      	push	ax
  9412 00000191 BA[BE95]                	mov	dx,INTERNATVARS
  9413 00000194 B80038                  	mov	ax,3800h
  9414                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
  9415 00000197 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9416                                  			; get current-country info
  9417                                  			; DS:DX	-> buffer for returned info
  9418 00000199 58                      	pop	ax
  9419 0000019A 2B06[E28A]              	sub	ax,[TPA]	; AX=size of TPA in paragraphs
  9420 0000019E 53                      	push	bx
  9421 0000019F BB1000                  	mov	bx,16
  9422 000001A2 F7E3                    	mul	bx		; DX:AX=size of TPA in bytes
  9423 000001A4 5B                      	pop	bx
  9424 000001A5 09D2                    	or	dx,dx		; See if over 64K
  9425 000001A7 7403                    	jz	short SAVSIZ	; OK if not
  9426 000001A9 B8FFFF                  	mov	ax,-1		; If so, limit to 65535 bytes
  9427                                  SAVSIZ:
  9428                                  
  9429                                  ; AX is the number of bytes free in the buffer between the resident and the
  9430                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  9431                                  
  9432 000001AC 3D0002                  	cmp	ax,512
  9433 000001AF 7603                    	jbe	short GOTSIZE
  9434                                  	;and	ax,~1FFh
  9435 000001B1 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FF
  9436                                  GOTSIZE:
  9437 000001B4 A3[018B]                	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  9438 000001B7 8E1E[E08A]              	mov	ds,[RESSEG]	; All batch work must use resident seg.
  9439                                  
  9440 000001BB F606[A001]01            	test	byte [EchoFlag],1 
  9441 000001C0 741E                    	jz	short GETCOM	; Don't do the CRLF
  9442 000001C2 E8382B                  	call	SINGLETEST
  9443 000001C5 7219                    	jb	short GETCOM
  9444 000001C7 F606[1802]FF            	test	byte [PipeFlag],0FFh ; -1
  9445 000001CC 7512                    	jnz	short GETCOM
  9446                                  				; G  Don't print prompt in FOR
  9447 000001CE F606[AC01]FF            	test	byte [ForFlag],0FFh ; -1
  9448 000001D3 750B                    	jnz	short GETCOM
  9449                                  					; G  Don't print prompt if in batch
  9450 000001D5 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; -1
  9451 000001DB 7503                    	jnz	short GETCOM
  9452 000001DD E81924                  	call	CRLF2
  9453                                  GETCOM:
  9454 000001E0 C606[B101]00            	mov	byte [Call_Flag],0 ; G Reset call flags
  9455 000001E5 C606[B201]00            	mov	byte [Call_Batch_Flag],0
  9456 000001EA B419                    	mov	ah,19h
  9457                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  9458 000001EC CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
  9459 000001EE 36A2[F48A]              	mov	[ss:CURDRV],al
  9460 000001F2 F606[1802]FF            	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
  9461 000001F7 7403                    	jz	short NOPIPE
  9462 000001F9 E9ED2B                  	jmp	PIPEPROC	; Continue the pipeline
  9463                                  NOPIPE:
  9464 000001FC F606[A001]01            	test	byte [EchoFlag],1
  9465 00000201 7417                    	jz	short NOPDRV	; No prompt if echo off
  9466 00000203 E8F72A                  	call	SINGLETEST
  9467 00000206 7212                    	jb	short NOPDRV
  9468 00000208 F606[AC01]FF            	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
  9469 0000020D 750B                    	jnz	short NOPDRV
  9470 0000020F F706[4C01]FFFF          	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
  9471 00000215 750D                    	jnz	short TESTFORBAT
  9472 00000217 E8931B                  	call	PRINT_PROMPT	; Prompt the user
  9473                                  NOPDRV:
  9474 0000021A F606[AC01]FF            	test	byte [ForFlag],0FFh ; FOR has next highest precedence
  9475 0000021F 7403                    	jz	short TESTFORBAT
  9476 00000221 E9BE0B                  	jmp	FORPROC		; Continue the FOR
  9477                                  
  9478                                  TESTFORBAT:
  9479 00000224 36C606[8B8A]00          	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  9480 0000022A C606[C701]00            	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
  9481 0000022F C606[C601]00            	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
  9482 00000234 C606[AB01]00            	mov	byte [IfFlag],0	; no more ifs...
  9483 00000239 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; Batch has lowest precedence
  9484 0000023F 7441                    	jz	short ISNOBAT
  9485                                  
  9486                                  	; 31/01/2023
  9487                                  
  9488                                  	; MSDOS 6.0
  9489                                  
  9490                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  9491                                  
  9492 00000241 06                      	push	es			;AN000; save ES
  9493 00000242 1E                      	push	ds			;AN000; save DS
  9494                                  	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  9495                                  	; 05/02/2023
  9496 00000243 B80219                  	mov	ax,1902h
  9497 00000246 8E06[4C01]              	mov	es,[Batch]		;AN000; get batch segment
  9498                                  	;mov	di,20h
  9499 0000024A BF2000                  	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
  9500 0000024D 0E                      	push	cs			;AN000; get local segment to DS
  9501 0000024E 1F                      	pop	ds			;AN000;
  9502                                  	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  9503 0000024F BA[3F89]                	mov	dx,COMBUF
  9504 00000252 CD2F                    	int	2Fh			;AN000; call the shell
  9505                                  		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
  9506                                  		; ES:DI -> ASCIZ full filename of current batch file, with at least the
  9507                                  		; final filename element uppercased
  9508                                  		; DS:DX -> buffer for results
  9509                                  	;cmp	al,0FFh
  9510 00000254 3CFF                    	cmp	al,shell_action 	;AN000; does shell have a commmand?
  9511 00000256 1F                      	pop	ds			;AN000; restore DS
  9512 00000257 07                      	pop	es			;AN000; restore ES
  9513 00000258 7424                    	jz	short JDOCOM1		;AN000; yes - go process command
  9514                                  
  9515                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9516 0000025A 1E                      	push	ds
  9517 0000025B E81603                  	call	READBAT			; Continue BATCH
  9518 0000025E 1F                      	pop	ds
  9519 0000025F C606[B501]00            	mov	byte [NullFlag],0	;G reset no command flag
  9520 00000264 F706[4C01]FFFF          	test	word [Batch],0FFFFh
  9521 0000026A 7512                    	jnz	short JDOCOM1		;G if batch still in progress continue
  9522 0000026C 8B1E[B301]              	mov	bx,[Next_Batch]
  9523                                  	; 31/01/2023
  9524 00000270 09DB                    	or	bx,bx
  9525                                  	;cmp	bx,0			;G see if there is a new batch file
  9526 00000272 740A                    	jz	short JDOCOM1		;G no - go do command
  9527 00000274 891E[4C01]              	mov	[Batch],bx		;G get segment of next batch file
  9528 00000278 C706[B301]0000          	mov	word [Next_Batch],0	;G reset next batch
  9529                                  JDOCOM1:
  9530 0000027E 0E                      	push	cs
  9531 0000027F 1F                      	pop	ds
  9532 00000280 EB55                    	jmp	short DOCOM1
  9533                                  ISNOBAT:
  9534 00000282 833E[A601]00            	cmp	word [SingleCom],0
  9535 00000287 741C                    	jz	short REGCOM
  9536                                  	;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
  9537 00000289 BEFFFF                  	mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
  9538 0000028C 8736[A601]              	xchg	si,[SingleCom]
  9539 00000290 BF[4189]                	mov	di,COMBUF+2
  9540 00000293 31C9                    	xor	cx,cx
  9541                                  SINGLELOOP:
  9542 00000295 AC                      	lodsb
  9543 00000296 AA                      	stosb
  9544 00000297 41                      	inc	cx
  9545 00000298 3C0D                    	cmp	al,0Dh
  9546 0000029A 75F9                    	jnz	short SINGLELOOP
  9547 0000029C 49                      	dec	cx
  9548 0000029D 0E                      	push	cs
  9549 0000029E 1F                      	pop	ds
  9550 0000029F 880E[4089]              	mov	[COMBUF+1],cl
  9551                                  
  9552                                  ; do NOT issue a trailing CRLF...
  9553                                  
  9554 000002A3 EB32                    	jmp	short DOCOM1
  9555                                  
  9556                                  	;nop
  9557                                  
  9558                                  	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
  9559                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h
  9560                                  
  9561                                  ; We have a normal command.  
  9562                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  9563                                  ; sometimes they aren't. At this point, we automatically close all spool
  9564                                  ; files and turn on truncation mode.
  9565                                  
  9566                                  REGCOM:
  9567                                  	;mov	ax,(ServerCall shl 8) + 9
  9568                                  	; 31/01/2023
  9569 000002A5 B8095D                  	mov	ax,5D09h
  9570                                  	;mov	ax,(SERVERCALL<<8)+9
  9571 000002A8 CD21                    	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  9572                                  	;mov	ax,(ServerCall shl 8) + 8
  9573 000002AA B8085D                  	mov	ax,5D08h
  9574                                  	;mov	ax,(SERVERCALL<<8)+8
  9575 000002AD B201                    	mov	dl,1
  9576 000002AF CD21                    	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  9577                                  			; DL = 00h redirected output is	combined
  9578                                  			;      01h redirected output placed in separate	jobs
  9579                                  			; start	new print job now
  9580 000002B1 0E                      	push	cs
  9581 000002B2 1F                      	pop	ds	; Need local segment to point to buffer
  9582 000002B3 BA[BC88]                	mov	dx,UCOMBUF
  9583                                  
  9584                                  	; MSDOS 6.0
  9585                                  ;	Try to read interactive command line via DOSKey.
  9586                                  ;	If that fails, use DOS Buffered Keyboard Input.
  9587                                  
  9588                                  	; 31/01/2023
  9589 000002B6 B81048                  	mov	ax,4810h	; AX = DOSKey Read Line function
  9590 000002B9 CD2F                    	int	2Fh
  9591 000002BB 09C0                    	or	ax,ax
  9592 000002BD 7404                    	jz	short GOTCOM	; DOSKey gave us a command line
  9593                                  
  9594 000002BF B40A                    	mov	ah,0Ah
  9595                                  	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
  9596 000002C1 CD21                    	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  9597                                  			; DS:DX	-> buffer
  9598                                  GOTCOM:
  9599 000002C3 8A0E[BC88]              	mov	cl,[UCOMBUF]
  9600 000002C7 30ED                    	xor	ch,ch
  9601 000002C9 83C103                  	add	cx,3
  9602 000002CC BE[BC88]                	mov	si,UCOMBUF
  9603 000002CF BF[3F89]                	mov	di,COMBUF
  9604 000002D2 F3A4                    	rep	movsb		; Transfer it to the cooked buffer
  9605                                  DOCOM:
  9606 000002D4 E82223                  	call	CRLF2
  9607                                  DOCOM1:
  9608 000002D7 E8A626                  	call	PRESCAN		; Cook the input buffer
  9609 000002DA 7406                    	jz	short NOPIPEPROC
  9610 000002DC E9892A                  	jmp	PIPEPROCSTRT	; Fire up the pipe
  9611                                  
  9612                                  NULLCOMJ:
  9613 000002DF E9FA00                  	jmp	NULLCOM
  9614                                  
  9615                                  NOPIPEPROC:
  9616 000002E2 E88D2D                  	call	PARSELINE
  9617 000002E5 730B                    	jnb	short OKPARSE	; user error? or maybe we goofed?
  9618                                  BADPARSE:
  9619 000002E7 0E                      	push	cs
  9620 000002E8 1F                      	pop	ds
  9621 000002E9 BA[987F]                	mov	dx,BADNAM_PTR	; 31/01/2023
  9622 000002EC E84C4B                  	call	std_eprintf
  9623 000002EF E912FE                  	jmp	TCOMMAND
  9624                                  
  9625                                  OKPARSE:
  9626                                  	;test	byte [ARGV0_ARG_FLAGS],2
  9627                                  	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
  9628                                  	; 01/02/2023
  9629 000002F2 F606[718E]02            	test	byte [ARG+ARGV_ELE.argflags],2
  9630 000002F7 75EE                    	jnz	short BADPARSE	; ambiguous commands not allowed
  9631                                  	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  9632 000002F9 833E[2F91]00            	cmp	word [ARG+ARG_UNIT.argvcnt],0
  9633 000002FE 74DF                    	jz	short NULLCOMJ
  9634                                  	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  9635 00000300 833E[748E]00            	cmp	word [ARG+ARGV_ELE.arglen],0
  9636 00000305 74D8                    	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  9637                                  
  9638 00000307 BE[4189]                	mov	si,COMBUF+2
  9639 0000030A BF[6A8B]                	mov	di,IDLEN
  9640                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9641                                  				; Make FCB with blank scan-off
  9642                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9643 0000030D B80129                  	mov	ax,2901h
  9644 00000310 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9645                                  			; DS:SI	-> string to parse
  9646                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9647                                  			; AL = bit mask	to control parsing
  9648                                  	;mov	bx,[ARG_ARGV]
  9649 00000312 8B1E[6F8E]              	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  9650 00000316 807F013A                	cmp	byte [bx+1],':'	; was a drive specified?
  9651 0000031A 751B                    	jne	short DRVGD	; no, use default of zero...
  9652 0000031C 8A17                    	mov	dl,[bx]		; pick-up drive letter
  9653                                  	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  9654                                  	;and	dl,~20h
  9655 0000031E 80E2DF                  	and	dl,0DFh		; uppercase the sucker
  9656                                  	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  9657                                  	; 31/01/2023
  9658 00000321 80EA41                  	sub	dl,'A'
  9659 00000324 3CFF                    	cmp	al,-1		; See what PARSE said about our drive letter.
  9660 00000326 740C                    	je	short DRVBADJ	; It was invalid.
  9661                                  	;mov	di,[ARGV0_ARGSTARTEL]
  9662 00000328 8B3E[728E]              	mov	di,[ARG+ARGV_ELE.argstartel]
  9663 0000032C 803D00                  	cmp	byte [di],0	; is there actually a command there?
  9664 0000032F 7506                    	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  9665 00000331 E9CCFD                  	jmp	SETDRV		; and set drive to new drive spec
  9666                                  DRVBADJ:
  9667 00000334 E94B25                  	jmp	DRVBAD
  9668                                  DRVGD:
  9669 00000337 8A05                    	mov	al,[di]
  9670 00000339 A2[008B]                	mov	[SPECDRV],al
  9671 0000033C B020                    	mov	al,' '
  9672 0000033E B90900                  	mov	cx,9
  9673 00000341 47                      	inc	di
  9674 00000342 F2AE                    	repne	scasb		; Count number of letters in command name
  9675 00000344 B008                    	mov	al,8
  9676 00000346 28C8                    	sub	al,cl
  9677 00000348 A2[6A8B]                	mov	[IDLEN],al	; IDLEN is truly the length
  9678 0000034B BF8100                  	mov	di,81h
  9679 0000034E 56                      	push	si
  9680 0000034F BE[4189]                	mov	si,COMBUF+2	; Skip over all leading delims
  9681 00000352 E8B122                  	call	scanoff
  9682                                  
  9683                                  	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9684                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h
  9685                                  
  9686                                  	; MSDOS 6.0
  9687                                  ;SR;
  9688                                  ; We are going to skip over the first char always. The logic is that the
  9689                                  ;command tail can never start from the first character. The code below is 
  9690                                  ;trying to figure out the command tail and copy it to the command line 
  9691                                  ;buffer in the PSP. However, if the first character happens to be a switch
  9692                                  ;character and the user given command line is a full 128 bytes, we try to
  9693                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  9694                                  ;char overwrites the code and leads to a crash on future commands.
  9695                                  
  9696 00000355 46                      	inc	si ;  MSDOS 6.0
  9697                                  DO_SKIPCOM:
  9698 00000356 AC                      	lodsb			; move command line pointer over
  9699 00000357 E8B422                  	call	DELIM		; pathname -- have to do it ourselves
  9700 0000035A 740A                    	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  9701 0000035C 3C0D                    	cmp	al,0Dh		; can't always depend on argv[0].arglen
  9702 0000035E 7406                    	jz	short DO_SKIPPED ; to be the same length as the user-
  9703 00000360 3A06[E48A]              	cmp	al,[SWITCHAR]	; specified command string
  9704 00000364 75F0                    	jnz	short DO_SKIPCOM 
  9705                                  DO_SKIPPED:
  9706 00000366 4E                      	dec	si
  9707 00000367 31C9                    	xor	cx,cx
  9708                                  COMTAIL:
  9709 00000369 AC                      	lodsb
  9710 0000036A AA                      	stosb			; Move command tail to 80h
  9711 0000036B 3C0D                    	cmp	al,0Dh
  9712 0000036D E0FA                    	loopne	COMTAIL
  9713 0000036F 4F                      	dec	di
  9714 00000370 89FD                    	mov	bp,di
  9715 00000372 F6D1                    	not	cl
  9716 00000374 880E8000                	mov	[80h],cl
  9717 00000378 5E                      	pop	si
  9718                                  ;-----
  9719                                  ; Some of these comments are sadly at odds with this brave new code.
  9720                                  ;-----
  9721                                  ; If the command has 0 parameters must check here for
  9722                                  ; any switches that might be present.
  9723                                  ; SI -> first character after the command.
  9724                                  
  9725                                  	;mov	di,arg.argv[0].argsw_word
  9726                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9727 00000379 8B3E[768E]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9728 0000037D 893E[F78A]              	mov	[COMSW],di	; ah yes, the old addressing mode problem...
  9729                                  	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  9730                                  				; s = argv[1];
  9731                                  	;mov	si,[ARGV1_ARGPOINTER]
  9732 00000381 8B36[7A8E]              	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  9733 00000385 09F6                    	or	si,si		;   if (s == NULL)
  9734 00000387 7502                    	jnz	short DOPARSE	;	s = bp; (buffer end)
  9735 00000389 89EE                    	mov	si,bp
  9736                                  DOPARSE:
  9737 0000038B BF5C00                  	mov	di,FCB ; 5Ch
  9738                                  	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9739                                  	; 01/02/2023
  9740 0000038E B80129                  	mov	ax,2901h
  9741                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9742 00000391 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9743                                  			; DS:SI	-> string to parse
  9744                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9745                                  			; AL = bit mask	to control parsing
  9746 00000393 A2[F58A]                	mov	[PARM1],al	; Save result of parse
  9747                                  	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  9748                                  	;mov	di,[ARGV1_ARGSW_WORD]
  9749 00000396 8B3E[818E]              	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  9750 0000039A 893E[F98A]              	mov	[ARG1S],di
  9751                                  	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  9752                                  				; s = argv[2];
  9753                                  	;mov	si,[ARGV2_ARGPOINTER]
  9754 0000039E 8B36[858E]              	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  9755 000003A2 09F6                    	or	si,si		; if (s == NULL)
  9756 000003A4 7502                    	jnz	short DOPARSE2
  9757 000003A6 89EE                    	mov	si,bp		;     s = bp; (buffer end)
  9758                                  DOPARSE2:			
  9759 000003A8 BF6C00                  	mov	di,FCB+10h ; 6Ch
  9760                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9761 000003AB B80129                  	mov	ax,2901h
  9762                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9763 000003AE CD21                    	int	21h	; DOS -	PARSE FILENAME
  9764                                  			; DS:SI	-> string to parse
  9765                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9766                                  			; AL = bit mask	to control parsing
  9767 000003B0 A2[F68A]                	mov	[PARM2],al	; Save result
  9768                                  	;mov	di,[ARGV2_ARGSW_WORD]
  9769                                  	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  9770 000003B3 8B3E[8C8E]              	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  9771 000003B7 893E[FB8A]              	mov	[ARG2S],di
  9772                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9773                                  	;mov	di,arg.argv[0].argsw_word
  9774 000003BB 8B3E[768E]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9775 000003BF F7D7                    	not	di		; ARGTS doesn't include the flags
  9776                                  	;and	di,[ARG_ARGSWINFO] ; from COMSW...
  9777                                  	;and	di,arg.argswinfo	
  9778 000003C1 233E[3191]              	and	di,[ARG+ARG_UNIT.argswinfo]
  9779 000003C5 893E[FD8A]              	mov	[ARGTS],di
  9780                                  
  9781 000003C9 A0[6A8B]                	mov	al,[IDLEN]
  9782 000003CC 8A16[008B]              	mov	dl,[SPECDRV]
  9783 000003D0 08D2                    	or	dl,dl		; if a drive was specified...
  9784 000003D2 7505                    	jnz	short EXTERNALJ1 ; it MUST be external, by this time
  9785 000003D4 FEC8                    	dec	al		; (I don't know why -- old code did it)
  9786 000003D6 E9FC23                  	jmp	FNDCOM		; otherwise, check internal com table
  9787                                  EXTERNALJ1:
  9788 000003D9 E9FE24                  	jmp	EXTERNAL
  9789                                  NULLCOM:
  9790 000003DC 8E1E[E08A]              	mov	ds,[RESSEG]
  9791 000003E0 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
  9792 000003E6 7405                    	jz	short NOSETFLAG	  ;G only set flag if in batch
  9793 000003E8 C606[B501]01            	mov	byte [NullFlag],1 ;G set flag to indicate no command
  9794                                  	;mov	byte [NullFlag],nullcommand ; 1
  9795                                  NOSETFLAG:
  9796 000003ED 833E[A601]FF            	cmp	word [SingleCom],0FFFFh ; -1
  9797 000003F2 7403                    	je	short EXITJ
  9798 000003F4 E9E9FD                  	jmp	GETCOM
  9799                                  EXITJ:
  9800 000003F7 E92DFD                  	jmp	_$EXITPREP
  9801                                  
  9802                                  ;============================================================================
  9803                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  9804                                  ;============================================================================
  9805                                  ; 12/10/2018 - Retro DOS v3.0
  9806                                  
  9807                                  ; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM
  9808                                  
  9809                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  9810                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  9811                                  ;   there is a header that describes a block of rom program.  This header
  9812                                  ;   contains information needed to initialize a module and to provide PCDOS
  9813                                  ;   with a set of reserved names for execution.
  9814                                  ;
  9815                                  ;   This header has the following format:
  9816                                  ;
  9817                                  ;   rom_header	STRUC
  9818                                  ;	Signature1  DB	55h
  9819                                  ;	Signature2  DB	AAh
  9820                                  ;	rom_length  DB	?		; number of 512 byte pieces
  9821                                  ;	init_jmp    DB	3 dup (?)
  9822                                  ;	name_list   name_struc <>
  9823                                  ;   rom_header	ENDS
  9824                                  ;
  9825                                  ;   name_struc	STRUC
  9826                                  ;	name_len    DB	?
  9827                                  ;	name_text   DB	? DUP (?)
  9828                                  ;	name_jmp    DB	3 DUP (?)
  9829                                  ;   name_struc	ENDS
  9830                                  ;
  9831                                  ;   The name list is a list of names that are reserved by a particular section
  9832                                  ;   of a module.  This list of names is terminated by a null name (length
  9833                                  ;   is zero).
  9834                                  ;
  9835                                  ;   Consider now, the PCDOS action when a user enters a command:
  9836                                  ;
  9837                                  ;	COMMAND.COM has control.
  9838                                  ;	o   If location FFFFEh has FDh then
  9839                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  9840                                  ;		    by AAh, stop scan if we get above or = F0000H
  9841                                  ;	o	When we've found one, compare the name entered by the user
  9842                                  ;		    with the one found in the rom.  If we have a match, then
  9843                                  ;		    set up the environment for execution and do a long jump
  9844                                  ;		    to the near jump after the found name.
  9845                                  ;	o	If no more names in the list, then continue scanning the module
  9846                                  ;		    for more 55h followed by AAh.
  9847                                  ;	o   We get to this point only if there is no matching name in the
  9848                                  ;		rom.  We now look on disk for the command.
  9849                                  ;
  9850                                  ;   This gives us the flexibility to execute any rom cartridge without having
  9851                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  9852                                  ;   want to be invisible to the DOS should not have any names in their lists
  9853                                  ;   (i.e. they have a single null name).
  9854                                  ;
  9855                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  9856                                  ;   Clearly this version will be available on disk.  How does a user actually
  9857                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  9858                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  9859                                  ;   solution:
  9860                                  ;
  9861                                  ;   o	Keep things consistent and force the user to have his software named
  9862                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  9863                                  
  9864                                  struc ROM_HEADER
  9865 00000000 ??                          .signature1: resb 1
  9866 00000001 ??                          .signature2: resb 1
  9867 00000002 ??                          .rom_length: resb 1
  9868 00000003 ??????                      .init_jmp:	 resb 3
  9869 00000006 ??                          .name_list:	 resb 1
  9870                                      .size:
  9871                                  endstruc
  9872                                  
  9873                                  struc NAME_STRUC
  9874 00000000 ??                          .name_len:	resb 1
  9875 00000001 ??                          .name_text:	resb 1
  9876 00000002 ??????                      .name_jmp:	resb 3
  9877                                      .size:	
  9878                                  endstruc
  9879                                  
  9880                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  9881                                  
  9882                                  ; =============== S U B	R O U T	I N E =======================================
  9883                                  
  9884                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  9885                                  
  9886                                  ; 05/02/2023
  9887                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh
  9888                                  
  9889                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  9890                                  
  9891                                  ROM_SCAN:
  9892 000003FA 06                      	push	es
  9893 000003FB 56                      	push	si
  9894 000003FC 57                      	push	di
  9895 000003FD 51                      	push	cx
  9896 000003FE 50                      	push	ax
  9897 000003FF 53                      	push	bx
  9898                                  
  9899                                  	; check for PC Jr signature in rom
  9900                                  
  9901 00000400 B800F0                  	mov	ax,0F000h
  9902 00000403 8EC0                    	mov	es,ax
  9903 00000405 26803EFEFFFD            	cmp	byte [es:0FFFEh],0FDh
  9904 0000040B 7408                    	je	short SCAN_IT
  9905                                  NO_ROM:
  9906 0000040D F8                      	clc
  9907                                  ROM_RET:
  9908 0000040E 5B                      	pop	bx
  9909 0000040F 58                      	pop	ax
  9910 00000410 59                      	pop	cx
  9911 00000411 5F                      	pop	di
  9912 00000412 5E                      	pop	si
  9913 00000413 07                      	pop	es
  9914 00000414 C3                      	retn
  9915                                  
  9916                                  	; start scanning at C000h
  9917                                  SCAN_IT:
  9918 00000415 B800C0                  	mov	ax,0C000h
  9919                                  SCAN_ONE:
  9920 00000418 8EC0                    	mov	es,ax
  9921 0000041A 31FF                    	xor	di,di
  9922                                  
  9923                                  	; check for a valid header
  9924                                  SCAN_MODULE:
  9925 0000041C 26813D55AA              	cmp	word [es:di],0AA55h
  9926 00000421 740A                    	je	short SCAN_LIST
  9927 00000423 058000                  	add	ax,80h
  9928                                  SCAN_END:
  9929 00000426 3D00F0                  	cmp	ax,0F000h
  9930 00000429 72ED                    	jb	short SCAN_ONE
  9931 0000042B EBE0                    	jmp	short NO_ROM
  9932                                  
  9933                                  	; trundle down list of names
  9934                                  SCAN_LIST:
  9935                                  	;mov	bl,[es:di+2]	; number of 512-byte jobbers
  9936 0000042D 268A5D02                	mov	bl,[es:di+ROM_HEADER.rom_length]
  9937 00000431 30FF                    	xor	bh,bh		; nothing in the high byte
  9938 00000433 D1E3                    	shl	bx,1
  9939 00000435 D1E3                    	shl	bx,1		; number of paragraphs
  9940 00000437 83C37F                  	add	bx,7Fh
  9941 0000043A 83E380                  	and	bx,0FF80h	; round to 2k	
  9942                                  	;mov	di,6
  9943                                  	; 05/05/2023
  9944 0000043D BF0600                  	mov	di,ROM_HEADER.name_list
  9945                                  	;nop
  9946                                  SCAN_NAME:
  9947 00000440 268A0D                  	mov	cl,[es:di]	; length of name
  9948 00000443 47                      	inc	di		; point to name
  9949 00000444 30ED                    	xor	ch,ch
  9950 00000446 09C9                    	or	cx,cx		; zero length name
  9951 00000448 7504                    	jnz	short SCAN_TEST	; nope... compare
  9952 0000044A 01D8                    	add	ax,bx		; yep, skip to next block
  9953 0000044C EBD8                    	jmp	short SCAN_END
  9954                                  
  9955                                  	; compare a single name
  9956                                  SCAN_TEST:
  9957 0000044E 89D6                    	mov	si,dx
  9958 00000450 46                      	inc	si
  9959 00000451 F3A6                    	repe cmpsb		 ; compare name
  9960 00000453 7407                    	jz	short SCAN_FOUND ; success!
  9961                                  SCAN_NEXT:
  9962 00000455 01CF                    	add	di,cx		; failure, next name piece
  9963 00000457 83C703                  	add	di,3
  9964 0000045A EBE4                    	jmp	short SCAN_NAME
  9965                                  
  9966                                  	; found a name. save entry location
  9967                                  SCAN_FOUND:	
  9968 0000045C 803C3F                  	cmp	byte [si],'?'
  9969 0000045F 7405                    	je	short SCAN_SAVE
  9970 00000461 803C20                  	cmp	byte [si],' '
  9971 00000464 75EF                    	jne	short SCAN_NEXT
  9972                                  SCAN_SAVE:
  9973 00000466 2E8C06[E58C]            	mov	[cs:ROM_CS],es
  9974 0000046B 2E893E[E38C]            	mov	[cs:ROM_IP],di
  9975 00000470 F9                      	stc
  9976 00000471 EB9B                    	jmp	short ROM_RET
  9977                                  
  9978                                  ; ---------------------------------------------------------------------------
  9979                                  
  9980                                  ; execute a rom-placed body of code. allocate largest block
  9981                                  
  9982                                  ROM_EXEC:
  9983 00000473 BBFFFF                  	mov	bx,0FFFFh
  9984                                  	; 05/02/2023
  9985 00000476 B448                    	mov	ah,48h
  9986                                  	;mov	ah,ALLOC ; 48h
  9987 00000478 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
  9988                                  			; BX = number of 16-byte paragraphs desired
  9989 0000047A B448                    	mov	ah,48h
  9990                                  	;mov	ah,ALLOC ; 48h
  9991 0000047C CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
  9992                                  			; BX = number of 16-byte paragraphs desired
  9993 0000047E 53                      	push	bx
  9994 0000047F 50                      	push	ax
  9995                                  
  9996                                  	; set terminate addresses
  9997                                  
  9998 00000480 B82225                  	mov	ax,2522h
  9999                                  	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
 10000                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
 10001 00000483 1E                      	push	ds
 10002 00000484 2E8E1E[E08A]            	mov	ds,[cs:RESSEG]
 10003                                  	;mov	dx,offset RESGROUP:EXEC_WAIT
 10004                                  	;mov	dx,131h ; MSDOS 3.3
 10005                                  	; 05/02/2023
 10006                                  	;mov	dx,0D6Bh ; MSDOS 5.0
 10007 00000489 BA[390C]                	mov	dx,Exec_Wait
 10008 0000048C CD21                    	int	21h	; DOS -	SET INTERRUPT VECTOR
 10009                                  			; AL = interrupt number
 10010                                  			; DS:DX	= new vector to	be used	for specified interrupt
 10011 0000048E 8CDA                    	mov	dx,ds
 10012 00000490 8EC2                    	mov	es,dx
 10013 00000492 1F                      	pop	ds
 10014                                  		
 10015                                  	; and create program header and dup all jfn's
 10016                                  
 10017 00000493 5A                      	pop	dx
 10018 00000494 B455                    	mov	ah,55h
 10019                                  	;mov	ah,DUP_PDB ; 55h
 10020 00000496 CD21                    	int	21h	; DOS -	2+ internal - CREATE PSP
 10021                                  			; DX = segment number at which to set up PSP
 10022                                  			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
 10023                                  		
 10024                                  	; set up dma address
 10025                                  
 10026 00000498 8EDA                    	mov	ds,dx
 10027 0000049A BA8000                  	mov	dx,80h
 10028 0000049D B41A                    	mov	ah,1Ah
 10029                                  	;mov	ah,Set_DMA ; 1Ah
 10030 0000049F CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 10031                                  			; DS:DX	-> disk	transfer buffer
 10032                                  
 10033                                  	; copy in environment info
 10034                                  
 10035 000004A1 26A1[3F03]              	mov	ax,[es:EnvirSeg]
 10036                                  	;mov	[2Ch],ax
 10037 000004A5 A32C00                  	mov	[PDB.ENVIRON],ax
 10038                                  
 10039                                  	; set up correct size of block
 10040                                  
 10041 000004A8 5B                      	pop	bx		; BX has size, DS has segment
 10042 000004A9 8CDA                    	mov	dx,ds
 10043 000004AB 01DA                    	add	dx,bx
 10044                                  	;mov	[2],dx
 10045 000004AD 89160200                	mov	[PDB.BLOCK_LEN],dx
 10046                                  
 10047                                  	; change ownership of block
 10048                                  
 10049 000004B1 8CDA                    	mov	dx,ds
 10050 000004B3 4A                      	dec	dx
 10051 000004B4 8EDA                    	mov	ds,dx
 10052 000004B6 42                      	inc	dx	
 10053                                  	;mov	[1],dx
 10054 000004B7 89160100                	mov	[ARENA.owner],dx
 10055 000004BB 8EDA                    	mov	ds,dx
 10056                                  
 10057                                  	; set up correct stack
 10058                                  
 10059 000004BD 81FB0010                	cmp	bx,1000h
 10060 000004C1 7202                    	jb	short GOT_STACK
 10061 000004C3 31DB                    	xor	bx,bx
 10062                                  GOT_STACK:
 10063 000004C5 B104                    	mov	cl,4
 10064 000004C7 D3E3                    	shl	bx,cl
 10065 000004C9 8CDA                    	mov	dx,ds
 10066 000004CB 8ED2                    	mov	ss,dx
 10067 000004CD 89DC                    	mov	sp,bx
 10068 000004CF 31C0                    	xor	ax,ax
 10069 000004D1 50                      	push	ax
 10070                                  
 10071                                  	; set up initial registers and go to the guy
 10072                                  
 10073 000004D2 F7D0                    	not	ax
 10074 000004D4 2EFF36[E58C]            	push	word [cs:ROM_CS]
 10075 000004D9 2EFF36[E38C]            	push	word [cs:ROM_IP]
 10076 000004DE 8EC2                    	mov	es,dx
 10077 000004E0 CB                      	retf	; far return
 10078                                  
 10079                                  ;============================================================================
 10080                                  ; TBATCH.ASM, MSDOS 6.0, 1991
 10081                                  ;============================================================================
 10082                                  ; 12/10/2018 - Retro DOS v3.0
 10083                                  
 10084                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
 10085                                  
 10086                                  ; =============== S U B	R O U T	I N E =======================================
 10087                                  
 10088                                  ;Break	<PromptBat - Open or wait for batch file>
 10089                                  
 10090                                  ; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10091                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h
 10092                                  
 10093                                  ; Open the batch file. If we cannot find the batch file. If the media is
 10094                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
 10095                                  ; file. Leave segment registers alone.
 10096                                  
 10097                                  PROMPTBAT:
 10098 000004E1 E84E08                  	call	BATOPEN
 10099 000004E4 7201                    	jc	short PROMPTBAT1
 10100 000004E6 C3                      	retn
 10101                                  PROMPTBAT1:
 10102                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10103                                  	; MSDOS 6.0 COMMAND.COM
 10104 000004E7 83FA02                  	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
 10105 000004EA 740A                    	je	short BAT_REMCHECK	;AN022;
 10106 000004EC 83FA03                  	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
 10107 000004EF 7405                    	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
 10108                                  	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
 10109 000004F1 E83500                  	call	output_batch_name
 10110 000004F4 EB13                    	jmp	short BATDIE		;AN022;
 10111                                  
 10112                                  	; 05/02/2023
 10113                                  	; MSDOS 3.3 COMMAND.COM
 10114                                  	;cmp	dx,ACCDENPTR
 10115                                  	;jz	short BATDIE
 10116                                  
 10117                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10118                                  BAT_REMCHECK:				;AN022; Go see if media is removable
 10119 000004F6 2EFF1E[EA8A]            	call	far [cs:RCH_ADDR]	; DX has error number
 10120 000004FB 7417                    	jz	short ASKFORBAT		; Media is removable
 10121                                  
 10122                                  ; The media is not changeable. Turn everything off.
 10123                                  
 10124 000004FD E8460B                  	call	FOROFF
 10125 00000500 E8A22A                  	call	PipeOff
 10126 00000503 A2[AB01]                	mov	[IfFlag],al	; No If in progress.	
 10127 00000506 BA[927F]                	mov	dx,BADBAT_PTR
 10128                                  BATDIE:
 10129 00000509 E8F303                  	call	BATCHOFF
 10130 0000050C 0E                      	push	cs
 10131 0000050D 1F                      	pop	ds
 10132                                  	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
 10133                                  	; 05/02/2023
 10134 0000050E E82A49                  	call	std_eprintf	; MSDOS 6.0
 10135                                  	;call	STD_PRINTF	; MSDOS 3.3
 10136                                  
 10137                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
 10138                                  
 10139 00000511 E9F0FB                  	jmp	TCOMMAND
 10140                                  
 10141                                  ; Ask the user to reinsert the batch file
 10142                                  
 10143                                  ASKFORBAT:
 10144 00000514 1E                      	push	ds
 10145 00000515 0E                      	push	cs
 10146 00000516 1F                      	pop	ds
 10147                                  
 10148                                  	; MSDOS 6.0
 10149                                  	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
 10150 00000517 BA[957F]                	mov	dx,NEEDBAT_PTR
 10151                                  	;invoke	std_eprintf	 	;Prompt for batch file on stderr
 10152                                  	; 05/02/2023
 10153 0000051A E81E49                  	call	std_eprintf
 10154                                  	;mov	dx,offset trangroup:pausemes_ptr
 10155 0000051D BA[0780]                	mov	dx,PAUSEMES_PTR
 10156                                  	;invoke std_eprintf		;AN000; get second part of message
 10157 00000520 E81849                  	call	std_eprintf
 10158                                  					;AN000; print it to stderr
 10159                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10160                                  	;call	STD_EPRINTF
 10161 00000523 E82E00                  	call	GETKEYSTROKE
 10162 00000526 1F                      	pop	ds
 10163 00000527 EBB8                    	jmp	short PROMPTBAT
 10164                                  
 10165                                  
 10166                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10167                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah
 10168                                  
 10169                                  	; MSDOS 6.0
 10170                                  ;****************************************************************
 10171                                  ;*
 10172                                  ;* ROUTINE:	Output_batch_name
 10173                                  ;*
 10174                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
 10175                                  ;*
 10176                                  ;* INPUT:	DX - extended error number
 10177                                  ;*
 10178                                  ;* OUTPUT:	Ready to call print routine
 10179                                  ;*
 10180                                  ;****************************************************************
 10181                                  ;
 10182                                  ;public	output_batch_name		;AN022;
 10183                                  
 10184                                  output_batch_name:	;proc near	;AN022;
 10185                                  
 10186 00000529 1E                      	push	ds			;AN022; save resident segment
 10187 0000052A 8E1E[4C01]              	mov	ds,[Batch]		;AN022; get batch file segment
 10188                                  	;assume	DS:nothing		;AN022;
 10189                                  	;;mov	SI,BatFile		;AN022; get offset of batch file
 10190                                  	; 05/02/2023
 10191                                  	;mov	si,20h
 10192                                  	; 24/04/2023
 10193 0000052E BE2000                  	mov	si,BATCHSEGMENT.BatFile
 10194                                  	;invoke	dstrlen 		;AN022; get length of string
 10195 00000531 E86927                  	call	dstrlen
 10196                                  	;mov	di,offset Trangroup:bwdbuf
 10197                                  					;AN022; target for batch name
 10198 00000534 BF[E98B]                	mov	di,BWDBUF
 10199 00000537 F3A4                    	rep	movsb			;AN022; move the name
 10200                                  
 10201 00000539 0E                      	push	cs			;AN022; get local segment
 10202 0000053A 1F                      	pop	ds			;AN022;
 10203                                  	;assume	DS:trangroup		;AN022;
 10204                                  	; 05/02/2023
 10205 0000053B 8916[757F]              	mov	[extend_buf_ptr],dx	;AN022; put message number in block
 10206                                  	;mov	byte [msg_disp_class],1
 10207 0000053F C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class
 10208                                  					;AN022; set up extended error msg class
 10209                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 10210 00000544 BA[757F]                	mov	dx,extend_buf_ptr	
 10211                                  					;AN022; get extended message pointer
 10212                                  	;mov	string_ptr_2,offset trangroup:bwdbuf 
 10213 00000547 C706[D08C][E98B]        	mov	word [string_ptr_2],BWDBUF	
 10214                                  					;AN022; point to substitution
 10215                                  	;mov	byte [extend_buf_sub],1
 10216 0000054D C606[777F]01            	mov	byte [extend_buf_sub],one_subst
 10217                                  					;AN022; set up for one subst
 10218 00000552 1F                      	pop	ds			;AN022; restore data segment
 10219 00000553 C3                      	retn				;AN022; return
 10220                                  
 10221                                  ;output_batch_name    endp		;AN022;
 10222                                  
 10223                                  
 10224                                  ; =============== S U B	R O U T	I N E =======================================
 10225                                  
 10226                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
 10227                                  
 10228                                  ; Read the next keystroke. Since there may be several characters in the queue
 10229                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
 10230                                  ; AFTER waiting.
 10231                                  
 10232                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10233                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h
 10234                                  
 10235                                  GETKEYSTROKE:
 10236                                  	; 05/02/2023
 10237                                  	; MSDOS 3.3
 10238                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
 10239                                  	;;mov	ax,0C08h
 10240                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
 10241                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10242                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10243                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10244                                  	;;mov	ax,0C00h
 10245                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
 10246                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10247                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10248                                  	;retn
 10249                                  
 10250                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10251                                  	; MSDOS 6.0
 10252 00000554 52                      	push	dx			;AN000;  3/3/KK
 10253                                  	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
 10254                                  					;AN000;  3/3/KK
 10255 00000555 B80263                  	mov	ax,6302h
 10256 00000558 CD21                    	int	21h			;AN000;  3/3/KK
 10257                                  		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
 10258                                  	
 10259 0000055A 52                      	push	dx			;AN000;  save interim state 3/3/KK
 10260                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10261                                  					;AN000;  3/3/KK
 10262 0000055B B80163                  	mov	ax,6301h
 10263 0000055E B201                    	mov	dl,1
 10264                                  	;mov	dl,InterimMode		;AN000;  3/3/KK
 10265 00000560 CD21                    	int	21h			;AN000;  3/3/KK
 10266                                  		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
 10267                                  		; DL = new mode
 10268                                  		; 00h return only full characters on DOS keyboard input functions
 10269                                  		; 01h return partially-formed characters also
 10270                                  	
 10271                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
 10272 00000562 B8080C                  	mov	ax,0C08h
 10273 00000565 CD21                    	int	21h			; Get character with KB buffer flush
 10274                                  		; DOS - CLEAR KEYBOARD BUFFER
 10275                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10276                                  
 10277                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10278 00000567 B8000C                  	mov	ax,0C00h
 10279 0000056A CD21                    	int	21h
 10280                                  		; DOS - CLEAR KEYBOARD BUFFER
 10281                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10282                                  
 10283                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10284                                  					;AN000;  3/3/KK
 10285 0000056C B80163                  	mov	ax,6301h
 10286 0000056F 5A                      	pop	dx			;AN000;  restore interim state 3/3/KK
 10287 00000570 CD21                    	int	21h			;AN000;  3/3/KK
 10288 00000572 5A                      	pop	dx			;AN000;  3/3/KK
 10289                                  	
 10290 00000573 C3                      	retn
 10291                                  
 10292                                  ; =============== S U B	R O U T	I N E =======================================
 10293                                  
 10294                                  ; Break	<ReadBat - read 1 line from batch file>
 10295                                  
 10296                                  ; ReadBat - read a single line from the batch file. 
 10297                                  ; Perform all substitutions as appropriate.
 10298                                  
 10299                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10300                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h
 10301                                  
 10302                                  READBAT:
 10303                                  	;ASSUME	DS:ResGroup,ES:TranGroup
 10304                                  		
 10305                                  	;mov	byte [Suppress],1
 10306                                  				; initialize line suppress status
 10307 00000574 C606[A101]01            	mov	byte [Suppress],YES_ECHO 
 10308 00000579 F606[9601]FF            	test	byte [Batch_Abort],-1 ; 0FFh
 10309 0000057E 751F                    	jnz	short TRYING_TO_ABORT
 10310 00000580 C606[9501]01            	mov	byte [In_Batch],1 ; set flag to indicate batch job
 10311                                  
 10312                                  	; MSDOS 6.0
 10313                                  
 10314                                  ;M037; Start of changes
 10315                                  ; We check here if we have set the flag indicating that the batchfile is at
 10316                                  ;EOF. In this case, we do not want to continue with the normal processing.
 10317                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
 10318                                  ;batch file gets closed etc. and then return as if everything is done.
 10319                                  
 10320                                  	; 05/02/2023
 10321 00000585 1E                      	push	ds
 10322 00000586 8E1E[4C01]              	mov	ds,[Batch]
 10323                                  	;cmp	byte [2],0
 10324 0000058A 803E020000              	cmp	byte [BATCHSEGMENT.BatchEOF],0
 10325                                  				; are we at EOF in batchfile
 10326 0000058F 1F                      	pop	ds
 10327 00000590 740A                    	jz	short CONTBAT	; no, continue normal processing
 10328                                  	;invoke	GetBatByt	; frees up batchseg
 10329 00000592 E8D903                  	call	GETBATBYT
 10330 00000595 26A2[4189]              	mov	[es:COMBUF+2],al
 10331                                  				; stuff CR into command buffer
 10332                                  				; as a dummy command
 10333                                  	;;invoke CrLf2		; print a CR-LF
 10334                                  	;call	CRLF2
 10335                                  	;;return		; done batch processing
 10336                                  	;retn
 10337                                  	; 24/04/2023
 10338 00000599 E95D20                  	jmp	CRLF2
 10339                                  
 10340                                  ;M037; End of changes
 10341                                  		
 10342                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10343                                  CONTBAT:
 10344 0000059C E842FF                  	call	PROMPTBAT
 10345                                  
 10346                                  TRYING_TO_ABORT:
 10347 0000059F BF[4189]                	mov	di,COMBUF+2
 10348                                  
 10349                                  ; Save position and try to scan for first non delimiter.
 10350                                  
 10351                                  TESTNOP:
 10352 000005A2 8CD8                    	mov	ax,ds
 10353 000005A4 8E1E[4C01]              	mov	ds,[Batch]
 10354 000005A8 FF360800                	push	word [BATCHSEGMENT.BatSeek]
 10355 000005AC FF360A00                	push	word [BATCHSEGMENT.BatSeek+2]
 10356                                  				; save current location.
 10357 000005B0 8ED8                    	mov	ds,ax
 10358 000005B2 E85106                  	call	SKIPDELIM	; skip to first non-delim
 10359                                  
 10360                                  ; If the first non-delimiter is not a : (label), we reseek back to the
 10361                                  ; beginning and read the line.
 10362                                  
 10363 000005B5 3C3A                    	cmp	al,':'		; is it a label?
 10364 000005B7 59                      	pop	cx
 10365 000005B8 5A                      	pop	dx		; restore position in bat file
 10366 000005B9 7431                    	jz	short NOPLINE	; yes, resync everything.
 10367 000005BB F706[4C01]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10368 000005C1 7438                    	jz	short RDBAT	; no, go read batch file
 10369                                  
 10370                                  	;cmp	al,'@'
 10371 000005C3 3C40                    	cmp	al,No_Echo_Char	; see if user wants to suppress line
 10372 000005C5 7507                    	jne	short SET_BAT_POS ; no - go and set batch file position
 10373                                  	;mov	byte [Suppress],0
 10374 000005C7 C606[A101]00            	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
 10375 000005CC EB2D                    	jmp	short RDBAT	; go read batch file
 10376                                  	;nop
 10377                                  SET_BAT_POS:
 10378 000005CE 1E                      	push	ds
 10379 000005CF 8E1E[4C01]              	mov	ds,[Batch]
 10380                                  	;mov	[8],dx
 10381 000005D3 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
 10382                                  	;mov	[10],cx
 10383 000005D7 890E0A00                	mov	[BATCHSEGMENT.BatSeek+2],cx
 10384 000005DB 1F                      	pop	ds
 10385                                  	;;mov	ax,(LSEEK SHL 8) + 0
 10386                                  	; 05/02/2023
 10387 000005DC B80042                  	mov	ax,4200h
 10388                                  	;mov	ax,(LSEEK*256) ; 4200h ; ; seek back
 10389 000005DF CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 10390                                  			; AL = method: offset from beginning of	file
 10391                                  	;mov	word [cs:BATBUFPOS],0FFFFh
 10392                                  	; 24/04/2023
 10393                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
 10394 000005E1 26C706[E795]FFFF        	mov	word [es:BATBUFPOS],-1; 0FFFFh
 10395                                  	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
 10396 000005E8 31C9                    	xor	cx,cx		; Initialize line length to zero
 10397 000005EA EB0F                    	jmp	short RDBAT
 10398                                  
 10399                                  	;nop
 10400                                  
 10401                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
 10402                                  ; We eat characters until a CR is seen.
 10403                                  
 10404                                  NOPLINE:
 10405 000005EC E80501                  	call	SKIPTOEOL
 10406 000005EF E87C03                  	call	GETBATBYT	; eat trailing LF
 10407                                  	;test	word [Batch],0FFFFh
 10408 000005F2 F706[4C01]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10409 000005F8 75A8                    	jnz	short TESTNOP	; no, go get another line
 10410                                  READBAT_RETN:				; Hit EOF			
 10411 000005FA C3                      	retn
 10412                                  
 10413                                  ; ---------------------------------------------------------------------------
 10414                                  
 10415                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
 10416                                  ; input, we are to consider two special cases:
 10417                                  ;
 10418                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
 10419                                  ;   %sym%	This is a symbol from the environment
 10420                                  
 10421                                  RDBAT:
 10422 000005FB E87003                  	call	GETBATBYT
 10423 000005FE 41                      	inc	cx		; Inc the line length
 10424                                  
 10425                                  	; 05/02/2023
 10426                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
 10427 000005FF E8E21D                  	call	testkanj
 10428 00000602 740C                    	jz	short RDBAT1
 10429                                  	;cmp	cx,127
 10430 00000604 83F97F                  	cmp	cx,COMBUFLEN-1
 10431 00000607 7350                    	jnb	short TOOLONG
 10432 00000609 AA                      	stosb
 10433 0000060A E86103                  	call    GETBATBYT
 10434 0000060D 41                      	inc	cx
 10435 0000060E EB0A                    	jmp	short SAVBATBYT
 10436                                  RDBAT1:
 10437 00000610 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10438 00000614 7343                    	jnb	short TOOLONG	   ; Yes - handle it, handle it
 10439                                  
 10440                                  ; See if we have a parameter character.
 10441                                  
 10442 00000616 3C25                    	cmp	al,'%'		; Check for parameter
 10443 00000618 7449                    	je	short NEEDPARM
 10444                                  
 10445                                  ; no parameter character. Store it as usual and see if we are done.
 10446                                  
 10447                                  SAVBATBYT:
 10448 0000061A AA                      	stosb			; End of line found?
 10449 0000061B 3C0D                    	cmp	al,0Dh
 10450 0000061D 75DC                    	jne	short RDBAT	; no, go for more
 10451                                  
 10452                                  ; We have read in an entire line. 
 10453                                  ; Decide whether we should echo the command line or not.
 10454                                  
 10455                                  FOUND_EOL:
 10456 0000061F 81EF[4289]              	sub	di,COMBUF+3
 10457 00000623 89F8                    	mov	ax,di		; remember that we've not counted the CR
 10458 00000625 26A2[4089]              	mov	[es:COMBUF+1],al
 10459                                  				; Set length of line
 10460 00000629 E84203                  	call	GETBATBYT	; Eat linefeed
 10461 0000062C E8EF06                  	call	BATCLOSE
 10462 0000062F 803E[A101]00            	cmp	byte [Suppress],NO_ECHO ; 0
 10463 00000634 7407                    	jz	short RESET
 10464 00000636 F606[A001]01            	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
 10465 0000063B 7504                    	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
 10466                                  RESET:
 10467 0000063D 0E                      	push	cs
 10468 0000063E 1F                      	pop	ds		; Go back to local segment
 10469 0000063F 74B9                    	jz	short READBAT_RETN ; no echoing here...
 10470                                  TRY_NEXTFLAG:
 10471 00000641 803E[B501]01            	cmp	byte [NullFlag],nullcommand ; 1
 10472                                  				;G was there a command last time?
 10473 00000646 7403                    	jz	short NO_CRLF_PRINT
 10474                                  				;G no - don't print crlf
 10475 00000648 E8AE1F                  	call	CRLF2		;G Print out prompt
 10476                                  NO_CRLF_PRINT:
 10477 0000064B E85F17                  	call	PRINT_PROMPT
 10478 0000064E 0E                      	push	cs		;G change data segment
 10479 0000064F 1F                      	pop	ds
 10480 00000650 BA[4189]                	mov	dx,COMBUF+2	; get command line for echoing
 10481 00000653 E8FC1F                  	call	CRPRINT
 10482                                  	;call	CRLF2
 10483                                  	;retn
 10484                                  	; 06/02/2023
 10485 00000656 E9A01F                  	jmp	CRLF2
 10486                                  
 10487                                  ; The line was too long. Eat remainder of input text up until the CR
 10488                                  
 10489                                  TOOLONG:
 10490 00000659 3C0D                    	cmp	al,0Dh		; Has the end of the line been reached?
 10491 0000065B 7403                    	jz	short LTLCONT	; Yes, continue
 10492 0000065D E89400                  	call	SKIPTOEOL	; Eat remainder of line	
 10493                                  LTLCONT:
 10494 00000660 AA                      	stosb			; Terminate the command
 10495 00000661 EBBC                    	jmp	short FOUND_EOL	; Go process the valid part of the line
 10496                                  
 10497                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
 10498                                  
 10499                                  NEEDPARM:
 10500 00000663 E80803                  	call	GETBATBYT	; get next character
 10501 00000666 3C25                    	cmp	al,'%'		; Check for two consecutive %
 10502 00000668 74B0                    	je	short SAVBATBYT	; if so, replace with a single %
 10503 0000066A 3C0D                    	cmp	al,0Dh		; Check for end-of-line
 10504 0000066C 74AC                    	je	short SAVBATBYT	; yes, treat it normally
 10505                                  
 10506                                  ; We have found %<something>. If the <something> is in the range 0-9, we
 10507                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
 10508                                  ; see if the <something> has a terminating % and then look up the contents
 10509                                  ; in the environment.
 10510                                  
 10511                                  PAROK:
 10512 0000066E 2C30                    	sub	al,'0'
 10513 00000670 7239                    	jb	short NEEDENV	; look for parameter in the environment
 10514 00000672 3C09                    	cmp	al,9
 10515 00000674 7735                    	ja	short NEEDENV
 10516                                  
 10517                                  ; We have found %<number>. This is taken from the parameters in the
 10518                                  ; allocated batch area.
 10519                                  
 10520 00000676 98                      	cbw
 10521 00000677 89C3                    	mov	bx,ax		; move index into AX
 10522 00000679 D1E3                    	shl	bx,1		; convert word index into byte ptr
 10523 0000067B 06                      	push	es
 10524 0000067C 8E06[4C01]              	mov	es,[Batch]
 10525                                  
 10526                                  ; The structure of the batch area is:
 10527                                  ;
 10528                                  ;   BYTE    type of segment
 10529                                  ;   DWORD   offset for next line
 10530                                  ;   10 WORD pointers to parameters. -1 is empty parameter
 10531                                  ;   ASCIZ   file name (with . and ..)
 10532                                  ;   BYTES   CR-terminated parameters
 10533                                  ;   BYTE    0 flag to indicate end of parameters
 10534                                  ;
 10535                                  ; Get pointer to BX'th argument
 10536                                  
 10537                                  	;;mov	si,[es:bx+0Bh]
 10538                                  	; 05/02/2023
 10539                                  	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
 10540 00000680 268B770C                	mov	si,[es:bx+BATCHSEGMENT.BatParm]
 10541 00000684 07                      	pop	es
 10542                                  
 10543                                  ; Is there a parameter here?
 10544                                  
 10545 00000685 83FEFF                  	cmp	si,-1		; Check if parameter exists
 10546 00000688 7503                    	jnz	short YES_THERE_IS ; Yes go get it
 10547 0000068A E96EFF                  	jmp	RDBAT		; Ignore if it doesn't
 10548                                  
 10549                                  ; Copy in the found parameter from batch segment
 10550                                  
 10551                                  YES_THERE_IS:
 10552 0000068D 1E                      	push	ds
 10553 0000068E 8E1E[4C01]              	mov	ds,[Batch]
 10554 00000692 49                      	dec	cx		; Don't count '%' in line length
 10555                                  COPYPARM:
 10556 00000693 AC                      	lodsb			; From resident segment
 10557 00000694 3C0D                    	cmp	al,0Dh		; Check for end of parameter
 10558 00000696 740F                    	je	short ENDPARAM
 10559 00000698 41                      	inc	cx		; Inc the line length
 10560 00000699 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10561 0000069D 7303                    	jnb	short LINETOOL	; Yes - handle it, handle it
 10562 0000069F AA                      	stosb
 10563 000006A0 EBF1                    	jmp	short COPYPARM
 10564                                  
 10565                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
 10566                                  ; line. We need to make sure that the tooLong code isn't fooled into
 10567                                  ; believing that we are at EOL. Clobber AL too.
 10568                                  
 10569                                  LINETOOL:
 10570 000006A2 30C0                    	xor	al,al
 10571 000006A4 1F                      	pop	ds
 10572 000006A5 EBB2                    	jmp	short TOOLONG
 10573                                  
 10574                                  ; We have copied in an entire parameter. Go back for more
 10575                                  
 10576                                  ENDPARAM:
 10577 000006A7 1F                      	pop	ds
 10578 000006A8 E950FF                  	jmp	RDBAT
 10579                                  
 10580                                  ; We have found % followed by something other than 0-9. We presume that there
 10581                                  ; will be a following % character. In between is an environment variable that
 10582                                  ; we will fetch and replace in the batch line with its value.
 10583                                  
 10584                                  NEEDENV:
 10585                                  	; MSDOS 6.0 COMMAND.COM
 10586                                  	; 05/02/2023 
 10587 000006AB 49                      	dec     cx 		;AN070; Don't count "%"
 10588                                  
 10589                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10590 000006AC 1E                      	push	ds
 10591 000006AD 57                      	push	di
 10592                                  				; temp spot for name
 10593 000006AE BF[6B8B]                	mov	di,ID
 10594 000006B1 0430                    	add	al,'0'		; reconvert character
 10595 000006B3 AA                      	stosb			; store it in appropriate place
 10596                                  
 10597                                  ; loop getting characters until the next % is found or until EOL
 10598                                  
 10599                                  GETENV1:
 10600 000006B4 E8B702                  	call	GETBATBYT	; get the byte
 10601 000006B7 AA                      	stosb			; store it
 10602 000006B8 3C0D                    	cmp	al,0Dh		; EOL?
 10603 000006BA 7514                    	jne	short GETENV15	; no, see if it the term char
 10604                                  
 10605                                  ; The user entered a string with a % but no trailing %. We copy the string.
 10606                                  
 10607 000006BC 26C645FF00              	mov	byte [es:di-1],0 ; nul terminate the string
 10608 000006C1 BE[6B8B]                	mov	si,ID 		; point to buffer
 10609 000006C4 5F                      	pop	di		; point to line buffer
 10610 000006C5 0E                      	push	cs
 10611 000006C6 1F                      	pop	ds
 10612 000006C7 E89102                  	call	STRCPY
 10613                                  	; 05/02/2023
 10614 000006CA 72D6                    	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
 10615                                  	; 24/04/2023
 10616                                  	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
 10617 000006CC 1F                      	pop	ds
 10618 000006CD E94AFF                  	jmp	SAVBATBYT
 10619                                  GETENV15:
 10620 000006D0 3C25                    	cmp	al,'%'		; terminating %?
 10621 000006D2 75E0                    	jne	short GETENV1	; no, go suck out more characters
 10622                                  
 10623                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
 10624                                  ; This was the source of bug #1.
 10625                                  ;	dec	cx		;AN070; Don't count "%"
 10626                                  
 10627 000006D4 B03D                    	mov	al,'='		; terminate  with =
 10628 000006D6 268845FF                	mov	[es:di-1],al
 10629                                  
 10630                                  ; ID now either has a =-terminated string which we are to find in the
 10631                                  ; environment or a non =-terminated string which will not be found in the
 10632                                  ; environment.
 10633                                  
 10634                                  GETENV2:
 10635 000006DA BE[6B8B]                	mov	si,ID
 10636 000006DD 0E                      	push	cs
 10637 000006DE 1F                      	pop	ds		; DS:SI points to name
 10638 000006DF 51                      	push	cx
 10639 000006E0 E8571C                  	call	find_name_in_environment
 10640 000006E3 59                      	pop	cx
 10641 000006E4 06                      	push	es
 10642 000006E5 1F                      	pop	ds
 10643 000006E6 0E                      	push	cs
 10644 000006E7 07                      	pop	es
 10645 000006E8 89FE                    	mov	si,di
 10646 000006EA 5F                      	pop	di		; get back pointer to command line
 10647                                  
 10648                                  ; If the parameter was not found, there is no need to perform any replacement.
 10649                                  ; We merely pretend that we've copied the parameter.
 10650                                  
 10651 000006EB 7203                    	jc	short GETENV6
 10652                                  
 10653                                  ; ES:DI points to command line being built
 10654                                  ; DS:SI points either to nul-terminated environment object AFTER =
 10655                                  
 10656 000006ED E86B02                  	call	STRCPY		; (let RdBat handle overflow)
 10657                                  	; 24/04/2022
 10658                                  	;dec	di 		; MSDOS 3.3 COMMAND.COM
 10659                                  GETENV6:
 10660 000006F0 1F                      	pop	ds
 10661 000006F1 E907FF                  	jmp	RDBAT		; go back to batch file
 10662                                  
 10663                                  ; =============== S U B	R O U T	I N E =======================================
 10664                                  
 10665                                  ;   SkipToEOL - read from batch file until end of line
 10666                                  
 10667                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10668                                  SKIPTOEOL:
 10669 000006F4 F706[4C01]FFFF          	test	word [Batch],-1 ; 0FFFFh
 10670                                  	;jnz	short SKIPTOEOL1  	
 10671                                  	;retn			; no batch file in effect
 10672                                  	
 10673 000006FA 7407                    	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
 10674                                  SKIPTOEOL1:
 10675 000006FC E86F02                  	call	GETBATBYT
 10676 000006FF 3C0D                    	cmp	al,0Dh		; eol character?
 10677 00000701 75F1                    	jnz	short SKIPTOEOL	; no, go eat another
 10678                                  SKIPTOEOL2:
 10679 00000703 C3                      	retn
 10680                                  
 10681                                  ; =============== S U B	R O U T	I N E =======================================
 10682                                  
 10683                                  ;Break	<Allocate and deallocate the transient portion>
 10684                                  
 10685                                  ; Free Transient. Modify ES,AX,flags
 10686                                  
 10687                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10688                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
 10689                                  FREE_TPA:
 10690 00000704 06                      	push	es
 10691 00000705 8E06[E08A]              	mov	es,[RESSEG]
 10692 00000709 268E06[5F03]            	mov	es,[es:Res_Tpa]
 10693 0000070E B449                    	mov	ah,49h
 10694                                  	;mov	ah,DEALLOC ; 49h
 10695 00000710 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 10696                                  			; ES = segment address of area to be freed
 10697 00000712 07                      	pop	es
 10698 00000713 C3                      	retn
 10699                                  
 10700                                  ; =============== S U B	R O U T	I N E =======================================
 10701                                  
 10702                                  ; Allocate transient. Modify AX,BX,DX,flags
 10703                                  
 10704                                  	; 06/02/2023
 10705                                  ALLOC_TPA:
 10706 00000714 06                      	push	es
 10707 00000715 8E06[E08A]              	mov	es,[RESSEG]
 10708 00000719 BBFFFF                  	mov	bx,0FFFFh 	; Re-allocate the transient	
 10709 0000071C B448                    	mov	ah,48h
 10710                                  	;mov	ah,ALLOC ; 48h
 10711 0000071E CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10712                                  			; BX = number of 16-byte paragraphs desired
 10713 00000720 53                      	push	bx	  	; Save size of block
 10714 00000721 B448                    	mov	ah,48h
 10715                                  	;mov	ah,ALLOC ; 48h
 10716 00000723 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10717                                  			; BX = number of 16-byte paragraphs desired
 10718                                  
 10719                                  ; Attempt to align TPA on 64K boundary
 10720                                  
 10721 00000725 5B                      	pop	bx		; Restore size of block
 10722 00000726 26A3[5F03]              	mov	[es:Res_Tpa],ax
 10723                                  				; Save segment to beginning of block
 10724 0000072A A3[F08A]                	mov	[TRAN_TPA],ax
 10725                                  
 10726                                  ; Is the segment already aligned on a 64K boundary
 10727                                  
 10728 0000072D 89C2                    	mov	dx,ax		; Save segment
 10729 0000072F 25FF0F                  	and	ax,0FFFh	; Test if above boundary
 10730 00000732 7507                    	jnz	short CALC_TPA
 10731 00000734 89D0                    	mov	ax,dx
 10732 00000736 2500F0                  	and	ax,0F000h	; Test if multiple of 64K
 10733 00000739 7523                    	jnz	short NOROUND
 10734                                  CALC_TPA:
 10735 0000073B 89D0                    	mov	ax,dx
 10736 0000073D 2500F0                  	and	ax,0F000h
 10737 00000740 050010                  	add	ax,1000h	; Round up to next 64K boundary
 10738 00000743 7219                    	jc	short NOROUND	; Memory wrap if carry set
 10739                                  
 10740                                  ; Make sure that new boundary is within allocated range
 10741                                  
 10742 00000745 268B16[5F03]            	mov	dx,[es:Res_Tpa]
 10743 0000074A 01DA                    	add	dx,bx		; Compute maximum address
 10744 0000074C 39C2                    	cmp	dx,ax		; Is 64K address out of range?
 10745 0000074E 720E                    	jb	short NOROUND
 10746                                  
 10747                                  ; Make sure that we won't overwrite the transient
 10748                                  
 10749 00000750 8CCB                    	mov	bx,cs		; CS is beginning of transient
 10750 00000752 39C3                    	cmp	bx,ax
 10751 00000754 7208                    	jb	short NOROUND
 10752                                  
 10753                                  ; The area from the 64K boundary to the beginning of the transient must
 10754                                  ; be at least 64K.
 10755                                  
 10756 00000756 29C3                    	sub	bx,ax
 10757                                  	;cmp	bx,4096
 10758 00000758 81FB0010                	cmp	bx,1000h	; Size greater than 64K?	
 10759 0000075C 7304                    	jnb	short ROUNDDONE
 10760                                  NOROUND:
 10761 0000075E 26A1[5F03]              	mov	ax,[es:Res_Tpa]
 10762                                  ROUNDDONE:
 10763 00000762 26A3[5103]              	mov	[es:LTpa],ax	; Re-compute everything
 10764 00000766 A3[E28A]                	mov	[TPA],ax
 10765 00000769 89C3                    	mov	bx,ax
 10766 0000076B 8CC8                    	mov	ax,cs
 10767 0000076D 29D8                    	sub	ax,bx
 10768 0000076F 53                      	push	bx
 10769 00000770 BB1000                  	mov	bx,16
 10770 00000773 F7E3                    	mul	bx
 10771 00000775 5B                      	pop	bx
 10772 00000776 09D2                    	or	dx,dx
 10773 00000778 7403                    	jz	short SAVSIZ2
 10774 0000077A B8FFFF                  	mov	ax,-1
 10775                                  SAVSIZ2:
 10776                                  
 10777                                  ; AX is the number of bytes free in the buffer between the resident and the
 10778                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
 10779                                  
 10780 0000077D 3D0002                  	cmp	ax,512
 10781 00000780 7603                    	jbe	short GOTSIZE2
 10782                                  	;and	ax,~1FFh
 10783 00000782 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FFh
 10784                                  GOTSIZE2:
 10785 00000785 A3[018B]                	mov	[BYTCNT],ax
 10786 00000788 07                      	pop	es
 10787 00000789 C3                      	retn
 10788                                  
 10789                                  ; =============== S U B	R O U T	I N E =======================================
 10790                                  
 10791                                  ;Break	<BatCom - enter a batch file>
 10792                                  
 10793                                  ; The exec search has determined that the user has requested a batch file for
 10794                                  ; execution. We parse the arguments, create the batch segment, and signal
 10795                                  ; batch processing.
 10796                                  
 10797                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10798                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
 10799                                  BATCOM:	
 10800                                  
 10801                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
 10802                                  
 10803                                  ; Batch parameters are read with ES set to segment of resident part
 10804                                  
 10805                                  	; MSDOS 6.0
 10806 0000078A 8E06[E08A]              	mov	es,[RESSEG]
 10807                                  	;ASSUME	ES:RESGROUP
 10808                                  	;cmp	byte [es:Call_Batch_Flag],1
 10809 0000078E 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10810                                  					;AN043; If in CALL,
 10811 00000794 7403                    	jz	short skip_ioset	;AN043; redirection was already set up
 10812                                  	;invoke	IOSET			; Set up any redirection
 10813 00000796 E81324                  	call	IOSET
 10814                                  skip_ioset:				;AN043;
 10815 00000799 E868FF                  	call	FREE_TPA		; G
 10816                                  	;cmp	byte [es:Call_Batch_Flag],1
 10817 0000079C 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10818 000007A2 7403                    	jz	short GETECHO 		; G if we're in a call, don't execute
 10819                                  
 10820                                  	; 12/02/2023
 10821                                  	; MSDOS 3.3
 10822                                  	;call	IOSET
 10823                                  	;mov	es,[RESSEG]
 10824                                  	;call	FREE_TPA
 10825                                  	;;cmp	byte [es:CALL_BATCH_FLAG],1
 10826                                  	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
 10827                                  	;jz	short GETECHO		; G if we're in a call, don't execute
 10828                                  
 10829                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10830                                  
 10831                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
 10832                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
 10833                                  ; Don't execute if in call
 10834                                  
 10835 000007A4 E89F08                  	call	FOROFF
 10836                                  GETECHO:
 10837 000007A7 E8FB27                  	call	PipeOff
 10838 000007AA 26A0[A001]              	mov	al,[es:EchoFlag]	; preserve echo state for chaining
 10839 000007AE 2401                    	and	al,1			; Save current echo state
 10840                                  
 10841 000007B0 50                      	push	ax
 10842 000007B1 31C0                    	xor	ax,ax
 10843 000007B3 26F706[4C01]FFFF        	test	word [es:Batch],-1 	; Are we in a batch file?
 10844 000007BA 7414                    	jz	short LEAVEBAT	   	; No, nothing to save
 10845 000007BC 26A1[4C01]              	mov	ax,[es:Batch] 		; Get current batch segment
 10846                                  	;cmp	byte [es:Call_Batch_Flag],1
 10847 000007C0 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10848 000007C6 7408                    	jz	short LEAVEBAT
 10849                                  
 10850                                  ;  We are in a chained batch file, save batlast from previous batch segment
 10851                                  ;  so that if we're in a CALL, we will return to the correct batch file.
 10852                                  
 10853 000007C8 06                      	push	es
 10854 000007C9 8EC0                    	mov	es,ax		; Get current batch segment
 10855                                  	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
 10856                                  				; Get previous batch segment
 10857                                  	; 12/02/2023
 10858                                  	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
 10859 000007CB 26A10300                	mov	ax,[es:BATCHSEGMENT.BatLast]
 10860 000007CF 07                      	pop	es
 10861                                  LEAVEBAT:
 10862 000007D0 50                      	push	ax		; Keep segment until new one created
 10863                                  	;cmp	byte [es:Call_Batch_Flag],1
 10864 000007D1 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10865 000007D7 7403                    	jz	short STARTBAT
 10866 000007D9 E82301                  	call	BATCHOFF
 10867                                  
 10868                                  ; Find length of batch file
 10869                                  
 10870                                  STARTBAT:
 10871 000007DC 26C606[B201]00          	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
 10872 000007E2 BE[088A]                	mov	si,EXECPATH
 10873                                  
 10874                                  	; 12/02/2023
 10875                                  	; MSDOS 6.0
 10876 000007E5 B811B7                  	mov	ax,0B711h
 10877                                  	;mov	ax,AppendTruename
 10878                                  				;AN042; Get the real path where the batch file
 10879 000007E8 CD2F                    	int	2Fh		;AN042;    was found with APPEND
 10880 000007EA B44E                    	mov	ah,4Eh
 10881                                  	;mov	ah,Find_First	;AN042; The find_first will return it
 10882 000007EC 89F2                    	mov	dx,si		;AN042; Get the string
 10883 000007EE B91300                  	mov	cx,13h
 10884                                  	;mov	cx,search_attr	;AN042; filetypes to search for
 10885 000007F1 CD21                    	int	21h		;AN042;
 10886                                  
 10887                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10888 000007F3 E8A724                  	call	dstrlen
 10889                                  ;
 10890                                  ; Allocate batch area:
 10891                                  ;   BYTE    type of segment
 10892                                  ;   WORD    segment of last batch file
 10893                                  ;   WORD    segment for FOR command
 10894                                  ;   BYTE    FOR flag state on entry to batch file
 10895                                  ;   DWORD   offset for next line
 10896                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
 10897                                  ;   ASCIZ   file name (with . and ..)
 10898                                  ;   BYTES   CR-terminated parameters
 10899                                  ;   BYTE    0 flag to indicate end of parameters
 10900                                  ;
 10901                                  ; We allocate the maximum size for the command line and use setblock to shrink
 10902                                  ; later when we've squeezed out the extra
 10903                                  ;
 10904 000007F6 89CB                    	mov	bx,cx		; length of file name.
 10905                                  	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
 10906                                  	; 12/02/2023
 10907                                  	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
 10908                                  	; 25/04/2023
 10909 000007F8 81C3BF00                	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
 10910                                  					; structure + max len + round up
 10911 000007FC 51                      	push	cx
 10912 000007FD B104                    	mov	cl,4
 10913 000007FF D3EB                    	shr	bx,cl		; convert to paragraphs
 10914 00000801 53                      	push	bx		; Save size of batch segment
 10915 00000802 B448                    	mov	ah,48h
 10916                                  	;mov	ah,ALLOC ; 48h ; Allocate batch segment
 10917 00000804 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10918                                  				; BX = number of 16-byte paragraphs desired
 10919 00000806 5B                      	pop	bx		; Get size of batch segment
 10920                                  
 10921                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
 10922                                  ; the batch segment. This may not be true, however, in a multitasking system.
 10923                                  ; G This error will occur with nesting of batch files. We also need to
 10924                                  ; G make sure that we don't overlay the transient.
 10925                                  
 10926 00000807 7221                    	jc	short MEM_ERROR	;G not enough memory - exit
 10927                                  
 10928 00000809 50                      	push	ax		;G save batch segment
 10929 0000080A 01D8                    	add	ax,bx		;G get end of batch segment
 10930 0000080C 83C020                  	add	ax,20h		;G add some tpa work area
 10931 0000080F 8CCB                    	mov	bx,cs		;G get the transient segment
 10932                                  
 10933                                  	; MSDOS 6.0
 10934                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
 10935                                  ; M006; batchseg is always above the transient. We need to change this code
 10936                                  ; M006; to only check for an overlap
 10937                                  
 10938                                  	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
 10939                                  	; 12/02/2023
 10940                                  	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
 10941                                  	;mov	dx,TRANSPACEEND		
 10942                                  	;add	dx,15		;round up para; M006
 10943 00000811 BA3E96                  	mov	dx,TRANSPACEEND+15
 10944                                  
 10945 00000814 D3EA                    	shr	dx,cl		;para size of transient; M006
 10946 00000816 01DA                    	add	dx,bx		;dx = top of transient; M006
 10947                                  
 10948 00000818 39D8                    	cmp	ax,bx		; M006
 10949 0000081A 7211                    	jb	short ENOUGH_MEM
 10950                                  				; Batchseg below transient
 10951                                  				; enough memory ; M006
 10952 0000081C 39D0                    	cmp	ax,dx		; M006
 10953 0000081E 770D                    	ja	short ENOUGH_MEM	
 10954                                  				; Batchseg above transient
 10955                                  				; enough memory ; M006
 10956                                  
 10957                                  ; M006; Batchseg overlaps transient -- insufficient memory
 10958                                  
 10959 00000820 58                      	pop	ax		; restore ax; M006
 10960                                  
 10961                                  	; 12/02/2023
 10962                                  	; MSDOS 3.3
 10963                                  ; M006;	cmp	ax,bx		;G do we end before the transient
 10964                                  ; M006;	pop	ax		;G get batch segment back
 10965                                  ; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue
 10966                                  
 10967                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10968 00000821 06                      	push	es		;G no we're hitting the transient
 10969 00000822 8EC0                    	mov	es,ax
 10970 00000824 B80049                  	mov	ax,4900h
 10971                                  	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
 10972 00000827 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 10973                                  			; ES = segment address of area to be freed
 10974 00000829 07                      	pop	es
 10975                                  MEM_ERROR:
 10976 0000082A E9BB00                  	jmp	NO_MEMORY	;G Set up for message and exit
 10977                                  
 10978                                  ENOUGH_MEM:
 10979                                  	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
 10980                                  	; MSDOS 6.0
 10981 0000082D 58                      	pop	ax		; restore ax; M006
 10982                                  
 10983                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10984 0000082E 26A3[4C01]              	mov	[es:Batch],ax
 10985 00000832 E8DFFE                  	call	ALLOC_TPA
 10986                                  
 10987                                  ; Initialize batch segment
 10988                                  
 10989 00000835 5A                      	pop	dx		; length of name
 10990 00000836 58                      	pop	ax		;G get saved batch segment back
 10991 00000837 26FF06[AF01]            	inc	word [es:Nest]	;G increment # batch files in progress
 10992 0000083C 06                      	push	es
 10993 0000083D 268E06[4C01]            	mov	es,[es:Batch]
 10994                                  	;mov	byte [ES:0],0
 10995                                  				; signal batch file type
 10996 00000842 26C606000000            	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
 10997                                  	;;mov	[es:2],ax	; MSDOS 3.3
 10998                                  				;G save segment of last batch file
 10999                                  	;mov	[es:3],ax	; MSDOS 6.0
 11000 00000848 26A30300                	mov	[es:BATCHSEGMENT.BatLast],ax
 11001 0000084C 1E                      	push	ds
 11002 0000084D 8E1E[E08A]              	mov	ds,[RESSEG]	;G set to resident data
 11003                                  
 11004 00000851 31C0                    	xor	ax,ax
 11005 00000853 8A1E[AC01]              	mov	bl,[ForFlag]	;G get the current FOR state
 11006                                  	;;mov	[es:6],bl	; MSDOS 3.3
 11007                                  				;G save it in the batch segment
 11008                                  	;mov	[es:7],bl	; MSDOS 6.0 	
 11009 00000857 26881E0700              	mov	[es:BATCHSEGMENT.BatForFlag],bl
 11010 0000085C F6C3FF                  	test	bl,-1		;G are we in a FOR?
 11011 0000085F 7408                    	jz	short FOR_NOT_ON ;G no, for segment set to 0	
 11012 00000861 A1[AD01]                	mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11013 00000864 C606[AC01]00            	mov	byte [ForFlag],0 ;G reset forflag
 11014                                  FOR_NOT_ON:
 11015                                  	;;mov	[es:4],ax	; MSDOS 3.3
 11016                                  				;G save FOR segment in batch segment
 11017                                  	;mov	[es:5],ax	; MSDOS 6.0		
 11018 00000869 26A30500                	mov	[es:BATCHSEGMENT.BatForPtr],ax	
 11019 0000086D 31C0                    	xor	ax,ax
 11020 0000086F A3[AD01]                	mov	[ForPtr],ax	;G make sure for segment is not active
 11021 00000872 8A1E[A001]              	mov	bl,[EchoFlag]
 11022 00000876 1F                      	pop	ds
 11023                                  	;mov	[es:1],bl 
 11024                                  				 ;G save echo state of parent
 11025 00000877 26881E0100              	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
 11026                                  ;SR;
 11027                                  ; Initialize the new BatchEOF flag we have added to 0
 11028                                  
 11029                                  	; MSDOS 6.0
 11030                                  	;mov	byte [es:2],0
 11031 0000087C 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 11032                                  
 11033                                  	;mov	[es:08h],ax  ; MSDOS 6.0
 11034 00000882 26A30800                	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
 11035                                  	;mov	[es:0Ah],ax  ; MSDOS 6.0	
 11036 00000886 26A30A00                	mov	[es:BATCHSEGMENT.BatSeek+2],ax
 11037                                  
 11038                                  ; Initialize pointers
 11039                                  
 11040 0000088A 48                      	dec	ax		; put -1 into AX
 11041                                  	;;mov	di,0Bh  ; MSDOS 3.3
 11042                                  				; point to parm area
 11043                                  	;mov	di,0Ch	; MSDOS 6.0
 11044 0000088B BF0C00                  	mov	di,BATCHSEGMENT.BatParm
 11045 0000088E 89FB                    	mov	bx,di
 11046 00000890 B90A00                  	mov	cx,10
 11047 00000893 F3AB                    	rep stosw		; Init to no parms
 11048                                  
 11049                                  ; Move in batch file name
 11050                                  
 11051 00000895 89D1                    	mov	cx,dx
 11052 00000897 F3A4                    	rep	movsb
 11053                                  
 11054                                  ; Now copy the command line into batch segment, parsing the arguments along
 11055                                  ; the way. Segment will look like this:
 11056                                  ;
 11057                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
 11058                                  ;
 11059                                  ; or, in the case of fewer arguments:
 11060                                  ;
 11061                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
 11062                                  
 11063 00000899 BE[4189]                	mov	si,COMBUF+2
 11064 0000089C B90A00                  	mov	cx,10		; at most 10 arguments
 11065                                  EACHPARM:
 11066 0000089F E8641D                  	call	scanoff		; skip to argument
 11067                                  
 11068                                  ; AL is first non-delimiter. DS:SI points to char = AL
 11069                                  
 11070 000008A2 3C0D                    	cmp	al,0Dh		; end of road?
 11071 000008A4 741D                    	jz	short HAVPARM	; yes, no more arguments
 11072                                  
 11073                                  ; If CX = 0 then we have stored the most parm we can. Skip store
 11074                                  
 11075 000008A6 E306                    	jcxz	MOVPARM		; Only first 10 parms get pointers
 11076                                  
 11077                                  ; Go into allocated piece and stick in new argument pointer.
 11078                                  
 11079 000008A8 26893F                  	mov	[es:bx],di	; store batch pointer
 11080 000008AB 83C302                  	add	bx,2		; advance arg counter
 11081                                  
 11082                                  ; Move the parameter into batch segment
 11083                                  
 11084                                  MOVPARM:
 11085 000008AE AC                      	lodsb			; get byte
 11086 000008AF E85C1D                  	call	DELIM		; if delimiter
 11087 000008B2 7407                    	jz	short ENDPARM	; then done with parm
 11088 000008B4 AA                      	stosb			; store byte
 11089 000008B5 3C0D                    	cmp	al,0Dh		; if CR then not delimiter
 11090 000008B7 740A                    	jz	short HAVPARM	; but end of parm list, finish
 11091 000008B9 EBF3                    	jmp	short MOVPARM
 11092                                  
 11093                                  ; We have copied a parameter up until the first separator.
 11094                                  ; Terminate it with CR.
 11095                                  
 11096                                  ENDPARM:
 11097 000008BB B00D                    	mov	al,0Dh
 11098 000008BD AA                      	stosb
 11099 000008BE E3DF                    	jcxz	EACHPARM	; if no parameters, don't dec
 11100 000008C0 49                      	dec	cx		; remember that we've seen one.	
 11101 000008C1 EBDC                    	jmp	short EACHPARM
 11102                                  
 11103                                  ; We have parsed the entire line. Terminate the arg list
 11104                                  
 11105                                  HAVPARM:
 11106 000008C3 30C0                    	xor	al,al		; Nul terminate the parms
 11107 000008C5 AA                      	stosb
 11108                                  
 11109                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
 11110                                  ; into paragraphs and setblock to the appropriate size
 11111                                  
 11112 000008C6 8D5D0F                  	lea	bx,[di+15]
 11113 000008C9 B104                    	mov	cl,4
 11114 000008CB D3EB                    	shr	bx,cl
 11115 000008CD B44A                    	mov	ah,4Ah
 11116                                  	;mov	ah,SETBLOCK ; 4Ah
 11117 000008CF CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 11118                                  			; ES = segment address of block	to change
 11119                                  			; BX = new size	in paragraphs
 11120 000008D1 07                      	pop	es
 11121 000008D2 06                      	push	es
 11122 000008D3 1F                      	pop	ds		; Simply batch FCB setup
 11123 000008D4 833E[A601]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 11124 000008D9 7506                    	jne	short NOBATSING
 11125 000008DB C706[A601]F0FF          	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job
 11126                                  
 11127                                  NOBATSING:
 11128                                  
 11129                                  ; Enter the batch file with the current echo state
 11130                                  
 11131 000008E1 58                      	pop	ax		; Get original echo state
 11132 000008E2 A2[A001]                	mov	[EchoFlag],al	; restore it
 11133 000008E5 E91CF8                  	jmp	TCOMMAND
 11134                                  
 11135                                  ; The following is executed if there isn't enough memory for batch segment
 11136                                  
 11137                                  NO_MEMORY:
 11138 000008E8 5A                      	pop	dx		; even up our stack 
 11139 000008E9 58                      	pop	ax
 11140 000008EA 58                      	pop	ax
 11141 000008EB E826FE                  	call	ALLOC_TPA	; reallocate memory
 11142                                  
 11143                                  	; 12/02/2023
 11144                                  	; MSDOS 3.3
 11145                                  	;mov	dx,INSFMEMMESPTR
 11146                                  	;jmp	CERROR
 11147                                  
 11148                                  	; MSDOS 6.0
 11149                                  	;mov	byte [msg_disp_class],1
 11150 000008EE C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class
 11151                                  				;AN000; set up extended error msg class
 11152                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 11153 000008F3 BA[757F]                	mov	dx,extend_buf_ptr
 11154                                  	;			;AC000; get extended message pointer
 11155                                  	;mov	word [extend_buf_ptr],8
 11156 000008F6 C706[757F]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 11157                                  				;AN000; get message number in control block
 11158 000008FC E97B20                  	jmp	cerror		;g print error message and go...
 11159                                  
 11160                                  ; =============== S U B	R O U T	I N E =======================================
 11161                                  
 11162                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11163                                  BATCHOFF:
 11164 000008FF 50                      	push	ax
 11165 00000900 06                      	push	es
 11166 00000901 1E                      	push	ds
 11167 00000902 53                      	push	bx
 11168                                  
 11169 00000903 2E8E06[E08A]            	mov	es,[cs:RESSEG]
 11170 00000908 2E8E1E[E08A]            	mov	ds,[cs:RESSEG]
 11171 0000090D A1[4C01]                	mov	ax,[Batch]	; Free the batch segment
 11172 00000910 09C0                    	or	ax,ax
 11173 00000912 7442                    	jz	short NOTFREE
 11174                                  
 11175 00000914 06                      	push	es
 11176 00000915 8EC0                    	mov	es,ax
 11177 00000917 F606[A001]01            	test	byte [EchoFlag],1
 11178                                  				;G Is echo on?
 11179 0000091C 7505                    	jnz	short ECHO_LAST_LINE
 11180                                  				;G Yes - echo last line in file
 11181                                  	;mov	byte [SUPPRESS],0
 11182 0000091E C606[A101]00            	mov	byte [Suppress],NO_ECHO
 11183                                  				;G no - don't echo last line in file	
 11184                                  ECHO_LAST_LINE:
 11185                                  	;mov	bl,[es:1]
 11186 00000923 268A1E0100              	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
 11187                                  				; G get echo state
 11188 00000928 881E[A001]              	mov	[EchoFlag],bl
 11189                                  				; G  and restore it
 11190                                  	;;mov	bx,[es:4]  ; MSDOS 3.3
 11191                                  	;mov	bx,[es:5]  ; MSDOS 6.0
 11192 0000092C 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr]
 11193                                  				;G Get FOR segment
 11194 00000931 891E[AD01]              	mov	[ForPtr],bx	;G  and restore it
 11195                                  	;;mov	bl,[es:6]  ; MSDOS 3.3
 11196                                  	;mov	bl,[es:7]  ; MSDOS 6.0	
 11197 00000935 268A1E0700              	mov	bl,[es:BATCHSEGMENT.BatForFlag]
 11198                                  				;G Get FOR flag
 11199 0000093A 881E[AC01]              	mov	[ForFlag],bl
 11200                                  				;G  and restore it
 11201                                  	;;mov	bx,[es:2] ; MSDOS 3.3
 11202                                  	;mov	bx,[es:3] ; MSDOS 6.0	
 11203 0000093E 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 11204                                  				;G  Get old batch segment
 11205                                  
 11206 00000943 B449                    	mov	ah,49h
 11207                                  	;mov	ah,DEALLOC ; 49h
 11208 00000945 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11209                                  			; ES = segment address of area to be freed
 11210 00000947 07                      	pop	es
 11211 00000948 891E[B301]              	mov	[Next_Batch],bx	;G reset batch segment	
 11212 0000094C 26FF0E[AF01]            	dec	word [es:Nest]
 11213 00000951 31C0                    	xor	ax,ax
 11214 00000953 A3[4C01]                	mov	[Batch],ax	; No batch in progress
 11215                                  NOTFREE:
 11216 00000956 5B                      	pop	bx
 11217 00000957 1F                      	pop	ds
 11218 00000958 07                      	pop	es
 11219 00000959 58                      	pop	ax
 11220 0000095A C3                      	retn
 11221                                  
 11222                                  ; =============== S U B	R O U T	I N E =======================================
 11223                                  
 11224                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11225                                  
 11226                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
 11227                                  ;	Entry : DS:SI ==> source string
 11228                                  ;		ES:DI ==> destination string
 11229                                  ;		CX = current length of destination string
 11230                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
 11231                                  
 11232                                  	; 12/02/2023	
 11233                                  	; MSDOS 3.3
 11234                                  ;STRCPY:
 11235                                  	;push	ax
 11236                                  ;CCYCLE:
 11237                                  	;lodsb
 11238                                  	;stosb
 11239                                  	;or	al,al
 11240                                  	;jnz	short CCYCLE
 11241                                  	;pop	ax
 11242                                  	;retn
 11243                                  
 11244                                  ;Procedure StrCpy,NEAR
 11245                                  
 11246                                  	; 12/02/2023
 11247                                  	; MSDOS 6.0
 11248                                  STRCPY:
 11249 0000095B 50                      	push	ax
 11250                                  ccycle:
 11251 0000095C AC                      	lodsb
 11252 0000095D 41                      	inc	cx
 11253                                  	;cmp	cx,128
 11254 0000095E 81F98000                	cmp	cx,COMBUFLEN
 11255                                  	;jb	short ccopy
 11256                                  	;stc			; set carry to signal error
 11257                                  	;jmp	short ccend
 11258                                  	; 12/02/2023
 11259 00000962 F5                      	cmc
 11260 00000963 7205                    	jc	short ccend
 11261                                  ccopy:
 11262 00000965 AA                      	stosb
 11263 00000966 08C0                    	or	al,al
 11264 00000968 75F2                    	jnz	short ccycle
 11265                                  ccend:
 11266 0000096A 49                      	dec	cx		; discount extra byte
 11267 0000096B 4F                      	dec	di		; back up pointer
 11268 0000096C 58                      	pop	ax
 11269 0000096D C3                      	retn			; return carry clear
 11270                                  
 11271                                  ;EndProc StrCpy
 11272                                  
 11273                                  ;============================================================================
 11274                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
 11275                                  ;============================================================================
 11276                                  ; 12/10/2018 - Retro DOS v3.0
 11277                                  
 11278                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
 11279                                  
 11280                                  ; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11281                                  
 11282                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h
 11283                                  
 11284                                  ; =============== S U B	R O U T	I N E =======================================
 11285                                  
 11286                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
 11287                                  
 11288                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
 11289                                  ; <CR> and ends batch mode. DS must be set to resident segment.
 11290                                  ; AH, DX destroyed.
 11291                                  
 11292                                  GETBATBYT:
 11293 0000096E 53                      	push	bx
 11294 0000096F 51                      	push	cx
 11295 00000970 1E                      	push	ds
 11296 00000971 F606[9601]FF            	test	byte [Batch_Abort],-1
 11297                                  	;jnz	short BATEOF
 11298                                  	; 14/02/2023
 11299 00000976 7403                    	jz	short getbatbyt1
 11300 00000978 E9D100                  	jmp	BATEOF
 11301                                  getbatbyt1:
 11302 0000097B F706[4C01]FFFF          	test	word [Batch],-1
 11303                                  	;jz	short BATEOF
 11304                                  	; 14/02/2023
 11305 00000981 7503                    	jnz	short getbatbyt2
 11306 00000983 E9C600                  	jmp	BATEOF
 11307                                  getbatbyt2:
 11308 00000986 06                      	push	es
 11309 00000987 8E06[4C01]              	mov	es,[Batch]
 11310                                  
 11311                                  	; MSDOS 6.0
 11312                                  ;M020;
 11313                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
 11314                                  ;try to read from the batchfile again.
 11315                                  
 11316                                  	;cmp	byte [es:2],0
 11317 0000098B 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11318                                  				;already reached EOF?	;M020
 11319 00000991 7403                    	jz	short not_eof	;no, read batch file	;M020
 11320 00000993 E99C00                  	jmp	At_EOF		;yes, no more reads	;M020
 11321                                  not_eof:						;M020
 11322                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11323                                  	;add	word [es:8],1	; MSDOS 6.0
 11324 00000996 268306080001            	add	word [es:BATCHSEGMENT.BatSeek],1
 11325                                  	;adc	word [es:10],0	; MSDOS 6.0
 11326 0000099C 2683160A0000            	adc	word [es:BATCHSEGMENT.BatSeek+2],0
 11327 000009A2 07                      	pop	es
 11328                                  
 11329                                  ; See if we have bytes buffered...
 11330                                  
 11331 000009A3 8CC8                    	mov	ax,cs
 11332 000009A5 8ED8                    	mov	ds,ax
 11333 000009A7 8B1E[E795]              	mov	bx,[BATBUFPOS]
 11334 000009AB 83FBFF                  	cmp	bx,-1
 11335 000009AE 7540                    	jnz	short UNBUF
 11336                                  
 11337                                  ; There are no bytes in the buffer. Let's try to fill it up.
 11338                                  
 11339 000009B0 BA[E995]                	mov	dx,BATBUF
 11340 000009B3 8B0E[BD84]              	mov	cx,[BATBUFLEN] ; max to read.
 11341 000009B7 8B1E[148E]              	mov	bx,[BATHAND]
 11342                                  	; 14/02/2023
 11343 000009BB B43F                    	mov	ah,3Fh
 11344                                  	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
 11345 000009BD CD21                    	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 11346                                  			; BX = file handle,CX = number	of bytes to read
 11347                                  			; DS:DX	-> buffer
 11348                                  	; MSDOS 6.0
 11349 000009BF 7321                    	jnc	short bat_read_ok	;AN022; if no error - continue
 11350                                  	;invoke	get_ext_error_number	;AN022; get the error
 11351 000009C1 E85913                  	call	get_ext_error_number
 11352 000009C4 1E                      	push	ds			;AN022; save local segment
 11353 000009C5 8E1E[E08A]              	mov	ds,[RESSEG]		;AN022; get resident segment
 11354                                  	;assume ds:resgroup		;AN022;
 11355 000009C9 89C2                    	mov	dx,ax			;AN022; put error in DX
 11356                                  	;invoke	output_batch_name	;AN022; set up to print the error
 11357 000009CB E85BFB                  	call	output_batch_name
 11358 000009CE 1F                      	pop	ds			;AN022;
 11359                                  	;assume	ds:trangroup		;AN022;
 11360                                  	;invoke	std_eprintf		;AN022; print out the error
 11361 000009CF E86944                  	call	std_eprintf
 11362                                  	;mov	byte ptr combuf+2,end_of_line_in
 11363 000009D2 C606[4189]0D            	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
 11364                                  	;				;AN022; terminate the batch line for parsing
 11365                                  	;mov	byte ptr combuf+3,end_of_line_out 
 11366 000009D7 C606[4289]00            	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
 11367                                  	;				;AN022; terminate the batch line for output
 11368                                  ;M020;
 11369                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
 11370                                  ;error is never hit (and it shouldn't be)
 11371                                  
 11372 000009DC 8E1E[E08A]              	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
 11373 000009E0 EB6A                    	jmp	short BATEOF		;AN022; terminate the batch file
 11374                                  bat_read_ok:				;AN022;
 11375                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11376 000009E2 89C1                    	mov	cx,ax
 11377                                  	;jcxz	TURN_OFF ; MSDOS 3.3
 11378                                  	; 14/02/2023
 11379 000009E4 E320                    	jcxz	BATEOFDS ; MSDOS 6.0
 11380 000009E6 890E[0996]              	mov	[BATBUFEND],cx
 11381 000009EA 31DB                    	xor	bx,bx
 11382 000009EC 891E[E795]              	mov	[BATBUFPOS],bx
 11383                                  
 11384                                  	; Buffered bytes!
 11385                                  UNBUF:
 11386 000009F0 8A87[E995]              	mov	al,[BATBUF+bx]		; get next byte
 11387 000009F4 43                      	inc	bx
 11388 000009F5 3B1E[0996]              	cmp	bx,[BATBUFEND]		; beyond end of buffer?
 11389 000009F9 7203                    	jb	short SETBUFPOS
 11390 000009FB BBFFFF                  	mov	bx,-1
 11391                                  SETBUFPOS:
 11392 000009FE 891E[E795]              	mov	[BATBUFPOS],bx
 11393 00000A02 3C1A                    	cmp	al,1Ah			; ^Z for termination?
 11394 00000A04 7575                    	jne	short GETBYTEDONE
 11395                                  
 11396                                  ;We get here only when we hit an EOF
 11397                                  	
 11398                                  	; MSDOS 6.0
 11399                                  BATEOFDS:
 11400                                  ;SR;
 11401                                  ; HACK!!! A massive hack being put in here to get batch processing to work
 11402                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
 11403                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
 11404                                  ;batch processing is turned off before the last line is processed and so 
 11405                                  ;this line would never be executed. 
 11406                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
 11407                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
 11408                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
 11409                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
 11410                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
 11411                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
 11412                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
 11413                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
 11414                                  ;during this call, and there was a CR-LF previously, we are going to fake
 11415                                  ;another redundant CR-LF. There is no work-around I can think of.
 11416                                  ; 	I would love to restructure this entire routine and its caller to
 11417                                  ;make the flow really easy to understand but I guess this will have to wait.
 11418                                  ;
 11419 00000A06 06                      	push	es
 11420 00000A07 8E06[E08A]              	mov	es,[RESSEG]
 11421                                  ;SR;
 11422                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
 11423                                  ;or BatchEOF == 1 now), then do not do the LF check.
 11424                                  ;
 11425 00000A0B 268E06[4C01]            	mov	es,[es:Batch]
 11426                                  	;cmp	byte [es:2],0
 11427 00000A10 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11428 00000A16 7516                    	jnz	short crpresent
 11429                                  
 11430                                  	;inc	byte [es:2]
 11431 00000A18 26FE060200              	inc	byte [es:BATCHSEGMENT.BatchEOF]
 11432                                  					;match the dec following
 11433 00000A1D 8B1E[0996]              	mov	bx,[BATBUFEND]
 11434 00000A21 80BF[E895]0A            	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
 11435 00000A26 7406                    	je	short crpresent		;yes, no need to fake it
 11436                                  
 11437                                  	;add	byte [es:2],3
 11438 00000A28 268006020003            	add	byte [es:BATCHSEGMENT.BatchEOF],3
 11439                                  					;BatchEOF == 4 to fake CR-LF
 11440                                  crpresent:
 11441                                  ;;	;pop	es
 11442                                  
 11443                                  	;ASSUME	DS:TranGroup
 11444                                  	; 14/02/2023
 11445 00000A2E 8E1E[E08A]              	mov	ds,[RESSEG]
 11446                                  	;ASSUME	DS:ResGroup
 11447                                  ;SR;
 11448                                  ; The shift operation is done here to replace the decrement. This is because
 11449                                  ;we can jump to this label directly from above when bogus calls are made to
 11450                                  ;this routine even after batch processing is turned off. The shift ensures
 11451                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
 11452                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
 11453                                  ;calls.
 11454                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
 11455                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
 11456                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
 11457                                  ;turning batch processing off.
 11458                                  
 11459                                  At_EOF:					;new label added ;M020
 11460                                  	;shr	byte [es:2],1
 11461 00000A32 26D02E0200              	shr	byte [es:BATCHSEGMENT.BatchEOF],1
 11462                                  					;decrement the flag
 11463 00000A37 7412                    	jz	short turn_off		;zero,turn batch off
 11464                                  	;cmp	byte [es:2],1
 11465 00000A39 26803E020001            	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
 11466 00000A3F 7405                    	jz	short ret_lf		;BatchEOF was 2, return LF
 11467                                  ;
 11468                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
 11469                                  ;
 11470 00000A41 B00D                    	mov	al,0Dh			;return fake CR.
 11471 00000A43 07                      	pop	es
 11472 00000A44 EB35                    	jmp	short GETBYTEDONE
 11473                                  ret_lf:
 11474 00000A46 B00A                    	mov	al,0Ah			;return fake LF
 11475 00000A48 07                      	pop	es
 11476 00000A49 EB30                    	jmp	short GETBYTEDONE		
 11477                                  turn_off:
 11478 00000A4B 07                      	pop	es
 11479                                  ;BATEOF:
 11480                                  	; MSDOS 3.3
 11481                                  ;TURN_OFF:
 11482                                  	;mov	ds,[RESSEG]
 11483                                  
 11484                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11485                                  BATEOF:
 11486 00000A4C E8B0FE                  	call	BATCHOFF
 11487 00000A4F E8CC02                  	call	BATCLOSE
 11488                                  
 11489                                  ;;;	mov	BatchEOF,0	;make sure BatchEOF = 0
 11490                                  
 11491                                  ;SR; BugBug
 11492                                  ; There is a good reason why this carriage return is being returned here. 
 11493                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
 11494                                  ;of the way the caller is structured, a fake CR has to be returned again on
 11495                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
 11496                                  ;results in an extra linefeed after the batchfile is run if the last line of
 11497                                  ;the batchfile already had a CR-LF. 
 11498                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
 11499                                  ;the end-of-line. This CR is to mark the end-of-file.
 11500                                  
 11501 00000A52 B00D                    	mov	al,0Dh			; If end-of-file, then end of line
 11502 00000A54 F606[9601]FF            	test	byte [Batch_Abort],-1
 11503 00000A59 C606[9601]00            	mov	byte [Batch_Abort],0
 11504 00000A5E 7407                    	jz	short CONT_GET_BYT
 11505 00000A60 BF[4189]                	mov	di,COMBUF+2		; reset pointer to beginning of buffer
 11506 00000A63 31C9                    	xor	cx,cx			; zero line length
 11507 00000A65 EB14                    	jmp	short GETBYTEDONE
 11508                                  CONT_GET_BYT:
 11509 00000A67 833E[A601]F0            	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
 11510 00000A6C 750D                    	jne	short GETBYTEDONE
 11511 00000A6E 833E[AF01]00            	cmp	word [Nest],0		;G See if we have nested batch files
 11512 00000A73 7506                    	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
 11513 00000A75 C706[A601]FFFF          	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
 11514                                  GETBYTEDONE:
 11515 00000A7B 1F                      	pop	ds
 11516 00000A7C 59                      	pop	cx
 11517 00000A7D 5B                      	pop	bx
 11518 00000A7E C3                      	retn
 11519                                  
 11520                                  ; ---------------------------------------------------------------------------
 11521                                  
 11522                                  ;break	<$If - conditional execution>
 11523                                  
 11524                                  	; 17/04/2023
 11525                                  ;IFERRORP:
 11526                                  ;	pop	ax
 11527                                  ;IFERROR:
 11528                                  ;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11529                                  ;FORERROR:
 11530                                  ;	mov	dx,SYNTMES_PTR
 11531                                  ;	jmp	cerror
 11532                                  
 11533                                  ; ---------------------------------------------------------------------------
 11534                                  
 11535                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11536                                  _$IF:
 11537                                  	; MSDOS 6.0
 11538                                  ; Turn off any pipes in progress.
 11539 00000A7F 1E                      	push	ds			;AN004; save local DS
 11540 00000A80 8E1E[E08A]              	mov	ds,[RESSEG]		;AN004; get resident segment
 11541                                  	;assume	ds:resgroup		;AN004;
 11542 00000A84 803E[1902]00            	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
 11543 00000A89 7403                    	jz	short IFNoPipe		;AN004; no pipe - continue
 11544                                  	;invoke	PipeDel 		;AN004; turn off piping
 11545 00000A8B E89022                  	call	PIPEDEL	
 11546                                  IFNoPipe:				;AN004;
 11547 00000A8E 1F                      	pop	ds			;AN004; get local DS back
 11548                                  	;assume	ds:trangroup		;AN004;
 11549                                  
 11550                                  	; MSDOS 3.3 (&MSDOS 6.0)
 11551 00000A8F C606[F38A]00            	mov	byte [IFNOTFLAG],0
 11552 00000A94 C706[BB94]0000          	mov	word [IF_NOT_COUNT],0
 11553 00000A9A BE8100                  	mov	si,81h
 11554                                  IFREENT:
 11555 00000A9D E8661B                  	call	scanoff
 11556 00000AA0 3C0D                    	cmp	al,0Dh
 11557 00000AA2 743C                    	je	short IFERROR
 11558 00000AA4 89F5                    	mov	bp,si
 11559 00000AA6 BF[0E83]                	mov	di,IFTAB		; Prepare to search if table	
 11560                                  	;mov	ch,0
 11561                                  	; 17/04/2023
 11562 00000AA9 30ED                    	xor	ch,ch
 11563                                  IFINDCOM:
 11564 00000AAB 89EE                    	mov	si,bp
 11565 00000AAD 8A0D                    	mov	cl,[di]
 11566 00000AAF 47                      	inc	di
 11567 00000AB0 E33E                    	jcxz	IFSTRING
 11568 00000AB2 EB02                    	jmp	short FIRSTCOMP
 11569                                  IFCOMP:
 11570 00000AB4 7510                    	jnz	short IF_DIF
 11571                                  FIRSTCOMP:
 11572 00000AB6 AC                      	lodsb
 11573 00000AB7 268A25                  	mov	ah,[es:di]
 11574 00000ABA 47                      	inc	di
 11575 00000ABB 38E0                    	cmp	al,ah
 11576 00000ABD 7405                    	je	short IFLP
 11577 00000ABF 80CC20                  	or	ah,20h			; Try lower case
 11578 00000AC2 38E0                    	cmp	al,ah
 11579                                  IFLP:
 11580 00000AC4 E2EE                    	loop	IFCOMP
 11581                                  IF_DIF:
 11582 00000AC6 9F                      	lahf
 11583 00000AC7 01CF                    	add	di,cx			; Bump to next position without affecting flags
 11584 00000AC9 8B1D                    	mov	bx,[di]			; Get handler address
 11585 00000ACB 47                      	inc	di
 11586 00000ACC 47                      	inc	di
 11587 00000ACD 9E                      	sahf
 11588 00000ACE 75DB                    	jnz	short IFINDCOM
 11589 00000AD0 AC                      	lodsb
 11590 00000AD1 3C0D                    	cmp	al,0Dh
 11591                                  IFERRJ:
 11592 00000AD3 740B                    	jz	short IFERROR
 11593 00000AD5 E8361B                  	call	DELIM
 11594 00000AD8 75D1                    	jnz	short IFINDCOM
 11595 00000ADA E8291B                  	call	scanoff
 11596 00000ADD FFE3                    	jmp	bx
 11597                                  
 11598                                  	; 17/04/2023
 11599                                  IFERRORP:
 11600 00000ADF 58                      	pop	ax
 11601                                  IFERROR:
 11602                                  	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11603                                  FORERROR:
 11604 00000AE0 BA[0D80]                	mov	dx,SYNTMES_PTR
 11605 00000AE3 E9941E                  	jmp	cerror
 11606                                  
 11607                                  IFNOT:
 11608 00000AE6 F616[F38A]              	not	byte [IFNOTFLAG]
 11609 00000AEA FF06[BB94]              	inc	word [IF_NOT_COUNT]
 11610 00000AEE EBAD                    	jmp	short IFREENT
 11611                                  
 11612                                  ; We are comparing two strings for equality. First, find the end of the
 11613                                  ; first string.
 11614                                  
 11615                                  IFSTRING:
 11616 00000AF0 56                      	push	si			; save away pointer for later compare
 11617 00000AF1 31C9                    	xor	cx,cx			; count of chars in first string
 11618                                  FIRST_STRING:
 11619 00000AF3 AC                      	lodsb				; get character
 11620 00000AF4 3C0D                    	cmp	al,0Dh			; end of line?
 11621 00000AF6 74E7                    	jz	short IFERRORP		; yes => error
 11622 00000AF8 E8131B                  	call	DELIM			; is it a delimiter?
 11623 00000AFB 7403                    	jz	short EQUAL_CHECK 	; yes, go find equal sign
 11624 00000AFD 41                      	inc	cx			; remember 1 byte for the length
 11625 00000AFE EBF3                    	jmp	short FIRST_STRING 	; go back for more
 11626                                  EQUAL_CHECK:
 11627 00000B00 3C3D                    	cmp	al,'='			; is char we have an = sign?
 11628 00000B02 7407                    	je	short EQUAL_CHECK2 	; yes, go find second one.
 11629 00000B04 3C0D                    	cmp	al,0Dh			; end of line?
 11630 00000B06 74D7                    	je	short IFERRORP		; yes, syntax error
 11631 00000B08 AC                      	lodsb				; get next char
 11632 00000B09 EBF5                    	jmp	short EQUAL_CHECK
 11633                                  
 11634                                  ; The first = has been found. The next char had better be an = too.
 11635                                  
 11636                                  EQUAL_CHECK2:
 11637 00000B0B AC                      	lodsb				; get potential = char
 11638 00000B0C 3C3D                    	cmp	al,'='			; is it good?	
 11639                                  	;jnz	short IFERRPJ		; no, error
 11640                                  	; 17/04/2023
 11641 00000B0E 75CF                    	jne	short IFERRORP
 11642                                  
 11643                                  ; Find beginning of second string.
 11644                                  
 11645 00000B10 E8F31A                  	call	scanoff
 11646 00000B13 3C0D                    	cmp	al,0Dh
 11647                                  	;jz	short IFERRPJ
 11648                                  	; 17/04/2023
 11649 00000B15 74C8                    	je	short IFERRORP
 11650 00000B17 5F                      	pop	di
 11651                                  
 11652                                  ; DS:SI points to second string
 11653                                  ; CX has number of chars in first string
 11654                                  ; ES:DI points to first string
 11655                                  
 11656 00000B18 F3A6                    	repe	cmpsb
 11657 00000B1A 7414                    	jz	short MATCH		; match found!
 11658                                  
 11659                                  ; No match. Let's find out what was wrong. The character that did not match
 11660                                  ; has been advanced over. Let's back up to it.
 11661                                  
 11662 00000B1C 4E                      	dec	si
 11663                                  
 11664                                  ; If it is EOL, then syntax error
 11665                                  
 11666 00000B1D 803C0D                  	cmp	byte [si],0Dh
 11667                                  	;jz	short IFERRJ
 11668                                  	; 17/04/2023
 11669 00000B20 74BE                    	je	short IFERROR
 11670                                  
 11671                                  ; Advance pointer over remainder of unmatched text to next delimiter
 11672                                  
 11673                                  SKIPSTRINGEND:
 11674 00000B22 AC                      	lodsb
 11675                                  NOTMATCH:
 11676 00000B23 3C0D                    	cmp	al,0Dh
 11677                                  IFERRORJ2:
 11678                                  	;jz	short IFERRJ
 11679                                  	; 17/04/2023
 11680 00000B25 74B9                    	jz	short IFERROR
 11681 00000B27 E8E41A                  	call	DELIM
 11682 00000B2A 75F6                    	jnz	short SKIPSTRINGEND
 11683                                  
 11684                                  ; Signal that we did NOT have a match
 11685                                  
 11686 00000B2C B0FF                    	mov	al,-1
 11687 00000B2E EB37                    	jmp	short IFRET
 11688                                  
 11689                                  	; 17/04/2023
 11690                                  ;IFERRPJ:
 11691                                  	;jmp	IFERRORP
 11692                                  
 11693                                  ; The compare succeeded. Was the second string longer than the first?
 11694                                  ; We do this by seeing if the next char is a delimiter.
 11695                                  
 11696                                  MATCH:
 11697 00000B30 AC                      	lodsb
 11698 00000B31 E8DA1A                  	call	DELIM
 11699 00000B34 75ED                    	jnz	short NOTMATCH ; not same.
 11700 00000B36 30C0                    	xor	al,al
 11701 00000B38 EB2D                    	jmp	short IFRET
 11702                                  
 11703                                  ; ---------------------------------------------------------------------------
 11704                                  
 11705                                  IFEXISTS:
 11706                                  
 11707                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
 11708                                  
 11709                                  ;MOREDELIM:
 11710 00000B3A AC                      	lodsb
 11711 00000B3B E8D01A                  	call	DELIM
 11712 00000B3E 75FA                    	jnz	short IFEXISTS
 11713                                  	;jnz	short MOREDELIM
 11714                                  
 11715 00000B40 BA[E98B]                	mov	dx,DIRBUF
 11716 00000B43 B8001A                  	mov	ax,1A00h
 11717                                  	;mov	ax,Set_DMA*256 ; 1A00h
 11718 00000B46 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11719                                  			; DS:DX	-> disk	transfer buffer
 11720 00000B48 BB0200                  	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
 11721 00000B4B 031E[BB94]              	add	bx,[IF_NOT_COUNT]
 11722                                  	;mov	ax,ARG_ARGV
 11723                                  	;mov	ax,ARG+ARG_UNIT.argv
 11724 00000B4F B8[6F8E]                	mov	ax,ARG
 11725 00000B52 E84326                  	call	argv_calc		; convert arg index to pointer
 11726 00000B55 8B17                    	mov	dx,[bx]
 11727                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 11728                                  	;mov	cx,6
 11729 00000B57 B90600                  	mov	cx,IFEXIST_ATTR ; filetypes to search for
 11730 00000B5A B8004E                  	mov	ax,4E00h
 11731                                  	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 11732 00000B5D CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11733                                  			; CX = search attributes
 11734                                  			; DS:DX	-> ASCIZ filespec
 11735                                  			; (drive,path, and wildcards allowed)
 11736 00000B5F 7204                    	jc	short IF_EX_C ; carry is how to determine error
 11737 00000B61 30C0                    	xor	al,al
 11738 00000B63 EB02                    	jmp	short IFRET
 11739                                  
 11740                                  	;nop
 11741                                  IF_EX_C:
 11742 00000B65 B0FF                    	mov	al,-1			; false 'n' fall through...
 11743                                  IFRET:
 11744 00000B67 F606[F38A]FF            	test	byte [IFNOTFLAG],-1 ; 0FFh
 11745 00000B6C 7402                    	jz	short REALTEST
 11746 00000B6E F6D0                    	not	al
 11747                                  REALTEST:
 11748 00000B70 08C0                    	or	al,al
 11749 00000B72 7403                    	jz	short IFTRUE
 11750 00000B74 E98DF5                  	jmp	TCOMMAND
 11751                                  
 11752                                  IFTRUE:
 11753 00000B77 E88C1A                  	call	scanoff
 11754 00000B7A 89F1                    	mov	cx,si
 11755 00000B7C 81E98100                	sub	cx,81h
 11756 00000B80 280E8000                	sub	[80h],cl
 11757 00000B84 8A0E8000                	mov	cl,[80h]
 11758 00000B88 880E[4089]              	mov	[COMBUF+1],cl
 11759 00000B8C BF[4189]                	mov	di,COMBUF+2
 11760 00000B8F FC                      	cld
 11761 00000B90 F3A4                    	rep	movsb
 11762 00000B92 B00D                    	mov	al,0Dh
 11763 00000B94 AA                      	stosb
 11764                                  
 11765                                  ; Signal that an IF was done. 
 11766                                  ; This prevents the redirections from getting lost.
 11767                                  
 11768 00000B95 1E                      	push	ds
 11769 00000B96 8E1E[E08A]              	mov	ds,[RESSEG]
 11770 00000B9A C606[AB01]FF            	mov	byte [IfFlag],-1
 11771 00000B9F 1F                      	pop	ds
 11772                                  
 11773                                  ; Go do the command
 11774                                  
 11775 00000BA0 E934F7                  	jmp	DOCOM1
 11776                                  
 11777                                  ; ---------------------------------------------------------------------------
 11778                                  
 11779                                  IFERRORJ3:
 11780 00000BA3 EB80                    	jmp	IFERRORJ2
 11781                                  
 11782                                  IFERLEV:
 11783 00000BA5 B70A                    	mov	bh,10
 11784 00000BA7 30DB                    	xor	bl,bl
 11785                                  GETNUMLP:
 11786 00000BA9 AC                      	lodsb
 11787 00000BAA 3C0D                    	cmp	al,0Dh
 11788 00000BAC 74F5                    	je	short IFERRORJ3
 11789 00000BAE E85D1A                  	call	DELIM
 11790 00000BB1 740C                    	jz	short GOTNUM
 11791 00000BB3 2C30                    	sub	al,'0'
 11792 00000BB5 86C3                    	xchg	al,bl
 11793 00000BB7 F6E7                    	mul	bh
 11794 00000BB9 00D8                    	add	al,bl
 11795 00000BBB 86C3                    	xchg	al,bl
 11796 00000BBD EBEA                    	jmp	short GETNUMLP
 11797                                  GOTNUM:
 11798 00000BBF 1E                      	push	ds
 11799 00000BC0 8E1E[E08A]              	mov	ds,[RESSEG]
 11800 00000BC4 8A26[9D01]              	mov	ah,[RetCode]
 11801 00000BC8 1F                      	pop	ds
 11802 00000BC9 30C0                    	xor	al,al
 11803 00000BCB 38DC                    	cmp	ah,bl
 11804 00000BCD 7398                    	jnb	short IFRET
 11805 00000BCF FEC8                    	dec	al
 11806 00000BD1 EB94                    	jmp	short IFRET
 11807                                  
 11808                                  ; ---------------------------------------------------------------------------
 11809                                  
 11810                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
 11811                                  ; This is a NOP if no batch in progress.
 11812                                  
 11813                                  _SHIFT:
 11814 00000BD3 8E1E[E08A]              	mov	ds,[RESSEG]
 11815 00000BD7 A1[4C01]                	mov	ax,[Batch]		; get batch pointer
 11816 00000BDA 09C0                    	or	ax,ax			; in batch mode?
 11817 00000BDC 7501                    	jnz	short SHIFT1		; yes, operate in batch segment	
 11818                                  SHIFT_RETN:				; no, done.
 11819 00000BDE C3                      	retn
 11820                                  SHIFT1:
 11821 00000BDF 8EC0                    	mov	es,ax
 11822 00000BE1 8ED8                    	mov	ds,ax
 11823                                  
 11824                                  ; Now move the batch args down by 1 word
 11825                                  
 11826                                  	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
 11827                                  	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
 11828 00000BE3 BF0C00                  	mov	di,BATCHSEGMENT.BatParm ; point to parm table
 11829 00000BE6 8D7502                  	lea	si,[di+2]		; make source = dest + 2
 11830 00000BE9 B90900                  	mov	cx,9			; move 9 parameters
 11831 00000BEC F3A5                    	rep	movsw			; SHIFT down
 11832                                  
 11833                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
 11834                                  ; We have copied it into the previous position.
 11835                                  
 11836 00000BEE 833DFF                  	cmp	word [di],-1	; if last one was not in use then
 11837 00000BF1 74EB                    	je	short SHIFT_RETN ; No new parm
 11838                                  
 11839                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
 11840                                  ; Assume, first, that there is no next argument.
 11841                                   
 11842 00000BF3 8B35                    	mov	si,[di]
 11843 00000BF5 C705FFFF                	mov	word [di],-1		; Assume no parm
 11844                                  
 11845                                  ; The parameters are CR separated. Scan for end of this parm.
 11846                                  
 11847                                  SKIPCRLP:
 11848 00000BF9 AC                      	lodsb
 11849 00000BFA 3C0D                    	cmp	al,0Dh
 11850 00000BFC 75FB                    	jne	short SKIPCRLP
 11851                                  
 11852                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
 11853                                  ; are finished. There are no more parms and the pointer has been previously
 11854                                  ; initialized to indicate it.
 11855                                  
 11856 00000BFE 803C00                  	cmp	byte [si],0
 11857 00000C01 74DB                    	jz	short SHIFT_RETN 	; End of parms
 11858 00000C03 8935                    	mov	[di],si			; Pointer to next parm as %9
 11859 00000C05 C3                      	retn
 11860                                  
 11861                                  ; =============== S U B	R O U T	I N E =======================================
 11862                                  
 11863                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
 11864                                  ; returns char in AL, carry set -> eof
 11865                                  
 11866                                  SKIPDELIM:
 11867 00000C06 F706[4C01]FFFF          	test	word [Batch],-1		; batch file empty. OOPS!
 11868 00000C0C 740A                    	jz	short SKIPERR
 11869 00000C0E E85DFD                  	call	GETBATBYT		; get a char
 11870 00000C11 E8FA19                  	call	DELIM			; check for ignoreable chars
 11871 00000C14 74F0                    	jz	short SKIPDELIM		; ignore this char.
 11872 00000C16 F8                      	clc
 11873 00000C17 C3                      	retn
 11874                                  SKIPERR:
 11875 00000C18 F9                      	stc
 11876                                  GOTO_RETN:
 11877 00000C19 C3                      	retn
 11878                                  
 11879                                  ; ---------------------------------------------------------------------------
 11880                                  
 11881                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
 11882                                  ;  .com file. This routine strips the CALL off the command line, sets
 11883                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
 11884                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
 11885                                  ;  being CALLed.
 11886                                  
 11887                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11888                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
 11889                                  _$CALL:
 11890                                  
 11891                                  ;  strip off CALL from command line
 11892                                  
 11893                                  	;ASSUME DS:trangroup,ES:trangroup
 11894                                  
 11895 00000C1A 56                      	push	si
 11896 00000C1B 57                      	push	di
 11897 00000C1C 50                      	push	ax
 11898 00000C1D 51                      	push	cx
 11899 00000C1E BE[4189]                	mov	si,COMBUF+2
 11900 00000C21 E8E219                  	call	scanoff			;get to first non-delimeter
 11901                                  	;add	si,4
 11902 00000C24 83C604                  	add	si,length_call		;point to char past CALL
 11903 00000C27 BF[4189]                	mov	di,COMBUF+2
 11904                                  	;mov	cx,124		
 11905 00000C2A B97C00                  	mov	cx,COMBUFLEN-length_call 
 11906                                  					;get length of buffer
 11907 00000C2D F3A4                    	rep	movsb			;move it
 11908 00000C2F 59                      	pop	cx
 11909 00000C30 58                      	pop	ax
 11910 00000C31 5F                      	pop	di
 11911 00000C32 5E                      	pop	si
 11912                                  
 11913                                  ;  set call flag to indicate call in progress
 11914                                  
 11915 00000C33 1E                      	push	ds
 11916 00000C34 8E1E[E08A]              	mov	ds,[RESSEG]
 11917 00000C38 C606[B101]01            	mov	byte [Call_Flag],call_in_progress ; 1
 11918 00000C3D C606[B201]01            	mov	byte [Call_Batch_Flag],call_in_progress ; 1
 11919                                  
 11920                                  ; Turn off any pipes in progress.
 11921                                  
 11922 00000C42 803E[1902]00            	cmp	byte [PipeFiles],0 	; Only turn off if present.
 11923 00000C47 7403                    	jz	short _NOPIPE
 11924 00000C49 E8D220                  	call	PIPEDEL
 11925                                  _NOPIPE:
 11926 00000C4C 1F                      	pop	ds
 11927 00000C4D C3                      	retn
 11928                                  
 11929                                  ; ---------------------------------------------------------------------------
 11930                                  
 11931                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11932                                  _GOTO:
 11933 00000C4E 8E1E[E08A]              	mov	ds,[RESSEG]
 11934 00000C52 F706[4C01]FFFF          	test	word [Batch],-1	; If not in batch mode, a nop
 11935 00000C58 74BF                    	jz	short GOTO_RETN
 11936 00000C5A 31D2                    	xor	dx,dx
 11937 00000C5C 1E                      	push	ds
 11938 00000C5D 8E1E[4C01]              	mov	ds,[Batch]
 11939                                  	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
 11940 00000C61 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
 11941                                  	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
 11942 00000C65 89160A00                	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
 11943                                  
 11944                                  	; MSDOS 6.0
 11945                                  ;M037
 11946                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
 11947                                  ;
 11948 00000C69 C606020000              	mov	byte [BATCHSEGMENT.BatchEOF],0
 11949                                  					; clear eof indicator ;M037
 11950                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11951 00000C6E 1F                      	pop	ds
 11952                                  GOTOOPEN:
 11953 00000C6F E86FF8                  	call	PROMPTBAT
 11954                                  	;mov	di,5Dh
 11955 00000C72 BF5D00                  	mov	di,FCB+1		; Get the label
 11956 00000C75 B90B00                  	mov	cx,11
 11957 00000C78 B020                    	mov	al,' '
 11958 00000C7A F2AE                    	repne	scasb
 11959 00000C7C 7501                    	jnz	short NOINC
 11960 00000C7E 41                      	inc	cx
 11961                                  NOINC:
 11962 00000C7F 83E90B                  	sub	cx,11
 11963 00000C82 F7D9                    	neg	cx
 11964                                  	;mov	[cs:GOTOLEN],cx
 11965                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11966 00000C84 26890E[E98B]            	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)
 11967                                  
 11968                                  ; At beginning of file. Skip to first non-delimiter char
 11969                                  
 11970 00000C89 E87AFF                  	call	SKIPDELIM
 11971 00000C8C 721C                    	jb	short BADGOTO
 11972 00000C8E 3C3A                    	cmp	al,':'
 11973 00000C90 7426                    	jz	short CHKLABEL
 11974                                  LABLKLP:				; Look for the label
 11975 00000C92 E8D9FC                  	call	GETBATBYT
 11976 00000C95 3C0A                    	cmp	al,0Ah
 11977 00000C97 7509                    	jne	short LABLKTST
 11978                                  
 11979                                  ; At beginning of line. Skip to first non-delimiter char
 11980                                  
 11981 00000C99 E86AFF                  	call	SKIPDELIM
 11982 00000C9C 720C                    	jb	short BADGOTO
 11983 00000C9E 3C3A                    	cmp	al,':'
 11984 00000CA0 7416                    	je	short CHKLABEL
 11985                                  LABLKTST:
 11986 00000CA2 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; -1
 11987 00000CA8 75E8                    	jnz	short LABLKLP
 11988                                  BADGOTO:
 11989 00000CAA E87100                  	call	BATCLOSE
 11990                                  
 11991                                  	; MSDOS 6.0
 11992                                  ;SR;
 11993                                  ; At this point we are terminating without freeing up any nested batch 
 11994                                  ;segments i.e if the error occurred within a called batch file. This routine
 11995                                  ;will traverse the linked list of batch segments and free all of them.
 11996                                  ;
 11997 00000CAD E8BB00                  	call	free_batch		; free up nested batch segments
 11998                                  
 11999                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12000 00000CB0 0E                      	push	cs
 12001 00000CB1 1F                      	pop	ds
 12002 00000CB2 BA[0A80]                	mov	dx,BADLAB_PTR
 12003 00000CB5 E9C21C                  	jmp	cerror
 12004                                  
 12005                                  ; Found the :.	Skip to first non-delimiter char
 12006                                  
 12007                                  CHKLABEL:
 12008 00000CB8 E84BFF                  	call	SKIPDELIM
 12009 00000CBB 72ED                    	jb	short BADGOTO
 12010 00000CBD BF5D00                  	mov	di,FCB+1 ; 5Dh
 12011                                  	;mov	cx,[cs:GOTOLEN]
 12012                                  	; 14/02/2023
 12013 00000CC0 268B0E[E98B]            	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12014 00000CC5 EB05                    	jmp	short GOTBYTE
 12015                                  
 12016                                  NEXTCHRLP:
 12017 00000CC7 51                      	push	cx
 12018 00000CC8 E8A3FC                  	call	GETBATBYT
 12019 00000CCB 59                      	pop	cx
 12020                                  GOTBYTE:
 12021                                  	; 18/03/2023
 12022                                  	; 14/02/2023
 12023                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
 12024 00000CCC E81517                  	call	testkanj
 12025 00000CCF 7413                    	jz	short NOTKANJ1
 12026 00000CD1 263A05                  	cmp	al,[es:di]
 12027 00000CD4 75CC                    	jne	short LABLKTST
 12028 00000CD6 47                      	inc	di
 12029 00000CD7 49                      	dec	cx
 12030 00000CD8 E3C8                    	jcxz	LABLKTST
 12031 00000CDA 51                      	push	cx
 12032 00000CDB E890FC                  	call	GETBATBYT
 12033 00000CDE 59                      	pop	cx
 12034 00000CDF 263A05                  	cmp	al,[es:di]
 12035 00000CE2 EB0C                    	jmp	short KNEXTLABCHR
 12036                                  NOTKANJ1:
 12037                                  	; 14/02/2023
 12038                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
 12039 00000CE4 0C20                    	or	al,20h
 12040 00000CE6 263A05                  	cmp	al,[es:di]
 12041                                  	;jne	short TRYUPPER
 12042                                  	;jmp	short NEXTLABCHR
 12043                                  	; 25/04/2023
 12044 00000CE9 7407                    	je	short NEXTLABCHR 
 12045                                  TRYUPPER:
 12046 00000CEB 2C20                    	sub	al,20h
 12047 00000CED 263A05                  	cmp	al,[es:di]
 12048                                  KNEXTLABCHR:
 12049 00000CF0 75B0                    	jnz	short LABLKTST
 12050                                  NEXTLABCHR:
 12051 00000CF2 47                      	inc	di
 12052 00000CF3 E2D2                    	loop	NEXTCHRLP
 12053 00000CF5 E876FC                  	call	GETBATBYT
 12054                                  	; 14/02/2023
 12055 00000CF8 26833E[E98B]08          	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
 12056                                  	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
 12057 00000CFE 7D04                    	jge	short GOTOCONT	; Yes, then the next char doesn't matter
 12058 00000D00 3C20                    	cmp	al,' '
 12059 00000D02 779E                    	ja	short LABLKTST
 12060                                  GOTOCONT:
 12061 00000D04 3C0D                    	cmp	al,0Dh
 12062 00000D06 7407                    	je	short SKIPLFEED
 12063                                  TONEXTBATLIN:
 12064 00000D08 E863FC                  	call	GETBATBYT
 12065 00000D0B 3C0D                    	cmp	al,0Dh
 12066 00000D0D 75F9                    	jne	short TONEXTBATLIN
 12067                                  SKIPLFEED:
 12068 00000D0F E85CFC                  	call	GETBATBYT
 12069                                  
 12070                                  	; MSDOS 6.0
 12071                                  ;SR;
 12072                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
 12073                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
 12074                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
 12075                                  ;to get the EOF has not been made yet because we encountered the Goto. On
 12076                                  ;all other cases, EOF will be hit while trying to read the next line and
 12077                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
 12078                                  ;
 12079 00000D12 06                      	push	es
 12080 00000D13 8E06[4C01]              	mov	es,[Batch]
 12081 00000D17 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 12082                                  					;invalidate fake CR-LF flag
 12083 00000D1D 07                      	pop	es
 12084                                  
 12085                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12086                                  	;call	BATCLOSE
 12087                                  	;retn
 12088                                  	; 14/02/2023
 12089                                  	;jmp	short BATCLOSE
 12090                                  
 12091                                  ; =============== S U B	R O U T	I N E =======================================
 12092                                  
 12093                                  BATCLOSE:
 12094 00000D1E 2E8B1E[148E]            	mov	bx,[cs:BATHAND]
 12095 00000D23 83FB05                  	cmp	bx,5
 12096 00000D26 7204                    	jb	short CLOSERETURN
 12097                                  	; 14/02/2023
 12098 00000D28 B43E                    	mov	ah,3Eh
 12099                                  	;mov	ah,CLOSE ; 3Eh
 12100 00000D2A CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 12101                                  			; BX = file handle
 12102                                  CLOSERETURN:
 12103 00000D2C C606[9501]00            	mov	byte [In_Batch],0 ; reset flag	
 12104 00000D31 C3                      	retn
 12105                                  
 12106                                  ; =============== S U B	R O U T	I N E =======================================
 12107                                  
 12108                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
 12109                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
 12110                                  
 12111                                  	; 14/02/2023
 12112                                  BATOPEN:
 12113 00000D32 1E                      	push	ds
 12114 00000D33 8E1E[4C01]              	mov	ds,[Batch]
 12115                                  	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
 12116                                  	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
 12117 00000D37 BA2000                  	mov	dx,BATCHSEGMENT.BatFile
 12118 00000D3A B8003D                  	mov	ax,3D00h
 12119                                  	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
 12120 00000D3D CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 12121                                  			; DS:DX	-> ASCIZ filename
 12122                                  			; AL = access mode
 12123                                  			; 0 - read
 12124 00000D3F 721C                    	jb	short SETERRDL
 12125                                  	;mov	dx,[8]
 12126 00000D41 8B160800                	mov	dx,[BATCHSEGMENT.BatSeek]
 12127                                  	;mov	cx,[10]
 12128 00000D45 8B0E0A00                	mov	cx,[BATCHSEGMENT.BatSeek+2]
 12129 00000D49 1F                      	pop	ds
 12130                                  	;mov	[cs:BATHAND],ax
 12131 00000D4A 26A3[148E]              	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12132 00000D4E 89C3                    	mov	bx,ax
 12133 00000D50 B80042                  	mov	ax,4200h
 12134                                  	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
 12135 00000D53 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 12136                                  			; AL = method: offset from beginning of	file
 12137                                  
 12138                                  	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
 12139                                  					; nuke batch buffer position
 12140 00000D55 26C706[E795]FFFF        	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12141                                  BATOPEN_RETN:
 12142 00000D5C C3                      	retn
 12143                                  
 12144                                  SETERRDL:
 12145 00000D5D 89D3                    	mov	bx,dx
 12146                                  	; MSDOS 6.0
 12147                                  	;invoke	get_ext_error_number 	;AN022; get the extended error
 12148                                  	; 14/02/2023
 12149 00000D5F E8BB0F                  	call	get_ext_error_number
 12150 00000D62 89C2                    	mov	dx,ax		     	;AN022; save extended error in DX
 12151                                  
 12152                                  	; MSDOS 3.3
 12153                                  	;mov	dx,INSERTDSKPTR
 12154                                  	;call	GET_EXT_ERR_NUMBER
 12155                                  
 12156                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12157 00000D64 8A07                    	mov	al,[bx]			; Get drive spec
 12158 00000D66 2C40                    	sub	al,'@'			; A = 1
 12159 00000D68 1F                      	pop	ds
 12160 00000D69 F9                      	stc				; SUB mucked over carry
 12161 00000D6A C3                      	retn
 12162                                  
 12163                                  ; =============== S U B	R O U T	I N E =======================================
 12164                                  
 12165                                  ;Free_batch : This routine traverses the linked batch segments freeing all
 12166                                  ;the batch and FOR segments until all of them are freed. It also restores
 12167                                  ;the old state of the EchoFlag.
 12168                                  ;
 12169                                  ;	ENTRY:	ds = RESGROUP
 12170                                  ;
 12171                                  ;	EXIT: 	All batch & FOR segments freed.
 12172                                  ;		EchoFlag restored to old state before batch process.
 12173                                  ;
 12174                                  ;	REGISTERS AFFECTED: bx, cx
 12175                                  
 12176                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12177                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh
 12178                                  
 12179                                  free_batch: ;proc near
 12180                                  	;assume	ds:RESGROUP,es:nothing
 12181                                  
 12182 00000D6B 06                      	push	es
 12183 00000D6C 8B1E[B301]              	mov	bx,[Next_Batch]
 12184 00000D70 09DB                    	or	bx,bx
 12185 00000D72 7432                    	jz	short fb_ret
 12186                                  _ClearBatch:
 12187 00000D74 8EC3                    	mov	es,bx			; get batch segment
 12188                                  	;mov	bx,es:BatForPtr		; get old FOR segment
 12189 00000D76 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
 12190 00000D7B 83FB00                  	cmp	bx,0			; is a FOR in progress
 12191 00000D7E 7408                    	je	short no_bat_for	; no - don't deallocate
 12192 00000D80 06                      	push	es			;
 12193 00000D81 8EC3                    	mov	es,bx			; yes - free it up...
 12194 00000D83 B449                    	mov	ah,49h
 12195                                  	;mov	ah,DEALLOC		;
 12196 00000D85 CD21                    	int	21h			;
 12197 00000D87 07                      	pop	es			; restore to batch segment
 12198                                  no_bat_for:
 12199                                  	;mov	cl,[es:1]
 12200 00000D88 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
 12201                                  					; get old echo flag
 12202                                  	;mov	bx,[es:3]
 12203 00000D8D 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 12204                                  					; get old batch segment
 12205 00000D92 B449                    	mov	ah,49h
 12206                                  	;mov	ah,DEALLOC		; free it up...
 12207 00000D94 CD21                    	int	21h
 12208                                  	; 14/02/2023
 12209                                  	;mov	[Batch],bx		; get ready to deallocate next batch
 12210 00000D96 FF0E[AF01]              	dec	word [Nest]		; is there another batch file?
 12211 00000D9A 75D8                    	jnz	short _ClearBatch	; keep going until no batch file
 12212                                  	
 12213 00000D9C 880E[A001]              	mov	[EchoFlag],cl		;restore echo status
 12214 00000DA0 C706[4C01]0000          	mov	word [Batch],0		;no batch process in progress
 12215                                  fb_ret:
 12216 00000DA6 07                      	pop	es
 12217 00000DA7 C3                      	ret
 12218                                  
 12219                                  ;free_batch endp
 12220                                  
 12221                                  ;============================================================================
 12222                                  ; TFOR.ASM, MSDOS 6.0, 1991
 12223                                  ;============================================================================
 12224                                  ; 10/10/2018 - Retro DOS v3.0
 12225                                  
 12226                                  ; All batch proccessing has DS set to segment of resident portion
 12227                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
 12228                                  
 12229                                  ; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h
 12230                                  
 12231                                  ; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12232                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh
 12233                                  
 12234                                  ; ---------------------------------------------------------------------------
 12235                                  
 12236                                  	; 15/02/2023
 12237                                  FORTERM:
 12238                                  	; MSDOS 6.0
 12239 00000DA8 0E                      	push	cs			;AN037; Get local segment into
 12240 00000DA9 1F                      	pop	ds			;AN037;  DS, ES
 12241 00000DAA 0E                      	push	cs			;AN037;
 12242 00000DAB 07                      	pop	es			;AN037;
 12243                                  
 12244                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12245 00000DAC E89702                  	call	FOROFF
 12246                                  	;mov	ds,[cs:RESSEG]
 12247 00000DAF 268E1E[E08A]            	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
 12248 00000DB4 813E[A601]00FF          	cmp	word [SingleCom],0FF00h
 12249 00000DBA 750F                    	jne	short BAT_CRLF
 12250 00000DBC 833E[AF01]00            	cmp	word [Nest],0		;See if we have nested batch files
 12251 00000DC1 7508                    	jne	short BAT_CRLF		;Yes - don't exit just yet
 12252 00000DC3 C706[A601]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
 12253 00000DC9 EB12                    	jmp	short NOFORP2
 12254                                  BAT_CRLF:
 12255 00000DCB F606[A001]01            	test	byte [EchoFlag],1 	; Is echo on?
 12256 00000DD0 740B                    	jz	short NOFORP2		; no - exit
 12257 00000DD2 F706[4C01]FFFF          	test	word [Batch],-1 ; 0FFFFh
 12258                                  					; print CRLF if in batch
 12259 00000DD8 7403                    	jz	short NOFORP2
 12260 00000DDA E81C18                  	call	CRLF2
 12261                                  NOFORP2:
 12262 00000DDD E924F3                  	jmp	TCOMMAND
 12263                                  
 12264                                  ; ---------------------------------------------------------------------------
 12265                                  
 12266                                  ;------
 12267                                  ;   For-loop processing. For loops are of the form:
 12268                                  ;	    for %<loop-variable> in (<list>) do <command>
 12269                                  ; where <command> may contain references of the form %<variable>, which are
 12270                                  ; later substituted with the items in <list>. The for-loop structure is
 12271                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
 12272                                  ; <command> once for each item in <list>. All of the information needed for
 12273                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
 12274                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
 12275                                  ; a complete copy of the original command-line structure as parsed by
 12276                                  ; 'parseline', loop control variables, and a dma buffer for the
 12277                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
 12278                                  ; processing has completed, this chunk of memory is returned to the system.
 12279                                  ;
 12280                                  ;   All of the previously defined variables, in 'datares', used for loop
 12281                                  ; processing may be erased. Only one, (DW) ForPtr, need be allocated.
 12282                                  ;
 12283                                  ;   The error message, 'for_alloc_mes', should be moved into the file
 12284                                  ; containing all of the other error messages.
 12285                                  ;
 12286                                  ;   Referencing the allocated for-loop structure is a little tricky.
 12287                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
 12288                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
 12289                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
 12290                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
 12291                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
 12292                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
 12293                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
 12294                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
 12295                                  ; instead of
 12296                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
 12297                                  ; By using 'f', we pretend that we are actually referencing an allocated
 12298                                  ; structure, and the assembler coughs up the code we want. Notice that it
 12299                                  ; doesn't matter whether we put brackets around the location or not -- the
 12300                                  ; assembler is "smart" enough to know that we want an address instead of the
 12301                                  ; contents of that location.
 12302                                  ;
 12303                                  ;   Finally, there now exists the potential to easily implement nested loops.
 12304                                  ; One method would be to have a link field in each for-structure pointing to
 12305                                  ; its parent.  Variable references that couldn't be resolved in the local
 12306                                  ; frame would cause a search of prior frames. For-structures would still be
 12307                                  ; allocated and released in exactly the same fashion. The only limit on the
 12308                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
 12309                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
 12310                                  ; maintained in the resident data area. This structure would be an array of
 12311                                  ; control-variable names and pointers to for-structure blocks. This would
 12312                                  ; greatly speed up the resolution of non-local variable references. However,
 12313                                  ; since space in the resident is precious, we would have to compromise on a
 12314                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
 12315                                  ; allocation and de-allocation would have to be modified slightly to take this
 12316                                  ; new structure into account.
 12317                                  ;
 12318                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
 12319                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
 12320                                  ; it may be easier to allocate it as part of 'for_segment'.
 12321                                  ;------
 12322                                  		; include fordata.asm
 12323                                  
 12324                                  ; Data structure definitions included by tfor.asm
 12325                                  
 12326                                  struc FOR_INFO
 12327 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
 12328 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
 12329 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
 12330 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
 12331 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
 12332 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
 12333 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
 12334 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
 12335                                    .size:
 12336                                  endstruc
 12337                                  					; ARG_UNIT.SIZE = 1348 (544h)
 12338                                  _$FOR_EXIT:
 12339 00000DE0 EBC6                    	jmp	short FORTERM		; exceeding maxarg means all done
 12340                                  
 12341                                  ; ---------------------------------------------------------------------------
 12342                                  
 12343                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
 12344                                  FORPROC:
 12345 00000DE2 A1[AD01]                	mov	ax,[ForPtr]
 12346 00000DE5 8ED8                    	mov	ds,ax
 12347 00000DE7 8EC0                    	mov	es,ax			; operate in for-info area
 12348                                  	;mov	dx,5CBh	; MSDOS 5.0
 12349 00000DE9 BACB05                  	mov	dx,FOR_INFO.FORDMA ; 5CBh
 12350                                  					; 1348+1+2+2+2+128 = 1483 = 5CBh
 12351 00000DEC B8001A                  	mov	ax,1A00h
 12352                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12353 00000DEF CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12354                                  			; DS:DX	-> disk	transfer buffer
 12355                                  FOR_BEGIN:
 12356                                  	;cmp	word [545h],0
 12357 00000DF1 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0 ; [545h]
 12358 00000DF6 7404                    	jz	short FOR_BEGIN1
 12359                                  					; non-zero for_expand equals FALSE
 12360                                  	;inc	word [547h]
 12361 00000DF8 FF064705                	inc	word [FOR_INFO.FOR_MINARG] ; [547h]
 12362                                  FOR_BEGIN1:
 12363 00000DFC 8B1E4705                	mov	bx,[FOR_INFO.FOR_MINARG] ; [547h]
 12364                                  					; current item in <list> to examine
 12365 00000E00 3B1E4905                	cmp	bx,[FOR_INFO.FOR_MAXARG] ; [549h]
 12366 00000E04 7FDA                    	jg	short _$FOR_EXIT	; exceeding maxarg means all done	
 12367                                  	;mov	ax,0
 12368 00000E06 B80000                  	mov	ax,FOR_INFO.FOR_ARGS ; 0 
 12369 00000E09 E88C23                  	call	argv_calc		; compute argv[x] address
 12370                                  	;mov	cx,[bx+3]
 12371 00000E0C 8B4F03                  	mov	cx,[bx+ARGV_ELE.argstartel]
 12372 00000E0F 8B17                    	mov	dx,[bx]
 12373                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12374                                  	;test	byte [bx+2],4		; Is there a path separator in this arg?
 12375 00000E11 F6470204                	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 12376 00000E15 7514                    	jnz	short FORSUB		; Yes, argstartel should be correct
 12377 00000E17 8B37                    	mov	si,[bx]
 12378                                  	;mov	si,[bx+ARGV_ELE.argpointer]
 12379                                  
 12380                                  	;mov	al,[cs:LPAREN]
 12381                                  	; 15/02/2023
 12382                                  	; MSDOS 6.0 (& 5.0) COMMAND.com
 12383 00000E19 B028                    	mov	al,'('	; mov al,lparen
 12384 00000E1B 3844FF                  	cmp	[si-1],	al		; If the current token is the first
 12385 00000E1E 750B                    	jne	short FORSUB		;  one in the list and originally had
 12386 00000E20 41                      	inc	cx			;  the opening paren as its first char,
 12387                                  					;  the argstartel ptr needs to be
 12388                                  					;  advanced passed it before the prefix
 12389                                  					;  length is computed.
 12390 00000E21 B03A                    	mov	al,':'
 12391 00000E23 384401                  	cmp	[si+1],	al		; If the token begins with "(d:",
 12392 00000E26 7503                    	jne	short FORSUB		;  argstartel has to be moved over the
 12393 00000E28 83C102                  	add	cx,2			;  rest of the prefix as well.
 12394                                  FORSUB:
 12395 00000E2B 29D1                    	sub	cx,dx			; compute length of pathname prefix
 12396                                  	;cmp	word [545h],0
 12397 00000E2D 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12398                                  					; are we still expanding a name?
 12399 00000E32 7416                    	jz	short FOR_FIND_NEXT
 12400                                  					; if so, get next matching filename
 12401                                  	;test	byte [bx+2],2
 12402 00000E34 F6470202                	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
 12403 00000E38 7505                    	jnz	short FOR_FIND_FIRST
 12404                                  					; should we expand THIS (new) arg?
 12405                                  	;mov	cx,[bx+5]	
 12406                                  					; else, just copy all of it directly	
 12407 00000E3A 8B4F05                  	mov	cx,[bx+ARGV_ELE.arglen]
 12408 00000E3D EB1D                    	jmp	short FOR_SMOOSH
 12409                                  
 12410                                  	;nop
 12411                                  	; 15/02/2023
 12412                                  FOR_FIND_FIRST:
 12413 00000E3F 51                      	push	cx
 12414 00000E40 31C9                    	xor	cx,cx
 12415 00000E42 B8004E                  	mov	ax,4E00h
 12416                                  	;mov	ax,Find_First*256 ; 4E00h
 12417 00000E45 CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12418                                  			; CX = search attributes
 12419                                  			; DS:DX	-> ASCIZ filespec
 12420                                  			; (drive,path, and wildcards allowed)
 12421 00000E47 59                      	pop	cx
 12422 00000E48 EB05                    	jmp	short FOR_RESULT
 12423                                  
 12424                                  	;nop
 12425                                  FOR_FIND_NEXT:
 12426 00000E4A B8004F                  	mov	ax,4F00h
 12427                                  	;mov	ax,Find_Next*256 ;4F00h
 12428 00000E4D CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 12429                                  			; [DTA]	= data block from
 12430                                  			; last AH = 4Eh/4Fh call
 12431                                  FOR_RESULT:
 12432 00000E4F B8FFFF                  	mov	ax,-1 ; 0FFFFh		; assume worst case
 12433 00000E52 7201                    	jc	short FOR_CHECK
 12434                                  	; 15/02/2023
 12435 00000E54 40                      	inc	ax ; ax = 0
 12436                                  	;mov	ax,0			; Find* returns 0 for SUCCESS
 12437                                  FOR_CHECK:				; record success of findfirst/next
 12438 00000E55 A34505                  	mov	[FOR_INFO.FOR_EXPAND],ax
 12439 00000E58 09C0                    	or	ax,ax			; anything out there?
 12440 00000E5A 7595                    	jnz	short FOR_BEGIN		; if not, try next arg
 12441                                  FOR_SMOOSH:
 12442                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12443 00000E5C 8B37                    	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
 12444                                  	;mov	di,54Bh	; MSDOS 5.0
 12445 00000E5E BF4B05                  	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
 12446 00000E61 F3A4                    	rep	movsb			; arg, some days just the path prefix
 12447                                  					
 12448 00000E63 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12449                                  					; if we're not expanding, we can
 12450 00000E68 7509                    	jnz	short FOR_MAKE_COM 	; skip the following	
 12451                                  	; 15/02/2023
 12452                                  	;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.0 COMMAND.COM
 12453 00000E6A BEE905                  	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
 12454                                  FOR_MORE:
 12455                                  	;cmp	byte [si],0		; tack on matching filename
 12456                                  	;jz	short FOR_MAKE_COM
 12457                                  	;movsb
 12458                                  	;jnz	short FOR_MORE
 12459                                  	; 25/04/2023
 12460 00000E6D AC                      	lodsb
 12461 00000E6E AA                      	stosb
 12462 00000E6F 08C0                    	or	al,al
 12463 00000E71 75FA                    	jnz	short FOR_MORE
 12464                                  FOR_MAKE_COM:
 12465                                  	; 25/04/2023
 12466                                  	;xor	al,al			; tack a null byte onto the end
 12467                                  	;stosb				; of the substitute string
 12468 00000E73 31C9                    	xor	cx,cx			; character count for command line
 12469 00000E75 F7D1                    	not	cx			; negate it -- take advantage of loopnz
 12470 00000E77 31DB                    	xor	bx,bx			; argpointer
 12471 00000E79 BF[4189]                	mov	di,COMBUF+2
 12472                                  	; 15/02/2023
 12473                                  	;mov	bl,[544h]  ; MSDOS 5.0
 12474 00000E7C 8A1E4405                	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
 12475                                  	;mov	dh,[64Bh]
 12476 00000E80 8A364B06                	mov	dh,[FOR_INFO.FOR_VAR] 
 12477                                  					; %<for-var> is replaced by [forbuf]
 12478 00000E84 0E                      	push	cs			; time to form the <command> string
 12479 00000E85 07                      	pop	es
 12480                                  	;assume ES:trangroup
 12481                                  	;mov	ax,FOR_INFO.FOR_ARGS
 12482 00000E86 B80000                  	mov	ax,0			; translate offset to pointer
 12483 00000E89 E80C23                  	call	argv_calc
 12484                                  	;mov	si,[bx+9]
 12485 00000E8C 8B7709                  	mov	si,[bx+ARGV_ELE.arg_ocomptr] 
 12486                                  					; mov ptr passed beginning space
 12487 00000E8F 46                      	inc	si
 12488                                  FOR_MAKE_LOOP:
 12489 00000E90 8A04                    	mov	al,[si]			; the <command> arg, byte by byte
 12490 00000E92 46                      	inc	si
 12491 00000E93 3C25                    	cmp	al,'%'			; looking for %<control-variable>
 12492 00000E95 7514                    	jne	short FOR_STOSB 	; no % ... add byte to string
 12493 00000E97 3834                    	cmp	[si],dh			; got the right <variable>?
 12494 00000E99 7510                    	jnz	short FOR_STOSB		; got a %, but wrong <variable>
 12495 00000E9B 46                      	inc	si			; skip over <for-variable>
 12496                                  
 12497 00000E9C 56                      	push	si
 12498                                  	; 15/02/2023
 12499                                  	;mov	si,54Bh	; MSDOS 5.0
 12500 00000E9D BE4B05                  	mov	si,FOR_INFO.FORBUF
 12501                                  					; substitute the <item> for <variable>
 12502                                  					; to make a final <command> to execute
 12503                                  SLOOP:					
 12504 00000EA0 AC                      	lodsb				; grab all those <item> bytes, and
 12505 00000EA1 AA                      	stosb				; add 'em to the <command> string,
 12506 00000EA2 08C0                    	or	al,al			; until we run into a null
 12507 00000EA4 E0FA                    	loopne	SLOOP
 12508 00000EA6 4F                      	dec	di			; adjust length and <command> pointer
 12509 00000EA7 41                      	inc	cx			; so we can overwrite the null
 12510 00000EA8 5E                      	pop	si
 12511 00000EA9 EBE5                    	jmp	short FOR_MAKE_LOOP
 12512                                  					; got back for more <command> bytes
 12513                                  FOR_STOSB:
 12514 00000EAB AA                      	stosb				; take a byte from the <command> arg
 12515 00000EAC 49                      	dec	cx			; and put it into the <command> to be
 12516                                  					; executed (and note length, too)
 12517 00000EAD 3C0D                    	cmp	al,0Dh		
 12518 00000EAF 75DF                    	jne	short FOR_MAKE_LOOP ; If not done, loop.
 12519                                  FOR_MADE_COM:
 12520 00000EB1 F6D1                    	not	cl
 12521                                  	;mov	[cs:COMBUF+1],cl
 12522                                  	;mov	ds,[cs:RESSEG]
 12523                                  	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
 12524                                  	; MSDOS 5.0 COMMAND.COM
 12525 00000EB3 26880E[4089]            	mov	[es:COMBUF+1],cl
 12526 00000EB8 268E1E[E08A]            	mov	ds,[es:RESSEG]				
 12527                                  	;assume DS:resgroup
 12528 00000EBD F606[A001]01            	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
 12529 00000EC2 742F                    	jz	short NOECHO3
 12530                                  	;cmp	byte [NullFlag],nullcommand
 12531 00000EC4 803E[B501]01            	cmp	byte [NullFlag],1 	;G was there a command last time?
 12532 00000EC9 7403                    	jz	short NO_CRLF_PR  	;G no - don't print crlf	 	
 12533                                  
 12534 00000ECB E82B17                  	call	CRLF2		  	;G Print out prompt
 12535                                  NO_CRLF_PR:
 12536 00000ECE C606[B501]00            	mov	byte [NullFlag],0 	;G reset no command flag
 12537 00000ED3 0E                      	push	cs
 12538 00000ED4 1F                      	pop	ds
 12539 00000ED5 57                      	push	di
 12540 00000ED6 E8D40E                  	call	PRINT_PROMPT	  	;G Prompt the user
 12541 00000ED9 5F                      	pop	di
 12542                                  
 12543 00000EDA 26C645FF00              	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
 12544 00000EDF C706[D08C][4189]        	mov	word [string_ptr_2],COMBUF+2
 12545                                  	; 17/04/2023
 12546 00000EE5 BA[3C81]                	mov	dx,string_buf_ptr
 12547 00000EE8 E8583F                  	call	std_printf
 12548 00000EEB 26C645FF0D              	mov	byte [es:di-1],0Dh
 12549 00000EF0 E9E1F3                  	jmp	DOCOM		  	; run silent, run deep...
 12550                                  NOECHO3:
 12551 00000EF3 C606[B501]00            	mov	byte [NullFlag],0
 12552 00000EF8 0E                      	push	cs
 12553 00000EF9 1F                      	pop	ds
 12554 00000EFA E9DAF3                  	jmp	DOCOM1
 12555                                  
 12556                                  FORNESTERRJ:				; no multi-loop processing... yet!		
 12557 00000EFD E84601                  	call	FOROFF
 12558 00000F00 E92901                  	jmp	FORNESTERR
 12559                                  
 12560                                  ; ---------------------------------------------------------------------------
 12561                                  
 12562                                  FORERRORJ:
 12563 00000F03 E9DAFB                  	jmp	FORERROR
 12564                                  
 12565                                  ; ---------------------------------------------------------------------------
 12566                                  
 12567                                  _$FOR:
 12568 00000F06 8E06[E08A]              	mov	es,[RESSEG]
 12569 00000F0A 26803E[AC01]00          	cmp	byte [es:ForFlag],0 ; is another one already running?
 12570 00000F10 75EB                    	jnz	short FORNESTERRJ   ; if flag is set.... boom!
 12571                                  
 12572                                  ; Turn off any pipes in progress.
 12573                                  
 12574 00000F12 26803E[1902]00          	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
 12575 00000F18 7403                    	jz	short NO_PIPE
 12576 00000F1A E8011E                  	call	PIPEDEL
 12577                                  NO_PIPE:
 12578 00000F1D 31D2                    	xor	dx,dx			; counter (0 <= DX < argvcnt)
 12579 00000F1F E8F400                  	call	NEXTARG			; move to next argv[n]
 12580 00000F22 72DF                    	jc	short FORERRORJ		; no more args -- bad forloop
 12581 00000F24 3C25                    	cmp	al,'%'			; next arg MUST start with '%'...
 12582 00000F26 75DB                    	jne	short FORERRORJ
 12583 00000F28 89C5                    	mov	bp,ax			; save forloop variable
 12584 00000F2A AC                      	lodsb
 12585 00000F2B 08C0                    	or	al,al			; and MUST end immediately...
 12586 00000F2D 75D4                    	jnz	short FORERRORJ
 12587 00000F2F E8E400                  	call	NEXTARG			; let's make sure the next arg is 'in'
 12588 00000F32 72CF                    	jb	short FORERRORJ
 12589                                  	;and	ax,0DFDFh
 12590 00000F34 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12591                                  	; 15/02/2023
 12592                                  	;cmp	ax,4E49h  	; MSDOS 5.0	
 12593                                  	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
 12594                                  	;cmp	ax,in_word	; MSDOS 5.0
 12595 00000F37 3D494E                  	cmp	ax,'IN'
 12596 00000F3A 75C7                    	jnz	short FORERRORJ
 12597 00000F3C AC                      	lodsb
 12598                                  
 12599                                  	; 15/02/2023
 12600                                  	; MSDOS 3.3
 12601                                  	;or	al,al			; it, too, must end right away
 12602                                  	;jz	short CHECKLPAREN
 12603                                  	;cmp	al,[LPAREN]
 12604                                  	;jnz	short FORERRORJ
 12605                                  	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
 12606                                  	;add	word [bx],2
 12607                                  	;;add	word [bx+9],2
 12608                                  	;add	word [bx+ARGV_ELE.arg_ocomptr],2
 12609                                  	;;sub	word [bx+5],2
 12610                                  	;sub	word [bx+ARGV_ELE.arglen],2
 12611                                  	;mov	ax,[si-1]
 12612                                  	;jmp	short LPCHECK
 12613                                  
 12614                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12615                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh
 12616                                  
 12617                                  	; MSDOS 6.0
 12618                                  ; Compaq bug fix -- exit from this loop on error
 12619                                  
 12620 00000F3D 08C0                    	or	al,al
 12621 00000F3F 75C2                    	jne	short FORERRORJ		; jump on error
 12622                                  
 12623                                  ;	je	short CHECKLPAREN
 12624                                  ;
 12625                                  ; Not null. Perhaps there are no spaces between this and the (:
 12626                                  ;   FOR %i in(foo bar...
 12627                                  ; Check for the Lparen here
 12628                                  ;
 12629                                  ;;	cmp	al,lparen
 12630                                  ;;	jnz	short FORERRORJ	
 12631                                  ;
 12632                                  ; The token was in(... We strip off the "in" part to simulate a separator
 12633                                  ; being there in the first place.
 12634                                  ;
 12635                                  ;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
 12636                                  ;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
 12637                                  ;;						; advance original string
 12638                                  ;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
 12639                                  ;
 12640                                  ; SI now points past the in(.  Simulate a nextarg call that results in the
 12641                                  ; current value.
 12642                                  ;
 12643                                  ;;	mov	ax,[si-1]		; get lparen and next char
 12644                                  ;;	jmp	short LPCHECK
 12645                                  ;
 12646                                  ; end of Compaq bug fix
 12647                                  
 12648                                  ; ---------------------------------------------------------------------------
 12649                                  
 12650                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12651                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh
 12652                                  
 12653                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12654                                  CHECKLPAREN:
 12655 00000F41 E8D200                  	call	NEXTARG			; lparen delimits beginning of <list>
 12656 00000F44 72BD                    	jc	short FORERRORJ
 12657                                  LPCHECK:
 12658                                  	; 15/02/2023
 12659                                  	; MSDOS 5.0 (% MSDOS 6.0)	
 12660                                  	;;cmp	al,[LPAREN]
 12661                                  	;cmp	al,lparen
 12662 00000F46 3C28                    	cmp	al,'('
 12663 00000F48 75B9                    	jne	short FORERRORJ
 12664 00000F4A 80FC00                  	cmp	ah,0
 12665 00000F4D 7410                    	je	short FOR_PAREN_TOKEN
 12666                                  	;;cmp	ah,[RPAREN]		; special case:  null list	
 12667                                  	;cmp	ah,rparen
 12668 00000F4F 80FC29                  	cmp	ah,')'
 12669 00000F52 7503                    	jne	short FOR_LIST_NOT_EMPTY
 12670 00000F54 E951FE                  	jmp	FORTERM
 12671                                  FOR_LIST_NOT_EMPTY:
 12672                                  	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
 12673 00000F57 FF07                    	inc	word [bx]		; Advance ptr past "("
 12674                                  	;dec	word [bx+5]		; Adjust the rest of this argv entry	
 12675 00000F59 FF4F05                  	dec	word [bx+ARGV_ELE.arglen] ; to agree.
 12676 00000F5C 46                      	inc	si			; Inc si so check for ")" works
 12677 00000F5D EB0D                    	jmp	short FOR_LIST
 12678                                  
 12679                                  	;nop
 12680                                  FOR_PAREN_TOKEN:
 12681 00000F5F E8B400                  	call	NEXTARG			; what have we in our <list>?
 12682 00000F62 729F                    	jc	short FORERRORJ
 12683                                  	; 15/02/2023
 12684                                  	;;;cmp	ax,[RPAREN+1]	
 12685                                  	;;cmp	ax,[NULLRPAREN]		; special case:  null list
 12686                                  	;cmp	ax,nullrparen
 12687 00000F64 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12688 00000F67 7503                    	jne	short FOR_LIST
 12689 00000F69 E93CFE                  	jmp	FORTERM
 12690                                  
 12691                                  ;FORERORJJ:
 12692                                  	;jmp	FORERROR
 12693                                  
 12694                                  FOR_LIST:				; skip over rest of <list>
 12695 00000F6C 89D1                    	mov	cx,dx			; first arg of <list>
 12696                                  
 12697                                  SKIP_LIST:
 12698                                  	;add	si,[bx+5]
 12699 00000F6E 037705                  	add	si,[bx+ARGV_ELE.arglen]
 12700 00000F71 83EE03                  	sub	si,3			; si = ptr to last char of token
 12701                                  	; 15/02/2023
 12702                                  	;;mov	al,[RPAREN]
 12703                                  	;mov	al,rparen
 12704 00000F74 B029                    	mov	al,')'
 12705 00000F76 3804                    	cmp	[si],al			; Is this the last element in <list>
 12706 00000F78 7408                    	je	short FOR_END_LIST 	; Yes, exit loop.
 12707 00000F7A E89900                  	call	NEXTARG			; No, get next arg <list>
 12708                                  	;jc	short FORERORJJ		; If no more and no rparen, error.
 12709                                  	;jmp	short SKIP_LIST
 12710                                  	; 15/02/2023
 12711 00000F7D 73EF                    	jnc	short SKIP_LIST
 12712                                  
 12713                                  	; 15/02/2023
 12714                                  FORERORJJ:
 12715 00000F7F E95EFB                  	jmp	FORERROR
 12716                                  
 12717                                  FOR_END_LIST:
 12718 00000F82 89D7                    	mov	di,dx			; record position of last arg in <list>
 12719 00000F84 C60400                  	mov	byte [si],0		; Zap the rparen
 12720                                  	; 15/02/2023
 12721                                  	;;;cmp	ax,[RPAREN+1]	
 12722                                  	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
 12723                                  	;cmp	ax,nullparen
 12724 00000F87 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12725 00000F8A 7401                    	je	short FOR_DO		; Yes, continue
 12726 00000F8C 47                      	inc	di			; No, inc position of last arg
 12727                                  FOR_DO:
 12728 00000F8D E88600                  	call	NEXTARG			; now we had BETTER find a 'do'...
 12729 00000F90 72ED                    	jc	short FORERORJJ
 12730                                  	;and	ax,0DFDFh	
 12731 00000F92 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12732                                  	; 15/02/2023
 12733                                  	;;cmp	ax,[DO_WORD]
 12734                                  	;cmp	ax,do_word ; 4F44h
 12735 00000F95 3D444F                  	cmp	ax,'DO'	 ; 4F44h	
 12736 00000F98 75E5                    	jne	short FORERORJJ
 12737 00000F9A AC                      	lodsb
 12738 00000F9B 08C0                    	or	al,al			; and it had BETTER be ONLY a 'do'...
 12739 00000F9D 75E0                    	jnz	short FORERORJJ
 12740                                  		
 12741 00000F9F E87400                  	call	NEXTARG			; on to the beginning of <command>
 12742 00000FA2 72DB                    	jc	short FORERORJJ		; null <command> not legal
 12743                                  
 12744 00000FA4 50                      	push	ax
 12745 00000FA5 53                      	push	bx
 12746 00000FA6 51                      	push	cx
 12747 00000FA7 52                      	push	dx			; preserve registers against disaster
 12748 00000FA8 57                      	push	di
 12749 00000FA9 56                      	push	si
 12750 00000FAA 55                      	push	bp
 12751 00000FAB E856F7                  	call	FREE_TPA		; need to make free memory, first
 12752 00000FAE E89500                  	call	FOROFF
 12753                                  	;mov	bx,264
 12754 00000FB1 BB0801                  	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
 12755 00000FB4 E80C25                  	call	SAVE_ARGS		; extra bytes needed for for-info
 12756 00000FB7 9C                      	pushf
 12757 00000FB8 26A3[AD01]              	mov	[es:ForPtr],ax
 12758 00000FBC E855F7                  	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
 12759 00000FBF 9D                      	popf
 12760 00000FC0 5D                      	pop	bp
 12761 00000FC1 5E                      	pop	si
 12762 00000FC2 5F                      	pop	di
 12763 00000FC3 5A                      	pop	dx
 12764 00000FC4 59                      	pop	cx
 12765 00000FC5 5B                      	pop	bx
 12766 00000FC6 58                      	pop	ax
 12767 00000FC7 723C                    	jc	short FOR_ALLOC_ERR
 12768                                  
 12769 00000FC9 06                      	push	es			; save resgroup seg...
 12770 00000FCA 26FF36[AD01]            	push	word [es:ForPtr]
 12771 00000FCF 07                      	pop	es
 12772                                  	;assume es:for_segment	
 12773 00000FD0 49                      	dec	cx			; forproc wants min pointing before
 12774 00000FD1 4F                      	dec	di			; first arg, max right at last one
 12775                                  	; 15/02/2023
 12776                                  	;mov	[547h],cx
 12777 00000FD2 26890E4705              	mov	[es:FOR_INFO.FOR_MINARG],cx
 12778                                  	;mov	[549h],di
 12779 00000FD7 26893E4905              	mov	[es:FOR_INFO.FOR_MAXARG],di
 12780                                  	;mov	[544h],dl
 12781 00000FDC 2688164405              	mov	[es:FOR_INFO.FOR_COM_START],dl
 12782                                  	;mov	word [545h],0FFFFh ; -1
 12783 00000FE1 26C7064505FFFF          	mov	word [es:FOR_INFO.FOR_EXPAND],-1
 12784                                  					; non-zero means FALSE
 12785 00000FE8 89E8                    	mov	ax,bp
 12786                                  	;mov	[64Bh],ah
 12787 00000FEA 2688264B06              	mov	[es:FOR_INFO.FOR_VAR],ah
 12788 00000FEF 07                      	pop	es
 12789                                  	;assume es:resgroup	
 12790 00000FF0 26FE06[AC01]            	inc	byte [es:ForFlag]
 12791 00000FF5 26833E[A601]FF          	cmp	word [es:SingleCom],-1
 12792 00000FFB 7507                    	jne	short FOR_RET
 12793 00000FFD 26C706[A601]00FF        	mov	word [es:SingleCom],0FF00h
 12794                                  FOR_RET:
 12795 00001004 C3                      	retn
 12796                                  
 12797                                  FOR_ALLOC_ERR:
 12798                                  	; 15/02/2023
 12799                                  	; MSDOS 3.3
 12800                                  	;mov	dx,INSFMEMMESPTR
 12801                                  	;jmp	CERROR
 12802                                  
 12803                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12804                                  	; MSDOS 6.0
 12805                                  	;mov	byte [msg_disp_class],1
 12806 00001005 C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class	
 12807                                  					;AN000; set up extended error msg class
 12808                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr     
 12809 0000100A BA[757F]                	mov	dx,extend_buf_ptr
 12810                                  					;AC000; get extended message pointer
 12811                                  	;mov	word [extend_buf_ptr],8
 12812 0000100D C706[757F]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 12813                                  					;AN000; get message number in control block
 12814 00001013 E96419                  	jmp	cerror
 12815                                  
 12816                                  
 12817                                  ; =============== S U B	R O U T	I N E =======================================
 12818                                  
 12819                                  NEXTARG:
 12820 00001016 42                      	inc	dx			; next argv[n]
 12821                                  	;cmp	dx,[ARG_ARGVCNT]
 12822 00001017 3B16[2F91]              	cmp	dx,[ARG+ARG_UNIT.argvcnt]
 12823                                  					; make sure we don't run off end
 12824 0000101B 7D0D                    	jge	short NEXTARG_ERR 	;  of argv[]...	
 12825 0000101D 89D3                    	mov	bx,dx
 12826                                  	;mov	ax,ARG_ARGV
 12827                                  	;mov	ax,ARG+ARG_UNIT.argv
 12828 0000101F B8[6F8E]                	mov	ax,ARG
 12829 00001022 E87321                  	call	argv_calc		; convert array index to pointer
 12830 00001025 8B37                    	mov	si,[bx]			; load pointer to argstring
 12831                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12832 00001027 AD                      	lodsw				; and load first two chars
 12833 00001028 F8                      	clc
 12834 00001029 C3                      	retn
 12835                                  NEXTARG_ERR:
 12836 0000102A F9                      	stc
 12837 0000102B C3                      	retn
 12838                                  
 12839                                  ; ---------------------------------------------------------------------------
 12840                                  
 12841                                  FORNESTERR:
 12842 0000102C 1E                      	push	ds
 12843 0000102D 8E1E[E08A]              	mov	ds,[RESSEG]
 12844                                  	;ASSUME DS:RESGROUP
 12845 00001031 BA[D380]                	mov	dx,FORNESTMES_PTR
 12846 00001034 813E[A601]00FF          	cmp	word [SingleCom],0FF00h
 12847 0000103A 7506                    	jne	short NOFORP3
 12848 0000103C C706[A601]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
 12849                                  NOFORP3:
 12850 00001042 1F                      	pop	ds
 12851 00001043 E93419                  	jmp	cerror
 12852                                  
 12853                                  ; =============== S U B	R O U T	I N E =======================================
 12854                                  
 12855                                  ; General routine called to free the for segment. We also clear the forflag
 12856                                  ; too. Change no registers.
 12857                                  
 12858                                  FOROFF:
 12859 00001046 50                      	push	ax
 12860 00001047 06                      	push	es
 12861 00001048 2E8E06[E08A]            	mov	es,[cs:RESSEG]
 12862 0000104D 26A1[AD01]              	mov	ax,[es:ForPtr]
 12863 00001051 09C0                    	or	ax,ax
 12864 00001053 7408                    	jz	short FREEDONE
 12865 00001055 06                      	push	es
 12866 00001056 8EC0                    	mov	es,ax
 12867                                  	; 15/02/2023
 12868 00001058 B449                    	mov	ah,49h
 12869                                  	;mov	ah,DEALLOC ; 49h
 12870 0000105A CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 12871                                  			; ES = segment address of area to be freed
 12872 0000105C 07                      	pop	es
 12873                                  FREEDONE:
 12874 0000105D 26C706[AD01]0000        	mov	word [es:ForPtr],0
 12875 00001064 26C606[AC01]00          	mov	byte [es:ForFlag],0
 12876 0000106A 07                      	pop	es
 12877 0000106B 58                      	pop	ax
 12878 0000106C C3                      	retn
 12879                                  
 12880                                  ;============================================================================
 12881                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
 12882                                  ;============================================================================
 12883                                  ; 09/10/2018 - Retro DOS v3.0
 12884                                  
 12885                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
 12886                                  
 12887                                  ; ---------------------------------------------------------------------------
 12888                                  
 12889                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12890                                  
 12891                                  %if 0
 12892                                  
 12893                                  ; The DIR command displays the contents of a directory.
 12894                                  ;
 12895                                  ; ****************************************************************
 12896                                  ; *
 12897                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
 12898                                  ; *
 12899                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
 12900                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
 12901                                  ; *		 If an error occurs issue and error message and
 12902                                  ; *		 transfer control to CERROR.
 12903                                  ; *
 12904                                  ; * INPUT:	 command line at offset 81H
 12905                                  ; *
 12906                                  ; * OUTPUT:	 none
 12907                                  ; *
 12908                                  ; ****************************************************************
 12909                                  
 12910                                  CATALOG:
 12911                                  	; MSDOS 3.3
 12912                                  
 12913                                  	;mov	ax,ARG_ARGV
 12914                                  	;mov	ax,ARG+ARG_UNIT.argv
 12915                                  	mov	ax,ARG
 12916                                  	mov	dx,0FFFFh
 12917                                  	xor	cx,cx
 12918                                  	xor	si,si
 12919                                  DIR1:
 12920                                  	;cmp	cx,[ARG_ARGVCNT]
 12921                                  	cmp	cx,[ARG+ARG_UNIT.argvcnt]
 12922                                  	jnb	short DIR6 ; No more arguments
 12923                                  	mov	bx,cx
 12924                                  	call	ARGV_CALC
 12925                                  	;or	si,[bx+7]
 12926                                  	or	si,[bx+ARGV_ELE.argsw_word]
 12927                                  	test	si,7FFCh  ; test si,~8003
 12928                                  	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
 12929                                  	;test	byte [bx+2],1
 12930                                  	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
 12931                                  	jz	short DIR3
 12932                                  	jmp	short DIR5
 12933                                  DIR2:
 12934                                  	mov	dx,BADPARMPTR
 12935                                  	jmp	CERROR
 12936                                  DIR3:
 12937                                  	or	cx,cx
 12938                                  	jnz	short DIR4	
 12939                                  	;cmp	word [bx+5],3
 12940                                  	cmp	word [bx+ARGV_ELE.arglen],3
 12941                                  	jz	short DIR5
 12942                                  	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
 12943                                  	add	word [bx],3
 12944                                  	;add	word [bx+9],3
 12945                                  	add	word [bx+ARGV_ELE.arg_ocomptr],3
 12946                                  	;add	word [bx+3],3
 12947                                  	add	word [bx+ARGV_ELE.argstartel],3
 12948                                  	;sub	word [bx+5],3
 12949                                  	sub	word [bx+ARGV_ELE.arglen],3
 12950                                  DIR4:
 12951                                  	cmp	dx,0FFFFh
 12952                                  	jnz	short DIR2
 12953                                  	mov	dx,bx
 12954                                  DIR5:
 12955                                  	inc	cx
 12956                                  	jmp	short DIR1
 12957                                  DIR6:
 12958                                  	mov	[COMSW],si
 12959                                  	push	dx
 12960                                  	xor	al,al
 12961                                  	cmp	dx,0FFFFh
 12962                                  	jz	short DIR7
 12963                                  	mov	bx,dx
 12964                                  	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
 12965                                  	mov	di,[bx]
 12966                                  	cmp	byte [di+1],':'
 12967                                  	jnz	short DIR7
 12968                                  	mov	al,[di]
 12969                                  	or	al,20h		; Lowercase drive name	
 12970                                  	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
 12971                                  DIR7:
 12972                                  	;mov	[5CH],al
 12973                                  	mov	[FCB],al
 12974                                  	call	OKVOLARG
 12975                                  	mov	al,'?'		; *.* is default file spec.
 12976                                  	;mov	di,5Dh
 12977                                  	mov	di,FCB+1
 12978                                  	mov	cx,11
 12979                                  	rep stosb
 12980                                  
 12981                                  ; Begin by processing any switches that may have been specified.
 12982                                  ; BITS will contain any information about switches that was
 12983                                  ; found when the command line was parsed.
 12984                                  
 12985                                  	mov	ax,[COMSW]	; Get switches from command
 12986                                  	mov	[_BITS],ax	; initialize switches
 12987                                  	mov	word [COMSW],0	; initialize flags
 12988                                  	mov	byte [LINPERPAG],23 ; Set default for lines per page
 12989                                  	;test	al,1
 12990                                  	test	al,SWITCHW	; /W ?
 12991                                  	;mov	al,1
 12992                                  	mov	al,NORMPERLIN
 12993                                  	jz	short DIR8
 12994                                  	;mov	al,5
 12995                                  	mov	al,WIDEPERLIN
 12996                                  DIR8:
 12997                                  	mov	[LINLEN],al	; Set number of entries per line
 12998                                  	mov	[LINCNT],al
 12999                                  	mov	word [FILECNT],0 ; Keep track of how many files found
 13000                                  	mov	dx,DIRBUF
 13001                                  	mov	ah,Set_DMA ; 1Ah
 13002                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13003                                  			; DS:DX	-> disk	transfer buffer
 13004                                  	;mov	dl,[5Ch]
 13005                                  	mov	dl,[FCB]
 13006                                  	call	SAVUDIR
 13007                                  	pop	bx
 13008                                  	cmp	bx,0FFFFh
 13009                                  	jz	short DIR9
 13010                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 13011                                  	mov	dx,[bx]
 13012                                  
 13013                                  ; The user may have specified a device. Search for the path and see if the
 13014                                  ; attributes indicate a device.
 13015                                  
 13016                                  	mov	ah,Find_First ; 4Eh
 13017                                  	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 13018                                  			; CX = search attributes
 13019                                  			; DS:DX	-> ASCIZ filespec
 13020                                  			; (drive,path, and wildcards allowed)
 13021                                  	jc	short DIR10
 13022                                  			; Check device atrribute..
 13023                                  	;test	byte [DIRBUF_ATTRIB2],40h
 13024                                  	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
 13025                                  	; 14/10/2018
 13026                                  	;test	byte [DIRBUF+21],40h
 13027                                  	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 13028                                  	jz	short DIR10	; no, go do normal operation
 13029                                  	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
 13030                                  DIR9:
 13031                                  	jmp	short DOHEADER
 13032                                  DIR10:
 13033                                  	;mov	dx,[bx+ARGV_ELE.argpointer]
 13034                                  	mov	dx,[bx]
 13035                                  	mov	ah,CHDir ; 3Bh
 13036                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13037                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13038                                  	jnc	short DOHEADER
 13039                                  	;mov	si,[bx+3]
 13040                                  	mov	si,[bx+ARGV_ELE.argstartel]
 13041                                  	cmp	dx,si
 13042                                  	jz	short DIR_NO_DRIVE
 13043                                  	xor	cl,cl
 13044                                  	xchg	cl,[si]
 13045                                  	mov	ah,CHDir ; 3Bh
 13046                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13047                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13048                                  	xchg	cl,[si]
 13049                                  	jnc	short DIR_NO_DRIVE
 13050                                  	mov	al,[si-1]
 13051                                  	call	PATHCHRCMP
 13052                                  	jnz	short DIR11
 13053                                  	mov	al,[si-2]
 13054                                  	call	PATHCHRCMP
 13055                                  	jz	short DIR12
 13056                                  	xchg	cl,[si-1]
 13057                                  	mov	ah,CHDir ; 3Bh
 13058                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13059                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13060                                  	xchg	cl,[si-1]
 13061                                  	jnc	short DIR_NO_DRIVE
 13062                                  DIR11:
 13063                                  	mov	ch,':'
 13064                                  	cmp	ch,[si-1]
 13065                                  	jnz	short DIR12
 13066                                  	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
 13067                                  	mov	cx,[bx]
 13068                                  	xchg	cx,si
 13069                                  	sub	cx,si
 13070                                  	cmp	cx,2
 13071                                  	jz	short DIR_NO_DRIVE
 13072                                  DIR12:
 13073                                  	mov	dx,BADCDPTR
 13074                                  	;test	byte [bx+2],4
 13075                                  	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 13076                                  	jnz	short DIRERROR
 13077                                  DIRNF:
 13078                                  	mov	dx,FNOTFOUNDPTR
 13079                                  DIRERROR:
 13080                                  	jmp	CERROR
 13081                                  DIR_NO_DRIVE:
 13082                                  	cmp	word [si],'..'
 13083                                  	jnz	short DOREALPARSE
 13084                                  	cmp	byte [si+2],0
 13085                                  	jnz	short DOREALPARSE
 13086                                  	inc	word [COMSW]
 13087                                  	jmp	short DOHEADER
 13088                                  DOREALPARSE:
 13089                                  	mov	di,FCB ; 5Ch	
 13090                                  	;mov	ax,290Eh
 13091                                  	mov	ax,(Parse_File_Descriptor<<8)|0Eh
 13092                                  	int	21h	; DOS -	PARSE FILENAME
 13093                                  			; DS:SI	-> string to parse
 13094                                  			; ES:DI	-> buffer to fill with unopened	FCB
 13095                                  			; AL = bit mask	to control parsing
 13096                                  	cmp	byte [si],0
 13097                                  	jz	short DOHEADER
 13098                                  	dec	word [COMSW]
 13099                                  DOHEADER:
 13100                                  		
 13101                                  ; Display the header
 13102                                  
 13103                                  	push	bx
 13104                                  	call	BUILD_DIR_STRING
 13105                                  	mov	dx,DIRBUF
 13106                                  	mov	[VOL_DIR],dx
 13107                                  	mov	dx,DIRHEADPTR
 13108                                  	call	PRINTF_CRLF
 13109                                  	pop	bx
 13110                                  	cmp	bx,0FFFFh
 13111                                  	jz	short DOSEARCH
 13112                                  
 13113                                  ; If there were chars left after parse or device, then invalid file name
 13114                                  
 13115                                  	cmp	word [COMSW],0
 13116                                  	jz	short DOSEARCH	; nothing left; good parse
 13117                                  	jl	short DIRNFFIX	; not .. => error file not found
 13118                                  	call	RESTUDIR
 13119                                  	mov	dx,BADCDPTR
 13120                                  	jmp	CERROR		; was .. => error directory not found
 13121                                  DIRNFFIX:
 13122                                  	call	RESTUDIR
 13123                                  	jmp	short DIRNF
 13124                                  
 13125                                  ; We are assured that everything is correct. Let's go and search. Use
 13126                                  ; attributes that will include finding directories. Perform the first search
 13127                                  ; and reset our directory afterward.
 13128                                  
 13129                                  DOSEARCH:
 13130                                  	;mov	byte [55h],0FFh
 13131                                  	mov	byte [FCB-7],0FFh
 13132                                  	;mov	byte [5Bh],10h
 13133                                  	mov	byte [FCB-1],10h
 13134                                  
 13135                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
 13136                                  ; the directory information as an extended FCB. We must bias all fetches into
 13137                                  ; DIRBUF by 8 (Extended FCB part + drive)
 13138                                  
 13139                                  	mov	ah,Dir_Search_First ; 11h
 13140                                  	mov	dx,FCB-7 ; 55h
 13141                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 13142                                  			; DS:DX	-> FCB
 13143                                  
 13144                                  ; Restore the user's directory. We preserve, though, the return from the
 13145                                  ; previous system call for later checking.
 13146                                  
 13147                                  FOUND_FIRST_FILE:
 13148                                  	push	ax		; save return state
 13149                                  	call	RESTUDIR	; restore user's dir	
 13150                                  	pop	ax		; get return state back
 13151                                  
 13152                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
 13153                                  ; no more.
 13154                                  
 13155                                  DIRSTART:
 13156                                  	inc	al		; 0FFh = file not found
 13157                                  	jnz	short DISPLAY	; Either an error or we are finished
 13158                                  	jmp	CHKCNT
 13159                                  DISPLAY:
 13160                                  	inc	word [FILECNT]	; Keep track of how many we find
 13161                                  	mov	si,DIRBUF+8	; SI -> information returned by sys call
 13162                                  	;call	SHONAME
 13163                                  	call	DISPLAYNAME
 13164                                  	;test	byte [_BITS],1
 13165                                  	test	byte [_BITS],SWITCHW ; W switch set?
 13166                                  	jz	short DIRTEST	; If so, no size, date, or time
 13167                                  	jmp	NEXENT
 13168                                  DIRTEST:
 13169                                  	;test	byte [DIRBUF_ATTRIB1],10h
 13170                                  	; 14/10/2018
 13171                                  	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
 13172                                  	;test	byte [DIRBUF+19],10h
 13173                                  	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
 13174                                  	jz	short FILEENT
 13175                                  	mov	dx,DMESPTR
 13176                                  	call	STD_PRINTF
 13177                                  	jmp	short NOFSIZ
 13178                                  FILEENT:
 13179                                  	;mov	dx,[DIRBUF_FSIZ_L]
 13180                                  	;mov	dx,[DIRBUF+36]
 13181                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
 13182                                  	mov	[FILESIZE_L],dx
 13183                                  	;mov	dx,[DIRBUF_FSIZ_H]
 13184                                  	;mov	dx,[DIRBUF+38]
 13185                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
 13186                                  	mov	[FILESIZE_H],dx
 13187                                  	mov	dx,FSIZEMESPTR
 13188                                  	call	STD_PRINTF	; Print size of file
 13189                                  NOFSIZ:
 13190                                  	;mov	ax,[DIRBUF_FDATE]  ; Get date
 13191                                  	;mov	ax,[DIRBUF+32]
 13192                                  	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
 13193                                  	or	ax,ax
 13194                                  	jz	short NEXENT	; Skip if no date
 13195                                  	mov	di,CHARBUF
 13196                                  	push	ax
 13197                                  	mov	ax,'  '
 13198                                  	stosw
 13199                                  	pop	ax
 13200                                  	mov	bx,ax
 13201                                  	and	ax,1Fh		; Get day
 13202                                  	mov	dl,al
 13203                                  	mov	ax,bx
 13204                                  	mov	cl,5
 13205                                  	shr	ax,cl		; Align month
 13206                                  	and	al,0Fh		; Get month
 13207                                  	mov	dh,al
 13208                                  	mov	cl,bh
 13209                                  	shr	cl,1		; Align year
 13210                                  	xor	ch,ch
 13211                                  	add	cx,80		; Relative 1980
 13212                                  	cmp	cl,100
 13213                                  	jb	short MILLENIUM
 13214                                  	sub	cl,100
 13215                                  MILLENIUM:
 13216                                  	call	DATE_CXDX
 13217                                  	;mov	cx,[DIRBUF_FTIME]
 13218                                  	;mov	cx,[DIRBUF+30]
 13219                                  	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
 13220                                  	jcxz	PRBUF		; Time field present?
 13221                                  	mov	ax,2020h
 13222                                  	stosw
 13223                                  	shr	cx,1
 13224                                  	shr	cx,1
 13225                                  	shr	cx,1
 13226                                  	shr	cl,1
 13227                                  	shr	cl,1		; Hours in CH, minutes in CL
 13228                                  	mov	bl,[TIME_24]
 13229                                  	or	bl,80h		; Tell P_TIME called from DIR
 13230                                  	call	P_TIME		; Don't care about DX, never used with DIR
 13231                                  PRBUF:
 13232                                  	xor	ax,ax
 13233                                  	stosb
 13234                                  	mov	dx,CHARBUF
 13235                                  	mov	[STRING_PTR_2],dx
 13236                                  	mov	dx,STRINGBUF2PTR
 13237                                  	call	STD_PRINTF
 13238                                  NEXENT:
 13239                                  	dec	byte [LINCNT]
 13240                                  	jnz	short SAMLIN
 13241                                  NEXLIN:
 13242                                  	mov	al,[LINLEN]
 13243                                  	mov	[LINCNT],al
 13244                                  	call	CRLF2
 13245                                  	dec	byte [LINPERPAG]
 13246                                  	jnz	short SCROLL
 13247                                  	;test	byte [_BITS],2
 13248                                  	test	byte [_BITS],SWITCHP ; P switch present?
 13249                                  	jz	short SCROLL	; If not, just continue
 13250                                  	mov	byte [LINPERPAG],23
 13251                                  	call	PAUSE
 13252                                  	jmp	short SCROLL
 13253                                  SAMLIN:
 13254                                  	mov	dx,TABPTR	; Output a tab
 13255                                  	call	STD_PRINTF
 13256                                  SCROLL:
 13257                                  	mov	ah,Dir_Search_Next ; 12h
 13258                                  	;mov	dx,55h
 13259                                  	mov	dx,FCB-7	; DX -> Unopened FCB
 13260                                  	int	21h	; DOS -	SEARCH NEXT USING FCB
 13261                                  			; DS:DX	-> FCB
 13262                                  			; Return: AL = status
 13263                                  	jmp	DIRSTART
 13264                                  CHKCNT:
 13265                                  	test	word [FILECNT],0FFFFh ; -1
 13266                                  	jnz	short TRAILER
 13267                                  	jmp	DIRNF
 13268                                  TRAILER:
 13269                                  	mov	al,[LINLEN]
 13270                                  	cmp	al,[LINCNT]
 13271                                  	jz	short MMESSAGE
 13272                                  	call	CRLF2
 13273                                  MMESSAGE:
 13274                                  	mov	dx,DIRMESPTR
 13275                                  	mov	si,[FILECNT]
 13276                                  	mov	[DIR_NUM],si
 13277                                  	call	STD_PRINTF
 13278                                  DTFREE:
 13279                                  	mov	ah,GET_DRIVE_FREESPACE ; 36h
 13280                                  	;mov	dl,[5Ch]
 13281                                  	mov	dl,[FCB]
 13282                                  	int	21h	; DOS -	2+ - GET DISK SPACE
 13283                                  			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
 13284                                  	cmp	ax,-1
 13285                                  	jnz	short DTFREE1
 13286                                  DTRET:
 13287                                  	retn
 13288                                  DTFREE1:
 13289                                  	mul	cx
 13290                                  	mul	bx
 13291                                  	mov	[BYTES_FREE],ax
 13292                                  	mov	[BYTES_FREE+2],dx
 13293                                  	mov	dx,BYTEMESPTR
 13294                                  	jmp	STD_PRINTF
 13295                                  
 13296                                  ; =============== S U B	R O U T	I N E =======================================
 13297                                  
 13298                                  SHONAME:
 13299                                  DISPLAYNAME:
 13300                                  	; MSDOS 3.3
 13301                                  	mov	di,CHARBUF
 13302                                  	mov	cx,8
 13303                                  	rep	movsb
 13304                                  	mov	al,' '
 13305                                  	stosb
 13306                                  	mov	cx,3
 13307                                  	rep	movsb
 13308                                  	xor	ax,ax
 13309                                  	stosb
 13310                                  	push	dx
 13311                                  	mov	dx,CHARBUF
 13312                                  	mov	[STRING_PTR_2],dx
 13313                                  	mov	dx,STRINGBUF2PTR
 13314                                  	call	STD_PRINTF
 13315                                  	pop	dx
 13316                                  	retn
 13317                                  
 13318                                  %endif
 13319                                  
 13320                                  ;============================================================================
 13321                                  ; DIR.ASM, MSDOS 6.0, 1991
 13322                                  ;============================================================================
 13323                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13324                                  
 13325                                  	; MSDOS 6.0
 13326                                  %if 0
 13327                                  
 13328                                  ;***	DIR.ASM - DIR internal command
 13329                                  
 13330                                  comment	% =================================================================
 13331                                  
 13332                                  This module replaces TCMD1A.ASM.  The old module was titled 
 13333                                  "PART4 COMMAND Transient routines".
 13334                                  
 13335                                  From residual documentation, I surmise that TCMD.ASM originally
 13336                                  contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
 13337                                  VER.  The file seems to have been successively split:
 13338                                  
 13339                                    TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B
 13340                                  
 13341                                  TCMD1A.ASM contained only the DIR command.
 13342                                  
 13343                                  Usage:
 13344                                  ------
 13345                                  
 13346                                  DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>
 13347                                  
 13348                                  DIR /?
 13349                                  
 13350                                  
 13351                                  <filespec> may include any or none of:  drive; directory path;
 13352                                             wildcarded filename.  If drive or directory path are
 13353                                  	   omitted, the current defaults are used.  If the
 13354                                  	   file name or extension is omitted, wildcards are
 13355                                  	   assumed.
 13356                                  
 13357                                  /w	Wide listing format.  Files are displayed in compressed
 13358                                  	'name.ext' format.  Subdirectory files are enclosed in
 13359                                  	brackets, '[dirname]'.
 13360                                  
 13361                                  /p	Paged, or prompted listing.  A screenful is displayed
 13362                                  	at a time.  The name of the directory being listed appears
 13363                                  	at the top of each page.
 13364                                  
 13365                                  	Bugbug:  pages nead to be uniform length..?
 13366                                  
 13367                                  /b	Bare listing format.  Turns off /w or /p.  Files are 
 13368                                  	listed in compressed 'name.ext' format, one per line,
 13369                                  	without additional information.  Good for making batch
 13370                                  	files or for piping.  When used with /s, complete
 13371                                  	pathnames are listed.
 13372                                  
 13373                                  /s	Descend subdirectory tree.  Performs command on current
 13374                                  	or specified directory, then for each subdirectory below
 13375                                  	that directory.  Directory header and footer is displayed
 13376                                  	for each directory where matching files are found, unless
 13377                                  	used with /b.  /b suppresses headers and footers.
 13378                                  
 13379                                  	Tree is explored depth first, alphabetically within the
 13380                                  	same level.
 13381                                  
 13382                                  	Bugbug:  hidden directories aren't searched.
 13383                                  
 13384                                  /l	Display file names, extensions and paths in lowercase.	;M010
 13385                                  
 13386                                  /c	Display file compression ratio, if the file is on a MagicDrv
 13387                                  	compressed volume.
 13388                                  
 13389                                  /o	Sort order.  /o alone sorts by default order (dirs-first, name,
 13390                                  	extension).  A sort order may be specified after /o.  Any of
 13391                                  	the following characters may be used: nedsgc (name, extension,
 13392                                  	date/time, size, group-dirs-first, compression ratio).	Placing
 13393                                  	a '-' before any letter causes a downward sort on that field.
 13394                                  	E.g., /oe-d means sort first by extension in alphabetical order,
 13395                                  	then within each extension sort by date and time in reverse
 13396                                  	chronological order.
 13397                                  
 13398                                  /a	Attribute selection.  Without /a, hidden and system files
 13399                                  	are suppressed from the listing.  With /a alone, all files
 13400                                  	are listed.  An attribute list may follow /a, consisting of
 13401                                  	any of the following characters:  hsdar (hidden, system,
 13402                                  	directory, archive, read-only).  A '-' before any letter
 13403                                  	means 'not' that attribute.  E.g., /ar-d means files that
 13404                                  	are marked read-only and are not directory files.  Note
 13405                                  	that hidden or system files may be included in the listing.
 13406                                  	They are suppressed without /a but are treated like any other
 13407                                  	attribute with /a.
 13408                                  
 13409                                  /?	Help listing.  Display DIR useage information.	;M008;Handled externally
 13410                                  
 13411                                  /h has been removed.					;M008
 13412                                  
 13413                                  DIRCMD	An environment variable named DIRCMD is parsed before the
 13414                                  	DIR command line.  Any command line options may be specified
 13415                                  	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
 13416                                  	A filespec may be specified in DIRCMD and will be used unless
 13417                                  	a filespec is specified on the command line.  Any switch
 13418                                  	specified in DIRCMD may be overridden on the command line.
 13419                                  	If the original DIR default action is desired for a particular
 13420                                  	switch, the switch letter may be preceded by a '-' on the
 13421                                  	command line.  E.g.,
 13422                                  
 13423                                  	  /-w	use long listing format
 13424                                  	  /-p	don't page the listing
 13425                                  	  /-b	don't use bare format
 13426                                  	  /-s	don't descend subdirectory tree
 13427                                  	  /-o	display files in disk order
 13428                                  	  /-a	suppress hidden and system files
 13429                                  
 13430                                  Notes:
 13431                                  ------
 13432                                  
 13433                                  For sorted listings, file entries are loaded into the TPA buffer, which
 13434                                  is usually about 64K in size.  This allows sorts of up to 3000 files at
 13435                                  a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
 13436                                  The byte after the last entry is 0FFh.  The first byte of each entry is
 13437                                  a flag byte which is made zero when the entry is loaded, and made one
 13438                                  when the entry is used.
 13439                                  
 13440                                  Revision History
 13441                                  ================
 13442                                  M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
 13443                                  				in the absence of ANSI.SYS
 13444                                  
 13445                                  M007	sa	8/1/90		Allow /p/b combination
 13446                                  
 13447                                  M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
 13448                                  				to internally handle /? message.
 13449                                  
 13450                                  M010	sa	8/5/90		Add support for /l (lowercase) option.
 13451                                  
 13452                                  M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
 13453                                  				first FCB with the drive number when the drive
 13454                                  				letter in the command line is preceded by a
 13455                                  				switch.  Now dir manually loads the drive
 13456                                  				number after parsing.
 13457                                  
 13458                                  M018	md	8/12/90 	Increment the screen height by 1 when obtained
 13459                                  				from the ROM BIOS.
 13460                                  
 13461                                  M023	sa	8/31/90		Prevent DIR from failing if it encounters
 13462                                  				a subdirectory having len(pathname)>MAXPATH.
 13463                                  				Just skip over that subdirectory.
 13464                                  
 13465                                  M028	dbo	9/24/90		When country=US, sort by strict character
 13466                                  				byte value, rather than collating table.
 13467                                  				This to match MS-DOS Shell's sort order.
 13468                                  
 13469                                  ========================================================================= %
 13470                                  
 13471                                  %endif
 13472                                  
 13473                                  ; 16/02/2023
 13474                                  
 13475                                  NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13476                                  
 13477                                  ;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13478                                  ;
 13479                                  ;		on/off bit record for /l, /b, /s, /p, /w, /c options
 13480                                  ;		(order is hard-coded; see OnOffSw)
 13481                                  ;		Inmem is set when entries are loaded in memory.
 13482                                  
 13483                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13484                                  mask.wide  equ 1
 13485                                  mask.pagd  equ 2
 13486                                  mask.subd  equ 4
 13487                                  mask.bare  equ 8
 13488                                  mask.lcase equ 16
 13489                                  mask.inmem equ 32
 13490                                  ;
 13491                                  mask.dev    equ 1
 13492                                  mask.baddir equ 2	
 13493                                  
 13494                                  NUM_ATTR_LTRS	equ	6	; length of attribute letter list
 13495                                  
 13496                                  NUM_ORDER_LTRS	equ	5	; length of sort order letter list
 13497                                  
 13498                                  ;ResultBuffer	struc		; structure of parse result buffer
 13499                                  ;ValueType	db	?
 13500                                  ;ValueTag	db	?
 13501                                  ;SynPtr		dw	?
 13502                                  ;ValuePtr	dd	?
 13503                                  ;ResultBuffer	ends
 13504                                  
 13505                                  ;ErrorRec	record	baddir:1,dev:1
 13506                                  ;
 13507                                  ;		Error bits are:
 13508                                  ;		  Invalid directory format
 13509                                  ;		  File is device
 13510                                  
 13511                                  ;EntryStruc	struc			; our private directory entry structure
 13512                                  ;used		db	?		; =0 until entry used, then =1
 13513                                  ;filename	db	8 dup (?)	; filename
 13514                                  ;fileext	db	3 dup (?)	; extension
 13515                                  ;fileattr	db	?		; file attributes
 13516                                  ;filetime	dw	?		; file time
 13517                                  ;filedate	dw	?		; file date
 13518                                  ;filesize	dd	?		; file size
 13519                                  ;EntryStruc	ends
 13520                                  
 13521                                  ;shove	macro	val		; hose-bag 8086 doesn't push immediate
 13522                                  ;	mov	ax,val		; invisible, dangerous use of AX!
 13523                                  ;	push	ax
 13524                                  ;	endm
 13525                                  
 13526                                  ;	public	Catalog		; our entry point
 13527                                  ;
 13528                                  ;	break	<DIR (Catalog) principal routines>
 13529                                  ;
 13530                                  ;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
 13531                                  ; ---------------------------------------------------------------------------
 13532                                  ;	Bugbug:	Each routine should start with it's own ASSUME.
 13533                                  
 13534                                  ; ---------------------------------------------------------------------------
 13535                                  ;----------------------------------------------------------------------------
 13536                                  
 13537                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13538                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh
 13539                                  
 13540                                  ;***	Catalog - DIR command main routine
 13541                                  ;
 13542                                  ;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
 13543                                  ;		Cmd-line tail text is at 81h, terminated by 0Dh
 13544                                  ;		CS, DS, ES, SS = TRANGROUP seg addr
 13545                                  ;		Tpa = TPA buffer seg addr
 13546                                  ;		BytCnt = # bytes in TPA buffer
 13547                                  ;
 13548                                  ;	EXIT	nothing
 13549                                  ;
 13550                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 13551                                  ;
 13552                                  ;	ERROR EXITS
 13553                                  ;
 13554                                  ;	  Errors are handled by setting up error message pointers
 13555                                  ;	   for Std_EPrintf and jumping to CError. Syntax errors in
 13556                                  ;	   the environment variable, however, are handled by printing
 13557                                  ;	   an error message and continuing.
 13558                                  ;
 13559                                  ;	EFFECTS
 13560                                  ;
 13561                                  ;	  Directory listing is displayed (on standard output).
 13562                                  ;	  APPEND is disabled. HeadFix routine is expected to
 13563                                  ;	   restore APPEND state.
 13564                                  ;	  Working directory may be changed. The user's default
 13565                                  ;	   directory is saved and flagged for restoration by RestUDir
 13566                                  ;	   during COMMAND cycle.
 13567                                  ;	  Lots of variables may be changed in TRANSPACE segment.
 13568                                  ;
 13569                                  ;	NOTES
 13570                                  ;
 13571                                  ;	  ES = TRANGROUP seg addr except when used to address the
 13572                                  ;	   the TPA buffer, where directory entries are loaded from disk.
 13573                                  
 13574                                  	; 16/02/2023
 13575                                  CATALOG:
 13576 0000106D E8A500                  	call	SetDefaults
 13577 00001070 E8C900                  	call	ParseEnvironment
 13578 00001073 E8E100                  	call	ParseCmdLine
 13579 00001076 7303                    	jnc	short catalog1	; no parse error
 13580 00001078 E99700                  	jmp	catErr		; error msg is set up
 13581                                  catalog1:
 13582 0000107B E80A01                  	call	SetOptions
 13583 0000107E E8E000                  	call	SetCollatingTable
 13584                                  
 13585                                  ;	Drive # to operate on has already been placed in FCB by
 13586                                  ;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.
 13587                                  
 13588                                  	;;;test	Bits,mask bare
 13589                                  	;;test 	word [_Bits],8
 13590                                  	;test	byte [_Bits],8
 13591 00001081 F606[3B8C]08            	test	byte [_Bits],mask.bare
 13592 00001086 750A                    	jnz	short catalog2	; don't display volume info for /b
 13593                                  	;invoke	OkVolArg	; find & display volume info
 13594 00001088 E8040C                  	call	OkVolArg
 13595                                  	;sub	byte [LeftOnpage],2
 13596 0000108B 832E[0A8B]02            	sub	word [LeftOnPage],2
 13597                                  				; record display lines used by volume info
 13598 00001090 EB15                    	jmp	short catCrunch
 13599                                  
 13600                                  ;	OkVolArg side effects:
 13601                                  ;	APPEND is disabled;
 13602                                  ;	DTA established at DirBuf;
 13603                                  ;	Filename fields in FCB are wildcarded.
 13604                                  
 13605                                  catalog2:
 13606                                  ;	OkVolArg wasn't executed, so we have to do these ourselves.
 13607                                  
 13608                                  	;invoke	DisAppend	; disable APPEND
 13609 00001092 E8C70B                  	call	DisAppend
 13610                                  
 13611                                  	;mov	dx,offset TRANGROUP:DirBuf
 13612 00001095 BA[E98B]                	mov	dx,DIRBUF
 13613 00001098 B41A                    	mov	ah,1Ah
 13614                                  	;mov	ah,Set_DMA
 13615 0000109A CD21                    	int	21h		; set DTA
 13616                                  
 13617 0000109C BF5C00                  	mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
 13618 0000109F 47                      	inc	di		; ES:DI = ptr to filename field of FCB
 13619 000010A0 B03F                    	mov	al,'?'		; AL = wildcard character
 13620 000010A2 B90B00                  	mov	cx,11
 13621 000010A5 F3AA                    	rep	stosb		; wildcard filename field
 13622                                  
 13623                                  catCrunch:
 13624 000010A7 E83901                  	call	CrunchPath	; crunch pathname to get directory and filename
 13625 000010AA 7230                    	jc	short catRecErr	; handle recorded or extended error
 13626                                  
 13627                                  ;	User's directory has been saved, we've changed to specified directory.
 13628                                  ;	ComSw = error bits for later use
 13629                                  ;	FCB contains parsed filename
 13630                                  
 13631                                  	;cmp	byte [COMSW],0
 13632 000010AC 833E[F78A]00            	cmp	word [COMSW],0
 13633 000010B1 7529                    	jne	short catRecErr	; handle recorded error
 13634                                  
 13635 000010B3 E88701                  	call	InstallCtrlC	; install control-C handler
 13636 000010B6 E8EA08                  	call	ZeroTotals	; zero grand totals
 13637 000010B9 E85804                  	call	ListDir		; list main directory
 13638 000010BC 7244                    	jc	short catExtErr
 13639                                  
 13640                                  	;;;test	Bits,mask subd
 13641                                  	;;test	word [_Bits],4
 13642                                  	;test	byte [_Bits],4
 13643 000010BE F606[3B8C]04            	test	byte [_Bits],mask.subd
 13644 000010C3 7405                    	jz	short catalog3	; subdirectories option not set
 13645 000010C5 E88D01                  	call	ListSubds	; list subdirectories
 13646 000010C8 7238                    	jc	short catExtErr
 13647                                  catalog3:
 13648                                  ;	Check if any files were found.
 13649                                  
 13650                                  	;;;test	Bits,mask bare
 13651                                  	;;test	word [_Bits],8
 13652                                  	;test	byte [_Bits],8
 13653 000010CA F606[3B8C]08            	test	byte [_Bits],mask.bare
 13654 000010CF 750A                    	jnz	short catRet	; don't bother for bare format
 13655                                  
 13656 000010D1 A1[128B]                	mov	ax,[FileCntTotal]
 13657 000010D4 09C0                    	or	ax,ax
 13658 000010D6 7417                    	jz	short catNoFiles ; no files found
 13659                                  
 13660 000010D8 E8B302                  	call	DisplayTotals	; display trailing grand totals
 13661                                  	;jmp	short catRet	; all done
 13662                                  	; 25/04/2023
 13663                                  catRet:
 13664 000010DB C3                      	retn
 13665                                  
 13666                                  catRecErr:
 13667                                  
 13668                                  ;	ComSw may have error bit set. If not, do extended error.
 13669                                  
 13670                                  	;;;test	ComSw,mask dev
 13671                                  	;;test	word [COMSW],1
 13672                                  	;test	byte [COMSW],1
 13673 000010DC F606[F78A]01            	test	byte [COMSW],mask.dev
 13674 000010E1 750C                    	jnz	short catNoFiles 
 13675                                  				; filename is device, respond 'file not found'
 13676                                  	;;test	ComSw,mask baddir
 13677                                  	;;test	word [COMSW],2
 13678                                  	;test	byte [COMSW],2
 13679 000010E3 F606[F78A]02            	test	byte [COMSW],mask.baddir
 13680 000010E8 7418                    	jz	short catExtErr	; no ComSw error bits, must be extended error
 13681                                  	;mov	dx,offset TRANGROUP:BadCd_Ptr
 13682                                  				; invalid directory
 13683 000010EA BA[B080]                	mov	dx,badcd_ptr
 13684 000010ED EB23                    	jmp	short catErr
 13685                                  
 13686                                  catNoFiles:
 13687                                  
 13688                                  ;	Display header and force 'file not found' message.
 13689                                  
 13690 000010EF E82907                  	call	DisplayHeader
 13691 000010F2 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 13692 000010F5 C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 13693 000010FA BA[757F]                	mov	dx,extend_buf_ptr
 13694 000010FD A3[757F]                	mov	[extend_buf_ptr],ax
 13695 00001100 EB10                    	jmp	short catErr
 13696                                  
 13697                                  catExtErr:
 13698                                  
 13699                                  ;	DOS has returned an error status. Get the extended error#, and
 13700                                  ;	set up an error message, changing 'No more files' error 
 13701                                  ;	to 'File not found' error.
 13702                                  
 13703 00001102 E8080C                  	call	Set_Ext_Error_Msg
 13704 00001105 833E[757F]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 13705 0000110A 7506                    	jne	short catalog4  ; catErr
 13706 0000110C C706[757F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 13707                                  catalog4:
 13708                                  
 13709                                  ;	Error exit. Error message information has been set up
 13710                                  ;	for Std_EPrintf.
 13711                                  
 13712                                  catErr:
 13713 00001112 E96518                  	jmp	cerror		; go to COMMAND error recycle point
 13714                                  
 13715                                  	; 25/04/2023
 13716                                  ;catRet:
 13717                                  	;retn
 13718                                  
 13719                                  ; ---------------------------------------------------------------------------
 13720                                  
 13721                                  ;***	SetDefaults - set default pathname, options
 13722                                  ;
 13723                                  ;	ENTRY	DS = TRANGROUP seg addr
 13724                                  ;
 13725                                  ;	EXIT	nothing
 13726                                  ;
 13727                                  ;	USED	AX,DI
 13728                                  ;
 13729                                  ;	EFFECTS
 13730                                  ;	  SrcBuf = '*',EOL - default pathname
 13731                                  ;	  PathPos = ptr to pathname
 13732                                  ;	  PathCnt = length of pathname
 13733                                  
 13734                                  	; 16/02/2023
 13735                                  SetDefaults:
 13736 00001115 BF[4F8D]                	mov	di,SrcBuf		; DI = ptr to pathname buffer
 13737 00001118 893E[3F8C]              	mov	[PathPos],di		; PathPos = ptr to pathname
 13738                                  	;mov	al,STAR
 13739 0000111C B02A                    	mov	al,'*'
 13740 0000111E AA                      	stosb
 13741                                  	;mov	al,END_OF_LINE_IN
 13742 0000111F B00D                    	mov	al,0Dh ; cr
 13743 00001121 AA                      	stosb				; SrcBuf = '*',0Dh
 13744 00001122 C706[3D8C]0100          	mov	word [PathCnt],1	; PathCnt = pathname length
 13745                                  
 13746 00001128 31C0                    	xor	ax,ax			; AX = 0
 13747 0000112A A3[F78A]                	mov	[COMSW],ax		; = no error
 13748 0000112D A3[3B8C]                	mov	[_Bits],ax		; = options off
 13749 00001130 A2[EC8C]                	mov	[DestBuf],al		; = no sort
 13750 00001133 C606[438C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
 13751 00001138 A2[448C]                	mov	[AttrSelect],al		; exclude hidden, system files
 13752                                  peRet:	; 25/04/2023
 13753 0000113B C3                      	retn
 13754                                  
 13755                                  ; ---------------------------------------------------------------------------
 13756                                  
 13757                                  ;***	ParseEnvironment - find and parse our environment variable
 13758                                  ;
 13759                                  ;	Find our environment variable and parse it. If a parse
 13760                                  ;	error occurs, issue an error message. The parse results
 13761                                  ;	up to the error will still have effect. Always leave
 13762                                  ;	the option variables in a useable state.
 13763                                  ;
 13764                                  ;	ENTRY	DS = TRANGROUP seg addr
 13765                                  ;
 13766                                  ;	EXIT	nothing
 13767                                  ;
 13768                                  ;	USED	AX,BX,CX,DX,SI,DI
 13769                                  ;
 13770                                  ;	EFFECTS
 13771                                  ;
 13772                                  ;	  Bits may contain new option settings.
 13773                                  ;	  DestBuf may contain new series of sort codes.
 13774                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 13775                                  ;	  SrcBuf may contain a new default pathname/filespec.
 13776                                  ;	  PathPos, PathCnt updated for new pathname.
 13777                                  ;
 13778                                  ;	  If a parse error occurred, an error message will be issued.
 13779                                  
 13780                                  	; 16/02/2023
 13781                                  ParseEnvironment:
 13782 0000113C E88203                  	call	GetEnvValue		; get environment variable value
 13783 0000113F 72FA                    	jc	short peRet		; name not found in environment
 13784                                  
 13785                                  ;	SI = ptr to value of environment variable, in TRANGROUP seg
 13786                                  
 13787 00001141 E8D004                  	call	Parse_Line		; parse environment value
 13788 00001144 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 13789                                  	;cmp	ax,END_OF_LINE
 13790 00001147 74F2                    	je	short peRet		; successful completion
 13791                                  
 13792                                  ;	Some kind of parse error occurred.
 13793                                  ;	We're set up for a Std_EPrintf call.
 13794                                  
 13795 00001149 E8EF3C                  	call	std_eprintf		; display the parse error
 13796                                  	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
 13797                                  					; restore default msg class
 13798 0000114C C606[737F]FF            	mov	byte [msg_disp_class],0FFh ; -1
 13799                                  	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
 13800 00001151 BA[B481]                	mov	dx,errparsenv_ptr
 13801                                  	;;invoke Printf_Crlf		; "(Error occurred in environment.."
 13802                                  	;call	Printf_Crlf
 13803                                  	; 25/04/2023
 13804                                  	;retn
 13805 00001154 E9DE3C                  	jmp	Printf_Crlf
 13806                                  					;M008;Internal handling of /? removed
 13807                                  ;peOk:	and	Bits,not mask help	; disallow /h in environment variable
 13808                                  	; 25/04/2023
 13809                                  ;peRet:
 13810                                  	;retn
 13811                                  
 13812                                  ; ---------------------------------------------------------------------------
 13813                                  
 13814                                  ;***	ParseCmdLine - parse and record command line parameters
 13815                                  ;
 13816                                  ;	ENTRY	PSP offset 81h is beginning of cmd line buffer
 13817                                  ;		DS, ES, CS = TRANGROUP seg addr
 13818                                  ;
 13819                                  ;	EXIT	CY = set if parse error occurred
 13820                                  ;
 13821                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 13822                                  ;		AX = system parser error code
 13823                                  ;		DX = ptr to message block
 13824                                  ;
 13825                                  ;	USED	AX,BX,CX,DX,SI,DI
 13826                                  ;
 13827                                  ;	EFFECTS
 13828                                  ;
 13829                                  ;	  Bits may contain new option settings.
 13830                                  ;	  DestBuf may contain new series of sort codes.
 13831                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 13832                                  ;	  SrcBuf may contain a new default pathname/filespec.
 13833                                  ;	  PathPos, PathCnt updated for new pathname.
 13834                                  ;
 13835                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 13836                                  ;	  Msg_Disp_Class = parse error class
 13837                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 13838                                  ;	  Message block (see DX) is set up for parse error message
 13839                                  
 13840                                  	; 16/02/2023
 13841                                  ParseCmdLine:
 13842 00001157 BE8100                  	mov	si,81h			; SI = ptr to cmd-line tail text
 13843 0000115A E8B704                  	call	Parse_Line		; parse cmd line tail
 13844 0000115D 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 13845                                  	;;cmp	ax,END_OF_LINE
 13846                                  	; 25/04/2023
 13847                                  	;je	short pcOk		; parse completed successfully
 13848                                  
 13849                                  ;	A parse error occurred. We're all set up for message output.
 13850                                  
 13851                                  	; 25/04/2023
 13852                                  	; cf = 1 (ax < 0FFFFh)
 13853                                  	;stc		   		; return failure
 13854                                  	;jmp	short pcRet
 13855                                  	; 25/04/2023
 13856                                  	;retn
 13857                                  pcOk:
 13858                                  	; 25/04/2023
 13859                                  	;cf = 0 (ax = 0FFFFh)
 13860                                  	;clc				; return success
 13861                                  pcRet:
 13862 00001160 C3                      	retn
 13863                                  
 13864                                  ; ---------------------------------------------------------------------------
 13865                                  
 13866                                  ;***	SetCollatingTable - set up character collating table for sorting
 13867                                  ;
 13868                                  ;	If country is other than USA, try to get a collating table
 13869                                  ;	for character sorting. For USA, use straight byte values.
 13870                                  ;	This is so DIR behaves like the MS-DOS Shell, which sorts
 13871                                  ;	by straight byte values in the USA for better performance.
 13872                                  ;
 13873                                  ;	ENTRY	ES = TRANGROUP seg addr
 13874                                  ;
 13875                                  ;	EXIT	nothing
 13876                                  ;
 13877                                  ;	USED	AX,BX,CX,DX,DI
 13878                                  ;
 13879                                  ;	EFFECTS
 13880                                  ;
 13881                                  ;	  If collating table is set -
 13882                                  ;	    CountryPtrId = 6.
 13883                                  ;	    CountryPtr points to collating table.
 13884                                  ;
 13885                                  ;	  Otherwise -
 13886                                  ;	    CountryPtrId = 0.
 13887                                  
 13888                                  SetCollatingTable:
 13889                                  
 13890                                  ;	Begin modification M028
 13891                                  
 13892                                  	;mov	dx,offset TRANGROUP:InternatVars
 13893                                  	;			; DS:DX = ptr to international info buffer
 13894 00001161 BA[BE95]                	mov	dx,INTERNATVARS
 13895 00001164 B80038                  	mov	ax,3800h
 13896                                  	;mov	ax,INTERNATIONAL << 8
 13897                                  	;;mov	ax,INTERNATIONAL shl 8
 13898                                  				; AX = 'Get current country info'
 13899 00001167 CD21                    	int	21h		; call DOS
 13900 00001169 7217                    	jc	short scNoTable	; error - so don't collate
 13901                                  
 13902                                  ;	BX = country code
 13903                                  
 13904 0000116B 83FB01                  	cmp	bx,1
 13905 0000116E 7412                    	je	short scNoTable	; we're in USA, don't collate
 13906                                  
 13907                                  ;	End modification M028
 13908                                  
 13909                                  ;*	Country code is other than USA. Try to get a collating table.
 13910                                  
 13911 00001170 B80665                  	mov	ax,6506h
 13912                                  	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
 13913                                  	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
 13914                                  				; AH = 'Get Extended Country Info'
 13915                                  				; AL = 'Get Pointer to Collating Table'
 13916 00001173 BBFFFF                  	mov	bx,-1		; BX = code page of interest = CON
 13917 00001176 B90500                  	mov	cx,5		; CX = length of info buffer
 13918 00001179 89DA                    	mov	dx,bx		; DX = country ID = default
 13919                                  	;mov	di,offset TRANGROUP:CountryPtrInfo
 13920 0000117B BF[DE95]                	mov	di,CountryPtrInfo
 13921                                  				; ES:DI = ptr to info buffer
 13922 0000117E CD21                    	int	21h		; call DOS
 13923 00001180 7305                    	jnc	short scRet	; success
 13924                                  
 13925                                  ;*	Set CountryPtrId = 0 to signal no collating table.
 13926                                  
 13927                                  scNoTable:			;M028
 13928 00001182 C606[DE95]00            	mov	byte [CountryPtrId],0
 13929                                  scRet:
 13930 00001187 C3                      	retn
 13931                                  
 13932                                  ; ---------------------------------------------------------------------------
 13933                                  
 13934                                  ;***	SetOptions - check and set options
 13935                                  ;
 13936                                  ;	ENTRY	nothing
 13937                                  ;
 13938                                  ;	EXIT	nothing
 13939                                  ;
 13940                                  ;	USED	AX,BX,CX,DX
 13941                                  ;
 13942                                  ;	EFFECTS
 13943                                  ;
 13944                                  ;	  Bits may contain modified option settings.
 13945                                  ;	  Display_Ioctl table, including LinPerPag variable, is filled in.
 13946                                  ;	  LeftOnPage is initialized to # lines till end of page is handled.
 13947                                  ;	  PerLine is set according to /w presence.
 13948                                  
 13949                                  	; 16/02/2023
 13950                                  SetOptions:
 13951                                  
 13952                                  ;	If bare listing requested, cancel wide listings.
 13953                                  
 13954                                  	;;;test	Bits,mask bare
 13955                                  	;;test	word [_Bits],8
 13956                                  	;test	byte [_Bits],8
 13957 00001188 F606[3B8C]08            	test	byte [_Bits],mask.bare
 13958 0000118D 7405                    	jz	short setopts1
 13959                                  	;;;and	Bits,not mask wide	;M007;Allow /p with /b
 13960                                  	;;and	word [_Bits],0FFFEh
 13961                                  	;;and	byte [_Bits],0FEh
 13962 0000118F 8026[3B8C]FE            	and	byte [_Bits],~mask.wide ; 0FEh
 13963                                  setopts1:
 13964                                  ;	Set # lines per display page.
 13965                                  
 13966                                  ;M01  Obtain screen height from ROM BIOS data area
 13967                                  ;
 13968                                  ;M01	mov	LinPerPag,LINESPERPAGE	; default value
 13969                                  
 13970 00001194 1E                      	push	ds
 13971                                  	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
 13972 00001195 B84000                  	mov	ax,40h
 13973 00001198 8ED8                    	mov	ds,ax			;
 13974                                  	;Assume	DS:ROMBIOS_DATA
 13975                                  
 13976                                  	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
 13977 0000119A A08400                  	mov	al,[84h]
 13978 0000119D 1F                      	pop	ds			;
 13979                                  	;Assume	DS:Trangroup
 13980                                  
 13981 0000119E 08C0                    	or	al,al			; If zero specified
 13982 000011A0 7502                    	jnz	short setopts2		;
 13983                                  
 13984                                  	;mov	al,LINESPERPAGE 	; assume 24 rows
 13985 000011A2 B019                    	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
 13986                                  setopts2:
 13987 000011A4 30E4                    	xor	ah,ah
 13988                                  setopts3:
 13989 000011A6 FEC0                    	inc	al			; height + 1 ;M018
 13990                                  
 13991 000011A8 A3[368E]                	mov	[LinPerPag],ax		; set the rows now
 13992                                  
 13993                                  ; Now the console driver can change the rows if it knows better (M01 end)
 13994                                  
 13995                                  	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE 
 13996                                  					; IOCTL for handles
 13997 000011AB B80C44                  	mov	ax,440Ch
 13998                                  	;mov	bx,STDOUT		; handle #
 13999 000011AE BB0100                  	mov	bx,1
 14000                                  	;mov	ch,IOC_SC		; screen
 14001 000011B1 B503                    	mov	ch,3
 14002                                  	;mov	cl,get_generic		; get display info
 14003 000011B3 B17F                    	mov	cl,7Fh
 14004 000011B5 BA[268E]                	mov	dx,Display_Ioctl	; info block
 14005 000011B8 CD21                    	int	21h			; call DOS
 14006                                  
 14007 000011BA A1[368E]                	mov	ax,[LinPerPag]		; AX = # lines per page
 14008 000011BD A3[0A8B]                	mov	[LeftOnPage],ax		; initialize # lines left on page
 14009                                  
 14010                                  ;	Set # entries per line.
 14011                                  
 14012                                  	;mov	byte [PerLine],NORMPERLIN
 14013                                  					; # entries per line without /w
 14014 000011C0 C606[078B]01            	mov	byte [PerLine],1
 14015                                  	;;;test	Bits,mask wide
 14016                                  	;;test	word [_Bits],1
 14017                                  	;test	byte [_Bits],1
 14018 000011C5 F606[3B8C]01            	test	byte [_Bits],mask.wide
 14019 000011CA 7405                    	jz	short setopts4
 14020                                  	;mov	byte [PerLine],WIDEPERLIN
 14021                                  					; # entries per line with /w
 14022 000011CC C606[078B]05            	mov	byte [PerLine],5
 14023                                  setopts4:
 14024                                  				;M011;start;The following code checks if a drive
 14025                                  				;letter has been parsed into SrcBuf, and if
 14026                                  				;so, the correct drive number is loaded into
 14027                                  				;the first FCB, at offset 5C.
 14028                                  
 14029                                  	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
 14030 000011D1 803E[508D]3A            	cmp	byte [SrcBuf+1],':'
 14031 000011D6 750A                    	jne	short soRet
 14032                                  	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
 14033 000011D8 A0[4F8D]                	mov	al,[SrcBuf]
 14034                                  	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
 14035 000011DB 24DF                    	and	al,0DFh ; ~20h ; not 20h
 14036 000011DD 2C40                    	sub	al,'@'				; convert to 1-based number (1=A)
 14037 000011DF A25C00                  	mov	[FCB],al  ; [5Ch]		; store in first FCB
 14038                                  						;M011;end
 14039                                  soRet:
 14040 000011E2 C3                      	retn
 14041                                  
 14042                                  ; ---------------------------------------------------------------------------
 14043                                  
 14044                                  ;***	CrunchPath - analyze supplied or default pathname
 14045                                  ;
 14046                                  ;	ENTRY	PathPos = ptr to pathname buffer
 14047                                  ;		PathCnt = length of pathname, not incl trailing delimiter
 14048                                  ;		Pathname in buffer must end in delimiter (like CR) and
 14049                                  ;		 must have space for another char after the delimiter.
 14050                                  ;
 14051                                  ;	EXIT	CY = clear if no error
 14052                                  ;		We are changed to directory found in pathname
 14053                                  ;		Previous directory ready to be restored via RestUDir
 14054                                  ;		FCB filename fields contain filename (possibly w/ wildcards)
 14055                                  ;
 14056                                  ;		If error occurred,
 14057                                  ;		CY = set
 14058                                  ;		ComSw = error bits (see ErrorRec)
 14059                                  ;		If ComSw not set,
 14060                                  ;		Ready for DOS Get Extended Error call
 14061                                  
 14062                                  	; 16/02/2023
 14063                                  CrunchPath:
 14064 000011E3 E8ED01                  	call	FileIsDevice
 14065 000011E6 7507                    	jne	short crpath1	; not a device, skip ahead
 14066                                  	;;;or	ComSw,mask dev	; signal file is device
 14067                                  	;;or	word [COMSW],1
 14068                                  	;or	byte [COMSW],1
 14069 000011E8 800E[F78A]01            	or	byte [COMSW],mask.dev
 14070 000011ED EB2F                    	jmp	short cpErr	; return error
 14071                                  crpath1:
 14072 000011EF FF36[3F8C]              	push	word [PathPos]	; save ptr to pathname
 14073 000011F3 C606[478C]FF            	mov	byte [DirFlag],-1
 14074                                  				; tell PathCrunch not to parse file into FCB
 14075 000011F8 E8A714                  	call	PathCrunch	; change to directory in pathname
 14076 000011FB C606[478C]00            	mov	byte [DirFlag],0
 14077                                  				; reset our little flag
 14078 00001200 5E                      	pop	si		; SI = ptr to pathname
 14079 00001201 7208                    	jc	short cpNoDir	; didn't find directory path
 14080 00001203 741A                    	jz	short cpRet	; found directory path w/ no filename
 14081                                  				;  - leave wildcard default in FCB and return
 14082                                  
 14083                                  ;*	We found a directory, and there was a filename attached.
 14084                                  ;	DestTail = ptr to ASCIIZ filename
 14085                                  
 14086 00001205 8B36[E98C]              	mov	si,[DestTail]	; SI = ptr to filename
 14087 00001209 EB28                    	jmp	short cpFile	; go parse the file into FCB
 14088                                  
 14089                                  ;*	PathCrunch failed to find a directory in the pathname.
 14090                                  ;
 14091                                  ;	Msg_Numb = error code
 14092                                  ;	DestIsDir = nonzero if path delimiter char's occur in pathname
 14093                                  ;	SI = ptr to pathname (now an ASCIIZ string)
 14094                                  
 14095                                  cpNoDir:
 14096 0000120B A1[538E]                	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
 14097 0000120E 09C0                    	or	ax,ax
 14098 00001210 750C                    	jnz	short cpErr	  ; error occurred - return it
 14099 00001212 803E[E78C]00            	cmp	byte [DestIsDir],0
 14100 00001217 7407                    	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
 14101                                  crpath3:
 14102                                  	;;;or	ComSw,mask baddir ; signal invalid directory name
 14103                                  	;;or	word [COMSW],2
 14104                                  	;or	byte [COMSW],2
 14105 00001219 800E[F78A]02            	or	byte [COMSW],mask.baddir
 14106                                  	;jmp	short cpErr	  ; return error
 14107                                  	; 16/02/2023
 14108                                  cpErr:
 14109 0000121E F9                      	stc			  ; return error
 14110                                  cpRet:
 14111 0000121F C3                      	retn
 14112                                  
 14113                                  cpMaybe:
 14114                                  ;	SI = ptr to pathname
 14115                                  
 14116                                  	;cmp	byte [si+1],COLON_CHAR
 14117 00001220 807C013A                	cmp	byte [si+1],':'
 14118 00001224 7501                    	jne	short crpath2	  ; no drive specifier, skip ahead
 14119 00001226 AD                      	lodsw			  ; SI = ptr past drive specifier "d:"
 14120                                  crpath2:
 14121 00001227 813C2E2E                	cmp	word [si],".."
 14122 0000122B 7506                    	jne	short cpFile	  ; if not "..", treat as a file
 14123 0000122D 807C0200                	cmp	byte [si+2],0
 14124                                  	;jne	short cpFile	  ; or if there's more after "..", treat as file
 14125                                  	;;;;or	ComSw,mask baddir ; signal invalid directory
 14126                                  	;;;or	word [COMSW],2
 14127                                  	;;or	byte [COMSW],2
 14128                                  	;or	byte [COMSW],mask.baddir
 14129                                  	;jmp	short cpErr	  ; return error
 14130                                  	; 16/02/2023
 14131 00001231 74E6                    	je	short crpath3
 14132                                  
 14133                                  ;	The preceding code was taken from the old DIR routine.
 14134                                  ;	It's garbage, I'm afraid. It's meant to check for ".."
 14135                                  ;	occurring when we're at the root directory. Too bad it
 14136                                  ;	doesn't handle problems with "..\..", etc.
 14137                                  
 14138                                  ;	We're ready to parse a filename into the FCB.
 14139                                  ;	SI = ptr to ASCIIZ filename
 14140                                  
 14141                                  cpFile:	
 14142 00001233 BF5C00                  	mov	di,FCB	; 5Ch	; DI = ptr to FCB
 14143 00001236 B80E29                  	mov	ax,290Eh
 14144                                  	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
 14145                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
 14146                                  				; wildcards already in FCB used as defaults
 14147 00001239 CD21                    	int	21h
 14148 0000123B F8                      	clc			; return success
 14149                                  	;jmp	short cpRet
 14150                                  	; 16/02/2023
 14151 0000123C C3                      	retn
 14152                                  
 14153                                  ;cpErr:
 14154                                  ;	stc			; return error
 14155                                  ;cpRet:
 14156                                  ;	retn
 14157                                  
 14158                                  ; ---------------------------------------------------------------------------
 14159                                  
 14160                                  ;***	InstallCtrlC - install our private control-C handler
 14161                                  ;
 14162                                  ;	Put our control-c handler in front of command.com's default
 14163                                  ;	handler, to make sure the user's default directory gets restored.
 14164                                  ;	This shouldn't be necessary, but, for now, there are situations
 14165                                  ;	where the TDATA segment is left in a modified state when a
 14166                                  ;	control-c occurs.  This means that the transient will be
 14167                                  ;	reloaded, and the user's directory cannot be restored.
 14168                                  ;
 14169                                  ;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
 14170                                  ;
 14171                                  ;	ENTRY	nothing
 14172                                  ;
 14173                                  ;	EXIT	nothing
 14174                                  ;
 14175                                  ;	USED	AX,BX,DX
 14176                                  ;
 14177                                  ;	EFFECTS
 14178                                  ;
 14179                                  ;	  CtrlCHandler address placed in int 23 vector.
 14180                                  ;
 14181                                  ;	NOTE
 14182                                  ;
 14183                                  ;	  Command.com's basic control-c handler will be restored
 14184                                  ;	  to the int 23 vector by the HeadFix routine, after DIR finishes.
 14185                                  
 14186                                  	; 16/02/2023
 14187                                  InstallCtrlC:
 14188 0000123D 06                      	push	es			; preserve ES
 14189 0000123E B82335                  	mov	ax,3523h
 14190                                  	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
 14191                                  	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
 14192 00001241 CD21                    	int	21h
 14193 00001243 891E[E395]              	mov	[OldCtrlCHandler],bx	; save old int 23 vector
 14194 00001247 8C06[E595]              	mov	[OldCtrlCHandler+2],es	 
 14195 0000124B 07                      	pop	es			; restore ES
 14196                                  
 14197 0000124C BA[AE19]                	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
 14198 0000124F B82325                  	mov	ax,2523h
 14199                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
 14200                                  	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
 14201 00001252 CD21                    	int	21h
 14202 00001254 C3                      	retn
 14203                                  
 14204                                  ; ---------------------------------------------------------------------------
 14205                                  
 14206                                  ;***	ListSubds - search and list files in subdirectories
 14207                                  ;
 14208                                  ;	ENTRY	Current directory (on selected drive) is top of subdir tree
 14209                                  ;		FCB is still set up for file searches
 14210                                  ;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
 14211                                  ;
 14212                                  ;	EXIT	CY = clear if no error
 14213                                  ;		FileCnt = # files found & displayed
 14214                                  ;		FileSiz = total size of files found
 14215                                  ;
 14216                                  ;		If error,
 14217                                  ;		CY = set
 14218                                  ;		Ready for DOS Get Extended Error call
 14219                                  ;
 14220                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14221                                  ;
 14222                                  ;	EFFECTS
 14223                                  ;
 14224                                  ;	  FileCntTotal, FileSizTotal are updated.
 14225                                  ;	  Subdirectories may be listed on standard output device.
 14226                                  ;
 14227                                  ;	NOTES
 14228                                  ;
 14229                                  ;	  ListSubds seeds the recursive entry point lsNode with a ptr
 14230                                  ;	   to a buffer where we'll stack up subdirectory filenames.
 14231                                  ;	   Each name is stored ASCIIZ.
 14232                                  
 14233                                  	; 16/02/2023
 14234                                  ListSubds:
 14235                                  	;invoke	SetRest1		; make sure user's dir gets restored
 14236 00001255 E8BA1A                  	call	SetRest1
 14237                                  
 14238 00001258 BB[A98D]                	mov	bx,ScanBuf   		; BX = ptr to child name buffer
 14239                                  lsNode:
 14240 0000125B C60700                  	mov	byte [bx],0		; start with null child name
 14241                                  lsLoop:
 14242 0000125E E8FC01                  	call	FindNextChild		; search for next subdirectory
 14243 00001261 7235                    	jc	short lsErr		; search failed - examine error
 14244                                  
 14245 00001263 89DA                    	mov	dx,bx			; DX = ptr to child's name
 14246 00001265 E85904                  	call	ChangeDir		; enter child directory
 14247                                  
 14248                                  					; M023;start
 14249 00001268 7306                    	jnc	short lstsd1		; check for error
 14250                                  	;cmp	ax,3
 14251 0000126A 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
 14252 0000126D 74EF                    	je	short lsLoop		; yes, skip over this subdirectory
 14253                                  	;jmp	short lsRet		; no, other error: DIR must fail
 14254                                  	; 16/02/2023			; M023;end
 14255 0000126F C3                      	retn
 14256                                  lstsd1:	
 14257 00001270 53                      	push	bx
 14258 00001271 E8A002                  	call	ListDir			; list the directory
 14259 00001274 5B                      	pop	bx
 14260                                  
 14261                                  ;	Note we're ignoring errors returned here.
 14262                                  
 14263 00001275 89DF                    	mov	di,bx			; DI = ptr to child's name
 14264 00001277 B90D00                  	mov	cx,13			; CX = max name length w/ null
 14265 0000127A 30C0                    	xor	al,al			; AL = zero byte to look for
 14266 0000127C F2AE                    	repne	scasb			; DI = ptr to next name pos'n in buf
 14267 0000127E 53                      	push	bx			; save ptr to child's name
 14268 0000127F 89FB                    	mov	bx,di			; BX = ptr to next name pos'n in buf
 14269 00001281 E8D7FF                  	call	lsNode			; recurse from new node
 14270 00001284 5B                      	pop	bx			; BX = ptr to child's name
 14271 00001285 9C                      	pushf				; save error condition
 14272                                  	
 14273                                  	;;shove	0
 14274                                  	;mov	ax,0
 14275 00001286 29C0                    	sub	ax,ax ; 0
 14276 00001288 50                      	push	ax
 14277                                  	;shove	".."
 14278 00001289 B82E2E                  	mov	ax,'..'  ; 2E2Eh
 14279 0000128C 50                      	push	ax
 14280 0000128D 89E2                    	mov	dx,sp			; DX = ptr to "..",0 on stack
 14281 0000128F E82F04                  	call	ChangeDir		; return to parent directory
 14282 00001292 58                      	pop	ax			; restore stack
 14283 00001293 58                      	pop	ax
 14284                                  
 14285 00001294 9D                      	popf				; restore error condition from child
 14286                                  	;jc	short lsRet		; return error
 14287                                  	;jmp	short lsLoop		; look for more children
 14288                                  	; 16/02/2023
 14289 00001295 73C7                    	jnc	short lsLoop
 14290 00001297 C3                      	retn
 14291                                  lsErr:
 14292 00001298 E8820A                  	call	get_ext_error_number	; AX = extended error code
 14293                                  	;cmp	ax,2
 14294 0000129B 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 14295 0000129E 7406                    	je	short lsRet		; file not found, we're ok
 14296                                  	;cmp	ax,18
 14297 000012A0 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 14298 000012A3 7401                    	je	short lsRet		; no more files, we're ok
 14299 000012A5 F9                      	stc				; return other errors
 14300                                  lsRet:	
 14301 000012A6 C3                      	retn
 14302                                  
 14303                                  ; ---------------------------------------------------------------------------
 14304                                  
 14305                                  	;break	<DIR support routines>
 14306                                  
 14307                                  ;***	SUPPORT ROUTINES
 14308                                  
 14309                                  ; ----------------------
 14310                                  
 14311                                  ;***	CheckChild - check potential subdirectory name for FindNextChild
 14312                                  ;
 14313                                  ;	ENTRY	DirBuf contains DOS Find-buffer with potential child
 14314                                  ;		BX = ptr to last child's name
 14315                                  ;		BP = ptr to temp child's name
 14316                                  ;
 14317                                  ;	EXIT	nothing
 14318                                  ;
 14319                                  ;	USED	AX,CX,SI,DI
 14320                                  ;
 14321                                  ;	EFFECTS
 14322                                  ;
 14323                                  ;	  Filename pointed to by BP may be changed.
 14324                                  ;
 14325                                  ;	NOTES
 14326                                  ;
 14327                                  ;	  Potential filename replaces temp filename if:
 14328                                  ;	   it's a subdirectory file;
 14329                                  ;	   it doesn't start with a '.';
 14330                                  ;	   it's alphanumerically greater than last child's name;
 14331                                  ;	   and it's alphanumerically less than temp name.
 14332                                  
 14333                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14334                                  CheckChild:
 14335                                  	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
 14336 000012A7 F606[FE8B]10            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
 14337 000012AC 7423                    	jz	short ccRet	; not a subdirectory file- return
 14338                                  
 14339                                  	; 16/02/2023
 14340 000012AE BE[078C]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14341 000012B1 803C2E                  	cmp	byte [si],'.'
 14342                                  	;;cmp	DirBuf.find_buf_pname,'.'
 14343                                  	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
 14344 000012B4 741B                    	je	short ccRet	; starts with a dot- return
 14345                                  
 14346                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14347                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14348 000012B6 89DF                    	mov	di,bx
 14349 000012B8 E81D04                  	call	CmpAscz		; compare candidate to last child's name
 14350 000012BB 7614                    	jna	short ccRet	; it's not above it- return
 14351                                  
 14352                                  	;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14353 000012BD BE[078C]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14354 000012C0 89EF                    	mov	di,bp
 14355 000012C2 E81304                  	call	CmpAscz		; compare candidate to temp name
 14356 000012C5 730A                    	jnb	short ccRet	; it's not below it- return
 14357                                  
 14358                                  ;	New kid is alright. Copy to temp.
 14359                                  
 14360                                  	;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14361 000012C7 BE[078C]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14362 000012CA 89EF                    	mov	di,bp
 14363 000012CC B90D00                  	mov	cx,13
 14364 000012CF F3A4                    	rep	movsb
 14365                                  ccRet:
 14366 000012D1 C3                      	retn
 14367                                  
 14368                                  ; ---------------------------------------------------------------------------
 14369                                  
 14370                                  ;***	CmpEntry - compare one directory entry to another in sort order
 14371                                  ;
 14372                                  ;	Compare one directory entry against another according to
 14373                                  ;	the sort codes in DestBuf. One or more comparisons
 14374                                  ;	may be made of file name, extension, time/date, and
 14375                                  ;	size.  Comparisons may be made for upward or downward
 14376                                  ;	sort order.
 14377                                  ;
 14378                                  ;	ENTRY	ES:BX = ptr to entry to compare
 14379                                  ;		ES:BP = ptr to entry to be compared against
 14380                                  ;		DestBuf contains sort codes (see DestBuf)
 14381                                  ;		DS = TRANGROUP seg addr
 14382                                  ;
 14383                                  ;	EXIT	BX = unchanged
 14384                                  ;		BP = unchanged
 14385                                  ;		Condition flags set for same, above, or below
 14386                                  ;		 comparing BX entry against BP entry.
 14387                                  ;		 'Same, above, below' translate to 'same, after, before'.
 14388                                  ;
 14389                                  ;	USED:	AX,CX,DX,SI,DI
 14390                                  
 14391                                  	; 16/02/2023
 14392                                  CmpEntry:
 14393 000012D2 BE[EC8C]                	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
 14394                                  ceLoop:
 14395 000012D5 31C0                    	xor	ax,ax		; AX = 0
 14396 000012D7 8A04                    	mov	al,[si]		; AL = sort code
 14397 000012D9 08C0                    	or	al,al
 14398 000012DB 741C                    	jz	short ceDone	; sort code is zero, we're done
 14399 000012DD 46                      	inc	si		; DS:SI = ptr to next sort code
 14400 000012DE 56                      	push	si		; save ptr to next sort code
 14401 000012DF FEC8                    	dec	al
 14402 000012E1 D0E0                    	shl	al,1
 14403                                  	;sal	al,1		; AX = index into cmp call table
 14404                                  				; CY set for downward sort order
 14405 000012E3 89C6                    	mov	si,ax		; SI = index into cmp call table
 14406 000012E5 2E8B84[FA12]            	mov	ax,[cs:si+FieldCmps]
 14407                                  				; AX = addr of compare routine
 14408 000012EA 7204                    	jc	short ceDn	; downwards sort - go swap entries
 14409 000012EC FFD0                    	call	ax 		; do upwards sort
 14410 000012EE EB06                    	jmp	short ceNs
 14411                                  ceDn:
 14412 000012F0 87DD                    	xchg	bx,bp		; swap entry ptrs for downward sort order
 14413 000012F2 FFD0                    	call	ax		; do sort
 14414 000012F4 87DD                    	xchg	bx,bp		; swap ptrs back
 14415                                  ceNs:
 14416 000012F6 5E                      	pop	si		; SI = ptr to next sort code
 14417 000012F7 74DC                    	je	short ceLoop	; compare showed no difference, keep trying
 14418                                  
 14419                                  ceDone:
 14420                                  
 14421                                  ;	Get here either from unequal compare or sort code = 0.
 14422                                  ;	In the latter case, condition codes indicate equality,
 14423                                  ;	which is correct.
 14424                                  
 14425 000012F9 C3                      	retn
 14426                                  
 14427                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14428                                  	;(MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)
 14429                                  
 14430                                  FieldCmps:		; call table of entry comparisons
 14431 000012FA [0413]                  	dw	CmpName
 14432 000012FC [0F13]                  	dw	CmpExt
 14433 000012FE [4E13]                  	dw	CmpTime
 14434 00001300 [6113]                  	dw	CmpSize
 14435 00001302 [7413]                  	dw	CmpType
 14436                                  
 14437                                  ; ---------------------------------------------------------------------------
 14438                                  
 14439                                  ;***	CmpName - compare file name of two entries
 14440                                  ;***	CmpExt - compare extension of two entries
 14441                                  ;
 14442                                  ;	ENTRY	ES:BX = ptr to one entry
 14443                                  ;		ES:BP = ptr to another entry
 14444                                  ;
 14445                                  ;	EXIT	BX = unchanged
 14446                                  ;		BP = unchanged
 14447                                  ;		Condition flags set for same, above, or below
 14448                                  ;		comparing BX entry to BP entry.
 14449                                  ;
 14450                                  ;	USED:	AX,CX,DX,SI,DI
 14451                                  
 14452                                  	; 16/02/2023
 14453                                  CmpName:
 14454 00001304 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 14455 00001306 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 14456                                  	;;add	si,filename	; ES:SI = ptr to BX name
 14457                                  	;add	si,1
 14458                                  	; 25/04/2023
 14459 00001308 46                      	inc	si
 14460                                  	;;add	di,filename	; ES:DI = ptr to BP name
 14461                                  	;add	di,1
 14462                                  	; 25/04/2023
 14463 00001309 47                      	inc	di
 14464                                  	;mov	cx,size filename; CX = length of name
 14465 0000130A B90800                  	mov	cx,8
 14466 0000130D EB0D                    	jmp	short CmpStr
 14467                                  
 14468                                  CmpExt:
 14469 0000130F 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 14470 00001311 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 14471                                  	;add	si,fileext	; ES:SI = ptr to BX extension
 14472 00001313 83C609                  	add	si,9
 14473                                  	;add	di,fileext	; ES:DI = ptr to BP extension
 14474 00001316 83C709                  	add	di,9
 14475                                  	;mov	cx,size fileext	; CX = length of extension field
 14476 00001319 B90300                  	mov	cx,3
 14477                                  
 14478                                  ;	Bugbug:	use symbol for subfunction code.
 14479                                  
 14480                                  CmpStr:	
 14481 0000131C 803E[DE95]06            	cmp	byte [CountryPtrId],6
 14482 00001321 7527                    	jne	short cnNoCollTable
 14483                                  				; no collating table available
 14484                                  
 14485                                  ;*	Compare strings using collating table.
 14486                                  ;
 14487                                  ;	ES:SI = ptr to 1st string
 14488                                  ;	ES:DI = ptr to 2nd string
 14489                                  ;	CX = length
 14490                                  
 14491 00001323 55                      	push	bp		; preserve BP
 14492 00001324 53                      	push	bx		; preserve BX
 14493 00001325 1E                      	push	ds		; preserve DS
 14494 00001326 C51E[DF95]              	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
 14495                                  	;assume	ds:NOTHING
 14496 0000132A 8B2F                    	mov	bp,[bx]		; BP = size of collating table
 14497 0000132C 43                      	inc	bx
 14498 0000132D 43                      	inc	bx		; DS:BX = ptr to collating values
 14499                                  				; DS:[BX]-2 = size of table
 14500 0000132E 31C0                    	xor	ax,ax		; AX = 0 for starters
 14501                                  
 14502                                  ;	Bugbug:	Investigate removing collating table length checks.
 14503                                  
 14504                                  cnNextChar:
 14505 00001330 268A05                  	mov	al,[es:di]	; AL = AX = char from 2nd string
 14506 00001333 47                      	inc	di		; ES:DI = ptr to next char 2nd string
 14507 00001334 39E8                    	cmp	ax,bp		; compare to collating table length
 14508 00001336 7301                    	jae	short cn1 	; char not in table
 14509 00001338 D7                      	xlat				
 14510                                  cn1:				; AL = AX = collating value
 14511 00001339 89C2                    	mov	dx,ax		; DX = collating value from 2nd string
 14512                                  	;lods	byte ptr es:[si]
 14513 0000133B 26AC                    	es	lodsb		; AL = AX = char from 1st string
 14514                                  				; ES:SI = ptr to next char 1st string
 14515 0000133D 39E8                    	cmp	ax,bp		; compare to collating table length
 14516 0000133F 7301                    	jae	short cn2	; char not in table
 14517 00001341 D7                      	xlat				
 14518                                  cn2:				; AL = AX = collating value
 14519 00001342 39D0                    	cmp	ax,dx		; compare collating values
 14520 00001344 E1EA                    	loope	cnNextChar	; until unequal or no more left
 14521                                  
 14522 00001346 1F                      	pop	ds		; restore DS
 14523                                  	;assume	ds:TRANGROUP
 14524 00001347 5B                      	pop	bx		; restore BX
 14525 00001348 5D                      	pop	bp		; restore BP
 14526 00001349 C3                      	retn
 14527                                  
 14528                                  ;*	If no collating table is available, simply compare raw ASCII values.
 14529                                  ;	Don't we wish we could just do this all the time?  Sigh.
 14530                                  
 14531                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14532                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
 14533                                  cnNoCollTable:
 14534                                  	;repe	cmps byte ptr es:[si],[di]
 14535                                  				;db 0F3h,26h,0A6h,0C3h
 14536 0000134A F3                      	repe	; 0F3h
 14537 0000134B 26                      	es	; 26h
 14538 0000134C A6                      	cmpsb	; 0A6h
 14539 0000134D C3                      	retn	; 0C3h
 14540                                  
 14541                                  ; ---------------------------------------------------------------------------
 14542                                  
 14543                                  ;***	CmpTime - compare entries by date/time
 14544                                  ;
 14545                                  ;	ENTRY	ES:BX = ptr to one entry
 14546                                  ;		ES:BP = ptr to another entry
 14547                                  ;
 14548                                  ;	EXIT	BX = unchanged
 14549                                  ;		BP = unchanged
 14550                                  ;		Condition flags set for same, above, or below
 14551                                  ;		 comparing BX entry to BP entry.
 14552                                  ;
 14553                                  ;	USED:	CX,SI,DI
 14554                                  ;
 14555                                  ;	NOTE	Filetime and filedate fields in our private entry
 14556                                  ;		structure must be adjacent and in that order.
 14557                                  
 14558                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14559                                  CmpTime:
 14560 0000134E 89DE                    	mov	si,bx
 14561 00001350 89EF                    	mov	di,bp
 14562                                  	;add	si,filedate + size filedate - 1
 14563 00001352 83C610                  	add	si,16 ; 15+2-1
 14564                                  	;add	di,filedate + size filedate - 1
 14565 00001355 83C710                  	add	di,16 ; 15+2-1
 14566                                  	;mov	cx,size filetime + size filedate
 14567 00001358 B90400                  	mov	cx,4 ; 2+2
 14568 0000135B FD                      	std
 14569                                  	;repe	cmps byte ptr es:[si],[di]
 14570                                  				;db 0F3h,26h,0A6h,0FCh, 0C3h
 14571 0000135C F3                      	repe	; 0F3h
 14572 0000135D 26                      	es	; 26h
 14573 0000135E A6                      	cmpsb	; 0A6h
 14574                                  	
 14575 0000135F FC                      	cld	; 0FCh
 14576 00001360 C3                      	retn	; 0C3h
 14577                                  
 14578                                  ; ---------------------------------------------------------------------------
 14579                                  
 14580                                  ;***	CmpSize - compare entries by size
 14581                                  ;
 14582                                  ;	ENTRY	ES:BX = ptr to one entry
 14583                                  ;		ES:BP = ptr to another entry
 14584                                  ;
 14585                                  ;	EXIT	BX = unchanged
 14586                                  ;		BP = unchanged
 14587                                  ;		Condition flags set for same, above, or below
 14588                                  ;		 comparing BX entry to BP entry.
 14589                                  ;
 14590                                  ;	USED:	CX,SI,DI
 14591                                  
 14592                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14593                                  CmpSize:
 14594                                  
 14595 00001361 89DE                    	mov	si,bx
 14596 00001363 89EF                    	mov	di,bp
 14597                                  	;add	si,filesize + size filesize - 1
 14598 00001365 83C614                  	add	si,20  ; 17+4-1
 14599                                  	;add	di,filesize + size filesize - 1
 14600 00001368 83C714                  	add	di,20  ; 17+4-1
 14601                                  	;mov	cx,size filesize
 14602 0000136B B90400                  	mov	cx,4
 14603 0000136E FD                      	std
 14604                                  	;repe	cmps byte ptr es:[si],[di]
 14605                                  				;db 0F3h,26h,0A6h
 14606 0000136F F3                      	repe	; 0F3h
 14607 00001370 26                      	es	; 26h
 14608 00001371 A6                      	cmpsb	; 0A6h
 14609                                  
 14610 00001372 FC                      	cld
 14611 00001373 C3                      	retn
 14612                                  
 14613                                  ; ---------------------------------------------------------------------------
 14614                                  
 14615                                  ;***	CmpType - compare entries by file type (subdirectory or not)
 14616                                  ;
 14617                                  ;	ENTRY	ES:BX = ptr to one entry
 14618                                  ;		ES:BP = ptr to another entry
 14619                                  ;
 14620                                  ;	EXIT	BX = unchanged
 14621                                  ;		BP = unchanged
 14622                                  ;		Condition flags set for same, above, or below
 14623                                  ;		 comparing BX entry to BP entry.
 14624                                  ;
 14625                                  ;	USED:	AX
 14626                                  
 14627                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14628                                  CmpType:
 14629                                  	;mov	al,es:[bx].fileattr
 14630 00001374 268A470C                	mov	al,[es:bx+12]
 14631                                  	;mov	ah,es:[bp].fileattr
 14632 00001378 268A660C                	mov	ah,[es:bp+12]
 14633                                  	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
 14634                                  	;and	ax,1010h
 14635 0000137C 251010                  	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
 14636 0000137F 38C4                    	cmp	ah,al
 14637 00001381 C3                      	retn
 14638                                  
 14639                                  ; ---------------------------------------------------------------------------
 14640                                  
 14641                                  ;***	DefaultAttr - set default attribute conditions
 14642                                  ;
 14643                                  ;	ENTRY	nothing
 14644                                  ;
 14645                                  ;	EXIT	CY clear
 14646                                  ;
 14647                                  ;	USED
 14648                                  ;
 14649                                  ;	EFFECTS
 14650                                  ;
 14651                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 14652                                  
 14653                                  	; 16/02/2023
 14654                                  DefaultAttr:
 14655                                  	;mov	byte [AttrSpecified],6
 14656 00001382 C606[438C]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
 14657                                  					; specify H and S
 14658 00001387 C606[448C]00            	mov	byte [AttrSelect],0	; H and S must be off
 14659 0000138C F8                      	clc				; return success
 14660                                  dtRet:	; 18/02/2023
 14661 0000138D C3                      	retn
 14662                                  
 14663                                  ; ---------------------------------------------------------------------------
 14664                                  
 14665                                  ;***	DisplayTotals - display grand total stats
 14666                                  ;
 14667                                  ;	If we searched subdirectories, display the total # files found
 14668                                  ;	 and total size of files found.
 14669                                  ;	Display disk space remaining.
 14670                                  ;
 14671                                  ;	ENTRY	FileCntTotal, FileSizTotal contain correct values
 14672                                  ;		Bits contains setting of /s
 14673                                  ;		FCB contains drive #
 14674                                  ;
 14675                                  ;	EXIT	nothing
 14676                                  ;
 14677                                  ;	USES	AX,DX
 14678                                  ;		FileSiz
 14679                                  
 14680                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14681                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h
 14682                                  
 14683                                  DisplayTotals:
 14684                                  	;;;test	Bits,mask subd
 14685                                  	;;test	word [_Bits],4
 14686                                  	;test	byte [_Bits],4
 14687 0000138E F606[3B8C]04            	test	byte [_Bits],mask.subd
 14688 00001393 741D                    	jz	short dtFree		; no subdirectories- do bytes free
 14689                                  
 14690 00001395 E86112                  	call	CRLF2			; start on new line
 14691 00001398 E8CF03                  	call	UseLine
 14692                                  
 14693 0000139B BA[B181]                	mov	dx,total_ptr
 14694 0000139E E8A23A                  	call	std_printf		; "Total:",cr,lf
 14695 000013A1 E8C603                  	call	UseLine
 14696                                  
 14697 000013A4 A1[128B]                	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
 14698 000013A7 BE[168B]                	mov	si,FileSizTotal
 14699 000013AA BF[0E8B]                	mov	di,FileSiz
 14700 000013AD A5                      	movsw
 14701 000013AE A5                      	movsw				; move total size to size variable
 14702 000013AF E88505                  	call	DisplayCntSiz		; display file count & size &
 14703                                  dtFree: 				;   (maybe) compression ratio
 14704 000013B2 B436                    	mov	ah,36h
 14705                                  	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
 14706 000013B4 8A165C00                	mov	dl,[FCB] ; [5Ch]	; DL = drive#
 14707 000013B8 CD21                    	int	21h			; call DOS
 14708 000013BA 83F8FF                  	cmp	ax,-1			; check 'invalid drive' return code
 14709 000013BD 74CE                    	jz	short dtRet		; can't get drive space - return
 14710 000013BF F7E1                    	mul	cx
 14711 000013C1 F7E3                    	mul	bx
 14712 000013C3 A3[D78C]                	mov	[Bytes_Free],ax
 14713 000013C6 8916[D98C]              	mov	[Bytes_Free+2],dx
 14714 000013CA BA[C37F]                	mov	dx,bytmes_ptr
 14715 000013CD E8733A                  	call	std_printf		; "nnn bytes free",cr,lf
 14716                                  	;call	UseLine
 14717                                  ;dtRet:
 14718                                  	;retn
 14719                                  	; 18/02/2023
 14720 000013D0 E99703                  	jmp	UseLine
 14721                                  
 14722                                  ; ---------------------------------------------------------------------------
 14723                                  
 14724                                  ;***	FileIsDevice - see if file looks like a device
 14725                                  ;
 14726                                  ;	ENTRY	PathPos = ptr to pathname
 14727                                  ;		PathCnt = length of pathname w/o terminating char
 14728                                  ;		DirBuf is DOS DTA
 14729                                  ;
 14730                                  ;	EXIT	ZR = set if file looks like a device
 14731                                  ;
 14732                                  ;	USED	AX,BX,CX,DX,DI
 14733                                  ;
 14734                                  ;	EFFECTS
 14735                                  ;
 14736                                  ;	  DTA buffer holds results of Find First function
 14737                                  ;
 14738                                  ;	NOTES
 14739                                  ;
 14740                                  ;	  We try to flag devices in two ways. First, we try
 14741                                  ;	  the DOS Find First function. It returns attribute bit 6
 14742                                  ;	  set on a successful find if it identifies a device name.
 14743                                  ;	  Unfortunately, it returns 'path not found' for a device
 14744                                  ;	  name terminated with colon, such as "CON:". So, we look
 14745                                  ;	  for any colon in the pathname after the 2nd character,
 14746                                  ;	  and flag the pathname as a device if we find one.
 14747                                  
 14748                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14749                                  FileIsDevice:
 14750 000013D3 8B16[3F8C]              	mov	dx,[PathPos]	 ; DX = ptr to pathname
 14751                                  
 14752 000013D7 89D7                    	mov	di,dx
 14753 000013D9 033E[3D8C]              	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
 14754 000013DD 30DB                    	xor	bl,bl		 ; BL = NUL to terminate pathname with
 14755 000013DF 861D                    	xchg	bl,[di] 	 ; BL = saved pathname terminating char
 14756                                  
 14757 000013E1 31C9                    	xor	cx,cx		 ; CX = attribute mask (normal search)
 14758 000013E3 B44E                    	mov	ah,4Eh
 14759                                  	;mov	ah,Find_First	 ; AH = DOS Find First function code
 14760 000013E5 CD21                    	int	21h	 	 ; call DOS
 14761 000013E7 861D                    	xchg	bl,[di]		 ; restore pathname terminating char
 14762 000013E9 720A                    	jc	short piCol	 ; didn't find a dir entry, check for colon
 14763                                  
 14764                                  ;	Found a dir entry, see if Find First thinks it's a device.
 14765                                  
 14766                                  	;test	byte [DIRBUF+21],40h
 14767 000013EB F606[FE8B]40            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 14768 000013F0 7403                    	jz	short piCol	 ; device attribute not set, look for colon
 14769 000013F2 31C9                    	xor	cx,cx		 ; it's a device, return ZR flag
 14770                                  	;jmp	short piRet
 14771                                  	; 25/04/2023
 14772                                  piRet:
 14773 000013F4 C3                      	retn
 14774                                  
 14775                                  ;	Device attribute not returned by Find First function. But
 14776                                  ;	let's check for a colon anywhere in the pathname after the
 14777                                  ;	second byte.
 14778                                  ;
 14779                                  ;	DI = ptr to byte after pathname
 14780                                  
 14781                                  piCol:
 14782 000013F5 4F                      	dec	di		 ; DI = ptr to last char in pathname
 14783 000013F6 B03A                    	mov	al,':'
 14784                                  	;mov	al,COLON_CHAR	 ; AL = colon char to search for
 14785 000013F8 8B0E[3D8C]              	mov	cx,[PathCnt]	 ; CX = # chars to scan
 14786 000013FC 49                      	dec	cx
 14787 000013FD 49                      	dec	cx		 ; ignore 1st two chars of pathname
 14788 000013FE 09C9                    	or	cx,cx
 14789 00001400 78F2                    	js	short piRet	 ; if < 2 chars in pathname, just return
 14790 00001402 09FF                    	or	di,di		 ; clear ZR in case CX = 0
 14791 00001404 FD                      	std			 ; scan downward
 14792 00001405 F2AE                    	repne	scasb
 14793 00001407 FC                      	cld			 ; restore default upward direction
 14794                                  
 14795                                  ;	After scanning, the ZR flag is set to indicate presence of a colon.
 14796                                  ;piRet:
 14797 00001408 C3                      	retn
 14798                                  
 14799                                  ;FileIsDevice endp
 14800                                  
 14801                                  ; ---------------------------------------------------------------------------
 14802                                  
 14803                                  ;***	FindFirst - find first directory entry to display
 14804                                  ;***	FindNext - find next directory entry to display
 14805                                  ;
 14806                                  ;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
 14807                                  ;		AttrSpecified, AttrSelect are set
 14808                                  ;
 14809                                  ;	EXIT	CY = clear if successful
 14810                                  ;		BX = offset in TPA buffer of directory entry found
 14811                                  ;
 14812                                  ;		If unsuccessful,
 14813                                  ;		CY = set
 14814                                  ;		AX = DOS error code
 14815                                  ;		DOS Get Extended Error call will get error code
 14816                                  ;
 14817                                  ;		NOTE: if entries were loaded into TPA, AX contains
 14818                                  ;		ERROR_NO_MORE_FILES when no more entries are available,
 14819                                  ;		but DOS Get Extended Error call WON'T return the correct
 14820                                  ;		error. That's ok, because we'll see the value in AX
 14821                                  ;		and recognize it as a non-error condition.
 14822                                  ;
 14823                                  ;	USED	AX,CX,DX,SI,DI
 14824                                  ;
 14825                                  ;	EFFECTS
 14826                                  ;
 14827                                  ;	  Entries in memory may be marked as output.
 14828                                  ;	  If not sorted, entry is loaded at TPA.
 14829                                  ;
 14830                                  ;	NOTES
 14831                                  ;
 14832                                  ;	  If we don't find a qualifying file, we return after the final
 14833                                  ;	   DOS Find File call. A DOS Get Extended Error call will then
 14834                                  ;	   indicate an appropriate condition.
 14835                                  
 14836                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14837                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 14838                                  	
 14839                                  FindFirst:
 14840                                  	;mov	ax,offset TRANGROUP:GetFirst
 14841 00001409 B8[E014]                	mov	ax,GetFirst
 14842 0000140C EB03                    	jmp	short ffFindEntry
 14843                                  
 14844                                  	; 18/02/2023
 14845                                  FindNext:
 14846                                  	;mov	ax,offset TRANGROUP:GetNext
 14847 0000140E B8[F714]                	mov	ax,GetNext
 14848                                  
 14849                                  ;	AX = address of correct disk get routine to use.
 14850                                  
 14851                                  ffFindEntry:
 14852 00001411 06                      	push	es			; save TRANGROUP seg addr
 14853                                  	;;;test	Bits,mask inmem
 14854                                  	;;test	word [_Bits],20h
 14855                                  	;test	byte [_Bits],20h
 14856 00001412 F606[3B8C]20            	test	byte [_Bits],mask.inmem
 14857 00001417 7405                    	jz	short ffDisk		; entries not in memory, search disk
 14858                                  
 14859                                  ;	Entries are loaded in memory to sort out. Find the first one.
 14860                                  ;	There will always be one, or LoadEntries would've failed.
 14861                                  
 14862 00001419 E81A00                  	call	FindInMem		; find first entry in TPA
 14863 0000141C EB16                    	jmp	short ffRet		; return what TPA search returns
 14864                                  
 14865                                  ;	Get entry from disk.
 14866                                  
 14867                                  ffDisk:
 14868 0000141E FFD0                    	call	ax			; get entry from disk
 14869 00001420 720E                    	jc	short ffGetErr		; get & return error
 14870 00001422 8E06[E28A]              	mov	es,[TPA]		; ES = seg addr of TPA
 14871 00001426 31FF                    	xor	di,di			; ES:DI = ptr to TPA
 14872 00001428 89FB                    	mov	bx,di			; BX = offset of entry in TPA
 14873 0000142A E86101                  	call	LoadEntry		; load entry to TPA
 14874 0000142D F8                      	clc				; return success
 14875 0000142E EB04                    	jmp	short ffRet
 14876                                  
 14877                                  ffGetErr:
 14878 00001430 E8EA08                  	call	 get_ext_error_number	; AX = DOS error code
 14879 00001433 F9                      	stc
 14880                                  ffRet:
 14881 00001434 07                      	pop	es			; ES = TRANGROUP seg addr again
 14882 00001435 C3                      	retn
 14883                                  
 14884                                  ; ---------------------------------------------------------------------------
 14885                                  
 14886                                  ;***	FindInMem - find next directory entry in TPA buffer
 14887                                  ;
 14888                                  ;	ENTRY	TPA is loaded (see LoadEntries)
 14889                                  ;
 14890                                  ;	EXIT	BX = offset in TPA of entry found
 14891                                  ;
 14892                                  ;		If no more files,
 14893                                  ;		CY = set
 14894                                  ;		AX = DOS 'no more files' error code
 14895                                  ;
 14896                                  ;	USED	AX,BX,CX,DX,SI,DI,BP,ES
 14897                                  ;
 14898                                  ;	EFFECTS
 14899                                  ;
 14900                                  ;	  Entry found is flagged as 'used' (see EntryStruc).
 14901                                  
 14902                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14903                                  FindInMem:
 14904 00001436 8E06[E28A]              	mov	es,[TPA]		; ES = TPA seg addr
 14905 0000143A 31DB                    	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
 14906 0000143C FC                      	cld				; make sure default string direction is up
 14907                                  	
 14908 0000143D E86D00                  	call	FindOneInMem		; locate an entry
 14909 00001440 720E                    	jc	short fiNoMore		; none left, set up 'no more files' error
 14910                                  
 14911                                  ;	BX = ptr to entry in TPA
 14912                                  
 14913                                  fiBest:
 14914 00001442 89DD                    	mov	bp,bx			; BP = ptr to best entry so far
 14915                                  fiNext:
 14916 00001444 E87300                  	call	FindNextInMem		; locate next entry
 14917 00001447 720C                    	jc	short fiFound		; no more, best entry so far wins
 14918                                  
 14919                                  ;	BX = ptr to next entry
 14920                                  
 14921 00001449 E886FE                  	call	CmpEntry		; compare it to best found so far (BP)
 14922 0000144C 73F6                    	jnb	short fiNext		; it's not better, go look at next one
 14923 0000144E EBF2                    	jmp	short fiBest		; it's better, go mark it as best so far
 14924                                  
 14925                                  fiNoMore:
 14926                                  
 14927                                  ;	No more entries available in TPA. Set up 'no more files' error.
 14928                                  
 14929                                  	;mov	ax,18
 14930 00001450 B81200                  	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
 14931 00001453 F9                      	stc				; return error
 14932                                  	;jmp	short fiRet
 14933                                  	; 18/02/2023
 14934 00001454 C3                      	retn
 14935                                  
 14936                                  fiFound:
 14937 00001455 89EB                    	mov	bx,bp			; BX = ptr to best entry found
 14938 00001457 26C60701                	mov	byte [es:bx],1		; mark entry 'used'
 14939 0000145B F8                      	clc				; return success
 14940                                  fiRet:
 14941 0000145C C3                      	retn
 14942                                  
 14943                                  ; ---------------------------------------------------------------------------
 14944                                  
 14945                                  ;***	FindNextChild - find next subdirectory in current directory
 14946                                  ;
 14947                                  ;	ENTRY	BX = ptr to last child found, ASCIIZ filename
 14948                                  ;		DirBuf is established DTA
 14949                                  ;
 14950                                  ;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
 14951                                  ;
 14952                                  ;		If failure,
 14953                                  ;		CY = set
 14954                                  ;		DOS Get Extended Error call will get error
 14955                                  ;
 14956                                  ;	USED	AX,CX,DX,SI,DI,BP
 14957                                  ;
 14958                                  ;	EFFECTS
 14959                                  ;
 14960                                  ;	  DirBuf is used for find first/next calls.
 14961                                  ;
 14962                                  ;	NOTES
 14963                                  ;
 14964                                  ;	  We keep on checking files until DOS returns an error. If
 14965                                  ;	  the error is 'no more files' and the temp filename is not
 14966                                  ;	  the initial high tag, copy the temp to the child's name spot
 14967                                  ;	  and return success. Otherwise, send the error back to caller.
 14968                                  ;
 14969                                  ;	  This routine depends on DS,ES,CS, & SS all being equal.
 14970                                  
 14971                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14972                                  FindNextChild:
 14973 0000145D 83EC0C                  	sub	sp,12			; make temp filename buf on stack
 14974                                  	;shove	00FFh			; temp filename = high tag
 14975 00001460 B8FF00                  	mov	ax,0FFh
 14976 00001463 50                      	push	ax
 14977 00001464 89E5                    	mov	bp,sp			; BP = ptr to temp filename buf
 14978                                  	;shove	"*"	
 14979 00001466 B02A                    	mov	al,'*'  ; ax = 002Ah
 14980 00001468 50                      	push	ax
 14981                                  	;;shove	".*" 
 14982                                  	;mov	ax,"*."
 14983                                  	;mov	ax,2E2Ah
 14984 00001469 B42E                    	mov	ah,'.'
 14985 0000146B 50                      	push	ax
 14986 0000146C E80805                  	call	GetDriveLtr		; AX = "d:"
 14987 0000146F 50                      	push	ax
 14988 00001470 89E2                    	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack
 14989                                  
 14990                                  ;	See that the stack is restored properly at the end of this proc.
 14991                                  
 14992                                  	;mov	cx,10h
 14993 00001472 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 14994 00001475 B44E                    	mov	ah,4Eh
 14995                                  	;mov	ah,Find_First
 14996 00001477 CD21                    	int	21h			; DOS- Find First matching file
 14997 00001479 722C                    	jc	short fcRet		; return error
 14998                                  
 14999 0000147B E829FE                  	call	CheckChild		; check child against last, temp
 15000                                  fcNext:	
 15001                                  	;mov	cx,10h
 15002 0000147E B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15003 00001481 B44F                    	mov	ah,4Fh
 15004                                  	;mov	ah,Find_Next
 15005 00001483 CD21                    	int	21h			; DOS- Find Next matching file
 15006 00001485 7205                    	jc	short fcErr		; examine error
 15007                                  
 15008 00001487 E81DFE                  	call	CheckChild		; check child against last, temp
 15009 0000148A EBF2                    	jmp	short fcNext		; go find another child
 15010                                  
 15011                                  fcErr:
 15012 0000148C E88E08                  	call	get_ext_error_number	; AX = extended error code
 15013                                  	;cmp	ax,18
 15014 0000148F 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
 15015 00001492 7512                    	jne	short fcNope		; some other error- return it
 15016                                  
 15017                                  ;	We ran out of files. See if we qualified at least one.
 15018                                  
 15019 00001494 807E00FF                	cmp	byte [bp],0FFh
 15020 00001498 740C                    	je	short fcNope		; temp filename is unused- no child
 15021                                  
 15022                                  ;	Move temp filename to child name position.
 15023                                  
 15024 0000149A 89EE                    	mov	si,bp			; SI = ptr to temp filename
 15025 0000149C 89DF                    	mov	di,bx			; DI = ptr to child name pos'n
 15026                                  fcMove:
 15027 0000149E AC                      	lodsb				; AL = next byte of filename
 15028 0000149F AA                      	stosb				; store byte
 15029 000014A0 08C0                    	or	al,al
 15030 000014A2 7403                    	jz	short fcRet		; byte was zero, return success (CY clear)
 15031 000014A4 EBF8                    	jmp	short fcMove		; go move another byte
 15032                                  fcNope:
 15033 000014A6 F9                      	stc				; return error
 15034                                  fcRet:
 15035 000014A7 9F                      	lahf
 15036 000014A8 83C414                  	add	sp,20			; restore stack
 15037 000014AB 9E                      	sahf
 15038 000014AC C3                      	retn
 15039                                  
 15040                                  ; ---------------------------------------------------------------------------
 15041                                  
 15042                                  ;***	FindOneInMem - find the first available entry in TPA
 15043                                  ;***	FindNextInMem - find the next available entry in TPA
 15044                                  ;
 15045                                  ;	ENTRY	ES = TPA seg addr
 15046                                  ;		BX = ptr to entry in TPA
 15047                                  ;
 15048                                  ;	EXIT	BX = ptr to entry found
 15049                                  ;		CY = set if no more entries available in TPA
 15050                                  ;
 15051                                  ;	USED	AL
 15052                                  
 15053                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15054                                  FindOneInMem:
 15055 000014AD 268A07                  	mov	al,[es:bx]		; examine 'used' byte of starting entry
 15056 000014B0 3C01                    	cmp	al,1
 15057 000014B2 7406                    	je	short FindNextInMem	; entry has already been used
 15058 000014B4 3CFF                    	cmp	al,0FFh
 15059 000014B6 7407                    	je	short foNoMore		; 0FFh, we're at the end of the list
 15060                                  
 15061                                  ;	BX = ptr to entry that hasn't been output yet.
 15062                                  
 15063 000014B8 F8                      	clc				; return success
 15064 000014B9 C3                      	retn
 15065                                  
 15066                                  FindNextInMem:
 15067 000014BA 83C315                  	add	bx,21
 15068                                  	;add	bx,size EntryStruc	; BX = ptr to next entry
 15069 000014BD EBEE                    	jmp	short FindOneInMem	; go look at it
 15070                                  foNoMore:
 15071 000014BF F9                      	stc				; ran out of entries, return failure
 15072 000014C0 C3                      	retn
 15073                                  
 15074                                  ; ---------------------------------------------------------------------------
 15075                                  
 15076                                  ;***	GetEnvValue - get value of our environment variable
 15077                                  ;
 15078                                  ;	ENTRY	DS, ES = TRANGROUP seg addr
 15079                                  ;
 15080                                  ;	EXIT	CY = set if environment variable not in environment
 15081                                  ;
 15082                                  ;		Otherwise:
 15083                                  ;		SI = ptr to environment variable asciiz value in TRANGROUP
 15084                                  ;
 15085                                  ;	USED	AX,BX,CX,DX,DI
 15086                                  ;		(We assume the (almost) worst, since we don't know about
 15087                                  ;		Find_Name_In_Environment.)
 15088                                  ;
 15089                                  ;	EFFECTS
 15090                                  ;
 15091                                  ;	  ScanBuf is loaded with value text
 15092                                  
 15093                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15094                                  GetEnvValue:
 15095 000014C1 06                      	push	es				; save ES
 15096                                  	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
 15097 000014C2 BE[F981]                	mov	si,DirEnvVar
 15098                                  	;invoke	Find_Name_In_Environment
 15099 000014C5 E8720E                  	call	find_name_in_environment
 15100 000014C8 7214                    	jc	short geRet			; name not found in environment
 15101                                  
 15102                                  ;	ES:DI = ptr to value of environment variable
 15103                                  ;	We're assuming DS, CS, and SS are unchanged.
 15104                                  
 15105 000014CA 1E                      	push	ds
 15106 000014CB 06                      	push	es
 15107 000014CC 1F                      	pop	ds
 15108 000014CD 07                      	pop	es
 15109                                  
 15110                                  	;assume	ds:nothing
 15111                                  
 15112                                  ;	DS = seg addr of environment variable value (in environment segment)
 15113                                  ;	ES = TRANGROUP seg addr
 15114                                  
 15115 000014CE 89FE                    	mov	si,di				; DS:SI = ptr to value string
 15116                                  	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
 15117 000014D0 BF[A98D]                	mov	di,ScanBuf
 15118                                  geLoop:
 15119                                  ;@@:	
 15120 000014D3 AC                      	lodsb
 15121 000014D4 08C0                    	or	al,al
 15122 000014D6 AA                      	stosb
 15123                                  	;loopnz	@B		; move the string, including trailing null
 15124 000014D7 E0FA                    	loopnz	geLoop
 15125                                  
 15126 000014D9 06                      	push	es
 15127 000014DA 1F                      	pop	ds		; DS = TRANGROUP seg addr again
 15128                                  	;assume	ds:TRANGROUP
 15129                                  
 15130                                  	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
 15131 000014DB BE[A98D]                	mov	si,ScanBuf
 15132                                  geRet:
 15133 000014DE 07                      	pop	es				; restore ES
 15134 000014DF C3                      	retn
 15135                                  
 15136                                  ; ---------------------------------------------------------------------------
 15137                                  
 15138                                  ;***	GetFirst - get first directory entry from disk
 15139                                  ;
 15140                                  ;	ENTRY	DOS DTA established at DirBuf
 15141                                  ;		FCB contains drive # and filename
 15142                                  ;		Current directory (on selected drive) is the one to search
 15143                                  ;		AttrSpecified & AttrSelect masks set
 15144                                  ;
 15145                                  ;	EXIT	CY = clear if success
 15146                                  ;		DirBuf contains extended FCB for file found
 15147                                  ;
 15148                                  ;		If unsuccessful,
 15149                                  ;		CY = set
 15150                                  ;		Ready for DOS Get Extended Error call
 15151                                  ;
 15152                                  ;	USED	AX,DX
 15153                                  ;
 15154                                  ;	EFFECTS
 15155                                  ;
 15156                                  ;	  FCB-7 = 0FFh to mark extended FCB
 15157                                  ;	  FCB-1 = attribute mask to find all files
 15158                                  ;	  These fields should remain unmodified for GetNext calls.
 15159                                  ;
 15160                                  ;***	GetNext - get next directory entry from disk
 15161                                  ;
 15162                                  ;	ENTRY	As for GetFirst, plus
 15163                                  ;		FCB-7 set up as extended FCB w/ find-all attribute byte
 15164                                  ;
 15165                                  ;	EXIT	As for GetFirst
 15166                                  ;
 15167                                  ;	USED	AX,DX
 15168                                  
 15169                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15170                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15171                                  GetFirst:
 15172                                  	;mov	byte [55h],0FFh	; -1
 15173 000014E0 C6065500FF              	mov	byte [FCB-7],0FFh	; signal extended FCB
 15174                                  	;mov	byte [5Bh],16h
 15175 000014E5 C6065B0016              	mov	byte [FCB-1],ATTR_ALL ; 16h
 15176                                  					; find any file
 15177 000014EA BA5500                  	mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
 15178 000014ED B411                    	mov	ah,11h
 15179                                  	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
 15180 000014EF CD21                    	int	21h			; call DOS
 15181 000014F1 D0E0                    	shl	al,1			; CY = set if error
 15182 000014F3 721E                    	jc	short gfRet		; return error
 15183 000014F5 EB0B                    	jmp	short gfFound		; go look at attr's
 15184                                  GetNext:
 15185                                  	;mov	dx,55h
 15186 000014F7 BA5500                  	mov	dx,FCB-7		; DX = ptr to extended FCB
 15187 000014FA B412                    	mov	ah,12h
 15188                                  	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
 15189 000014FC CD21                    	int	21h			; call DOS
 15190 000014FE D0E0                    	shl	al,1			; CY = set if error
 15191 00001500 7211                    	jc	short gfRet		; return error
 15192                                  
 15193                                  ;*	Found an entry. Check attributes.
 15194                                  gfFound:
 15195                                  	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
 15196                                  	;mov	al,[DIRBUF+19]
 15197 00001502 A0[FC8B]                	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
 15198 00001505 8A26[438C]              	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
 15199 00001509 20E0                    	and	al,ah			; AL = pertinent attr's of file
 15200 0000150B 2226[448C]              	and	ah,[AttrSelect]		; AH = attr settings to match
 15201 0000150F 38E0                    	cmp	al,ah
 15202 00001511 75E4                    	jne	short GetNext		; attr's don't match, look for another
 15203                                  gfRet:
 15204 00001513 C3                      	retn
 15205                                  
 15206                                  ; ---------------------------------------------------------------------------
 15207                                  
 15208                                  ;***	ListDir - search for and list files in the current directory
 15209                                  ;
 15210                                  ;	List header, files, and trailer for current directory on selected
 15211                                  ;	drive. Header & trailer are listed if at least one file is found.
 15212                                  ;	If no qualifying files are found, no display output occurs.
 15213                                  ;
 15214                                  ;	ENTRY	Current directory (on selected drive) is the one to be listed
 15215                                  ;		FCB contains selected drive # and filename spec
 15216                                  ;		Option bits, attribute masks, and sort codes set up
 15217                                  ;
 15218                                  ;	EXIT	CY = clear if no error
 15219                                  ;		FileCnt = # files found & displayed
 15220                                  ;
 15221                                  ;		If error,
 15222                                  ;		CY = set
 15223                                  ;		Ready for DOS Get Extended Error call
 15224                                  ;
 15225                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 15226                                  ;		FileSiz
 15227                                  ;
 15228                                  ;	EFFECTS
 15229                                  ;
 15230                                  ;	  FileCntTotal, FileSizTotal are updated.
 15231                                  ;	  Files found are listed. A directory header and trailer are
 15232                                  ;	   displayed only if files are found.
 15233                                  
 15234                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15235                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh
 15236                                  
 15237                                  ListDir:
 15238 00001514 31C0                    	xor	ax,ax
 15239 00001516 A3[0C8B]                	mov	[FileCnt],ax		; zero file count
 15240 00001519 A3[0E8B]                	mov	[FileSiz],ax		; zero file size accumulator
 15241 0000151C A3[108B]                	mov	[FileSiz+2],ax
 15242 0000151F 803E[EC8C]00            	cmp	byte [DestBuf],0	; check for sort code
 15243 00001524 740A                    	je	short ld1		; no sort
 15244 00001526 E83100                  	call	LoadEntries		; load entries for sorted listing
 15245 00001529 7305                    	jnc	short ld1		; no error - continue
 15246 0000152B E8EF07                  	call	get_ext_error_number	; AX = DOS error code
 15247                                  	; 19/02/2023
 15248                                  	;stc
 15249 0000152E EB12                    	jmp	short ldErr		; return error
 15250                                  ld1:
 15251 00001530 E8D6FE                  	call	FindFirst		; find first file
 15252 00001533 720D                    	jc	short ldErr		; not found, return error
 15253                                  
 15254                                  ;	BX = offset in TPA buffer of entry found
 15255                                  
 15256 00001535 E8E302                  	call	DisplayHeader		; if at least one file, display header
 15257                                  ldNext:
 15258 00001538 E8BB02                  	call	DisplayFile		; display the file entry
 15259                                  ;ldNext:
 15260 0000153B E8D0FE                  	call	FindNext		; find another file
 15261 0000153E 7202                    	jc	short ldErr		; not found
 15262                                  	;call	DisplayFile		; display entry
 15263                                  	;jmp	short ldNext		; go find another one
 15264                                  	; 19/02/2023
 15265 00001540 EBF6                    	jmp	short ldNext
 15266                                  ldErr:
 15267                                  	;cmp	ax,2
 15268 00001542 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 15269 00001545 7407                    	je	short ldDone		; file not found, we're done
 15270                                  	;cmp	ax,18
 15271 00001547 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 15272 0000154A 7402                    	je	short ldDone		; no more files, we're done
 15273 0000154C F9                      	stc
 15274                                  	;jmp	short ldRet
 15275                                  	; 19/02/2023
 15276 0000154D C3                      	retn
 15277                                  ldDone:
 15278 0000154E 833E[0C8B]00            	cmp	word [FileCnt],0
 15279                                  	;je	short ld2		; no files found, just return
 15280                                  	; 25/04/2023
 15281 00001553 7404                    	jz	short ldRet
 15282 00001555 E8CF03                  	call	DisplayTrailer		; display trailing info
 15283                                  ld2:	
 15284 00001558 F8                      	clc				; return success
 15285                                  ldRet:
 15286 00001559 C3                      	retn
 15287                                  
 15288                                  
 15289                                  ; ---------------------------------------------------------------------------
 15290                                  
 15291                                  ;***	LoadEntries - attempt to load entries from current directory
 15292                                  ;
 15293                                  ;	Load all qualifying directory entries from the current directory
 15294                                  ;	into the TPA. If an error is returned by FindFirst/FindNext calls
 15295                                  ;	other than 'no more files', return to caller with carry flag set.
 15296                                  ;	If we run out of buffer space, display a message that we haven't
 15297                                  ;	enough memory to sort this directory, but return without error.
 15298                                  ;	Other routines know whether or not entries have been loaded by
 15299                                  ;	the 'inmem' flag bit, which we set here.
 15300                                  ;
 15301                                  ;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
 15302                                  ;	this allows sorting over 3000 entries in a directory.
 15303                                  ;
 15304                                  ;	ENTRY	Tpa = buffer seg addr
 15305                                  ;		BytCnt = buffer length, in bytes
 15306                                  ;		Current directory (on selected drive) is the one to load
 15307                                  ;		FCB contains drive # and filespec
 15308                                  ;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
 15309                                  ;
 15310                                  ;	EXIT	CY = set if error
 15311                                  ;		If error, DOS Get Extended Error will get error info
 15312                                  ;
 15313                                  ;	USED	AX,CX,DX,SI,DI
 15314                                  ;
 15315                                  ;	EFFECTS
 15316                                  ;
 15317                                  ;	  Inmem bit of Bits = set if load succeeded.
 15318                                  ;	  Tpa buffer contains directory entries.
 15319                                  ;	  Byte after last entry = 0FFh.
 15320                                  
 15321                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15322                                  LoadEntries:
 15323 0000155A 06                      	push	es			; save TRANGROUP seg addr
 15324 0000155B 8E06[E28A]              	mov	es,[TPA]		; ES = TPA seg addr
 15325 0000155F 31FF                    	xor	di,di			; ES:DI = destination ptr
 15326                                  	;;;and	Bits,not mask inmem	; signal entries not loaded
 15327                                  	;;and	word [_Bits],0FFDFh
 15328                                  	;and	byte [_Bits],0DFh	; not 20h
 15329 00001561 8026[3B8C]DF            	and	byte [_Bits],~mask.inmem ; ~20h
 15330                                  
 15331 00001566 E877FF                  	call	GetFirst		; look for first file
 15332 00001569 7221                    	jc	short leRet		; return any error
 15333 0000156B E82000                  	call	LoadEntry		; load entry into TPA
 15334                                  leNext:
 15335 0000156E E886FF                  	call	GetNext			; get another file
 15336 00001571 720F                    	jc	short leLoaded		; assume any error is no more files
 15337 00001573 A1[018B]                	mov	ax,[BYTCNT]		; AX = size of TPA
 15338 00001576 29F8                    	sub	ax,di			; AX = bytes left in TPA
 15339                                  	;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
 15340 00001578 83F817                  	cmp	ax,23 ; 21+2 
 15341 0000157B 720E                    	jb	short leOk		; not enough memory left, give up
 15342 0000157D E80E00                  	call	LoadEntry		; load entry into TPA
 15343 00001580 EBEC                    	jmp	short leNext		; go get another file
 15344                                  
 15345                                  leLoaded:
 15346 00001582 26C605FF                	mov	byte [es:di],0FFh	; mark end of entry list
 15347                                  	;;;or	Bits,mask inmem		; signal entries loaded in memory
 15348                                  	;;or	word [_Bits],20h
 15349                                  	;or	byte [_Bits],20h
 15350 00001586 800E[3B8C]20            	or	byte [_Bits],mask.inmem
 15351                                  	; 25/04/2023
 15352                                  	; cf = 0
 15353                                  leOk:
 15354 0000158B F8                      	clc				; return no error
 15355                                  leRet:
 15356 0000158C 07                      	pop	es			; ES = TRANGROUP seg addr again
 15357 0000158D C3                      	retn
 15358                                  
 15359                                  
 15360                                  ; ---------------------------------------------------------------------------
 15361                                  
 15362                                  ;***	LoadEntry - load directory entry from DirBuf ext'd FCB
 15363                                  ;
 15364                                  ;	ENTRY	ES:DI = ptr to load point in TPA
 15365                                  ;		DirBuf contains extended FCB of entry to load
 15366                                  ;
 15367                                  ;	EXIT	ES:DI = ptr to next byte available in TPA
 15368                                  ;
 15369                                  ;	USED	AX,CX,SI
 15370                                  ;
 15371                                  ;	NOTES
 15372                                  ;
 15373                                  ;	  I could've used symbolic offsets and sizes of fields from
 15374                                  ;	   the dir_entry struc to do this, but this is time-critical,
 15375                                  ;	   so I hard-wired the structure of the DOS 4.x returned FCB,
 15376                                  ;	   as well as our private directory entry structure.
 15377                                  ;
 15378                                  ;	  We force a zero size for subdirectory files. A zero size is
 15379                                  ;	   ordinarily returned for subdirectories, but with Novell
 15380                                  ;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.
 15381                                  
 15382                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15383                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
 15384                                  LoadEntry:
 15385                                  	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
 15386 0000158E BE[F18B]                	mov	si,DIRBUF+8
 15387 00001591 30C0                    	xor	al,al				; AL = 0
 15388 00001593 AA                      	stosb					; 'used' byte = false
 15389 00001594 B90B00                  	mov	cx,11
 15390 00001597 F3A4                    	rep	movsb				; transfer filename & extension
 15391 00001599 AC                      	lodsb					; AL = attrib byte
 15392 0000159A AA                      	stosb					; store attrib byte
 15393                                  	;add	si,10 ; 22-11-1
 15394                                  	;add	si,dir_time-dir_attr-1		; skip to time field
 15395 0000159B 83C60A                  	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
 15396 0000159E A5                      	movsw					; transfer time
 15397 0000159F A5                      	movsw					; transfer date
 15398 000015A0 46                      	inc	si				; skip alloc unit
 15399 000015A1 46                      	inc	si
 15400                                  	;and	al,10h
 15401 000015A2 2410                    	and	al,ATTR_DIRECTORY
 15402 000015A4 7503                    	jnz	short leSetDirSize		; force zero size for subdir
 15403 000015A6 A5                      	movsw
 15404 000015A7 A5                      	movsw					; transfer size
 15405 000015A8 C3                      	retn
 15406                                  leSetDirSize:
 15407 000015A9 31C0                    	xor	ax,ax ; 0
 15408 000015AB AB                      	stosw
 15409 000015AC AB                      	stosw					; store zero size
 15410 000015AD C3                      	retn
 15411                                  
 15412                                  ; ---------------------------------------------------------------------------
 15413                                  
 15414                                  ;***	NoOrder - turn sorting off
 15415                                  ;
 15416                                  ;	ENTRY	nothing
 15417                                  ;
 15418                                  ;	EXIT	CY clear
 15419                                  ;
 15420                                  ;	USED	AX
 15421                                  ;
 15422                                  ;	EFFECTS
 15423                                  ;
 15424                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15425                                  
 15426                                  	; 19/02/2023
 15427                                  NoOrder:
 15428 000015AE C606[EC8C]00            	mov	byte [DestBuf],0
 15429                                  				; no sort
 15430 000015B3 F8                      	clc			; no error
 15431 000015B4 C3                      	retn
 15432                                  
 15433                                  ; ---------------------------------------------------------------------------
 15434                                  
 15435                                  ;***	OnOffSw - record occurence of on/off option switch
 15436                                  ;
 15437                                  ;	ENTRY	DI = index into word list of switches
 15438                                  ;
 15439                                  ;	EXIT	CY clear
 15440                                  ;
 15441                                  ;	USED	AX,CX
 15442                                  ;
 15443                                  ;	EFFECTS
 15444                                  ;
 15445                                  ;	  Bits modified to indicate option state.
 15446                                  
 15447                                  	; 19/02/2023
 15448                                  OnOffSw:
 15449 000015B5 89F9                    	mov	cx,di		; CX = index into word list of options
 15450 000015B7 D1E9                    	shr	cx,1
 15451 000015B9 D1E9                    	shr	cx,1		; CX = bit position of option
 15452 000015BB B80100                  	mov	ax,1		
 15453 000015BE D3E0                    	shl	ax,cl		; AX = bit mask of option
 15454 000015C0 F7C70200                	test	di,2		; check if it is a negated option
 15455 000015C4 7405                    	jz	short oo1	; it's negated
 15456                                  	;or	Bits,ax		; turn option on
 15457 000015C6 0906[3B8C]              	or	[_Bits],ax
 15458                                  	;jmp	short ooRet
 15459                                  	; 19/02/2023
 15460                                  	;cf=0
 15461 000015CA C3                      	retn
 15462                                  oo1:	
 15463 000015CB F7D0                    	not	ax		; AX = complemented bit mask of option
 15464                                  	;and	Bits,ax		; turn option off
 15465 000015CD 2106[3B8C]              	and	[_Bits],ax
 15466                                  ooRet:
 15467                                  	; 19/02/2023
 15468                                  	;cf=0
 15469                                  	;clc			; always return success
 15470 000015D1 C3                      	retn
 15471                                  
 15472                                  ; ---------------------------------------------------------------------------
 15473                                  
 15474                                  ;***	ParseAttr - parse and record /A option
 15475                                  ;
 15476                                  ;	ENTRY	BX = ptr to system parser result buffer for /A occurence
 15477                                  ;
 15478                                  ;	EXIT	CY = set if error occurs parsing attribute conditions
 15479                                  ;
 15480                                  ;		For parse error, we set up for Std_EPrintf call:
 15481                                  ;		AX = parse error code, like system parser
 15482                                  ;		DX = ptr to message block
 15483                                  ;
 15484                                  ;	USED	AX,CX,DX,DI
 15485                                  ;
 15486                                  ;	EFFECTS
 15487                                  ;
 15488                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 15489                                  ;	  If parse error occurs, attribute conditions parsed so far hold.
 15490                                  ;
 15491                                  ;	  For parse error, we set up for Std_EPrintf call:
 15492                                  ;	  Msg_Disp_Class = parse error message class
 15493                                  ;	  Message block (see DX) is set up for parse error message
 15494                                  
 15495                                  	; 19/02/2023
 15496                                  ParseAttr:
 15497 000015D2 56                      	push	si			; save SI
 15498 000015D3 C606[438C]00            	mov	byte [AttrSpecified],0	; cancel all attribute conditions
 15499                                  
 15500                                  ;	Each /A invocation starts by assuming all files are to be listed.
 15501                                  
 15502                                  	;;mov	si,word ptr [bx].ValuePtr
 15503                                  					; SI = ptr to string after /A
 15504                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15505 000015D8 8B7704                  	mov	si,[bx+4]
 15506                                  paLoop:	
 15507 000015DB BA0100                  	mov	dx,1			; DX = 1 (for un-negated attribute)
 15508 000015DE AC                      	lodsb				; AL = next char in string
 15509 000015DF 08C0                    	or	al,al
 15510                                  	;jz	short paOk		; it's terminating null, we're done
 15511                                  	; 19/02/2023
 15512 000015E1 742F                    	jz	short paRet ; cf=0
 15513 000015E3 3C2D                    	cmp	al,'-'
 15514 000015E5 7502                    	jne	short pa1		; not '-', go look for letter
 15515 000015E7 4A                      	dec	dx			; DX = 0 (for negated attribute)
 15516 000015E8 AC                      	lodsb				; AL = next char
 15517                                  pa1:	
 15518                                  	;mov	di,offset TRANGROUP:AttrLtrs 
 15519                                  					; DI = ptr to attrib letter list
 15520 000015E9 BF[B184]                	mov	di,AttrLtrs ; "RHSvDA"
 15521                                  	;mov	cx,6
 15522 000015EC B90600                  	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
 15523 000015EF F2AE                    	repne	scasb			; look for our letter in the list
 15524 000015F1 751B                    	jne	short paErr		; not found, return error
 15525                                  
 15526 000015F3 F7D1                    	not	cx
 15527                                  	;add	cx,6
 15528 000015F5 83C106                  	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5
 15529                                  
 15530                                  ;	Note that we rely on AttrLtrs to be in the attribute bit order,
 15531                                  ;	starting from bit 0.
 15532                                  
 15533                                  ;	Record this attribute bit in AttrSpecified.
 15534                                  
 15535 000015F8 B001                    	mov	al,1
 15536 000015FA D2E0                    	shl	al,cl			; AL = mask for our bit
 15537 000015FC 0806[438C]              	or	[AttrSpecified],al	; set it in the 'specified' mask
 15538                                  
 15539                                  ;	Record the selected state for this attribute in AttrSelect.
 15540                                  ;	DX = 0 or 1, the selected state for this attribute.
 15541                                  
 15542 00001600 F6D0                    	not	al			; AL = mask for all other bits
 15543 00001602 2006[448C]              	and	[AttrSelect],al		; clear our bit
 15544 00001606 D2E2                    	shl	dl,cl			; DL = our bit state in position
 15545 00001608 0816[448C]              	or	[AttrSelect],dl		; set selected attr state
 15546 0000160C EBCD                    	jmp	short paLoop		; go look at next char
 15547                                  
 15548                                  ;	The attribute letter string is invalid.
 15549                                  
 15550                                  paErr:	
 15551 0000160E E87703                  	call	SetupParamError		; set message up for Std_EPrintf
 15552 00001611 F9                      	stc		   		; return error
 15553                                  	; 19/02/2023
 15554                                  	;jmp	short paRet
 15555                                  ;paOk:
 15556                                  	;clc				; return success		
 15557                                  paRet:	
 15558 00001612 5E                      	pop	si			; restore SI
 15559 00001613 C3                      	retn
 15560                                  
 15561                                  ; ---------------------------------------------------------------------------
 15562                                  
 15563                                  ;***	ParseLine - parse a line of text
 15564                                  ;
 15565                                  ;	Parse text until an EOL (CR or NUL) is found, or until a parse
 15566                                  ;	error occurs.
 15567                                  ;
 15568                                  ;	ENTRY	DS:SI = ptr to text
 15569                                  ;		CS, DS, ES = TRANGROUP seg addr
 15570                                  ;
 15571                                  ;	EXIT	AX = last return code from system parser
 15572                                  ;		CX = # positional parameters (pathnames) found - 0 or 1
 15573                                  ;
 15574                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15575                                  ;		DX = ptr to message block
 15576                                  ;
 15577                                  ;	USED	BX,CX,DX,SI,DI
 15578                                  ;
 15579                                  ;	EFFECTS
 15580                                  ;
 15581                                  ;	  Bits may contain new option settings.
 15582                                  ;	  DestBuf may contain new series of sort codes.
 15583                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15584                                  ;	  SrcBuf may contain a new default pathname/filespec.
 15585                                  ;	  PathPos, PathCnt updated for new pathname.
 15586                                  ;
 15587                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15588                                  ;	  Msg_Disp_Class = parse error class
 15589                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15590                                  ;	  Message block (see DX) is set up for parse error message
 15591                                  
 15592                                  	; 19/02/2023
 15593                                  Parse_Line:
 15594                                  	; 04/05/2023
 15595 00001614 BF[7E85]                	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
 15596 00001617 31C9                    	xor	cx,cx			; CX = # positionals found
 15597                                  plPars:
 15598 00001619 E8C20B                  	call	Parse_With_Msg		; call parser
 15599 0000161C 83F8FF                  	cmp	ax,-1
 15600                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
 15601 0000161F 7411                    	je	short plRet		; EOL encountered, return
 15602 00001621 83F800                  	cmp	ax,RESULT_NO_ERROR ; 0
 15603 00001624 750C                    	jne	short plRet		; parse error occurred, return
 15604                                  
 15605                                  ;	Parse call succeeded. We have a filespec or a switch.
 15606                                  ;	DX = ptr to result buffer
 15607                                  
 15608 00001626 89D3                    	mov	bx,dx			; BX = ptr to parse result buffer
 15609 00001628 803F05                  	cmp	byte [bx],RESULT_FILESPEC ; 5
 15610 0000162B 7406                    	je	short plFil		; we have a filespec
 15611                                  
 15612 0000162D E85B00                  	call	ParseSwitch		; else we have a switch
 15613                                  	;jc	short plRet		; error parsing switch, return
 15614                                  	;jmp	short plPars		; parse more
 15615                                  	; 19/02/2023
 15616 00001630 73E7                    	jnc	short plPars
 15617                                  plRet:
 15618 00001632 C3                      	retn	
 15619                                  plFil:	
 15620 00001633 E8B200                  	call	CopyPathname		; copy pathname into our buffer
 15621 00001636 EBE1                    	jmp	short plPars		; parse more
 15622                                  ;plRet:
 15623                                  ;	retn
 15624                                  
 15625                                  ; ---------------------------------------------------------------------------
 15626                                  
 15627                                  ;***	ParseOrder - parse and record /O option
 15628                                  ;
 15629                                  ;	ENTRY	BX = ptr to system parser result buffer for /O occurence
 15630                                  ;
 15631                                  ;	EXIT	CY = set if error occurs parsing order
 15632                                  ;
 15633                                  ;		For parse error, we set up for Std_EPrintf call:
 15634                                  ;		AX = parse error code, like system parser
 15635                                  ;		DX = ptr to message block
 15636                                  ;
 15637                                  ;	USED	AX,CX,DX,DI
 15638                                  ;
 15639                                  ;	EFFECTS
 15640                                  ;
 15641                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15642                                  ;
 15643                                  ;	  For parse error, we set up for Std_EPrintf call:
 15644                                  ;	  Msg_Disp_Class = parse error message class
 15645                                  ;	  Message block (see DX) is set up for parse error message
 15646                                  
 15647                                  	; 19/02/2023
 15648                                  ParseOrder:
 15649 00001638 56                      	push	si			; save SI
 15650 00001639 53                      	push	bx			; save ptr to result buffer
 15651                                  
 15652                                  	;;mov	si,word ptr [bx].ValuePtr
 15653                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15654 0000163A 8B7704                  	mov	si,[bx+4]		; SI = ptr to order letters
 15655                                  	;mov	bx,offset TRANGROUP:DestBuf
 15656 0000163D 8B1E[EC8C]              	mov	bx,[DestBuf]		; BX = ptr to sort code buffer
 15657 00001641 8A04                    	mov	al,[si]			; AL = 1st char of order string
 15658 00001643 08C0                    	or	al,al
 15659 00001645 750E                    	jnz	short poLtr		; not NUL, go parse letters
 15660                                  
 15661                                  ;	We have /O alone. Set standard sort order.
 15662                                  ;	Note hardwired dependency on character order in OrderLtrs.
 15663                                  
 15664 00001647 C60705                  	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
 15665 0000164A 43                      	inc	bx
 15666 0000164B C60701                  	mov	byte [bx],1		; then by name
 15667 0000164E 43                      	inc	bx
 15668 0000164F C60702                  	mov	byte [bx],2		; then by extension
 15669 00001652 43                      	inc	bx
 15670 00001653 EB30                    	jmp	short poOk		; return success
 15671                                  
 15672                                  ;	We have /O<something>. Parse sort order letters.
 15673                                  
 15674                                  poLtr:	
 15675 00001655 30D2                    	xor	dl,dl			; DL = 0 (upward sort)
 15676 00001657 AC                      	lodsb				; AL = next sort order letter
 15677 00001658 08C0                    	or	al,al
 15678 0000165A 7429                    	jz	short poOk		; NUL found, return success
 15679                                  
 15680 0000165C 3C2D                    	cmp	al,'-'
 15681 0000165E 7503                    	jne	short po1		; not '-', go look for letter
 15682 00001660 B280                    	mov	dl,80h			; DL = downward sort mask
 15683 00001662 AC                      	lodsb				; AL = next char
 15684                                  po1:
 15685                                  	;mov	di,offset TRANGROUP:OrderLtrs
 15686 00001663 8B3E[B784]              	mov	di,[OrderLtrs] ;"NEDSG" ; DI = ptr to list of letters
 15687 00001667 B90500                  	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
 15688 0000166A F2AE                    	repne	scasb			; look for our letter in the list
 15689 0000166C 7510                    	jne	short poErr		; not found, return error
 15690                                  
 15691 0000166E F7D9                    	neg	cx
 15692 00001670 83C105                  	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6
 15693                                  
 15694 00001673 08D1                    	or	cl,dl			; CL = sort code with up/dn bit
 15695 00001675 880F                    	mov	[bx],cl			; store sort order code in buffer
 15696 00001677 43                      	inc	bx			; BX = ptr to next spot in buffer
 15697                                  	;cmp	bx,offset TRANGROUP:EndDestBuf
 15698 00001678 81FB[438D]              	cmp	bx,EndDestBuf
 15699                                  	;jae	short poErr		; too many letters
 15700                                  	;
 15701                                  	;jmp	short poLtr		; go look at next char
 15702                                  	; 19/02/2023
 15703 0000167C 72D7                    	jb	short poLtr
 15704                                  
 15705                                  ;	The sort order string is invalid.  
 15706                                  
 15707                                  poErr:
 15708 0000167E 5B                      	pop	bx			; BX = ptr to result buffer
 15709 0000167F E80603                  	call	SetupParamError		; set message up for Std_EPrintf
 15710 00001682 F9                      	stc				; return failure
 15711 00001683 EB04                    	jmp	short poRet
 15712                                  poOk:	
 15713 00001685 C60700                  	mov	byte [bx],0		; mark end of sort code list
 15714 00001688 5B                      	pop	bx			; BX = ptr to result buffer
 15715                                  	; 19/02/2023
 15716                                  	;cf=0
 15717                                  	;clc				; return success
 15718                                  poRet:
 15719 00001689 5E                      	pop	si			; restore SI
 15720 0000168A C3                      	retn
 15721                                  
 15722                                  ; ---------------------------------------------------------------------------
 15723                                  
 15724                                  ;***	ParseSwitch - parse a switch
 15725                                  ;
 15726                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 15727                                  ;		     a switch
 15728                                  ;
 15729                                  ;	EXIT	CY = set if parse error occurred
 15730                                  ;
 15731                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15732                                  ;		AX = parse error code, like system parser
 15733                                  ;		DX = ptr to message block
 15734                                  ;
 15735                                  ;	USED	AX,BX,DX
 15736                                  ;
 15737                                  ;	EFFECTS
 15738                                  ;
 15739                                  ;	  Bits may contain new option settings.
 15740                                  ;	  DestBuf may contain new series of sort codes.
 15741                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15742                                  ;
 15743                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15744                                  ;	  Msg_Disp_Class = parse error class
 15745                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15746                                  ;	  Message block (see DX) is set up for parse error message
 15747                                  
 15748                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15749                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
 15750                                  ParseSwitch:
 15751 0000168B 51                      	push	cx			; save CX
 15752 0000168C 57                      	push	di			; save DI
 15753                                  
 15754                                  	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
 15755                                  	;mov	ax,[bx+ResultBuffer.SynPtr]
 15756 0000168D 8B4702                  	mov	ax,[bx+2]
 15757                                  	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
 15758 00001690 BF[CE85]                	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
 15759 00001693 B90E00                  	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
 15760 00001696 FC                      	cld				; scan direction = upward
 15761 00001697 F2AF                    	repne	scasw			; locate synonym ptr in list
 15762                                  	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
 15763 00001699 81EF[D085]              	sub	di,Dir_Sw_Ptrs+2
 15764                                  
 15765                                  ;	DI = index into word list of synonym ptrs
 15766                                  
 15767 0000169D 2EFF95[A516]            	call	word [cs:di+SwHandler]	; use same index into call table
 15768                                  
 15769 000016A2 5F                      	pop	di			; restore DI
 15770 000016A3 59                      	pop	cx			; restore CX
 15771                                  
 15772 000016A4 C3                      	retn
 15773                                  
 15774                                  ; ---------------------------------------------------------------------------
 15775                                  
 15776                                  ;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
 15777                                  ;	Simple on/off switches must occur first in both lists, and must be
 15778                                  ;	  in order of option bits in Bits, starting with bit 0.
 15779                                  
 15780                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15781                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh
 15782                                  
 15783                                  SwHandler:
 15784 000016A5 [B515]                  	dw	OnOffSw		; /-W
 15785 000016A7 [B515]                  	dw	OnOffSw		; /W
 15786 000016A9 [B515]                  	dw	OnOffSw		; /-P
 15787 000016AB [B515]                  	dw	OnOffSw		; /P
 15788 000016AD [B515]                  	dw	OnOffSw		; /-S
 15789 000016AF [B515]                  	dw	OnOffSw		; /S
 15790 000016B1 [B515]                  	dw	OnOffSw		; /-B
 15791 000016B3 [B515]                  	dw	OnOffSw		; /B
 15792 000016B5 [B515]                  	dw	OnOffSw		; /-L	;M010
 15793 000016B7 [B515]                  	dw	OnOffSw		; /L	;M010
 15794 000016B9 [AE15]                  	dw	NoOrder		; /-O
 15795 000016BB [3816]                  	dw	ParseOrder	; /O
 15796 000016BD [8213]                  	dw	DefaultAttr	; /-A
 15797 000016BF [D215]                  	dw	ParseAttr	; /A
 15798                                  
 15799                                  ; ---------------------------------------------------------------------------
 15800                                  
 15801                                  	;break	<DIR utility routines>
 15802                                  
 15803                                  ;***	UTILITY ROUTINES
 15804                                  ; ---------------------- 
 15805                                  
 15806                                  ; ---------------------------------------------------------------------------
 15807                                  
 15808                                  ;***	ChangeDir - change directory on target drive
 15809                                  ;
 15810                                  ;	ENTRY	FCB contains drive #
 15811                                  ;		DS:DX = ptr to ASCIIZ string w/o drive specifier
 15812                                  ;
 15813                                  ;	EXIT	Changed current directory on drive
 15814                                  ;
 15815                                  ;		If error,
 15816                                  ;		CY = set
 15817                                  ;		DOS Get Extended Error call will get error
 15818                                  ;
 15819                                  ;	USED	AX,DX,SI,DI
 15820                                  ;
 15821                                  ;	EFFECTS
 15822                                  ;
 15823                                  ;	  DirBuf is used to build "d:string".
 15824                                  
 15825                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15826                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h
 15827                                  
 15828                                  ChangeDir:
 15829                                  	;mov	di,offset TRANGROUP:DirBuf
 15830 000016C1 BF[E98B]                	mov	di,DIRBUF
 15831 000016C4 E8B002                  	call	GetDriveLtr	; AX = "d:"
 15832 000016C7 AB                      	stosw			; put drive specifier in buffer
 15833 000016C8 89D6                    	mov	si,dx		; SI = ptr to argument string
 15834                                  cdLoop:
 15835 000016CA AC                      	lodsb
 15836 000016CB AA                      	stosb			; move byte to buffer
 15837 000016CC 08C0                    	or	al,al
 15838 000016CE 75FA                    	jne	short cdLoop	; continue until null transferred
 15839                                  
 15840                                  	;mov	dx,offset TRANGROUP:DirBuf
 15841 000016D0 BA[E98B]                	mov	dx,DIRBUF	; DX = ptr to "d:string"
 15842                                  	;mov	ah,CHDir
 15843 000016D3 B43B                    	mov	ah,3Bh
 15844 000016D5 CD21                    	int	21h		; change directory
 15845 000016D7 C3                      	retn			; return what CHDIR returns
 15846                                  
 15847                                  ; ---------------------------------------------------------------------------
 15848                                  
 15849                                  ;***	CmpAscz - compare two ASCIIZ strings alphanumerically
 15850                                  ;
 15851                                  ;	ENTRY	DS:SI = ptr to one ASCIIZ string
 15852                                  ;		ES:DI = ptr to another ASCIIZ string
 15853                                  ;
 15854                                  ;	EXIT	flags set after REPE CMPSB
 15855                                  ;
 15856                                  ;	USED	AL,CX,SI,DI
 15857                                  ;
 15858                                  ;	NOTES
 15859                                  ;
 15860                                  ;	Maximum run of comparison is length of DS:SI string.
 15861                                  ;	This ensures that two identical strings followed by
 15862                                  ;	random characters will compare correctly.
 15863                                  
 15864                                  	; 19/02/2023
 15865                                  CmpAscz:
 15866 000016D8 57                      	push	di
 15867                                  
 15868 000016D9 89F7                    	mov	di,si
 15869 000016DB 30C0                    	xor	al,al
 15870 000016DD B9FFFF                  	mov	cx,0FFFFh
 15871 000016E0 F2AE                    	repne	scasb
 15872 000016E2 F7D1                    	not	cx
 15873                                  
 15874 000016E4 5F                      	pop	di
 15875 000016E5 F3A6                    	repe	cmpsb
 15876 000016E7 C3                      	retn
 15877                                  
 15878                                  ; ---------------------------------------------------------------------------
 15879                                  
 15880                                  ;***	CopyPathname - copy pathname to our buffer
 15881                                  ;
 15882                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 15883                                  ;		     a filespec
 15884                                  ;
 15885                                  ;	EXIT	nothing
 15886                                  ;
 15887                                  ;	USED	AX
 15888                                  ;
 15889                                  ;	EFFECTS
 15890                                  ;
 15891                                  ;	  SrcBuf may contain a new pathname/filespec.
 15892                                  ;	  PathPos, PathCnt updated for new pathname.
 15893                                  
 15894                                  	; 19/02/2023
 15895                                  CopyPathname:
 15896 000016E8 56                      	push	si
 15897                                  	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
 15898                                  	;lds	si,[bx+ResultBuffer.ValuePtr]
 15899 000016E9 C57704                  	lds	si,[bx+4]
 15900                                  	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
 15901 000016EC E8E715                  	call	Move_To_SrcBuf
 15902 000016EF 5E                      	pop	si
 15903 000016F0 C3                      	retn
 15904                                  
 15905                                  ; ---------------------------------------------------------------------------
 15906                                  
 15907                                  ;***	CountFile - update counters with current file
 15908                                  ;
 15909                                  ;	ENTRY	BX = offset of entry in TPA buffer
 15910                                  ;
 15911                                  ;	EXIT	nothing
 15912                                  ;
 15913                                  ;	USED	AX,DX
 15914                                  ;
 15915                                  ;	EFFECTS
 15916                                  ;
 15917                                  ;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 15918                                  
 15919                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15920                                  CountFile:
 15921 000016F1 06                      	push	es			; save TRANGROUP seg addr
 15922 000016F2 8E06[E28A]              	mov	es,[TPA]		; ES = TPA seg addr
 15923                                  
 15924 000016F6 FF06[0C8B]              	inc	word [FileCnt]		; # files this directory
 15925 000016FA FF06[128B]              	inc	word [FileCntTotal]	; # files total
 15926 000016FE 7504                    	jnz	short cntf1
 15927 00001700 FF06[148B]              	inc	word [FileCntTotal+2]
 15928                                  cntf1:
 15929                                  	;mov	ax,word ptr es:[bx].filesize
 15930                                  					; AX = low word of file size
 15931                                  	;mov	dx,word ptr es:[bx].filesize+2
 15932                                  					; DX = high word of file size
 15933 00001704 268B4711                	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
 15934 00001708 268B5713                	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
 15935 0000170C 0106[0E8B]              	add	[FileSiz],ax
 15936 00001710 1116[108B]              	adc	[FileSiz+2],dx		; size of this directory
 15937 00001714 0106[168B]              	add	[FileSizTotal],ax
 15938 00001718 1116[188B]              	adc	[FileSizTotal+2],dx	; total size of files listed
 15939                                  
 15940 0000171C 07                      	pop	es			; ES = TRANGROUP seg addr again
 15941                                  dbRet:	; 19/02/2023
 15942 0000171D C3                      	retn
 15943                                  
 15944                                  ; ---------------------------------------------------------------------------
 15945                                  
 15946                                  ;***	DisplayBare - display filename in bare format
 15947                                  ;
 15948                                  ;	ENTRY	BX = offset of entry in TPA buffer
 15949                                  ;
 15950                                  ;	EXIT	DX = # char's displayed, including dot
 15951                                  ;
 15952                                  ;	USED	AX,CX,SI,DI
 15953                                  ;
 15954                                  ;	EFFECTS
 15955                                  ;
 15956                                  ;	  Filename is displayed in name.ext format, followed by cr/lf.
 15957                                  ;	  If /s is on, complete pathname is displayed.
 15958                                  ;
 15959                                  ;	NOTE
 15960                                  ;
 15961                                  ;	  Directory pseudofiles . and .. and suppressed in bare listing.
 15962                                  
 15963                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15964                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h
 15965                                  
 15966                                  DisplayBare:
 15967                                  ;	Suppress . and .. files from bare listing.
 15968                                  
 15969 0000171E 8CD9                    	mov	cx,ds			; CX = saved TRANGROUP seg addr
 15970 00001720 8E1E[E28A]              	mov	ds,[TPA]		; DS:BX = ptr to file entry
 15971                                  	;assume	ds:NOTHING
 15972                                  	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
 15973 00001724 807F012E                	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
 15974 00001728 8ED9                    	mov	ds,cx			; DS = TRANGROUP seg addr again
 15975                                  	;assume	ds:TRANGROUP
 15976 0000172A 74F1                    	je	short dbRet		; it's . or .. - don't display
 15977                                  
 15978                                  	;;;test	Bits,mask subd
 15979                                  	;;test	word [_Bits],4
 15980                                  	;test	byte [_Bits],4
 15981 0000172C F606[3B8C]04            	test	byte [_Bits],mask.subd
 15982 00001731 7431                    	jz	short dbNameExt		; not /s - display filename only
 15983                                  
 15984                                  	;invoke	Build_Dir_String
 15985 00001733 E83007                  	call	build_dir_string
 15986                                  	;mov	di,offset TRANGROUP:BwdBuf
 15987 00001736 BF[E98B]                	mov	di,BWDBUF		; ES:DI = ptr to dir string
 15988                                     
 15989                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 15990                                  	;;test	word [_Bits],10h
 15991                                  	;test	byte [_Bits],10h
 15992 00001739 F606[3B8C]10            	test	byte [_Bits],mask.lcase
 15993                                  	;jz	@F			;M010;lowercase not needed
 15994 0000173E 7405                    	jz	short dbare1
 15995 00001740 89FE                    	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
 15996 00001742 E88402                  	call	LowercaseString		;M010;path string is in BwdBuf
 15997                                  dbare1:
 15998                                  ;@@:	
 15999                                  	;xor	al,al			; AL = 0
 16000                                  	; 19/02/2023
 16001 00001745 31C0                    	xor	ax,ax
 16002 00001747 B9FFFF                  	mov	cx,0FFFFh
 16003 0000174A FC                      	cld
 16004 0000174B F2AE                    	repne	scasb			; ES:DI = ptr to byte after null
 16005 0000174D 4F                      	dec	di			; ES:DI = ptr to null byte
 16006                                  
 16007 0000174E 26807DFF5C              	cmp	byte [es:di-1],'\'
 16008                                  	;je	@F
 16009 00001753 7403                    	je	short dbare2		; already terminated w/ '\'
 16010                                  
 16011                                  	;mov	ax,'\'			; AX = '\',0
 16012 00001755 B05C                    	mov	al,'\'
 16013 00001757 AB                      	stosw				; add to dir string
 16014                                  ;@@:
 16015                                  dbare2:
 16016                                  	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
 16017 00001758 C706[D08C][E98B]        	mov	word [string_ptr_2],BWDBUF
 16018                                  	;mov	dx,offset TRANGROUP:String_Buf_Ptr
 16019 0000175E BA[3C81]                	mov	dx,string_buf_ptr
 16020                                  	;invoke	Std_Printf		; display device & directory path
 16021 00001761 E8DF36                  	call	std_printf
 16022                                  dbNameExt:
 16023 00001764 E82D00                  	call	DisplayDotForm		; display name.ext
 16024                                  	;invoke	CrLf2			; display cr/lf
 16025 00001767 E88F0E                  	call	CRLF2
 16026                                  	; 19/02/2023
 16027                                  	;call	UseLine			;M007;Allow /p with /b
 16028                                  ;dbRet:
 16029                                  	;retn
 16030                                  
 16031                                  	; 19/02/2023
 16032                                  	;jmp	short UseLine
 16033                                  
 16034                                  ; ---------------------------------------------------------------------------
 16035                                  
 16036                                  ;***	UseLine - use a display line, start a new page if none left
 16037                                  ;
 16038                                  ;	ENTRY	nothing
 16039                                  ;
 16040                                  ;	EXIT	nothing
 16041                                  ;
 16042                                  ;	USED	flags
 16043                                  
 16044                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16045                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
 16046                                  UseLine:
 16047 0000176A FF0E[0A8B]              	dec	word [LeftOnPage]
 16048 0000176E 833E[0A8B]02            	cmp	word [LeftOnPage],2
 16049 00001773 771E                    	ja	short ulRet
 16050                                  	; 19/02/2023
 16051                                  	;call	EndPage
 16052                                  ;ulRet:
 16053                                  	;retn
 16054                                  
 16055                                  	; 19/02/2023
 16056                                  	;jmp	short EndPage
 16057                                  
 16058                                  ; ---------------------------------------------------------------------------
 16059                                  
 16060                                  ;***	EndPage - end the current display page
 16061                                  ;
 16062                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16063                                  ;		Current directory (on selected drive) is the one being listed
 16064                                  ;		Bits contains /p setting
 16065                                  ;
 16066                                  ;	EXIT	LeftOnPage = # lines left for next page
 16067                                  ;
 16068                                  ;	USED	AX,DX
 16069                                  ;
 16070                                  ;	EFFECTS
 16071                                  ;
 16072                                  ;	  Pause is invoked to display a message and wait for a keystroke.
 16073                                  ;	  BwdBuf (same as DirBuf) used to build directory string.
 16074                                  
 16075                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16076                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h
 16077                                  
 16078                                  EndPage:
 16079                                  	;;;test	Bits,mask pagd
 16080                                  	;;test	word [_Bits],2
 16081                                  	;test	byte [_Bits],2
 16082 00001775 F606[3B8C]02            	test	byte [_Bits],mask.pagd
 16083 0000177A 7410                    	jz	short epNew		; paged display isn't enabled
 16084                                  
 16085 0000177C 53                      	push	bx			; save BX
 16086 0000177D 51                      	push	cx			; save CX
 16087                                  
 16088                                  	;invoke	Pause			; "Press any key to continue..."
 16089 0000177E E85902                  	call	PAUSE
 16090                                  
 16091                                  	;invoke	Build_Dir_String
 16092 00001781 E8E206                  	call	build_dir_string
 16093                                  	;mov	dx,offset TRANGROUP:DirCont_Ptr
 16094 00001784 BA[B781]                	mov	dx,dircont_ptr
 16095                                  	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
 16096 00001787 E8AB36                  	call	Printf_Crlf
 16097                                  
 16098 0000178A 59                      	pop	cx			; restore CX
 16099 0000178B 5B                      	pop	bx			; restore BX
 16100                                  epNew:	
 16101 0000178C A1[368E]                	mov	ax,[LinPerPag]		; AX = # lines per page
 16102 0000178F 48                      	dec	ax			; AX = # lines till next EndPage
 16103 00001790 A3[0A8B]                	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
 16104                                  ulRet:	
 16105                                  	; 19/02/2023
 16106 00001793 C3                      	retn
 16107                                  
 16108                                  ; ---------------------------------------------------------------------------
 16109                                  
 16110                                  ;***	DisplayDotForm - display filename in compressed dot format
 16111                                  ;
 16112                                  ;	Display name.ext, with no cr/lf's. Dot is displayed only
 16113                                  ;	if the filename has a nonblank extension.
 16114                                  ;
 16115                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16116                                  ;
 16117                                  ;	EXIT	DX = # char's displayed, including dot
 16118                                  ;
 16119                                  ;	USED	AX,CX,SI,DI
 16120                                  ;
 16121                                  ;	EFFECTS
 16122                                  ;
 16123                                  ;	  Filename is displayed in name.ext format.
 16124                                  ;
 16125                                  ;	NOTE
 16126                                  ;
 16127                                  ;	  We allow for bogus filenames that have blanks embedded
 16128                                  ;	  in the name or extension.
 16129                                  
 16130                                  ;	Bugbug:	might be a good performance gain if we buffered
 16131                                  ;	up the output and used DOS function 9.
 16132                                  
 16133                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16134                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h
 16135                                  
 16136                                  DisplayDotForm:
 16137 00001794 1E                      	push	ds			; save TRANGROUP seg addr
 16138 00001795 06                      	push	es			; save ES
 16139 00001796 2EA1[E28A]              	mov	ax,[cs:TPA]		; AX = TPA seg addr
 16140 0000179A 8ED8                    	mov	ds,ax			; DS:BX = ptr to entry
 16141                                  	;assume	ds:nothing
 16142 0000179C 8EC0                    	mov	es,ax			; ES:BX = ptr to entry
 16143                                  
 16144 0000179E 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 16145                                  	;;add	di,filename + size filename - 1
 16146 000017A0 83C708                  	add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
 16147                                  	;mov	cx,size filename	; CX = length of name field
 16148 000017A3 B90800                  	mov	cx,8
 16149 000017A6 B020                    	mov	al,' '
 16150 000017A8 FD                      	std				; scan down
 16151 000017A9 F3AE                    	repe	scasb			; scan for nonblank
 16152                                  
 16153                                  ;	Assume file name has at least one character.
 16154                                  
 16155 000017AB 41                      	inc	cx			; CX = # chars in name
 16156 000017AC 89CA                    	mov	dx,cx			; DX = # chars to be displayed
 16157                                  
 16158 000017AE 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16159                                  	;;add	si,filename		; DS:SI = ptr to name
 16160                                  	;add	si,1 
 16161                                  	;		; add si,EntryStruc.filename
 16162                                  	; 25/04/2023
 16163 000017B0 46                      	inc	si
 16164                                  NextNameChar:
 16165 000017B1 FC                      	cld
 16166 000017B2 AC                      	lodsb				; AL = next char
 16167                                  
 16168                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16169                                  	;;test	word [ss:_Bits],10h
 16170                                  	;test	byte [ss:_Bits],10h
 16171 000017B3 36F606[3B8C]10          	test	byte [ss:_Bits],mask.lcase
 16172                                  	;jz	short @F		;M010;lowercase not required
 16173 000017B9 7403                    	jz	short ddf1
 16174 000017BB E80002                  	call	LowerCase		;M010;filename char is in AL
 16175                                  ddf1:
 16176                                  ;@@:	
 16177                                  	;invoke	Print_Char		; display it
 16178 000017BE E85606                  	call	PRINT_CHAR
 16179 000017C1 E2EE                    	loop	NextNameChar
 16180                                  
 16181                                  ;	Now do extension.
 16182                                  
 16183 000017C3 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 16184                                  	;add	di,fileext + size fileext - 1
 16185 000017C5 83C70B                  	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
 16186                                  	;mov	cx,size fileext		; CX = length of ext field
 16187 000017C8 B90300                  	mov	cx,3
 16188 000017CB B020                    	mov	al,' '
 16189 000017CD FD                      	std				; scan down
 16190 000017CE F3AE                    	repe	scasb			; scan for nonblank
 16191 000017D0 7420                    	je	short ddDone		; no nonblank chars in ext
 16192                                  
 16193 000017D2 41                      	inc	cx			; CX = # chars in ext
 16194 000017D3 01CA                    	add	dx,cx			; DX = total # chars to be displayed
 16195 000017D5 42                      	inc	dx			;      including dot
 16196                                  
 16197 000017D6 B02E                    	mov	al,'.'
 16198 000017D8 E83C06                  	call	PRINT_CHAR
 16199 000017DB 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16200                                  	;add	si,fileext		; DS:SI = ptr to ext
 16201 000017DD 83C609                  	add	si,9
 16202                                  
 16203                                  NextExtChar:
 16204 000017E0 FC                      	cld
 16205 000017E1 AC                      	lodsb				; AL = next char
 16206                                  
 16207                                  	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
 16208                                  	;;test	word [cs:_Bits],10h
 16209                                  	;test	byte [cs:_Bits],10h
 16210 000017E2 2EF606[3B8C]10          	test	byte [cs:_Bits],mask.lcase
 16211                                  	;jz	short @F		;M010;lowercase not required
 16212 000017E8 7403                    	jz	short ddf2
 16213 000017EA E8D101                  	call	LowerCase		;M010;fileext char is in AL
 16214                                  ;@@:	
 16215                                  ddf2:
 16216                                  	;invoke	Print_Char		; display it
 16217 000017ED E82706                  	call	PRINT_CHAR
 16218 000017F0 E2EE                    	loop	NextExtChar
 16219                                  ddDone:
 16220 000017F2 07                      	pop	es			; restore ES
 16221 000017F3 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16222                                  	;assume	ds:TRANGROUP
 16223 000017F4 FC                      	cld				; leave direction flag = up
 16224 000017F5 C3                      	retn
 16225                                  
 16226                                  ; ---------------------------------------------------------------------------
 16227                                  
 16228                                  ;***	DisplayFile - display file entry, update counters
 16229                                  ;
 16230                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16231                                  ;		Bits contains /w, /p settings
 16232                                  ;
 16233                                  ;	EXIT	nothing
 16234                                  ;
 16235                                  ;	USED	AX,CX,DX,SI,DI,BP
 16236                                  ;
 16237                                  ;	EFFECTS
 16238                                  ;
 16239                                  ;	  Entry is displayed.  
 16240                                  ;	  If not /b,
 16241                                  ;	    Cursor is left at end of entry on screen.
 16242                                  ;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16243                                  ;	  If /b,
 16244                                  ;	    Cursor is left at beginning of next line.
 16245                                  ;	    Cnt's and Siz's aren't updated.
 16246                                  
 16247                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16248                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh
 16249                                  
 16250                                  DisplayFile:
 16251                                  	;;;test	Bits,mask bare
 16252                                  	;;test	word [_Bits],8
 16253                                  	;test	byte [_Bits],8
 16254 000017F6 F606[3B8C]08            	test	byte [_Bits],mask.bare
 16255 000017FB 7405                    	jz	short dfNorm		; not /b - do normal display
 16256                                  
 16257 000017FD E81EFF                  	call	DisplayBare		; display file in bare format
 16258 00001800 EB18                    	jmp	short dfRet
 16259                                  dfNorm:	
 16260 00001802 E87B00                  	call	DisplayNext		; pos'n cursor for next entry
 16261                                  	;;;test	Bits,mask wide
 16262                                  	;;test	word [_Bits],1
 16263                                  	;test	byte [_Bits],1
 16264 00001805 F606[3B8C]01            	test	byte [_Bits],mask.wide
 16265 0000180A 7405                    	jz	short dfFull		; full format
 16266 0000180C E83A01                  	call	DisplayWide		; wide format
 16267 0000180F EB06                    	jmp	short dfCnt
 16268                                  dfFull:	
 16269 00001811 E83400                  	call	DisplayName		; display filename & extension
 16270 00001814 E89000                  	call	DisplayTheRest		; display size, date, time
 16271                                  dfCnt:
 16272 00001817 E8D7FE                  	call	CountFile		; update file counters
 16273                                  dfRet:
 16274                                  dhRet:	; 19/02/2023
 16275 0000181A C3                      	retn
 16276                                  
 16277                                  ; ---------------------------------------------------------------------------
 16278                                  
 16279                                  ;***	DisplayHeader - display directory header of working directory
 16280                                  ;
 16281                                  ;	ENTRY	Current directory (on selected drive) is the one to display
 16282                                  ;		LeftOnPage = # lines left on display page
 16283                                  ;
 16284                                  ;	EXIT	nothing
 16285                                  ;
 16286                                  ;	ERROR EXIT
 16287                                  ;
 16288                                  ;	  Build_Dir_String will exit through CError with "Invalid drive
 16289                                  ;	   specification" if there's a problem obtaining the current 
 16290                                  ;	   directory pathname.
 16291                                  ;
 16292                                  ;	USED	AX,DX,SI,DI
 16293                                  ;
 16294                                  ;	EFFECTS
 16295                                  ;
 16296                                  ;	  BwdBuf (which is really the same buffer as DirBuf, which
 16297                                  ;	   we are using for the DTA) contains the directory string.
 16298                                  ;	  LeftOnPage is adjusted.
 16299                                  
 16300                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16301                                  
 16302                                  DisplayHeader:
 16303                                  	;;;test	Bits,mask bare
 16304                                  	;;test	word [_Bits],8
 16305                                  	;test	byte [_Bits],8
 16306 0000181B F606[3B8C]08            	test	byte [_Bits],mask.bare
 16307 00001820 75F8                    	jnz	short dhRet		; /b - don't display header
 16308                                  
 16309                                  	;;;test	Bits,mask subd
 16310                                  	;;test	word [_Bits],4
 16311                                  	;test	byte [_Bits],4
 16312 00001822 F606[3B8C]04            	test	byte [_Bits],mask.subd
 16313 00001827 7408                    	jz	short dhNorm		; not /s
 16314                                  
 16315                                  ;	For subdirectory listings, put a blank line before the header.
 16316                                  
 16317                                  	;invoke	Crlf2			; start with a blank line
 16318 00001829 E8CD0D                  	call	CRLF2
 16319 0000182C E83BFF                  	call	UseLine
 16320 0000182F EB05                    	jmp	short dhCom
 16321                                  dhNorm:
 16322 00001831 B020                    	mov	al,' ' ; 20h
 16323                                  	;mov	al,BLANK		; if not /s, precede by a blank
 16324 00001833 E8E105                  	call	PRINT_CHAR		; print a leading blank
 16325                                  dhCom:
 16326 00001836 E82D06                  	call	build_dir_string
 16327 00001839 BA[BC80]                	mov	dx,dirhead_ptr
 16328 0000183C E80436                  	call	std_printf		; print header & cr/lf
 16329 0000183F E828FF                  	call	UseLine
 16330 00001842 E8B40D                  	call	CRLF2			; another cr/lf
 16331                                  	;call	UseLine
 16332                                  ;dhRet:
 16333                                  	;retn
 16334                                  
 16335                                  	; 19/02/2023
 16336 00001845 E922FF                  	jmp	UseLine
 16337                                  
 16338                                  ; ---------------------------------------------------------------------------
 16339                                  
 16340                                  ;***	DisplayName - display file name & extension
 16341                                  ;
 16342                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16343                                  ;
 16344                                  ;	EXIT	nothing
 16345                                  ;
 16346                                  ;	USED	AX,CX,DX,SI,DI
 16347                                  ;
 16348                                  ;	EFFECTS
 16349                                  ;
 16350                                  ;	  Filename & extension are displayed in spread format.
 16351                                  ;	  Cursor is left at end of extension.
 16352                                  
 16353                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16354                                  
 16355                                  DisplayName:
 16356 00001848 1E                      	push	ds			; save TRANGROUP seg addr
 16357 00001849 8E1E[E28A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16358                                  	;assume	ds:nothing
 16359 0000184D 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16360                                  	;add	si,filename		; DS:SI = ptr to filename
 16361 0000184F 83C601                  	add	si,1  ; EntryStruc.filename
 16362 00001852 BF[1A8B]                	mov	di,CHARBUF		; ES:DI = ptr to CharBuf
 16363                                  
 16364 00001855 B90800                  	mov	cx,8
 16365 00001858 FC                      	cld
 16366 00001859 F3A4                    	rep	movsb			; move filename to CharBuf
 16367 0000185B B020                    	mov	al,' '
 16368 0000185D AA                      	stosb				; add a blank
 16369 0000185E B90300                  	mov	cx,3
 16370 00001861 F3A4                    	rep	movsb			; add extension
 16371 00001863 30C0                    	xor	al,al
 16372 00001865 AA                      	stosb				; add a NULL
 16373                                  
 16374 00001866 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16375                                  	;assume	ds:TRANGROUP
 16376                                  
 16377                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16378                                  	;;test	word [_Bits],10h
 16379                                  	;test	byte [_Bits],10h
 16380 00001867 F606[3B8C]10            	test	byte [_Bits],mask.lcase
 16381 0000186C 7406                    	jz	short dn1		;M010;lowercase not required
 16382 0000186E BE[1A8B]                	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
 16383 00001871 E85501                  	call	LowercaseString		;M010;filename.ext string is in CharBuf
 16384                                  dn1:	
 16385 00001874 C706[D08C][1A8B]        	mov	word [string_ptr_2],CHARBUF
 16386 0000187A BA[3C81]                	mov	dx,string_buf_ptr
 16387                                  	;call	std_printf		; print filename & extension
 16388                                  	;retn
 16389                                  	; 19/02/2023
 16390 0000187D E9C335                  	jmp	std_printf
 16391                                  
 16392                                  ; ---------------------------------------------------------------------------
 16393                                  
 16394                                  ;***	DisplayNext - move display cursor to next entry position
 16395                                  ;
 16396                                  ;	ENTRY	LeftOnLine = # entries can still be printed on this line
 16397                                  ;		LeftOnPage = # lines can still be printed for this page
 16398                                  ;		FileCnt = # files in this dir displayed before this one
 16399                                  ;		Bits contains /w setting
 16400                                  ;
 16401                                  ;	EXIT	nothing
 16402                                  ;
 16403                                  ;	USED	AX,DX
 16404                                  ;
 16405                                  ;	EFFECTS
 16406                                  ;
 16407                                  ;	  LeftOnLine will be updated to reflect the entry about to be
 16408                                  ;	   displayed.
 16409                                  ;	  LeftOnPage may be updated.
 16410                                  
 16411                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16412                                  
 16413                                  DisplayNext:
 16414 00001880 833E[0C8B]00            	cmp	word [FileCnt],0
 16415 00001885 7415                    	je	short dn1st		; 1st file in directory
 16416 00001887 803E[068B]00            	cmp	byte [LeftOnLine],0
 16417 0000188C 7E08                    	jng	short dnEol		; no more room on this line
 16418                                  
 16419                                  ;	We are in wide mode (LeftOnLine is always 0 otherwise) and
 16420                                  ;	we still have room for more on this line.
 16421                                  ;	Tab to next position.
 16422                                  
 16423 0000188E BA[4B81]                	mov	dx,tab_ptr
 16424 00001891 E8AF35                  	call	std_printf
 16425 00001894 EB0C                    	jmp	short dnDone
 16426                                  dnEol:	
 16427                                  ;	Start this entry on a new line.
 16428                                  
 16429 00001896 E8600D                  	call	CRLF2		; start on new line
 16430 00001899 E8CEFE                  	call	UseLine
 16431                                  dn1st:
 16432 0000189C A0[078B]                	mov	al,[PerLine]
 16433 0000189F A2[068B]                	mov	[LeftOnLine],al	; reset # entries left on line
 16434                                  
 16435                                  dnDone:
 16436 000018A2 FE0E[068B]              	dec	byte [LeftOnLine]
 16437                                  				; reflect the entry about to be displayed
 16438 000018A6 C3                      	retn
 16439                                  
 16440                                  ; ---------------------------------------------------------------------------
 16441                                  
 16442                                  ;***	DisplayTheRest - display file size/dir, date, time
 16443                                  ;
 16444                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16445                                  ;		Display cursor is at end of file extension
 16446                                  ;
 16447                                  ;	EXIT	nothing
 16448                                  ;
 16449                                  ;	USED	AX,CX,DX,SI,DI,BP
 16450                                  ;
 16451                                  ;	EFFECTS
 16452                                  ;
 16453                                  ;	  File size, date, & time are displayed.
 16454                                  
 16455                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16456                                  DisplayTheRest	:
 16457 000018A7 06                      	push	es			; save TRANGROUP seg addr
 16458 000018A8 8E06[E28A]              	mov	es,[TPA]		; ES = TPA seg addr
 16459 000018AC 89DD                    	mov	bp,bx			; BP = offset of entry in TPA
 16460                                  	;;test	es:[bp].fileattr,ATTR_DIRECTORY
 16461                                  	;test	byte [es:bp+EntryStruc.fileattr],10h
 16462 000018AE 26F6460C10              	test	byte [es:bp+12],ATTR_DIRECTORY
 16463 000018B3 7408                    	jz	short drNonDir		; not a directory file
 16464                                  
 16465                                  ;	For a directory file, display <DIR> instead of size.
 16466                                  
 16467 000018B5 BA[4E81]                	mov	dx,dmes_ptr
 16468 000018B8 E88835                  	call	std_printf
 16469 000018BB EB16                    	jmp	short drCom		; skip to common fields
 16470                                  
 16471                                  drNonDir:
 16472                                  ;	For a non-directory file, display file size.
 16473                                  
 16474                                  	;;mov	dx,word ptr es:[bp].filesize
 16475                                  	;mov	dx,[es:bp+EntryStruc.filesize]
 16476 000018BD 268B5611                	mov	dx,[es:bp+17]
 16477 000018C1 8916[CC8C]              	mov	[File_Size_Low],dx
 16478                                  	;;mov	dx,word ptr es:[bp].filesize+2
 16479                                  	;mov	dx,[es:bp+EntryStruc.filesize+2]
 16480 000018C5 268B5613                	mov	dx,[es:bp+19]
 16481 000018C9 8916[CE8C]              	mov	[File_Size_High],dx
 16482 000018CD BA[2E81]                	mov	dx,disp_file_size_ptr
 16483 000018D0 E87035                  	call	std_printf
 16484                                  drCom:
 16485                                  ;	For all files, display date & time.
 16486                                  
 16487                                  	;;mov	ax,es:[bp].filedate	; AX = date word
 16488                                  	;mov	ax,[es:bp+EntryStruc.filedate]
 16489 000018D3 268B460F                	mov	ax,[es:bp+15]
 16490 000018D7 09C0                    	or	ax,ax			; test for null date (DOS 1.x)
 16491 000018D9 7448                    	jz	short drDone		; no date, skip date/time display
 16492 000018DB 89C3                    	mov	bx,ax			; BX = date word
 16493 000018DD 83E01F                  	and	ax,1Fh			; AX = day of month
 16494 000018E0 88C2                    	mov	dl,al			; DL = day of month
 16495 000018E2 89D8                    	mov	ax,bx			; AX = date word
 16496 000018E4 B105                    	mov	cl,5
 16497 000018E6 D3E8                    	shr	ax,cl			; shift day out
 16498 000018E8 240F                    	and	al,0Fh			; AL = month
 16499 000018EA 88C6                    	mov	dh,al			; DH = month
 16500 000018EC 88F9                    	mov	cl,bh
 16501 000018EE D0E9                    	shr	cl,1			; CL = year - 1980
 16502 000018F0 30ED                    	xor	ch,ch			; CX = year - 1980
 16503 000018F2 83C150                  	add	cx,80			; CX = 2-digit year
 16504 000018F5 80F964                  	cmp	cl,100
 16505 000018F8 7203                    	jb	short dr_1		; not year 2000 yet, skip ahead
 16506 000018FA 80E964                  	sub	cl,100			; adjust for 21st century
 16507                                  dr_1:	
 16508 000018FD 86F2                    	xchg	dh,dl			; DX = month/day
 16509 000018FF 890E[8C81]              	mov	[DirDat_Yr],cx		; move year to msg block
 16510 00001903 8916[8E81]              	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
 16511                                  	;;mov	cx,es:[bp].filetime	; CX = file time
 16512                                  	;mov	cx,[es:bp+EntryStruc.filetime]
 16513 00001907 268B4E0D                	mov	cx,[es:bp+13]
 16514 0000190B E310                    	jcxz	drPrint			; no time field - go print
 16515 0000190D D1E9                    	shr	cx,1
 16516 0000190F D1E9                    	shr	cx,1
 16517 00001911 D1E9                    	shr	cx,1			; CH = hours
 16518 00001913 D0E9                    	shr	cl,1
 16519 00001915 D0E9                    	shr	cl,1			; CL = minutes
 16520 00001917 86E9                    	xchg	ch,cl			; CX = hr/min
 16521 00001919 890E[9781]              	mov	[DirTim_Hr_Min],cx	; move time to msg block
 16522                                  drPrint:
 16523 0000191D BA[8781]                	mov	dx,dirdattim_ptr
 16524 00001920 E82035                  	call	std_printf		; print date & time
 16525                                  drDone:
 16526 00001923 07                      	pop	es			; ES = TRANGROUP seg addr again	
 16527 00001924 89EB                    	mov	bx,bp			; BX = offset of entry in TPA again
 16528                                  dtrRet:
 16529                                  	; 19/02/2023
 16530 00001926 C3                      	retn
 16531                                  
 16532                                  ; ---------------------------------------------------------------------------
 16533                                  
 16534                                  ;***	DisplayTrailer - display trailing lines for directory listing
 16535                                  ;
 16536                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16537                                  ;		FileCnt = # files listed
 16538                                  ;		FileSiz = total size of files listed
 16539                                  ;
 16540                                  ;	EXIT	nothing
 16541                                  ;
 16542                                  ;	USED
 16543                                  ;
 16544                                  ;	EFFECTS
 16545                                  ;
 16546                                  ;	  Trailing info lines are displayed
 16547                                  
 16548                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16549                                  
 16550                                  DisplayTrailer:
 16551                                  	;;;test	Bits,mask bare
 16552                                  	;;test	word [_Bits],8
 16553                                  	;test	byte [_Bits],8
 16554 00001927 F606[3B8C]08            	test	byte [_Bits],mask.bare
 16555 0000192C 75F8                    	jnz	short dtrRet		; /b - don't display trailer
 16556                                  
 16557 0000192E E8C80C                  	call	CRLF2			; start on new line
 16558 00001931 E836FE                  	call	UseLine
 16559 00001934 A1[0C8B]                	mov	ax,[FileCnt]		; AX = # files found
 16560                                  
 16561                                  ;	DisplayTotals uses this entry point.
 16562                                  ;
 16563                                  DisplayCntSiz:
 16564                                  ;	AX = # files
 16565                                  ;	FileSiz = dword total size of files
 16566                                  
 16567 00001937 A3[D58C]                	mov	[Dir_Num],ax		; load # files
 16568 0000193A BA[B57F]                	mov	dx,dirmes_ptr		; DX = ptr to message block
 16569 0000193D E80335                  	call	std_printf		; "nnn File(s)"
 16570                                  
 16571 00001940 BA[A381]                	mov	dx,bytes_ptr
 16572 00001943 E8FD34                  	call	std_printf		; "nnn bytes",cr,lf
 16573                                  	; 19/02/2023
 16574                                  	;call	UseLine
 16575                                  ;dtrRet:
 16576                                  	;retn
 16577                                  
 16578                                  	; 19/02/2023
 16579 00001946 E921FE                  	jmp	UseLine
 16580                                  
 16581                                  ; ---------------------------------------------------------------------------
 16582                                  
 16583                                  ;***	DisplayWide - display filename in wide format
 16584                                  ;
 16585                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16586                                  ;
 16587                                  ;	EXIT	nothing
 16588                                  ;
 16589                                  ;	USED	AX,CX,DX,SI,DI
 16590                                  ;
 16591                                  ;	EFFECTS
 16592                                  ;
 16593                                  ;	  Name.ext is displayed. Cursor left at end of field (padded
 16594                                  ;	  with blanks). Subdirectory files are displayed as [name.ext].
 16595                                  
 16596                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16597                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah
 16598                                  
 16599                                  DisplayWide:
 16600 00001949 1E                      	push	ds			; save TRANGROUP seg addr
 16601 0000194A 8E1E[E28A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16602                                  	;assume	ds:nothing
 16603                                  
 16604                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16605                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16606 0000194E F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 16607 00001952 7405                    	jz	short dw1		; not a subdirectory file
 16608 00001954 B05B                    	mov	al,'['
 16609 00001956 E8BE04                  	call	PRINT_CHAR		; prefix subdirectory
 16610                                  dw1:	
 16611 00001959 E838FE                  	call	DisplayDotForm		; display name.ext
 16612                                  
 16613                                  ;	DX = # chars displayed in name.ext
 16614                                  
 16615                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16616                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16617 0000195C F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 16618 00001960 7405                    	jz	short dw2		; not a subdirectory file
 16619 00001962 B05D                    	mov	al,']'
 16620 00001964 E8B004                  	call	PRINT_CHAR		; postfix subdirectory
 16621                                  dw2:
 16622                                  ;	Pad field with blanks.
 16623                                  
 16624                                  	;mov	cx,size filename + size fileext + 1
 16625 00001967 B90C00                  	mov	cx,12 ; 8+3+1
 16626                                  					; CX = field size
 16627 0000196A 29D1                    	sub	cx,dx			; CX = # pad char's
 16628 0000196C E307                    	jcxz	dwDone
 16629 0000196E B020                    	mov	al,' '
 16630                                  dw3:	
 16631 00001970 E8A404                  	call	PRINT_CHAR
 16632 00001973 E2FB                    	loop	dw3
 16633                                  dwDone:	
 16634 00001975 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16635                                  	;assume	ds:TRANGROUP
 16636 00001976 C3                      	retn
 16637                                  
 16638                                  ; ---------------------------------------------------------------------------
 16639                                  
 16640                                  ;***	GetDriveLtr - get target drive letter
 16641                                  ;
 16642                                  ;	ENTRY	FCB contains drive #
 16643                                  ;
 16644                                  ;	EXIT	AX = "d:"
 16645                                  ;
 16646                                  ;	USED	nothing
 16647                                  
 16648                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16649                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
 16650                                  GetDriveLtr:
 16651 00001977 A05C00                  	mov	al,[FCB] ; 5Ch	; AL = target drive #
 16652 0000197A 08C0                    	or	al,al
 16653 0000197C 7505                    	jnz	short gdl1	; not current drive default, skip ahead
 16654 0000197E A0[F48A]                	mov	al,[CURDRV]	; AL = current drive #
 16655 00001981 FEC0                    	inc	al		; AL = 1-based drive #
 16656                                  gdl1:	
 16657 00001983 0440                    	add	al,'A'-1 ; 40h	; AL = target drive letter
 16658 00001985 B43A                    	mov	ah,':'		; AX = "d:"
 16659 00001987 C3                      	retn
 16660                                  
 16661                                  ; ---------------------------------------------------------------------------
 16662                                  
 16663                                  ;***	SetupParamError - set up for Std_EPrintf parameter parse error message
 16664                                  ;
 16665                                  ;	Do for our /O and /A string parsers what Parse_With_Msg does
 16666                                  ;	for system parser calls. Set up a message substitution block,
 16667                                  ;	etc. for invalid value strings. I copied the procedure from
 16668                                  ;	Setup_Parse_Error_Msg.
 16669                                  ;
 16670                                  ;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
 16671                                  ;		
 16672                                  ;
 16673                                  ;	EXIT	AX = system parser error return code for bad param format
 16674                                  ;		DX = ptr to message description block for Std_EPrintf
 16675                                  ;
 16676                                  ;	USED	SI
 16677                                  ;
 16678                                  ;	EFFECTS
 16679                                  ;
 16680                                  ;	  Msg_Disp_Class = parse error message class
 16681                                  ;	  Message block (see DX) is set up for parse error message
 16682                                  
 16683                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16684                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
 16685                                  SetupParamError:
 16686 00001988 B80900                  	mov	ax,9			; parse error #
 16687 0000198B C606[737F]02            	mov	byte [msg_disp_class],parse_msg_class
 16688                                  	;mov	byte [msg_disp_class],2
 16689 00001990 A3[757F]                	mov	[extend_buf_ptr],ax
 16690                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16691 00001993 8B7704                  	mov	si,[bx+4]
 16692 00001996 8936[D08C]              	mov	[string_ptr_2],si
 16693 0000199A C606[777F]01            	mov	byte [extend_buf_sub],one_subst
 16694                                  	;mov	byte [extend_buf_sub],1
 16695 0000199F BA[757F]                	mov	dx,extend_buf_ptr
 16696 000019A2 C3                      	retn
 16697                                  
 16698                                  ; ---------------------------------------------------------------------------
 16699                                  
 16700                                  ;***	ZeroTotals - zero grand total file count, size
 16701                                  ;
 16702                                  ;	ENTRY	nothing
 16703                                  ;
 16704                                  ;	EXIT	nothing
 16705                                  ;
 16706                                  ;	USED	AX
 16707                                  ;
 16708                                  ;	EFFECTS
 16709                                  ;
 16710                                  ;	  FileCntTotal & FileSizTotal are zeroed.
 16711                                  ;
 16712                                  ;	NOTES
 16713                                  ;
 16714                                  ;	  FileCntTotal throuth csecUsedTotal must be together!
 16715                                  	
 16716                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16717                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h	
 16718                                  ZeroTotals:
 16719 000019A3 BF[128B]                	mov	di,FileCntTotal
 16720                                  
 16721                                  	;mov	cx,size FileCntTotal+size FileSizTotal
 16722 000019A6 B90800                  	mov	cx,8
 16723                                  
 16724 000019A9 30C0                    	xor	al,al
 16725 000019AB F3AA                    	rep	stosb
 16726 000019AD C3                      	retn	
 16727                                  
 16728                                  ; ---------------------------------------------------------------------------
 16729                                  
 16730                                  ;***	CtrlCHandler - our own control-c handler
 16731                                  ;
 16732                                  ;	Make sure user's default directory gets restored. See notes
 16733                                  ;	at InstallCtrlCHandler.
 16734                                  ;
 16735                                  ;	ENTRY	control-c
 16736                                  ;
 16737                                  ;	EXIT	to OldCtrlCHandler
 16738                                  ;
 16739                                  ;	USED	DS,flags
 16740                                  ;
 16741                                  ;	EFFECTS
 16742                                  ;
 16743                                  ;	  Restore user's default directory.
 16744                                  ;
 16745                                  ;	NOTES
 16746                                  ;
 16747                                  ;	  This handler is only installed after calling PathCrunch,
 16748                                  ;	  which sets UserDir1, so the restoration will work.
 16749                                  ;
 16750                                  ;	  The original control-c vector will be restored, whether
 16751                                  ;	  or not this one is invoked, in the HeadFix routine.
 16752                                  
 16753                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16754                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh
 16755                                  
 16756                                  CtrlCHandler:	;proc	far
 16757                                  
 16758                                  ;SR;
 16759                                  ; Save all registers used: ds, dx, ax. I know ax is being used by the 
 16760                                  ;CtrlC handler, am not sure about ds & dx. Save them to be safe
 16761                                  ;
 16762 000019AE 1E                      	push	ds
 16763 000019AF 0E                      	push	cs
 16764 000019B0 1F                      	pop	ds			; DS = TRANGROUP seg addr
 16765 000019B1 50                      	push	ax
 16766 000019B2 52                      	push	dx
 16767 000019B3 E8FD0A                  	call	RestUDir		; restore user's default directory
 16768 000019B6 5A                      	pop	dx
 16769 000019B7 58                      	pop	ax
 16770 000019B8 1F                      	pop	ds
 16771 000019B9 2EFF2E[E395]            	jmp	far [cs:OldCtrlCHandler]
 16772                                  					; go to previous int 23 handler
 16773                                  
 16774                                  ; ---------------------------------------------------------------------------
 16775                                  
 16776                                  ;M010;start
 16777                                  ;***	LowerCase - convert ASCII character in AL to lowercase
 16778                                  ;
 16779                                  ;	ENTRY	AL = character to be displayed
 16780                                  ;
 16781                                  ;	EXIT	AL is lowercase
 16782                                  ;
 16783                                  ;	USED	nothing
 16784                                  
 16785                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16786                                  LowerCase:
 16787 000019BE 3C41                    	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
 16788 000019C0 7206                    	jb	short lcRet
 16789 000019C2 3C5A                    	cmp	al,'Z'
 16790 000019C4 7702                    	ja	short lcRet
 16791                                  
 16792 000019C6 0C20                    	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase
 16793                                  lcRet:
 16794 000019C8 C3                      	retn
 16795                                  
 16796                                  ; ---------------------------------------------------------------------------
 16797                                  
 16798                                  ;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
 16799                                  ;
 16800                                  ;	ENTRY	DS:SI points to start of ASCIIZ string
 16801                                  ;		ES = DS
 16802                                  ;
 16803                                  ;	EXIT	nothing
 16804                                  ;	
 16805                                  ;	USED	AL,SI
 16806                                  
 16807                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16808                                  LowercaseString:
 16809 000019C9 57                      	push	di			; save di
 16810 000019CA 89F7                    	mov	di,si			; ES:DI --> ASCIIZ string
 16811 000019CC FC                      	cld
 16812                                  NextChar: 
 16813 000019CD AC                      	lodsb				; get character from string into al
 16814 000019CE 08C0                    	or	al,al			; are we at end of string?
 16815 000019D0 7406                    	jz	short EndOfString
 16816                                  
 16817 000019D2 E8E9FF                  	call	LowerCase		; convert character to lowercase
 16818 000019D5 AA                      	stosb				; store character back into buffer
 16819 000019D6 EBF5                    	jmp	short NextChar		; repeat until end of string
 16820                                  
 16821                                  EndOfString:
 16822 000019D8 5F                      	pop	di			; restore di
 16823 000019D9 C3                      	retn
 16824                                  
 16825                                  ;M010;end
 16826                                  
 16827                                  ;============================================================================
 16828                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 16829                                  ;============================================================================
 16830                                  ; 09/10/2018 - Retro DOS v3.0
 16831                                  
 16832                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
 16833                                  
 16834                                  ; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16835                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah
 16836                                  
 16837                                  ; =============== S U B	R O U T	I N E =======================================
 16838                                  
 16839                                  PAUSE:
 16840 000019DA BA[0780]                	mov	dx,PAUSEMES_PTR ; 19/02/2023
 16841 000019DD E86334                  	call	std_printf
 16842 000019E0 E871EB                  	call	GETKEYSTROKE
 16843                                  	;call	CRLF2
 16844                                  	;retn
 16845                                  	; 19/02/2023
 16846 000019E3 E9130C                  	jmp	CRLF2
 16847                                  
 16848                                  ; ---------------------------------------------------------------------------
 16849                                  
 16850                                  ;****************************************************************
 16851                                  ;*
 16852                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
 16853                                  ;*
 16854                                  ;* FUNCTION:	PARSE command line for file or path name and /P
 16855                                  ;*		and invoke PATHCRUNCH. If an error occurs, set
 16856                                  ;*		up an error message and transfer control to CERROR.
 16857                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
 16858                                  ;*		entered or SLASHP_ERASE if /P entered.
 16859                                  ;*
 16860                                  ;* INPUT:	command line at offset 81H
 16861                                  ;*
 16862                                  ;* OUTPUT:	if no error:
 16863                                  ;*		FCB at 5ch set up with filename(s) entered
 16864                                  ;*		Current directory set to entered directory
 16865                                  ;*
 16866                                  ;****************************************************************
 16867                                  
 16868                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16869                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
 16870                                  ERASE:
 16871                                  	; MSDOS 6.0
 16872                                  
 16873                                  	;assume	ds:trangroup,es:trangroup
 16874                                  
 16875 000019E6 BE8100                  	mov	si,81h		;AC000; get command line
 16876 000019E9 C706[F78A]0000          	mov	word [COMSW],0 	;AN000; clear switch indicator
 16877 000019EF BF[7385]                	mov	di,PARSE_ERASE
 16878                                  				;AN000; Get address of PARSE_ERASE
 16879 000019F2 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 16880                                  erase_scan:
 16881 000019F4 31D2                    	xor	dx,dx		;AN000;
 16882 000019F6 E8E507                  	call	Parse_With_Msg	;AC018; call parser
 16883 000019F9 83F8FF                  	cmp	ax,-1  ; 0FFFFh
 16884                                  	;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 16885 000019FC 743D                    	je	short good_line	;AN000; yes - done parsing
 16886                                  	;cmp	ax,0
 16887                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 16888 000019FE 21C0                    	and	ax,ax		;AC000; did we have an error?
 16889 00001A00 7566                    	jnz	short errj2	;AC000; yes exit
 16890                                  
 16891 00001A02 813E[1196][E684]        	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
 16892                                  				;AN000; was /P entered?
 16893 00001A08 741C                    	je	short set_erase_prompt
 16894                                  				;AN000; yes - go set prompt
 16895                                  ;
 16896                                  ; Must be filespec since no other matches occurred. move filename to srcbuf
 16897                                  ;
 16898 00001A0A 56                      	push	si		;AC000; save position in line
 16899 00001A0B C536[1396]              	lds	si,[PARSE1_ADDR]
 16900                                  				;AC000; get address of filespec
 16901                                  	;cmp	byte [si+1],colon_char
 16902 00001A0F 807C013A                	cmp	byte [si+1],':'	;AC000; drive specified?
 16903 00001A13 750B                    	jne	short erase_drive_ok
 16904                                  				;AC000; no - continue
 16905                                  	;cmp	byte [si+2],END_OF_LINE_OUT	
 16906 00001A15 807C0200                	cmp	byte [si+2],0	;AC000; was only drive entered?
 16907 00001A19 7505                    	jne	short erase_drive_ok
 16908                                  				;AC000; no - continue
 16909 00001A1B B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
 16910                                  				;AN022; get message number in control block
 16911 00001A1E EB3D                    	jmp	short extend_setup
 16912                                  				;AC000; exit
 16913                                  erase_drive_ok:
 16914 00001A20 E8B312                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 16915 00001A23 5E                      	pop	si		;AC000; get position back
 16916 00001A24 EBCE                    	jmp	short erase_scan
 16917                                  				;AN000; continue parsing
 16918                                  set_erase_prompt:
 16919 00001A26 833E[F78A]00            	cmp	word [COMSW],0 	;AN018; was /P already entered?
 16920 00001A2B 7408                    	jz	short ok_to_set_erase_prompt
 16921                                  				;AN018; no go set switch
 16922                                  	;mov	ax,1
 16923 00001A2D B80100                  	mov	ax,MoreArgs_Ptr 
 16924                                  				;AN018; set up too many arguments
 16925 00001A30 E8BA07                  	call	setup_parse_error_msg
 16926                                  				;AN018; set up an error message
 16927 00001A33 EB33                    	jmp	short errj2	;AN018; exit
 16928                                  
 16929                                  ok_to_set_erase_prompt: 	;AN018;
 16930 00001A35 FF06[F78A]              	inc	word [COMSW]	;AN000; indicate /p specified
 16931 00001A39 EBB9                    	jmp	short erase_scan
 16932                                  				;AN000; continue parsing
 16933                                  good_line:			;G  We know line is good
 16934 00001A3B E8640C                  	call	PathCrunch
 16935 00001A3E 730D                    	jnc	short checkdr
 16936 00001A40 A1[538E]                	mov	ax,[Msg_Numb]	;AN022; get message number
 16937                                  	;cmp	ax,0		;AN022; was message flag set?
 16938 00001A43 09C0                    	or	ax,ax
 16939 00001A45 7516                    	jnz	short extend_setup
 16940                                  				;AN022; yes - print out message
 16941                                  	;cmp	byte [DestIsDir],0
 16942 00001A47 3806[E78C]              	cmp	[DestIsDir],al 	; No CHDIRs worked
 16943 00001A4B 750D                    	jnz	short badpath_err
 16944                                  				;AC022; see if they should have
 16945                                  checkdr:
 16946 00001A4D 833E[F78A]00            	cmp	word [COMSW],0 	;AN000; was /p specified
 16947 00001A52 7403                    	jz	short notest2j	;AN000; no - go to notest2
 16948 00001A54 E92F1B                  	jmp	slashp_erase	;AN000; yes - go to slashp_erase
 16949                                  notest2j:
 16950 00001A57 E9C71A                  	jmp	notest2
 16951                                  
 16952                                  badpath_err:			;AN022; "Path not found" message
 16953 00001A5A B80300                  	mov	ax,ERROR_PATH_NOT_FOUND ; 3
 16954                                  				;AN022; set up error number
 16955                                  extend_setup:			;AN022;
 16956                                  	;mov	byte [msg_disp_class],1
 16957 00001A5D C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class
 16958                                  				;AN022; set up extended error msg class
 16959 00001A62 BA[757F]                	mov	dx,extend_buf_ptr
 16960                                  				;AC022; get extended message pointer
 16961 00001A65 A3[757F]                	mov	[extend_buf_ptr],ax
 16962                                  				;AN022; get message number in control block
 16963                                  errj2:				;AC022; exit jump
 16964 00001A68 E90F0F                  	jmp	cerror		;AN022;
 16965                                  
 16966                                  ; 20/02/2023
 16967                                  %if 0
 16968                                  	; MSDOS 3.3
 16969                                  	mov	dx,BADARGSPTR
 16970                                  	mov	si,80h
 16971                                  	lodsb
 16972                                  	or	al,al
 16973                                  	jz	short ERRJ2
 16974                                  	call	SCANOFF
 16975                                  	cmp	al,0Dh		; Return key
 16976                                  	jz	short ERRJ2	; If so no parameters specified
 16977                                  	push	dx
 16978                                  	push	si
 16979                                  	mov	dx,FNOTFOUNDPTR
 16980                                  ERASE_SCAN:
 16981                                  	lodsb
 16982                                  	call	DELIM
 16983                                  	jz	short ERASE_CHKDELIMCHR
 16984                                  	cmp	al,0Dh
 16985                                  	jz	short GOOD_LINE
 16986                                  	jmp	short ERASE_SCAN
 16987                                  ERASE_CHKDELIMCHR:
 16988                                  	cmp	al,20h
 16989                                  	jg	short ERRJ2
 16990                                  	lodsb
 16991                                  	call	DELIM
 16992                                  	jz	short ERASE_CHKDELIMCHR
 16993                                  	cmp	al,0Dh
 16994                                  	jz	short GOOD_LINE
 16995                                  	mov	dx,BADARGSPTR
 16996                                  	jmp	short ERRJ2
 16997                                  GOOD_LINE:
 16998                                  	pop	si
 16999                                  	pop	dx
 17000                                  	push	si
 17001                                  	call	PATHCRUNCH
 17002                                  	jnc	short CHECKDR
 17003                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17004                                  	jz	short CHECKDR	   ; see if they should have
 17005                                  BADCDERR:
 17006                                  	pop	si
 17007                                  	mov	dx,BADCDPTR
 17008                                  ERRJ2:
 17009                                  	jmp	CERROR
 17010                                  CHECKDR:
 17011                                  	mov	dx,FNOTFOUNDPTR
 17012                                  	pop	cx
 17013                                  	mov	al,' '
 17014                                  	;cmp	[5Dh],al
 17015                                  	cmp	[FCB+1],al
 17016                                  	jz	short ERRJ2
 17017                                  	add	cx,3
 17018                                  	cmp	si,cx
 17019                                  	jnz	short NOTEST2J
 17020                                  	mov	al,':'
 17021                                  	cmp	[si-2],al
 17022                                  	jz	short ERRJ2
 17023                                  NOTEST2J:
 17024                                  	jmp	NOTEST2
 17025                                  %endif
 17026                                  
 17027                                  ; ---------------------------------------------------------------------------
 17028                                  
 17029                                  ; ****************************************************************
 17030                                  ; *
 17031                                  ; * ROUTINE:	 CRENAME - rename file(s)
 17032                                  ; *
 17033                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
 17034                                  ; *		 filename. Invoke PATHCRUNCH on the full filespec.
 17035                                  ; *		 Make sure the second filespec only contains a
 17036                                  ; *		 filename. If both openands are valid, attempt
 17037                                  ; *		 to rename the file.
 17038                                  ; *
 17039                                  ; * INPUT:	 command line at offset 81H
 17040                                  ; *
 17041                                  ; * OUTPUT:	 none
 17042                                  ; *
 17043                                  ; ****************************************************************
 17044                                  
 17045                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17046                                  CRENAME:
 17047                                  	; MSDOS 6.0
 17048                                  	;assume	ds:trangroup,es:trangroup
 17049                                  
 17050 00001A6B BE8100                  	mov	si,81h		;AC000; Point to command line
 17051 00001A6E BF[EA85]                	mov	di,PARSE_RENAME
 17052                                  				;AN000; Get address of PARSE_RENAME
 17053 00001A71 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17054 00001A73 31D2                    	xor	dx,dx		;AN000;
 17055 00001A75 E86607                  	call	Parse_With_Msg	;AC018; call parser
 17056                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 17057 00001A78 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17058                                  ;	jz	short crename_no_parse_error
 17059                                  				;AC000; no - continue
 17060 00001A7A 752C                    	jnz	short crename_parse_error
 17061                                  				;AC000; Yes, fail. (need long jump)
 17062                                  ;
 17063                                  ;  Get first file name returned from parse into our buffer
 17064                                  ;
 17065                                  crename_no_parse_error:
 17066 00001A7C 56                      	push	si		;AN000; save position in line
 17067 00001A7D C536[1396]              	lds	si,[PARSE1_ADDR]
 17068                                  				;AN000; get address of filespec
 17069 00001A81 E85212                  	call    Move_To_SrcBuf	;AN000; move to srcbuf
 17070 00001A84 5E                      	pop	si		;AN000; restore position in line
 17071                                  
 17072 00001A85 31D2                    	xor	dx,dx		;AN000; clear dx
 17073 00001A87 E85407                  	call	Parse_With_Msg	;AC018; call parser
 17074                                  	;cmp	ax,RESULT_NO_ERROR
 17075 00001A8A 21C0                    	and	ax,ax ; 0 ?	;AN000; did we have an error?
 17076 00001A8C 751A                    	jnz	short crename_parse_error
 17077                                  				;AN000; Yes, fail.
 17078                                  ;
 17079                                  ;  Check the second file name for drive letter colon
 17080                                  ;
 17081 00001A8E 56                      	push	si		;AN000; save position in line
 17082 00001A8F C536[1396]              	lds	si,[PARSE1_ADDR]
 17083                                  				;AC000; get address of path
 17084                                  	;mov	al,':'		;AC000;
 17085                                  	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
 17086 00001A93 807C013A                	cmp	byte [si+1],':'
 17087 00001A97 7511                    	jnz	short ren_no_drive
 17088                                  				;AN000; Yes, error
 17089                                  	;mov	byte [msg_disp_class],2
 17090 00001A99 C606[737F]02            	mov	byte [msg_disp_class],parse_msg_class
 17091                                  				;AN000; set up parse error msg class
 17092 00001A9E BA[757F]                	mov	dx,extend_buf_ptr
 17093                                  				;AC000; get extended message pointer
 17094                                  	;mov	word [extend_buf_ptr],0Ah
 17095 00001AA1 C706[757F]0A00          	mov	word [extend_buf_ptr],BadParm_Ptr
 17096                                  				;AN000; get "Invalid parameter" message number
 17097 00001AA7 5E                      	pop	si		;AN000;
 17098                                  crename_parse_error:		;AC022;
 17099 00001AA8 EB64                    	jmp	short errj	;AC000;
 17100                                  
 17101                                  ;  Get second file name returned from parse into the fCB. Save
 17102                                  ;  character after file name so we can later check to make sure it
 17103                                  ;  isn't a path character.
 17104                                  
 17105                                  ren_no_drive:
 17106 00001AAA BF6C00                  	mov	di,FCB+10h ; 6Ch
 17107                                  				;AC000; set up to parse second file name
 17108                                  	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
 17109 00001AAD B80129                  	mov	ax,2901h
 17110 00001AB0 CD21                    	int	21h		;AC000; do the function
 17111 00001AB2 AC                      	lodsb			;AC000; Load char after filename
 17112 00001AB3 A2[DF8C]                	mov	[One_Char_Val],al
 17113                                  				;AN000; save char after filename
 17114 00001AB6 5E                      	pop	si		;AN000; get line position back
 17115                                  ;
 17116                                  ; We have source and target. See if any args beyond.
 17117                                  ;
 17118 00001AB7 BF[EA85]                	mov	di,PARSE_RENAME
 17119                                  				;AC000; get address of parse_rename
 17120 00001ABA E80B07                  	call	parse_check_eol ;AC000; are we at end of line?
 17121 00001ABD 75E9                    	jnz	short crename_parse_error
 17122                                  				;AN000; no, fail.
 17123                                  
 17124 00001ABF E8E00B                  	call	PathCrunch
 17125 00001AC2 BA[867F]                	mov	dx,BADCPMES_PTR
 17126 00001AC5 74A1                    	jz	short errj2	; If 1st parm a dir, print error msg
 17127 00001AC7 730F                    	jnc	short notest3
 17128 00001AC9 A1[538E]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17129                                  	;cmp	ax,0		;AN022; was message flag set?
 17130 00001ACC 21C0                    	and	ax,ax ; 0 ?
 17131 00001ACE 758D                    	jnz	short extend_setup
 17132                                  				;AN022; yes - print out message
 17133                                  	;cmp	byte [DestIsDir],0
 17134 00001AD0 3806[E78C]              	cmp	[DestIsDir],al	; No CHDIRs worked
 17135 00001AD4 7402                    	jz	short notest3 	; see if they should have
 17136 00001AD6 EB82                    	Jmp	badpath_err	;AC022; set up error
 17137                                  notest3:
 17138 00001AD8 A0[DF8C]                	mov	al,[One_Char_Val]
 17139                                  				;AN000; move char into AX
 17140 00001ADB BA[A47F]                	mov	dx,INORNOT_PTR 
 17141                                  				; Load invalid fname error ptr
 17142 00001ADE E8B30B                  	call	pathchrcmp	; Is the char in al a path sep?
 17143 00001AE1 742B                    	jz	short errj	; Yes, error - 2nd arg must be
 17144                                  				;  filename only.
 17145                                  	;mov	ah,FCB_Rename
 17146 00001AE3 B417                    	mov	ah,17h
 17147 00001AE5 BA5C00                  	mov	dx,FCB ; 5Ch
 17148 00001AE8 CD21                    	int	21h
 17149 00001AEA 3CFF                    	cmp	al,0FFh		; Did an error occur??
 17150 00001AEC 7506                    	jne	short renameok
 17151                                  
 17152 00001AEE E82C02                  	call	get_ext_error_number
 17153                                  				;AN022; get extended error
 17154 00001AF1 50                      	push	ax		;AC022; Save results
 17155 00001AF2 B0FF                    	mov	al,0FFh		; Restore original error state
 17156                                  renameok:
 17157 00001AF4 50                      	push	ax
 17158 00001AF5 E8BB09                  	call	RestUDir
 17159 00001AF8 58                      	pop	ax
 17160 00001AF9 FEC0                    	inc	al
 17161                                  	;;retnz
 17162                                  	;jz	short rn1
 17163                                  	;retn	
 17164 00001AFB 7514                    	jnz	short ret56
 17165                                  rn1:
 17166 00001AFD 58                      	pop	ax		;AC022; get the error number back
 17167 00001AFE 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
 17168                                  				;AN022; error file not found?
 17169 00001B01 7408                    	jz	short use_renerr
 17170                                  				;AN022; yes - use generic error message
 17171 00001B03 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5 
 17172                                  				;AN022; error file not found?
 17173 00001B06 7403                    	jz	short use_renerr
 17174                                  				;AN022; yes - use generic error message
 17175 00001B08 E952FF                  	jmp	extend_setup	;AN022; need long jump - use extended error
 17176                                  
 17177                                  use_renerr:
 17178 00001B0B BA[837F]                	mov	dx,RENERR_PTR	;AC022;
 17179                                  errj:
 17180 00001B0E E9690E                  	jmp	cerror
 17181                                  ret56:
 17182                                  ;typefil_ret:	; 20/02/2023 ; 17/04/2023	
 17183 00001B11 C3                      	retn
 17184                                  
 17185                                  ; 20/02/2023
 17186                                  %if 0
 17187                                  	; MSDOS 3.3
 17188                                  	mov	dx,BADARGSPTR
 17189                                  	call	SCANOFF
 17190                                  	cmp	al,0Dh
 17191                                  	jz	short ERRJ2
 17192                                  	call	PATHCRUNCH
 17193                                  	mov	dx,BADCPMESPTR
 17194                                  	jz	short ERRJ2
 17195                                  	jnb	short CRENAME_NO_PARSE_ERROR
 17196                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17197                                  	jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
 17198                                  	jmp	short BADCDERR
 17199                                  
 17200                                  ;  Get first file name returned from parse into our buffer
 17201                                  
 17202                                  CRENAME_NO_PARSE_ERROR:
 17203                                  	mov	si,[PATHPOS]
 17204                                  	call	SCANOFF
 17205                                  	cmp	al,0Dh
 17206                                  	mov	dx,BADARGSPTR
 17207                                  	jz	short ERRJ
 17208                                  	mov	al,':'
 17209                                  	mov	dx,BADPARMPTR
 17210                                  	cmp	[si+1],al
 17211                                  	jz	short ERRJ
 17212                                  
 17213                                  ;  Get second file name returned from parse into the FCB. Save
 17214                                  ;  character after file name so we can later check to make sure it
 17215                                  ;  isn't a path character.
 17216                                  
 17217                                  REN_NO_DRIVE:
 17218                                  	;mov	di,6Ch
 17219                                  	mov	di,FCB+10h
 17220                                  	mov	ax,(Parse_File_Descriptor<<8)|01h ; 2901h
 17221                                  	int	21h	; DOS -	PARSE FILENAME
 17222                                  			; DS:SI	-> string to parse
 17223                                  			; ES:DI	-> buffer to fill with unopened	FCB
 17224                                  			; AL = bit mask	to control parsing
 17225                                  	mov	al,' '
 17226                                  	;cmp	[6Dh],al
 17227                                  	cmp	[FCB+10h+1],al	; Check if parameter exists
 17228                                  	jz	short ERRJ	; Error if missing parameter
 17229                                  	lodsb
 17230                                  	mov	dx,INORNOTPTR
 17231                                  	call	PATHCHRCMP
 17232                                  	jz	short ERRJ
 17233                                  	mov	ah,FCB_RENAME ; 17h
 17234                                  	mov	dx,FCB ; 5Ch
 17235                                  	int	21h	; DOS -	RENAME FILE via	FCB
 17236                                  			; DS:DX	-> FCB
 17237                                  			; FCB contains new name	starting at byte 17h.
 17238                                  	cmp	al,0FFh		; Did an error occur??	
 17239                                  	jnz	short RENAMEOK
 17240                                  	stc
 17241                                  	mov	dx,RENERRPTR
 17242                                  	call	GET_EXT_ERR_NUMBER ; get extended error
 17243                                  	push	dx
 17244                                  	mov	al,0FFh		; Restore original error state
 17245                                  RENAMEOK:
 17246                                  	push	ax
 17247                                  	call	RESTUDIR
 17248                                  	pop	ax
 17249                                  	inc	al
 17250                                  	jz	short RENAME_ERR
 17251                                  RENAME_RETN:
 17252                                  TYPELP_RET:
 17253                                  	retn
 17254                                  RENAME_ERR:
 17255                                  	pop	dx
 17256                                  ERRJ:				; Retro DOS v3.0
 17257                                  	call	STD_EPRINTF
 17258                                  	jmp	TCOMMAND
 17259                                  
 17260                                  ; ---------------------------------------------------------------------------
 17261                                  
 17262                                  ;ERRJ:
 17263                                  ;	jmp	CERROR
 17264                                  
 17265                                  ; ---------------------------------------------------------------------------
 17266                                  
 17267                                  ;TYPELP_RET:
 17268                                  ;	retn
 17269                                  
 17270                                  %endif
 17271                                  
 17272                                  ; ---------------------------------------------------------------------------
 17273                                  
 17274                                  ;****************************************************************
 17275                                  ;*
 17276                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
 17277                                  ;*		standard output device
 17278                                  ;*
 17279                                  ;* SYNTAX:	TYPE filespec
 17280                                  ;*
 17281                                  ;* FUNCTION:	If a valid filespec is found, read the file until
 17282                                  ;*		1Ah and display the contents to STDOUT.
 17283                                  ;*
 17284                                  ;* INPUT:	command line at offset 81H
 17285                                  ;*
 17286                                  ;* OUTPUT:	none
 17287                                  ;*
 17288                                  ;****************************************************************
 17289                                  
 17290                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17291                                  TYPEFIL:
 17292                                  	; MSDOS 6.0	
 17293                                  	;assume	ds:trangroup,es:trangroup
 17294                                  
 17295 00001B12 BE8100                  	mov	si,81h
 17296 00001B15 BF[6185]                	mov	di,PARSE_MRDIR
 17297                                  				;AN000; Get address of PARSE_MRDIR
 17298 00001B18 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17299 00001B1A 31D2                    	xor	dx,dx		;AN000;
 17300 00001B1C E8BF06                  	call	Parse_With_Msg	;AC018; call parser
 17301                                  	;cmp	ax,RESULT_NO_ERROR
 17302 00001B1F 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17303 00001B21 751E                    	jnz	short typefil_parse_error
 17304                                  				;AN000; yes - issue error message
 17305                                  
 17306 00001B23 56                      	push	si		;AC000; save position in line
 17307 00001B24 C536[1396]              	lds	si,[PARSE1_ADDR]
 17308                                  				;AC000; get address of filespec
 17309 00001B28 E8AB11                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17310 00001B2B 5E                      	pop	si		;AC000; get position back
 17311 00001B2C BF[6185]                	mov	di,PARSE_MRDIR
 17312                                  				;AC000; get address of parse_mrdir
 17313 00001B2F E89606                  	call	parse_check_eol ;AC000; are we at end of line?
 17314                                  	;jz	short gottarg 	;AC000; yes - continue
 17315                                  	; 20/02/2023
 17316                                  ;typefil_parse_error:		;AN000; no - set up error message and exit
 17317                                  	;jmp	cerror
 17318 00001B32 750D                    	jnz	short typefil_parse_error
 17319                                  gottarg:
 17320 00001B34 E8DD0F                  	call	SETPATH
 17321 00001B37 F606[EB8C]02            	test	byte [DestInfo],00000010b ; 2
 17322                                  				; Does the filespec contain wildcards
 17323 00001B3C 7406                    	jz	short nowilds 	; No, continue processing
 17324 00001B3E BA[A47F]                	mov	dx,INORNOT_PTR	; Yes, report error
 17325                                  	; 20/02/2023
 17326                                  typefil_parse_error:
 17327 00001B41 E9360E                  	jmp	cerror
 17328                                  nowilds:
 17329                                  	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
 17330 00001B44 B8006C                  	mov	ax,6C00h
 17331                                  	;mov	bx,read_open_mode ; 0
 17332                                  				;AN000; get open mode for TYPE
 17333 00001B47 31C9                    	xor	cx,cx		;AN000; no special files
 17334 00001B49 89CB                    	mov	bx,cx ; 20/02/2023
 17335 00001B4B BA0101                  	mov	dx,101h
 17336                                  	;mov	dx,read_open_flag ; 101h
 17337                                  				;AN000; set up open flags
 17338 00001B4E BE[4F8D]                	mov	si,SrcBuf	;AN030; get file name
 17339 00001B51 CD21                    	int	21h
 17340 00001B53 7313                    	jnc	short typecont	; If open worked, continue. Otherwise load
 17341                                  
 17342                                  typerr: 			;AN022;
 17343 00001B55 0E                      	push	cs		;AN022; make sure we have local segment
 17344 00001B56 1F                      	pop	ds		;AN022;
 17345 00001B57 E8B301                  	call	Set_Ext_Error_Msg ;AN022;
 17346 00001B5A C706[D08C][4F8D]        	mov	word [string_ptr_2],SrcBuf 
 17347                                  				;AC022; get address of failed string
 17348                                  	;mov	byte [extend_buf_sub],1
 17349 00001B60 C606[777F]01            	mov	byte [extend_buf_sub],one_subst
 17350                                  				;AC022; put number of subst in control block
 17351 00001B65 E9120E                  	jmp	cerror		;AC022; exit
 17352                                  
 17353                                  typecont:
 17354 00001B68 89C3                    	mov	bx,ax		;AC000; get Handle
 17355                                  ;M043
 17356                                  ; We should do the LSEEK for filesize only if this handle belongs to a file
 17357                                  ;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
 17358                                  ;indicate it is a device.
 17359                                  ;
 17360                                  	;mov	ax,(IOCTL shl 8) or 0
 17361 00001B6A B80044                  	mov	ax,4400h
 17362 00001B6D CD21                    	int	21h
 17363                                  
 17364 00001B6F F6C280                  	test	dl,80h		;is it a device?
 17365 00001B72 7408                    	jz	short not_device
 17366                                  				;no, a file
 17367                                  
 17368 00001B74 C706[0D96]FFFF          	mov	word [TypeFilSiz+2],-1
 17369                                  				;indicate it is a device
 17370 00001B7A EB17                    	jmp	short dotype
 17371                                  not_device:
 17372                                  ;SR;
 17373                                  ; Find the filesize by seeking to the end and then reset file pointer to
 17374                                  ;start of file
 17375                                  
 17376                                  	;mov	ax,(LSEEK shl 8) or 2
 17377 00001B7C B80242                  	mov	ax,4202h
 17378 00001B7F 31D2                    	xor	dx,dx
 17379 00001B81 89D1                    	mov	cx,dx		;seek  to end of file
 17380 00001B83 CD21                    	int	21h
 17381                                  
 17382 00001B85 A3[0B96]                	mov	[TypeFilSiz],ax
 17383 00001B88 8916[0D96]              	mov	[TypeFilSiz+2],dx ;store filesize
 17384                                  	;mov	ax,(LSEEK shl 8) or 0
 17385 00001B8C B80042                  	mov	ax,4200h
 17386 00001B8F 31D2                    	xor	dx,dx
 17387 00001B91 CD21                    	int	21h	        ;reset file pointer to start
 17388                                  dotype:				;M043
 17389 00001B93 C606[BD94]00            	mov	byte [zflag],0 	; Reset ^Z flag
 17390 00001B98 8E1E[E28A]              	mov	ds,[TPA]
 17391 00001B9C 31D2                    	xor	dx,dx
 17392                                  	;ASSUME	DS:NOTHING
 17393                                  typelp:
 17394 00001B9E 2E803E[BD94]00          	cmp	byte [cs:zflag],0
 17395                                  				;AC050; Is the ^Z flag set?
 17396                                  	;retnz			; Yes, return
 17397                                  	; 17/04/2023
 17398 00001BA4 7401                    	jz	short tf1
 17399 00001BA6 C3                      	retn
 17400                                  tf1:
 17401 00001BA7 2E8B0E[018B]            	mov	cx,[cs:BYTCNT]	;AC056; No, continue
 17402                                  
 17403                                  ;Update the filesize left to read
 17404                                  
 17405 00001BAC 2E833E[0D96]FF          	cmp	word [cs:TypeFilSiz+2],-1
 17406                                  				;is it a device? M043
 17407 00001BB2 7431                    	je	short typ_read	;yes, just read from it; M043
 17408                                  
 17409 00001BB4 2E833E[0D96]00          	cmp	word [cs:TypeFilSiz+2],0
 17410                                  				;more than 64K left?
 17411 00001BBA 740D                    	jz	short lt64k	;no, do word subtraction
 17412 00001BBC 2E290E[0B96]            	sub	[cs:TypeFilSiz],cx
 17413 00001BC1 2E831E[0D96]00          	sbb	word [cs:TypeFilSiz+2],0
 17414                                  				;update filesize
 17415 00001BC7 EB1C                          	jmp	short typ_read	;do the read
 17416                                  lt64k:
 17417 00001BC9 2E3B0E[0B96]            	cmp	cx,[cs:TypeFilSiz]
 17418                                  				;readsize <= buffer?
 17419 00001BCE 7610                    	jbe	short gtbuf	; yes, just update readsize
 17420                                  
 17421                                  ;Buffer size is larger than bytes to read
 17422                                  
 17423 00001BD0 2E8B0E[0B96]            	mov	cx,[cs:TypeFilSiz]
 17424 00001BD5 E361                    	jcxz	typelp_ret
 17425 00001BD7 2EC706[0B96]0000        	mov	word [cs:TypeFilSiz],0
 17426 00001BDE EB05                    	jmp	short typ_read
 17427                                  gtbuf:
 17428 00001BE0 2E290E[0B96]            	sub	[cs:TypeFilSiz],cx
 17429                                  				;update filesize remaining
 17430                                  typ_read:
 17431                                  	;mov	ah,read
 17432 00001BE5 B43F                    	mov	ah,3Fh
 17433 00001BE7 CD21                    	int	21h		
 17434 00001BE9 7303                    	jnc	short tf2	;M043
 17435 00001BEB E967FF                  	jmp	typerr		;M043
 17436                                  tf2:				;M043
 17437                                  ;M043;	jc	typerr		;AN022; Exit if error
 17438                                  
 17439 00001BEE 89C1                    	mov	cx,ax
 17440 00001BF0 E346                    	jcxz	typelp_ret	;AC000; exit if nothing read
 17441 00001BF2 1E                      	push	ds
 17442 00001BF3 07                      	pop	es		; Check to see if a ^Z was read.
 17443                                  	;assume es:nothing
 17444 00001BF4 31FF                    	xor	di,di
 17445 00001BF6 50                      	push	ax
 17446 00001BF7 B01A                    	mov	al,1Ah
 17447 00001BF9 F2AE                    	repnz	scasb
 17448 00001BFB 58                      	pop	ax
 17449 00001BFC 91                      	xchg	ax,cx
 17450                                  	;cmp	ax,0
 17451 00001BFD 21C0                    	and	ax,ax
 17452 00001BFF 7506                    	jnz	short foundz	; Yes, handle it
 17453 00001C01 807DFF1A                	cmp	byte [di-1],1Ah	; No, double check
 17454 00001C05 750A                    	jnz	short typecont2	; No ^Z, continue
 17455                                  foundz:
 17456 00001C07 29C1                    	sub	cx,ax		; Otherwise change cx so that only those
 17457 00001C09 49                      	dec	cx		;  bytes up to but NOT including the ^Z
 17458 00001C0A 0E                      	push	cs		;  will be typed.
 17459 00001C0B 07                      	pop	es
 17460                                  	;assume es:trangroup
 17461 00001C0C 26F616[BD94]            	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
 17462                                  typecont2:			;  will quit after this write.
 17463 00001C11 53                      	push	bx
 17464 00001C12 BB0100                  	mov	bx,1
 17465                                  	;mov	ah,Write
 17466 00001C15 B440                    	mov	ah,40h
 17467 00001C17 CD21                    	int	21h
 17468 00001C19 5B                      	pop	bx
 17469 00001C1A 720C                    	jc	short Error_outputj
 17470 00001C1C 39C8                    	cmp	ax,cx
 17471 00001C1E 7503                    	jnz	short tf3	;M043
 17472 00001C20 E97BFF                  	jmp	typelp		;M043
 17473                                  tf3:				;M043
 17474                                  ;M043;	jz	short typelp
 17475 00001C23 49                      	dec	cx
 17476 00001C24 39C8                    	cmp	ax,cx
 17477                                  	;;retz			; One less byte OK (^Z)
 17478                                  	;jnz	short Error_outputj
 17479                                  ;tf4:
 17480                                  	;retn
 17481 00001C26 7410                    	jz	short typelp_ret ; 20/02/2023
 17482                                  
 17483                                  Error_outputj:
 17484 00001C28 BB0100                  	mov	bx,1
 17485                                  	;mov	ax,IOCTL SHL 8
 17486 00001C2B B80044                  	mov	ax,4400h
 17487 00001C2E CD21                    	int	21h
 17488 00001C30 F6C280                  	test	dl,80h
 17489                                  	;test	dl,devid_ISDEV
 17490                                  	;;retnz			; If device, no error message
 17491                                  	;jnz	short tf4
 17492 00001C33 7503                    	jnz	short typelp_ret
 17493 00001C35 E9420A                  	jmp	error_output
 17494                                  typelp_ret:
 17495 00001C38 C3                      	retn
 17496                                  
 17497                                  ; 20/02/2023
 17498                                  %if 0
 17499                                  	; MSDOS 3.3
 17500                                  	mov	si,81h
 17501                                  	call	SCANOFF		; Skip to first non-delim
 17502                                  	cmp	al,0Dh
 17503                                  	jnz	short GOTTARG
 17504                                  	mov	dx,BADARGSPTR
 17505                                  
 17506                                  	;jmp	CERROR
 17507                                  	jmp	short ERRJ	; No args
 17508                                  GOTTARG:
 17509                                  	call	SETPATH
 17510                                  	test	byte [DESTINFO],2
 17511                                  	jz	short NOWILDS
 17512                                  	mov	dx,INORNOTPTR
 17513                                  
 17514                                  	;jmp	CERROR
 17515                                  	jmp	short ERRJ
 17516                                  NOWILDS:
 17517                                  	mov	ax,OPEN*256 ; 3D00h
 17518                                  	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 17519                                  			; DS:DX	-> ASCIZ filename
 17520                                  			; AL = access mode
 17521                                  			; 0 - read
 17522                                  	jnc	short TYPECONT
 17523                                  	mov	dx,FNOTFOUNDPTR
 17524                                  	cmp	ax,2
 17525                                  	jz	short ERRJ
 17526                                  	mov	dx,BADCPMESPTR
 17527                                  	stc
 17528                                  	call	GET_EXT_ERR_NUMBER
 17529                                  	
 17530                                  	;jmp	CERROR
 17531                                  	jmp	short ERRJ
 17532                                  TYPECONT:
 17533                                  	mov	byte [ZFLAG],0	; Reset ^Z flag
 17534                                  	mov	bx,ax		; Handle
 17535                                  	mov	ds,[TPA]
 17536                                  	xor	dx,dx
 17537                                  TYPELP:
 17538                                  	cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
 17539                                  	jnz	short RENAME_RETN ; Yes, return	
 17540                                  	mov	cx,[cs:BYTCNT]	; No, continue
 17541                                  	mov	ah,READ ; 3Fh
 17542                                  	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 17543                                  			; BX = file handle,CX = number	of bytes to read
 17544                                  			; DS:DX	-> buffer
 17545                                  	mov	cx,ax
 17546                                  	jcxz	TYPELP_RET	; exit if nothing read
 17547                                  				; Check to see if a ^Z was read.
 17548                                  	push	ds
 17549                                  	pop	es		
 17550                                  	xor	di,di
 17551                                  	push	ax
 17552                                  	mov	al,1Ah
 17553                                  	repne	scasb
 17554                                  	pop	ax
 17555                                  	xchg	ax,cx
 17556                                  	cmp	ax,0
 17557                                  	jnz	short FOUNDZ	; Yes, handle it
 17558                                  	cmp	byte [di-1],1Ah	; No, double check
 17559                                  	jnz	short TYPECONT2	; No ^Z, continue
 17560                                  FOUNDZ:
 17561                                  	sub	cx,ax		; Otherwise change cx so that only those
 17562                                  	dec	cx		;  bytes up to but NOT including the ^Z
 17563                                  	push	cs		;  will be typed.
 17564                                  	pop	es
 17565                                  	not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
 17566                                  				;  will quit after this write.
 17567                                  TYPECONT2:
 17568                                  	push	bx
 17569                                  	mov	bx,1
 17570                                  	mov	ah,WRITE ; 40h
 17571                                  	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 17572                                  			; BX = file handle, CX = number of bytes to write,
 17573                                  			; DS:DX -> buffer
 17574                                  	pop	bx
 17575                                  	jc	short ERROR_OUTPUTJ
 17576                                  	cmp	ax,cx
 17577                                  	jz	short TYPELP
 17578                                  	dec	cx
 17579                                  	cmp	ax,cx		; One less byte OK (^Z)
 17580                                  	jnz	short ERROR_OUTPUTJ
 17581                                  TYPEFIL_RETN:
 17582                                  	retn
 17583                                  ERROR_OUTPUTJ:
 17584                                  	mov	bx,1
 17585                                  	mov	ax,IOCTL*256 ; 4400h
 17586                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 17587                                  			; BX = file or device handle
 17588                                  	;test	dl,devid_ISDEV
 17589                                  	test	dl,80h
 17590                                  	jnz	short TYPEFIL_RETN ; If device, no error message
 17591                                  	jmp	ERROR_OUTPUT
 17592                                  %endif
 17593                                  
 17594                                  ; ---------------------------------------------------------------------------
 17595                                  
 17596                                  ; VOLUME command displays the volume ID on the specified drive
 17597                                  
 17598                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17599                                  VOLUME:
 17600                                  	; MSDOS 6.0
 17601 00001C39 BE8100                  	mov	si,81h
 17602 00001C3C BF[4F85]                	mov	di,PARSE_VOL
 17603                                  				;AN000; Get address of PARSE_VOL
 17604 00001C3F 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17605 00001C41 31D2                    	xor	dx,dx		;AN000;
 17606 00001C43 E89805                  	call	Parse_With_Msg	;AC018; call parser
 17607 00001C46 83F8FF                  	cmp	ax,-1
 17608                                  	;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 17609 00001C49 7444                    	je	short OkVolArg	;AC000; Yes, display default volume ID
 17610                                  	;cmp	ax,RESULT_NO_ERROR
 17611                                  	;cmp	ax,0		;AC000; did we have an error?
 17612 00001C4B 09C0                    	or	ax,ax ; 0?
 17613 00001C4D 750A                    	jnz	short badvolarg	;AC000; Yes, fail.
 17614                                  
 17615                                  ; We have parsed off the drive. See if there are any more chars left
 17616                                  
 17617 00001C4F BF[4F85]                	mov	di,PARSE_VOL
 17618                                  				;AC000; get address of parse_vol
 17619 00001C52 31D2                    	xor	dx,dx		;AC000;
 17620 00001C54 E87105                  	call	parse_check_eol ;AC000; call parser
 17621 00001C57 7436                    	jz	short OkVolArg	;AC000; yes, end of road
 17622                                  
 17623                                  ; The line was not interpretable. Report an error.
 17624                                  
 17625                                  badvolarg:
 17626 00001C59 E91E0D                  	jmp	cerror
 17627                                  
 17628                                  ; 20/02/2023
 17629                                  %if 0
 17630                                  	; MSDOS 3.3
 17631                                  	mov	si,81h
 17632                                  	call	SCANOFF		; Skip to first non-delim
 17633                                  	;mov	ah,[5Ch]
 17634                                  	mov	ah,[FCB]
 17635                                  	;mov	byte [5Ch],0
 17636                                  	mov	byte [FCB],0
 17637                                  	cmp	al,0Dh		; are we at end of line?
 17638                                  	jz	short OKVOLARG	; Yes, display default volume ID
 17639                                  	;mov	[5Ch],ah
 17640                                  	mov	[FCB],ah
 17641                                  	lodsb
 17642                                  	lodsb
 17643                                  	cmp	al,':'
 17644                                  	jnz	short VOLUME_ERR
 17645                                  	call	SCANOFF
 17646                                  	cmp	al,0Dh
 17647                                  	jz	short OKVOLARG
 17648                                  VOLUME_ERR:
 17649                                  	mov	dx,BADDRVPTR
 17650                                  	jmp	CERROR
 17651                                  
 17652                                  ; ---------------------------------------------------------------------------
 17653                                  
 17654                                  OKVOLARG:
 17655                                  	call	CRLF2
 17656                                  	push	ds
 17657                                  	pop	es
 17658                                  	;mov	di,55h
 17659                                  	mov	di,FCB-7	; Set up extended FCB
 17660                                  	mov	al,-1
 17661                                  	stosb
 17662                                  	xor	ax,ax
 17663                                  	stosw
 17664                                  	stosw
 17665                                  	stosb
 17666                                  	mov	al,8		; Look for volume label
 17667                                  	stosb
 17668                                  	inc	di		; Skip drive byte
 17669                                  	mov	cx,11
 17670                                  	mov	al,'?'
 17671                                  	rep stosb
 17672                                  	mov	dx,DIRBUF
 17673                                  	mov	ah,Set_DMA ; 1Ah
 17674                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 17675                                  			; DS:DX	-> disk	transfer buffer
 17676                                  	;mov	dx,55h
 17677                                  	mov	dx,FCB-7
 17678                                  	mov	ah,Dir_Search_First ; 11h
 17679                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 17680                                  			; DS:DX	-> FCB
 17681                                  	jmp	PRINTVOL
 17682                                  %endif
 17683                                  
 17684                                  ; ---------------------------------------------------------------------------
 17685                                  
 17686                                  ;***	DisAppend - disable APPEND
 17687                                  ;
 17688                                  ;	ENTRY	nothing
 17689                                  ;
 17690                                  ;	EXIT	nothing
 17691                                  ;
 17692                                  ;	USED	AX,BX
 17693                                  ;
 17694                                  ;	EFFECTS
 17695                                  ;
 17696                                  ;	  APPEND is disabled. If it was active, it will be re-enabled
 17697                                  ;	  after the command finishes, by the HeadFix routine.
 17698                                  ;
 17699                                  ;	NOTE
 17700                                  ;
 17701                                  ;	  This routine must not be called more than once during a single
 17702                                  ;	  command cycle. The second call would permanently disable APPEND.
 17703                                  
 17704                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17705                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh
 17706                                  
 17707                                  	; MSDOS 6.0
 17708                                  DisAppend:
 17709 00001C5C 1E                      	push	ds			; save DS
 17710 00001C5D 06                      	push	es			; save ES
 17711 00001C5E 57                      	push	di
 17712                                  
 17713                                  	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
 17714 00001C5F B800B7                  	mov	ax,0B700h
 17715 00001C62 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17716 00001C64 08C0                    	or	al,al
 17717 00001C66 7423                    	jz	short daRet		; APPEND not installed, return
 17718                                  
 17719                                  	;mov	ax,APPENDDOS		; AX = Get Append Version code
 17720 00001C68 B802B7                  	mov	ax,0B702h
 17721 00001C6B CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17722 00001C6D 83F8FF                  	cmp	ax,0FFFFh
 17723 00001C70 7519                    	jne	short daRet		; it's not a local version, return
 17724                                  
 17725                                  	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
 17726 00001C72 B806B7                  	mov	ax,0B706h
 17727 00001C75 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17728                                  
 17729 00001C77 8E1E[E08A]              	mov	ds,[RESSEG]		; DS = resident seg addr
 17730                                  
 17731 00001C7B 891E[C301]              	mov	[Append_State],bx	; Append_State = saved APPEND state
 17732 00001C7F C606[C501]FF            	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state
 17733                                  
 17734 00001C84 31DB                    	xor	bx,bx			; BX = APPEND state = off
 17735                                  	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
 17736 00001C86 B807B7                  	mov	ax,0B707h
 17737 00001C89 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17738                                  daRet:	
 17739 00001C8B 5F                      	pop	di
 17740 00001C8C 07                      	pop	es			; restore ES
 17741 00001C8D 1F                      	pop	ds			; restore DS
 17742                                  
 17743 00001C8E C3                      	retn
 17744                                  
 17745                                  ; ---------------------------------------------------------------------------
 17746                                  
 17747                                  ; Find the Volume ID on the disk.
 17748                                  
 17749                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17750                                  
 17751                                  	; MSDOS 6.0
 17752                                  OkVolArg:
 17753 00001C8F E8CAFF                  	call	DisAppend		; disable APPEND
 17754 00001C92 E86409                  	call	CRLF2
 17755                                  	;mov	al,blank			
 17756 00001C95 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 17757 00001C97 E87D01                  	call	PRINT_CHAR		;AN051;  before volume message
 17758 00001C9A 1E                      	push	ds
 17759 00001C9B 07                      	pop	es
 17760                                  
 17761                                  ; Volume IDs are only findable via extended FCBs or find_first with attributes
 17762                                  ; of volume_id ONLY.
 17763                                  
 17764 00001C9C BF5500                  	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
 17765 00001C9F B0FF                    	mov	al,-1			; Tag to indicate Extention
 17766 00001CA1 AA                      	stosb
 17767 00001CA2 31C0                    	xor	ax,ax			; Zero padding to volume label
 17768 00001CA4 AB                      	stosw
 17769 00001CA5 AB                      	stosw
 17770 00001CA6 AA                      	stosb
 17771 00001CA7 B008                    	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
 17772 00001CA9 AA                      	stosb
 17773 00001CAA 47                      	inc	di			; Skip drive byte; it is already set
 17774 00001CAB B90B00                  	mov	cx,11			; fill in remainder of file
 17775 00001CAE B03F                    	mov	al,'?'
 17776 00001CB0 F3AA                    	rep	stosb
 17777                                  
 17778                                  ; Set up transfer address (destination of search first information)
 17779                                  
 17780 00001CB2 BA[E98B]                	mov	dx,DIRBUF
 17781                                  	;mov	ah,Set_DMA
 17782 00001CB5 B41A                    	mov	ah,1Ah
 17783 00001CB7 CD21                    	int	21h
 17784                                  
 17785                                  ; Do the search
 17786                                  
 17787 00001CB9 BA5500                  	mov	dx,FCB-7 ; 55h
 17788                                  	;mov	ah,Dir_Search_First
 17789 00001CBC B411                    	mov	ah,11h
 17790 00001CBE CD21                    	int	21h
 17791                                  
 17792                                  ;********************************
 17793                                  ; Print volume ID info
 17794                                  
 17795 00001CC0 50                      	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
 17796 00001CC1 A05C00                  	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
 17797 00001CC4 0440                    	add	al,'@'  ; add al,40h
 17798 00001CC6 3C40                    	cmp	al,'@'
 17799 00001CC8 7505                    	jne	short drvok
 17800 00001CCA A0[F48A]                	mov	al,[CURDRV]
 17801                                  	;add	al,capital_A
 17802 00001CCD 0441                    	add	al,'A'
 17803                                  drvok:
 17804 00001CCF A2[E18C]                	mov	[vol_drv],al		;AC000; get drive letter into argument
 17805 00001CD2 58                      	pop	ax			;AC000; get return code back
 17806 00001CD3 08C0                    	or	al,al			;AC000; volume label found?
 17807 00001CD5 7405                    	jz	short Get_vol_name	;AC000; volume label exists - go get it
 17808 00001CD7 BA[7080]                	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
 17809 00001CDA EB13                    	jmp	short print_serial	;AC000; go print it
 17810                                  
 17811                                  Get_vol_name:
 17812 00001CDC BF[1A8B]                	mov	di,CHARBUF
 17813 00001CDF 89FA                    	mov	dx,di
 17814 00001CE1 BE[F18B]                	mov	si,DIRBUF+8		;AN000;  3/3/KK
 17815 00001CE4 B90B00                  	mov	cx,11			;AN000;  3/3/KK
 17816 00001CE7 F3A4                    	rep	movsb			;AN000;  3/3/KK
 17817                                  
 17818 00001CE9 30C0                    	xor	al,al			;AC000; store a zero to terminate the string
 17819 00001CEB AA                      	stosb
 17820 00001CEC BA[7E80]                	mov	dx,VolMes_Ptr		;AC000; set up message
 17821                                  
 17822                                  print_serial:
 17823                                  
 17824                                  ; Attempt to get the volume serial number from the disk. If an error
 17825                                  ; occurs, do not print volume serial number.
 17826                                  
 17827 00001CEF 52                      	push	dx			;AN000; save message offset
 17828                                  	;mov	ax,(GetSetMediaID SHL 8)
 17829 00001CF0 B80069                  	mov	ax,6900h		;AC036; Get the volume serial info
 17830 00001CF3 8A1E5C00                	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
 17831 00001CF7 BA[388E]                	mov	dx,vol_ioctl_buf	;AN000;target buffer
 17832 00001CFA CD21                    	int	21h			;AN000; do the call
 17833                                  			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
 17834                                  			; AL = 00h get serial number / 01h set serial number
 17835                                  			; BL = drive (0=default, 1=A, 2=B, etc)
 17836                                  			; DS:DX -> disk info
 17837 00001CFC 5A                      	pop	dx			;AN000; get message offset back
 17838 00001CFD 720B                    	jc	short printvol_end	;AN000; if error, just go print label
 17839 00001CFF E84131                  	call	std_printf		;AC000; go print volume message
 17840                                  	;mov	al,blank				
 17841 00001D02 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 17842 00001D04 E81001                  	call	PRINT_CHAR		;AN051;  before volume message
 17843 00001D07 BA[9780]                	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
 17844                                  printvol_end:
 17845 00001D0A E93631                  	jmp	std_printf		;AC000; go print and exit
 17846                                  
 17847                                  ; ---------------------------------------------------------------------------
 17848                                  
 17849                                  ;****************************************************************
 17850                                  ;*
 17851                                  ;* ROUTINE:	Set_ext_error_msg
 17852                                  ;*
 17853                                  ;* FUNCTION:	Sets up extended error message for printing
 17854                                  ;*
 17855                                  ;* INPUT:	return from INT 21
 17856                                  ;*
 17857                                  ;* OUTPUT:	extended error message set up in extended error
 17858                                  ;*		buffer.
 17859                                  ;*
 17860                                  ;****************************************************************
 17861                                  	
 17862                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17863                                  
 17864                                  	; MSDOS 6.0
 17865                                  Set_Ext_Error_Msg:			;AN000;
 17866 00001D0D E80D00                  	call	get_ext_error_number	;AC022; get the extended error
 17867 00001D10 C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class
 17868                                  	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
 17869 00001D15 BA[757F]                	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
 17870 00001D18 A3[757F]                	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
 17871 00001D1B F9                      	stc				;AN000; make sure carry is set
 17872 00001D1C C3                      	retn				;AN000; return
 17873                                  
 17874                                  ; ---------------------------------------------------------------------------
 17875                                  
 17876                                  ;****************************************************************
 17877                                  ;*
 17878                                  ;* ROUTINE:	Get_ext_error_number
 17879                                  ;*
 17880                                  ;* FUNCTION:	Does get extended error function call
 17881                                  ;*
 17882                                  ;* INPUT:	return from INT 21
 17883                                  ;*
 17884                                  ;* OUTPUT:	AX - extended error number
 17885                                  ;*
 17886                                  ;****************************************************************
 17887                                  
 17888                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17889                                  
 17890                                  	; MSDOS 6.0
 17891                                  get_ext_error_number:			;AN022;
 17892                                  
 17893                                  	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
 17894                                  					;AN022; save registers
 17895 00001D1D 53                      	push	bx
 17896 00001D1E 51                      	push	cx
 17897 00001D1F 52                      	push	dx
 17898 00001D20 56                      	push	si
 17899 00001D21 57                      	push	di
 17900 00001D22 55                      	push	bp
 17901 00001D23 06                      	push	es
 17902 00001D24 1E                      	push	ds
 17903                                  	;mov	ah,GetExtendedError	;AN022; get extended error
 17904 00001D25 B459                    	mov	ah,59h
 17905 00001D27 31DB                    	xor	bx,bx			;AN022; clear BX
 17906 00001D29 CD21                    	int	21h			;AN022;
 17907                                  			; DOS - 3+ - GET EXTENDED ERROR CODE
 17908                                  			; BX = version code (0000h for DOS 3.x)
 17909                                  
 17910                                  	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
 17911                                  					;AN022; restore registers
 17912 00001D2B 1F                      	pop	ds
 17913 00001D2C 07                      	pop	es
 17914 00001D2D 5D                      	pop	bp
 17915 00001D2E 5F                      	pop	di
 17916 00001D2F 5E                      	pop	si
 17917 00001D30 5A                      	pop	dx
 17918 00001D31 59                      	pop	cx
 17919 00001D32 5B                      	pop	bx
 17920                                  
 17921 00001D33 C3                      	retn				;AN022; return
 17922                                  
 17923                                  ;============================================================================
 17924                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
 17925                                  ;============================================================================
 17926                                  ; 08/10/2018 - Retro DOS v3.0
 17927                                  
 17928                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
 17929                                  
 17930                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 17931                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h
 17932                                  
 17933                                  ; ---------------------------------------------------------------------------
 17934                                  
 17935                                  ; MSDOS 6.0
 17936                                  ;***	Version - display DOS version
 17937                                  ;
 17938                                  ;	SYNTAX	ver [/debug]
 17939                                  ;
 17940                                  ;		/debug - display additional DOS configuration info
 17941                                  ;
 17942                                  ;	ENTRY	command-line tail is in PSP
 17943                                  ;
 17944                                  ;	EXIT	if successful, nothing
 17945                                  ;		if parse fails,
 17946                                  ;		  parse error message is set up (for Std_EPrintf)
 17947                                  ;		    AX = system parser error code
 17948                                  ;		    DX = ptr to message block
 17949                                  ;		  we jump to CError
 17950                                  ;
 17951                                  ;	EFFECTS
 17952                                  ;	  If parse fails, a parse error message is displayed.
 17953                                  ;	  Otherwise, version message is displayed.
 17954                                  ;	  If /debug is specified, additional DOS info is displayed.
 17955                                  
 17956                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17957                                  VERSION:
 17958                                  	;assume	ds:TRANGROUP,es:TRANGROUP
 17959                                  
 17960                                  ;	Parse command line for /debug switch.
 17961                                  
 17962 00001D34 BE8100                  	mov	si,81h			; DS:SI = ptr to command tail
 17963 00001D37 BF[0786]                	mov	di,PARSE_VER		; ES:DI = ptr to parse block
 17964 00001D3A 31C9                    	xor	cx,cx			; CX = # positional param's found
 17965 00001D3C E89F04                  	call	Parse_With_Msg
 17966                                  
 17967 00001D3F B301                    	mov	bl,1			; BL = flag = /debug present
 17968                                  	;cmp	ax,RESULT_NO_ERROR
 17969                                  	;cmp	ax,0
 17970                                  	;je	short verPrintVer	; something parsed - must be /debug
 17971 00001D41 09C0                    	or	ax,ax
 17972 00001D43 740A                    	jz	short verPrintVer 
 17973 00001D45 FECB                    	dec	bl			; BL = flag = no /debug present
 17974                                  	;cmp	ax,END_OF_LINE ; -1
 17975 00001D47 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 17976 00001D4A 7403                    	je	short verPrintVer	; reached end of line - ok
 17977                                  
 17978                                  ;	The parse failed. Error message has been set up.
 17979                                  
 17980 00001D4C E92B0C                  	jmp	cerror
 17981                                  
 17982                                  verPrintVer:
 17983 00001D4F 53                      	push	bx			; save /debug flag
 17984 00001D50 E8A608                  	call	CRLF2
 17985 00001D53 E83F00                  	call	PRINT_VERSION
 17986 00001D56 E8A008                  	call	CRLF2
 17987 00001D59 5B                      	pop	bx   			; BL = /debug flag
 17988 00001D5A 08DB                    	or	bl,bl
 17989 00001D5C 7434                    	jz	short verDone		; /debug is false - we're done
 17990                                  
 17991                                  ;*	For /debug, display DOS internal revision and DOS location
 17992                                  ;	(low memory, HMA, or ROM).
 17993                                  
 17994                                  ;	Bugbug:	use symbols for bitmasks below.
 17995                                  
 17996                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
 17997 00001D5E B80633                  	mov	ax,3306h
 17998 00001D61 CD21                    	int	21h
 17999                                  		; DOS - 5+ Get TRUE Version Number
 18000                                  		; (BL major, BH minor, DL revision, DH flags)
 18001 00001D63 88D0                    	mov	al,dl			;revision number in dl; M013
 18002 00001D65 88F7                    	mov	bh,dh			;flags in dh now; M013
 18003                                  ;M032	and	al,7			; AL = DOS internal revision
 18004 00001D67 3C19                    	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
 18005                                  	;jbe	short @f	 ;M032	; A-to-Z revision ok
 18006 00001D69 7602                    	jbe	short ver1
 18007 00001D6B B0E9                    	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
 18008                                  ;@@:
 18009                                  ver1:
 18010 00001D6D 0441                    	add	al,'A' ; 41h		; AL = DOS internal rev letter
 18011 00001D6F A2[DF8C]                	mov	[One_Char_Val],al
 18012 00001D72 BA[C581]                	mov	dx,dosrev_ptr
 18013 00001D75 E8CB30                  	call	std_printf		; print DOS internal revision
 18014                                  
 18015 00001D78 B104                    	mov	cl,4
 18016 00001D7A D2EF                    	shr	bh,cl			; CY = DOS in ROM
 18017 00001D7C 7209                    	jc	short verRom
 18018 00001D7E D0EF                    	shr	bh,1			; CY = DOS in HMA
 18019 00001D80 720A                    	jc	short verHma
 18020                                  
 18021                                  ;	DOS isn't in ROM or HMA, so it must be in lower memory.
 18022                                  
 18023                                  	;mov	dx,offset TRANGROUP:DosLow_Ptr
 18024 00001D82 BA[D981]                	mov	dx,DosLow_Ptr
 18025 00001D85 EB08                    	jmp	short verPrintLoc
 18026                                  verRom: 
 18027                                  	;mov	dx,offset TRANGROUP:DosRom_Ptr
 18028 00001D87 BA[D381]                	mov	dx,DosRom_Ptr
 18029 00001D8A EB03                    	jmp	short verPrintLoc
 18030                                  verHma: 
 18031                                  	;mov	dx,offset TRANGROUP:DosHma_Ptr
 18032 00001D8C BA[D681]                	mov	dx,DosHma_Ptr
 18033                                  verPrintLoc:
 18034 00001D8F E8B130                  	call	std_printf
 18035                                  verDone:
 18036 00001D92 E96408                  	jmp	CRLF2
 18037                                  
 18038                                  ; 21/02/2023
 18039                                  ;	; MSDOS 3.3
 18040                                  ;VERSION:
 18041                                  ;	call	CRLF2
 18042                                  ;	call	PRINT_VERSION
 18043                                  ;	jmp	CRLF2
 18044                                  
 18045                                  ; =============== S U B	R O U T	I N E =======================================
 18046                                  
 18047                                  	; 21/02/2023 - Retro DOS v4.0
 18048                                  PRINT_VERSION:
 18049                                  	;mov	ah,GET_VERSION ; 30h
 18050 00001D95 B430                    	mov	ah,30h
 18051 00001D97 CD21                    	int	21h	; DOS -	GET DOS	VERSION
 18052                                  			; Return: AL = major version number (00h for DOS 1.x)
 18053 00001D99 50                      	push	ax
 18054 00001D9A 30E4                    	xor	ah,ah
 18055 00001D9C A3[DB8C]                	mov	[Major_Ver_Num],ax
 18056 00001D9F 58                      	pop	ax
 18057 00001DA0 86E0                    	xchg	ah,al
 18058 00001DA2 30E4                    	xor	ah,ah
 18059 00001DA4 A3[DD8C]                	mov	[Minor_Ver_Num],ax
 18060 00001DA7 BA[5780]                	mov	dx,VerMes_Ptr
 18061 00001DAA E99630                  	jmp	std_printf
 18062                                  
 18063                                  ; =============== S U B	R O U T	I N E =======================================
 18064                                  
 18065                                  	; 21/02/2023 - Retro DOS v4.0
 18066                                  PRINT_PROMPT:
 18067 00001DAD 1E                      	push	ds
 18068 00001DAE 0E                      	push	cs
 18069 00001DAF 1F                      	pop	ds		; Make sure Ds is in TRANGROUP
 18070 00001DB0 06                      	push	es
 18071 00001DB1 E88305                  	call	find_prompt	; Look for prompt string
 18072 00001DB4 7206                    	jc	short PP0	; Can't find one	
 18073 00001DB6 26803D00                	cmp	byte [es:di],0
 18074 00001DBA 7524                    	jnz	short PP1
 18075                                  PP0:				; Use default prompt
 18076 00001DBC E86700                  	call	PRINT_DRIVE
 18077 00001DBF B03E                    	mov	al,'>'
 18078                                  	;mov	al,SYM
 18079 00001DC1 E85300                  	call	PRINT_CHAR
 18080 00001DC4 EB36                    	jmp	short PP5
 18081                                  ;PP1:
 18082                                  ;	mov	al,[es:di]	; Get a char
 18083                                  ;	inc	di
 18084                                  ;	or	al,al
 18085                                  ;	jz	short PP5	; Nul terminated
 18086                                  ;	; 21/02/2023
 18087                                  ;	cmp	al,'$' ; 24h
 18088                                  ;	;cmp	al,[DOLLAR]	; Meta character
 18089                                  ;	jz	short PP2	; Nope
 18090                                  ;	call	PRINT_CHAR
 18091                                  ;	jmp	short PP1
 18092                                  PP2:
 18093 00001DC6 268A05                  	mov	al,[es:di]
 18094 00001DC9 47                      	inc	di
 18095                                  	;mov	bx,CLSSTRING+2	; "[2J"
 18096 00001DCA BB[E382]                	mov	bx,PROMPT_TABLE-3
 18097 00001DCD 08C0                    	or	al,al
 18098 00001DCF 742B                    	jz	short PP5
 18099                                  PP3:
 18100 00001DD1 83C303                  	add	bx,3
 18101                                  	; 21/02/2023
 18102 00001DD4 E83706                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 18103                                  	;call	UPCONV_MAPCALL  ; MSDOS 3.3
 18104 00001DD7 3A07                    	cmp	al,[bx]
 18105 00001DD9 7416                    	jz	short PP4
 18106 00001DDB 803F00                  	cmp	byte [bx],0
 18107 00001DDE 75F1                    	jnz	short PP3
 18108                                  	;jmp	short PP1
 18109                                  	; 21/02/2023
 18110                                  PP1:
 18111 00001DE0 268A05                  	mov	al,[es:di]	; Get a char
 18112 00001DE3 47                      	inc	di
 18113 00001DE4 08C0                    	or	al,al
 18114 00001DE6 7414                    	jz	short PP5	; Nul terminated
 18115                                  	; 21/02/2023
 18116 00001DE8 3C24                    	cmp	al,'$' ; 24h
 18117                                  	;cmp	al,[DOLLAR]	; Meta character
 18118 00001DEA 74DA                    	jz	short PP2	; Nope
 18119 00001DEC E82800                  	call	PRINT_CHAR
 18120 00001DEF EBEF                    	jmp	short PP1
 18121                                  PP4:
 18122 00001DF1 06                      	push	es
 18123 00001DF2 57                      	push	di
 18124 00001DF3 0E                      	push	cs
 18125 00001DF4 07                      	pop	es
 18126 00001DF5 FF5701                  	call	word [bx+1]
 18127 00001DF8 5F                      	pop	di
 18128 00001DF9 07                      	pop	es
 18129 00001DFA EBE4                    	jmp	short PP1
 18130                                  PP5:
 18131 00001DFC 07                      	pop	es		; Restore segments
 18132 00001DFD 1F                      	pop	ds
 18133 00001DFE C3                      	retn
 18134                                  
 18135                                  ; ---------------------------------------------------------------------------
 18136                                  
 18137                                  PRINT_BACK:
 18138                                  	; 21/02/2023
 18139 00001DFF BA[5181]                	mov	dx,dback_ptr
 18140 00001E02 E93E30                  	jmp	std_printf
 18141                                  
 18142                                  ; ---------------------------------------------------------------------------
 18143                                  
 18144                                  PRINT_EQ:
 18145 00001E05 B03D                    	mov	al,'='
 18146 00001E07 EB0E                    	jmp	short PRINT_CHAR
 18147                                  
 18148                                  ; ---------------------------------------------------------------------------
 18149                                  
 18150                                  PRINT_ESC:
 18151 00001E09 B01B                    	mov	al,1Bh
 18152 00001E0B EB0A                    	jmp	short PRINT_CHAR
 18153                                  
 18154                                  ; ---------------------------------------------------------------------------
 18155                                  
 18156                                  	; 21/02/2023
 18157                                  PRINT_G:
 18158                                  	;mov	al,[RABRACKET]
 18159 00001E0D B03E                    	mov	al,'>' ; 3Eh
 18160 00001E0F EB06                    	jmp	short PRINT_CHAR
 18161                                  
 18162                                  ; ---------------------------------------------------------------------------
 18163                                  
 18164                                  	; 21/02/2023
 18165                                  PRINT_L:
 18166                                  	;mov	al,[LABRACKET]
 18167 00001E11 B03C                    	mov	al,'<' ; 3Ch
 18168 00001E13 EB02                    	jmp	short PRINT_CHAR
 18169                                  
 18170                                  ; ---------------------------------------------------------------------------
 18171                                  
 18172                                  	; 21/02/2023
 18173                                  Print_B:
 18174                                  	;mov	al,[VBAR]
 18175 00001E15 B07C                    	mov	al,'|' ; 7Ch
 18176                                  
 18177                                  ; =============== S U B	R O U T	I N E =======================================
 18178                                  
 18179                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18180                                  PRINT_CHAR:
 18181                                  	; MSDOS 6.0
 18182                                  
 18183                                  ;	Bugbug:	Why bother with ds,es here?
 18184                                  		
 18185 00001E17 06                      	push	es
 18186 00001E18 1E                      	push	ds
 18187 00001E19 07                      	pop	es
 18188 00001E1A 57                      	push	di
 18189 00001E1B 52                      	push	dx
 18190 00001E1C 88C2                    	mov	dl,al		;AC000; Get char into al
 18191                                  	;mov	ah,STD_CON_OUTPUT
 18192                                  				;AC000; print the char to stdout
 18193 00001E1E B402                    	mov	ah,2
 18194 00001E20 CD21                    	int	21h		;AC000;
 18195 00001E22 5A                      	pop	dx
 18196 00001E23 5F                      	pop	di
 18197 00001E24 07                      	pop	es
 18198 00001E25 C3                      	retn
 18199                                  
 18200                                  ;21/02/2023
 18201                                  %if 0
 18202                                  	; MSDOS 3.3
 18203                                  	push	es
 18204                                  	push	ds
 18205                                  	pop	es
 18206                                  	push	di
 18207                                  	push	dx
 18208                                  	mov	di,ONE_CHAR_VAL	
 18209                                  	stosb
 18210                                  	mov	dx,ONECHRVALPTR
 18211                                  	call	STD_PRINTF
 18212                                  	pop	dx
 18213                                  	pop	di
 18214                                  	pop	es
 18215                                  	retn
 18216                                  %endif
 18217                                  
 18218                                  ; ---------------------------------------------------------------------------
 18219                                  
 18220                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18221                                  PRINT_DRIVE:
 18222                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 18223 00001E26 B419                    	mov	ah,19h
 18224 00001E28 CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
 18225 00001E2A 0441                    	add	al,'A'
 18226                                  	;add	al,[CAPITAL_A]
 18227                                  	;call	PRINT_CHAR
 18228                                  	;retn
 18229                                  	; 21/02/2023
 18230 00001E2C EBE9                    	jmp	short PRINT_CHAR
 18231                                  
 18232                                  ; ---------------------------------------------------------------------------
 18233                                  
 18234                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18235                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h
 18236                                  
 18237                                  build_dir_for_prompt:
 18238 00001E2E 30D2                    	xor	dl,dl
 18239 00001E30 BE[E98B]                	mov	si,BWDBUF
 18240 00001E33 89F7                    	mov	di,si
 18241 00001E35 A0[F48A]                	mov	al,[CURDRV]
 18242 00001E38 0441                    	add	al,'A'
 18243 00001E3A B43A                    	mov	ah,':'
 18244 00001E3C AB                      	stosw
 18245 00001E3D A0[E58A]                	mov	al,[DIRCHAR]
 18246 00001E40 AA                      	stosb
 18247 00001E41 87F7                    	xchg	si,di
 18248 00001E43 893E[D08C]              	mov	[string_ptr_2],di
 18249                                  	;mov	ah,CURRENT_DIR ; 47h
 18250 00001E47 B447                    	mov	ah,47h
 18251 00001E49 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18252                                  			; DL = drive (0=default,1=A,etc.)
 18253                                  			; DS:SI	points to 64-byte buffer area
 18254                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18255 00001E4B BA[3C81]                	mov	dx,string_buf_ptr
 18256 00001E4E 7303                    	jnc	short doprint
 18257                                  	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
 18258 00001E50 BA[0480]                	mov	dx,BADCURDRV
 18259                                  doprint:
 18260                                  	;call	std_printf
 18261                                  	;retn
 18262 00001E53 E9ED2F                  	jmp	std_printf
 18263                                  
 18264                                  ; =============== S U B	R O U T	I N E =======================================
 18265                                  
 18266                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18267                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh
 18268                                  
 18269                                  build_dir_for_chdir:
 18270 00001E56 E80D00                  	call	build_dir_string
 18271 00001E59 BA[E98B]                	mov	dx,DIRBUF
 18272 00001E5C 8916[D08C]              	mov	[string_ptr_2],dx
 18273                                  	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
 18274                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18275 00001E60 BA[3C81]                	mov	dx,string_buf_ptr
 18276                                  	;call	std_printf
 18277                                  	;retn
 18278                                  	; 21/02/2023
 18279                                  	;jmp	short doprint
 18280 00001E63 E9DD2F                  	jmp	std_printf
 18281                                  
 18282                                  
 18283                                  ; =============== S U B	R O U T	I N E =======================================
 18284                                  
 18285                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18286                                  build_dir_string:
 18287 00001E66 8A165C00                	mov	dl,[FCB] ; mov dl,[5Ch]
 18288 00001E6A 88D0                    	mov	al,dl
 18289 00001E6C 0440                    	add	al,'@'	; 40h
 18290 00001E6E 3C40                    	cmp	al,'@'
 18291 00001E70 7506                    	jne	short gotdrive
 18292 00001E72 0206[F48A]              	add	al,[CURDRV]
 18293 00001E76 FEC0                    	inc	al
 18294                                  gotdrive:
 18295 00001E78 50                      	push	ax
 18296 00001E79 BE[EC8B]                	mov	si,BWDBUF+3
 18297                                  	;mov	ah,CURRENT_DIR ; 47h
 18298 00001E7C B447                    	mov	ah,47h
 18299 00001E7E CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18300                                  			; DL = drive (0=default,1=A,etc.)
 18301                                  			; DS:SI	points to 64-byte buffer area
 18302 00001E80 7305                    	jnc	short dpbisok
 18303 00001E82 0E                      	push	cs
 18304 00001E83 1F                      	pop	ds
 18305 00001E84 E9FB09                  	jmp	DRVBAD
 18306                                  dpbisok:
 18307 00001E87 BF[E98B]                	mov	di,BWDBUF
 18308 00001E8A 89FA                    	mov	dx,di
 18309 00001E8C 58                      	pop	ax
 18310 00001E8D B43A                    	mov	ah,':'
 18311 00001E8F AB                      	stosw
 18312 00001E90 A0[E58A]                	mov	al,[DIRCHAR]
 18313 00001E93 AA                      	stosb
 18314 00001E94 C3                      	retn
 18315                                  
 18316                                  ; ---------------------------------------------------------------------------
 18317                                  
 18318                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18319                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
 18320                                  PATH:
 18321                                  	; MSDOS 6.0
 18322 00001E95 30C0                    	xor	al,al			;AN049; Set up holding buffer
 18323 00001E97 BF[0E88]                	mov	di,SRCXNAME		;AN049;  for PATH while parsing
 18324 00001E9A AA                      	stosb				;AN049; Initialize PATH to null
 18325 00001E9B 4F                      	dec	di			;AN049; point to the start of buffer
 18326 00001E9C E8F30C                  	call	PGETARG 		; Pre scan for arguments
 18327 00001E9F 7460                    	jz	short disppath		; Print the current path
 18328                                  	;cmp	al,semicolon		;AC049; NUL path argument?
 18329 00001EA1 3C3B                    	cmp	al,';' ; 3Bh
 18330 00001EA3 7503                    	jne	short pathslp 		;AC049;
 18331 00001EA5 46                      	inc	si			;AN049; point past semicolon
 18332 00001EA6 EB1B                    	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
 18333                                  pathslp:					; Get the user specified path
 18334 00001EA8 AC                      	lodsb				; Get a character
 18335 00001EA9 3C0D                    	cmp	al,0Dh
 18336                                  	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
 18337 00001EAB 7434                    	je	short path_eol		;AC049; yes - end of command
 18338 00001EAD E83405                  	call	testkanj		;See if DBCS
 18339 00001EB0 7405                    	jz	short notkanj2		;No - continue
 18340 00001EB2 AA                      	stosb				;AC049; Yes - store the first byte
 18341 00001EB3 AC                      	lodsb				;skip second byte of DBCS
 18342                                  path_hold:				;AN049;
 18343 00001EB4 AA                      	stosb				;AC049; Store a byte in the PATH buffer
 18344 00001EB5 EBF1                    	jmp	short pathslp		;continue parsing
 18345                                  notkanj2:
 18346 00001EB7 E85405                  	call	UPCONV			;upper case the character
 18347                                  
 18348 00001EBA 3C3B                    	cmp	al,';' ; 3Bh
 18349                                  	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
 18350 00001EBC 74F6                    	je	short path_hold		;AC049; go store it
 18351 00001EBE E84D07                  	call	DELIM			;delimiter?
 18352 00001EC1 75F1                    	jnz	short path_hold		;AC049; no - go store character
 18353                                  scan_white:				;AN049; make sure were at EOL
 18354 00001EC3 AC                      	lodsb				;AN049; get a character
 18355 00001EC4 3C0D                    	cmp	al,0Dh
 18356                                  	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
 18357 00001EC6 7419                    	je	short path_eol		;AN049; yes - go set path
 18358 00001EC8 3C20                    	cmp	al,' ' ; 20h
 18359                                  	;cmp	al,blank		;AN049; whitespace?
 18360 00001ECA 74F7                    	je	short scan_white	;AN049; yes - continue scanning
 18361                                  	;cmp	al,9
 18362 00001ECC 3C09                    	cmp	al,tab_chr ; 9		;AN049; whitespace?
 18363 00001ECE 74F3                    	je	short scan_white	;AN049; yes - continue scanning
 18364                                  
 18365 00001ED0 BA[757F]                	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
 18366                                  	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
 18367 00001ED3 C706[757F]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 18368                                  	;mov	byte [msg_disp_class],2		
 18369                                  					;AN049; set up parse error msg class
 18370 00001ED9 C606[737F]02            	mov	byte [msg_disp_class],parse_msg_class
 18371 00001EDE E9990A                  	jmp	cerror			;AN049;
 18372                                  path_eol:				;AN049; Parsing was clean
 18373 00001EE1 30C0                    	xor	al,al			;AN049; null terminate the PATH
 18374 00001EE3 AA                      	stosb				;AN049;    buffer
 18375 00001EE4 E84B04                  	call	find_path		;AN049; Find PATH in environment
 18376 00001EE7 E81F04                  	call	delete_path		;AC049; Delete any offending name
 18377 00001EEA E8D504                  	call	scan_double_null	;AC049; Scan to end of environment
 18378 00001EED E8A504                  	call	move_name		;AC049; move in PATH=
 18379 00001EF0 BE[0E88]                	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
 18380                                  store_path:				;AN049; Store the PATH in the environment
 18381 00001EF3 AC                      	lodsb				;AN049; Get a character
 18382                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
 18383 00001EF4 20C0                    	and	al,al ; al=0 ?
 18384 00001EF6 7405                    	jz	short got_paths		;AN049; yes - exit
 18385 00001EF8 E83505                  	call	store_char		;AN049; no - store character
 18386 00001EFB EBF6                    	jmp	short store_path	;AN049; continue
 18387                                  got_paths:				;AN049; we're finished
 18388 00001EFD 31C0                    	xor	ax,ax			;	null terminate the PATH in
 18389 00001EFF AB                      	stosw				;    	the environment
 18390 00001F00 C3                      	retn
 18391                                  disppath:
 18392 00001F01 E82E04                  	call	find_path		;AN049;
 18393 00001F04 E80300                  	call	print_path
 18394                                  	;call	CRLF2
 18395                                  	;retn
 18396                                  	; 21/02/2023
 18397 00001F07 E9EF06                  	jmp	CRLF2
 18398                                  
 18399                                  ; 21/02/2023
 18400                                  %if 0
 18401                                  	; MSDOS 3.3
 18402                                  	call	FIND_PATH		; Find PATH in environment
 18403                                  	call	PGETARG			; Pre scan for arguments
 18404                                  	jz	short DISPPATH		; Print the current path
 18405                                  	call	DELETE_PATH		; Delete any offending name
 18406                                  	call	SCAN_DOUBLE_NULL	; Scan to end of environment	
 18407                                  	call	MOVE_NAME		; Move in PATH=
 18408                                  	call	PGETARG
 18409                                  	cmp	al,';'
 18410                                  	jz	short GOTPATHS
 18411                                  PATHSLP:
 18412                                  	lodsb
 18413                                  	cmp	al,0Dh			; End of line (CR) ?		
 18414                                  	jz	short GOTPATHS		; yes - exit
 18415                                  	;call	UPCONV	; MSDOS 6.0
 18416                                  	call	UPCONV_MAPCALL		; convert to uppercase
 18417                                  	cmp	al,';'			; ';' not a delimiter on PATH
 18418                                  	jz	short NOTDELIM		; go set path
 18419                                  	call	DELIM			; is it delim/null char ?
 18420                                  	jz	short GOTPATHS		; yes - exit
 18421                                  NOTDELIM:
 18422                                  	call	STORE_CHAR		; no - store character
 18423                                  	jmp	short PATHSLP
 18424                                  GOTPATHS:
 18425                                  	xor	ax,ax			; null terminate the PATH
 18426                                  	stosw				; in the environment
 18427                                  	retn
 18428                                  DISPPATH:
 18429                                  	call	PRINT_PATH
 18430                                  	call	CRLF2
 18431                                  	retn
 18432                                  %endif
 18433                                  
 18434                                  ; =============== S U B	R O U T	I N E =======================================
 18435                                  
 18436                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18437                                  print_path:
 18438 00001F0A 26803D00                	cmp	byte [es:di],0
 18439 00001F0E 750A                    	jnz	short path1
 18440                                  path0:
 18441 00001F10 BA[CA80]                	mov	dx,NULLPATH_PTR
 18442 00001F13 0E                      	push	cs
 18443 00001F14 07                      	pop	es
 18444 00001F15 0E                      	push	cs
 18445 00001F16 1F                      	pop	ds
 18446 00001F17 E9292F                  	jmp	std_printf
 18447                                  path1:
 18448 00001F1A 06                      	push	es
 18449 00001F1B 1F                      	pop	ds
 18450 00001F1C 83EF05                  	sub	di,5
 18451 00001F1F 89FE                    	mov	si,di
 18452 00001F21 E8B804                  	call	SCASB2		; Look for null
 18453                                  	;cmp	cx,0FFh ; 255
 18454                                  	; 21/02/2023
 18455                                  	;ch = 0
 18456 00001F24 80F9FF                  	cmp	cl,255
 18457 00001F27 74E7                    	je	short path0
 18458 00001F29 0E                      	push	cs
 18459 00001F2A 07                      	pop	es
 18460 00001F2B BF[4C8C]                	mov	di,Arg_Buf
 18461                                  	;mov	dx,100h ; 256
 18462                                  	;sub	dx,cx
 18463                                  	;xchg	dx,cx
 18464                                  	; 21/02/2023
 18465 00001F2E F6D9                    	neg	cl ; 256-cl
 18466 00001F30 F3A4                    	rep	movsb
 18467 00001F32 BA[1281]                	mov	dx,arg_buf_ptr
 18468 00001F35 0E                      	push	cs
 18469 00001F36 1F                      	pop	ds
 18470 00001F37 E9092F                  	jmp	std_printf
 18471                                  
 18472                                  ; ---------------------------------------------------------------------------
 18473                                  
 18474                                  ; ****************************************************************
 18475                                  ; *
 18476                                  ; * ROUTINE:	 CLS
 18477                                  ; *
 18478                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
 18479                                  ; *		 installed, send a control string to clear the
 18480                                  ; *		 screen.
 18481                                  ; *
 18482                                  ; * INPUT:	 command line at offset 81H
 18483                                  ; *
 18484                                  ; * OUTPUT:	 none
 18485                                  ; *
 18486                                  ; ****************************************************************
 18487                                  
 18488                                  	; MSDOS 6.0
 18489                                  
 18490                                  ANSI_installed	equ 0FFh
 18491                                  
 18492                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18493                                  CLS:
 18494                                  	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
 18495                                  	;mov	ah,1Ah
 18496                                  	;mov	al,0			;AN000;
 18497 00001F3A B8001A                  	mov	ax,1A00h
 18498 00001F3D CD2F                    	int	2Fh			;AN000;
 18499                                  		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
 18500                                  		; Return: AL = FFh if installed
 18501 00001F3F 3CFF                    	cmp	al,ANSI_installed	;AN000;
 18502 00001F41 7429                    	je	short ansicls 		;AN000; installed - go do ANSI CLS
 18503                                  
 18504                                  check_lines:
 18505                                  	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
 18506 00001F43 B80C44                  	mov	ax,440Ch		;AN000; get lines per page on display
 18507                                  	;mov	bx,stdout		;AN000; lines for stdout
 18508 00001F46 BB0100                  	mov	bx,1   ; handle
 18509                                  	;;mov	ch,ioc_sc		;AN000; type is display
 18510                                  	;mov	ch,3   ; CON device	
 18511                                  	;;mov	cl,get_generic		;AN000; get information
 18512                                  	;mov	cl,7Fh ; minor function, get display info
 18513                                  	; 25/04/2023
 18514 00001F49 B97F03                  	mov	cx,037Fh
 18515 00001F4C BA[268E]                	mov	dx,Display_Ioctl	;AN000;
 18516 00001F4F CD21                    	int	21h			;AN000;
 18517 00001F51 720A                    	jc	short no_variable	;AN000; function had error, use default
 18518                                  		; 21/02/2023
 18519                                  		; ds:dx = parameter block
 18520                                  		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
 18521                                  		; offset 00h  byte  level (0 for DOS 4.0)
 18522                                  		;   	 01h  byte  reserved
 18523                                  		;   	 02h  word  length of following data
 18524                                  		;   	 04h  word  control flags
 18525                                  		;	       bit 0 set for blink, clear for intensity
 18526                                  		;	       bits 1 to 15 reserved
 18527                                  		;   	 06h  byte  mode type (1=text, 2=graphics)
 18528                                  		;   	 07h  byte  reserved
 18529                                  		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
 18530                                  		;   	 0Ah  word  pixel columns
 18531                                  		;   	 0Ch  word  pixel rows
 18532                                  		;   	 0Eh  word  character columns
 18533                                  		;   	 10h  word  character rows
 18534                                  	
 18535                                  	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
 18536                                  	;				;AN000; get number of rows returned
 18537                                  	;mov	dh,al			;AN000; set number of rows
 18538                                  	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
 18539                                  	;				;AN000; get number of columns returned
 18540                                  	;mov	dl,al			;AN000; set number of columns
 18541                                  	; 21/02/2023
 18542 00001F53 8A16[348E]              	mov	dl,[display_width]
 18543 00001F57 8A36[368E]              	mov	dh,[LinPerPag]
 18544 00001F5B EB3B                    	jmp	short regcls		;AN000; go do cls
 18545                                  
 18546                                  no_variable:
 18547                                  	;;mov	bx,stdout		;AC000; set handle as stdout
 18548                                  	;mov	bx,1
 18549                                  	; bx = 1
 18550                                  	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
 18551 00001F5D B80044                  	mov	ax,4400h
 18552 00001F60 CD21                    	int	21h			;AC000;
 18553 00001F62 F6C280                  	test	dl,80h
 18554                                  	;test	dl,devid_ISDEV		;AC000; is handle a device
 18555 00001F65 7405                    	jz	short ansicls 		;AC000; If a file put out ANSI
 18556 00001F67 F6C210                  	test	dl,10h
 18557                                  	;test	dl,devid_SPECIAL	;AC000;
 18558 00001F6A 7505                    	jnz	short cls_normal	;AC000; If not special CON, do ANSI
 18559                                  
 18560                                  ansicls:
 18561 00001F6C E85200                  	call	ansi_cls		;AN000; clear the screen
 18562 00001F6F EB2C                    	jmp	short cls_ret		;AN000; exit
 18563                                  
 18564                                  ; Get video mode
 18565                                  
 18566                                  cls_normal:				;AC000;
 18567                                  	;mov	ah,get_video_state	;AC000; set up to get video state
 18568 00001F71 B40F                    	mov	ah,0Fh
 18569                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18570 00001F73 CD10                    	int	10h
 18571 00001F75 3C03                    	cmp	al,3
 18572                                  	;cmp	al,video_alpha		;AC000; see if in text mode
 18573 00001F77 760A                    	jbe	short DoAlpha
 18574 00001F79 3C07                    	cmp	al,7
 18575                                  	;cmp	al,video_bw		;AC000; see if black & white card
 18576 00001F7B 7406                    	je	short DoAlpha
 18577                                  
 18578                                  ; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
 18579                                  ; be just as bogus and set the mode that we just got. This will blank the
 18580                                  ; screen too.
 18581                                  
 18582                                  	;mov	ah,set_video_mode	;AC000; set video mode call
 18583 00001F7D B400                    	mov	ah,0
 18584                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18585 00001F7F CD10                    	int	10h
 18586 00001F81 EB1A                    	jmp	short cls_ret		;AC000; exit
 18587                                  
 18588                                  DoAlpha:
 18589                                  
 18590                                  ; Get video mode and number of columns to scroll
 18591                                  
 18592                                  ;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
 18593                                  ;M01   adaptors. We circumvent this by reaching directly into the BIOS data
 18594                                  ;M01   area
 18595                                  ;M01   Commented out code here is the original
 18596                                  ;M01	mov	ah,get_video_state	;AC000; set up to get current video state
 18597                                  ;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
 18598                                  ;M01	mov	dl,ah
 18599                                  ;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen
 18600                                  
 18601                                  ;M01   Following code lifted from a fix Compaq applied to ANSI
 18602                                  
 18603 00001F83 1E                      	push	ds
 18604                                  	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
 18605 00001F84 B84000                  	mov	ax,40h
 18606 00001F87 8ED8                    	mov	ds,ax			;  *			M01
 18607                                  
 18608                                  	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
 18609 00001F89 8A164A00                	mov	dl,[4Ah]
 18610                                  	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
 18611 00001F8D 8A368400                	mov	dh,[84h]
 18612 00001F91 1F                      	pop	ds			;			M01
 18613                                  
 18614 00001F92 08F6                    	or	dh,dh			; Q:ZERO		M01
 18615 00001F94 7502                    	jnz	short regcls		;  *JMP IF NO		M01
 18616                                  
 18617                                  	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
 18618                                  	; 25/04/2023
 18619 00001F96 B619                    	mov	dh,25
 18620                                  regcls:
 18621 00001F98 FEC6                    	inc	dh			; height+1		M018
 18622 00001F9A E80100                  	call	reg_cls 		; go clear the screen
 18623                                  cls_ret:
 18624 00001F9D C3                      	retn				; exit
 18625                                  
 18626                                  ; ---------------------------------------------------------------------------
 18627                                  
 18628                                  ; 21/02/2023
 18629                                  %if 0
 18630                                  	; MSDOS 3.3
 18631                                  CLS:
 18632                                  	mov	bx,STDOUT ; 1
 18633                                  	mov	ax,IOCTL*256 ; 4400h
 18634                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 18635                                  			; BX = file or device handle
 18636                                  	test	dl,80h	; devid_ISDEV
 18637                                  	jz	short ANSICLS	; If a file put out ANSI
 18638                                  	test	dl,10h  ; devid_SPECIAL
 18639                                  	jz	short ANSICLS	; If not special CON, do ANSI
 18640                                  
 18641                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
 18642                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18643                                  			; AL = interrupt number
 18644                                  			; Return: ES:BX	= value	of interrupt vector
 18645                                  	mov	dx,es
 18646                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
 18647                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18648                                  			; AL = interrupt number
 18649                                  			; Return: ES:BX	= value	of interrupt vector
 18650                                  	mov	ax,es
 18651                                  	cmp	dx,ax	; If not default driver, do ANSI
 18652                                  	ja	short ANSICLS
 18653                                  
 18654                                  	mov	ah,0Fh
 18655                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18656                                  			; Return: AH = number of columns on screen
 18657                                  			; AL = current video mode
 18658                                  			; BH = current active display page
 18659                                  	cmp	al,3
 18660                                  	jbe	short DOALPHA
 18661                                  	cmp	al,7
 18662                                  	jz	short DOALPHA
 18663                                  	mov	ah,0
 18664                                  	int	10h	; - VIDEO - SET	VIDEO MODE
 18665                                  			; AL = mode
 18666                                  	retn
 18667                                  
 18668                                  DOALPHA:
 18669                                  	mov	ah,0Bh	; Set overscan to black
 18670                                  	xor	bx,bx
 18671                                  	int	10h	; - VIDEO - SET	COLOR PALETTE
 18672                                  			; BH = 00h, BL = border color
 18673                                  			; BH = 01h, BL = palette (0-3)
 18674                                  	mov	ah,0Fh
 18675                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18676                                  			; Return: AH = number of columns on screen
 18677                                  			; AL = current video mode
 18678                                  			; BH = current active display page
 18679                                  	mov	dl,ah
 18680                                  	dec	dl
 18681                                  	mov	dh,24
 18682                                  	xor	ax,ax
 18683                                  	mov	cx,ax
 18684                                  	mov	bx,700h
 18685                                  	mov	ah,6
 18686                                  	int	10h	; - VIDEO - SCROLL PAGE	UP
 18687                                  			; AL = number of lines to scroll window	
 18688                                  			;	(0 = blank whole window)
 18689                                  			; BH = attributes to be	used on	blanked	lines
 18690                                  			; CH,CL	= row,column of	upper left corner of window 
 18691                                  			;	  to scroll
 18692                                  			; DH,DL	= row,column of	lower right corner of window
 18693                                  	xor	dx,dx
 18694                                  	mov	bh,0
 18695                                  	mov	ah,2
 18696                                  	int	10h	; - VIDEO - SET	CURSOR POSITION
 18697                                  			; DH,DL	= row,column (0,0 = upper left)
 18698                                  			; BH = page number
 18699                                  	retn
 18700                                  
 18701                                  ANSICLS:
 18702                                  	mov	si,CLSSTRING
 18703                                  	lodsb
 18704                                  	mov	cl,al
 18705                                  	xor	ch,ch
 18706                                  	mov	ah,RAW_CON_IO ; 6
 18707                                  CLRLOOP:
 18708                                  	lodsb
 18709                                  	mov	dl,al
 18710                                  	int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
 18711                                  			; DL = character <> FFh
 18712                                  			;  Return: ZF set = no character
 18713                                  			;   ZF clear = character recieved, AL = character
 18714                                  	loop	CLRLOOP
 18715                                  	retn
 18716                                  %endif
 18717                                  
 18718                                  ; ---------------------------------------------------------------------------
 18719                                  
 18720                                  ; MSDOS 6.0
 18721                                  
 18722                                  ; ****************************************************************
 18723                                  ; *
 18724                                  ; * ROUTINE:	 REG_CLS
 18725                                  ; *
 18726                                  ; * FUNCTION:	 Clear the screen using INT 10H.
 18727                                  ; *
 18728                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
 18729                                  ; *		 DH = NUMBER OF ROWS
 18730                                  ; *
 18731                                  ; * OUTPUT:	 none
 18732                                  ; *
 18733                                  ; ****************************************************************
 18734                                  
 18735                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18736                                  reg_cls:
 18737                                  ; Set overscan to black.
 18738                                  
 18739 00001F9E FECE                    	dec	dh			; decrement rows and columns
 18740 00001FA0 FECA                    	dec	dl			;  to zero base
 18741 00001FA2 52                      	push	dx			; save rows,columns
 18742                                  	;mov	ah,set_color_palette	; set up to set the color to blank
 18743 00001FA3 B40B                    	mov	ah,0Bh
 18744 00001FA5 31DB                    	xor	bx,bx
 18745                                  	;int	video_io_int		; do int 10h - BIOS video IO
 18746 00001FA7 CD10                    	int	10h
 18747 00001FA9 5A                      	pop	dx			;  restore rows,colums
 18748                                  
 18749 00001FAA 31C0                    	xor	ax,ax			; zero out ax
 18750 00001FAC 89C1                    	mov	cx,ax			;  and cx
 18751                                  
 18752                                  ; Scroll active page
 18753                                  
 18754                                  	;mov	ah,scroll_video_page	; set up to scroll page up
 18755 00001FAE B406                    	mov	ah,6
 18756                                  	;mov	bh,video_attribute	; attribute for blank line
 18757 00001FB0 B707                    	mov	bh,7
 18758 00001FB2 30DB                    	xor	bl,bl			; set BL to 0
 18759                                  	;int	video_io_int		; do int 10h - BIOS video IO
 18760 00001FB4 CD10                    	int	10h
 18761                                  
 18762                                  ; Seek to cursor to 0,0
 18763                                  
 18764                                  ;M022 following two lines added
 18765                                  	;mov	ah,get_video_state	; get current video page in BH
 18766 00001FB6 B40F                    	mov	ah,0Fh
 18767                                  	;int	video_io_int
 18768 00001FB8 CD10                    	int	10h
 18769                                  	;mov	ah,set_cursor_position	; set up to set cursor position
 18770 00001FBA B402                    	mov	ah,2
 18771 00001FBC 31D2                    	xor	dx,dx			; row and column 0
 18772                                  ;M022	mov	bh,0
 18773                                  	;int	video_io_int		; do into 10h - BIOS video IO
 18774 00001FBE CD10                    	int	10h
 18775                                  
 18776 00001FC0 C3                      	retn
 18777                                  
 18778                                  ; ---------------------------------------------------------------------------
 18779                                  
 18780                                  ; MSDOS 6.0
 18781                                  
 18782                                  ; ****************************************************************
 18783                                  ; *
 18784                                  ; * ROUTINE:	 ANSI_CLS
 18785                                  ; *
 18786                                  ; * FUNCTION:	 Clear the screen using by writing a control code
 18787                                  ; *		 to STDOUT.
 18788                                  ; *
 18789                                  ; * INPUT:	 none
 18790                                  ; *
 18791                                  ; * OUTPUT:	 none
 18792                                  ; *
 18793                                  ; ****************************************************************
 18794                                  
 18795                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18796                                  ansi_cls:			;AC000;
 18797 00001FC1 BE[E182]                	mov	si,CLSSTRING
 18798                                  			; db 4,1Bh,'[2J'
 18799 00001FC4 AC                      	lodsb
 18800 00001FC5 88C1                    	mov	cl,al	; al = 4
 18801 00001FC7 30ED                    	xor	ch,ch
 18802                                  	;mov	ah,Raw_CON_IO
 18803 00001FC9 B406                    	mov	ah,6
 18804                                  clrloop:
 18805 00001FCB AC                      	lodsb
 18806 00001FCC 88C2                    	mov	dl,al
 18807 00001FCE CD21                    	int	21h
 18808                                  		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 18809 00001FD0 E2F9                    	loop	clrloop
 18810 00001FD2 C3                      	retn
 18811                                  
 18812                                  ;============================================================================
 18813                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
 18814                                  ;============================================================================
 18815                                  ; 08/10/2018 - Retro DOS v3.0
 18816                                  
 18817                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
 18818                                  
 18819                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 18820                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh
 18821                                  
 18822                                  ; ---------------------------------------------------------------------------
 18823                                  
 18824                                  ; ****************************************************************
 18825                                  ; *
 18826                                  ; * ROUTINE:	 CTTY - Change console
 18827                                  ; *
 18828                                  ; * SYNTAX:	 CTTY device
 18829                                  ; *
 18830                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
 18831                                  ; *		 duplicate the device handle to STDIN, STDOUT and
 18832                                  ; *		 STDERR. This routine returns to LODCOM1.
 18833                                  ; *
 18834                                  ; * INPUT:	 command line at offset 81H
 18835                                  ; *
 18836                                  ; * OUTPUT:	 none
 18837                                  ; *
 18838                                  ; ****************************************************************
 18839                                  
 18840                                  	; 21/02/2023 - Retro DOS v4.0
 18841                                  CTTY:
 18842                                  	; MSDOS 6.0
 18843 00001FD3 1E                      	push	ds			;AN000; Get local ES
 18844 00001FD4 07                      	pop	es			;AN000;
 18845 00001FD5 BE8100                  	mov	si,81h			;AC000; Get command argument for CTTY
 18846 00001FD8 BF[F585]                	mov	di,PARSE_CTTY
 18847                                  					;AC000; Get address of PARSE_CTTY
 18848 00001FDB 31C9                    	xor	cx,cx			;AC000; clear cx,dx
 18849 00001FDD 31D2                    	xor	dx,dx			;AC000;
 18850 00001FDF E88E23                  	call	cmd_parse		;AC000; call parser
 18851 00001FE2 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 18852                                  	;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 18853 00001FE5 7435                    	je	short ctty_error	;AN000; yes - error
 18854                                  	;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
 18855 00001FE7 21C0                    	and	ax,ax ; ax > 0 ?
 18856 00001FE9 7531                    	jnz	short ctty_error	;AN000; YES -ERROR
 18857                                  
 18858 00001FEB 56                      	push	si			;AN000; save position in line
 18859 00001FEC C536[1396]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 18860 00001FF0 BF[4F8D]                	mov	di,SrcBuf		;AN000; get address of srcbuf
 18861                                  ctty_move_filename:			;AN000; put filespec in srcbuf
 18862 00001FF3 AC                      	lodsb				;AN000; get a char from buffer
 18863 00001FF4 AA                      	stosb				;AN000; store in srcbuf
 18864                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
 18865 00001FF5 08C0                    	or	al,al ; al = 0 ?
 18866 00001FF7 75FA                    	jnz	short ctty_move_filename ; 26/04/2023
 18867                                  					;AN000; no - keep moving
 18868 00001FF9 5E                      	pop	si			;AN000; get line position back
 18869 00001FFA BF[F585]                	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
 18870 00001FFD E8C801                  	call	parse_check_eol 	;AN000; are we at end of line?
 18871                                  	;jz	short nocolon 		;AN000; yes - continue
 18872                                  	; 21/02/2023
 18873 00002000 751A                    	jnz	short ctty_error
 18874                                  ;ctty_error:
 18875                                  	;jmp	short isbaddev		;AC000; yes - exit
 18876                                  
 18877                                  	; 21/02/2023
 18878                                  	; MSDOS 3.3
 18879                                  	;call	SETPATH
 18880                                  	;dec	si
 18881                                  	;dec	si
 18882                                  	;cmp	byte [si],':'
 18883                                  	;jnz	short NOCOLON
 18884                                  	;mov	byte [si],0
 18885                                  nocolon:
 18886                                  	; 21/02/2023
 18887                                  	; MSDOS 6.0
 18888 00002002 BA[4F8D]                	mov	dx,SrcBuf
 18889                                  ;NOCOLON:
 18890                                  	; MSDOS 3.3 & MSDOS 6.0
 18891                                  	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
 18892                                  	;mov	ax,(OPEN<<8)|2 ; 3D02h
 18893 00002005 B8023D                  	mov	ax,3D02h ; 21/02/2023
 18894 00002008 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 18895                                  			; DS:DX	-> ASCIZ filename
 18896                                  			; AL = access mode
 18897                                  			; 2 - read & write
 18898 0000200A 7210                    	jc	short isbaddev
 18899 0000200C 89C3                    	mov	bx,ax
 18900                                  	;mov	ax,IOCTL*256 ; 4400h
 18901 0000200E B80044                  	mov	ax,4400h
 18902 00002011 CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 18903                                  			; BX = file or device handle
 18904 00002013 F6C280                  	test	dl,80h
 18905 00002016 750C                    	jnz	short devisok
 18906                                  closedev:
 18907                                  	;mov	ah,CLOSE ; 3Eh ; Close initial handle
 18908 00002018 B43E                    	mov	ah,3Eh
 18909 0000201A CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 18910                                  			; BX = file handle
 18911                                  ctty_error:
 18912                                  isbaddev:
 18913 0000201C BA[D080]                	mov	dx,BADDEV_PTR
 18914 0000201F E8212E                  	call	std_printf
 18915 00002022 EB40                    	jmp	short resret
 18916                                  
 18917                                  	;nop
 18918                                  devisok:
 18919                                  	; 21/02/2023
 18920                                  	; MSDOS 6.0
 18921 00002024 52                      	push	dx		;AN007; save device info
 18922 00002025 B8[5481]                	mov	ax,acrlf_ptr	;AN021; get message number for 0d, 0a
 18923                                  	;mov	dh,util_msg_class
 18924 00002028 B6FF                    	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
 18925 0000202A 53                      	push	bx		;AN021; save handle
 18926 0000202B E8FC2E                  	call	TSYSGETMSG	;AN021; get the address of the message
 18927 0000202E 89F2                    	mov	dx,si		;AN021; get address into dx
 18928                                  	;mov	ax,(Write shl 8)
 18929 00002030 B80040                  	mov	ax,4000h	;AN007; write to device
 18930 00002033 B90200                  	mov	cx,2		;AN007; write two bytes
 18931 00002036 CD21                    	int	21h		;AN007;
 18932 00002038 5B                      	pop	bx		;AN021; get back handle
 18933 00002039 5A                      	pop	dx		;AN007; get back device info
 18934 0000203A 72DC                    	jc	short closedev	;AN007; if error, quit
 18935                                  
 18936                                  	; MSDOS 3.3 & MSDOS 6.0
 18937 0000203C 30F6                    	xor	dh,dh
 18938 0000203E 80CA03                  	or	dl,3
 18939                                  	;;mov	ax,(IOCTL SHL 8) OR 1
 18940                                  	;mov	ax,(IOCTL<<8)|1 ; 4401h
 18941 00002041 B80144                  	mov	ax,4401h
 18942 00002044 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 18943                                  			; BX = device handle,DH = 0
 18944                                  			; DL = device information to set 
 18945                                  			;	(bits 0-7 from	function 0)
 18946 00002046 53                      	push	bx
 18947 00002047 B90300                  	mov	cx,3
 18948 0000204A 31DB                    	xor	bx,bx
 18949                                  iclloop:			; Close basic handles
 18950                                  	;mov	ah,CLOSE ; 3Eh
 18951 0000204C B43E                    	mov	ah,3Eh
 18952 0000204E CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 18953                                  			; BX = file handle
 18954 00002050 43                      	inc	bx
 18955 00002051 E2F9                    	loop	iclloop
 18956 00002053 5B                      	pop	bx		; Get handle
 18957                                  	;mov	ah,XDUP ; 45h
 18958 00002054 B445                    	mov	ah,45h
 18959 00002056 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 18960                                  			; BX = file handle to duplicate
 18961                                  	;mov	ah,XDUP ; 45h
 18962 00002058 B445                    	mov	ah,45h
 18963 0000205A CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 18964                                  			; BX = file handle to duplicate
 18965                                  	;mov	ah,XDUP ; 45h
 18966 0000205C B445                    	mov	ah,45h
 18967 0000205E CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 18968                                  			; BX = file handle to duplicate
 18969                                  	;mov	ah,CLOSE ; 3Eh
 18970 00002060 B43E                    	mov	ah,3Eh
 18971 00002062 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 18972                                  			; BX = file handle
 18973                                  resret:
 18974 00002064 8E1E[E08A]              	mov	ds,[RESSEG]
 18975 00002068 1E                      	push	ds
 18976                                  	;mov	ax,[18h]
 18977 00002069 A11800                  	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
 18978 0000206C A3[A201]                	mov	[Io_Save],ax
 18979                                  	;;;mov	ax,31Eh ; MSDOS 3.3
 18980                                  	;;mov	ax,LODCOM1
 18981                                  	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
 18982                                  	;mov	ax,175h ; MSDOS 6.0
 18983 0000206F B8[7400]                	mov	ax,TrnLodCom1_Trap
 18984 00002072 50                      	push	ax
 18985                                  
 18986 00002073 CB                      	retf		; Far return
 18987                                  
 18988                                  ; ---------------------------------------------------------------------------
 18989                                  
 18990                                  ;****************************************************************
 18991                                  ;*
 18992                                  ;* ROUTINE:	CHCP - Change code page internal command
 18993                                  ;*		(added DOS 3.30 07/21/86)
 18994                                  ;*
 18995                                  ;* SYNTAX:	CHCP [xxx]
 18996                                  ;*		where xxx is a valid code page
 18997                                  ;*
 18998                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
 18999                                  ;*		6402H to set the code page to xxxx. If no parameters
 19000                                  ;*		are specified, CHCP will use INT 21H function 6401H
 19001                                  ;*		to get global code page and display it to the user.
 19002                                  ;*
 19003                                  ;* INPUT:	command line at offset 81H
 19004                                  ;*
 19005                                  ;* OUTPUT:	none
 19006                                  ;*
 19007                                  ;****************************************************************
 19008                                  
 19009                                  NLSFUNC_installed equ  0FFh
 19010                                  set_global_cp	  equ  2
 19011                                  get_global_cp	  equ  1
 19012                                  
 19013                                  	; 21/02/2023 - Retro DOS v4.0
 19014                                  CHCP:
 19015                                  	; MSDOS 6.0
 19016 00002074 1E                      	push	ds		;AN000; Get local ES
 19017 00002075 07                      	pop	es		;AN000;
 19018 00002076 BE8100                  	mov	si,81h		;AC000; Get command argument for CHCP
 19019 00002079 BF[0C85]                	mov	di,PARSE_CHCP
 19020                                  				;AN000; Get address of PARSE_CHCP
 19021 0000207C 31C9                    	xor	cx,cx		;AC000; clear cx,dx
 19022 0000207E 31D2                    	xor	dx,dx		;AC000;
 19023 00002080 E85B01                  	call    Parse_With_Msg	;AC018; call parser
 19024 00002083 83F8FF                  	cmp	ax,-1
 19025                                  	;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 19026                                  	;jne	short setcp	;AC000; no go get number & set code page
 19027 00002086 745E                    	je	short getcp	;AC000; yes - no parm - get code page
 19028                                  setcp:
 19029                                  	;cmp	ax,0
 19030                                  	;cmp	ax,RESULT_NO_ERROR
 19031                                  				;AN000; did we have an error?
 19032                                  	;jne	short cp_error	;AC018; yes - go issue message
 19033 00002088 21C0                    	and	ax,ax ; ax > 0 ?
 19034 0000208A 7557                    	jnz	short cp_error	
 19035                                  
 19036                                  	;push	cx		;AN000; save positional count
 19037 0000208C BB[1396]                	mov	bx,PARSE1_ADDR	;AN000; get number returned
 19038                                  	;mov	cx,[bx]		;AN000;  into cx
 19039                                  	;mov	[system_cpage],cx
 19040                                  				;AN000; save user input number
 19041                                  	;pop	cx		;AC000; restore positional count
 19042                                  	; 21/02/2023
 19043 0000208F 8B3F                    	mov	di,[bx]
 19044 00002091 893E[4A8C]              	mov	[system_cpage],di
 19045                                  	;
 19046 00002095 BF[0C85]                	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
 19047 00002098 E82D01                  	call	parse_check_eol ;AN000; are we at end of line?
 19048 0000209B 7546                    	jnz	short cp_error	;AC000; no - exit
 19049                                  okset:
 19050                                  	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
 19051                                  	;mov	ah,14h
 19052                                  	;mov	al,0		;AN000;
 19053 0000209D B80014                  	mov	ax,1400h
 19054 000020A0 CD2F                    	int	2Fh		;AN000;
 19055                                  	;cmp	al,0FFh
 19056 000020A2 3CFF                    	cmp	al,NLSFUNC_installed
 19057                                  				;AN000;
 19058 000020A4 7405                    	je	short got_NLS 	;AN000; Yes - continue
 19059 000020A6 BA[FE7F]                	mov	dx,NLSFUNC_PTR
 19060                                  				;AN000; no - set up error message
 19061 000020A9 EB38                    	jmp	short cp_error	;AN000; error exit
 19062                                  
 19063                                  ; 21/02/2023
 19064                                  %if 0
 19065                                  	; MSDOS 3.3
 19066                                  	mov	si,81h
 19067                                  	call	SCANOFF
 19068                                  	cmp	al,0Dh ; CR
 19069                                  	jnz	short SETCP
 19070                                  	jmp	short GETCP
 19071                                  
 19072                                  	;nop
 19073                                  SETCP:
 19074                                  	xor	bx,bx
 19075                                  	mov	cx,bx
 19076                                  	mov	ax,bx
 19077                                  GET_CP_DIGIT:
 19078                                  	lodsb
 19079                                  	cmp	al,'0'
 19080                                  	jb	short CHRNOTNUMBER
 19081                                  	cmp	al,'9'
 19082                                  	ja	short CHRNOTNUMBER
 19083                                  	sub	al,'0'
 19084                                  	inc	cl
 19085                                  	cmp	cl,4
 19086                                  	ja	short CHCP_BADPARM
 19087                                  	mov	dx,bx
 19088                                  	shl	dx,1
 19089                                  	shl	dx,1
 19090                                  	add	bx,dx
 19091                                  	shl	bx,1
 19092                                  	add	bx,ax
 19093                                  	jmp	short GET_CP_DIGIT
 19094                                  CP_NEXTCHR:
 19095                                  	lodsb
 19096                                  CHRNOTNUMBER:
 19097                                  	cmp	al,' '		; SPACE
 19098                                  	jz	short CP_NEXTCHR
 19099                                  	cmp	al,9		; TAB
 19100                                  	jz	short CP_NEXTCHR
 19101                                  	cmp	al,0Dh		; CR
 19102                                  	jz	short SET_CP_TBL_NUM
 19103                                  CHCP_BADPARM:
 19104                                  	mov	dx,BADPARMPTR
 19105                                  	jmp	CERROR
 19106                                  ;GOT_NLS:
 19107                                  %endif
 19108                                  	; 21/02/2023
 19109                                  got_NLS:
 19110                                  	; MSDOS 6.0
 19111 000020AB 8B1E[4A8C]              	mov	bx,[system_cpage]
 19112                                  				;AN000; get user input code page
 19113                                  ;SET_CP_TBL_NUM:
 19114                                  	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
 19115                                  	;
 19116                                  	; MSDOS 3.3 & MSDOS 6.0
 19117                                  	;;mov	ah,GETSETCDPG 	;get/set global code page function
 19118                                  	;mov	ah,66h
 19119                                  	;;mov	al,set_global_cp 
 19120                                  	;mov	al,2		;minor - set
 19121                                  	; 26/04/2023
 19122 000020AF B80266                  	mov	ax,6602h
 19123 000020B2 CD21                    	int	21h
 19124                                  		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
 19125                                  		; BX = active code page
 19126                                  		; DX = system code page (active page at boot time)
 19127                                  
 19128 000020B4 733F                    	jnc	short chcp_return
 19129                                  				;no error - exit
 19130                                  
 19131 000020B6 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
 19132 000020B9 7515                    	jnz	short chcp_other_error
 19133                                  
 19134                                  	;mov	ah,GETEXTENDEDERROR ; 59h
 19135 000020BB B459                    	mov	ah,59h
 19136 000020BD 31DB                    	xor	bx,bx
 19137 000020BF CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19138                                  			; BX = version code (0000h for DOS 3.x)
 19139                                  
 19140 000020C1 83F80D                  	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
 19141 000020C4 7505                    	jne	short no_countrysys ; 26/04/2023
 19142                                  	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
 19143 000020C6 BA[0180]                	mov	dx,INV_CODE_PAGE
 19144                                  	;jmp	cerror
 19145 000020C9 EB18                    	jmp	short cp_error
 19146                                  
 19147                                  	; 21/02/2023
 19148                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 19149                                  no_countrysys:
 19150                                  ;M045;	mov	byte [msg_disp_class],ext_msg_class	   
 19151                                  ;					;AN000; set up extended error msg class
 19152                                  ;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
 19153                                  ;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
 19154                                  					;AN000; get message number in control block
 19155 000020CB BA[E281]                	mov	dx,NoCntry_Ptr
 19156 000020CE EB13                    	jmp	short cp_error
 19157                                  
 19158                                  chcp_other_error:		; end of p716
 19159                                  	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
 19160 000020D0 B459                    	mov	ah,59h
 19161 000020D2 31DB                    	xor	bx,bx
 19162 000020D4 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19163                                  			; BX = version code (0000h for DOS 3.x)
 19164 000020D6 83F841                  	cmp	ax,65		;was it access denied?
 19165 000020D9 7505                    	jne	short none_set	;no - assume all failed
 19166 000020DB BA[E27F]                	mov	dx,cp_not_all_ptr
 19167                                  				;set up message
 19168                                  	;jmp	cerror		;AC000; error exit
 19169 000020DE EB03                    	jmp     short cp_error
 19170                                  none_set:
 19171 000020E0 BA[D47F]                	mov	dx,cp_not_set_ptr
 19172                                  				;set up message
 19173                                  cp_error:
 19174 000020E3 E99408                  	jmp	cerror		;exit
 19175                                  getcp:
 19176                                  	;;mov	ah,GETSETCDPG ; 66h
 19177                                  	;mov	ah,66h		;get/set global code page function	
 19178                                  	;;mov	al,get_global_cp ; 1
 19179                                  	;mov	al,1		;minor - get
 19180                                  	; 26/04/2023
 19181 000020E6 B80166                  	mov	ax,6601h
 19182 000020E9 CD21                    	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
 19183 000020EB 891E[4A8C]              	mov	[system_cpage],bx
 19184                                  				;get active cp for output
 19185 000020EF BA[F07F]                	mov	dx,cp_active_ptr
 19186 000020F2 E84E2D                  	call	std_printf	;print it out
 19187                                  chcp_return:
 19188 000020F5 C3                      	retn
 19189                                  
 19190                                  ; ---------------------------------------------------------------------------
 19191                                  
 19192                                  ; ****************************************************************
 19193                                  ; *
 19194                                  ; * ROUTINE:	 TRUENAME
 19195                                  ; *
 19196                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
 19197                                  ; *		 Parses the command line. If a path is found, set
 19198                                  ; *		 SRCXNAME to path. If only a drive letter is found,
 19199                                  ; *		 set SRCXNAME to the drive letter. If no path
 19200                                  ; *		 is found, set the path of SRCXNAME to dot (.) for
 19201                                  ; *		 current directory. Use the NAME TRANSLATE system
 19202                                  ; *		 call to get the real name and  then display the 
 19203                                  ; *		 real name. If an error occurs issue an error
 19204                                  ; *		 message and transfer control to  CERROR.
 19205                                  ; *
 19206                                  ; * INPUT:	 command line at offset 81H
 19207                                  ; *
 19208                                  ; * OUTPUT:	 none
 19209                                  ; *
 19210                                  ; ****************************************************************
 19211                                  
 19212                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19213                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
 19214                                  
 19215                                  TRUENAME:				;AN000; TRUENAME entry point
 19216 000020F6 1E                      	push	ds			;AN000; Get local ES
 19217 000020F7 07                      	pop	es			;AN000;
 19218 000020F8 BE8100                  	mov	si,81h			;AN000; Get command line
 19219 000020FB BF[6A85]                	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
 19220 000020FE 31C9                    	xor	cx,cx			;AN000; clear cx,dx
 19221 00002100 31D2                    	xor	dx,dx			;AN000;
 19222 00002102 E8D900                  	call	Parse_With_Msg		;AC018; call parser
 19223                                  
 19224 00002105 BF[0E88]                	mov	di,SRCXNAME		;AN000; get address of srcxname
 19225 00002108 83F8FF                  	cmp	ax,0FFFFh
 19226                                  	;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 19227 0000210B 7434                    	je	short tn_eol		;AN000; yes - go process
 19228                                  	; 22/02/2023
 19229                                  	;cmp	ax,0
 19230                                  	;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 19231                                  	;jne	short tn_parse_error	;AN000; yes - go issue message
 19232 0000210D 21C0                    	and	ax,ax ; ax = 0 ?
 19233 0000210F 752D                    	jnz	short tn_parse_error ; no, parse error	
 19234                                  
 19235                                  	;cmp	byte [PARSE1_TYPE],6
 19236 00002111 803E[0F96]06            	cmp	byte [PARSE1_TYPE],result_drive
 19237                                  					;AN000; was a drive entered?
 19238                                  	;je	short tn_drive		;AN000; yes - go process
 19239                                  	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
 19240                                  	; 23/02/2023
 19241 00002116 7512                    	jne	short tn_filespec
 19242                                  
 19243                                  ;tn_eol: 
 19244                                  ;	;mov	ah,0			;AN000; no parameters on line
 19245                                  ;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19246                                  ;	;mov	al,dot_chr		;AN000;   for current dir
 19247                                  ;	mov	al,'.'
 19248                                  ;	stosw				;AN000; store in srcxname
 19249                                  ;	jmp	short tn_doit		;AN000; go do command
 19250                                  
 19251                                  tn_drive:				;AN000; a drive was entered
 19252 00002118 56                      	push	si			;AN000; save position in line
 19253 00002119 BE[1396]                	mov	si,PARSE1_ADDR		;AN000; get address of drive
 19254 0000211C AC                      	lodsb				;AN000; get the drive number
 19255 0000211D 0440                    	add	al,"A"-1 ; 40h		;AN000; convert it to char
 19256 0000211F AA                      	stosb				;AN000; store it in srcxname
 19257                                  	;mov	ax,dot_colon		;AN000; get colon and . and
 19258 00002120 B83A2E                  	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
 19259 00002123 AB                      	stosw				;AN000;  store in srcxname
 19260                                  	;mov	al,0
 19261 00002124 B000                    	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
 19262 00002126 AA                      	stosb				;AN000;
 19263 00002127 5E                      	pop	si			;AN000; get line position back
 19264 00002128 EB0C                    	jmp	short tn_check_eol	;AN000; check to make sure eol
 19265                                  
 19266                                  tn_filespec:				;AN000; a filespec was entered
 19267 0000212A 56                      	push	si			;AN000; save position in line
 19268 0000212B C536[1396]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19269                                  
 19270                                  tn_move_filename:			;AN000; put filespec in srcxname
 19271 0000212F AC                      	lodsb				;AN000; get a char from buffer
 19272 00002130 AA                      	stosb				;AN000; store in srcxname
 19273                                  	;;cmp	al,0
 19274                                  	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
 19275 00002131 08C0                    	or	al,al ; al = 0 ?
 19276 00002133 75FA                    	jnz	short tn_move_filename	;AN000; no - keep moving
 19277 00002135 5E                      	pop	si			;AN000; get line position back
 19278                                  
 19279                                  tn_check_eol:				;AN000; make sure no extra parms
 19280 00002136 BF[6A85]                	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
 19281 00002139 E88C00                  	call	parse_check_eol 	;AN000; are we at end of line?
 19282 0000213C 7407                    	jz	short tn_doit 		;AN000; Yes - do the command
 19283                                  tn_parse_error: 			;AN000; A parse error occurred
 19284 0000213E E93908                  	jmp	cerror			;AN000; Go to error routine
 19285                                  
 19286                                  tn_eol: 
 19287                                  	;23/02/2023
 19288                                  	;;mov	ah,0			;AN000; no parameters on line
 19289                                  	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19290                                  	;;mov	al,dot_chr		;AN000;   for current dir
 19291                                  	;mov	al,'.'
 19292 00002141 B82E00                  	mov	ax,002Eh
 19293 00002144 AB                      	stosw				;AN000; store in srcxname
 19294                                  	; 23/02/2023
 19295                                  	;jmp	short tn_doit		;AN000; go do command
 19296                                  
 19297                                  tn_doit:				;AN000;
 19298 00002145 BE[0E88]                	mov	si,SRCXNAME		;AN000; set up srcxname as source
 19299 00002148 BF[3F89]                	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
 19300                                  	;mov	ah,xNameTrans		;AN000; do name translate call
 19301 0000214B B460                    	mov	ah,60h
 19302 0000214D CD21                    	int	21h			;AN000;
 19303 0000214F 7311                    	jnc	short tn_print_xname	;AN000; If no error - print result
 19304                                  
 19305 00002151 E8B9FB                  	call	Set_Ext_Error_Msg	;AN000; get extended message
 19306 00002154 C706[D08C][0E88]        	mov	word [string_ptr_2],SRCXNAME
 19307                                  					;AN000; get address of failed string
 19308                                  	;mov	byte [extend_buf_sub],1
 19309 0000215A C606[777F]01            	mov	byte [extend_buf_sub],one_subst
 19310                                  					;AN000; put number of subst in control block
 19311 0000215F E91808                  	jmp	cerror			;AN000; Go to error routine
 19312                                  
 19313                                  tn_print_xname: 			;AN000;
 19314 00002162 C706[D08C][3F89]        	mov	word [string_ptr_2],COMBUF
 19315                                  					;AN000; Set up address of combuf
 19316 00002168 BA[3C81]                	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
 19317 0000216B E88B04                  	call	CRLF2			;AN000; print a crlf
 19318                                  	;call	Printf_Crlf		;AN000; print it out
 19319                                  	;retn				;AN000;
 19320                                  	; 23/02/2023
 19321 0000216E E9C42C                  	jmp	Printf_Crlf
 19322                                  
 19323                                  ; ---------------------------------------------------------------------------
 19324                                  
 19325                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19326                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
 19327                                  _$EXIT:
 19328                                  	; MSDOS 6.0
 19329 00002171 1E                      	push	ds			;AN000; save data segment
 19330 00002172 8E1E[E08A]              	mov	ds,[RESSEG]		;AN000; get resident data segment
 19331                                  	;assume	ds:resgroup		;AN000;
 19332                                  
 19333 00002176 803E[A501]00            	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
 19334 0000217B 740A                    	jz	short free_com		;AN045; no - free everything
 19335                                  
 19336                                  ;	We're a permanent command.
 19337                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
 19338                                  
 19339 0000217D 833E[A601]FF            	cmp	word [SingleCom],-1	;M034
 19340 00002182 7412                    	je	short no_reset		;M034 ; exit singlecom
 19341 00002184 E97DDF                  	jmp	TCOMMAND		;permanent command, recycle
 19342                                  
 19343                                  free_com:
 19344                                  	;mov	ax,(multdos shl 8 or message_2f)
 19345 00002187 B82E12                  	mov	ax,122Eh		;AN060; reset parse message pointers
 19346                                  	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
 19347 0000218A B205                    	mov	dl,5
 19348 0000218C 8B3E[BB01]              	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
 19349 00002190 8E06[BD01]              	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
 19350 00002194 CD2F                    	int	2Fh			;AN000; go set it
 19351                                  no_reset:				;AN045;
 19352 00002196 1F                      	pop	ds			;AN000; restore local data segment
 19353                                  	;assume	ds:trangroup		;AN000;
 19354                                  ;M040
 19355                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
 19356                                  ;this, restores user dir if flag is set and resets the flag.
 19357                                  
 19358                                  	;invoke	RestUDir1		;restore user dir if needed ;M040
 19359 00002197 E80C03                  	call	RestUDir1
 19360 0000219A 8E06[E08A]              	mov	es,[RESSEG]
 19361                                  	;assume	es:resgroup
 19362                                  
 19363 0000219E 26A1[4101]              	mov	ax,[es:Parent]
 19364                                  	;mov	[es:16h],ax
 19365                                  	;mov	[es:PDB_Parent_PID],ax
 19366 000021A2 26A31600                	mov	[es:PDB.PARENT_PID],ax
 19367 000021A6 26A1[4301]              	mov	ax,[es:OldTerm]
 19368                                  	;mov	[es:0Ah],ax
 19369                                  	;mov	[es:PDB_Exit],ax
 19370 000021AA 26A30A00                	mov	[es:PDB.EXIT],ax
 19371 000021AE 26A1[4501]              	mov	ax,[es:OldTerm+2]
 19372                                  	;mov	[es:0Ch],ax
 19373                                  	;mov	[es:PDB_Exit+2],ax
 19374 000021B2 26A30C00                	mov	[es:PDB.EXIT+2],ax
 19375                                  
 19376 000021B6 06                      	push	es
 19377 000021B7 8E06[F08A]              	mov	es,[TRAN_TPA]
 19378                                  	;mov	ah,DEALLOC
 19379 000021BB B449                    	mov	ah,49h
 19380 000021BD CD21                    	int	21h			; Now running in "free" space
 19381 000021BF 07                      	pop	es
 19382                                  
 19383                                  	;mov	ah,Exit
 19384 000021C0 B44C                    	mov	ah,4Ch
 19385                                  	;mov	al,byte ptr RetCode
 19386 000021C2 26A0[9D01]              	mov	al,[es:RetCode]
 19387 000021C6 CD21                    	int	21h
 19388                                  
 19389                                  	;..........
 19390                                  
 19391                                  ; 23/02/2023
 19392                                  %if 0
 19393                                  _$EXIT:
 19394                                  	; MSDOS 3.3
 19395                                  	mov	es,[RESSEG]
 19396                                  	mov	ax,[es:PARENT]
 19397                                  	;mov	[es:16h],ax
 19398                                  	mov	[es:PDB.PARENT_PID],ax
 19399                                  	mov	ax,[es:OLDTERM]
 19400                                  	;mov	[es:0Ah],ax
 19401                                  	mov	[es:PDB.EXIT],ax
 19402                                  	mov	ax,[es:OLDTERM+2]
 19403                                  	;mov	[es:0Ch],ax
 19404                                  	mov	[es:PDB.EXIT+2],ax
 19405                                  	push	es
 19406                                  	mov	es,[TRAN_TPA]
 19407                                  	mov	ah,DEALLOC ; 49h
 19408                                  	int	21h	; DOS -	2+ - FREE MEMORY
 19409                                  			; ES = segment address of area to be freed
 19410                                  	pop	es
 19411                                  	mov	ah,EXIT ; 4Ch
 19412                                  	;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
 19413                                  	mov	al,byte [es:RETCODE]
 19414                                  	int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
 19415                                  ;;here:
 19416                                  ;;	jmp	short here
 19417                                  %endif
 19418                                  
 19419                                  ; ---------------------------------------------------------------------------
 19420                                  
 19421                                  ; MSDOS 6.0
 19422                                  ; ****************************************************************
 19423                                  ; *
 19424                                  ; * ROUTINE:	 PARSE_CHECK_EOL
 19425                                  ; *
 19426                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
 19427                                  ; *		 If not end of line, set up to print parse
 19428                                  ; *		 error message. ASSUMES NO MORE PARAMETERS ARE
 19429                                  ; *		 EXPECTED!
 19430                                  ; *
 19431                                  ; * INPUT:	 DS:SI	  last output from parser
 19432                                  ; *		 ES:DI	  points to parse block
 19433                                  ; *		 CX	  last output from parser
 19434                                  ; *
 19435                                  ; * OUTPUT:	 AX	  parser return code
 19436                                  ; *
 19437                                  ; *		 if end of line found
 19438                                  ; *		     zero flag set
 19439                                  ; *		 else
 19440                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19441                                  ; *
 19442                                  ; ****************************************************************
 19443                                  
 19444                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19445                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h
 19446                                  
 19447                                  parse_check_eol:
 19448 000021C8 31D2                    	xor	dx,dx			;AN000;
 19449 000021CA 8936[488C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19450 000021CE E89F21                  	call	cmd_parse		;AN000; call parser
 19451 000021D1 3CFF                    	cmp	al,-1  ;0FFh
 19452                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
 19453 000021D3 7408                    	je	short parse_good_eol	;AN000; yes - no problem
 19454                                  	;cmp	ax,0
 19455                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
 19456 000021D5 21C0                    	and	ax,ax ; ax = 0 ?
 19457 000021D7 7501                    	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
 19458 000021D9 40                      	inc	ax			;AN018; set AX to 1 and turn off zero flag
 19459                                  ok_to_setup_pmsg:
 19460 000021DA E81000                  	call	setup_parse_error_msg	;AN018; go set up error message
 19461                                  parse_good_eol:
 19462                                  parse_msg_good:	; 23/02/2023
 19463 000021DD C3                      	retn				;AN000;
 19464                                  
 19465                                  ; ---------------------------------------------------------------------------
 19466                                  
 19467                                  ; MSDOS 6.0
 19468                                  ; ****************************************************************
 19469                                  ; *
 19470                                  ; * ROUTINE:	 PARSE_WITH_MSG
 19471                                  ; *
 19472                                  ; * FUNCTION:	 Calls parser. If an error occurred, the error
 19473                                  ; *		 message is set up.
 19474                                  ; *
 19475                                  ; * INPUT:	 DS:SI	  last output from parser
 19476                                  ; *		 ES:DI	  points to parse block
 19477                                  ; *		 CX	  last output from parser
 19478                                  ; *
 19479                                  ; * OUTPUT:	 AX	  parser return code
 19480                                  ; *
 19481                                  ; *		 if no error
 19482                                  ; *		     outputs from parser
 19483                                  ; *		 else
 19484                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19485                                  ; *		     error message set up for STD_PRINTF
 19486                                  ; *
 19487                                  ; ****************************************************************
 19488                                  
 19489                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19490                                  Parse_With_Msg:
 19491 000021DE 8936[488C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19492 000021E2 E88B21                  	call	cmd_parse		;AN018; call parser
 19493 000021E5 3CFF                    	cmp	al,-1  ;0FFh
 19494                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
 19495 000021E7 74F4                    	je	short parse_msg_good	;AN018; yes - no problem
 19496                                  	;cmp	ax,0
 19497                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
 19498 000021E9 09C0                    	or	ax,ax ; ax = 0 ?
 19499 000021EB 74F0                    	jz	short parse_msg_good	;AN018; yes - no problem
 19500                                  	; 23/02/2023
 19501                                  	;call	setup_parse_error_msg	;AN018; go set up error message
 19502                                  ;parse_msg_good:
 19503                                  	;retn				;AN018;
 19504                                  	; 23/02/2023
 19505                                  	;jmp	short setup_parse_error_msg	
 19506                                  
 19507                                  ; ---------------------------------------------------------------------------
 19508                                  
 19509                                  ; MSDOS 6.0
 19510                                  ; ****************************************************************
 19511                                  ; *
 19512                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
 19513                                  ; *
 19514                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
 19515                                  ; *		 message is set up.
 19516                                  ; *
 19517                                  ; * INPUT:	 AX	     Parse error number
 19518                                  ; *		 SI	     Set to past last parameter
 19519                                  ; *		 Parse_last  Set to start of last parameter
 19520                                  ; *
 19521                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
 19522                                  ; *		 error message set up for STD_PRINTF
 19523                                  ; *
 19524                                  ; ****************************************************************
 19525                                  
 19526                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19527                                  setup_parse_error_msg:
 19528 000021ED C606[737F]02            	mov	byte [msg_disp_class],parse_msg_class
 19529                                  	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
 19530 000021F2 BA[757F]                	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
 19531 000021F5 C60400                  	mov	byte [si],END_OF_LINE_OUT ; 0
 19532                                  					;AC018; terminate the parameter string
 19533 000021F8 A3[757F]                	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
 19534 000021FB 83F802                  	cmp	ax,2
 19535                                  	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
 19536 000021FE 740D                    	je	short setup_parse_msg_ret
 19537                                  					;AN018;    no subst
 19538 00002200 8B36[488C]              	mov	si,[parse_last] 	;AC018; get start of parameter
 19539 00002204 8936[D08C]              	mov	[string_ptr_2],si 	;AC018; get address of failed string
 19540 00002208 C606[777F]01            	mov	byte [extend_buf_sub],one_subst
 19541                                  					;AC018; put number of subst in control block
 19542                                  	;mov	byte [extend_buf_sub],1
 19543                                  setup_parse_msg_ret:
 19544 0000220D 46                      	inc	si			;AN018; make sure zero flag not set
 19545 0000220E C3                      	retn				;AC018;
 19546                                  
 19547                                  ;============================================================================
 19548                                  ; TENV.ASM, MSDOS 6.0, 1991
 19549                                  ;============================================================================
 19550                                  ; 08/10/2018 - Retro DOS v3.0
 19551                                  
 19552                                  ; TITLE	Part6 COMMAND Transient routines.
 19553                                  
 19554                                  ;	Environment utilities and misc. routines
 19555                                  
 19556                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
 19557                                  
 19558                                  ; 23/02/2023 - Retro DOS v4.0 (& v4.1)
 19559                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh
 19560                                  
 19561                                  ; ---------------------------------------------------------------------------
 19562                                  
 19563                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19564                                  ADD_PROMPT:
 19565 0000220F E8FC00                  	call	delete_prompt	; Delete any existing prompt
 19566 00002212 E8AD01                  	call	scan_double_null
 19567                                  
 19568                                  ADD_PROMPT2:
 19569 00002215 56                      	push	si
 19570 00002216 E89B01                  	call	GETARG
 19571 00002219 5E                      	pop	si
 19572 0000221A 7501                    	jnz	short ADD_PROMPT3
 19573                                  ADD_PROMPT_RETN:
 19574 0000221C C3                      	retn
 19575                                  ADD_PROMPT3:			; Pre scan for arguments
 19576 0000221D E87501                  	call	move_name	; Move in name
 19577 00002220 E89101                  	call	GETARG
 19578 00002223 56                      	push	si
 19579 00002224 EB53                    	jmp	short ADD_NAME
 19580                                  
 19581                                  ;break	The SET command
 19582                                  
 19583                                  ; Input: DS:SI points to a CR terminated string
 19584                                  ; Output: carry flag is set if no room
 19585                                  ;	  otherwise name is added to environment
 19586                                  
 19587                                  DISP_ENVJ:
 19588 00002226 E9BC00                  	jmp	DISP_ENV
 19589                                  
 19590                                  ADD_NAME_TO_ENVIRONMENT:
 19591 00002229 E88801                  	call	GETARG
 19592 0000222C 74F8                    	jz	short DISP_ENVJ
 19593                                  
 19594                                  ; check if line contains exactly one equals sign
 19595                                  
 19596 0000222E 31DB                    	xor	bx,bx		; = count is 0
 19597 00002230 56                      	push	si		; Save pointer to beginning of line
 19598                                  EQLP:
 19599 00002231 AC                      	lodsb			; Get a char
 19600 00002232 3C0D                    	cmp	al,13 ; 0Dh	; IF CR we're all done
 19601 00002234 740F                    	je	short QUEQ	
 19602 00002236 3C3D                    	cmp	al,'='		; Look for = sign	
 19603 00002238 75F7                    	jne	short EQLP	; not there, get next char
 19604 0000223A FEC3                    	inc	bl		; Otherwise increment EQ count
 19605 0000223C 803C0D                  	cmp	byte [si],13	; Look for CR following = sign
 19606 0000223F 75F0                    	jne	short EQLP
 19607 00002241 FEC7                    	inc	bh		; Set BH=1 means no parameters
 19608 00002243 EBEC                    	jmp	short EQLP	; And look for more
 19609                                  QUEQ:
 19610 00002245 5E                      	pop	si		; Restore beginning of line
 19611 00002246 FECB                    	dec	bl		; Zero flag means only one EQ
 19612 00002248 7406                    	jz	short ONEQ	; Good line
 19613 0000224A BA[0D80]                	mov	dx,SYNTMES_PTR
 19614 0000224D E92A07                  	jmp	cerror
 19615                                  ONEQ:
 19616 00002250 53                      	push	bx
 19617 00002251 E8BD00                  	call	delete_name_in_environment
 19618 00002254 5B                      	pop	bx
 19619 00002255 FECF                    	dec	bh
 19620 00002257 74C3                    	jz	short ADD_PROMPT_RETN
 19621 00002259 E86601                  	call	scan_double_null
 19622 0000225C 89FB                    	mov	bx,di		; Save ptr to beginning of env var name
 19623 0000225E E83401                  	call	move_name
 19624 00002261 56                      	push	si
 19625 00002262 87DF                    	xchg	bx,di		; Switch ptrs to beginning and end of
 19626                                  				;  env var name
 19627                                  		
 19628                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
 19629                                  ; necessary in the resident for re-reading the transient. Let's look for
 19630                                  ; COMSPEC=
 19631                                  
 19632 00002264 C606[BC84]00            	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
 19633 00002269 BE[F181]                	mov	si,COMSPECSTR ; "COMSPEC="
 19634 0000226C B90400                  	mov	cx,4
 19635 0000226F F3A7                    	repe	cmpsw
 19636 00002271 7504                    	jnz	short NOT_COMSPEC
 19637                                  				; Zero set => exact match
 19638 00002273 FE06[BC84]              	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
 19639                                  	;mov	byte [COMSPEC_FLAG],1
 19640                                  NOT_COMSPEC:
 19641 00002277 89DF                    	mov	di,bx		; Load ptr to end of env var name
 19642                                  ADD_NAME:
 19643 00002279 5E                      	pop	si		; Add the value of the new env var
 19644 0000227A 56                      	push	si		;  to the environment.
 19645                                  ADD_NAME1:
 19646 0000227B AC                      	lodsb
 19647 0000227C 3C0D                    	cmp	al,13 ; 0Dh
 19648 0000227E 7405                    	je	short ADD_NAME_RET
 19649 00002280 E8AD01                  	call	store_char
 19650 00002283 EBF6                    	jmp	short ADD_NAME1
 19651                                  ADD_NAME_RET:
 19652 00002285 5E                      	pop	si
 19653 00002286 803E[BC84]00            	cmp	byte [comspec_flag],0
 19654                                  				; If the new env var is comspec,	
 19655                                  ADD_NAME_JZ_RET:
 19656 0000228B 748F                    	jz	short ADD_PROMPT_RETN 
 19657                                  				;  copy the value into the
 19658                                  				;  comspec var in the resident
 19659                                  
 19660                                  ; We have changed the COMSPEC variable. We need to update the resident
 19661                                  ; pieces necessary to reread in the info. First, skip all delimiters
 19662                                  
 19663 0000228D E87603                  	call	scanoff
 19664 00002290 8E06[E08A]              	mov	es,[RESSEG]	;  comspec var in the resident
 19665                                  
 19666                                  ; Make sure that the printer knows where the beginning of the string is
 19667                                  
 19668 00002294 BF[4E01]                	mov	di,ComSpec
 19669 00002297 89FB                    	mov	bx,di
 19670                                  
 19671                                  ; Generate drive letter for display
 19672                                  
 19673 00002299 31C0                    	xor	ax,ax		;g assume no drive first
 19674 0000229B 26A2[9701]              	mov	[es:ComDrv],al
 19675                                  	; 23/02/2023
 19676                                  	; MSDOS 6.0 (& 5.0)
 19677 0000229F 50                      	push	ax		;AN000; 3/3/KK
 19678 000022A0 8A04                    	mov	al,[si]		;AN000; 3/3/KK
 19679 000022A2 E83F01                  	call	testkanj	;AN000; 3/3/KK	
 19680 000022A5 58                      	pop	ax		;AN000; 3/3/KK
 19681 000022A6 7518                    	jnz	short _GOTDRIVE
 19682                                  	;
 19683 000022A8 807C013A                	cmp	byte [si+1],':'	; drive specified?
 19684 000022AC 7512                    	jne	short _GOTDRIVE
 19685 000022AE 8A04                    	mov	al,[si]		; get his specified drive
 19686                                  	; 23/02/2023
 19687 000022B0 E85B01                  	call	UPCONV
 19688                                  	;call	UPCONV_MAPCALL	; convert to uppercase
 19689 000022B3 2C41                    	sub	al,'A'		; convert to 0-based
 19690 000022B5 83C702                  	add	di,2
 19691 000022B8 FEC0                    	inc	al		; convert to 1-based number
 19692 000022BA 26A2[9701]              	mov	[es:ComDrv],al
 19693                                  
 19694                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
 19695                                  ; done here..
 19696                                  	;add	al,40h
 19697 000022BE 0440                    	add	al,'A'-1
 19698                                  _GOTDRIVE:
 19699                                  	; 23/02/2023
 19700                                  	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
 19701                                  	;mov	[es:PUTBACKSUBSTPTR],di
 19702                                  	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
 19703 000022C0 26893E[2D01]            	mov	[es:PutBackComSpec],di
 19704                                  				;g point to beginning of name after drive
 19705                                  	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
 19706                                  	;mov	[es:PUTBACKDRV],al
 19707                                  	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
 19708 000022C5 26A2[3201]              	mov	[es:PutBackDrv],al
 19709                                  
 19710                                  ; Copy chars until delim      	
 19711                                  
 19712 000022C9 89DF                    	mov	di,bx
 19713                                  COPY_COMSPEC:
 19714 000022CB AC                      	lodsb
 19715 000022CC E83F03                  	call	DELIM
 19716 000022CF 7407                    	jz	short COPYDONE
 19717 000022D1 3C0D                    	cmp	al,13 ; 0Dh
 19718 000022D3 7403                    	je	short COPYDONE
 19719 000022D5 AA                      	stosb
 19720 000022D6 EBF3                    	jmp	short COPY_COMSPEC
 19721                                  COPYDONE:
 19722 000022D8 30C0                    	xor	al,al		; Null terminate the string and quit
 19723 000022DA AA                      	stosb
 19724                                  	;mov	byte [comspec_flag],0
 19725 000022DB A2[BC84]                	mov	[comspec_flag],al ; 0 ; 23/02/2023
 19726 000022DE 4F                      	dec	di
 19727 000022DF 26893E[8E01]            	mov	[es:ComSpec_End],di
 19728 000022E4 C3                      	retn
 19729                                  
 19730                                  DISP_ENV:
 19731 000022E5 8E1E[E08A]              	mov	ds,[RESSEG]
 19732 000022E9 8E1E[3F03]              	mov	ds,[EnvirSeg]
 19733                                  	; assume ds:nothing
 19734 000022ED 31F6                    	xor	si,si
 19735                                  PENVLP:
 19736 000022EF 803C00                  	cmp	byte [si],0
 19737 000022F2 7497                    	jz	short ADD_NAME_JZ_RET
 19738 000022F4 BF[4C8C]                	mov	di,Arg_Buf
 19739                                  PENVLP2:
 19740 000022F7 AC                      	lodsb
 19741 000022F8 AA                      	stosb
 19742 000022F9 08C0                    	or	al,al
 19743 000022FB 75FA                    	jnz	short PENVLP2
 19744 000022FD BA[1281]                	mov	dx,arg_buf_ptr
 19745 00002300 1E                      	push	ds
 19746 00002301 06                      	push	es
 19747 00002302 1F                      	pop	ds
 19748                                  	; assume ds:nothing
 19749 00002303 E82F2B                  	call	Printf_Crlf
 19750 00002306 1F                      	pop	ds
 19751 00002307 EBE6                    	jmp	short PENVLP
 19752                                  
 19753                                  ; =============== S U B	R O U T	I N E =======================================
 19754                                  
 19755                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19756                                  delete_path:
 19757 00002309 BE[E581]                	mov	si,PATH_TEXT ; "PATH="
 19758 0000230C EB03                    	jmp	short delete_name_in_environment
 19759                                  
 19760                                  ; =============== S U B	R O U T	I N E =======================================
 19761                                  
 19762                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19763                                  delete_prompt:
 19764 0000230E BE[EA81]                	mov	si,PROMPT_TEXT ; "PROMPT="
 19765                                  
 19766                                  ; ---------------------------------------------------------------------------
 19767                                  
 19768                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19769                                  delete_name_in_environment:
 19770                                  
 19771                                  ; Input: DS:SI points to a "=" terminated string
 19772                                  ; Output: carry flag is set if name not found
 19773                                  ;	  otherwise name is deleted
 19774                                  
 19775 00002311 56                      	push	si
 19776 00002312 1E                      	push	ds
 19777 00002313 E82C00                  	call	FIND		; ES:DI points to name
 19778 00002316 7217                    	jc	short del1
 19779 00002318 89FE                    	mov	si,di		; Save it
 19780 0000231A E8BF00                  	call	SCASB2		; Scan for the nul
 19781 0000231D 87F7                    	xchg	si,di
 19782                                  ;SR;
 19783                                  ; If we have only one env string, then the double null is lost when the last
 19784                                  ;string is deleted and we have an invalid empty environment with only a 
 19785                                  ;single null. To avoid this, we will look for the double null case and then
 19786                                  ;move an extra null char.
 19787                                  ; Bugbug: The only possible problem is that the last pathstring 
 19788                                  ;will be followed by a triple null. Is this really a problem?
 19789                                  
 19790                                  	; MSDOS 6.0
 19791 0000231F 26803C00                	cmp	byte [es:si],0	;null char?
 19792 00002323 7501                    	jnz	short not_dnull	;no, we are at a double null
 19793 00002325 4E                      	dec	si		;point at the double null
 19794                                  not_dnull:
 19795                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19796 00002326 E86901                  	call	GETENVSIZ
 19797 00002329 29F1                    	sub	cx,si
 19798 0000232B 06                      	push	es
 19799 0000232C 1F                      	pop	ds		; ES:DI points to name
 19800                                  				; DS:SI points to next name
 19801 0000232D F3A4                    	rep	movsb
 19802                                  del1:
 19803 0000232F 1F                      	pop	ds
 19804 00002330 5E                      	pop	si
 19805                                  find_retn:
 19806 00002331 C3                      	retn
 19807                                  
 19808                                  ; =============== S U B	R O U T	I N E =======================================
 19809                                  
 19810                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19811                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
 19812                                  find_path:
 19813 00002332 BE[E581]                	mov	si,PATH_TEXT ; "PATH="
 19814 00002335 EB03                    	jmp	short find_name_in_environment
 19815                                  
 19816                                  ; =============== S U B	R O U T	I N E =======================================
 19817                                  
 19818                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19819                                  find_prompt:
 19820 00002337 BE[EA81]                	mov	si,PROMPT_TEXT ; "PROMPT="
 19821                                  
 19822                                  ; ---------------------------------------------------------------------------
 19823                                  
 19824                                  find_name_in_environment:
 19825                                  
 19826                                  ; Input: DS:SI points to a "=" terminated string
 19827                                  ; Output: ES:DI points to the arguments in the environment
 19828                                  ;	  zero is set if name not found
 19829                                  ;	  carry flag is set if name not valid format
 19830                                  
 19831 0000233A E80500                  	call	FIND		; Find the name
 19832 0000233D 72F2                    	jc	short find_retn	; Carry means not found	
 19833 0000233F E99600                  	jmp	SCASB1		; Scan for = sign
 19834                                  
 19835                                  ; ---------------------------------------------------------------------------
 19836                                  	;nop
 19837                                  
 19838                                  ; =============== S U B	R O U T	I N E =======================================
 19839                                  
 19840                                  ; On return of FIND1, ES:DI points to beginning of name
 19841                                  
 19842                                  FIND:
 19843 00002342 FC                      	cld
 19844 00002343 E84100                  	call	COUNT0		; CX = Length of name
 19845 00002346 8E06[E08A]              	mov	es,[RESSEG]
 19846                                  	;assume es:RESGROUP
 19847 0000234A 268E06[3F03]            	mov	es,[es:EnvirSeg]
 19848                                  	;assume es:NOTHING
 19849 0000234F 31FF                    	xor	di,di
 19850                                  find1:	
 19851 00002351 51                      	push	cx
 19852 00002352 56                      	push	si
 19853 00002353 57                      	push	di
 19854                                  find11:
 19855 00002354 AC                      	lodsb
 19856                                  	; 23/02/2023 
 19857                                  	; MSDOS 6.0 (& 5.0)
 19858 00002355 E88C00                  	call	testkanj	
 19859 00002358 740F                    	jz	short notkanj3
 19860 0000235A 4E                      	dec	si
 19861 0000235B AD                      	lodsw
 19862 0000235C 47                      	inc	di
 19863 0000235D 47                      	inc	di
 19864 0000235E 263B45FE                	cmp	ax,[es:di-2]
 19865 00002362 7511                    	jne	short find12
 19866 00002364 49                      	dec	cx
 19867 00002365 E2ED                    	loop	find11
 19868 00002367 EB0C                    	jmp	short find12
 19869                                  notkanj3:
 19870 00002369 E8A200                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 19871                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 19872 0000236C 47                      	inc	di
 19873 0000236D 263A45FF                	cmp	al,[es:di-1]
 19874 00002371 7502                    	jne	short find12
 19875 00002373 E2DF                    	loop	find11
 19876                                  find12:
 19877 00002375 5F                      	pop	di
 19878 00002376 5E                      	pop	si
 19879 00002377 59                      	pop	cx
 19880 00002378 74B7                    	jz	short find_retn
 19881 0000237A 51                      	push	cx
 19882 0000237B E85E00                  	call	SCASB2		; Scan for a nul
 19883 0000237E 59                      	pop	cx
 19884 0000237F 26803D00                	cmp	byte [es:di],0
 19885 00002383 75CC                    	jnz	short find1
 19886 00002385 F9                      	stc			; Indicate not found
 19887 00002386 C3                      	retn
 19888                                  
 19889                                  ; =============== S U B	R O U T	I N E =======================================
 19890                                  
 19891                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19892                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
 19893                                  COUNT0:
 19894 00002387 1E                      	push	ds
 19895 00002388 07                      	pop	es
 19896                                  	;assume es:nothing
 19897 00002389 89F7                    	mov	di,si
 19898                                  ;COUNT1:
 19899 0000238B 57                      	push	di		; Count number of chars until "="
 19900 0000238C E84900                  	call	SCASB1
 19901                                  	; 23/02/2023
 19902                                  ;	jmp	short COUNTX
 19903                                  ;COUNT2:
 19904                                  ;	push	di		; Count number of chars until nul
 19905                                  ;	call	SCASB2
 19906                                  ;COUNTX:
 19907 0000238F 59                      	pop	cx
 19908 00002390 29CF                    	sub	di,cx
 19909 00002392 87F9                    	xchg	di,cx
 19910                                  move_name_retn:
 19911 00002394 C3                      	retn
 19912                                  
 19913                                  ; =============== S U B	R O U T	I N E =======================================
 19914                                  
 19915                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19916                                  move_name:
 19917 00002395 803C0D                  	cmp	byte [si],13 ; 0Dh
 19918 00002398 74FA                    	je	short move_name_retn
 19919 0000239A AC                      	lodsb
 19920                                  	; 23/02/2023 
 19921                                  	; MSDOS 6.0 (& 5.0)
 19922 0000239B E84600                  	call	testkanj		
 19923 0000239E 7409                    	jz	short notkanj1
 19924 000023A0 E88D00                  	call	store_char
 19925 000023A3 AC                      	lodsb
 19926 000023A4 E88900                  	call	store_char
 19927 000023A7 EBEC                    	jmp	short move_name
 19928                                  notkanj1: 
 19929 000023A9 E86200                  	call	UPCONV
 19930                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3
 19931 000023AC E88100                  	call	store_char
 19932 000023AF 3C3D                    	cmp	al,'='
 19933 000023B1 75E2                    	jne	short move_name
 19934                                  getarg_retn:
 19935 000023B3 C3                      	retn
 19936                                  
 19937                                  ; =============== S U B	R O U T	I N E =======================================
 19938                                  
 19939                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19940                                  GETARG:
 19941 000023B4 BE8000                  	mov	si,80h
 19942 000023B7 AC                      	lodsb
 19943 000023B8 08C0                    	or	al,al
 19944 000023BA 74F7                    	jz	short getarg_retn
 19945 000023BC E84702                  	call	scanoff
 19946 000023BF 3C0D                    	cmp	al,13 ; 0Dh
 19947                                  sdn_retn:
 19948 000023C1 C3                      	retn
 19949                                  
 19950                                  ; =============== S U B	R O U T	I N E =======================================
 19951                                  
 19952                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
 19953                                  ; there is NO double NULL, merely a string that is empty.
 19954                                  
 19955                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19956                                  scan_double_null:
 19957 000023C2 8E06[E08A]              	mov	es,[RESSEG]
 19958 000023C6 268E06[3F03]            	mov	es,[es:EnvirSeg]
 19959 000023CB 31FF                    	xor	di,di
 19960                                  
 19961                                  ; Top cycle-point. If the string here is empty, then we are done
 19962                                  
 19963                                  sdn1:
 19964 000023CD 26803D00                	cmp	byte [es:di],0	; nul string?
 19965 000023D1 74EE                    	jz	short sdn_retn	; yep, all done
 19966 000023D3 E80600                  	call	SCASB2
 19967 000023D6 EBF5                    	jmp	short sdn1
 19968                                  
 19969                                  ; =============== S U B	R O U T	I N E =======================================
 19970                                  
 19971                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19972                                  SCASB1:
 19973 000023D8 B03D                    	mov	al,'='		; Scan for an =
 19974 000023DA EB02                    	jmp	short SCASBX
 19975                                  
 19976                                  ; =============== S U B	R O U T	I N E =======================================
 19977                                  
 19978                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19979                                  SCASB2:
 19980 000023DC 30C0                    	xor	al,al		; Scan for a nul
 19981                                  
 19982                                  ; ---------------------------------------------------------------------------
 19983                                  
 19984                                  	; 23/02/2023
 19985                                  SCASBX:
 19986 000023DE B90001                  	mov	cx,256
 19987 000023E1 F2AE                    	repne	scasb
 19988 000023E3 C3                      	retn
 19989                                  
 19990                                  ; =============== S U B	R O U T	I N E =======================================
 19991                                  
 19992                                  ; MSDOS 6.0
 19993                                  
 19994                                  ;Bugbug: This is Kanji stuff - put it in conditionals
 19995                                  
 19996                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19997                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
 19998                                  testkanj:
 19999 000023E4 1E                      	push	ds			;AN000;  3/3/KK
 20000 000023E5 56                      	push	si			;AN000;  3/3/KK
 20001 000023E6 50                      	push	ax			;AN000;  3/3/KK
 20002 000023E7 2E8E1E[E08A]            	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
 20003 000023EC C536[BF01]              	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
 20004                                  ktlop:					;AN000;  3/3/KK
 20005 000023F0 833C00                  	cmp	word [si],0		;AN000;  end of Table 3/3/KK
 20006 000023F3 740E                    	je	short notlead 		;AN000;  3/3/KK
 20007 000023F5 58                      	pop	ax			;AN000;  3/3/KK
 20008 000023F6 50                      	push	ax			;AN000;  3/3/KK
 20009 000023F7 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20010 000023F9 7208                    	jb	short notlead 		;AN000;  3/3/KK
 20011 000023FB 46                      	inc	si			;AN000;  3/3/KK
 20012 000023FC 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20013 000023FE 7607                    	jbe	short islead		;AN000;  3/3/KK
 20014 00002400 46                      	inc	si			;AN000;  3/3/KK
 20015 00002401 EBED                    	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
 20016                                  notlead:				;AN000;  3/3/KK
 20017 00002403 31C0                    	xor	ax,ax			;AN000;  set zero 3/3/KK
 20018 00002405 EB03                    	jmp	short ktret		;AN000;  3/3/KK
 20019                                  islead: 				;AN000;  3/3/KK
 20020 00002407 31C0                    	xor	ax,ax			;AN000;  reset zero 3/3/KK
 20021 00002409 40                      	inc	ax			;AN000;  3/3/KK
 20022                                  ktret:					;AN000;  3/3/KK
 20023 0000240A 58                      	pop	ax			;AN000;  3/3/KK
 20024 0000240B 5E                      	pop	si			;AN000;  3/3/KK
 20025 0000240C 1F                      	pop	ds			;AN000;  3/3/KK
 20026 0000240D C3                      	retn				;AN000;  3/3/KK
 20027                                  
 20028                                  ; =============== S U B	R O U T	I N E =======================================
 20029                                  
 20030                                  ; MSDOS 6.0
 20031                                  
 20032                                  ; ****************************************************************
 20033                                  ; *
 20034                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 20035                                  ; *
 20036                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 20037                                  ; *		 the character in AL from the file upper case table
 20038                                  ; *		 in DOS if character if above  ascii 128, else
 20039                                  ; *		 subtracts 20H if between "a" and "z".
 20040                                  ; *
 20041                                  ; * INPUT:	 AL	      char to be upper cased
 20042                                  ; *		 FUCASE_ADDR  set to the file upper case table
 20043                                  ; *
 20044                                  ; * OUTPUT:	 AL	      upper cased character
 20045                                  ; *
 20046                                  ; ****************************************************************
 20047                                  
 20048                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20049                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
 20050                                  UPCONV:
 20051 0000240E 3C80                    	cmp	al,80h			;AN000;  see if char is > ascii 128
 20052 00002410 7213                    	jb	short oth_fucase	;AN000;  no - upper case math
 20053 00002412 2C80                    	sub	al,80h			;AN000;  only upper 128 chars in table
 20054 00002414 1E                      	push	ds			;AN000;
 20055 00002415 53                      	push	bx			;AN000;
 20056 00002416 8E1E[E08A]              	mov	ds,[RESSEG]		;AN000;  get resident data segment
 20057                                  	;lds	bx,dword ptr FUCase_Addr+1
 20058 0000241A C51E[B701]              	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
 20059 0000241E 83C302                  	add	bx,2			;AN000;  skip over first word
 20060                                  	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
 20061 00002421 D7                      	xlat
 20062 00002422 5B                      	pop	bx			;AN000;
 20063 00002423 1F                      	pop	ds			;AN000;
 20064                                  	;jmp	short upconv_end	;AN000;  we finished - exit
 20065                                  	; 24/02/2023
 20066 00002424 C3                      	retn
 20067                                  oth_fucase:				;AN000;
 20068 00002425 3C61                    	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
 20069 00002427 7206                    	jb	short upconv_end	;AC000;    subtract 20h to get
 20070 00002429 3C7A                    	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
 20071 0000242B 7702                    	ja	short upconv_end	;AC000;
 20072 0000242D 2C20                    	sub	al,20h			;AC000; Change lower-case to upper
 20073                                  upconv_end:				;AN000;
 20074 0000242F C3                      	retn
 20075                                  
 20076                                  ; ---------------------------------------------------------------------------
 20077                                  
 20078                                  ; MSDOS 3.3
 20079                                  
 20080                                  	; 24/02/2023
 20081                                  ;UPCONV_MAPCALL:
 20082                                  	;			; If between "a" and "z"
 20083                                  	;cmp	al,[small_a]
 20084                                  	;jb	short UPCONV_END
 20085                                  	;cmp	al,[small_z]
 20086                                  	;ja	short UPCONV_END
 20087                                  	;sub	al,20h		; Change lower-case to upper
 20088                                  ;UPCONV_END:
 20089                                  	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
 20090                                  	;			  ; 	  for (current) country
 20091                                  	;retn
 20092                                  
 20093                                  ; =============== S U B	R O U T	I N E =======================================
 20094                                  
 20095                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
 20096                                  
 20097                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20098                                  store_char:
 20099 00002430 51                      	push	cx
 20100 00002431 53                      	push	bx
 20101                                  
 20102                                  	; 24/02/2023
 20103                                  	;;16/10/2018
 20104                                  	; MSDOS 6.0
 20105 00002432 06                      	push	es		;AN056;*
 20106 00002433 1E                      	push	ds		;AN056; Save local DS
 20107 00002434 8E1E[E08A]              	mov	ds,[RESSEG]	;AN056; Get resident segment
 20108 00002438 8E06[3F03]              	mov	es,[EnvirSeg]	;AN056; Get environment segment
 20109 0000243C 1F                      	pop	ds		;AN056; Get local segment back
 20110                                  
 20111                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20112 0000243D E85200                  	call	GETENVSIZ
 20113 00002440 89CB                    	mov	bx,cx		; Save room for double nul	
 20114 00002442 83EB02                  	sub	bx,2
 20115 00002445 39DF                    	cmp	di,bx
 20116 00002447 723F                    	jb	short store1
 20117 00002449 50                      	push	ax
 20118 0000244A 51                      	push	cx
 20119 0000244B 53                      	push	bx		; Save Size of environment
 20120 0000244C E8B5E2                  	call	FREE_TPA
 20121 0000244F 5B                      	pop	bx
 20122 00002450 83C302                  	add	bx,2		; Recover true environment size
 20123                                  
 20124 00002453 81FB0080                	cmp	bx,8000h	; Don't let environment grow > 32K	
 20125 00002457 7203                    	jb	short envsiz_ok
 20126                                  bad_env_size:			;AN056;
 20127 00002459 F9                      	stc
 20128 0000245A EB16                    	jmp	short envnoset
 20129                                  	;nop
 20130                                  envsiz_ok:
 20131 0000245C B104                    	mov	cl,4
 20132 0000245E D3EB                    	shr	bx,cl		; Convert back to paragraphs
 20133 00002460 43                      	inc	bx
 20134                                  	; 24/02/2023
 20135                                  	; MSDOS 6.0
 20136 00002461 8CC1                    	mov	cx,es		;AN056; Get environment segment
 20137 00002463 01D9                    	add	cx,bx		;AN056; Add in size of environment
 20138 00002465 83C120                  	add	cx,20h		;AN056; Add in some TPA
 20139 00002468 8CC8                    	mov	ax,cs		;AN056; Get the transient segment
 20140 0000246A 39C1                    	cmp	cx,ax		;AN056; Are we hitting the transient?
 20141 0000246C 73EB                    	jnb	short bad_env_size
 20142                                  				;AN056; Yes - don't do it!!!
 20143                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20144 0000246E B44A                    	mov	ah,4Ah
 20145                                  	;mov	ah,SETBLOCK ; 4Ah
 20146 00002470 CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 20147                                  			; ES = segment address of block	to change
 20148                                  			; BX = new size	in paragraphs
 20149                                  envnoset:
 20150 00002472 9C                      	pushf
 20151 00002473 06                      	push	es
 20152 00002474 8E06[E08A]              	mov	es,[RESSEG]
 20153 00002478 E899E2                  	call	ALLOC_TPA
 20154 0000247B 07                      	pop	es
 20155 0000247C 9D                      	popf
 20156 0000247D 59                      	pop	cx
 20157 0000247E 58                      	pop	ax
 20158                                  	; 24/02/2023
 20159 0000247F 07                      	pop	es ; MSDOS 6.0	;AN056;*	
 20160 00002480 7306                    	jnc	short store1
 20161 00002482 BA[8C7F]                	mov	dx,ENVERR_PTR
 20162 00002485 E9F204                  	jmp	cerror
 20163                                  store1:	
 20164 00002488 AA                      	stosb
 20165 00002489 26C7050000              	mov	word [es:di],0	; NULL IS AT END
 20166                                  	; 24/02/2023
 20167 0000248E 07                      	pop	es ; MSDOS 6.0	;AN056;*
 20168 0000248F 5B                      	pop	bx
 20169 00002490 59                      	pop	cx
 20170 00002491 C3                      	retn
 20171                                  
 20172                                  ; =============== S U B	R O U T	I N E =======================================
 20173                                  
 20174                                  	; 24/02/2023
 20175                                  GETENVSIZ:
 20176                                  
 20177                                  ;Get size of environment in bytes, rounded up to paragraph boundry
 20178                                  ;ES has environment segment
 20179                                  ;Size returned in CX, all other registers preserved
 20180                                  
 20181 00002492 06                      	push	es
 20182 00002493 50                      	push	ax
 20183 00002494 8CC0                    	mov	ax,es
 20184 00002496 48                      	dec	ax		;Point at arena	
 20185 00002497 8EC0                    	mov	es,ax
 20186                                  	;mov	ax,[es:3]
 20187 00002499 26A10300                	mov	ax,[es:ARENA.size]
 20188 0000249D B104                    	mov	cl,4
 20189 0000249F D3E0                    	shl	ax,cl		;Convert to bytes
 20190 000024A1 89C1                    	mov	cx,ax
 20191 000024A3 58                      	pop	ax
 20192 000024A4 07                      	pop	es
 20193                                  getenvsiz_retn:
 20194 000024A5 C3                      	retn
 20195                                  
 20196                                  ; =============== S U B	R O U T	I N E =======================================
 20197                                  
 20198                                  	; 24/02/2023
 20199                                  RestUDir1:
 20200 000024A6 1E                      	push	ds
 20201 000024A7 8E1E[E08A]              	mov	ds,[RESSEG]
 20202 000024AB 803E[A401]00            	cmp	byte [RestDir],0
 20203 000024B0 1F                      	pop	ds
 20204 000024B1 74F2                    	jz	short getenvsiz_retn
 20205                                  
 20206                                  ; =============== S U B	R O U T	I N E =======================================
 20207                                  
 20208                                  	; 24/02/2023
 20209                                  RestUDir:
 20210 000024B3 BA[C289]                	mov	dx,USERDIR1
 20211 000024B6 B43B                    	mov	ah,3Bh
 20212                                  	;mov	ah,CHDir ; 3Bh
 20213 000024B8 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20214                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 20215 000024BA 30C0                    	xor	al,al
 20216                                  	;call	SETREST
 20217                                  	;retn
 20218                                  	; 24/02/2023
 20219 000024BC E95508                  	jmp	SETREST	
 20220                                  
 20221                                  ;============================================================================
 20222                                  ; TENV2.ASM, MSDOS 6.0, 1991
 20223                                  ;============================================================================
 20224                                  ; 07/10/2018 - Retro DOS v3.0
 20225                                  
 20226                                  ; TITLE	Part6 COMMAND Transient routines.
 20227                                  
 20228                                  ;	Environment utilities and misc. routines
 20229                                  
 20230                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
 20231                                  
 20232                                  ; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20233                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h
 20234                                  
 20235                                  ; ---------------------------------------------------------------------------
 20236                                  
 20237                                  ; ****************************************************************
 20238                                  ; *
 20239                                  ; * ROUTINE:	 $CHDIR
 20240                                  ; *
 20241                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
 20242                                  ; *		 line. If path is found, CHDIR to path. If a drive
 20243                                  ; *		 letter is found, get and display the current dir
 20244                                  ; *		 of the specified drive. If nothing is found, get
 20245                                  ; *		 and display the current dir of the default drive.
 20246                                  ; *
 20247                                  ; * INPUT:	 command line at offset 81H
 20248                                  ; *
 20249                                  ; * OUTPUT:	 none
 20250                                  ; *
 20251                                  ; ****************************************************************
 20252                                  
 20253                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20254                                  _$CHDIR:
 20255                                  	; MSDOS 6.0
 20256 000024BF BE8100                  	mov	si,81h
 20257 000024C2 BF[6A85]                	mov	di,PARSE_CHDIR
 20258                                  				;AN000; Get address of PARSE_CHDIR
 20259 000024C5 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20260 000024C7 31D2                    	xor	dx,dx		;AN000;
 20261 000024C9 E812FD                  	call	Parse_With_Msg	;AC018; call parser
 20262                                  	
 20263 000024CC 83F8FF                  	cmp	ax,-1
 20264                                  	;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 20265 000024CF 7415                    	je	short bwdj	; No args
 20266                                  	;cmp	ax,0
 20267                                  	;cmp	ax,RESULT_NO_ERROR
 20268                                  				;AC000; did we have an error?
 20269 000024D1 09C0                    	or	ax,ax ; ax = 0 ?
 20270 000024D3 756D                    	jnz	short ChDirErr	;AC018; yes - exit
 20271                                  	
 20272                                  	;cmp	byte [PARSE1_TYPE],6
 20273 000024D5 803E[0F96]06            	cmp	byte [PARSE1_TYPE],result_drive
 20274                                  				;AC000; was a drive entered?
 20275 000024DA 7511                    	jne	short REALCD	; no
 20276                                  
 20277                                  ; D: was found. See if there is anything more.
 20278                                  
 20279 000024DC BF[6A85]                	mov	di,PARSE_CHDIR
 20280                                  				;AC000; get address of parse_chdir
 20281 000024DF 31D2                    	xor	dx,dx		;AC000;
 20282 000024E1 E8E4FC                  	call	parse_check_eol ;AC000; call parser
 20283 000024E4 755C                    	jnz	short ChDirErr	;AC000;
 20284                                  bwdj:
 20285 000024E6 E86DF9                  	call	build_dir_for_chdir
 20286                                  				; Drive only specified
 20287 000024E9 E80D01                  	call	CRLF2
 20288                                  chdir_retn:
 20289 000024EC C3                      	retn
 20290                                  
 20291                                  	; 24/02/2023
 20292                                  	; MSDOS 3.3
 20293                                  	;mov	ax,[COMSW]
 20294                                  	;or	ax,[ALLSWITCH]
 20295                                  	;mov	dx,BADPARMPTR
 20296                                  	;jnz	short CHDIR_ERR
 20297                                  	;mov	si,81h
 20298                                  	;call	SCANOFF
 20299                                  	;cmp	al,0Dh		; are we at end of line?
 20300                                  	;je	short BWDJ	; No args
 20301                                  	;inc	si
 20302                                  	;lodsb
 20303                                  	;cmp	al,':'
 20304                                  	;jne	short REALCD
 20305                                  	;push	si
 20306                                  	;call	SCANOFF
 20307                                  	;pop	si
 20308                                  	;cmp	al,0Dh		; was a drive entered?
 20309                                  	;jne	short REALCD	; no
 20310                                  ;BWDJ:
 20311                                  	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
 20312                                  	;call	CRLF2
 20313                                  ;CHDIR_RETN:
 20314                                  	;retn
 20315                                  
 20316                                  	; 24/02/2023
 20317                                  	; MSDOS 6.0
 20318                                  REALCD:
 20319 000024ED 56                      	push	si		;AN000; save position in line
 20320 000024EE C536[1396]              	lds	si,[PARSE1_ADDR]
 20321                                  				;AN000; get address of filespec
 20322 000024F2 E8E107                  	call	Move_To_SrcBuf	;AN000; move to srcbuf
 20323 000024F5 5E                      	pop	si		;AN000; restore position in line
 20324 000024F6 BF[6A85]                	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
 20325 000024F9 31D2                    	xor	dx,dx		;AC000;
 20326 000024FB E8CAFC                  	call	parse_check_eol ;AC000; call parser
 20327 000024FE 7542                    	jnz	short ChDirErr	;AC000;
 20328                                  	
 20329 00002500 E81106                  	call	SETPATH
 20330 00002503 F606[EB8C]02            	test	byte [DestInfo],2
 20331 00002508 7518                    	jnz	short BadChDir
 20332                                  
 20333                                  	; 26/04/2023
 20334 0000250A B43B                    	mov	ah,3Bh
 20335                                  	;mov	ah,CHDir
 20336 0000250C CD21                    	int	21h
 20337 0000250E 73DC                    	jnc	short chdir_retn
 20338                                  	
 20339 00002510 E80AF8                  	call	get_ext_error_number
 20340                                  				;AN022; get the extended error
 20341 00002513 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20342                                  				;AN022; see if path not found
 20343 00002516 740A                    	je	short BadChDir	;AN022; yes - issue old message
 20344                                  ;SR;
 20345                                  ; We want to issue "Invalid Directory" message even if the path is valid
 20346                                  ;but is not a directory. The extended error returns "Access denied" which
 20347                                  ;is kind of confusing. Issue the old message if access denied error is 
 20348                                  ;returned
 20349                                  
 20350 00002518 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20351 0000251B 7405                    	je	short BadChDir
 20352                                  	
 20353 0000251D E89E00                  	call	set_ext_error_subst ;AN022;
 20354 00002520 EB20                    	jmp	short ChDirErr	;AN022;
 20355                                  
 20356                                  BadChDir:
 20357 00002522 BA[B080]                	mov	dx,badcd_ptr
 20358                                  ;ChDirErr:
 20359                                  ;	call	std_eprintf
 20360                                  ;mkdir_retn:
 20361                                  	;retn
 20362                                  	; 24/02/2023
 20363 00002525 EB1B                    	jmp	short ChDirErr	;AN022;
 20364                                  
 20365                                  	; 24/02/2023
 20366                                  	; MSDOS 3.3
 20367                                  ;REALCD:
 20368                                  	;call	SETPATH
 20369                                  	;test	byte [DESTINFO],2
 20370                                  	;jnz	short BADCHDIR
 20371                                  	;mov	ah,CHDir ; 3Bh
 20372                                  	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20373                                  	;		; DS:DX	-> ASCIZ directory name	(may include drive)
 20374                                  	;jnc	short CHDIR_RETN
 20375                                  ;BADCHDIR:
 20376                                  	;mov	dx,BADCDPTR
 20377                                  ;CHDIR_ERR:
 20378                                  	;call	STD_EPRINTF
 20379                                  ;MKDIR_RETN:
 20380                                  	;retn
 20381                                  
 20382                                  ; =============== S U B	R O U T	I N E =======================================
 20383                                  
 20384                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20385                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
 20386                                  _$MKDIR:
 20387                                  	; MSDOS 6.0
 20388 00002527 E86300                  	call	SETRMMK
 20389 0000252A 7216                    	jc	short MkDirErr
 20390                                  
 20391 0000252C B439                    	mov	ah,39h
 20392                                  	;mov	ah,MKDIR
 20393 0000252E CD21                    	int	21h
 20394 00002530 7313                    	jnc	short mkdir_retn
 20395                                  
 20396 00002532 E8E8F7                  	call	get_ext_error_number	
 20397                                  				;AN022; get the extended error
 20398 00002535 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20399                                  				;AN022; see if path not found
 20400 00002538 742A                    	je	short MD_other_err
 20401                                  				;AN022; yes - issue old message
 20402 0000253A 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20403                                  				;AN022; access denied?
 20404 0000253D 7407                    	je	short badmderr	;AN022; yes - see if file exists
 20405                                  	
 20406 0000253F E87C00                  	call	set_ext_error_subst
 20407                                  				;AN022;
 20408                                  	;jmp	short MkDirerr	;AC022; yes - go print it
 20409                                  	; 24/02/2023
 20410                                  ChDirErr:
 20411                                  MkDirErr:
 20412                                  RmDirErr:
 20413 00002542 E8F628                  	call	std_eprintf
 20414                                  mkdir_retn:
 20415                                  rmdir_retn:
 20416 00002545 C3                      	retn
 20417                                  	
 20418                                  badmderr:
 20419 00002546 BA[0E88]                	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
 20420 00002549 B41A                    	mov	ah,1Ah
 20421                                  	;mov	ah,Set_DMA	;AN006;
 20422 0000254B CD21                    	int	21h		;AN006;
 20423                                  	
 20424 0000254D B44E                    	mov	ah,4Eh
 20425                                  	;mov	ah,Find_First	;AN006; see if file/dir exists
 20426                                  	;mov	cx,10h
 20427 0000254F B91000                  	mov	cx,ATTR_DIRECTORY
 20428                                  				;AN006;   search for directory
 20429 00002552 CD21                    	int	21h		;AN006;
 20430 00002554 720E                    	jc	short MD_other_err
 20431                                  				;AN006; doesn't exist - must be something else
 20432                                  	;;mov	dl,SRCXNAME.find_buf_attr
 20433                                  				;AN006; we found a file/dir
 20434                                  	;mov	dl,[SRCXNAME+21] 
 20435 00002556 8A16[2388]              	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
 20436 0000255A F6C210                  	test	dl,ATTR_DIRECTORY
 20437                                  				;AN006; was it a directory?
 20438 0000255D 7405                    	jz	short MD_other_err
 20439                                  				;AN006; no - must have been a file
 20440 0000255F BA[A081]                	mov	dx,MD_EXISTS_PTR
 20441                                  				;AN006; set up already exists error
 20442 00002562 EBDE                    	jmp	short MkDirErr	;AN006; make sure we didn't have network error
 20443                                  MD_other_err:			;AN006;
 20444 00002564 BA[B380]                	mov	dx,badmkd_ptr
 20445                                  ;MkDirErr:
 20446                                  	;call	std_eprintf
 20447                                  	;retn
 20448                                  	; 24/02/2023
 20449 00002567 EBD9                    	jmp	short MkDirErr
 20450                                  
 20451                                  	; 24/02/2023
 20452                                  	; MSDOS 3.3
 20453                                  	;call	SETRMMK
 20454                                  	;jb	short MKDIRERR
 20455                                  	;mov	ah,MKDIR ; 39h
 20456                                  	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
 20457                                  	;		; DS:DX	-> ASCIZ pathname (may include drive)
 20458                                  	;jnc	short MKDIR_RETN
 20459                                  	;mov	dx,BADMKDPTR
 20460                                  	;call	GET_EXT_ERR_NUMBER
 20461                                  ;MKDIRERR:
 20462                                  	;call	STD_EPRINTF
 20463                                  	;retn
 20464                                  
 20465                                  ; =============== S U B	R O U T	I N E =======================================
 20466                                  
 20467                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20468                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
 20469                                  _$RMDIR:
 20470 00002569 E82100                  	call	SETRMMK
 20471 0000256C 72D4                    	jb	short RmDirErr
 20472 0000256E 7518                    	jnz	short badrderr
 20473                                  
 20474 00002570 B43A                    	mov	ah,3Ah
 20475                                  	;mov	ah,RMDIR ; 3Ah
 20476 00002572 CD21                    	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
 20477                                  			; DS:DX	-> ASCIZ pathname (may include drive)
 20478 00002574 73CF                    	jnc	short rmdir_retn ; 24/02/2023
 20479                                  
 20480                                  	; 24/02/2023
 20481                                  	; MSDOS 6.0
 20482 00002576 E8A4F7                  	call	get_ext_error_number
 20483                                  				;AN022; get the extended error
 20484 00002579 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20485                                  				;AN022; see if path not found
 20486 0000257C 740A                    	je	short badrderr	;AN022; yes - issue old message
 20487 0000257E 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20488                                  				;AN022; access denied?
 20489 00002581 7405                    	je	short badrderr	;AN022; yes - issue old message
 20490                                  
 20491 00002583 E83800                  	call	set_ext_error_subst
 20492                                  				;AN022;
 20493 00002586 EBBA                    	jmp	short RmDirErr	;AC022; yes - go print it
 20494                                  
 20495                                  	; MSDOS 6.0
 20496                                  badrderr:
 20497                                  	; 24/02/2023
 20498 00002588 BA[B680]                	mov	dx,badrmd_ptr
 20499 0000258B EBB5                    	jmp	short RmDirErr
 20500                                  ;RmDirErr:
 20501                                  	;call	std_eprintf
 20502                                  ;;rmdir_retn
 20503                                  	;retn
 20504                                  
 20505                                  	; 24/02/2023
 20506                                  	; MSDOS 3.3
 20507                                  	;mov	dx,BADRMDPTR
 20508                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 20509                                  ;RMDIRERR:
 20510                                  	;call	STD_EPRINTF
 20511                                  ;RMDIR_RETN:
 20512                                  	;retn
 20513                                  
 20514                                  ; =============== S U B	R O U T	I N E =======================================
 20515                                  
 20516                                  ; 	<Common MkDir/RmDir set up code>
 20517                                  ;****************************************************************
 20518                                  ;*
 20519                                  ;* ROUTINE:	SETRMMK
 20520                                  ;*
 20521                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
 20522                                  ;*		commands. Parses the command line for a required
 20523                                  ;*		filespec.
 20524                                  ;*
 20525                                  ;* INPUT:	command line at offset 81H
 20526                                  ;*
 20527                                  ;* OUTPUT:	carry clear
 20528                                  ;*		    DS:DX points to ASCIIZ argument
 20529                                  ;*		carry set
 20530                                  ;*		    DS:DX has error message pointer
 20531                                  ;*
 20532                                  ;****************************************************************
 20533                                  
 20534                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20535                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
 20536                                  SETRMMK:
 20537                                  	; MSDOS 6.0
 20538 0000258D BE8100                  	mov	si,81h
 20539 00002590 BF[6185]                	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
 20540 00002593 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20541 00002595 31D2                    	xor	dx,dx		;AN000;
 20542                                  	;invoke	Parse_With_Msg	;AC000; call parser
 20543 00002597 E844FC                  	call	Parse_With_Msg
 20544                                  	;cmp	ax,0
 20545                                  	;cmp	ax,RESULT_NO_ERROR
 20546 0000259A 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 20547 0000259C 7519                    	jnz	short noargerr	;AC000; yes - exit
 20548                                  
 20549 0000259E BF[0E88]                	mov	di,SRCXNAME
 20550                                  				;AN000; get address of srcxname
 20551 000025A1 57                      	push	di		;AN000; save address
 20552 000025A2 56                      	push	si		;AN000; save position in line
 20553 000025A3 C536[1396]              	lds	si,[PARSE1_ADDR]
 20554                                  				;AN000; get address of path
 20555                                  mrdir_move_filename:		;AN000; put filespec in srcxname
 20556 000025A7 AC                      	lodsb			;get a char from buffer
 20557 000025A8 AA                      	stosb			;AN000; store in srcxname
 20558                                  	;cmp	al,0
 20559                                  	;cmp	al,END_OF_LINE_OUT
 20560 000025A9 20C0                    	and	al,al ; 0 ?	;AC000; it char a terminator?
 20561 000025AB 75FA                    	jnz	short mrdir_move_filename
 20562                                  				;AC000; no - keep moving
 20563 000025AD 5E                      	pop	si		;AN000; get line position back
 20564                                  
 20565                                  ; we have scanned an argument.	See if any args beyond.
 20566                                  
 20567 000025AE BF[6185]                	mov	di,PARSE_MRDIR
 20568 000025B1 E814FC                  	call	parse_check_eol ;AC000; are we at end of line?
 20569 000025B4 5A                      	pop	dx		;AC000; get address of SRCXNAME
 20570                                  	;retz			;yes - return no error
 20571 000025B5 7406                    	jz	short setrmmk_retn
 20572                                  noargerr:
 20573 000025B7 BA[757F]                	mov	dx,extend_buf_ptr
 20574                                  				;AC000; get extended message pointer
 20575 000025BA 31C0                    	xor	ax,ax
 20576 000025BC F9                      	stc
 20577                                  setrmmk_retn:
 20578 000025BD C3                      	retn
 20579                                  
 20580                                  	; 24/02/2023
 20581                                  	; MSDOS 3.3
 20582                                  ;SETRMMK:
 20583                                  	;mov	si,81h
 20584                                  	;call	SCANOFF
 20585                                  	;cmp	al,0Dh
 20586                                  	;je	short NOARGERR
 20587                                  	;mov	dx,si
 20588                                  ;SETRMMK1:
 20589                                  	;lodsb
 20590                                  	;call	DELIM
 20591                                  	;jz	short SETRMMK3
 20592                                  	;cmp	al,0Dh
 20593                                  	;jne	short SETRMMK1
 20594                                  	;mov	byte [si-1],0
 20595                                  ;SETRMMK2:
 20596                                  	;retn
 20597                                  ;SETRMMK3:
 20598                                  	;mov	byte [si-1],0
 20599                                  	;push	si
 20600                                  	;call	SCANOFF
 20601                                  	;pop	si
 20602                                  	;cmp	al,0Dh
 20603                                  	;je	short SETRMMK2
 20604                                  ;NOARGERR:
 20605                                  	;mov	dx,BADARGSPTR
 20606                                  	;xor	ax,ax
 20607                                  	;stc
 20608                                  ;SETRMMK_RETN:
 20609                                  	;retn
 20610                                  
 20611                                  ; =============== S U B	R O U T	I N E =======================================
 20612                                  
 20613                                  ; MSDOS 6.0
 20614                                  
 20615                                  ;****************************************************************
 20616                                  ;*
 20617                                  ;* ROUTINE:	Set_ext_error_subst
 20618                                  ;*
 20619                                  ;* FUNCTION:	Sets up substitution for extended error
 20620                                  ;*
 20621                                  ;* INPUT:	AX - extended error number
 20622                                  ;*		DX - offset of string
 20623                                  ;*
 20624                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
 20625                                  ;*
 20626                                  ;****************************************************************
 20627                                  
 20628                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20629                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
 20630                                  set_ext_error_subst:
 20631                                  	;mov	byte [msg_disp_class],1
 20632 000025BE C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class
 20633                                  					;AN022; set up extended error msg class
 20634 000025C3 8916[D08C]              	mov	[string_ptr_2],dx 	;AN022; get address of failed string
 20635                                  	;mov	byte [extend_buf_sub],1
 20636 000025C7 C606[777F]01            	mov	byte [extend_buf_sub],one_subst 
 20637                                  	;AN022; put number of subst in control block
 20638 000025CC BA[757F]                	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
 20639 000025CF A3[757F]                	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
 20640                                  savudir_err_retn: ; 24/02/2023
 20641 000025D2 C3                      	retn				;AN022; return
 20642                                  
 20643                                  ; =============== S U B	R O U T	I N E =======================================
 20644                                  
 20645                                  ; <SavUDir - preserve the users current directory on a particular drive>
 20646                                  
 20647                                  ; SavUDir - move the user's current directory on a drive into UserDir1
 20648                                  ; SavUDir1 - move the user's current directory on a drive into a specified
 20649                                  ;   buffer
 20650                                  ;
 20651                                  ;   Inputs:	DL has 1-based drive number
 20652                                  ;		ES:DI has destination buffer (SavUDir1 only)
 20653                                  ;   Outputs:	Carry Clear
 20654                                  ;		    DS = TranGroup
 20655                                  ;		Carry Set
 20656                                  ;		    AX has error code
 20657                                  ;   Registers Modified: AX, SI
 20658                                  
 20659                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20660                                  SAVUDIR:
 20661 000025D3 BF[C289]                	mov	di,USERDIR1
 20662                                  ; --------------
 20663                                  SAVUDIR1:
 20664 000025D6 88D0                    	mov	al,dl
 20665 000025D8 0440                    	add	al,'@' ; 40h
 20666 000025DA 3C40                    	cmp	al,'@' ; 40h
 20667 000025DC 7506                    	jne	short GOTUDRV
 20668 000025DE 0206[F48A]              	add	al,[CURDRV]
 20669 000025E2 FEC0                    	inc	al		; A = 1
 20670                                  GOTUDRV:
 20671 000025E4 AA                      	stosb
 20672 000025E5 8A26[E58A]              	mov	ah,[DIRCHAR]
 20673 000025E9 B03A                    	mov	al,':' ; 3Ah
 20674 000025EB AB                      	stosw
 20675 000025EC 06                      	push	es
 20676 000025ED 1F                      	pop	ds
 20677 000025EE 89FE                    	mov	si,di
 20678 000025F0 B447                    	mov	ah,47h ; 24/02/2023
 20679                                  	;mov	ah,CURRENT_DIR	; 47h
 20680 000025F2 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 20681                                  			; DL = drive (0=default,1=A,etc.)
 20682                                  			; DS:SI	points to 64-byte buffer area
 20683 000025F4 72DC                    	jc	short savudir_err_retn ; 24/02/2023
 20684 000025F6 0E                      	push	cs
 20685 000025F7 1F                      	pop	ds
 20686 000025F8 C3                      	retn
 20687                                  
 20688                                  ; =============== S U B	R O U T	I N E =======================================
 20689                                  
 20690                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20691                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
 20692                                  CRLF2:
 20693 000025F9 52                      	push	dx
 20694 000025FA BA[5481]                	mov	dx,acrlf_ptr
 20695 000025FD 1E                      	push	ds
 20696 000025FE 0E                      	push	cs
 20697 000025FF 1F                      	pop	ds
 20698 00002600 E84028                  	call	std_printf
 20699 00002603 1F                      	pop	ds
 20700 00002604 5A                      	pop	dx
 20701 00002605 C3                      	retn
 20702                                  
 20703                                  ; =============== S U B	R O U T	I N E =======================================
 20704                                  
 20705                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
 20706                                  ; may NOT be TRANGROUP
 20707                                  
 20708                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20709                                  scanoff:
 20710 00002606 AC                      	lodsb
 20711 00002607 E80400                  	call	DELIM
 20712 0000260A 74FA                    	jz	short scanoff
 20713 0000260C 4E                      	dec	si		; Point to first non-delimiter
 20714                                  scanoff_retn:
 20715 0000260D C3                      	retn
 20716                                  
 20717                                  ; =============== S U B	R O U T	I N E =======================================
 20718                                  
 20719                                  ; Input:    AL is character to classify
 20720                                  ; Output:   Z set if delimiter
 20721                                  ;	    NZ set otherwise
 20722                                  ; Registers modified: none
 20723                                  
 20724                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20725                                  DELIM:
 20726 0000260E 3C20                    	cmp	al,' '	 ;20h
 20727 00002610 74FB                    	je	short scanoff_retn
 20728 00002612 3C3D                    	cmp	al,'='  ; 3Dh
 20729 00002614 74F7                    	je	short scanoff_retn
 20730 00002616 3C2C                    	cmp	al,','	; 2Ch
 20731 00002618 74F3                    	je	short scanoff_retn
 20732 0000261A 3C3B                    	cmp	al,';'	 ;3Bh
 20733 0000261C 74EF                    	je	short scanoff_retn
 20734 0000261E 3C09                    	cmp	al,9		; Check for TAB character
 20735 00002620 74EB                    	je	short scanoff_retn
 20736 00002622 3C0A                    	cmp	al,0Ah		; Check for line feed character - BAS
 20737 00002624 C3                      	retn
 20738                                  
 20739                                  
 20740                                  ; =============== S U B	R O U T	I N E =======================================
 20741                                  
 20742                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20743                                  FCB_TO_ASCZ:			
 20744                                  	; Convert DS:SI to ASCIZ ES:DI
 20745 00002625 B90800                  	mov	cx,8
 20746                                  MAINNAME:
 20747 00002628 AC                      	lodsb
 20748 00002629 3C20                    	cmp	al,' ' ; 20h
 20749 0000262B 7401                    	jz	short SKIPSPC
 20750 0000262D AA                      	stosb
 20751                                  SKIPSPC:
 20752 0000262E E2F8                    	loop	MAINNAME
 20753 00002630 AC                      	lodsb
 20754 00002631 3C20                    	cmp	al,' '
 20755 00002633 740F                    	je	short GOTNAME
 20756 00002635 88C4                    	mov	ah,al
 20757                                  	; 24/02/2023
 20758 00002637 B02E                    	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
 20759                                  	;mov	al,[DOT_CHR]  ; MSDOS 3.3
 20760                                  	;stosb
 20761                                  	;xchg	al,ah
 20762                                  	;stosb
 20763                                  	; 24/02/2023
 20764 00002639 AB                      	stosw
 20765 0000263A B102                    	mov	cl,2
 20766                                  EXTNAME:
 20767 0000263C AC                      	lodsb
 20768 0000263D 3C20                    	cmp	al,' '
 20769 0000263F 7403                    	je	short GOTNAME
 20770 00002641 AA                      	stosb
 20771 00002642 E2F8                    	loop	EXTNAME
 20772                                  GOTNAME:
 20773 00002644 30C0                    	xor	al,al
 20774 00002646 AA                      	stosb
 20775                                  STRCOMP_RETN:
 20776 00002647 C3                      	retn
 20777                                  
 20778                                  ; =============== S U B	R O U T	I N E =======================================
 20779                                  
 20780                                  ; Compare ASCIZ DS:SI with ES:DI.
 20781                                  ; SI,DI destroyed.
 20782                                  
 20783                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20784                                  STRCOMP:	
 20785 00002648 A6                      	cmpsb
 20786 00002649 75FC                    	jnz	short STRCOMP_RETN ; Strings not equal
 20787 0000264B 807CFF00                	cmp	byte [si-1],0	; Hit NUL terminator?	
 20788                                  	;jz	short STRCOMP_RETN ; Yes, strings equal
 20789                                  	;jmp	short STRCOMP	; Equal so far, keep going
 20790                                  	; 24/02/2023
 20791 0000264F 75F7                    	jnz	short STRCOMP
 20792 00002651 C3                      	retn
 20793                                  
 20794                                  ; =============== S U B	R O U T	I N E =======================================
 20795                                  
 20796                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20797                                  CRPRINT:
 20798 00002652 50                      	push	ax
 20799                                  	;mov	al,13	; 0Dh
 20800 00002653 B00D                    	mov	al,0Dh
 20801 00002655 51                      	push	cx
 20802 00002656 57                      	push	di
 20803 00002657 89D7                    	mov	di,dx
 20804 00002659 B9FFFF                  	mov	cx,65535 ; 0FFFFh
 20805 0000265C 06                      	push	es
 20806 0000265D 1E                      	push	ds
 20807 0000265E 07                      	pop	es
 20808 0000265F F2AE                    	repne	scasb		; LOOK FOR TERMINATOR
 20809 00002661 C645FF00                	mov	byte [di-1],0	; nul terminate the string
 20810 00002665 07                      	pop	es
 20811 00002666 8916[D08C]              	mov	[string_ptr_2],dx
 20812                                  	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
 20813 0000266A BA[3C81]                	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
 20814 0000266D E8D327                  	call	std_printf
 20815                                  	;mov	byte [di-1],13
 20816 00002670 C645FF0D                	mov	byte [di-1],0Dh	; now put the CR back
 20817 00002674 7204                    	jb	short error_output
 20818 00002676 5F                      	pop	di
 20819 00002677 59                      	pop	cx
 20820 00002678 58                      	pop	ax
 20821 00002679 C3                      	retn
 20822                                  
 20823                                  ; ---------------------------------------------------------------------------
 20824                                  
 20825                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20826                                  error_output:
 20827 0000267A 0E                      	push	cs
 20828 0000267B 1F                      	pop	ds
 20829 0000267C 8E06[E08A]              	mov	es,[RESSEG]
 20830 00002680 BA[897F]                	mov	dx,NOSPACE_PTR
 20831 00002683 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 20832 00002689 7406                    	jz	short go_to_error
 20833 0000268B E81709                  	call	PipeOff
 20834 0000268E BA[D680]                	mov	dx,PIPEEMES_PTR
 20835                                  go_to_error:
 20836 00002691 E9E602                  	jmp	cerror
 20837                                  
 20838                                  ; =============== S U B	R O U T	I N E =======================================
 20839                                  
 20840                                  ;---- Mod for path invocation ----
 20841                                  
 20842                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20843                                  pathchrcmp:
 20844                                  	; 18/03/2023	
 20845                                  	;push	ax
 20846                                  	;mov	ah,'/' ; 2Fh
 20847                                  	;cmp	[SWITCHAR],ah
 20848 00002694 803E[E48A]2F            	cmp	byte [SWITCHAR],'/' ; 2Fh
 20849 00002699 7404                    	je	short noslasht
 20850 0000269B 3C2F                    	cmp	al,'/'
 20851 0000269D 7402                    	je	short pccont
 20852                                  noslasht:
 20853 0000269F 3C5C                    	cmp	al,'\' ; 5Ch
 20854                                  pccont:	
 20855                                  	;pop	ax
 20856 000026A1 C3                      	retn
 20857                                  
 20858                                  ; =============== S U B	R O U T	I N E =======================================
 20859                                  
 20860                                  ; PATHCRUNCH -
 20861                                  ;
 20862                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
 20863                                  ;       PathPos = ptr to string with pathname in it
 20864                                  ;       PathCnt = length of string
 20865                                  ;
 20866                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
 20867                                  ;       PathCnt = length left in string
 20868                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
 20869                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
 20870                                  ;       If path crunched successfully,
 20871                                  ;         CY = clear
 20872                                  ;         Current directory is changed to directory in pathname
 20873                                  ;         UserDir1 contains previous directory for use by RestUDir
 20874                                  ;         RestDir = nonzero to flag later restoration of user's dir
 20875                                  ;         DestTail = ptr to beginning of filename
 20876                                  ;         If filename found in pathname,
 20877                                  ;           ZR = clear
 20878                                  ;           FCB filename fields contain filename
 20879                                  ;         If filename not found (pure directory path),
 20880                                  ;           ZR = set
 20881                                  ;           FCB filename fields are wildcarded with ?'s
 20882                                  ;       If pathcrunch failed (no ChDir's worked),
 20883                                  ;         CY = set
 20884                                  ;         Msg_Numb = extended error code
 20885                                  ;
 20886                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
 20887                                  ;       FCB by setting DirFlag. In this case, the FCB is returned
 20888                                  ;       with the filename wildcarded.
 20889                                  
 20890                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 20891                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h
 20892                                  
 20893                                  PathCrunch:
 20894                                  	; MSDOS 6.0
 20895 000026A2 C706[538E]0000          	mov     word [Msg_Numb],0
 20896                                  				;AN022; Set up message flag
 20897                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20898                                  	;mov	dl,[5Ch]
 20899 000026A8 8A165C00                	mov	dl,[FCB]	; DL = drive # (1 = A)
 20900 000026AC E824FF                  	call	SAVUDIR		; save current directory in UserDir1
 20901                                  	; MSDOS 6.0
 20902 000026AF 7233                     	jc	short pcrunch_cderrj
 20903                                  				;AN022; if error on current dir - report
 20904 000026B1 E86004                  	call	SETPATH		; scan past switches, whitespace
 20905                                  
 20906                                  ;       DX = ptr to pathname, NULL-terminated
 20907                                  ;       PathPos = ptr to byte after NULL at end of pathname
 20908                                  
 20909                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20910 000026B4 F606[EB8C]02            	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
 20911 000026B9 752C                    	jnz	short trypeel	; wildcard seen, peel filename
 20912                                  
 20913                                  	;mov	ah,CHDir ; 3Bh
 20914 000026BB B43B                    	mov	ah,3Bh
 20915 000026BD CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20916                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 20917                                  	; MSDOS 6.0
 20918 000026BF 7313                    	jnc	short chdir_worked	;AN022; no error - continue
 20919                                  	
 20920 000026C1 E859F6                  	call	get_ext_error_number    ;AN022; get the extended error
 20921 000026C4 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
 20922 000026C7 741E                    	je	short trypeel		;AC022;    keep trying
 20923 000026C9 83F805                  	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
 20924 000026CC 7419                    	je	short trypeel		;AC022;    keep trying
 20925 000026CE A3[538E]                	mov	[Msg_Numb],ax           ;AN022; set up message flag
 20926 000026D1 E99C00                  	jmp	peelfail                ;AN022; exit with other error
 20927                                  
 20928                                  	; MSDOS 3.3
 20929                                  	;jc	short trypeel
 20930                                  chdir_worked:
 20931                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20932 000026D4 E83B06                  	call	SetRest1	; set 'Restore Directory' flag true
 20933 000026D7 B03F                    	mov	al,'?'		; if pure dir, wildcard filename in FCB
 20934 000026D9 BF5D00                  	mov	di,5Dh  ; FCB+1
 20935 000026DC B90B00                  	mov	cx,11
 20936 000026DF F3AA                    	rep	stosb
 20937 000026E1 30C0                    	xor	al,al		; return carry clear, zero set
 20938 000026E3 C3                      	retn
 20939                                  
 20940                                  pcrunch_cderrj: 		;AN022; need this for long jmp
 20941 000026E4 E98100                  	jmp	pcrunch_cderr	;AN022;
 20942                                  
 20943                                  trypeel:
 20944 000026E7 8B36[3F8C]              	mov	si,[PathPos]
 20945 000026EB 4E                      	dec	si		; SI = ptr to NULL at end of pathname
 20946 000026EC 8A44FF                  	mov	al,[si-1]	; AL = last char of pathname
 20947                                  	; 25/02/2023
 20948                                  	; MSDOS 5.0 (& 6.0)
 20949 000026EF 803E[6E8E]00            	cmp	byte [KPARSE],0
 20950 000026F4 7505                    	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
 20951                                  	
 20952 000026F6 E89BFF                  	call	pathchrcmp
 20953 000026F9 7475                    	jz	short peelfail	; Trailing '/'
 20954                                  delstrt:
 20955 000026FB 89F1                    	mov	cx,si		; CX = ptr to NULL at end of pathname
 20956 000026FD 89D6                    	mov	si,dx		; SI = ptr to start of pathname
 20957 000026FF 52                      	push	dx		; save ptr to pathname
 20958                                  delloop:
 20959 00002700 39CE                    	cmp	si,cx
 20960                                  	;jz	short BADRET
 20961                                  	; 25/02/2023
 20962 00002702 7413                    	je	short gotdele	; no char's left, we have what we have
 20963 00002704 AC                      	lodsb			; AL = next char of pathname
 20964 00002705 E8DCFC                  	call	testkanj
 20965 00002708 7403                    	jz	short notkanj8	; not Kanji, move along
 20966 0000270A 46                      	inc	si
 20967 0000270B EBF3                    	jmp	short delloop	
 20968                                  
 20969                                  	; 25/02/2023
 20970                                  	; MSDOS 3.3
 20971                                  	;mov	al,[si]
 20972                                  	;call	PATHCHRCMP
 20973                                  	;jz	short TRYCD
 20974                                  	;dec	si
 20975                                  	;jmp	short delloop
 20976                                  
 20977                                  notkanj8:
 20978 0000270D E884FF                  	call	pathchrcmp
 20979 00002710 75EE                    	jnz	short delloop	; not a path delimiter, keep looking
 20980 00002712 89F2                    	mov	dx,si
 20981 00002714 4A                      	dec	dx		; DX = ptr to last delimiter found	
 20982 00002715 EBE9                    	jmp	short delloop	; go look for more
 20983                                  
 20984                                  	; 25/02/2023
 20985                                  	; MSDOS 5.0 (& 6.0)
 20986                                  gotdele:
 20987 00002717 89D6                    	mov	si,dx		; SI = ptr to pathname or last delim
 20988 00002719 5A                      	pop	dx		; DX = ptr to pathname
 20989 0000271A 39D6                    	cmp	si,dx
 20990 0000271C 7454                    	je	short badret	; didn't find path delim
 20991 0000271E 89F1                    	mov	cx,si		; CX = ptr to last path delimiter
 20992 00002720 89D6                    	mov	si,dx		; SI = ptr to pathname
 20993                                  delloop2:			; Set value of KPARSE
 20994 00002722 39CE                    	cmp	si,cx
 20995 00002724 7412                    	je	short trycd	; roll up till SI meets CX
 20996 00002726 C606[6E8E]00            	mov	byte [KPARSE],0
 20997 0000272B AC                      	lodsb
 20998 0000272C E8B5FC                  	call	testkanj
 20999 0000272F 74F1                    	jz	short delloop2
 21000 00002731 46                      	inc	si
 21001 00002732 FE06[6E8E]              	inc	byte [KPARSE]
 21002 00002736 EBEA                    	jmp	short delloop2
 21003                                  
 21004                                  trycd:
 21005 00002738 50                      	push	ax
 21006                                  	; 25/02/2023
 21007 00002739 B02E                    	mov	al,'.'
 21008                                  	;mov	al,[DOT_CHR]	; AL = '.'
 21009                                  	; MSDOS 6.0
 21010 0000273B 384401                  	cmp	[si+1],al	; check for '.' after path delim
 21011                                  				;M019; allow continuation if '. ' or 
 21012                                  				;M019; '..' is not found.
 21013 0000273E 7509                    	jne	short trycd1	;M019; '.' not found
 21014 00002740 384402                  	cmp	[si+2],al	;M019; check for '..'
 21015 00002743 7404                    	je	short trycd1	;M019; found '..'
 21016 00002745 807C0200                	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
 21017                                  trycd1:	
 21018 00002749 58                      	pop     ax
 21019 0000274A 7424                    	jz	short peelfail	; if . or .., pure cd should have worked
 21020                                  
 21021                                  	; 25/02/2023
 21022                                  	; MSDOS 3.3
 21023                                  	;cmp	[si+1],	al	; check for '.' after path delim
 21024                                  	;pop	ax
 21025                                  	;jz	short PEELFAIL	; if . or .., pure cd should have worked
 21026                                  
 21027                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21028 0000274C 8A44FF                  	mov	al,[si-1]
 21029 0000274F 3C3A                    	cmp	al,':' 		; Special case d:\file
 21030 00002751 741F                    	je	short badret
 21031                                  	; 25/02/2023
 21032                                  	; MSDOS 6.0
 21033 00002753 803E[6E8E]00            	cmp	byte [KPARSE],0
 21034 00002758 7505                    	jnz	short notdoublesl
 21035 0000275A E837FF                  	call	pathchrcmp
 21036                                  	;jnz	short notdoublesl
 21037                                  				; Last char is 2nd KANJI byte, might be '\'
 21038                                  	; 25/02/2023
 21039 0000275D 7411                    	jz	short peelfail 
 21040                                  ;peelfail:
 21041                                  	;stc
 21042                                  	;retn
 21043                                  
 21044                                  notdoublesl:
 21045 0000275F C60400                  	mov	byte [si],0
 21046                                  	;mov	ah,CHDir ; 3Bh
 21047 00002762 B43B                    	mov	ah,3Bh
 21048 00002764 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21049                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21050 00002766 7320                    	jnc	short cdsucc
 21051                                  
 21052                                  	; 25/02/2023
 21053                                  	; MSDOS 6.0
 21054                                  pcrunch_cderr:
 21055 00002768 E8B2F5                  	call	get_ext_error_number
 21056                                  				;AN022; get the extended error
 21057 0000276B A3[538E]                	mov	[Msg_Numb],ax	;AN022; set up message flag
 21058 0000276E 09F6                    	or	si,si		;AN022; set up zero flag to not zero
 21059                                  peelfail: ; 25/02/2023
 21060 00002770 F9                      	stc			;AN022; set up carry flag
 21061                                  pcrunch_retn:
 21062 00002771 C3                      	retn
 21063                                  
 21064                                  badret:
 21065                                  	; MSDOS 3.3 & MSDOS 6.0
 21066 00002772 8A04                    	mov	al,[si]
 21067 00002774 E81DFF                  	call	pathchrcmp	; Special case 'DIRCHAR'file
 21068 00002777 F9                      	stc
 21069 00002778 75F7                    	jnz	short pcrunch_retn
 21070 0000277A 30DB                    	xor	bl,bl
 21071 0000277C 865C01                  	xchg	bl,[si+1]
 21072                                  	;mov	ah,CHDir ; 3Bh
 21073 0000277F B43B                    	mov	ah,3Bh
 21074 00002781 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21075                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21076                                  	;jc	short pcrunch_retn ; MSDOS 3.3
 21077                                  	; 25/02/2023
 21078 00002783 72E3                    	jc	short pcrunch_cderr
 21079                                  				;AN022; go to error exit 
 21080 00002785 885C01                  	mov	[si+1],bl
 21081                                  cdsucc:
 21082 00002788 E88705                  	call	SetRest1
 21083 0000278B 46                      	inc	si		; Reset zero
 21084 0000278C 8936[E98C]              	mov	[DestTail],si
 21085                                  	; 25/02/2023
 21086                                  	; MSDOS 6.0
 21087 00002790 9C                      	pushf			;AN015; save flags
 21088 00002791 803E[478C]FF            	cmp	byte [DirFlag],-1
 21089                                  				;AN015; don't do parse if in DIR
 21090 00002796 7408                    	je	short pcrunch_end
 21091                                  				;AN015;
 21092                                  	; MSDOS 3.3 & MSDOS 6.0
 21093 00002798 BF5C00                  	mov	di,FCB  ; 5Ch
 21094                                  	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
 21095 0000279B B80229                  	mov	ax,2902h	
 21096 0000279E CD21                    	int	21h		; Parse with default drive
 21097                                  			; DOS -	PARSE FILENAME
 21098                                  			; DS:SI	-> string to parse
 21099                                  			; ES:DI	-> buffer to fill with unopened	FCB
 21100                                  			; AL = bit mask	to control parsing
 21101                                  	; MSDOS 3.3
 21102                                  	;retn
 21103                                  
 21104                                  pcrunch_end:
 21105 000027A0 9D                      	popf			;AN015; get flags back
 21106 000027A1 C3                      	retn
 21107                                  
 21108                                  ;============================================================================
 21109                                  ; TMISC1.ASM, MSDOS 6.0, 1991
 21110                                  ;============================================================================
 21111                                  ; 05/10/2018 - Retro DOS v3.0
 21112                                  
 21113                                  ;TITLE	Part7 COMMAND Transient Routines
 21114                                  
 21115                                  ;	More misc routines
 21116                                  
 21117                                  ;---------------------------
 21118                                  ; We can get rid of this switch processing code if we can take
 21119                                  ; care of the remaining two calls to switch, later in the file.
 21120                                  ; However, I have not checked whether or not any other files use
 21121                                  ; switch -- after all, it IS public!
 21122                                  ;---------------------------
 21123                                  
 21124                                  ; 28/03/2023
 21125                                  SWCOUNT  EQU  6  ; MSDOS 6.0		; Length of switch_list
 21126                                  ;SWCOUNT EQU  5  ; MSDOS 3.3	
 21127                                  
 21128                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
 21129                                  
 21130                                  ; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21131                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h
 21132                                  
 21133                                  ; ---------------------------------------------------------------------------
 21134                                  
 21135                                  	; 25/02/2023
 21136                                  RETSW:
 21137 000027A2 93                      	xchg	ax,bx		; Put switches in AX
 21138 000027A3 C3                      	retn
 21139                                  
 21140                                  ; =============== S U B	R O U T	I N E =======================================
 21141                                  
 21142                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21143                                  SWITCH:
 21144 000027A4 31DB                    	xor	bx,bx		; Initialize - no switches set
 21145                                  SWLOOP:
 21146 000027A6 E85DFE                  	call	scanoff		; Skip any delimiters
 21147 000027A9 3A06[E48A]              	cmp	al,[SWITCHAR]	; Is it a switch specifier?
 21148 000027AD 75F3                    	jnz	short RETSW	; No -- we're finished
 21149 000027AF 81CB0080                	or	bx,8000h
 21150                                  	;or	bx,FSWITCH	; Indicate there is a switch specified
 21151 000027B3 46                      	inc	si		; Skip over the switch character
 21152 000027B4 E84FFE                  	call	scanoff
 21153 000027B7 3C0D                    	cmp	al,0Dh
 21154 000027B9 74E7                    	je	short RETSW	; Oops
 21155 000027BB 46                      	inc	si
 21156                                  
 21157                                  	; Convert lower case input to upper case
 21158                                  
 21159 000027BC E84FFC                  	call	UPCONV
 21160                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 21161                                  
 21162 000027BF BF[AB84]                	mov	di,switch_list	; "?VBAPW" (for MSDOS 6.0)
 21163                                  				; ("VBAPW" (for MSDOS 3.3))
 21164 000027C2 B90600                  	mov	cx,6  ; MSDOS 6.0
 21165                                  	;mov	cx,5  ; MSDOS 3.3
 21166                                  	;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
 21167                                  		
 21168                                  	;nop
 21169                                  		
 21170 000027C5 F2AE                    	repne	scasb		; Look for matching switch
 21171 000027C7 7507                    	jnz	short BADSW
 21172 000027C9 B80100                  	mov	ax,1
 21173 000027CC D3E0                    	shl	ax,cl		; Set a bit for the switch
 21174 000027CE 09C3                    	or	bx,ax
 21175                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
 21176 000027D0 EBD4                    	jmp	short SWLOOP
 21177                                  ;BADSW:
 21178                                  	;jmp	short SWLOOP
 21179                                  ;DRVBAD:
 21180                                  ;	mov	dx,baddrv_ptr
 21181                                  ;	jmp	cerror
 21182                                  EXTERNALJ:
 21183 000027D2 E90501                  	jmp	EXTERNAL
 21184                                  FNDCOM:				; search the internal command table
 21185 000027D5 08C0                    	or	al,al		; Get real length of first arg
 21186 000027D7 74F9                    	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
 21187                                  				;  to be external.
 21188                                  ; barryf code starts here
 21189                                  
 21190 000027D9 E82703                  	call	test_append	; see if APPEND installed
 21191 000027DC 7429                    	jz	short CONTCOM	; not loaded
 21192                                  
 21193                                  APPEND_INTERNAL:
 21194 000027DE 8A0E[6A8B]              	mov	cl,[IDLEN]
 21195 000027E2 B500                    	mov	ch,0
 21196 000027E4 890E[3F8C]              	mov	[PathPos],cx
 21197                                  	
 21198                                  	; 25/02/2023	
 21199                                  	; MSDOS 6.0
 21200 000027E8 FE06[558E]              	inc 	byte [append_exec]
 21201                                  				;AN041; set APPEND to ON
 21202 000027EC E8BD03                  	call	IOSET		; re-direct the o'l io
 21203                                  
 21204 000027EF BE[6A8B]                	mov	si,IDLEN	; address command name, DS already set	
 21205 000027F2 BAFFFF                  	mov	dx,-1 ; 0FFFFh	; set invoke function
 21206                                  		
 21207                                  	; MSDOS 6.0
 21208 000027F5 BF[2D4E]                	mov	di,append_parse
 21209                                  				;AN010; Get the entry point for PARSE for APPEND
 21210                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21211 000027F8 B801AE                  	mov	ax,0AE01h
 21212 000027FB CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal
 21213                                  			; - INSTALLABLE	COMMAND	- EXECUTE
 21214                                  			; DX = FFFFh, DS:SI -> buffer
 21215                                  			; Return: buffer at DS:SI filled with a	length byte
 21216                                  			; followed by the uppercase internal command
 21217                                  			; to execute (if length not 0)
 21218                                  	; 25/02/2023
 21219                                  	; INT 2Fh
 21220                                  	; 	AX = AE01h
 21221                                  	; entry:
 21222                                  	; 	DX = magic value FFFFh
 21223                                  	; 	CH = 00h
 21224                                  	; 	CL = length of command name
 21225                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 21226                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 21227                                  	; return:
 21228                                  	;	DS:SI buffer updated
 21229                                  	;	if length byte is nonzero, the following bytes contain
 21230                                  	;	the uppercase internal command to execute and the command line
 21231                                  	; 	buffer contains the command's parameters
 21232                                  	;	(the first DS:[SI] bytes are ignored)
 21233                                  	;
 21234                                  	; Format of COMMAND.COM command line buffer:
 21235                                  	;	Offset  Size    Description
 21236                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 21237                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 21238                                  	;	N BYTEs command line text, terminated by 0Dh
 21239                                  	;
 21240                                  	; Format of command name buffer:
 21241                                  	;	Offset  Size    Description
 21242                                  	;	00h     BYTE    length of command name
 21243                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 21244                                  
 21245 000027FD 803E[6A8B]00            	cmp	byte [IDLEN],0 ; execute requested
 21246 00002802 7503                    	jne	short CONTCOM
 21247 00002804 E9A300                  	jmp	CMD_DONE
 21248                                  
 21249                                  	;nop
 21250                                  CONTCOM:			; continue with internal scan
 21251 00002807 BF[2A83]                	mov	di,COMTAB
 21252 0000280A 31C9                    	xor	cx,cx
 21253                                  FINDCOM:
 21254 0000280C BE[6B8B]                	mov	si,ID		; pointer to command argument
 21255 0000280F 8A0D                    	mov	cl,[di]		; load length of internal command
 21256 00002811 47                      	inc	di		; advance past length
 21257 00002812 E3BE                    	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
 21258 00002814 3A0E[6A8B]              	cmp	cl,[IDLEN]	; that of the command argument
 21259 00002818 7506                    	jne	short ABCD	; lengths not equal ==> strings not eq
 21260 0000281A 890E[3F8C]              	mov	[PathPos],cx	; store length of command
 21261 0000281E F3A6                    	repe	cmpsb
 21262                                  ABCD:					
 21263 00002820 9F                      	lahf			; save the good ol' flags
 21264 00002821 01CF                    	add	di,cx		; skip over remaining internal, if any
 21265 00002823 8A05                    	mov	al,[di]		; load drive-check indicator byte (DCIB)
 21266 00002825 A2[F28A]                	mov	[CHKDRV],al	; save command flag byte in chkdrv
 21267 00002828 47                      	inc	di		; increment DI (OK, OK, I'll stop)
 21268 00002829 8B1D                    	mov	bx,[di]		; load internal command address
 21269 0000282B 47                      	inc	di		; skip over the puppy
 21270 0000282C 47                      	inc	di
 21271                                  		
 21272                                  	; MSDOS 6.0
 21273 0000282D 8B15                    	mov	dx,[di]		; load ptr to help msg #s
 21274 0000282F 47                      	inc	di
 21275 00002830 47                      	inc	di
 21276 00002831 9E                      	sahf			; remember those flags?
 21277 00002832 75D8                    	jnz	short FINDCOM	; well, if all the cmps worked...
 21278                                  
 21279                                  ; All messages get redirected.
 21280                                  
 21281 00002834 803E[558E]00            	cmp     byte [append_exec],0
 21282                                  				;AN041; APPEND just executed?
 21283 00002839 7503                    	jnz 	short DONT_SET_IO
 21284                                  				;AN041; Yes - this junk is already set
 21285 0000283B E86E03                  	call	IOSET		; re-direct the ol' i/o
 21286                                  
 21287                                  DONT_SET_IO:			;AN041;
 21288                                  
 21289                                  ; Check for /?. Certain commands, flagged fLimitHelp,
 21290                                  ; respond to /? only if it is the only command-line argument.
 21291                                  
 21292 0000283E A1[F78A]                	mov	ax,[COMSW]	; AX = switches after command
 21293 00002841 0B06[FD8A]              	or	ax,[AllSwitch]	; AX = all switches
 21294                                  	;and	ax,SwitchQues	
 21295 00002845 83E020                  	and	ax,20h
 21296 00002848 7426                    	jz	short DRIVE_CHECK
 21297                                  				; /? not in command line
 21298 0000284A F606[F28A]04            	test	byte [CHKDRV],4	
 21299                                  	;test	byte [CHKDRV],fLimitHelp
 21300 0000284F 7407                    	jz	short DO_HELP	; /? allowed in combination
 21301                                  
 21302                                  ; Make sure /? is the only argument on the command line.
 21303                                  
 21304 00002851 833E[2F91]02            	cmp	word [ARG+ARG_UNIT.argvcnt],2
 21305 00002856 7518                    	jne	short DRIVE_CHECK
 21306                                  				; /? not only arg - ignore
 21307                                  
 21308                                  ; Note: this is all the check we need, even against things like /??.
 21309                                  ; Our argv parser breaks /?? into two args, /? and ?.
 21310                                  
 21311                                  DO_HELP:
 21312                                  ; DX = ptr to word list of msg #s, terminated by zero word
 21313                                  
 21314 00002858 89D6                    	mov	si,dx		; SI = ptr to list of msg #s
 21315                                      	;mov	ax,no_subst	; AL = no subst's code
 21316 0000285A B80000                  	mov	ax,0
 21317 0000285D 50                      	push	ax		; build subst block on stack
 21318                                  
 21319                                  NEXT_HELP_MSG:
 21320 0000285E AD                      	lodsw			; AX = help msg # or zero
 21321 0000285F 09C0                    	or	ax,ax
 21322 00002861 7409                    	jz	short HELP_DONE
 21323 00002863 50                      	push	ax		; SS:SP = ptr to subst block
 21324                                  				; (msg # and no_subst byte)
 21325                                  ;; We assume DS = SS.
 21326                                  	
 21327 00002864 89E2                    	mov     dx,sp		; DS:DX = ptr to subst block
 21328 00002866 E8DA25                  	call	std_printf	; display help message	
 21329 00002869 58                      	pop	ax		; remove msg # from stack
 21330 0000286A EBF2                    	jmp	short NEXT_HELP_MSG
 21331                                  
 21332                                  HELP_DONE:
 21333 0000286C 58                      	pop	ax		; clean up stack
 21334 0000286D E994D8                  	jmp	TCOMMAND	
 21335                                  
 21336                                  	; 25/02/2023
 21337                                  	; MSDOS 3.3
 21338                                  	;sahf			; remember those flags?
 21339                                  	;jnz	short FINDCOM	; well, if all the cmps worked...
 21340                                  	;call	IOSET		; re-direct the ol' i/o
 21341                                  
 21342                                  DRIVE_CHECK:
 21343 00002870 F606[F28A]01            	test	byte [CHKDRV],1
 21344                                  	;test	byte [CHKDRV],FCHECKDRIVE 
 21345                                  				; did we wanna check those drives?
 21346 00002875 7411                    	jz	short NOCHECK
 21347 00002877 A0[F58A]                	mov	al,[PARM1]	; parse_file_descriptor results tell
 21348 0000287A 0A06[F68A]              	or	al,[PARM2]	; us whether those drives were OK
 21349 0000287E 3CFF                    	cmp	al,-1
 21350 00002880 7506                    	jne	short NOCHECK
 21351                                  	;jmp	DRVBAD
 21352                                  	; 25/02/2023
 21353                                  DRVBAD:
 21354 00002882 BA[D17F]                	mov	dx,baddrv_ptr
 21355 00002885 E9F200                  	jmp	cerror
 21356                                  
 21357                                  ; The user may have omitted the space between the command and its arguments.
 21358                                  ; We need to copy the remainder of the user's command line into the buffer.
 21359                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
 21360                                  ; into the command line at 80.
 21361                                  
 21362                                  NOCHECK:
 21363 00002888 E85B02                  	call	cmd_copy
 21364                                  SWITCHECK:
 21365                                  	;test	byte [CHKDRV],2
 21366 0000288B F606[F28A]02            	test	byte [CHKDRV],fSwitchAllowed 
 21367                                  				; Does the command take switches
 21368 00002890 7516                    	jnz	short REALWORK	; Yes, process the command
 21369 00002892 E82F00                  	call	noswit		; No, check to see if any switches
 21370 00002895 7511                    	jnz	short REALWORK	; None, process the command
 21371                                  
 21372                                  	; MSDOS 6.0
 21373                                  	;mov	byte [msg_disp_class],2
 21374 00002897 C606[737F]02            	mov	byte [msg_disp_class],parse_msg_class
 21375                                  				;AN000; set up parse error msg class
 21376 0000289C BA[757F]                	mov	dx,extend_buf_ptr	
 21377                                  				;AC000; get extended message pointer
 21378                                  	;mov	word [extend_buf_ptr],3
 21379 0000289F C706[757F]0300          	mov	word [extend_buf_ptr],BadSwt_Ptr
 21380                                  				;AN000; get "Invalid switch" message number
 21381 000028A5 E9D200                  	jmp	cerror		; Print error and chill out...
 21382                                  
 21383                                  	; 25/02/2023
 21384                                  	; MSDOS 3.3
 21385                                  	;mov	dx,BADPARMPTR
 21386                                  	;jmp	CERROR
 21387                                  
 21388                                  REALWORK:
 21389 000028A8 FFD3                    	call	bx		; do some real work, at last
 21390                                  
 21391                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
 21392                                  ; otherwise, go get another command.
 21393                                  
 21394                                  CMD_DONE:
 21395 000028AA 0E                      	push	cs		; g  restore data segment
 21396 000028AB 1F                      	pop	ds		; g
 21397 000028AC 1E                      	push	ds
 21398 000028AD 8E1E[E08A]              	mov	ds,[RESSEG]	; g  save data segment
 21399                                  	;cmp	byte [Call_Flag],1
 21400                                  				; G  Is a call in progress?
 21401 000028B1 803E[B101]01            	cmp	byte [Call_Flag],call_in_progress
 21402 000028B6 C606[B101]00            	mov	byte [Call_Flag],0
 21403                                  				; G  Either way, reset flag
 21404 000028BB 1F                      	pop	ds		; g  get data segment back
 21405 000028BC 7403                    	jz	short INCALL	; G
 21406 000028BE E943D8                  	jmp	TCOMMAND	; chill out...
 21407                                  INCALL:
 21408 000028C1 E913DA                  	jmp	DOCOM1
 21409                                  
 21410                                  ; =============== S U B	R O U T	I N E =======================================
 21411                                  
 21412                                  	; 25/02/2023
 21413                                  noswit:
 21414 000028C4 57                      	push	di		; Save di
 21415 000028C5 BF8100                  	mov	di,81h		; di = ptr to command args
 21416 000028C8 BE8000                  	mov	si,80h		; Get address of length of command args
 21417 000028CB AC                      	lodsb			; Load length
 21418 000028CC 88C1                    	mov	cl,al		; Move length to cl
 21419 000028CE 30ED                    	xor	ch,ch		; Zero ch
 21420 000028D0 2EA0[E48A]              	mov	al,[cs:SWITCHAR] ; al = switch character
 21421                                  	;cmp	al,0		; Turn off ZF
 21422                                  	; 25/02/2023
 21423 000028D4 20C0                    	and	al,al
 21424 000028D6 F2AE                    	repne	scasb		; Scan for a switch character and return
 21425 000028D8 5F                      	pop	di		;  with ZF set if one was found
 21426 000028D9 C3                      	retn
 21427                                  
 21428                                  ; ---------------------------------------------------------------------------
 21429                                  
 21430                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21431                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h
 21432                                  
 21433                                  EXTERNAL:
 21434 000028DA E82602                  	call	test_append	; check to see if append installed
 21435 000028DD 7403                    	jz	short NOT_BARRYF
 21436                                  				; no - truly external command
 21437 000028DF E9FCFE                  	jmp	APPEND_INTERNAL	; yes - go to Barryf code
 21438                                  
 21439                                  NOT_BARRYF:
 21440 000028E2 2EC606[F38A]00          	mov	byte [cs:FILTYP],0
 21441 000028E8 2E8A16[008B]            	mov	dl,[cs:SPECDRV]
 21442 000028ED 2E8816[6A8B]            	mov	[cs:IDLEN],dl
 21443 000028F2 2EC606[E28C]00          	mov	byte [cs:ROM_CALL],0
 21444 000028F8 52                      	push	dx
 21445 000028F9 BA[6A8B]                	mov	dx,IDLEN
 21446 000028FC E8FBDA                  	call	ROM_SCAN
 21447 000028FF 5A                      	pop	dx
 21448                                  	;jnc	short POSTSAVE
 21449 00002900 7305                    	jnc	short DO_SCAN
 21450 00002902 2EFE06[E28C]            	inc	byte [cs:ROM_CALL]
 21451                                  	;jmp	short POSTSAVE
 21452                                  
 21453                                  	;nop
 21454                                  DO_SCAN:
 21455                                  POSTSAVE:
 21456 00002907 BF[088A]                	mov	di,EXECPATH
 21457 0000290A C60500                  	mov	byte [di],0	; Initialize to current directory
 21458                                  	
 21459 0000290D 2E803E[E28C]00          	cmp	byte [cs:ROM_CALL],0
 21460                                  	;jz	short RESEARCH
 21461                                  	; 25/02/2023
 21462                                  	;jmp	short NEOEXECUTE
 21463 00002913 750F                    	jnz	short NEOEXECUTE	
 21464                                  
 21465                                  	;nop
 21466                                  RESEARCH:
 21467 00002915 E89808                  	call	path_search	; find the mother (result in execpath)
 21468 00002918 09C0                    	or	ax,ax		; did we find anything?
 21469                                  	;jz	short BADCOMJ45	; null means no (sob)
 21470                                  	; 25/02/2023
 21471 0000291A 7459                    	jz	short BADCOM
 21472 0000291C 83F804                  	cmp	ax,4		; 04H and 08H are .exe and .com
 21473                                  				; fuckin' sixteen-bit machine ought
 21474                                  	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
 21475                                  				; DISPLACEMENT!!
 21476                                  	;;jmp	short NEOEXECUTE
 21477                                  	;jmp	short EXECUTE	
 21478                                  	; 25/02/2023
 21479 0000291F 7D03                    	jnl	short EXECUTE ; jge
 21480                                  
 21481                                  	; 02H is .bat
 21482                                  
 21483                                  	;nop
 21484                                  BATCOMJ:
 21485 00002921 E966DE                  	jmp	BATCOM
 21486                                  
 21487                                  	; 25/02/2023
 21488                                  ;BADCOMJ45:
 21489                                  	;jmp	short BADCOM
 21490                                  
 21491                                  	;nop
 21492                                  EXECUTE:
 21493                                  NEOEXECUTE:
 21494 00002924 E88502                  	call	IOSET
 21495                                  
 21496                                  ; MSDOS 6.0
 21497                                  ;M051
 21498                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
 21499                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
 21500                                  ;After a close, this would still leave one open active resulting in sharing
 21501                                  ;errors on subsequent opens of the redirected file.
 21502                                  
 21503                                  LH_EXECUTE:			;M051	
 21504 00002927 8E06[F08A]              	mov	es,[TRAN_TPA]
 21505                                  	;mov	ah,DEALLOC ; 49h
 21506 0000292B B449                    	mov	ah,49h
 21507 0000292D CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 21508                                  			; ES = segment address of area to be freed
 21509                                  				; Now running in "free" space
 21510 0000292F 8E06[E08A]              	mov	es,[RESSEG]
 21511 00002933 26FE06[9C01]            	inc	byte [es:ExtCom] ; Indicate external command
 21512 00002938 26C606[A401]00          	mov	byte [es:RestDir],0 
 21513                                  				; Since USERDIR1 is in transient, insure
 21514                                  				; this flag value for re-entry to COMMAND
 21515                                  	; MSDOS 6.0
 21516 0000293E BE[088A]                	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
 21517 00002941 BF[6303]                	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
 21518                                  	;mov	cx,LENMSGORPATHBUF
 21519 00002944 B95000                  	mov	cx,80
 21520 00002947 FC                      	cld
 21521 00002948 F3A4                    	rep	movsb		; copy program pathname to resident
 21522                                  
 21523                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21524 0000294A BF5C00                  	mov	di,FCB ; 5Ch
 21525 0000294D 89FE                    	mov	si,di
 21526                                  	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
 21527 0000294F B152                    	mov	cl,82 ; 25/02/2023
 21528 00002951 F3A5                    	rep	movsw		; Transfer parameters to resident header
 21529                                  	
 21530                                  	; 25/02/2023
 21531                                  	;mov	dx,EXECPATH  ; MSDOS 3.3
 21532                                  	; MSDOS 6.0 (& 5.0)
 21533                                  	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
 21534 00002953 BA[6303]                	mov	dx,SafePathBuffer
 21535 00002956 06                      	push	es
 21536 00002957 1F                      	pop	ds
 21537                                  
 21538                                  	;mov	bx,offset RESGROUP:EXEC_BLOCK
 21539 00002958 BB[3F03]                	mov	bx,Exec_Block  ; = offset EnvirSeg
 21540                                  	;mov	ax,EXEC*256 ; 4B00h
 21541 0000295B B8004B                  	mov	ax,4B00h
 21542                                  	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
 21543 0000295E 2EF606[E28C]FF          	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
 21544 00002964 7403                    	jz	short OK_EXEC
 21545 00002966 E90ADB                  	jmp	ROM_EXEC
 21546                                  
 21547                                  OK_EXEC:
 21548                                  
 21549                                  ; we are now running in free space. Anything we do from here on may get
 21550                                  ; trashed. Move the stack (also in free space) to allocated space because
 21551                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
 21552                                  
 21553 00002969 8CC1                    	mov	cx,es
 21554 0000296B 8ED1                    	mov	ss,cx
 21555 0000296D BC[3804]                	mov	sp,RStack
 21556                                  	; MSDOS 3.3
 21557                                  	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
 21558                                  	; 25/02/2023
 21559                                  	; MSDOS 6.0
 21560 00002970 2EFF2E[E68A]            	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident
 21561                                  
 21562                                  ; ---------------------------------------------------------------------------
 21563                                  
 21564                                  	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21565                                  BADCOM:
 21566 00002975 0E                      	push	cs
 21567 00002976 1F                      	pop	ds
 21568 00002977 BA[987F]                	mov	dx,BADNAM_PTR
 21569                                  cerror:		
 21570 0000297A E8BE24                  	call	std_eprintf
 21571 0000297D E984D7                  	jmp	TCOMMAND
 21572                                  
 21573                                  ; =============== S U B	R O U T	I N E =======================================
 21574                                  
 21575                                  ; Prescan converts the input buffer into a canonicalized form.
 21576                                  ; All redirections and pipes are removed.
 21577                                  
 21578                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21579                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h
 21580                                  
 21581                                  PRESCAN:
 21582 00002980 31C9                    	xor	cx,cx
 21583 00002982 8E06[E08A]              	mov	es,[RESSEG]
 21584 00002986 BE[4189]                	mov	si,COMBUF+2
 21585 00002989 89F7                    	mov	di,si
 21586                                  COUNTQUOTES:
 21587 0000298B AC                      	lodsb			; get a byte
 21588 0000298C 3C22                    	cmp	al,22h	; '"'	; is it a quote?
 21589 0000298E 7504                    	jne	short COUNTEND	; no, try for end of road
 21590 00002990 FEC5                    	inc	ch		; bump count
 21591 00002992 EBF7                    	jmp	short COUNTQUOTES
 21592                                  				; go get next char
 21593                                  COUNTEND:
 21594 00002994 3C0D                    	cmp	al,0Dh	; 13	; end of road?
 21595 00002996 75F3                    	jne	short COUNTQUOTES
 21596                                  				; no, go back for next char
 21597                                  	; 26/02/2023
 21598                                  	; MSDOS 5.0 (& 6.0)
 21599 00002998 51                      	push	cx		; save count
 21600 00002999 89FE                    	mov	si,di		; restore pointer to begining
 21601                                  KanjiScan:
 21602 0000299B AC                      	lodsb			; get a byte
 21603 0000299C E845FA                  	call	testkanj	; is it a leadin byte
 21604 0000299F 740F                    	jz	short KanjiQuote
 21605                                  				; no, check for quotes
 21606 000029A1 88C4                    	mov	ah,al		; save leadin
 21607 000029A3 AC                      	lodsb			; get trailing byte
 21608 000029A4 3D2020                  	cmp	ax,2020h
 21609                                  	;cmp	ax,DB_SPACE	; is it Kanji space
 21610 000029A7 75F2                    	jne	short KanjiScan	; no, go get next
 21611 000029A9 C744FE2020              	mov	word [si-2],2020h
 21612                                  				; replace with spaces
 21613 000029AE EBEB                    	jmp	short KanjiScan	; go get next char
 21614                                  	
 21615                                  KanjiQuote:
 21616 000029B0 3C22                    	cmp	al,22h	; '"'	; beginning of quoted string
 21617 000029B2 750D                    	jne	short KanjiEnd	; no, check for end
 21618 000029B4 FECD                    	dec	ch		; drop count
 21619 000029B6 74E3                    	jz	short KanjiScan	; if count is zero, no quoting
 21620                                  KanjiQuoteLoop:
 21621 000029B8 AC                      	lodsb			; get next byte
 21622 000029B9 3C22                    	cmp	al,22h	; '"'	; is it another quote
 21623 000029BB 75FB                    	jne	short KanjiQuoteLoop
 21624                                  				; no, get another
 21625 000029BD FECD                    	dec	ch		; yes, drop count
 21626 000029BF EBDA                    	jmp	short KanjiScan	; go get next char
 21627                                  KanjiEnd:
 21628 000029C1 3C0D                    	cmp	al,13 ; 0Dh	; end of line character?
 21629 000029C3 75D6                    	jne	short KanjiScan	; go back to beginning
 21630 000029C5 59                      	pop	cx		; get back original count
 21631                                  	; 26/04/2023
 21632 000029C6 89FE                    	mov	si,di		; restore pointer to beginning
 21633                                  	
 21634                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21635                                  PRESCANLP:
 21636 000029C8 AC                      	lodsb
 21637                                  	; 26/02/2023
 21638 000029C9 E818FA                  	call	testkanj
 21639 000029CC 740C                    	jz	short NOTKANJ6
 21640                                  	; MSDOS 6.0
 21641 000029CE 8805                    	mov	[di],al
 21642 000029D0 47                      	inc	di		; fake STOSB into DS
 21643 000029D1 AC                      	lodsb			; grab second byte
 21644 000029D2 8805                    	mov	[di],al		; fake stosb into DS
 21645 000029D4 FEC1                    	inc	cl
 21646 000029D6 FEC1                    	inc	cl
 21647 000029D8 EBEE                    	jmp	short PRESCANLP
 21648                                  
 21649                                  NOTKANJ6:
 21650                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21651 000029DA 3C22                    	cmp	al,'"'	; 22h	; " character
 21652 000029DC 7510                    	jne	short TRYGREATER
 21653 000029DE FECD                    	dec	ch
 21654 000029E0 740C                    	jz	short TRYGREATER
 21655                                  QLOOP:
 21656 000029E2 8805                    	mov	[di],al
 21657 000029E4 47                      	inc	di
 21658 000029E5 FEC1                    	inc	cl
 21659 000029E7 AC                      	lodsb
 21660 000029E8 3C22                    	cmp	al,'"'		; " character
 21661 000029EA 75F6                    	jne	short QLOOP
 21662 000029EC FECD                    	dec	ch
 21663                                  TRYGREATER:
 21664 000029EE 3C3E                    	cmp	al,'>' ; 3Eh
 21665                                  	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
 21666                                  	;;cmp	al,[RABRACKET]	; MSDOS 3.3
 21667 000029F0 7557                    	jne	short NOOUT
 21668                                  
 21669                                  ; We have found a ">" char. We need to see if there is another ">"
 21670                                  ; following it.
 21671                                  
 21672 000029F2 3804                    	cmp	[si],al
 21673 000029F4 7506                    	jne	short NOAPPND
 21674 000029F6 AC                      	lodsb
 21675 000029F7 26FE06[C601]            	inc	byte [es:Re_Out_App] ; Flag >>
 21676                                  NOAPPND:
 21677                                  ; Now we attempt to find the file name. First, scan off all whitespace
 21678                                  
 21679 000029FC E807FC                  	call	scanoff
 21680                                  
 21681                                  	; 26/02/2023
 21682                                  	; MSDOS 6.0
 21683 000029FF 3C3C                    	cmp	al,'<' ; 3Ch
 21684                                  	;cmp	al,labracket	;AN040; was there no filename?
 21685 00002A01 7404                    	je	short REOUT_ERRSET
 21686                                  				;AN040; yes - set up error
 21687                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21688 00002A03 3C0D                    	cmp	al,0Dh
 21689 00002A05 750D                    	jnz	short GOTREOFIL
 21690                                  
 21691                                  ; There was no file present. Set us up at end-of-line.
 21692                                  
 21693                                  REOUT_ERRSET:			;AN040; set up for an error
 21694 00002A07 C6050D                  	mov	byte [di],0Dh	; Clobber first ">"
 21695 00002A0A 26C706[C701]0900        	mov	word [es:Re_OutStr],9
 21696                                  				; Cause an error later
 21697 00002A11 E9A900                  	jmp	PRESCANEND
 21698                                  
 21699                                  GOTREOFIL:
 21700 00002A14 57                      	push	di
 21701                                  	;mov	di,offset RESGROUP:RE_OUTSTR
 21702 00002A15 BF[C701]                	mov	di,Re_OutStr
 21703 00002A18 89FB                    	mov	bx,di
 21704 00002A1A 06                      	push	es
 21705                                  
 21706                                  	; 26/02/2023
 21707                                  	; MSDOS 6.0
 21708                                  SETREOUTSTR:			; Get the output redirection name
 21709                                  				; MSKK06 07/14/89
 21710 00002A1B 51                      	push	cx		; save cx
 21711 00002A1C B94D00                  	mov	cx,64+13	; CX = max string length
 21712                                  SETREOUTSTR_LOOP:
 21713 00002A1F AC                      	lodsb
 21714 00002A20 3C0D                    	cmp	al,0Dh
 21715 00002A22 741A                    	je	short GOTRESTR_J
 21716 00002A24 E8E7FB                  	call	DELIM
 21717 00002A27 7415                    	jz	short GOTRESTR_J
 21718 00002A29 3A06[E48A]              	cmp	al,[SWITCHAR]
 21719 00002A2D 740F                    	je	short GOTRESTR_J
 21720 00002A2F 3C22                    	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
 21721 00002A31 7413                    	je	short PIPEERRSYNJ5_J
 21722                                  				;AN033; Yes - get out quick - or system crashes
 21723 00002A33 3C3C                    	cmp	al,'<' ; 3Ch
 21724                                  	;cmp	al,labracket	;AN002; Is char for input redirection
 21725 00002A35 7404                    	je	short ABRACKET_TERM
 21726                                  				;AN002; yes - end of string
 21727 00002A37 3C3E                    	cmp	al,'>' ; 3Eh
 21728                                  	;cmp	al,rabracket	;AN002; Is char for output redirection
 21729 00002A39 7506                    	jne	short NO_ABRACKET
 21730                                  				;AN002; no - not end of string
 21731                                  ABRACKET_TERM:			;AN002; have end of string by < or >
 21732 00002A3B 4E                      	dec	si		;AN002; back up over symbol
 21733 00002A3C B020                    	mov	al,20h ; BLANK	;AN002; show delimiter as char
 21734                                  GOTRESTR_J:
 21735 00002A3E 59                      	pop	cx		; MSKK06 07/14/89
 21736 00002A3F EB58                    	jmp	short GOTRESTR	;AN002; go process it
 21737                                  NO_ABRACKET:			;AN002; NOT AT END OF STRING
 21738 00002A41 AA                      	stosb			; store it into resgroup
 21739 00002A42 E2DB                    	loop	SETREOUTSTR_LOOP
 21740                                  				; MSKK06 07/14/89
 21741 00002A44 EBF8                    	jmp	short GOTRESTR_J
 21742                                  PIPEERRSYNJ5_J:
 21743 00002A46 59                      	pop	cx		; recover CX
 21744 00002A47 EB4B                    	jmp	short PIPEERRSYNJ5
 21745                                  
 21746                                  	; 26/02/2023
 21747                                  ;	; MSDOS 3.3
 21748                                  ;SETREOUTSTR_LOOP:		; Get the output redirection name
 21749                                  ;	lodsb
 21750                                  ;	cmp	al,0Dh
 21751                                  ;	jz	short GOTRESTR
 21752                                  ;	call	DELIM
 21753                                  ;	jz	short GOTRESTR
 21754                                  ;	cmp	al,[SWITCHAR]
 21755                                  ;	je	short GOTRESTR
 21756                                  ;	cmp	al,'"'
 21757                                  ;	jne	short NO_ABRACKET
 21758                                  ;	dec	ch
 21759                                  ;NO_ABRACKET:
 21760                                  ;	stosb
 21761                                  ;	jmp	short SETREOUTSTR_LOOP
 21762                                  
 21763                                  NOOUT:
 21764                                  	; 26/02/2023
 21765                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21766 00002A49 3C3C                    	cmp	al, '<' ; 3Ch
 21767                                  	;cmp	al,labracket	; MSDOS 6.0
 21768                                  	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
 21769 00002A4B 7523                    	jne	short CHKPIPE
 21770 00002A4D 89F3                    	mov	bx,si		; Save loc of "<"
 21771 00002A4F E8B4FB                  	call	scanoff
 21772                                  	; MSDOS 6.0
 21773 00002A52 3C3E                    	cmp	al,'>' ; 3Eh
 21774                                  	;cmp	al,rabracket	;AN040; was there no filename?
 21775 00002A54 7404                    	je	short REIN_ERRSET ;AN040; yes - set up error
 21776                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21777 00002A56 3C0D                    	cmp	al,0Dh
 21778 00002A58 750B                    	jne	short GOTREIFIL
 21779                                  REIN_ERRSET:			;AN040; set up for error
 21780 00002A5A C6050D                  	mov	byte [di],0Dh	; Clobber "<"
 21781 00002A5D C706[8B8A]0900          	mov	word [RE_INSTR],9 
 21782                                  				; Cause an error later
 21783 00002A63 EB58                    	jmp	short PRESCANEND
 21784                                  GOTREIFIL:
 21785 00002A65 57                      	push	di
 21786 00002A66 BF[8B8A]                	mov	di,RE_INSTR
 21787 00002A69 89FB                    	mov	bx,di
 21788 00002A6B 06                      	push	es
 21789 00002A6C 0E                      	push	cs
 21790 00002A6D 07                      	pop	es		; store in TRANGROUP
 21791                                  	; 26/04/2023
 21792                                  	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
 21793 00002A6E EBAB                    	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
 21794                                  				; Get the input redirection name
 21795                                  CHKPIPE:
 21796 00002A70 88C4                    	mov	ah,al
 21797                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21798 00002A72 80FC7C                  	cmp	ah,'|' ; 7Ch
 21799                                  	;cmp	ah,ALTPIPECHR ; 7Ch
 21800                                  	;je	short ISPIPE3
 21801                                  	;; MSDOS 6.0
 21802                                  	;cmp	ah,'|' ; 7Ch
 21803                                  	;;cmp	al,vbar ; 7Ch
 21804                                  	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
 21805 00002A75 7539                    	jne	short CONTPRESCAN
 21806                                  ISPIPE3:
 21807                                  ; Only push the echo flag if we are entering the pipe for the first time.
 21808                                  
 21809 00002A77 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 21810 00002A7D 7505                    	jne	short NOECHOPUSH
 21811 00002A7F 26D026[A001]            	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
 21812                                  NOECHOPUSH:
 21813 00002A84 26FE06[1802]            	inc	byte [es:PipeFlag]
 21814 00002A89 E87AFB                  	call	scanoff
 21815 00002A8C 3C0D                    	cmp	al,0Dh
 21816 00002A8E 7404                    	je	short PIPEERRSYNJ5
 21817                                  	; 26/02/2023
 21818 00002A90 3C7C                    	cmp	al,'|' ; 7Ch
 21819                                  	;cmp	al,ALTPIPECHR ; 7Ch
 21820                                  	;je	short PIPEERRSYNJ5
 21821                                  	;; MSDOS 6.0
 21822                                  	;cmp	al,'|' ; 7Ch
 21823                                  	;;cmp	al,vbar ; 7Ch
 21824                                  	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
 21825 00002A92 751C                    	jne	short CONTPRESCAN
 21826                                  
 21827                                  PIPEERRSYNJ5:
 21828 00002A94 06                      	push	es
 21829 00002A95 1F                      	pop	ds
 21830 00002A96 E9A502                  	jmp	PIPEERRSYN
 21831                                  
 21832                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
 21833                                  ; than just a : in the redir string.
 21834                                  
 21835                                  GOTRESTR:
 21836 00002A99 86E0                    	xchg	ah,al
 21837 00002A9B B03A                    	mov	al,':' ; 3Ah
 21838 00002A9D 29FB                    	sub	bx,di		; compute negative of number of chars
 21839 00002A9F 83FBFF                  	cmp	bx,-1		; is there just a :?
 21840 00002AA2 7407                    	je	short NOTRAILCOL ; yep, don't change
 21841 00002AA4 263845FF                	cmp	[es:di-1],al	; Trailing ':' OK on devices
 21842 00002AA8 7501                    	jne	short NOTRAILCOL
 21843 00002AAA 4F                      	dec	di		; Back up over trailing ':'
 21844                                  NOTRAILCOL:
 21845 00002AAB 30C0                    	xor	al,al
 21846 00002AAD AA                      	stosb			; NUL terminate the string
 21847 00002AAE 07                      	pop	es
 21848 00002AAF 5F                      	pop	di		; Remember the start
 21849                                  CONTPRESCAN:
 21850 00002AB0 8825                    	mov	[di],ah		; "delete" the redirection string
 21851 00002AB2 47                      	inc	di
 21852 00002AB3 80FC0D                  	cmp	ah,0Dh
 21853 00002AB6 7405                    	je	short PRESCANEND
 21854 00002AB8 FEC1                    	inc	cl
 21855 00002ABA E90BFF                  	jmp	PRESCANLP
 21856                                  PRESCANEND:
 21857 00002ABD 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 21858 00002AC3 7414                    	jz	short ISNOPIPE
 21859                                  
 21860                                  	; 26/02/2023
 21861                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
 21862                                  	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
 21863                                  	;;			; (EndInit+160]
 21864                                  	;mov	di,offset RESGROUP:PIPESTR
 21865 00002AC5 BF[BA02]                	mov	di,PipeStr	; RESGROUP:EndInit+160
 21866                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
 21867                                  	;;mov	[es:3BEh],di	; [es:EndInit+158]
 21868 00002AC8 26893E[B802]            	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
 21869                                  	
 21870 00002ACD BE[4189]                	mov	si,COMBUF+2
 21871 00002AD0 E833FB                  	call	scanoff
 21872                                  PIPESETLP:			; Transfer the pipe into the resident
 21873 00002AD3 AC                      	lodsb			; pipe buffer
 21874 00002AD4 AA                      	stosb
 21875 00002AD5 3C0D                    	cmp	al,0Dh
 21876 00002AD7 75FA                    	jnz	short PIPESETLP
 21877                                  ISNOPIPE:
 21878 00002AD9 880E[4089]              	mov	[COMBUF+1],cl
 21879 00002ADD 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 21880 00002AE3 0E                      	push	cs
 21881 00002AE4 07                      	pop	es
 21882 00002AE5 C3                      	retn
 21883                                  
 21884                                  ; =============== S U B	R O U T	I N E =======================================
 21885                                  
 21886                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21887                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
 21888                                  cmd_copy:
 21889 00002AE6 BE[4189]                	mov	si,COMBUF+2
 21890 00002AE9 E81AFB                  	call	scanoff		; advance past separators...
 21891 00002AEC 0336[3F8C]              	add	si,[PathPos]
 21892 00002AF0 BF8100                  	mov	di,81h
 21893 00002AF3 31C9                    	xor	cx,cx
 21894                                  cmdcopy:
 21895 00002AF5 AC                      	lodsb
 21896 00002AF6 AA                      	stosb
 21897 00002AF7 3C0D                    	cmp	al,0Dh
 21898 00002AF9 7403                    	je	short copy_done
 21899 00002AFB 41                      	inc	cx
 21900 00002AFC EBF7                    	jmp	short cmdcopy
 21901                                  copy_done:
 21902 00002AFE 880E8000                	mov	[80h],cl
 21903 00002B02 C3                      	retn
 21904                                  
 21905                                  ; =============== S U B	R O U T	I N E =======================================
 21906                                  
 21907                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21908                                  test_append:
 21909 00002B03 BB[3F89]                	mov	bx,COMBUF	; barry can address
 21910 00002B06 BE[6A8B]                	mov	si,IDLEN	; address command name, DS already set 	
 21911 00002B09 BAFFFF                  	mov	dx,-1
 21912 00002B0C B800AE                  	mov	ax,0AE00h
 21913 00002B0F CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
 21914                                  			; - INSTALLABLE	COMMAND	- INSTALL CHECK
 21915                                  			; DX = FFFFh,[BX -> command line
 21916                                  			; Return: AL = FFh if this command is a TSR extension 
 21917                                  			;		   to COMMAND.COM
 21918                                  			; AL = 00h if the command should be executed as	usual
 21919                                  	;cmp	al,0
 21920 00002B11 08C0                    	or	al,al ; 25/02/2023
 21921 00002B13 C3                      	retn
 21922                                  
 21923                                  	; 25/02/2023
 21924                                  	; INT 2Fh
 21925                                  	; 	AX = AE00h
 21926                                  	; entry:
 21927                                  	; 	DX = magic value FFFFh
 21928                                  	; 	CH = FFh
 21929                                  	; 	CL = length of command line tail
 21930                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 21931                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 21932                                  	; return:
 21933                                  	;	AL = FFh if this command is a TSR extension to COMMAND.COM
 21934                                  	;	AL = 00h if the command should be executed as usual
 21935                                  	;
 21936                                  	; Format of COMMAND.COM command line buffer:
 21937                                  	;	Offset  Size    Description
 21938                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 21939                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 21940                                  	;	N BYTEs command line text, terminated by 0Dh
 21941                                  	;
 21942                                  	; Format of command name buffer:
 21943                                  	;	Offset  Size    Description
 21944                                  	;	00h     BYTE    length of command name
 21945                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 21946                                  
 21947                                  ;============================================================================
 21948                                  ; TMISC2.ASM, MSDOS 6.0, 1991
 21949                                  ;============================================================================
 21950                                  ; 05/10/2018 - Retro DOS v3.0
 21951                                  
 21952                                  ;	More misc routines
 21953                                  
 21954                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
 21955                                  
 21956                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21957                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh
 21958                                  
 21959                                  ; =============== S U B	R O U T	I N E =======================================
 21960                                  
 21961                                  SETPATH:
 21962                                  
 21963                                  ; ENTRY PathPos = ptr to string
 21964                                  ;       PathCnt = length of string
 21965                                  ;
 21966                                  ; EXIT  PathPos = ptr to string after pathname
 21967                                  ;       PathCnt = length of rest of string
 21968                                  ;       DX = ptr to pathname in string, made ASCIIZ
 21969                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
 21970                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
 21971                                  ;
 21972                                  ;       A null character is dropped at the end of the pathname. If the
 21973                                  ;       character in that spot previously was CR, it is copied into the
 21974                                  ;       following byte. So there must be at least two two character 
 21975                                  ;       positions in the buffer following the pathname.
 21976                                  
 21977                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21978                                  	; MSDOS 6.0
 21979 00002B14 A1[3D8C]                	mov	ax,[PathCnt]	;AC000; get length of string
 21980 00002B17 8B36[3F8C]              	mov	si,[PathPos]	;AC000; get start of source buffer
 21981                                  
 21982                                  	; 26/02/2023
 21983                                  	; MSDOS 3.3
 21984                                  	;mov	si,80h
 21985                                  	;lodsb
 21986                                  	;xor	ah,ah
 21987                                  	;mov	[PATCNT],ax
 21988                                  	;mov	[PATHPOS],si
 21989                                  GETPATH:
 21990                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21991 00002B1B C606[EB8C]00            	mov	byte [DestInfo],0
 21992 00002B20 C606[E78C]00            	mov	byte [DestIsDir],0
 21993 00002B25 8B36[3F8C]              	mov	si,[PathPos]	; SI = ptr to string
 21994 00002B29 8B0E[3D8C]              	mov	cx,[PathCnt]	; CX = string length
 21995 00002B2D 89F2                    	mov	dx,si		; DX = ptr to string
 21996 00002B2F E34D                    	jcxz	PATHDONE	; string length is zero, we're done
 21997 00002B31 51                      	push	cx		; save string length
 21998 00002B32 56                      	push	si		; save ptr to string
 21999 00002B33 E86EFC                  	call	SWITCH
 22000                                  
 22001                                  ;       After Switch, SI has been scanned past any switches, and
 22002                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
 22003                                  
 22004 00002B36 A3[418C]                	mov	[PathSw],ax	; PathSw = switch occurrence mask
 22005 00002B39 5B                      	pop	bx		; BX = ptr to original string
 22006 00002B3A 29F3                    	sub	bx,si		; BX = -(# chars scanned by Switch)
 22007 00002B3C 59                      	pop	cx		; CX = string length
 22008 00002B3D 01D9                    	add	cx,bx		; CX = string length from current SI
 22009 00002B3F 89F2                    	mov	dx,si		; DX = ptr to current string
 22010                                  SKIPPATH:
 22011                                  	; 26/02/2023
 22012                                  	; MSDOS 6.0
 22013 00002B41 C606[6E8E]00            	mov	byte [KPARSE],0
 22014                                  SKIPPATH2:
 22015 00002B46 E336                    	jcxz	PATHDONE	; string length is zero, we're done
 22016 00002B48 49                      	dec	cx		; CX = length left after next char
 22017 00002B49 AC                      	lodsb			; AL = next char of string
 22018                                  				; SI = ptr to char after this one
 22019                                  	; 26/02/2023
 22020 00002B4A E897F8                  	call	testkanj
 22021 00002B4D 7408                    	jz	short TESTPPSEP
 22022 00002B4F 49                      	dec	cx
 22023 00002B50 46                      	inc	si
 22024 00002B51 FE06[6E8E]              	inc	byte [KPARSE]
 22025 00002B55 EBEF                    	jmp	short SKIPPATH2
 22026                                  TESTPPSEP:
 22027 00002B57 E83AFB                  	call	pathchrcmp	; compare AL to path delimiter char
 22028 00002B5A 7504                    	jnz	short TESTPMETA	; it's not a path delim
 22029 00002B5C FE06[E78C]              	inc	byte [DestIsDir]
 22030                                  				; DestIsDir = 1, signalling path char
 22031                                  TESTPMETA:
 22032 00002B60 3C3F                    	cmp	al,'?'
 22033 00002B62 7505                    	jne	short TESTPSTAR	; char is not '?'
 22034 00002B64 800E[EB8C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22035                                  TESTPSTAR:
 22036 00002B69 3C2A                    	cmp	al,'*'
 22037                                  	;cmp	al,[STAR] ; MSDOS 3.3	
 22038 00002B6B 7505                    	jne	short TESTPDELIM ; char is not '*'
 22039 00002B6D 800E[EB8C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22040                                  TESTPDELIM:
 22041 00002B72 E899FA                  	call	DELIM		; compare AL to all delimiters
 22042 00002B75 7406                    	jz	short PATHDONEDEC ; delimiter found, back up & leave
 22043 00002B77 3A06[E48A]              	cmp	al,[SWITCHAR]
 22044 00002B7B 75C4                    	jne	short SKIPPATH	; char isn't switch, go get next char
 22045                                  PATHDONEDEC:
 22046 00002B7D 4E                      	dec	si		; SI = ptr to char after pathname
 22047                                  PATHDONE:
 22048 00002B7E 30C0                    	xor	al,al		; AL = NULL
 22049 00002B80 8604                    	xchg	al,[si]		; place NULL after pathname
 22050 00002B82 46                      	inc	si		; SI = ptr to byte after NULL
 22051 00002B83 3C0D                    	cmp	al,0Dh		; were we at end of line?
 22052 00002B85 7502                    	jne	short NOPSTORE	; not EOL, finish up
 22053 00002B87 8804                    	mov	[si],al		; save EOL after NULL
 22054                                  NOPSTORE:
 22055 00002B89 8936[3F8C]              	mov	[PathPos],si	; PathPos = ptr to char after NULL
 22056 00002B8D 890E[3D8C]              	mov	[PathCnt],cx	; PathCnt = length of string left
 22057                                  SETPATH_RETN:
 22058 00002B91 C3                      	retn
 22059                                  
 22060                                  ; ---------------------------------------------------------------------------
 22061                                  
 22062                                  PGETARG:
 22063 00002B92 BE8000                  	mov	si,80h
 22064 00002B95 AC                      	lodsb
 22065 00002B96 08C0                    	or	al,al
 22066 00002B98 74F7                    	jz	short SETPATH_RETN
 22067 00002B9A E80300                  	call	PSCANOFF
 22068 00002B9D 3C0D                    	cmp	al,0Dh
 22069 00002B9F C3                      	retn
 22070                                  
 22071                                  ; ---------------------------------------------------------------------------
 22072                                  
 22073                                  PSCANOFF:
 22074 00002BA0 AC                      	lodsb
 22075 00002BA1 E86AFA                  	call	DELIM
 22076 00002BA4 7504                    	jnz	short PSCANOFFD
 22077 00002BA6 3C3B                    	cmp	al,';' ; 3Bh
 22078 00002BA8 75F6                    	jne	short PSCANOFF	; ';' is not a delimiter
 22079                                  PSCANOFFD:
 22080 00002BAA 4E                      	dec	si		; Point to first non-delimiter
 22081 00002BAB C3                      	retn
 22082                                  
 22083                                  ; =============== S U B	R O U T	I N E =======================================
 22084                                  
 22085                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22086                                  IOSET:
 22087                                  	; ALL REGISTERS PRESERVED
 22088 00002BAC 1E                      	push	ds
 22089 00002BAD 52                      	push	dx
 22090 00002BAE 50                      	push	ax
 22091 00002BAF 53                      	push	bx
 22092 00002BB0 51                      	push	cx
 22093 00002BB1 2E8E1E[E08A]            	mov	ds,[cs:RESSEG]
 22094 00002BB6 803E[1802]00            	cmp	byte [PipeFlag],0
 22095 00002BBB 750D                    	jne	short NOREDIR
 22096 00002BBD F606[AB01]FF            	test	byte [IfFlag],0FFh
 22097 00002BC2 7506                    	jnz	short NOREDIR
 22098 00002BC4 E88E00                  	call	TESTDOREIN
 22099 00002BC7 E80600                  	call	TESTDOREOUT
 22100                                  NOREDIR:
 22101 00002BCA 59                      	pop	cx
 22102 00002BCB 5B                      	pop	bx
 22103 00002BCC 58                      	pop	ax
 22104 00002BCD 5A                      	pop	dx
 22105 00002BCE 1F                      	pop	ds
 22106 00002BCF C3                      	retn
 22107                                  
 22108                                  ; =============== S U B	R O U T	I N E =======================================
 22109                                  
 22110                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22111                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
 22112                                  TESTDOREOUT:
 22113 00002BD0 803E[C701]00            	cmp	byte [Re_OutStr],0
 22114                                  	;je	short NOREOUT  ; MSDOS 3.3
 22115                                  	; 26/02/2023
 22116 00002BD5 7502                    	jne	short REOUTEXISTS
 22117 00002BD7 EB7B                    	jmp	NOREOUT 
 22118                                  REOUTEXISTS:
 22119 00002BD9 803E[C601]00            	cmp	byte [Re_Out_App],0
 22120 00002BDE 745D                    	je	short REOUTCRT
 22121                                  
 22122 00002BE0 BA[C701]                	mov	dx,Re_OutStr
 22123                                  
 22124                                  	; 26/02/2023
 22125                                  	; MSDOS 6.0
 22126                                  	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
 22127 00002BE3 B8023D                  	mov	ax,3D02h
 22128                                  	; MSDOS 3.3
 22129                                  	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
 22130                                  	
 22131                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22132 00002BE6 50                      	push	ax
 22133 00002BE7 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22134                                  			; DS:DX	-> ASCIZ filename
 22135                                  			; AL = access mode
 22136                                  			; 1 - write
 22137 00002BE9 5B                      	pop	bx
 22138 00002BEA 724B                    	jc	short OpenWriteError
 22139                                  
 22140                                  	; 26/02/2023
 22141                                  	; MSDOS 6.0
 22142 00002BEC 89C3                    	mov	bx,ax
 22143                                  	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
 22144 00002BEE B80044                  	mov	ax,4400h
 22145 00002BF1 CD21                    	int	21h			;AN035;
 22146                                  			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 22147                                  			; BX = file or device handle
 22148 00002BF3 F6C280                  	test	dl,80h
 22149                                  	;test	dl,devid_ISDEV		;AN035; Is it a device?
 22150 00002BF6 7554                    	jnz	short SET_REOUT		;AN035; Yes, don't read from it
 22151                                  	
 22152                                  	;mov	ax,(LSEEK SHL 8) OR 2
 22153 00002BF8 B80242                  	mov	ax,4202h
 22154 00002BFB B9FFFF                  	mov	cx,-1			;AC011; MOVE TO EOF -1
 22155 00002BFE 89CA                    	mov	dx,cx			;AC011;
 22156 00002C00 CD21                    	int	21h
 22157                                  			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22158                                  			; AL = method: offset from end of file
 22159 00002C02 0E                      	push	cs			;AN011; Get transient seg to DS
 22160 00002C03 1F                      	pop	ds			;AN011;
 22161                                  	
 22162                                  	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
 22163 00002C04 B8003F                  	mov	ax,3F00h
 22164 00002C07 B90100                  	mov	cx,1			;AN011;  file into one_char_val
 22165 00002C0A BA[DF8C]                	mov	dx,One_Char_Val		;AN011;
 22166 00002C0D CD21                    	int	21h			;AN011;
 22167                                  			; DOS - 2+ - READ FROM FILE WITH HANDLE
 22168                                  			; BX = file handle, CX = number of bytes to read
 22169                                  			; DS:DX -> buffer
 22170 00002C0F 7226                    	jc	short OpenWriteError	;AN011; If error, exit
 22171 00002C11 39C8                    	cmp	ax,cx			;AN017; Did we read 1 byte?
 22172 00002C13 7517                    	jnz	short reout_0_length	;AN017; No - file must be 0 length
 22173                                  	
 22174 00002C15 803E[DF8C]1A            	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
 22175 00002C1A 8E1E[E08A]              	mov	ds,[RESSEG]		;AN011; Get resident segment back
 22176 00002C1E 752C                    	jne	short SET_REOUT		;AN011; No, just continue
 22177                                  	
 22178                                  	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
 22179 00002C20 B80142                  	mov	ax,4201h
 22180 00002C23 B9FFFF                  	mov	cx,-1			;AN011; LSEEK back one byte
 22181                                  setreout_p:	; 26/02/2023
 22182 00002C26 89CA                    	mov	dx,cx			;AN011;
 22183 00002C28 CD21                    	int	21h			;AN011;
 22184 00002C2A EB20                    	jmp	short SET_REOUT
 22185                                  reout_0_length: 			;AN017; We have a 0 length file
 22186                                  	; ds = cs ; 26/02/2023
 22187                                  	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
 22188                                  					;AN017; Get resident segment back
 22189                                  	; 26/02/2023
 22190 00002C2C 8E1E[E08A]              	mov	ds,[RESSEG]
 22191                                  	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
 22192 00002C30 B80042                  	mov	ax,4200h
 22193 00002C33 31C9                    	xor	cx,cx			;AN017; Offset is 0
 22194                                  	;mov	dx,cx			;AN017;
 22195                                  	;int	21h			;AN017;
 22196                                  	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
 22197                                  	; 26/02/2023
 22198 00002C35 EBEF                    	jmp	short setreout_p
 22199                                  
 22200                                  	; 26/02/2023
 22201                                  	; MSDOS 3.3
 22202                                  	;xor	dx,dx
 22203                                  	;xor	cx,cx
 22204                                  	;mov	bx,ax
 22205                                  	;mov	ax,(LSEEK<<8)|2 ; 4202h
 22206                                  	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22207                                  	;		; AL = method: offset from end of file
 22208                                  	;jmp	short SET_REOUT
 22209                                  		
 22210                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22211                                  OpenWriteError:	
 22212                                  	;cmp	ax,5
 22213 00002C37 83F805                  	cmp	ax,ERROR_ACCESS_DENIED
 22214 00002C3A F9                      	stc
 22215                                  	;;je	short REDIRERR ; MSDOS 3.3
 22216                                  	; 26/02/2023
 22217                                  	;jnz	short REOUTCRT
 22218                                  	;jmp	REDIRERR
 22219 00002C3B 743B                    	je	short REDIRERR
 22220                                  
 22221                                  REOUTCRT:	
 22222 00002C3D BA[C701]                	mov	dx,Re_OutStr
 22223 00002C40 31C9                    	xor	cx,cx
 22224                                  	;mov	ah,CREAT ; 3Ch
 22225 00002C42 B43C                    	mov	ah,3Ch
 22226 00002C44 50                      	push	ax
 22227 00002C45 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 22228                                  			; CX = attributes for file
 22229                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 22230 00002C47 5B                      	pop	bx
 22231                                  	;jc	short REDIRERR ; MSDOS 3.3
 22232                                  	; 26/02/2023
 22233                                  	;jnc	short NOREDIRERR
 22234                                  	;jmp	REDIRERR
 22235 00002C48 722E                    	jc	short REDIRERR
 22236                                  	
 22237                                  NOREDIRERR:
 22238 00002C4A 89C3                    	mov	bx,ax
 22239                                  SET_REOUT:
 22240                                  
 22241                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
 22242                                  ; spot. We invalidate the new JFN we got.
 22243                                  
 22244 00002C4C B0FF                    	mov	al,0FFh
 22245                                  	;xchg	al,[bx+18h]
 22246 00002C4E 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22247 00002C51 A21900                  	mov	[PDB.JFN_TABLE+1],al
 22248                                  NOREOUT:
 22249                                  IOSET_RETN:	; 17/04/2023
 22250 00002C54 C3                      	retn
 22251                                  
 22252                                  ; =============== S U B	R O U T	I N E =======================================
 22253                                  
 22254                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22255                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22256                                  TESTDOREIN:
 22257 00002C55 2E803E[8B8A]00          	cmp	byte [cs:RE_INSTR],0
 22258 00002C5B 74F7                    	jz	short IOSET_RETN
 22259 00002C5D 1E                      	push	ds
 22260 00002C5E 0E                      	push	cs
 22261 00002C5F 1F                      	pop	ds
 22262 00002C60 BA[8B8A]                	mov	dx,RE_INSTR
 22263                                  	;mov	ax,OPEN*256 ; 3D00h
 22264 00002C63 B8003D                  	mov	ax,3D00h
 22265 00002C66 89C3                    	mov	bx,ax
 22266 00002C68 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22267                                  			; DS:DX	-> ASCIZ filename
 22268                                  			; AL = access mode
 22269                                  			; 0 - read
 22270 00002C6A 1F                      	pop	ds
 22271                                  
 22272 00002C6B 720B                    	jc	short REDIRERR
 22273                                  
 22274 00002C6D 89C3                    	mov	bx,ax
 22275 00002C6F B0FF                    	mov	al,0FFh
 22276                                  
 22277                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
 22278                                  ; spot. We invalidate the new JFN we got.
 22279                                  
 22280                                  	;xchg	al,[bx+18h]
 22281 00002C71 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22282 00002C74 A21800                  	mov	[PDB.JFN_TABLE],al
 22283 00002C77 C3                      	retn
 22284                                  
 22285                                  ; ---------------------------------------------------------------------------
 22286                                  
 22287                                  ; We had some kind of error on the redirection. Figure out what the
 22288                                  ; appropriate message should be; BX has the system call that failed
 22289                                  
 22290                                  REDIRERR:
 22291 00002C78 0E                      	push	cs
 22292 00002C79 1F                      	pop	ds
 22293 00002C7A E82E00                  	call	TriageError  ; MSDOS 6.0
 22294                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22295                                  
 22296                                  ; At this point, we have recognized the network-generated access denied error.
 22297                                  ; The correct message is in DX
 22298                                  
 22299 00002C7D 83F841                  	cmp	ax,65
 22300 00002C80 7408                    	je	short _CERRORJ	;AC000; just issue message returned
 22301 00002C82 80FF3D                  	cmp	bh,OPEN ; 3Dh
 22302 00002C85 7406                    	je	short OpenError
 22303 00002C87 BA[8F7F]                	mov	dx,FULLDIR_PTR
 22304                                  _CERRORJ:
 22305 00002C8A E9EDFC                  	jmp	cerror
 22306                                  
 22307                                  OpenError:
 22308                                  ; The system call was an OPEN. Report either file not found or path not found.
 22309                                  
 22310                                  	; 26/02/2023
 22311                                  	; MSDOS 6.0
 22312                                  	;mov	byte [cs:msg_disp_class],1
 22313 00002C8D 2EC606[737F]01          	mov	byte [cs:msg_disp_class],ext_msg_class
 22314                                  				;AN000; set up extended error msg class
 22315 00002C93 BA[757F]                	mov	dx,extend_buf_ptr
 22316                                  				;AC000; get extended message pointer
 22317 00002C96 2EA3[757F]              	mov	[cs:extend_buf_ptr],ax
 22318                                  				;AN000; get message number in control block
 22319 00002C9A E9DDFC                  	jmp	cerror
 22320                                  
 22321                                  	; 26/02/2023
 22322                                  	; MSDOS 3.3
 22323                                  	;mov	dx,FNOTFOUNDPTR
 22324                                  	;;cmp	ax,2
 22325                                  	;cmp	ax,ERROR_FILE_NOT_FOUND
 22326                                  	;je	short _CERRORJ
 22327                                  	;mov	dx,ACCDENPTR
 22328                                  	;;cmp	ax,5 ; Access denied error
 22329                                  	;cmp	ax,ERROR_ACCESS_DENIED
 22330                                  	;je	short _CERRORJ
 22331                                  	;	; ERROR_PATH_NOT_FOUND
 22332                                  	;mov	dx,PNOTFOUNDPTR
 22333                                  	;jmp	CERROR
 22334                                  
 22335                                  ; =============== S U B	R O U T	I N E =======================================
 22336                                  
 22337                                  ; Compute length of string (including NUL) in DS:SI into CX. Change no other
 22338                                  ; registers
 22339                                  
 22340                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22341                                  dstrlen:
 22342 00002C9D 50                      	push	ax
 22343 00002C9E 31C9                    	xor	cx,cx
 22344 00002CA0 FC                      	cld
 22345                                  dloop:
 22346 00002CA1 AC                      	lodsb
 22347 00002CA2 41                      	inc	cx
 22348 00002CA3 08C0                    	or	al,al
 22349 00002CA5 75FA                    	jnz	short dloop
 22350 00002CA7 29CE                    	sub	si,cx
 22351 00002CA9 58                      	pop	ax
 22352                                  TRIAGEERR_RETN:
 22353 00002CAA C3                      	retn
 22354                                  
 22355                                  ; =============== S U B	R O U T	I N E =======================================
 22356                                  
 22357                                  ;Break	<Extended error support>
 22358                                  
 22359                                  TriageError:  ; MSDOS 6.0
 22360                                  
 22361                                  ; TriageError will examine the return from a carry-set system call and
 22362                                  ; return the correct error if applicable.
 22363                                  ;
 22364                                  ;   Inputs:	outputs from a carry-settable system call
 22365                                  ;		No system calls may be done in the interrim
 22366                                  ;   Outputs:	If carry was set on input
 22367                                  ;		   carry set on output
 22368                                  ;		   DX contains trangroup offset to printf message
 22369                                  ;		else
 22370                                  ;		   No registers changed
 22371                                  
 22372                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
 22373                                  
 22374                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22375                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h
 22376                                  
 22377                                  GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
 22378 00002CAB 73FD                    	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
 22379 00002CAD 9C                      	pushf
 22380 00002CAE 53                      	push	bx
 22381 00002CAF 51                      	push	cx
 22382 00002CB0 56                      	push	si
 22383 00002CB1 57                      	push	di
 22384 00002CB2 55                      	push	bp
 22385 00002CB3 06                      	push	es
 22386 00002CB4 1E                      	push	ds
 22387 00002CB5 50                      	push	ax
 22388 00002CB6 52                      	push	dx
 22389 00002CB7 B459                    	mov	ah,59h
 22390                                  	;mov	ah,GETEXTENDEDERROR
 22391 00002CB9 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 22392                                  			; BX = version code (0000h for DOS 3.x)
 22393 00002CBB 59                      	pop	cx
 22394 00002CBC 5B                      	pop	bx		; restore original AX
 22395 00002CBD BA[9B7F]                	mov	dx,ACCDEN_PTR
 22396 00002CC0 83F841                  	cmp	ax,65		; network access denied?
 22397 00002CC3 7404                    	je	short NoMove	; Yes, return it.
 22398 00002CC5 89D8                    	mov	ax,bx
 22399 00002CC7 89CA                    	mov	dx,cx
 22400                                  NoMove:
 22401 00002CC9 1F                      	pop	ds
 22402 00002CCA 07                      	pop	es
 22403 00002CCB 5D                      	pop	bp
 22404 00002CCC 5F                      	pop	di
 22405 00002CCD 5E                      	pop	si
 22406 00002CCE 59                      	pop	cx
 22407 00002CCF 5B                      	pop	bx
 22408 00002CD0 9D                      	popf
 22409 00002CD1 C3                      	retn
 22410                                  
 22411                                  ; =============== S U B	R O U T	I N E =======================================
 22412                                  
 22413                                  	; Far call from resident portion/segment of COMMAND.COM
 22414                                  
 22415                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
 22416                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h
 22417                                  
 22418                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22419                                  Triage_Init:
 22420 00002CD2 E8D6FF                  	call	TriageError	 ; MSDOS 6.0
 22421                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22422 00002CD5 CB                      	retf
 22423                                  
 22424                                  ; =============== S U B	R O U T	I N E =======================================
 22425                                  
 22426                                  ; MSDOS 6.0
 22427                                  
 22428                                  ; ****************************************************************
 22429                                  ; *
 22430                                  ; * ROUTINE:	 MOVE_TO_SRCBUF
 22431                                  ; *
 22432                                  ; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
 22433                                  ; *		 terminating 0 to 0dH.	Set PATHCNT to length of
 22434                                  ; *		 string.  Set PATHPOS to start of SRCBUF.
 22435                                  ; *
 22436                                  ; * INPUT:	 DS:SI points to ASCIIZ string
 22437                                  ; *		 ES    points to TRANGROUP
 22438                                  ; *
 22439                                  ; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
 22440                                  ; *		 PATHCNT set to length of string
 22441                                  ; *		 PATHPOS set to start of SRCBUF
 22442                                  ; *		 CX,AX	 changed
 22443                                  ; *
 22444                                  ; ****************************************************************
 22445                                  
 22446                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22447                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22448                                  Move_To_SrcBuf:
 22449 00002CD6 56                      	push	si			;AN000;  save si,di
 22450 00002CD7 57                      	push	di			;AN000;
 22451 00002CD8 51                      	push	cx			;AN000;
 22452 00002CD9 BF[4F8D]                	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
 22453 00002CDC 31C9                    	xor	cx,cx			;AN000; clear cx for counint
 22454 00002CDE 89C8                    	mov	ax,cx			;AN000; clear ax
 22455 00002CE0 57                      	push	di			;AN000; save start of srcbuf
 22456 00002CE1 AC                      	lodsb				;AN000; get a character from DS:SI
 22457                                  mts_get_chars:				;AN000;
 22458                                  	;cmp	al,0			;AN000; was it a null char?
 22459 00002CE2 20C0                    	and 	al,al ; al = 0 ?
 22460 00002CE4 7405                    	jz	short mts_end_string	;AN000; yes - exit
 22461 00002CE6 AA                      	stosb				;AN000; no - store it in srcbuf
 22462 00002CE7 41                      	inc	cx			;AN000; increment length count
 22463 00002CE8 AC                      	lodsb				;AN000; get a character from DS:SI
 22464 00002CE9 EBF7                    	jmp	short mts_get_chars	;AN000; go check it
 22465                                  mts_end_string: 			;AN000; we've reached the end of line
 22466                                  	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
 22467 00002CEB B00D                    	mov	al,0Dh
 22468 00002CED AA                      	stosb				;AN000;
 22469 00002CEE 5F                      	pop	di			;AN000; restore start of srcbuf
 22470 00002CEF 0E                      	push	cs			;AN000; set DS to local segment
 22471 00002CF0 1F                      	pop	ds			;AN000;
 22472 00002CF1 890E[3D8C]              	mov	[PathCnt],cx		;AN000; set patchcnt to length count
 22473 00002CF5 893E[3F8C]              	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
 22474 00002CF9 59                      	pop	cx			;AN000; restore cx,di,si
 22475 00002CFA 5F                      	pop	di			;AN000;
 22476 00002CFB 5E                      	pop	si			;AN000;
 22477 00002CFC C3                      	retn				;AN000; exit
 22478                                  
 22479                                  ;============================================================================
 22480                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 22481                                  ;============================================================================
 22482                                  ; 03/10/2018 - Retro DOS v3.0
 22483                                  
 22484                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
 22485                                  
 22486                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22487                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h
 22488                                  
 22489                                  ; =============== S U B	R O U T	I N E =======================================
 22490                                  
 22491                                  	; 26/02/2023
 22492                                  SINGLETEST:
 22493 00002CFD 1E                      	push	ds
 22494 00002CFE 2E8E1E[E08A]            	mov	ds,[cs:RESSEG]
 22495 00002D03 833E[A601]00            	cmp	word [SingleCom],0
 22496 00002D08 7406                    	jz	short TESTDONE
 22497 00002D0A 813E[A601]FFEF          	cmp	word [SingleCom],0EFFFh
 22498                                  TESTDONE:
 22499 00002D10 1F                      	pop	ds
 22500 00002D11 C3                      	retn
 22501                                  
 22502                                  ; =============== S U B	R O U T	I N E =======================================
 22503                                  
 22504                                  	; 26/02/2023
 22505                                  SetRest1:
 22506 00002D12 B001                    	mov	al,1
 22507                                  
 22508                                  ; ---------------------------------------------------------------------------
 22509                                  
 22510                                  SETREST:
 22511 00002D14 1E                      	push	ds
 22512 00002D15 8E1E[E08A]              	mov	ds,[RESSEG]
 22513 00002D19 A2[A401]                	mov	[RestDir],al
 22514 00002D1C 1F                      	pop	ds
 22515 00002D1D C3                      	retn
 22516                                  
 22517                                  ; =============== S U B	R O U T	I N E =======================================
 22518                                  
 22519                                  ; Note that we need to handle the same thing that RestDir handles: the
 22520                                  ; requirement that we try only once to restore the user's environment after
 22521                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
 22522                                  ; disappear, we just give up.
 22523                                  
 22524                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22525                                  PIPEDEL:
 22526 00002D1E 1E                      	push	ds
 22527 00002D1F 52                      	push	dx
 22528 00002D20 2E8E1E[E08A]            	mov	ds,[cs:RESSEG]
 22529                                  	;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
 22530                                  			; Pipe1 = offset RESGROUP:EndInit
 22531 00002D25 BA[1A02]                	mov	dx,Pipe1	; Clean up in case ^C
 22532                                  	;mov	ah,Unlink ; 41h 
 22533 00002D28 B441                    	mov	ah,41h
 22534 00002D2A CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22535                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 22536                                  			;		(no wildcards allowed)
 22537                                  
 22538                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
 22539                                  			; Pipe2 = offset RESGROUP:EndInit+79
 22540 00002D2C BA[6902]                	mov	dx,Pipe2
 22541                                  	;mov	ah,Unlink ; 41h
 22542 00002D2F B441                    	mov	ah,41h
 22543 00002D31 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22544                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 22545                                  			;		(no wildcards allowed)
 22546 00002D33 5A                      	pop	dx
 22547 00002D34 E86E02                  	call	PipeOff
 22548 00002D37 C606[1902]00            	mov	byte [PipeFiles],0
 22549 00002D3C 1F                      	pop	ds
 22550 00002D3D C3                      	retn
 22551                                  
 22552                                  ; ---------------------------------------------------------------------------
 22553                                  
 22554                                  	; 26/02/2023
 22555                                  PIPEERRSYN:
 22556 00002D3E BA[0D80]                	mov	dx,SYNTMES_PTR
 22557 00002D41 E8DAFF                  	call	PIPEDEL
 22558 00002D44 0E                      	push	cs
 22559 00002D45 1F                      	pop	ds
 22560 00002D46 E931FC                  	jmp	cerror
 22561                                  
 22562                                  ; ---------------------------------------------------------------------------
 22563                                  
 22564                                  	; 26/02/2023
 22565                                  PIPERR:
 22566 00002D49 9C                      	pushf
 22567 00002D4A E85EFF                  	call    TriageError
 22568                                  	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
 22569 00002D4D 50                      	push	ax		; Save results from TriageError
 22570 00002D4E 52                      	push	dx
 22571 00002D4F BA[D680]                	mov	dx,PIPEEMES_PTR
 22572 00002D52 E8C9FF                  	call	PIPEDEL
 22573 00002D55 0E                      	push	cs
 22574 00002D56 1F                      	pop	ds
 22575 00002D57 E8E120                  	call	std_eprintf
 22576 00002D5A 5A                      	pop	dx		; Restore results from TriageError
 22577 00002D5B 58                      	pop	ax
 22578 00002D5C 9D                      	popf
 22579 00002D5D 83F841                  	cmp	ax,65
 22580 00002D60 7503                    	jne	short TCOMMANDJ
 22581 00002D62 E915FC                  	jmp	cerror
 22582                                  
 22583                                  TCOMMANDJ:
 22584 00002D65 E99CD3                  	jmp	TCOMMAND
 22585                                  
 22586                                  ; ---------------------------------------------------------------------------
 22587                                  
 22588                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22589                                  PIPEPROCSTRT:
 22590 00002D68 8E1E[E08A]              	mov	ds,[RESSEG]
 22591 00002D6C FE06[1902]              	inc	byte [PipeFiles] ; Flag that the pipe files exist
 22592                                  
 22593                                  	; MSDOS 6.0
 22594 00002D70 06                      	push	es
 22595 00002D71 57                      	push	di
 22596 00002D72 1E                      	push	ds
 22597 00002D73 56                      	push	si
 22598                                  	
 22599 00002D74 1E                      	push	ds
 22600 00002D75 06                      	push	es
 22601 00002D76 1F                      	pop	ds			;ds = TRANGROUP
 22602 00002D77 BE[2586]                	mov	si,TempVarName		;ds:si = "TEMP="
 22603                                  
 22604                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
 22605                                  ;so the routine is not really general
 22606                                  
 22607 00002D7A E8BDF5                  	call	find_name_in_environment
 22608                                  					;es:di points at path
 22609 00002D7D 1F                      	pop	ds			;ds = DATARES again
 22610 00002D7E 721F                    	jc	short no_temp_path
 22611                                  	
 22612 00002D80 1E                      	push	ds
 22613 00002D81 06                      	push	es
 22614 00002D82 1F                      	pop	ds
 22615 00002D83 07                      	pop	es			;swap ds and es
 22616 00002D84 89FE                    	mov	si,di			;ds:si points at path
 22617                                  	
 22618 00002D86 E8B602                  	call	skip_white		;skip white space chars
 22619                                  
 22620                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
 22621                                  
 22622 00002D89 E8BF02                  	call	copy_pipe_path		;copy the pipe path
 22623                                  	
 22624                                  ;Check if the TEMP path is valid
 22625                                  
 22626 00002D8C 06                      	push	es
 22627 00002D8D 1F                      	pop	ds			;ds = DATARES
 22628                                  	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
 22629                                  	;mov	dx,320h ; MSDOS 5.0 - offset EndInit
 22630 00002D8E BA[1A02]                	mov	dx,Pipe1
 22631                                  	;mov	ax,(CHMOD shl 8) or 0
 22632 00002D91 B80043                  	mov	ax,4300h
 22633 00002D94 CD21                    	int	21h
 22634 00002D96 7207                    	jc	short no_temp_path
 22635                                  	
 22636 00002D98 F7C11000                	test	cx,10h			;is it a directory?
 22637 00002D9C 7501                    	jnz	short no_temp_path	;yes, continue (carry clear)
 22638                                  	
 22639 00002D9E F9                      	stc				;no, indicate fail
 22640                                  no_temp_path:
 22641 00002D9F 5E                      	pop	si
 22642 00002DA0 1F                      	pop	ds
 22643 00002DA1 5F                      	pop	di
 22644 00002DA2 07                      	pop	es
 22645 00002DA3 730B                    	jnc	short crt_temp		;path found, create tempfiles
 22646                                  
 22647                                  	; 27/02/2023
 22648                                  	; MSDOS 3.3
 22649                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 22650                                  	;				; Get current drive
 22651                                  	;int	21h ; DOS - GET DEFAULT DISK NUMBER
 22652                                  	;add	al,[cs:CAPITAL_A]
 22653                                  	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
 22654                                  	;mov	bx,PIPE1
 22655                                  	;mov	[bx],al
 22656                                  	;xor	ah,ah			; nul terminate path names
 22657                                  	;mov	byte [PIPE1+3],ah
 22658                                  	;mov	byte [PIPE2+3],ah
 22659                                  
 22660                                  	; MSDOS 6.0
 22661                                  ;SR;
 22662                                  ; We want to create temp files in the current directory rather than in the 
 22663                                  ;root of the drive. This is because the number of files that can be present
 22664                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
 22665                                  
 22666                                  	;mov	ah,'.'
 22667                                  	;mov	[Pipe1],ah	; = RESGROUP:EndInit
 22668                                  	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
 22669                                  	;xor	ah,ah
 22670                                  	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
 22671                                  	;mov	[Pipe2+1],ah		;create files in current dir
 22672                                  	; 27/02/2023
 22673 00002DA5 B92E00                  	mov	cx,002Eh
 22674 00002DA8 890E[1A02]              	mov	[Pipe1],cx
 22675 00002DAC 890E[6902]              	mov	[Pipe2],cx
 22676                                  crt_temp:
 22677                                  	; MSDOS 6.0
 22678                                  	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
 22679                                  	;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
 22680 00002DB0 BA[1A02]                	mov	dx,Pipe1
 22681                                  	; MSDOS 3.3
 22682                                  	;mov	dx,bx
 22683                                  	
 22684                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22685 00002DB3 31C9                    	xor	cx,cx
 22686                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 22687 00002DB5 B45A                    	mov	ah,5Ah
 22688 00002DB7 CD21                    	int	21h
 22689                                  		; DOS -	3+ - CREATE UNIQUE FILE
 22690                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 22691                                  		; receive generated filename
 22692                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 22693 00002DB9 728E                    	jc	short PIPERR	; Couldn't create
 22694                                  
 22695 00002DBB 89C3                    	mov	bx,ax
 22696                                  	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 22697 00002DBD B43E                    	mov	ah,3Eh
 22698 00002DBF CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 22699                                  			; BX = file handle
 22700                                  	;;mov	dx,PIPE2
 22701                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
 22702 00002DC1 BA[6902]                	mov	dx,Pipe2
 22703                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 22704 00002DC4 B45A                    	mov	ah,5Ah
 22705 00002DC6 CD21                    	int	21h
 22706                                  		; DOS -	3+ - CREATE UNIQUE FILE
 22707                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 22708                                  		; receive generated filename
 22709                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 22710                                  	; 17/04/2023
 22711                                  	;jc	short PIPERR
 22712                                  	; 27/02/2023
 22713 00002DC8 7303                    	jnc	short pps1
 22714 00002DCA E97CFF                  	jmp	PIPERR
 22715                                  pps1:
 22716 00002DCD 89C3                    	mov	bx,ax
 22717 00002DCF B43E                    	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 22718 00002DD1 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 22719                                  				; BX = file handle
 22720                                  	;call	near ptr TESTDOREIN ; Set up a redirection if specified
 22721 00002DD3 E87FFE                  	call	TESTDOREIN
 22722 00002DD6 8B36[B802]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 22723 00002DDA 833E[A601]FF            	cmp	word [SingleCom],-1
 22724 00002DDF 7506                    	jne	short NOSINGP
 22725 00002DE1 C706[A601]00F0          	mov	word [SingleCom],0F000h ; Flag single command pipe
 22726                                  NOSINGP:
 22727 00002DE7 EB29                    	jmp	short FIRSTPIPE
 22728                                  
 22729                                  ; ---------------------------------------------------------------------------
 22730                                  
 22731                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22732                                  PIPEPROC:
 22733 00002DE9 8026[A001]FE            	and	byte [EchoFlag],0FEh  ; force current echo to be off
 22734 00002DEE 8B36[B802]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 22735 00002DF2 AC                      	lodsb
 22736                                  	; 27/02/2023
 22737 00002DF3 3C7C                    	cmp	al,'|'		
 22738                                  	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
 22739                                  	;je	short ISPIPE1	; Yes
 22740                                  	;cmp	al,'|'
 22741                                  	;;cmp	al,[cs:VBAR]
 22742 00002DF5 7403                    	je	short ISPIPE1
 22743 00002DF7 E98400                  	jmp	PIPEEND		; Pipe done
 22744                                  ISPIPE1:
 22745 00002DFA 8B16[3B03]              	mov	dx,[InPipePtr]	; Get the input file name
 22746                                  	;mov	ax,OPEN*256 ; 3D00h
 22747 00002DFE B8003D                  	mov	ax,3D00h
 22748 00002E01 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22749                                  			; DS:DX	-> ASCIZ filename
 22750                                  			; AL = access mode
 22751                                  			; 0 - read
 22752                                  PIPEERRJ:
 22753 00002E03 7303                    	jnc	short NO_PIPEERR
 22754 00002E05 E941FF                  	jmp	PIPERR		; Lost the pipe file
 22755                                  NO_PIPEERR:
 22756 00002E08 89C3                    	mov	bx,ax
 22757 00002E0A B0FF                    	mov	al,0FFh
 22758                                  	;xchg	al,[bx+18h]
 22759 00002E0C 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22760 00002E0F A21800                  	mov	[PDB.JFN_TABLE],al	; Redirect
 22761                                  FIRSTPIPE:
 22762 00002E12 BF[4189]                	mov	di,COMBUF+2
 22763 00002E15 31C9                    	xor	cx,cx
 22764 00002E17 803C0D                  	cmp	byte [si],0Dh	; '|<CR>'
 22765 00002E1A 7503                    	jne	short PIPEOK1
 22766                                  PIPEERRSYNJ:
 22767 00002E1C E91FFF                  	jmp	PIPEERRSYN
 22768                                  PIPEOK1:
 22769                                  	;;;mov	al,[cs:VBAR]
 22770                                  	; 27/02/2023
 22771                                  	;;mov	al,vbar
 22772                                  	;mov	al,'|'
 22773                                  	;cmp	[si],al		; '||'
 22774                                  	;je	short PIPEERRSYNJ
 22775 00002E1F 803C7C                  	cmp	byte [si],'|'
 22776                                  	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
 22777 00002E22 74F8                    	je	short PIPEERRSYNJ
 22778                                  PIPECOMLP:
 22779 00002E24 AC                      	lodsb
 22780 00002E25 AA                      	stosb
 22781                                  	; 27/02/2023
 22782 00002E26 E8BBF5                  	call	testkanj
 22783 00002E29 7405                    	jz	short NOTKANJ5
 22784 00002E2B A4                      	movsb
 22785                                  ;  Added following 2 commands to the fix pipe bug.
 22786 00002E2C 41                      	inc	cx		;AN000;  3/3/KK
 22787 00002E2D 41                      	inc	cx		;AN000;  3/3/KK
 22788 00002E2E EBF4                    	jmp	short PIPECOMLP
 22789                                  NOTKANJ5:
 22790 00002E30 3C0D                    	cmp	al,0Dh
 22791 00002E32 7438                    	je	short LASTPIPE
 22792 00002E34 41                      	inc	cx
 22793                                  	; 27/02/2023
 22794 00002E35 3C7C                    	cmp	al,'|'
 22795                                  	;cmp	al,ALTPIPECHR
 22796                                  	;je	short ISPIPE2
 22797                                  	;;cmp	al,[cs:VBAR]
 22798                                  	;cmp	al,vbar
 22799 00002E37 75EB                    	jne	short PIPECOMLP
 22800                                  ISPIPE2:
 22801 00002E39 26C645FF0D              	mov	byte [es:di-1],0Dh
 22802 00002E3E 49                      	dec	cx
 22803                                  	;mov	[cs:COMBUF+1],cl
 22804                                  	; 27/02/2023
 22805 00002E3F 26880E[4089]            	mov	[es:COMBUF+1],cl
 22806 00002E44 4E                      	dec	si
 22807                                  	;mov	[3BEh],si ;  MSDOS 5.0 COMMAND.COM
 22808 00002E45 8936[B802]              	mov	[PipePtr],si		; On to next pipe element
 22809                                  			; mov [EndInit+158], si
 22810 00002E49 8B16[3D03]              	mov	dx,[OutPipePtr]
 22811 00002E4D 51                      	push	cx
 22812 00002E4E 31C9                    	xor	cx,cx
 22813                                  	;mov	ax,CREAT*256 ; 3C00h
 22814 00002E50 B8003C                  	mov	ax,3C00h
 22815 00002E53 CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 22816                                  			; CX = attributes for file
 22817                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 22818 00002E55 59                      	pop	cx
 22819 00002E56 72AB                    	jc	short PIPEERRJ		; Lost the file
 22820 00002E58 89C3                    	mov	bx,ax
 22821 00002E5A B0FF                    	mov	al,0FFh
 22822                                  	;xchg	al,[bx+18h]
 22823 00002E5C 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22824 00002E5F A21900                  	mov	[PDB.JFN_TABLE+1],al
 22825 00002E62 8716[3B03]              	xchg	dx,[InPipePtr]	; Swap for next element of pipe
 22826 00002E66 8916[3D03]              	mov	[OutPipePtr],dx
 22827 00002E6A EB0D                    	jmp	short PIPECOM
 22828                                  LASTPIPE:
 22829                                  	;mov	[cs:COMBUF+1],cl 
 22830                                  	; 27/02/2023
 22831 00002E6C 26880E[4089]            	mov	[es:COMBUF+1],cl
 22832 00002E71 4E                      	dec	si
 22833                                  	;mov	[3BEh],si ;  MSDOS 5.0 COMMAND.COM
 22834 00002E72 8936[B802]              	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
 22835                                  		; mov [EndInit+158], si
 22836 00002E76 E857FD                  	call	TESTDOREOUT	; Set up the redirection if specified
 22837                                  PIPECOM:
 22838 00002E79 0E                      	push	cs
 22839 00002E7A 1F                      	pop	ds
 22840 00002E7B E964D4                  	jmp	NOPIPEPROC	; Process the pipe element
 22841                                  PIPEEND:
 22842 00002E7E E89DFE                  	call	PIPEDEL
 22843 00002E81 813E[A601]00F0          	cmp	word [SingleCom],0F000h
 22844 00002E87 7506                    	jnz	short NOSINGP2
 22845 00002E89 C706[A601]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
 22846                                  NOSINGP2:
 22847 00002E8F E972D2                  	jmp	TCOMMAND
 22848                                  
 22849                                  ; =============== S U B	R O U T	I N E =======================================
 22850                                  
 22851                                  ; Date and time are set during initialization and use
 22852                                  ; this routines since they need to do a long return
 22853                                  
 22854                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22855                                  DATINIT:
 22856 00002E92 2E8C1E[E08A]            	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 22857 00002E97 06                      	push	es
 22858 00002E98 1E                      	push	ds		; Going to use the previous stack
 22859 00002E99 8CC8                    	mov	ax,cs		; Set up the appropriate segment registers
 22860 00002E9B 8EC0                    	mov	es,ax
 22861 00002E9D 8ED8                    	mov	ds,ax
 22862 00002E9F E88220                  	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 22863 00002EA2 BA[BE95]                	mov	dx,INTERNATVARS
 22864 00002EA5 B80038                  	mov	ax,3800h
 22865                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
 22866 00002EA8 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 22867                                  			; get current-country info
 22868                                  			; DS:DX	-> buffer for returned info
 22869                                  	; 20/10/2018
 22870 00002EAA C70681000D00            	mov	word [81h],0Dh ; Want to prompt for date during initialization
 22871 00002EB0 C606[3F89]80            	mov	byte [COMBUF],128 ; Init COMBUF
 22872 00002EB5 C706[4089]010D          	mov	word [COMBUF+1],0D01h
 22873 00002EBB E80600                  	call	DATE
 22874 00002EBE E86800                  	call	CTIME
 22875 00002EC1 1F                      	pop	ds
 22876 00002EC2 07                      	pop	es
 22877 00002EC3 CB                      	retf	; far return
 22878                                  
 22879                                  ; =============== S U B	R O U T	I N E =======================================
 22880                                  
 22881                                  ; MSDOS 6.0
 22882                                  
 22883                                  ; ****************************************************************
 22884                                  ; *
 22885                                  ; * ROUTINE:	 DATE - Set system date
 22886                                  ; *
 22887                                  ; * FUNCTION:	 If a date is specified, set the system date,
 22888                                  ; *		 otherwise display the current system date and
 22889                                  ; *		 prompt the user for a new date.  If an invalid
 22890                                  ; *		 date is specified, issue an error message and
 22891                                  ; *		 prompt for a new date.  If the user enters
 22892                                  ; *		 nothing when prompted for a date, terminate.
 22893                                  ; *
 22894                                  ; * INPUT:	 command line at offset 81H
 22895                                  ; *
 22896                                  ; * OUTPUT:	 none
 22897                                  ; *
 22898                                  ; ****************************************************************
 22899                                  
 22900                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22901                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
 22902                                  DATE:
 22903 00002EC4 BE8100                  	mov	si,81h			; Accepting argument for date inline
 22904 00002EC7 BF[2B85]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 22905 00002ECA 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 22906 00002ECC 31D2                    	xor	dx,dx			;AN000;
 22907 00002ECE E89F14                  	call	cmd_parse		;AC000; call parser
 22908                                  	; 27/02/2023
 22909 00002ED1 83F8FF                  	cmp	ax,-1
 22910                                  	;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 22911 00002ED4 7429                    	je	short PRMTDAT 		;AC000; yes - go ask for date
 22912                                  	;cmp	ax,0
 22913                                  	;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 22914                                  	;jne	short DATERR		;AN000; yes - go issue message
 22915                                  	; 26/04/2023
 22916 00002ED6 09C0                    	or	ax,ax ; ax = 0 ?
 22917 00002ED8 7544                    	jnz	short DATERR
 22918                                  	;jmp	short COMDAT		;AC000; we have a date
 22919                                  	; 27/02/2023
 22920                                  COMDAT:
 22921 00002EDA 8B0E[1B96]              	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
 22922 00002EDE 8A36[1D96]              	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
 22923 00002EE2 8A16[1E96]              	mov	dl,[DATE_DAY]		;AC000;  date function call.
 22924 00002EE6 51                      	push	cx			;AC000; save date
 22925 00002EE7 52                      	push	dx			;AC000;
 22926 00002EE8 B90100                  	mov	cx,1			;AC000; set 1 positional entered
 22927 00002EEB 31D2                    	xor	dx,dx			;AN029;
 22928 00002EED E88014                  	call	cmd_parse		;AN029; call parser
 22929 00002EF0 3CFF                    	cmp	al,0FFh ; -1
 22930                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 22931 00002EF2 5A                      	pop	dx			;AC000; retrieve date
 22932 00002EF3 59                      	pop	cx			;AC000;
 22933 00002EF4 7528                    	jnz	short DATERR		;AC000; extra stuff on line - try again
 22934                                  	; 26/04/2023
 22935                                  	;mov	ah,SET_DATE		;yes - set date
 22936 00002EF6 B42B                    	mov	ah,2Bh
 22937 00002EF8 CD21                    	int	21h
 22938                                  			; DOS - SET CURRENT DATE
 22939                                  			; DL = day, DH = month, CX = year
 22940                                  			; Return: AL = 00h if no error /= FFh if bad value sent to routine
 22941 00002EFA 08C0                    	or	al,al
 22942 00002EFC 7520                    	jnz	short DATERR
 22943                                  date_end:
 22944 00002EFE C3                      	retn
 22945                                  
 22946                                  PRMTDAT:
 22947                                  	; Print "Current date is
 22948                                  
 22949 00002EFF E83208                  	call	GetDate 		;AN000; get date for output
 22950 00002F02 86F2                    	xchg	dh,dl			;AN000; switch month & day
 22951 00002F04 890E[2380]              	mov	[CurDat_yr],cx		;AC000; put year into message control block
 22952 00002F08 8916[2580]              	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
 22953 00002F0C BA[1380]                	mov	dx,CurDat_Ptr		;AC000; set up message for output
 22954 00002F0F E8311F                  	call	std_printf
 22955                                  
 22956                                  ;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
 22957                                  ;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block
 22958                                  
 22959                                  GET_NEW_DATE:				;AN000;
 22960 00002F12 E8C500                  	call	GETDAT			;AC000; prompt user for date
 22961 00002F15 83F8FF                  	cmp	ax,0FFFFh ; -1
 22962                                  	;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 22963 00002F18 74E4                    	je	short date_end		;AC000; yes - exit
 22964                                  	; 26/04/2023
 22965                                  	;cmp	ax,0
 22966                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 22967                                  	;;jnz	short DATERR		;AN000; yes - go issue message
 22968                                  	;; 27/02/2023
 22969                                  	;jz	short COMDAT
 22970                                  	; 26/04/2023
 22971 00002F1A 21C0                    	and	ax,ax ; 0 ?
 22972 00002F1C 74BC                    	jz	short COMDAT
 22973                                  ;COMDAT:
 22974                                  ;	....
 22975                                  DATERR:
 22976 00002F1E E8D8F6                  	call	CRLF2			;AN028; print out a blank line
 22977 00002F21 BA[1080]                	mov	dx,BADDAT_PTR
 22978 00002F24 E81C1F                  	call	std_printf
 22979 00002F27 EBE9                    	jmp	short GET_NEW_DATE	;AC000; get date again
 22980                                  
 22981                                  ; =============== S U B	R O U T	I N E =======================================
 22982                                  
 22983                                  ; MSDOS 6.0
 22984                                  
 22985                                  ; TIME gets and sets the time
 22986                                  
 22987                                  ; ****************************************************************
 22988                                  ; *
 22989                                  ; * ROUTINE:	 TIME - Set system time
 22990                                  ; *
 22991                                  ; * FUNCTION:	 If a time is specified, set the system time,
 22992                                  ; *		 otherwise display the current system time and
 22993                                  ; *		 prompt the user for a new time.  If an invalid
 22994                                  ; *		 time is specified, issue an error message and
 22995                                  ; *		 prompt for a new time.  If the user enters
 22996                                  ; *		 nothing when prompted for a time, terminate.
 22997                                  ; *
 22998                                  ; * INPUT:	 command line at offset 81H
 22999                                  ; *
 23000                                  ; * OUTPUT:	 none
 23001                                  ; *
 23002                                  ; ****************************************************************
 23003                                  
 23004                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23005                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
 23006                                  CTIME:
 23007 00002F29 BE8100                  	mov	si,81h			; Accepting argument for time inline
 23008 00002F2C BF[3D85]                	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
 23009 00002F2F 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23010 00002F31 31D2                    	xor	dx,dx			;AN000;
 23011 00002F33 E83A14                  	call	cmd_parse		;AC000; call parser
 23012                                  	; 27/02/2023
 23013 00002F36 83F8FF                  	cmp	ax,-1
 23014                                  	;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23015 00002F39 742D                    	je	short PRMTTIM 		;AC000; yes - prompt for time
 23016                                  	;cmp	ax,0
 23017                                  	;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23018                                  	;jne	short TIMERR		;AN000; yes - go issue message
 23019 00002F3B 21C0                    	and	ax,ax ; ax = 0 ?
 23020 00002F3D 754B                    	jnz	short TIMERR
 23021                                  	;jmp	short COMTIM		;AC000; we have a time
 23022                                  	; 27/02/2023
 23023                                  COMTIM:
 23024 00002F3F 8A2E[2396]              	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
 23025 00002F43 8A0E[2496]              	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
 23026 00002F47 8A36[2596]              	mov	dh,[TIME_SECONDS]	;AC000;  time function call
 23027 00002F4B 8A16[2696]              	mov	dl,[TIME_FRACTION]	;AC000;
 23028 00002F4F 51                      	push	cx			;AC000; save time
 23029 00002F50 52                      	push	dx			;AC000;
 23030 00002F51 B90100                  	mov	cx,1			;AC000; set 1 positional parm entered
 23031 00002F54 31D2                    	xor	dx,dx			;AN029;
 23032 00002F56 E81714                  	call	cmd_parse		;AN029; call parser
 23033 00002F59 3CFF                    	cmp	al, -1
 23034                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23035 00002F5B 5A                      	pop	dx			;AC000; retieve time
 23036 00002F5C 59                      	pop	cx			;AC000;
 23037 00002F5D 752B                    	jnz	short TIMERR		;AC000; extra stuff on line - try again
 23038                                  SAVTIM:
 23039                                  	;mov	ah,SET_TIME
 23040 00002F5F B42D                    	mov	ah,2Dh
 23041 00002F61 CD21                    	int	21h
 23042 00002F63 08C0                    	or	al,al
 23043 00002F65 7523                    	jnz	short TIMERR		;AC000; if an error occured, try again
 23044                                  time_end:
 23045 00002F67 C3                      	retn
 23046                                  
 23047                                  PRMTTIM:
 23048                                  	;Printf "Current time is ... "
 23049                                  
 23050                                  	;mov	ah,Get_Time		;AC000; get the current time
 23051 00002F68 B42C                    	mov	ah,2Ch
 23052 00002F6A CD21                    	int	21h			;AC000;   Get time in CX:DX
 23053 00002F6C 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23054 00002F6E 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23055 00002F70 890E[4580]              	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23056 00002F74 8916[4780]              	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23057 00002F78 BA[4080]                	mov	dx,CurTim_Ptr		;AC000; set up message for output
 23058 00002F7B E8C51E                  	call	std_printf
 23059                                  
 23060                                  ;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
 23061                                  ;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block
 23062                                  
 23063                                  GET_NEW_TIME:
 23064 00002F7E E8B100                  	call	GETTIM			;AC000;
 23065 00002F81 83F8FF                  	cmp	ax,-1
 23066                                  	;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23067 00002F84 74E1                    	je	short time_end		;AC000;
 23068                                  	;cmp	ax,0
 23069                                  	;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23070                                  	;jne	short TIMERR		;AN000; yes - go issue message
 23071 00002F86 09C0                    	or	ax,ax  ; ax = 0 ?
 23072                                  	;jnz	short TIMERR
 23073                                  	; 27/02/2023
 23074 00002F88 74B5                    	jz	short COMTIM
 23075                                  ;COMTIM:
 23076                                  ;	....
 23077                                  TIMERR:
 23078 00002F8A E86CF6                  	call	CRLF2			;AN028; print out a blank line
 23079 00002F8D BA[3D80]                	mov	dx,BadTim_Ptr
 23080 00002F90 E8B01E                  	call	std_printf		; Print error message
 23081 00002F93 EBE9                    	jmp	short GET_NEW_TIME	;AC000; Try again
 23082                                  
 23083                                  ; =============== S U B	R O U T	I N E =======================================
 23084                                  
 23085                                  ; MSDOS 6.0
 23086                                  
 23087                                  ; Set the special flag in the INIT flag to the value in CX.
 23088                                  
 23089                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23090                                  SetInitFlag:
 23091 00002F95 8E1E[E08A]              	mov	ds,[RESSEG]
 23092                                  
 23093 00002F99 8026[1702]FD            	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
 23094                                  	;and	byte [InitFlag],0FDh
 23095 00002F9E 080E[1702]              	or	byte [InitFlag],cl
 23096 00002FA2 0E                      	push	cs
 23097 00002FA3 1F                      	pop	ds
 23098 00002FA4 C3                      	retn
 23099                                  
 23100                                  ; =============== S U B	R O U T	I N E =======================================
 23101                                  
 23102                                  ; MSDOS 6.0
 23103                                  
 23104                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23105                                  PipeOff:
 23106 00002FA5 1E                      	push	ds
 23107 00002FA6 50                      	push	ax
 23108 00002FA7 2E8E1E[E08A]            	mov	ds,[cs:RESSEG]
 23109 00002FAC 30C0                    	xor	al,al
 23110 00002FAE 8606[1802]              	xchg	[PipeFlag],al
 23111 00002FB2 08C0                    	or	al,al
 23112 00002FB4 7404                    	jz	short PipeOffDone
 23113 00002FB6 D02E[A001]              	shr	byte [EchoFlag],1
 23114                                  PipeOffDone:
 23115 00002FBA 58                      	pop	ax
 23116 00002FBB 1F                      	pop	ds
 23117 00002FBC C3                      	retn
 23118                                  
 23119                                  ; =============== S U B	R O U T	I N E =======================================
 23120                                  
 23121                                  ; MSDOS 6.0
 23122                                  
 23123                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23124                                  PRINT_TIME:
 23125                                  	;mov	ah,Get_Time
 23126 00002FBD B42C                    	mov	ah,2Ch
 23127 00002FBF CD21                    	int	21h			; Get time in CX:DX
 23128                                  
 23129 00002FC1 06                      	push	es
 23130 00002FC2 0E                      	push	cs
 23131 00002FC3 07                      	pop	es
 23132 00002FC4 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23133 00002FC6 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23134 00002FC8 2E890E[7E81]            	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23135 00002FCD 2E8916[8081]            	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23136 00002FD2 BA[7981]                	mov	dx,promtim_ptr		;AC000; set up message for output
 23137 00002FD5 E86B1E                  	call	std_printf
 23138                                  
 23139                                  ;AD061; mov	word [cs:PromTim_hr_min],0
 23140                                  					;AC000; reset hour, minutes, seconds, and hundredths
 23141                                  ;AD061; mov	word [cs:PromTim_Sec_hn],0
 23142                                  					;AC000;  pointers in control block
 23143 00002FD8 07                      	pop	es
 23144 00002FD9 C3                      	retn
 23145                                  
 23146                                  ; =============== S U B	R O U T	I N E =======================================
 23147                                  
 23148                                  ; MSDOS 6.0
 23149                                  
 23150                                  ; ****************************************************************
 23151                                  ; *
 23152                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 23153                                  ; *
 23154                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 23155                                  ; *		 INFORMATION and issues the "Enter new date"
 23156                                  ; *		 message with the proper date format. COMBUF
 23157                                  ; *		 is reset to get a date from the command line.
 23158                                  ; *		 The PARSE_DATE blocks are then reset and the
 23159                                  ; *		 PARSE function call is issued.
 23160                                  ; *
 23161                                  ; * INPUT:	 NONE
 23162                                  ; *
 23163                                  ; * OUTPUT:	 COMBUF
 23164                                  ; *		 PARSER RETURN CODES
 23165                                  ; *
 23166                                  ; ****************************************************************
 23167                                  
 23168                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23169                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
 23170                                  GETDAT:
 23171                                  	;mov	ax,(International SHL 8)
 23172 00002FDA B80038                  	mov	ax,3800h
 23173                                  					; Determine what format the date
 23174 00002FDD BA5C00                  	mov	dx,5Ch			;  should be entered in and
 23175 00002FE0 CD21                    	int	21h			;  print a message describing it
 23176                                  			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 23177                                  			; get current-country info
 23178                                  			; DS:DX -> buffer for returned info
 23179 00002FE2 89D6                    	mov	si,dx
 23180 00002FE4 AD                      	lodsw
 23181 00002FE5 2E8B16[5781]            	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
 23182 00002FEA 48                      	dec	ax
 23183 00002FEB 780C                    	js	short printformat
 23184 00002FED 2E8B16[5A81]            	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
 23185 00002FF2 7405                    	jz	short printformat
 23186 00002FF4 2E8B16[5D81]            	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
 23187                                  printformat:
 23188 00002FF9 89D0                    	mov	ax,dx			;AN000; get message number of format
 23189                                  	;mov	dh,util_msg_class	;AN000; this is a utility message
 23190 00002FFB B6FF                    	mov	dh,-1 ; 0FFh
 23191 00002FFD E82A1F                  	call	TSYSGETMSG		;AN000; get the address of the message
 23192 00003000 2E8936[3480]            	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
 23193 00003005 BA[2F80]                	mov	dx,NewDat_Ptr		;AC000; get address of message to print
 23194 00003008 E8381E                  	call	std_printf
 23195                                  	;mov	word [cs:NewDat_Format],no_subst
 23196                                  					;AN000; reset subst block
 23197 0000300B 2EC706[3480]0000        	mov	word [cs:NewDat_Format],0
 23198                                  
 23199                                  	; 28/02/2023
 23200 00003012 BF[2B85]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23201                                  ; 28/02/2023
 23202                                  gettim_p:	
 23203                                  	;mov	ah,Std_Con_String_Input
 23204 00003015 B40A                    	mov	ah,0Ah
 23205 00003017 BA[3F89]                	mov	dx,COMBUF
 23206 0000301A B90200                  	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23207 0000301D E875FF                  	call	SetInitFlag		;  prompting for date.
 23208 00003020 CD21                    	int	21h			; Get input line
 23209 00003022 31C9                    	xor	cx,cx			; Reset bit in InitFlag that indicates
 23210 00003024 E86EFF                  	call	SetInitFlag		;  prompting for date.
 23211 00003027 E8CFF5                  	call	CRLF2
 23212                                  	; 28/02/2023
 23213                                  	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23214                                  ;gettim_p: ; 28/02/2023
 23215 0000302A BE[4189]                	mov	si,COMBUF+2
 23216                                  	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
 23217 0000302D 31D2                    	xor	dx,dx			;AN000;
 23218                                  	;call	cmd_parse		;AC000; call parser
 23219                                  	;retn
 23220                                  	; 28/02/2023
 23221 0000302F E93E13                  	jmp	cmd_parse
 23222                                  
 23223                                  ; =============== S U B	R O U T	I N E =======================================
 23224                                  
 23225                                  ; MSDOS 6.0
 23226                                  
 23227                                  ; ****************************************************************
 23228                                  ; *
 23229                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 23230                                  ; *
 23231                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 23232                                  ; *		 INFORMATION and issues the "Enter new time"
 23233                                  ; *		 message. COMBUF is reset to get a time from the
 23234                                  ; *		 command line. The PARSE_TIME blocks are then
 23235                                  ; *		 reset and the PARSE function call is issued.
 23236                                  ; *
 23237                                  ; * INPUT:	 NONE
 23238                                  ; *
 23239                                  ; * OUTPUT:	 COMBUF
 23240                                  ; *		 PARSER RETURN CODES
 23241                                  ; *
 23242                                  ; ****************************************************************
 23243                                  
 23244                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23245                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
 23246                                  GETTIM:
 23247 00003032 31C9                    	xor	cx,cx			; Initialize hours and minutes to zero
 23248 00003034 BA[4E80]                	mov	dx,NewTim_Ptr
 23249 00003037 E8091E                  	call	std_printf
 23250                                  
 23251                                  	; 28/02/2023
 23252 0000303A BF[3D85]                	mov	di,PARSE_TIME
 23253 0000303D EBD6                    	jmp	short gettim_p
 23254                                  
 23255                                  ; 28/02/2023
 23256                                  ;	;mov	ah,Std_Con_String_Input
 23257                                  ;	mov	ah,0Ah
 23258                                  ;	mov	dx,COMBUF
 23259                                  ;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23260                                  ;	call	SetInitFlag		;  prompting for time.
 23261                                  ;	int	21h			; Get input line
 23262                                  ;	; 28/02/2023
 23263                                  ;	xor	cx,cx			; Reset bit in InitFlag that indicates
 23264                                  ;	call	SetInitFlag		;  prompting for time.
 23265                                  ;	call	CRLF2
 23266                                  ;	; 28/02/2023
 23267                                  ;	;mov	si,COMBUF+2
 23268                                  ;	; 28/02/2023
 23269                                  ;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
 23270                                  ;	; 28/02/2023
 23271                                  ;	jmp	short gettim_p	
 23272                                  ;	; 28/02/2023
 23273                                  ;	;;xor	cx,cx			;AN000; clear counter for positionals
 23274                                  ;	;xor	dx,dx			;AN000;
 23275                                  ;	;call	cmd_parse		;AC000; call parser
 23276                                  ;	;retn
 23277                                  
 23278                                  
 23279                                  ; =============== S U B	R O U T	I N E =======================================
 23280                                  
 23281                                  ; MSDOS 6.0
 23282                                  
 23283                                  ;Skip_white: Skips over the whitespace chars that could be present after
 23284                                  ;the '=' sign in the environment variable before the actual path.
 23285                                  ;
 23286                                  ;	ENTRY:	ds:si = arguments of the environment variable
 23287                                  ;
 23288                                  ;	EXIT:	ds:si = start of the path
 23289                                  ;
 23290                                  ;	REGISTERS AFFECTED: ax
 23291                                  
 23292                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23293                                  skip_white:
 23294 0000303F FC                      	cld
 23295                                  skw_lp:
 23296 00003040 AC                      	lodsb
 23297 00003041 3C20                    	cmp	al,' '			;blank char?
 23298 00003043 74FB                    	jz	short skw_lp		;yes, skip it
 23299 00003045 3C09                    	cmp	al,9			;tab char?
 23300 00003047 74F7                    	jz	short skw_lp		;yes, skip it
 23301 00003049 4E                      	dec	si			;point at first non-white
 23302 0000304A C3                      	retn
 23303                                  
 23304                                  ; =============== S U B	R O U T	I N E =======================================
 23305                                  
 23306                                  ; MSDOS 6.0
 23307                                  
 23308                                  ;Copy_pipe_path: This routine copies the path from the TEMP environment
 23309                                  ;variable into the path buffers Pipe1 & Pipe2.
 23310                                  ;
 23311                                  ;	ENTRY:	ds:si = path to be copied
 23312                                  ;		es = RESGROUP
 23313                                  ;
 23314                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 23315                                  ;
 23316                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 23317                                  
 23318                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23319                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h
 23320                                  
 23321                                  copy_pipe_path:
 23322 0000304B B9FFFF                  	mov	cx,0FFFFh ; 65535
 23323 0000304E 30C0                    	xor	al,al
 23324                                  
 23325 00003050 89F7                    	mov	di,si
 23326 00003052 06                      	push	es			;save es
 23327 00003053 1E                      	push	ds
 23328 00003054 07                      	pop	es			;es:di = path to be copied
 23329                                  	
 23330 00003055 FC                      	cld
 23331 00003056 57                      	push	di
 23332 00003057 F2AE                    	repnz	scasb			;look for the null char
 23333 00003059 5F                      	pop	di
 23334                                  
 23335 0000305A 07                      	pop	es			;es = RESGROUP again
 23336                                  
 23337 0000305B F7D1                    	not	cx			;length including the null
 23338                                  
 23339                                  	;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
 23340                                  	;mov	di,offset DATARES:Pipe1
 23341 0000305D BF[1A02]                	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
 23342 00003060 57                      	push	di
 23343 00003061 51                      	push	cx			
 23344 00003062 F3A4                    	rep	movsb			;copy path into Pipe1
 23345 00003064 59                      	pop	cx
 23346 00003065 5F                      	pop	di
 23347                                  
 23348 00003066 1E                      	push	ds
 23349 00003067 06                      	push	es
 23350 00003068 1F                      	pop	ds			;ds:si = Pipe1
 23351 00003069 89FE                    	mov	si,di
 23352                                  	;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
 23353                                  	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 23354 0000306B BF[6902]                	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
 23355 0000306E F3A4                    	rep	movsb			;copy path into Pipe2
 23356 00003070 1F                      	pop	ds
 23357 00003071 C3                      	retn
 23358                                  
 23359                                  ; 28/02/2023
 23360                                  %if 0
 23361                                  
 23362                                  ;============================================================================
 23363                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 23364                                  ;============================================================================
 23365                                  ; 05/10/2018 - Retro DOS v3.0
 23366                                  
 23367                                  ; DATE - Gets and sets the time
 23368                                  
 23369                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 23370                                  
 23371                                  ; =============== S U B	R O U T	I N E =======================================
 23372                                  
 23373                                  DATE_CXDX:
 23374                                  	mov	bx,cx
 23375                                  
 23376                                  ; =============== S U B	R O U T	I N E =======================================
 23377                                  
 23378                                  P_DATE:
 23379                                  	mov	ax,bx
 23380                                  	mov	cx,dx
 23381                                  	mov	dl,100
 23382                                  	div	dl
 23383                                  	xchg	al,ah
 23384                                  	xchg	ax,dx
 23385                                  	mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 23386                                  	;mov	ax,[INTERNATVARS]
 23387                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23388                                  	or	ax,ax
 23389                                  	jz	short USPDAT
 23390                                  	dec	ax
 23391                                  	jz	short EUPDAT
 23392                                  	mov	bh,0	 ; Disable leading zero suppression	
 23393                                  	call	P_YR
 23394                                  	call	P_DSEP
 23395                                  	call	P_MON
 23396                                  	call	P_DSEP
 23397                                  	call	P_DAY
 23398                                  	retn
 23399                                  
 23400                                  USPDAT:
 23401                                  	call	P_MON
 23402                                  	call	P_DSEP
 23403                                  	call	P_DAY
 23404                                  PLST:
 23405                                  	call	P_DSEP
 23406                                  	call	P_YR
 23407                                  	retn
 23408                                  
 23409                                  EUPDAT:
 23410                                  	call	P_DAY
 23411                                  	call	P_DSEP
 23412                                  	call	P_MON
 23413                                  	jmp	short PLST
 23414                                  
 23415                                  ; ---------------------------------------------------------------------------
 23416                                  
 23417                                  P_MON:
 23418                                  	mov	al,ch
 23419                                  	call	OUT2
 23420                                  	retn
 23421                                  
 23422                                  ; ---------------------------------------------------------------------------
 23423                                  
 23424                                  P_DSEP:
 23425                                  	;mov	al,[DATE_SEP] ; INTERNATVARS+11
 23426                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 23427                                  	stosb
 23428                                  	retn
 23429                                  
 23430                                  ; ---------------------------------------------------------------------------
 23431                                  
 23432                                  P_DAY:
 23433                                  	mov	al,cl
 23434                                  	call	OUT2
 23435                                  	retn
 23436                                  
 23437                                  ; ---------------------------------------------------------------------------
 23438                                  
 23439                                  P_YR:
 23440                                  	mov	al,dh
 23441                                  	or	al,al
 23442                                  	jz	short TWODIGYR	; Two instead of 4 digit year
 23443                                  	call	OUT2
 23444                                  TWODIGYR:
 23445                                  	mov	al,dl
 23446                                  	call	OUT2
 23447                                  DATE_RETN:
 23448                                  	retn
 23449                                  
 23450                                  ; =============== S U B	R O U T	I N E =======================================
 23451                                  
 23452                                  DATE:				 ; Accepting argument for date inline
 23453                                  	mov	si,81h
 23454                                  	call	SCANOFF
 23455                                  	cmp	al,0Dh
 23456                                  	jz	short PRMTDAT
 23457                                  	jmp	short COMDAT
 23458                                  
 23459                                  	;nop
 23460                                  PRMTDAT:
 23461                                  	; MSDOS 3.3
 23462                                  	mov	dx,CURDATPTR
 23463                                  	call	STD_PRINTF	; Print "Current date is "	
 23464                                  	call	PRINT_DATE
 23465                                  GETDAT:	
 23466                                  	mov	dx,NEWDATPTR
 23467                                  	call	STD_PRINTF	 ; Print "Enter new date: "
 23468                                  
 23469                                  	mov	ax,INTERNATIONAL*256 ; 3800h 
 23470                                  				; Determine what format the date
 23471                                  	mov	dx,5Ch		;  should be entered in and
 23472                                  	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23473                                  			; get current-country info
 23474                                  			; DS:DX	-> buffer for returned info
 23475                                  	mov	si,dx		;  print a message describing it
 23476                                  	lodsw
 23477                                  	mov	dx,USADATPTR	; get mm-dd-yy
 23478                                  	dec	ax
 23479                                  	js	short PRINTFORMAT
 23480                                  	mov	dx,EURDATPTR	; get dd-mm-yy
 23481                                  	jz	short PRINTFORMAT
 23482                                  	mov	dx,JAPDATPTR	; get yy-mm-dd
 23483                                  PRINTFORMAT:
 23484                                  	call	STD_PRINTF
 23485                                  	mov	ah,Std_Con_String_Input	; 0Ah
 23486                                  	mov	dx,COMBUF
 23487                                  	mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 23488                                  	call	SETINITFLAG	;  prompting for date.
 23489                                  	int	21h		; Get input line
 23490                                  	xor	cx,cx		; Reset bit in InitFlag that indicates
 23491                                  	call	SETINITFLAG	;  prompting for date.
 23492                                  	call	CRLF2
 23493                                  	mov	si,COMBUF+2
 23494                                  	cmp	byte [si],0Dh
 23495                                  	jz	short DATE_RETN
 23496                                  COMDAT:
 23497                                  	;mov	ax,[INTERNATVARS]
 23498                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23499                                  	or	ax,ax
 23500                                  	jz	short USSDAT
 23501                                  	dec	ax
 23502                                  	jz	short EUSDAT
 23503                                  	call	GET_YR
 23504                                  	jc	short DATERRJ
 23505                                  	call	GET_DSEP
 23506                                  	jc	short DATERRJ
 23507                                  	call	GET_MON
 23508                                  	jc	short DATERRJ
 23509                                  	call	GET_DSEP
 23510                                  	jc	short DATERRJ
 23511                                  	call	GET_DAY
 23512                                  DAT_SET:
 23513                                  	jnc	short DATSET
 23514                                  	jmp	DATERR
 23515                                  
 23516                                  ; ---------------------------------------------------------------------------
 23517                                  
 23518                                  DATSET:
 23519                                  	lodsb
 23520                                  	cmp	al,' '
 23521                                  	jz	short DATSET
 23522                                  	cmp	al,9
 23523                                  	jz	short DATSET
 23524                                  	cmp	al,0Dh
 23525                                  	jnz	short DATERR
 23526                                  	mov	ah,SET_DATE ; 2Bh
 23527                                  	int	21h	; DOS -	SET CURRENT DATE
 23528                                  			; DL = day,DH = month,	CX = year
 23529                                  			; Return: AL = 00h if no error 
 23530                                  			; 	     = FFh if bad value sent to routine
 23531                                  	or	al,al
 23532                                  	jnz	short DATERR
 23533                                  DAT_SET_RETN:
 23534                                  	retn
 23535                                  
 23536                                  ; ---------------------------------------------------------------------------
 23537                                  
 23538                                  USSDAT:
 23539                                  	call	GET_MON
 23540                                  	jb	short DATERR
 23541                                  	call	GET_DSEP
 23542                                  DATERRJ:
 23543                                  	jc	short DATERR
 23544                                  	call	GET_DAY
 23545                                  TGET:
 23546                                  	jc	short DATERR
 23547                                  	call	GET_DSEP
 23548                                  	jc	short DATERR
 23549                                  	call	GET_YR
 23550                                  	jmp	short DAT_SET
 23551                                  
 23552                                  ; ---------------------------------------------------------------------------
 23553                                  
 23554                                  EUSDAT:
 23555                                  	call	GET_DAY
 23556                                  	jc	short DATERR
 23557                                  	call	GET_DSEP
 23558                                  	jc	short DATERR
 23559                                  	call	GET_MON
 23560                                  	jmp	short TGET
 23561                                  
 23562                                  ; =============== S U B	R O U T	I N E =======================================
 23563                                  
 23564                                  GET_MON:
 23565                                  	call	GETNUM		; Get one or two digit number
 23566                                  	jc	short DAT_SET_RETN
 23567                                  	mov	dh,ah		; Put in position
 23568                                  	retn
 23569                                  
 23570                                  
 23571                                  ; =============== S U B	R O U T	I N E =======================================
 23572                                  
 23573                                  GET_DAY:
 23574                                  		call	GETNUM
 23575                                  		mov	dl,ah		; Put in position
 23576                                  GET_DAY_RETN:
 23577                                  		retn
 23578                                  
 23579                                  ; =============== S U B	R O U T	I N E =======================================
 23580                                  
 23581                                  GET_YR:
 23582                                  	call	GETNUM
 23583                                  	jc	short GET_DAY_RETN
 23584                                  	mov	cx,1900
 23585                                  	call	GET_DSEP
 23586                                  	pushf
 23587                                  	dec	si
 23588                                  	popf
 23589                                  	jz	short BIAS
 23590                                  	cmp	byte [si],0Dh
 23591                                  	je	short BIAS
 23592                                  	cmp	byte [si],' '
 23593                                  	je	short BIAS
 23594                                  	cmp	byte [si],9
 23595                                  	je	short BIAS
 23596                                  	push	bx
 23597                                  	mov	bl,100
 23598                                  	mov	al,ah
 23599                                  	mul	bl
 23600                                  	pop	bx
 23601                                  	mov	cx,ax
 23602                                  	call	GETNUM
 23603                                  	jc	short GET_DAY_RETN
 23604                                  BIAS:
 23605                                  	mov	al,ah
 23606                                  	mov	ah,0
 23607                                  	add	cx,ax
 23608                                  BIAS_RETN:
 23609                                  	retn
 23610                                  
 23611                                  ; ---------------------------------------------------------------------------
 23612                                  
 23613                                  DATERR:
 23614                                  	mov	dx,BADDATPTR
 23615                                  	call	STD_PRINTF
 23616                                  	jmp	GETDAT
 23617                                  
 23618                                  ; =============== S U B	R O U T	I N E =======================================
 23619                                  
 23620                                  GET_DSEP:
 23621                                  	lodsb
 23622                                  	cmp	al,'/'
 23623                                  	je	short BIAS_RETN
 23624                                  	;cmp	al,'.'
 23625                                  	cmp	al,[DOT_CHR]
 23626                                  	je	short BIAS_RETN
 23627                                  	;cmp	al,'-'
 23628                                  	cmp	al,[CHAR_SUB]
 23629                                  	je	short BIAS_RETN
 23630                                  	stc
 23631                                  	retn
 23632                                  
 23633                                  ; =============== S U B	R O U T	I N E =======================================
 23634                                  
 23635                                  ; TIME gets and sets the time
 23636                                  
 23637                                  CTIME:
 23638                                  	mov	si,81h		; Accepting argument for time inline
 23639                                  	call	SCANOFF
 23640                                  	cmp	al,0Dh
 23641                                  	je	short PRMTTIM
 23642                                  	mov	bx,2E3Ah ; ":."
 23643                                  	call	INLINE
 23644                                  	jmp	COMTIM
 23645                                  
 23646                                  ; =============== S U B	R O U T	I N E =======================================
 23647                                  
 23648                                  PRINT_TIME:
 23649                                  	mov	ah,Get_Time ; 2Ch ; Get time in CX:DX
 23650                                  	int	21h	; DOS -	GET CURRENT TIME
 23651                                  			; Return: CH = hours,CL = minutes,DH = seconds
 23652                                  			; DL = hundredths of seconds
 23653                                  	push	di
 23654                                  	push	es
 23655                                  	push	cs
 23656                                  	pop	es
 23657                                  	mov	di,CHARBUF
 23658                                  	mov	bl,1	; Always 24 hour time
 23659                                  	call	P_TIME
 23660                                  	xor	ax,ax
 23661                                  	stosb
 23662                                  	mov	dx,CHARBUF
 23663                                  	mov	[STRING_PTR_2],dx
 23664                                  	mov	dx,STRINGBUF2PTR
 23665                                  	call	STD_PRINTF
 23666                                  	pop	es
 23667                                  	pop	di
 23668                                  P_TIME_RETN:
 23669                                  	retn
 23670                                  
 23671                                  ; =============== S U B	R O U T	I N E =======================================
 23672                                  
 23673                                  P_TIME:
 23674                                  	mov	al,ch	
 23675                                  	test	bl,7Fh		; Ignore high bit
 23676                                  	jnz	short T24	; 24 hr time?
 23677                                  	mov	bh,'a'		; Assume A.M.
 23678                                  	cmp	al,12		; In the afternoon?
 23679                                  	jb	short MORN
 23680                                  	mov	bh,'p'
 23681                                  	jz	short MORN
 23682                                  	sub	al,12		; Keep it to 12 hours or less
 23683                                  MORN:
 23684                                  	or	al,al		; Before 1 am?
 23685                                  	jnz	short T24
 23686                                  	mov	al,12
 23687                                  T24:
 23688                                  	push	bx
 23689                                  	mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 23690                                  	call	OUT2
 23691                                  	call	P_TSEP
 23692                                  	mov	al,cl
 23693                                  	call	OUT2
 23694                                  	pop	bx
 23695                                  	push	bx
 23696                                  	test	bl,80h
 23697                                  	jnz	short PAP	; If from DIR, go directly to am pm
 23698                                  	mov	bh,0		; Disable leading zero suppression
 23699                                  	call	P_TSEP
 23700                                  	mov	al,dh
 23701                                  	call	OUT2
 23702                                  	;mov	al,'.'
 23703                                  	mov	al,[DECIMAL_SEP]
 23704                                  	stosb
 23705                                  	mov	al,dl
 23706                                  	call	OUT2
 23707                                  PAP:
 23708                                  	pop	bx
 23709                                  	test	bl,7Fh		; Ignore high bit
 23710                                  	jnz	short P_TIME_RETN
 23711                                  	mov	al,bh
 23712                                  	stosb
 23713                                  	retn
 23714                                  
 23715                                  ; =============== S U B	R O U T	I N E =======================================
 23716                                  
 23717                                  P_TSEP:
 23718                                  	;mov	al,[TIME_SEP]
 23719                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 23720                                  	stosb
 23721                                  P_TSEP_RETN:
 23722                                  	retn
 23723                                  
 23724                                  ; ---------------------------------------------------------------------------
 23725                                  
 23726                                  PRMTTIM:
 23727                                  	mov	dx,CURTIMPTR
 23728                                  	call	STD_PRINTF	; Print "Current time is "
 23729                                  	call	PRINT_TIME
 23730                                  GETTIM:
 23731                                  	xor	cx,cx		; Initialize hours and minutes to zero
 23732                                  	mov	dx,NEWTIMPTR
 23733                                  	call	STD_PRINTF
 23734                                  	;mov	bx,':.'
 23735                                  	mov	bx,[TIMECHARS] 
 23736                                  	call	GETBUF
 23737                                  COMTIM:
 23738                                  	jz	short P_TSEP_RETN ; If no time present, don't change it	
 23739                                  	jc	short TIMEERR
 23740                                  	mov	cx,dx
 23741                                  	xor	dx,dx
 23742                                  	lodsb
 23743                                  	cmp	al,0Dh
 23744                                  	je	short SAVTIM
 23745                                  	cmp	al,' '
 23746                                  	je	short GOTSEC2
 23747                                  	cmp	al,9
 23748                                  	je	short GOTSEC2
 23749                                  	cmp	al,bl
 23750                                  	je	short GOTSEC
 23751                                  	cmp	al,bh
 23752                                  	jne	short TIMEERR
 23753                                  GOTSEC:
 23754                                  	call	GETNUM
 23755                                  	jc	short TIMEERR
 23756                                  	mov	dh,ah		; Position seconds
 23757                                  	lodsb
 23758                                  	cmp	al,0Dh
 23759                                  	je	short SAVTIM
 23760                                  	cmp	al,' '
 23761                                  	je	short GOTSEC2
 23762                                  	cmp	al,9
 23763                                  	je	short GOTSEC2
 23764                                  	;cmp	al,'.'
 23765                                  	cmp	al,[DECIMAL_SEP]
 23766                                  	jne	short TIMEERR
 23767                                  	call	GETNUM
 23768                                  	jc	short TIMEERR
 23769                                  	mov	dl,ah
 23770                                  GOTSEC2:
 23771                                  	lodsb
 23772                                  	cmp	al,' '
 23773                                  	je	short GOTSEC2
 23774                                  	cmp	al,9
 23775                                  	je	short GOTSEC2
 23776                                  	cmp	al,0Dh
 23777                                  	jne	short TIMEERR
 23778                                  SAVTIM:
 23779                                  	mov	ah,SET_TIME ; 2Dh
 23780                                  	int	21h	; DOS -	SET CURRENT TIME
 23781                                  			; CH = hours,CL = minutes,DH = seconds,
 23782                                  			;		DL = hundredths of seconds
 23783                                  			; Return: AL = 00h if no error 
 23784                                  			;	     = FFh if bad value sent to routine
 23785                                  	or	al,al
 23786                                  P_TSEP_JRETN:
 23787                                  	jz	short P_TSEP_RETN ; Error in time?
 23788                                  TIMEERR:
 23789                                  	mov	dx,BADTIMPTR
 23790                                  	call	STD_PRINTF	; Print "Enter new time: "
 23791                                  	jmp	short GETTIM
 23792                                  
 23793                                  ; =============== S U B	R O U T	I N E =======================================
 23794                                  
 23795                                  GETBUF:
 23796                                  	mov	ah,Std_Con_String_Input ; 0Ah
 23797                                  	mov	dx,COMBUF
 23798                                  	mov	cx,2
 23799                                  	call	SETINITFLAG
 23800                                  	int	21h		; Get input line
 23801                                  	xor	cx,cx
 23802                                  	call	SETINITFLAG
 23803                                  	call	CRLF2
 23804                                  	mov	si,COMBUF+2
 23805                                  	cmp	byte [si],0Dh	; Check if new time entered
 23806                                  	jz	short P_TSEP_JRETN
 23807                                  
 23808                                  ; =============== S U B	R O U T	I N E =======================================
 23809                                  
 23810                                  INLINE:
 23811                                  	call	GETNUM		; Get one or two digit number
 23812                                  	jnb	short INLINE1
 23813                                  	retn
 23814                                  INLINE1:
 23815                                  	mov	dh,ah		; Put in position
 23816                                  	lodsb
 23817                                  	cmp	al,bl
 23818                                  	jz	short NEXT
 23819                                  	cmp	al,bh
 23820                                  	jz	short NEXT
 23821                                  	dec	si		; Clears zero flag
 23822                                  	clc
 23823                                  	mov	dl,0
 23824                                  	retn			; Time may have only an hour specified
 23825                                  NEXT:
 23826                                  	call	GETNUM
 23827                                  	mov	dl,ah		; Put in position
 23828                                  INLINE_RETN:
 23829                                  	retn
 23830                                  
 23831                                  ;============================================================================
 23832                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 23833                                  ;============================================================================
 23834                                  ; 05/10/2018 - Retro DOS v3.0
 23835                                  
 23836                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 23837                                  
 23838                                  ; =============== S U B	R O U T	I N E =======================================
 23839                                  
 23840                                  GETNUM:
 23841                                  	call	INDIG
 23842                                  	jb	short INLINE_RETN
 23843                                  	mov	ah,al		; Save first digit
 23844                                  	call	INDIG		; Another digit?
 23845                                  	jb	short OKRET
 23846                                  	aad			; Convert unpacked BCD to decimal
 23847                                  	mov	ah,al
 23848                                  OKRET:
 23849                                  	or	al,1
 23850                                  GETNUM_RETN:
 23851                                  	retn
 23852                                  
 23853                                  ; =============== S U B	R O U T	I N E =======================================
 23854                                  
 23855                                  INDIG:
 23856                                  	mov	al,[si]
 23857                                  	sub	al,'0'
 23858                                  	jc	short GETNUM_RETN
 23859                                  	cmp	al,10
 23860                                  	cmc
 23861                                  	jc	short GETNUM_RETN
 23862                                  	inc	si
 23863                                  	retn
 23864                                  
 23865                                  ; =============== S U B	R O U T	I N E =======================================
 23866                                  
 23867                                  OUT2:				; Output binary number as two ASCII digits
 23868                                  	aam			; Convert binary to unpacked BCD
 23869                                  	xchg	al,ah
 23870                                  	or	ax,3030h	; Add "0" bias to both digits
 23871                                  	cmp	al,'0'		; Is MSD zero?
 23872                                  	jnz	short NOSUP
 23873                                  	sub	al,bh		; Suppress leading zero if enabled
 23874                                  NOSUP:
 23875                                  	mov	bh,0		; Disable zero suppression
 23876                                  	stosw
 23877                                  	retn
 23878                                  
 23879                                  ; ---------------------------------------------------------------------------
 23880                                  	;stosb
 23881                                  	;retn
 23882                                  
 23883                                  ;============================================================================
 23884                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 23885                                  ;============================================================================
 23886                                  ; 03/10/2018 - Retro DOS v3.0
 23887                                  
 23888                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 23889                                  
 23890                                  ; =============== S U B	R O U T	I N E =======================================
 23891                                  
 23892                                  ; Set the special flag in the INIT flag to the value in CX.
 23893                                  
 23894                                  SETINITFLAG:
 23895                                  	mov	ds,[RESSEG]
 23896                                  	;and	byte [INITFLAG],0FDh
 23897                                  	and	byte [INITFLAG],~INITSPECIAL
 23898                                  	or	byte [INITFLAG],cl
 23899                                  	push	cs
 23900                                  	pop	ds
 23901                                  	retn
 23902                                  
 23903                                  ; =============== S U B	R O U T	I N E =======================================
 23904                                  
 23905                                  PIPEOFF:
 23906                                  	push	ds
 23907                                  	push	ax
 23908                                  	mov	ds,[cs:RESSEG]
 23909                                  	xor	al,al
 23910                                  	xchg	al,byte [PIPEFLAG]
 23911                                  	or	al,al
 23912                                  	jz	short PIPEOFFDONE
 23913                                  	shr	byte [ECHOFLAG],1
 23914                                  PIPEOFFDONE:
 23915                                  	pop	ax
 23916                                  	pop	ds
 23917                                  	retn
 23918                                  
 23919                                  ; ---------------------------------------------------------------------------
 23920                                  	;db    0,0,0,0,0
 23921                                  	;times 5 db 0
 23922                                  
 23923                                  align 16
 23924                                  
 23925                                  %endif
 23926                                  
 23927                                  ;============================================================================
 23928                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 23929                                  ;============================================================================
 23930                                  ; 03/10/2018 - Retro DOS v3.0
 23931                                  
 23932                                  ;----------------------------------------------------------------------------
 23933                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 23934                                  ; argv[argvcnt] array. The most important difference between this array and
 23935                                  ; the tradition UNIX format is the extra cparse information included with
 23936                                  ; each argument element.
 23937                                  ;---------------
 23938                                  ; ENTRY:
 23939                                  ;	BL	     special delimiter for cparse -- not implemented)
 23940                                  ;---------------
 23941                                  ; EXIT:
 23942                                  ;	CF	    set if error
 23943                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 23944                                  ;	argv[]	    array of cparse flags and pointers to arguments
 23945                                  ;	argvcnt     argument count
 23946                                  ;---------------
 23947                                  ; NOTE(S):
 23948                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 23949                                  ;	*   Parseflags record contains cparse flags, as follows:
 23950                                  ;		sw_flag 	--	was this arg a switch?
 23951                                  ;		wildcard	--	whether or not it contained a * or ?
 23952                                  ;		path_sep	--	maybe it was a pathname
 23953                                  ;		unused		--	for future expansion
 23954                                  ;		special_delim	--	was there an initial special delimiter?
 23955                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 23956                                  ;	*   Relationship between input, cparse output, and comtail can be
 23957                                  ;	    found in the following chart. Despite the claim of the cparse
 23958                                  ;	    documentation that, "Token buffer always starts d: for non switch
 23959                                  ;	    tokens", such is not the case (see column two, row two).
 23960                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 23961                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 23962                                  ;	    STARTEL addresses) will be null. This is clearly just a
 23963                                  ;	    documentation error.
 23964                                  ;	*   cparse also returns a switch code in BP for each switch it
 23965                                  ;	    recognizes on the command line.
 23966                                  ;	*   arglen for each token does NOT include the terminating null.
 23967                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 23968                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 23969                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 23970                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 23971                                  ;	    line parsing may result in slightly different behavior than
 23972                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 23973                                  ;
 23974                                  ;	    Input		    Cparse		Command Line (80H)
 23975                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 23976                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 23977                                  ;	foo.bat 		foo.bat 		foo.bat
 23978                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 23979                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 23980                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 23981                                  
 23982                                  ; =============== S U B	R O U T	I N E =======================================
 23983                                  
 23984                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 23985                                  
 23986                                  ; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23987                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh
 23988                                  
 23989                                  PARSELINE:
 23990 00003072 50                      	push	ax			; most of these are clobbered
 23991 00003073 53                      	push	bx			; by cparse...
 23992 00003074 51                      	push	cx
 23993 00003075 52                      	push	dx
 23994 00003076 57                      	push	di
 23995 00003077 56                      	push	si
 23996 00003078 9C                      	pushf
 23997 00003079 C606[D48C]00            	mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
 23998 0000307E C706[3594]FFFF          	mov	word [LASTARG],-1 ; last argument at which to accumulate
 23999 00003084 31C0                    	xor	ax,ax
 24000                                  	;mov	cx,1348
 24001 00003086 B94405                  	mov	cx,ARG_UNIT.SIZE
 24002 00003089 BF[6F8E]                	mov	di,ARG
 24003 0000308C F3AA                    	rep	stosb
 24004                                  	;mov	word [ARGBUF_PTR],ARG_ARGBUF
 24005 0000308E C706[B393][3391]        	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
 24006                                  	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 24007 00003094 C706[3191]0000          	mov	word [ARG+ARG_UNIT.argswinfo],0
 24008                                  	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 24009 0000309A C706[2F91]0000          	mov	word [ARG+ARG_UNIT.argvcnt],0
 24010 000030A0 BE[4189]                	mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 24011                                  
 24012                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 24013                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 24014                                  ; otherwise. This is done so that commands can get arg pointers into their
 24015                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 24016                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 24017                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 24018                                  ; the command to be repeated or the transient part of command has been
 24019                                  ; reloaded.
 24020                                  
 24021 000030A3 1E                      	push	ds
 24022 000030A4 8E1E[E08A]              	mov	ds,[RESSEG]
 24023 000030A8 803E[AC01]00            	cmp	byte [ForFlag],0
 24024 000030AD 1F                      	pop	ds
 24025 000030AE 7510                    	jnz	short PCONT
 24026                                  	;mov	di,ARG_ARGFORCOMBUF
 24027 000030B0 BF[3393]                	mov	di,ARG+ARG_UNIT.argforcombuf 
 24028 000030B3 30ED                    	xor	ch,ch
 24029 000030B5 8A0E[4089]              	mov	cl,[COMBUF+1]
 24030 000030B9 FEC1                    	inc	cl
 24031 000030BB F3A4                    	rep	movsb
 24032                                  	;mov	si,ARG_ARGFORCOMBUF
 24033 000030BD BE[3393]                	mov	si,ARG+ARG_UNIT.argforcombuf 
 24034                                  PCONT:
 24035 000030C0 BF[B593]                	mov	di,TPBUF	; destination is temporary token buffer	
 24036 000030C3 B320                    	mov	bl,' '		; no special delimiter, for now
 24037                                  PARSELOOP:
 24038 000030C5 8936[3794]              	mov	[COMPTR],si	; save ptr into original command buffer
 24039 000030C9 31ED                    	xor	bp,bp		; switch information put here by cparse
 24040 000030CB C606[518E]00            	mov	byte [expand_star],0 ; don't expand *'s to ?'s
 24041 000030D0 E833F5                  	call	scanoff		; skip leading blanks...
 24042 000030D3 E8D510                  	call	cparse		; byte off a token (args in SI, DI, BL)
 24043 000030D6 730B                    	jnb	short MORE_PRSE
 24044 000030D8 09ED                    	or	bp,bp		; Check for trailing switch character
 24045 000030DA 7403                    	jz	short PARSEDONE
 24046 000030DC E81700                  	call	newarg		; We hit CR but BP is non-zero. The
 24047                                  				;   typical cause of this is that a
 24048                                  				;   switch char IMMEDIATELY preceeds
 24049                                  				;   the CR. We have an argument, but it
 24050                                  				;   is sort of an error.
 24051                                  	;jmp	short PARSEDONE	; We're done (found the CR).
 24052                                  	; 01/03/2023
 24053                                  PARSEDONE:
 24054 000030DF 9D                      	popf
 24055 000030E0 F8                      	clc
 24056 000030E1 EB0C                    	jmp	short PARSE_EXIT
 24057                                  
 24058                                  MORE_PRSE:
 24059 000030E3 C606[D48C]02            	mov	byte [cpyflag],2
 24060                                  				; tell CPARSE that 1st token is done
 24061 000030E8 E80B00                  	call	newarg		; add to argv array (CX has char count)
 24062 000030EB 73D8                    	jnb	short PARSELOOP	; was everything OK?
 24063                                  	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 24064                                  	; 01/03/2023
 24065                                  ;PARSEDONE:
 24066                                  	;popf
 24067                                  	;clc
 24068                                  	;jmp	short PARSE_EXIT
 24069                                  
 24070                                  PARSE_ERROR:			; error entry (er, exit) point
 24071 000030ED 9D                      	popf
 24072 000030EE F9                      	stc
 24073                                  PARSE_EXIT:			; depend on not changing CF
 24074 000030EF 5E                      	pop	si
 24075 000030F0 5F                      	pop	di
 24076 000030F1 5A                      	pop	dx
 24077 000030F2 59                      	pop	cx
 24078 000030F3 5B                      	pop	bx
 24079 000030F4 58                      	pop	ax
 24080 000030F5 C3                      	retn
 24081                                  
 24082                                  ; =============== S U B	R O U T	I N E =======================================
 24083                                  
 24084                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 24085                                  ;
 24086                                  ; ENTRY:
 24087                                  ;   BH			argflags
 24088                                  ;   CX			character count in argstring
 24089                                  ;   DI			pointer to argstring
 24090                                  ;   comptr		ptr to starting loc of current token in original command
 24091                                  ;   [STARTEL]		cparse's answer to where the last element starts
 24092                                  ; EXIT:
 24093                                  ;   argbufptr		points to next free section of argbuffer
 24094                                  ;   arg.argbuf		contains null-terminated argument strings
 24095                                  ;   arg.argvcnt 	argument count
 24096                                  ;   arg.argv[]		array of flags and pointers
 24097                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 24098                                  ;   CF			set if error
 24099                                  ;   AL			carry set:  error code; otherwise, zero
 24100                                  
 24101                                  	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24102                                  newarg:
 24103 000030F6 53                      	push	bx
 24104 000030F7 51                      	push	cx
 24105 000030F8 52                      	push	dx
 24106 000030F9 57                      	push	di
 24107 000030FA 56                      	push	si
 24108 000030FB 9C                      	pushf
 24109 000030FC E86600                  	call	arg_switch		; if it's a switch, record switch info
 24110                                  					; LEAVE SWITCH ON COMMAND LINE!!
 24111                                  	;;;jc	short newarg_done 	; previous arg's switches -- and leave
 24112                                  
 24113                                  	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 24114 000030FF 833E[2F91]40            	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 24115 00003104 7D4F                    	jge	short to_many_args	; exceeded array limits
 24116 00003106 88FE                    	mov	dh,bh			
 24117                                  	;mov	bx,[ARG_ARGVCNT]	; save argflags	
 24118 00003108 8B1E[2F91]              	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 24119                                  	;inc	word [ARG_ARGVCNT]
 24120 0000310C FF06[2F91]              	inc	word [ARG+ARG_UNIT.argvcnt]
 24121                                  	;mov	ax,ARG_ARGV
 24122 00003110 B8[6F8E]                	mov	ax,ARG+ARG_UNIT.argv
 24123 00003113 E88200                  	call	argv_calc		; convert offset to pointer
 24124                                  	;mov	[BX].argsw_word,0 	; no switch information, yet...
 24125                                  	;mov	word [bx+7],0
 24126 00003116 C747070000              	mov	word [bx+ARGV_ELE.argsw_word],0
 24127                                  	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
 24128                                  	;mov	[bx+5],cx
 24129 0000311B 894F05                  	mov	[bx+ARGV_ELE.arglen],cx 
 24130                                  	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
 24131                                  	;mov	[bx+2],dh
 24132 0000311E 887702                  	mov	[bx+ARGV_ELE.argflags],dh
 24133 00003121 8B36[B393]              	mov	si,[ARGBUF_PTR]
 24134                                  	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
 24135                                  	;mov	[bx+ARGV_ELE.argpointer],si
 24136 00003125 8937                    	mov	[bx],si			
 24137 00003127 0336[168E]              	add	si,[STARTEL]		; save startel from new location
 24138 0000312B 29FE                    	sub	si,di			; form pointer into argbuf
 24139                                  	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 24140                                  	;mov	[bx+3],si
 24141 0000312D 897703                  	mov	[bx+ARGV_ELE.argstartel],si
 24142 00003130 8B36[3794]              	mov	si,[COMPTR]
 24143                                  	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 24144                                  	;mov	[bx+9],si
 24145 00003134 897709                  	mov	[bx+ARGV_ELE.arg_ocomptr],si
 24146 00003137 89FE                    	mov	si,di			; now save argstring in argbuffer
 24147 00003139 8B3E[B393]              	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
 24148 0000313D 01CF                    	add	di,cx			; sure we're not about to run off
 24149                                  	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 24150                                  	;cmp	di,ARG_ARGBUF+255
 24151 0000313F 81FF[3292]              	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24152 00003143 7D15                    	jge	short buf_oflow		; the end of the buffer (plus null byte)	
 24153 00003145 29CF                    	sub	di,cx
 24154 00003147 FC                      	cld
 24155 00003148 F3A4                    	rep	movsb
 24156 0000314A B000                    	mov	al,ANULL ; 0		; tack a null byte on the end
 24157 0000314C AA                      	stosb
 24158 0000314D 893E[B393]              	mov	[ARGBUF_PTR],di		; update argbufptr after copy
 24159                                  newarg_done:
 24160 00003151 9D                      	popf
 24161 00003152 F8                      	clc
 24162 00003153 EB0A                    	jmp	short newarg_exit
 24163                                  to_many_args:
 24164 00003155 B80100                  	mov	ax,1
 24165 00003158 EB03                    	jmp	short newarg_error
 24166                                  buf_oflow:
 24167 0000315A B80200                  	mov	ax,2
 24168                                  newarg_error:
 24169 0000315D 9D                      	popf
 24170 0000315E F9                      	stc
 24171                                  newarg_exit:
 24172 0000315F 5E                      	pop	si
 24173 00003160 5F                      	pop	di
 24174 00003161 5A                      	pop	dx
 24175 00003162 59                      	pop	cx
 24176 00003163 5B                      	pop	bx
 24177 00003164 C3                      	retn
 24178                                  
 24179                                  ; =============== S U B	R O U T	I N E =======================================
 24180                                  
 24181                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 24182                                  ; event that it is, and we can recognize
 24183                                  ;
 24184                                  ; ENTRY:
 24185                                  ;   As in <newarg>.
 24186                                  ; EXIT:
 24187                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 24188                                  ; NOTE(S):
 24189                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 24190                                  ;	on the order of definition in the <switch_list> variable and the
 24191                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 24192                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 24193                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 24194                                  ;   *	The <switch_list> declared below is redundant to one declared in
 24195                                  ;	TDATA.ASM, and used in TCODE.ASM.
 24196                                  ;   *	An ugly routine.
 24197                                  
 24198                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24199                                  arg_switch:
 24200 00003165 50                      	push	ax
 24201 00003166 53                      	push	bx
 24202 00003167 51                      	push	cx
 24203 00003168 57                      	push	di
 24204 00003169 9C                      	pushf
 24205 0000316A F6C701                  	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
 24206 0000316D 741C                    	jz	short arg_no_switch0
 24207 0000316F 833E[3594]FF            	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
 24208 00003174 741B                    	je	short arg_no_switch1 	; no, so leading switches don't matter
 24209 00003176 8B1E[3594]              	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
 24210                                  	;mov	ax,offset TRANGROUP:arg.argv
 24211                                  	;mov	ax,ARG_ARGV
 24212 0000317A B8[6F8E]                	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 24213 0000317D E81800                  	call	argv_calc
 24214                                  	;or	[BX].argsw_word,BP
 24215                                  	;or	[bx+7],bp
 24216 00003180 096F07                  	or	[bx+ARGV_ELE.argsw_word],bp
 24217                                  	;or	arg.argswinfo,BP
 24218                                  	;or	[ARG_ARGSWINFO],bp
 24219 00003183 092E[3191]              	or	[ARG+ARG_UNIT.argswinfo],bp
 24220                                  arg_yes_switch:
 24221 00003187 9D                      	popf
 24222 00003188 F9                      	stc
 24223 00003189 EB08                    	jmp	short arg_switch_exit
 24224                                  
 24225                                  arg_no_switch0:
 24226                                  	;mov	ax,[ARG_ARGVCNT]
 24227 0000318B A1[2F91]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 24228 0000318E A3[3594]                	mov	[LASTARG],ax
 24229                                  arg_no_switch1:
 24230 00003191 9D                      	popf
 24231 00003192 F8                      	clc
 24232                                  arg_switch_exit:
 24233 00003193 5F                      	pop	di
 24234 00003194 59                      	pop	cx
 24235 00003195 5B                      	pop	bx
 24236 00003196 58                      	pop	ax
 24237 00003197 C3                      	retn
 24238                                  
 24239                                  ; =============== S U B	R O U T	I N E =======================================
 24240                                  
 24241                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 24242                                  ; the supplied array.  Method used for computing the address is:
 24243                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 24244                                  ; ENTRY:
 24245                                  ;   AX	    --	    base of array
 24246                                  ;   BX	    --	    array index
 24247                                  ; EXIT:
 24248                                  ;   BX	    --	    byte offset
 24249                                  
 24250                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24251                                  argv_calc:
 24252 00003198 50                      	push	ax		; Save base
 24253 00003199 88D8                    	mov	al,bl		; al = array index
 24254                                  	;mov	bl,11
 24255 0000319B B30B                    	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 24256 0000319D F6E3                    	mul	bl		; ax = base offset
 24257 0000319F 5B                      	pop	bx		; Get base
 24258 000031A0 01D8                    	add	ax,bx		; Add in base offset
 24259 000031A2 93                      	xchg	ax,bx		; Restore ax and put byte offset in bx
 24260 000031A3 C3                      	retn
 24261                                  
 24262                                  ; ---------------------------------------------------------------------------
 24263                                  	
 24264                                  	;db 0Ah dup(0)
 24265                                  	;times 10 db 0
 24266                                  
 24267 000031A4 90<rep Ch>              align 16
 24268                                  
 24269                                  ;============================================================================
 24270                                  ; PATH1.ASM, MSDOS 6.0, 1991
 24271                                  ;============================================================================
 24272                                  ; 03/10/2018 - Retro DOS v3.0
 24273                                  
 24274                                  ;----------------------------------------------------------------------------
 24275                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 24276                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 24277                                  ;    given a pathname, attempts to find a corresponding executable or batch
 24278                                  ;    file on disk. Directories specified in the user's search path will be
 24279                                  ;    searched for a matching file, if a match is not found in the current
 24280                                  ;    directory and if the pathname is actually only an MSDOS filename.
 24281                                  ;    <Path_Search> assumes that the parsed command name can be found in
 24282                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 24283                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 24284                                  ;    information could be placed in argv[0], or <Path_Search> could be
 24285                                  ;    (easily) modified to make no assumptions about where its input is found.
 24286                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 24287                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 24288                                  ;    allocated memory. This is handy for for-loop processing, and anything
 24289                                  ;    else that wants to save the whole shebang and then process other command
 24290                                  ;    lines.
 24291                                  ;
 24292                                  ; Alan L, OS/MSDOS				    August 15, 1983
 24293                                  ;
 24294                                  ; ENTRY:
 24295                                  ;   <Path_Search>:	    argv[0].
 24296                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 24297                                  ; EXIT:
 24298                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 24299                                  ;   <Save_Args>:	    success flag, segment address of new memory
 24300                                  ; NOTE(S):
 24301                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 24302                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 24303                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 24304                                  ;	does not function as specified; see <Parseline> for more details.
 24305                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 24306                                  ;	need to know about. This extra information is stored in a switch_flag
 24307                                  ;	word with each command-line argument; the switches themselves will not
 24308                                  ;	appear in the resulting arg structure.
 24309                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 24310                                  ;----------------------------------------------------------------------------
 24311                                  
 24312                                  ; =============== S U B	R O U T	I N E =======================================
 24313                                  
 24314                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 24315                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 24316                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 24317                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 24318                                  ; have a match, either in the current working directory if we were handed
 24319                                  ; a filename, or in the specified directory, given a pathname. If this call
 24320                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 24321                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 24322                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 24323                                  ; either the first invocation of search or on one of the succeeding calls
 24324                                  ; sets up the appropriate information for copying the successful pathname
 24325                                  ; prefix (if any) into the result buffer, followed by the successful filename
 24326                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 24327                                  ;
 24328                                  ; ENTRY:
 24329                                  ;   argv[0]		--	command name and associated information
 24330                                  ; EXIT:
 24331                                  ;   AX			--	non-zero indicates type of file found
 24332                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 24333                                  ; NOTE(S):
 24334                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 24335                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 24336                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 24337                                  ;	if search returns an .exe or .bat.
 24338                                  ;   5)	Clobbers dma address.
 24339                                  
 24340                                  PBUFLEN 	EQU	128		; length of EXECPATH
 24341                                  PATH_SEP_CHAR	EQU	';'
 24342                                  
 24343                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 24344                                  
 24345                                  	;special_delim equ 128
 24346                                  	;path_sep equ 4
 24347                                  	;wildcard equ 2
 24348                                  	;sw_flag  equ 1
 24349                                  
 24350                                  ;----------------------------------------------------------------------------
 24351                                  
 24352                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 24353                                  
 24354                                  ; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24355                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h
 24356                                  
 24357                                  path_search:
 24358 000031B0 53                      	push	bx
 24359 000031B1 51                      	push	cx
 24360 000031B2 52                      	push	dx		; could use a "stack 'em" instruction
 24361 000031B3 56                      	push	si
 24362 000031B4 57                      	push	di
 24363 000031B5 55                      	push	bp
 24364 000031B6 9C                      	pushf
 24365                                  
 24366                                  	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 24367                                  	;test	byte [ARGV0_ARG_FLAGS],3
 24368 000031B7 F606[718E]03            	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
 24369 000031BC 7403                    	jz	short path_search_ok
 24370                                  path_failure_jmp:
 24371 000031BE E9C100                  	jmp	path_failure	; ambiguous commands not allowed
 24372                                  
 24373                                  path_search_ok:
 24374 000031C1 E85201                  	call	STORE_PCHAR	; figure out the pathname separator
 24375 000031C4 BA[3994]                	mov	dx,FBUF		; clobber old dma value with
 24376 000031C7 B8001A                  	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
 24377 000031CA CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 24378                                  			; DS:DX	-> disk	transfer buffer
 24379 000031CC 06                      	push	es
 24380 000031CD E862F1                  	call	find_path	; get a handle (ES:DI) on user path
 24381 000031D0 8C06[6494]              	mov	[pathinfo+0],es	; and squirrel it away
 24382 000031D4 893E[6694]              	mov	[pathinfo+2],di	; "old" pathstring pointer
 24383 000031D8 893E[6894]              	mov	[pathinfo+4],di	; "new" pathstring pointer
 24384 000031DC 07                      	pop	es
 24385                                  	
 24386 000031DD BB8000                  	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 24387 000031E0 BE[088A]                	mov	si,EXECPATH
 24388 000031E3 E88002                  	call	STRIP
 24389 000031E6 72D6                    	jc	short path_failure_jmp ; if possible, of course
 24390                                  		
 24391 000031E8 89F2                    	mov	dx,si		; search (EXECPATH, error_message)
 24392 000031EA C706[B994][D17F]        	mov	word [search_error],baddrv_ptr
 24393 000031F0 E89F01                  	call	PSEARCH		; must do at least one search
 24394 000031F3 09C0                    	or	ax,ax		; find anything?
 24395 000031F5 7469                    	jz	short path_noinit
 24396                                  				; failure ... search farther	
 24397 000031F7 89C5                    	mov	bp,ax		; success... save filetype code	
 24398 000031F9 BF[088A]                	mov	di,EXECPATH
 24399                                  	;mov	si,ds:arg.argv[0].argpointer
 24400                                  	;mov	si,[ARG_ARGV]
 24401 000031FC 8B36[6F8E]              	mov	si,[ARG+ARGV_ELE.argpointer]
 24402                                  	;mov	cx,ds:arg.argv[0].argstartel
 24403                                  	;mov	cx,[ARGV0_ARGSTARTEL]
 24404 00003200 8B0E[728E]              	mov	cx,[ARG+ARGV_ELE.argstartel]
 24405 00003204 29F1                    	sub	cx,si		; compute prefix bytes to copy
 24406                                  
 24407                                  ; We have the number of bytes in the prefix (up to the final component).
 24408                                  ; We need to form the complete pathname including leading drive and current
 24409                                  ; directory.
 24410                                  ;
 24411                                  ; Is there a drive letter present?
 24412                                  
 24413 00003206 B43A                    	mov	ah,':'
 24414 00003208 83F902                  	cmp	cx,2		; room for drive letter?
 24415 0000320B 7205                    	jb	short adddrive	; no, stick it in
 24416 0000320D 386401                  	cmp	[si+1],	ah	; colon present?
 24417 00003210 7408                    	je	short movedrive	; yes, just move it
 24418                                  adddrive:
 24419 00003212 A0[F48A]                	mov	al,[CURDRV]	; get current drive
 24420 00003215 0441                    	add	al,'A'		; convert to uppercase letter
 24421 00003217 AB                      	stosw			; store d:
 24422 00003218 EB05                    	jmp	short checkpath
 24423                                  
 24424                                  movedrive:
 24425 0000321A AD                      	lodsw			; move d:
 24426 0000321B AB                      	stosw
 24427 0000321C 83E902                  	sub	cx,2		; 2 bytes less to move
 24428                                  checkpath:
 24429 0000321F 0C20                    	or	al,20h
 24430 00003221 88C2                    	mov	dl,al		
 24431                                  	;sub	dl,60h
 24432 00003223 80EA60                  	sub	dl,'a'-1	; convert to 1-based for current dir
 24433                                  
 24434                                  ; Stick in beginning path char
 24435                                  
 24436 00003226 A0[6A94]                	mov	al,[psep_char]
 24437 00003229 AA                      	stosb
 24438                                  
 24439                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 24440                                  ; Otherwise, get current dir for DL.
 24441                                  
 24442 0000322A 83F901                  	cmp	cx,1		; is there room for path char?
 24443 0000322D 720A                    	jb	short addpath	; no, go add path
 24444 0000322F AC                      	lodsb
 24445 00003230 49                      	dec	cx
 24446 00003231 3A06[6A94]              	cmp	al,[psep_char]	; is there a path separator?
 24447 00003235 741C                    	je	short movepath	; yes, go move remainder of path
 24448 00003237 41                      	inc	cx
 24449 00003238 4E                      	dec	si		; undo the lodsb
 24450                                  addpath:
 24451 00003239 56                      	push	si
 24452 0000323A 89FE                    	mov	si,di		; remainder of buffer
 24453 0000323C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24454 0000323F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24455                                  			; DL = drive (0=default,1=A,etc.)
 24456                                  			; DS:SI	points to 64-byte buffer area
 24457                                  
 24458                                  ; The previous current dir will succeed a previous find_first already worked.
 24459                                  ;
 24460                                  ; Find end of string.
 24461                                  
 24462 00003241 89F7                    	mov	di,si
 24463 00003243 5E                      	pop	si
 24464 00003244 A0[6A94]                	mov	al,[psep_char]
 24465 00003247 803D00                  	cmp	byte [di],0	; root (empty dir string)?
 24466 0000324A 7407                    	jz	short movepath	; yes, no need for path char
 24467                                  scanend:
 24468                                  	;cmp	byte [di],0	; end of string?
 24469                                  	;jz	short foundend
 24470                                  	;inc	di
 24471                                  	;jmp	short scanend
 24472                                  	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
 24473 0000324C 47                      	inc	di
 24474 0000324D 803D00                  	cmp	byte [di],0
 24475 00003250 75FA                    	jnz	short scanend
 24476                                  
 24477                                  ; Stick in a trailing path char.
 24478                                  
 24479                                  foundend:
 24480 00003252 AA                      	stosb
 24481                                  
 24482                                  ; Move remaining part of path. Skip leading path char if present.
 24483                                  
 24484                                  movepath:
 24485 00003253 3804                    	cmp	[si],al		; first char a path char?
 24486 00003255 7502                    	jne	short copypath
 24487                                  	; 26/04/2023
 24488 00003257 46                      	inc	si		; move past leading char
 24489 00003258 49                      	dec	cx		; drop from count
 24490                                  copypath:
 24491 00003259 E302                    	jcxz	_copydone	; no chars to move!	
 24492 0000325B F3A4                    	rep	movsb
 24493                                  _copydone:
 24494 0000325D E9A100                  	jmp	path_success
 24495                                  				; run off and form complete pathname
 24496                                  path_noinit:
 24497                                  	;test	ds:arg.argv[0].argflags, MASK path_sep
 24498                                  	;test	byte [ARGV0_ARG_FLAGS],4
 24499 00003260 F606[718E]04            	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
 24500 00003265 751B                    	jnz	short path_failure
 24501                                  				; complete pathname specified ==> fail
 24502                                  	;mov	bh,';'
 24503 00003267 B73B                    	mov	bh,PATH_SEP_CHAR
 24504                                  				; semicolon terminates pathstring
 24505                                  	;mov	dx,ds:arg.argv[0].argstartel
 24506                                  				; this is where the last element starts
 24507                                  	;mov	dx,[ARGV0_ARGSTARTEL]
 24508 00003269 8B16[728E]              	mov	dx,[ARG+ARGV_ELE.argstartel]
 24509                                  	;sub	dx,ds:arg.argv[0].argpointer
 24510                                  				; form pointer into EXECPATH,
 24511                                  	;sub	dx,[ARG_ARGV]
 24512 0000326D 2B16[6F8E]              	sub	dx,[ARG+ARGV_ELE.argpointer]
 24513 00003271 81C2[088A]              	add	dx,EXECPATH	; skipping over drive spec, if any
 24514                                  path_loop:
 24515 00003275 E8AD00                  	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
 24516 00003278 89C5                    	mov	bp,ax		; save filetype code
 24517 0000327A 9F                      	lahf			; save flags, just in case
 24518 0000327B 09ED                    	or	bp,bp		; did path_crunch find anything?		
 24519 0000327D 7508                    	jnz	short path_found 
 24520 0000327F 9E                      	sahf			; see? needed those flags, after all!
 24521 00003280 73F3                    	jnc	short path_loop	; is there anything left to the path?
 24522                                  path_failure:
 24523 00003282 31C0                    	xor	ax,ax
 24524 00003284 E98700                  	jmp	path_exit
 24525                                  
 24526                                  path_found:				; pathinfo[] points to winner
 24527 00003287 BF[088A]                	mov	di,EXECPATH
 24528                                  	;mov	cx,pathinfo[4] 
 24529 0000328A 8B0E[6894]              	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
 24530                                  	;mov	si,pathinfo[2]
 24531 0000328E 8B36[6694]              	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string
 24532                                  
 24533                                  ;	BAS Nov 20/84
 24534                                  ;   Look at the pathname and expand . and .. if they are the first element
 24535                                  ;   in the pathname (after the drive letter)
 24536                                  
 24537 00003292 06                      	push	es
 24538                                  	;push	pathinfo[0]
 24539 00003293 FF36[6494]              	push	word [pathinfo+0]
 24540 00003297 07                      	pop	es
 24541                                  ;SR;
 24542                                  ; Oops! Gets fooled if path= \;..
 24543                                  ; We should also check if a drive letter is really present
 24544                                  ;
 24545 00003298 26807C022E              	cmp	byte [es:si+2],'.'
 24546                                  				; Look for Current dir at start of path
 24547 0000329D 7534                    	jne	short path_cpy
 24548                                  
 24549                                  	; 18/03/2023
 24550                                  	; MSDOS 6.0
 24551 0000329F 26807C013A              	cmp	byte [es:si+1],':'
 24552                                  				; does path have drive letter?
 24553 000032A4 752D                    	jne	short path_cpy	; no, copy the path string
 24554                                  
 24555 000032A6 51                      	push	cx		; Save pointer to end of string
 24556                                  	;mov	al,[es:si]
 24557                                  	;mov	[di],al		; Copy drive letter, :, and root char
 24558                                  	;mov	al,[es:si+1]	; to EXECPATH
 24559                                  	;mov	[di+1],al
 24560                                  	; 05/05/2023
 24561 000032A7 268B04                  	mov	ax,[es:si]
 24562 000032AA 8905                    	mov	[di],ax
 24563 000032AC A0[6A94]                	mov	al,[psep_char]
 24564 000032AF 884502                  	mov	[di+2],	al
 24565 000032B2 56                      	push	si		; Save pointer to begining of string
 24566 000032B3 268A14                  	mov	dl,[es:si]	; Convert device letter for cur dir
 24567 000032B6 80CA20                  	or	dl,20h
 24568                                  	;sub	dl,60h
 24569 000032B9 80EA60                  	sub	dl,'a'-1
 24570 000032BC 89FE                    	mov	si,di		; pointer to EXECPATH
 24571 000032BE 83C603                  	add	si,3		; Don't wipe out drive and root info
 24572 000032C1 B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24573 000032C4 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24574                                  			; DL = drive (0=default,1=A,etc.)
 24575                                  			; DS:SI	points to 64-byte buffer area
 24576 000032C6 E8D4F9                  	call	dstrlen		; Determine length of present info
 24577 000032C9 01CE                    	add	si,cx		; Don't copy over drive and root info
 24578 000032CB 4E                      	dec	si
 24579 000032CC 89F7                    	mov	di,si		; Point to end of target string
 24580 000032CE 5E                      	pop	si		; Restore pointer to begining of string
 24581 000032CF 83C603                  	add	si,3		; Point past drive letter, :, .
 24582 000032D2 59                      	pop	cx		; Restore pointer to end of string
 24583                                  path_cpy:
 24584 000032D3 07                      	pop	es
 24585 000032D4 29F1                    	sub	cx,si		; yields character count
 24586 000032D6 1E                      	push	ds		; time to switch segments
 24587 000032D7 FF36[6494]              	push	word [pathinfo+0]
 24588                                  				; string lives in this segment
 24589 000032DB 1F                      	pop	ds
 24590 000032DC FC                      	cld
 24591                                  
 24592                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24593                                  	; MSDOS 5.0 (& MSDOS 5.0)
 24594                                  	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
 24595                                  kloop:
 24596 000032DD AC                      	lodsb			;AN000;  3/3/KK
 24597 000032DE AA                      	stosb			;AN000;  3/3/KK
 24598 000032DF E802F1                  	call	testkanj	;AN000;  3/3/KK
 24599 000032E2 7410                    	jz	short _notkanj1	;AN000;  3/3/KK
 24600 000032E4 49                      	dec	cx		;AN000;  3/3/KK
 24601 000032E5 E307                    	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
 24602 000032E7 A4                      	movsb			;AN000;  3/3/KK
 24603 000032E8 49                      	dec	cx		;AN000;  3/3/KK
 24604 000032E9 83F901                  	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
 24605 000032EC 77EF                    	ja	short kloop	;AN000;  no.  3/3/KK
 24606                                  popdone:			;AN000;  3/3/KK
 24607 000032EE 1F                      	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
 24608 000032EF A0[6A94]                	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
 24609 000032F2 EB0C                    	jmp	short path_store
 24610                                  				;AN000;  3/3/KK
 24611                                  _notkanj1:
 24612                                  	; 26/04/2023
 24613 000032F4 E2E7                    	loop	kloop
 24614 000032F6 1F                      	pop	ds		; return to our segment
 24615 000032F7 4F                      	dec	di		; overwrite terminator
 24616 000032F8 A0[6A94]                	mov	al,[psep_char]	; with a pathname separator
 24617 000032FB 3A45FF                  	cmp	al,[di-1]
 24618 000032FE 7401                    	je	short path_success
 24619                                  path_store:
 24620 00003300 AA                      	stosb
 24621                                  path_success:
 24622 00003301 BE[6C94]                	mov	si,search_best_buf
 24623 00003304 31C9                    	xor	cx,cx
 24624                                  path_succ_loop:
 24625 00003306 AC                      	lodsb			; append winning filename to path
 24626 00003307 AA                      	stosb			; (including terminating null)	
 24627 00003308 08C0                    	or	al,al
 24628 0000330A 75FA                    	jnz	short path_succ_loop
 24629 0000330C 89E8                    	mov	ax,bp		; retrieve filetype code
 24630                                  path_exit:
 24631 0000330E 9D                      	popf
 24632 0000330F 5D                      	pop	bp
 24633 00003310 5F                      	pop	di
 24634 00003311 5E                      	pop	si		; chill out...
 24635 00003312 5A                      	pop	dx
 24636 00003313 59                      	pop	cx
 24637 00003314 5B                      	pop	bx
 24638 00003315 C3                      	retn
 24639                                  
 24640                                  ; =============== S U B	R O U T	I N E =======================================
 24641                                  
 24642                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 24643                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 24644                                  ;
 24645                                  ; ENTRY:
 24646                                  ; EXIT:
 24647                                  ; NOTE(S):
 24648                                  ;   *	Uses <psep_char>, defined in <path_search>.
 24649                                  
 24650                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24651                                  STORE_PCHAR:
 24652 00003316 50                      	push	ax
 24653 00003317 B02F                    	mov	al,'/'		; is the pathname-element separator
 24654 00003319 E878F3                  	call	pathchrcmp	; a regular slash?
 24655 0000331C 7402                    	jz	short STORE_SLASH
 24656                                  				; if yes, remember slash
 24657 0000331E B05C                    	mov	al,'\'
 24658                                  	; 18/03/2023
 24659                                  	;mov	[psep_char],al	; otherwise, remember back-slash
 24660                                  	;pop	ax
 24661                                  	;retn
 24662                                  STORE_SLASH:
 24663 00003320 A2[6A94]                	mov	[psep_char],al
 24664 00003323 58                      	pop	ax
 24665 00003324 C3                      	retn
 24666                                  
 24667                                  ; =============== S U B	R O U T	I N E =======================================
 24668                                  
 24669                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 24670                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 24671                                  ; additional separator to use for breaking up the path-string. Null is the
 24672                                  ; default. Once the user-string has been formed, search is invoked to see
 24673                                  ; what's out there.
 24674                                  ;
 24675                                  ; ENTRY:
 24676                                  ;   BH			--	additional terminator character
 24677                                  ;   SI			--	pointer into pathstring to be dissected
 24678                                  ;   DX			--	pointer to stripped filename
 24679                                  ; EXIT:
 24680                                  ;   AX			--	non-zero (file type), zero (nothing found)
 24681                                  ;   SI			--	moves along pathstring from call to call
 24682                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 24683                                  ;   [tpbuf]		--	clobbered
 24684                                  ; NOTE(S):
 24685                                  ;   *	Implicit in this code is the ability to specify when to search
 24686                                  ;	the current directory (if at all) through the PATH defined by
 24687                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 24688                                  ;	current directory before the bin and etc directories of drive c).
 24689                                  
 24690                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24691                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
 24692                                  	
 24693                                  path_crunch:
 24694 00003325 53                      	push	bx
 24695 00003326 51                      	push	cx
 24696 00003327 52                      	push	dx
 24697 00003328 57                      	push	di
 24698 00003329 56                      	push	si
 24699                                  	;pushf	; ** ; 18/03/2023
 24700 0000332A E8E9FF                  	call	STORE_PCHAR	; figure out pathname separator
 24701 0000332D BF[B593]                	mov	di,TPBUF	; destination of concatenated string
 24702 00003330 8B36[6894]              	mov	si,[pathinfo+4]	; "new" pointer to start with
 24703 00003334 8936[6694]              	mov	[pathinfo+2],si	; becomes "old" pointer
 24704 00003338 1E                      	push	ds		; save old segment pointer
 24705 00003339 FF36[6494]              	push	word [pathinfo+0]
 24706                                  				; replace with pointer to userpath's
 24707 0000333D 1F                      	pop	ds		; segment
 24708                                  	; 26/04/2023
 24709 0000333E 30C9                    	xor	cl,cl		;AN000; clear flag for later use 3/3/KK	
 24710                                  path_cr_copy:
 24711 00003340 AC                      	lodsb			; get a pathname byte
 24712 00003341 08C0                    	or	al,al		; check for terminator(s)
 24713 00003343 7414                    	jz	short path_seg	; null terminates segment & pathstring
 24714 00003345 38F8                    	cmp	al,bh
 24715 00003347 7410                    	je	short path_seg	; BH terminates a pathstring segment
 24716                                  	;
 24717                                  	; 18/03/2023
 24718                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 24719 00003349 E898F0                  	call	testkanj	;AN000; 3/3/KK
 24720 0000334C 7406                    	jz	short _notkanj2	;AN000; 3/3/KK
 24721 0000334E AA                      	stosb			;AN000; 3/3/KK
 24722 0000334F A4                      	movsb			;AN000; 3/3/KK
 24723 00003350 B101                    	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK	
 24724 00003352 EBEC                    	jmp	short path_cr_copy
 24725                                  _notkanj2:
 24726 00003354 30C9                    	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
 24727                                  	;
 24728 00003356 AA                      	stosb
 24729 00003357 EBE7                    	jmp	short path_cr_copy
 24730                                  
 24731                                  path_seg:
 24732 00003359 1F                      	pop	ds		; restore old data segment
 24733 0000335A 8936[6894]              	mov	[pathinfo+4],si	; save "new" pointer for next time
 24734 0000335E 88C3                    	mov	bl,al		; remember if we saw null or not...
 24735                                  				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 24736 00003360 31C0                    	xor	ax,ax		; in case nothing in pathstr...
 24737 00003362 81FF[B593]              	cmp	di,TPBUF	; was there really anything in pathstr?		
 24738 00003366 7421                    	je	short path_cr_leave
 24739                                  				; if nothing was copied, pathstr empty
 24740                                  path_cr_look:
 24741 00003368 A0[6A94]                	mov	al,[psep_char]	; form complete pathname
 24742                                  	;
 24743                                  	; 18/03/2023
 24744                                  	; MSDOS 6.0
 24745 0000336B 08C9                    	or	cl,cl ; *	;AN000; 3/3/KK
 24746 0000336D 7505                    	jnz	short path_cr_store
 24747                                  				;AN000; this is a trailing byte of ECS code 3/3/KK
 24748                                  	;
 24749 0000336F 3A45FF                  	cmp	al,[di-1]	; add pathname separator for suffix
 24750 00003372 7401                    	je	short path_cr_l1
 24751                                  path_cr_store:
 24752 00003374 AA                      	stosb
 24753                                  path_cr_l1:
 24754 00003375 89D6                    	mov	si,dx
 24755                                  path_cr_l2:
 24756 00003377 AC                      	lodsb			; tack the stripped filename onto
 24757 00003378 AA                      	stosb			; the end of the path, up to and
 24758 00003379 08C0                    	or	al,al		; including the terminating null
 24759 0000337B 75FA                    	jnz	short path_cr_l2
 24760 0000337D BA[B593]                	mov	dx,TPBUF	; and look for an appropriate file...	
 24761 00003380 C706[B994][CD80]        	mov	word [search_error],BADPMES_PTR
 24762                                  	;invoke search
 24763 00003386 E80900                  	call	PSEARCH		; results are in AX & search_best_buf
 24764                                  
 24765                                  	; 18/03/2023
 24766                                  ;path_cr_leave:
 24767                                  	;or	bl,bl		; did we finish off the pathstring?
 24768                                  	;jz	short path_cr_empty
 24769                                  	;			; null in BL means all gone...
 24770                                  	;popf	; **		; otherwise, plenty left
 24771                                  	;clc
 24772                                  	;jmp	short path_cr_exit
 24773                                  ;path_cr_empty:
 24774                                  	;popf	; **
 24775                                  	;stc
 24776                                  ;path_cr_exit:
 24777                                  
 24778                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24779                                  path_cr_leave:
 24780                                  	;popf ; ** ; 18/03/2023
 24781 00003389 80FB01                  	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
 24782                                  	
 24783                                  path_cr_exit:
 24784 0000338C 5E                      	pop	si
 24785 0000338D 5F                      	pop	di
 24786 0000338E 5A                      	pop	dx
 24787 0000338F 59                      	pop	cx
 24788 00003390 5B                      	pop	bx
 24789 00003391 C3                      	retn
 24790                                  
 24791                                  ;============================================================================
 24792                                  ; PATH2.ASM, MSDOS 6.0, 1991
 24793                                  ;============================================================================
 24794                                  ; 02/10/2018 - Retro DOS v3.0
 24795                                  
 24796                                  ;----------------------------------------------------------------------------
 24797                                  ;   SEARCH, when given a pathname, attempts to find a file with
 24798                                  ; one of the following extensions: .com, .exe, .bat (highest to
 24799                                  ; lowest priority). Where conflicts arise, the extension with
 24800                                  ; the highest priority is favored.
 24801                                  ; ENTRY:
 24802                                  ;   DX		--	pointer to null-terminated pathname
 24803                                  ;   fbuf	--	dma buffer for findfirst/next
 24804                                  ; EXIT:
 24805                                  ;   AX		--	8)  file found with .com extension
 24806                                  ;			4)  file found with .exe extension
 24807                                  ;			2)  file found with .bat extension
 24808                                  ;			0)  no such file to be found
 24809                                  ;   (if AX is non-zero:)
 24810                                  ;   [search_best]	identical to AX
 24811                                  ;   [search_best_buf]	null-terminated filename
 24812                                  ; NOTES:
 24813                                  ;   1) Requires caller to have allocated a dma buffer and executed a setdma.
 24814                                  ;---------------
 24815                                  ; CONSTANTS:
 24816                                  ;---------------
 24817                                  SEARCH_FILE_NOT_FOUND	EQU	0
 24818                                  SEARCH_COM		EQU	8
 24819                                  SEARCH_EXE		EQU	4
 24820                                  SEARCH_BAT		EQU	2
 24821                                  FNAME_LEN		EQU	8
 24822                                  FNAME_MAX_LEN		EQU	13
 24823                                  DOT			EQU	'.'
 24824                                  WILDCHAR		EQU	'?'
 24825                                  
 24826                                  
 24827                                  ; =============== S U B	R O U T	I N E =======================================
 24828                                  
 24829                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 24830                                  
 24831                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24832                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
 24833                                  	
 24834                                  PSEARCH:
 24835 00003392 51                      	push	cx
 24836 00003393 52                      	push	dx
 24837 00003394 57                      	push	di
 24838 00003395 56                      	push	si
 24839                                  	;pushf	; ** ; 18/03/2023
 24840 00003396 52                      	push	dx		; check drivespec (save pname ptr)
 24841 00003397 89D7                    	mov	di,dx		; working copy of pathname
 24842 00003399 BE[7994]                	mov	si,search_curdir_buf
 24843 0000339C 31D2                    	xor	dx,dx		; zero means current drive
 24844 0000339E 807D013A                	cmp	byte [di+1],':'	; is there a drive spec?
 24845 000033A2 7508                    	jne	short SEARCH_DIR_CHECK
 24846 000033A4 8A15                    	mov	dl,[di]		; get the drive byte
 24847 000033A6 80E2DF                  	and	dl,0DFh ; ~20h	; uppercase the sucker
 24848 000033A9 80EA40                  	sub	dl,'@' ; 40h	; and convert to drive number
 24849                                  SEARCH_DIR_CHECK:
 24850 000033AC B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24851 000033AF CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24852                                  			; DL = drive (0=default,1=A,etc.)
 24853                                  			; DS:SI	points to 64-byte buffer area
 24854 000033B1 5A                      	pop	dx		; directory? If we can't we'll		
 24855 000033B2 724C                    	jc	short SEARCH_INVALID_DRIVE
 24856                                  				; assume it's a bad drive...
 24857 000033B4 B91300                  	mov	cx,search_attr	; 13h
 24858                                  				; filetypes to search for
 24859 000033B7 B8004E                  	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 24860 000033BA CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 24861                                  			; CX = search attributes
 24862                                  			; DS:DX	-> ASCIZ filespec
 24863                                  			; (drive,path, and wildcards allowed)
 24864 000033BC 7249                    	jc	short SEARCH_NO_FILE
 24865 000033BE C606[6B94]00            	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
 24866 000033C3 C606[6C94]00            	mov	byte [search_best_buf],ANULL
 24867                                  				; 0 ; nothing's been found, yet
 24868                                  SEARCH_LOOP:
 24869 000033C8 E84300                  	call	SEARCH_FTYPE	; determine if .com, &c...
 24870 000033CB 3A06[6B94]              	cmp	al,[search_best]
 24871                                  				; better than what we've found so far?
 24872 000033CF 7E13                    	jle	short SEARCH_NEXT
 24873                                  				; no, look for another	
 24874 000033D1 A2[6B94]                	mov	[search_best],al
 24875                                  				; found something... save its code	
 24876                                  	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 24877                                  	;mov	si,FBUF_PNAME
 24878 000033D4 BE[5794]                	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
 24879 000033D7 BF[6C94]                	mov	di,search_best_buf
 24880 000033DA B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 24881 000033DD FC                      	cld
 24882 000033DE F3A4                    	rep	movsb		; save complete pathname representation
 24883 000033E0 3C08                    	cmp	al,SEARCH_COM	; 8
 24884                                  				; have we found the best of all?	
 24885 000033E2 740A                    	je	short SEARCH_DONE
 24886                                  SEARCH_NEXT:			; keep on looking
 24887 000033E4 B91300                  	mov	cx,search_attr ; 13h
 24888 000033E7 B8004F                  	mov	ax,Find_Next*256 ; 4F00h ; next match
 24889 000033EA CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 24890                                  			; [DTA]	= data block from
 24891                                  			; last AH = 4Eh/4Fh call
 24892 000033EC 73DA                    	jnc	short SEARCH_LOOP
 24893                                  SEARCH_DONE:			; it's all over with...
 24894 000033EE A0[6B94]                	mov	al,[search_best]
 24895                                  				; pick best to return with
 24896                                  	; 18/03/2023
 24897                                  	; MSDOS 6.0
 24898 000033F1 803E[258E]01            	cmp	byte [ext_entered],1
 24899                                  				;AN005; Did user request a specific ext?
 24900 000033F6 7411                    	je	short SEARCH_EXIT
 24901                                  				;AN005; no - exit
 24902 000033F8 A0[258E]                	mov	al,[ext_entered]
 24903                                  				;AN005; yes - get the real file type back
 24904 000033FB A2[6B94]                	mov	[search_best],al
 24905                                  				;AN005; save the real file type
 24906                                  	;
 24907 000033FE EB09                    	jmp	short SEARCH_EXIT
 24908                                  
 24909                                  SEARCH_INVALID_DRIVE:		; Tell the user path/drive
 24910 00003400 8B16[B994]              	mov	dx,[search_error]
 24911                                  				; appropriate error message
 24912 00003404 E83C1A                  	call	std_printf	; and pretend no file found
 24913                                  
 24914                                  SEARCH_NO_FILE:			; couldn't find a match
 24915                                  	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 24916                                  	; 18/03/2023
 24917 00003407 31C0                    	xor	ax,ax
 24918                                  SEARCH_EXIT:
 24919                                  	;popf	; ** ; 18/03/2023
 24920 00003409 5E                      	pop	si
 24921 0000340A 5F                      	pop	di
 24922 0000340B 5A                      	pop	dx
 24923 0000340C 59                      	pop	cx
 24924 0000340D C3                      	retn
 24925                                  
 24926                                  ; =============== S U B	R O U T	I N E =======================================
 24927                                  
 24928                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 24929                                  ;
 24930                                  ; ENTRY:
 24931                                  ;   fbuf    --	dma buffer containing filename
 24932                                  ; EXIT:
 24933                                  ;   AX	    --	file code, as given in search header
 24934                                  ; NOTE(S):
 24935                                  ;   *	Implicit assumption that NULL == search_file_not_found
 24936                                  
 24937                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24938                                  
 24939                                  SEARCH_FTYPE:
 24940 0000340E 57                      	push	di
 24941 0000340F 56                      	push	si
 24942                                  	;mov	ax,ANULL ; 0	; find the end of the filename
 24943                                  	; 18/02/2023
 24944 00003410 31C0                    	xor	ax,ax ; ax = 0		
 24945                                  	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 24946                                  	;mov	di,FBUF_PNAME
 24947 00003412 BF[5794]                	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
 24948 00003415 B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 24949 00003418 FC                      	cld
 24950 00003419 F2AE                    	repnz	scasb		; search for the terminating null
 24951 0000341B 7535                    	jnz	short FTYPE_EXIT
 24952                                  				; weird... no null byte at end
 24953 0000341D 83EF05                  	sub	di,5		; . + E + X + T + NULL
 24954                                  
 24955                                  	; Compare .COM
 24956                                  
 24957 00003420 BE[9F84]                	mov	si,comext ; ".COM"
 24958 00003423 89F8                    	mov	ax,di
 24959 00003425 A7                      	cmpsw
 24960 00003426 7508                    	jnz	short FTYPE_EXE
 24961 00003428 A7                      	cmpsw
 24962 00003429 7505                    	jnz	short FTYPE_EXE
 24963                                  	;mov	ax,8
 24964 0000342B B80800                  	mov	ax,SEARCH_COM	; success!
 24965 0000342E EB22                    	jmp	short FTYPE_EXIT
 24966                                  
 24967                                  	; Compare .EXE
 24968                                  FTYPE_EXE:			; still looking... now for '.exe'
 24969 00003430 89C7                    	mov	di,ax
 24970 00003432 BE[A384]                	mov	si,exeext ; ".EXE"
 24971 00003435 A7                      	cmpsw
 24972 00003436 7508                    	jnz	short FTYPE_BAT
 24973 00003438 A7                      	cmpsw
 24974 00003439 7505                    	jnz	short FTYPE_BAT
 24975                                  	;mov	ax,4
 24976 0000343B B80400                  	mov	ax,SEARCH_EXE	; success!
 24977 0000343E EB12                    	jmp	short FTYPE_EXIT
 24978                                  
 24979                                  	; Compare .BAT
 24980                                  FTYPE_BAT:			; still looking... now for '.bat'
 24981 00003440 89C7                    	mov	di,ax
 24982 00003442 BE[A784]                	mov	si,batext ; ".BAT"
 24983 00003445 A7                      	cmpsw
 24984 00003446 7508                    	jnz	short FTYPE_FAIL
 24985 00003448 A7                      	cmpsw
 24986 00003449 7505                    	jnz	short FTYPE_FAIL
 24987                                  	;mov	ax,2
 24988 0000344B B80200                  	mov	ax,SEARCH_BAT	; success!
 24989 0000344E EB02                    	jmp	short FTYPE_EXIT
 24990                                  
 24991                                  FTYPE_FAIL:			; file doesn't match what we need
 24992                                  	;mov	ax,ANULL ; 0
 24993                                  	; 18/03/2023
 24994 00003450 29C0                    	sub	ax,ax  ; ax = 0
 24995                                  FTYPE_EXIT:
 24996                                  	; 18/03/2023
 24997                                  	; MSDOS 6.0
 24998 00003452 803E[258E]01            	cmp	byte [ext_entered],1
 24999                                  				;AN005; was an extension entered?
 25000 00003457 740A                    	jz	short FTYPE_DONE
 25001                                  				;AN005; no - exit
 25002                                  	;cmp	ax,ANULL	;AN005; was any match found
 25003 00003459 21C0                    	and	ax,ax  ; ax = 0 ?
 25004 0000345B 7406                    	jz	short FTYPE_DONE
 25005                                  				;AN005; no - exit
 25006 0000345D A2[258E]                	mov	[ext_entered],al
 25007                                  				;AN005; save the match type found
 25008 00003460 B80800                  	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
 25009                                  FTYPE_DONE:
 25010 00003463 5E                      	pop	si
 25011 00003464 5F                      	pop	di
 25012 00003465 C3                      	retn
 25013                                  
 25014                                  ; =============== S U B	R O U T	I N E =======================================
 25015                                  
 25016                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 25017                                  ; replacing any extension with wildcards.
 25018                                  ;
 25019                                  ; ENTRY:
 25020                                  ;	BX	--	maximum length of destination buffer
 25021                                  ;	DS:SI	--	address of destination buffer
 25022                                  ;	argv[0] --	command name to be stripped
 25023                                  ; EXIT:
 25024                                  ;	CF	--	set if failure, clear if successful
 25025                                  ; NOTE(S):
 25026                                  
 25027                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25028                                  
 25029                                  STRIP:
 25030 00003466 50                      	push	ax
 25031 00003467 53                      	push	bx
 25032 00003468 51                      	push	cx
 25033 00003469 52                      	push	dx
 25034 0000346A 57                      	push	di
 25035 0000346B 56                      	push	si
 25036                                  	;pushf	; ** ; 18/03/2023
 25037                                  		
 25038                                  	; 05/05/2023
 25039                                  	; MSDOS 6.0
 25040 0000346C C606[258E]01            	mov	byte [ext_entered],1
 25041                                  				;AN005; assume no extension on file name
 25042                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25043                                  	;mov	dx,[ARG_ARGV]
 25044                                  	;mov	dx,ds:arg.argv[0].argpointer
 25045                                  				; save pointer to beginning of argstring
 25046                                  	;mov	dx,[ARGV0_ARGPOINTER]
 25047 00003471 8B16[6F8E]              	mov	dx,[ARG+ARGV_ELE.argpointer]
 25048                                  	;mov	di,ds:arg.argv[0].argstartel
 25049                                  				; beginning of last pathname element
 25050                                  	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 25051 00003475 8B3E[728E]              	mov	di,[ARG+ARGV_ELE.argstartel]
 25052 00003479 803D00                  	cmp	byte [di],0	; *STARTEL == NULL means no command
 25053 0000347C 743D                    	je	short STRIP_ERROR
 25054 0000347E 89D1                    	mov	cx,dx		; compute where end of argstring lies
 25055                                  	;add	cx,ds:arg.argv[0].arglen
 25056                                  	;add	cx,[ARGV0_ARGLEN]
 25057 00003480 030E[748E]              	add	cx,[ARG+ARGV_ELE.arglen]
 25058 00003484 29F9                    	sub	cx,di		; and then find length of last element
 25059 00003486 41                      	inc	cx		; include null as well
 25060 00003487 B02E                    	mov	al,'.'
 25061                                  	;mov	al,DOT		; let's find the filetype extension
 25062 00003489 FC                      	cld
 25063 0000348A F2AE                    	repnz	scasb		; wind up pointing to either null or dot
 25064                                  
 25065                                  	; 18/03/2023
 25066                                  	; MSDOS 6.0
 25067 0000348C E307                    	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
 25068 0000348E B000                    	mov	al,0 ; 18/03/2023
 25069                                  	;mov	byte [ext_entered],0
 25070 00003490 A2[258E]                	mov	[ext_entered],al
 25071                                  				;AN005; we found an extension
 25072                                  	;;mov	al,ANULL	;AN005; continue scanning until the
 25073                                  	;mov	al,0
 25074 00003493 F2AE                    	repnz	scasb		;AN005; end of line is reached.
 25075                                  PROCESS_EXT:
 25076                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25077 00003495 89F9                    	mov	cx,di		; pointer to end of argstring yields
 25078 00003497 29D1                    	sub	cx,dx		; number of bytes to be copied
 25079 00003499 83EB04                  	sub	bx,4		; can argstring fit into dest. buffer?
 25080 0000349C 39D9                    	cmp	cx,bx
 25081 0000349E 7F1B                    	jg	short STRIP_ERROR
 25082                                  				; if not, we must have a bad pathname
 25083 000034A0 89F7                    	mov	di,si		; destination buffer
 25084 000034A2 89D6                    	mov	si,dx		; source is beginning of pathname
 25085 000034A4 FC                      	cld
 25086 000034A5 F3A4                    	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 25087                                  
 25088                                  	; 18/03/2023
 25089                                  	; MSDOS 6.0
 25090 000034A7 803E[258E]01            	cmp	byte [ext_entered],1
 25091                                  				;AN005; if an extension was entered
 25092 000034AC 750A                    	jne	short SKIP_WILDS
 25093                                  				;AN005;    don't set up wildcard ext.
 25094                                  
 25095                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25096 000034AE 4F                      	dec	di		; overwrite null or dot
 25097 000034AF AA                      	stosb			; with a dot
 25098 000034B0 B03F                    	mov	al,'?'
 25099                                  	;mov	al,WILDCHAR	; now add wildcards
 25100 000034B2 AA                      	stosb
 25101 000034B3 AA                      	stosb
 25102 000034B4 AA                      	stosb
 25103 000034B5 B000                    	mov	al,0
 25104                                  	;mov	al,ANULL	; and a terminating null	
 25105 000034B7 AA                      	stosb
 25106                                  SKIP_WILDS:
 25107                                  	;popf	; ** ; 18/03/2023
 25108 000034B8 F8                      	clc
 25109 000034B9 EB01                    	jmp	short STRIP_EXIT ; chill out...
 25110                                  
 25111                                  STRIP_ERROR:
 25112                                  	;popf	; ** ; 18/03/2023
 25113 000034BB F9                      	stc
 25114                                  STRIP_EXIT:
 25115 000034BC 5E                      	pop	si
 25116 000034BD 5F                      	pop	di
 25117 000034BE 5A                      	pop	dx
 25118 000034BF 59                      	pop	cx
 25119 000034C0 5B                      	pop	bx
 25120 000034C1 58                      	pop	ax
 25121 000034C2 C3                      	retn
 25122                                  
 25123                                  ; =============== S U B	R O U T	I N E =======================================
 25124                                  
 25125                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 25126                                  ;
 25127                                  ; structure in newly allocated memory. The argv[] structure is found at the
 25128                                  ; beginning of this area. The caller indicates how much extra space is
 25129                                  ; needed in the resulting structure; Save_Args returns a segment number and
 25130                                  ; an offset into that area, indicating where the caller may preserve its own
 25131                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 25132                                  ; ENTRY:
 25133                                  ;   BX	    --	size (in bytes) of extra area to allocate
 25134                                  ; EXIT:
 25135                                  ;   AX	    --	segment of new area.
 25136                                  ;   CF	    --	set if unable to save a copy.
 25137                                  ; NOTE(S):
 25138                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 25139                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 25140                                  ;	paragraphs.
 25141                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 25142                                  ;	as the caller of Save_Args requests.
 25143                                  ;   3)	AX is undefined if CF indicates an error.
 25144                                  
 25145                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25146                                  
 25147                                  SAVE_ARGS:
 25148 000034C3 53                      	push	bx
 25149 000034C4 51                      	push	cx
 25150 000034C5 52                      	push	dx
 25151 000034C6 57                      	push	di
 25152 000034C7 56                      	push	si
 25153 000034C8 55                      	push	bp
 25154                                  	; 01/05/2023
 25155                                  	; 26/04/2023
 25156                                  	;pushf ; **
 25157                                  	;add	bx,1363		; space for arg structure, round up
 25158 000034C9 81C35305                	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 25159 000034CD B104                    	mov	cl,4		; to paragraph size and convert
 25160 000034CF D3EB                    	shr	bx,cl		; size in bytes to size in paragraphs
 25161 000034D1 B80048                  	mov	ax,ALLOC*256 ; 4800h
 25162 000034D4 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 25163                                  			; BX = number of 16-byte paragraphs desired
 25164 000034D6 7242                    	jc	short SAVE_ERROR ; ***
 25165 000034D8 89C5                    	mov	bp,ax		; save segment id
 25166 000034DA 06                      	push	es		; save TRANGROUP address
 25167 000034DB 8EC0                    	mov	es,ax		; switch to new memory segment
 25168                                  	; assume es:nothing
 25169                                  	;mov	cx,1348		; get back structure size
 25170 000034DD B94405                  	mov	cx,ARG_UNIT.SIZE
 25171 000034E0 31FF                    	xor	di,di		; destination is new memory area
 25172                                  	;mov	si,ARG_ARGV
 25173 000034E2 BE[6F8E]                	mov	si,ARG		; source is arg structure
 25174 000034E5 F3A4                    	rep	movsb		; move that sucker!
 25175                                  	;mov	cx,arg.argvcnt 	; adjust argv pointers
 25176                                  	;mov	cx,[ARG_ARGVCNT]
 25177 000034E7 8B0E[2F91]              	mov	cx,[ARG+ARG_UNIT.argvcnt]
 25178 000034EB 31C0                    	xor	ax,ax		; base address for argv_calc
 25179                                  
 25180                                  ;	Bugbug:	What did they mean by this?
 25181                                  ;	Note that the replacement line produces exactly the same code.
 25182                                  ;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 25183                                  ;	mov	SI, OFFSET TRANGROUP:arg
 25184                                  
 25185                                  	;mov	si,ARG_ARGV
 25186 000034ED BE[6F8E]                	mov	si,ARG	
 25187                                  SAVE_PTR_LOOP:
 25188 000034F0 49                      	dec	cx		; exhausted all args?
 25189 000034F1 7C24                    	jl	short SAVE_DONE
 25190 000034F3 89CB                    	mov	bx,cx		; get arg index and
 25191 000034F5 E8A0FC                  	call	argv_calc	; convert to a pointer
 25192                                  	;mov	dx,ds:arg.argv[bx].argpointer
 25193                                  	;mov	dx,[ARG_ARGV+bx]
 25194 000034F8 8B97[6F8E]              	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 25195 000034FC 29F2                    	sub	dx,si		; adjust argpointer
 25196                                  	;mov	es:argv[BX].argpointer,dx
 25197                                  	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 25198 000034FE 268917                  	mov	[es:bx],dx
 25199                                  	;mov	dx,ds:arg.argv[bx].argstartel
 25200                                  	;mov	dx,[ARGV0_ARGSTARTEL+bx]
 25201 00003501 8B97[728E]              	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 25202 00003505 29F2                    	sub	dx,si		; and adjust argstartel
 25203                                  	;mov	es:argv[bx].argstartel,dx
 25204                                  	;mov	[es:bx+3],dx
 25205 00003507 26895703                	mov	[es:bx+ARGV_ELE.argstartel],dx
 25206                                  	;mov	dx,ds:arg.argv[bx].arg_ocomptr
 25207                                  	;mov	dx,[ARGV0_OCOMPTR+bx]
 25208 0000350B 8B97[788E]              	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 25209 0000350F 29F2                    	sub	dx,si		; and adjust arg_ocomptr
 25210                                  	;mov	es:argv[bx].arg_ocomptr,dx
 25211                                  	;mov	[es:bx+9],dx
 25212 00003511 26895709                	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 25213 00003515 EBD9                    	jmp	short SAVE_PTR_LOOP
 25214                                  SAVE_DONE:
 25215 00003517 07                      	pop	es		; back we go to TRANGROUP
 25216                                  	; assume es:nothing
 25217 00003518 89E8                    	mov	ax,bp		; restore segment id
 25218                                  	; 26/04/2023
 25219                                  	; cf = 0 ; *
 25220                                  	;jmp	short SAVE_OK
 25221                                  
 25222                                  	; 26/04/2023
 25223                                  ;SAVE_ERROR:
 25224                                  ;	; 26/04/2023
 25225                                  ;	;popf ; **
 25226                                  ;	stc
 25227                                  ;	jmp	short SAVE_EXIT
 25228                                  
 25229                                  SAVE_OK:
 25230                                  	; 26/04/2023
 25231                                  	;popf ; **
 25232                                  	; 26/04/2023
 25233                                  	; cf = 0 ; *
 25234                                  	;clc
 25235                                  SAVE_EXIT:
 25236                                  SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
 25237 0000351A 5D                      	pop	bp
 25238 0000351B 5E                      	pop	si
 25239 0000351C 5F                      	pop	di
 25240 0000351D 5A                      	pop	dx
 25241 0000351E 59                      	pop	cx
 25242 0000351F 5B                      	pop	bx
 25243                                  answ_no:	; 26/04/2023
 25244 00003520 C3                      	retn
 25245                                  
 25246                                  ;============================================================================
 25247                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 25248                                  ;============================================================================
 25249                                  ; 02/10/2018 - Retro DOS v3.0
 25250                                  
 25251                                  ; Title	COMMAND Language midifiable Code Transient
 25252                                  
 25253                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 25254                                  
 25255                                  ; =============== S U B	R O U T	I N E =======================================
 25256                                  
 25257                                  ; ****************************************************************
 25258                                  ; *
 25259                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 25260                                  ; *
 25261                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25262                                  ; *		 user for Y/N if necessary. If an error occurs,
 25263                                  ; *		 set up an error message and go to CERROR.
 25264                                  ; *
 25265                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 25266                                  ; *		 Current directory set to entered directory
 25267                                  ; *
 25268                                  ; * OUTPUT:	 none
 25269                                  ; *
 25270                                  ; ****************************************************************
 25271                                  ;
 25272                                  ; ARE YOU SURE prompt when deleting *.*
 25273                                  
 25274                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25275                                  
 25276                                  notest2:
 25277 00003521 B90B00                  	mov	cx,11
 25278 00003524 BE5D00                  	mov	si,FCB+1 ; 5Dh
 25279                                  ambspec:
 25280 00003527 AC                      	lodsb
 25281 00003528 3C3F                    	cmp	al,'?'
 25282 0000352A 7502                    	jne	short allfil
 25283 0000352C E2F9                    	loop	ambspec
 25284                                  allfil:
 25285                                  	; 19/03/2023
 25286                                  	;cmp	cx,0
 25287 0000352E 09C9                    	or	cx,cx
 25288 00003530 752E                    	jnz	short noprmpt
 25289                                  askagn:	
 25290 00003532 BA[5480]                	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
 25291 00003535 E80B19                  	call	std_printf
 25292 00003538 BE8000                  	mov	si,80h
 25293 0000353B 89F2                    	mov	dx,si
 25294 0000353D C7047800                	mov	word [si],120	; zero length
 25295                                  	;mov	ax,0C0Ah
 25296 00003541 B80A0C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
 25297 00003544 CD21                    	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 25298                                  			; AL must be 01h,06h,07h,08h or 0Ah.
 25299 00003546 AD                      	lodsw
 25300 00003547 08E4                    	or	ah,ah
 25301 00003549 74E7                    	jz	short askagn
 25302 0000354B E8B8F0                  	call	scanoff
 25303                                  	; 19/03/2023
 25304                                  	; MSDOS 6.0
 25305 0000354E E80C02                  	call	char_in_xlat	; Convert to upper case
 25306                                  	;retc			; return if function not supported
 25307                                  	; 19/03/2023
 25308                                  	;jnc	short check_yn
 25309                                  ;answ_no:
 25310                                  	;retn
 25311 00003551 72CD                    	jc	short answ_no
 25312                                  
 25313                                  	; 19/03/2023
 25314                                  	; AL = 0 if it was (country depended) NO character
 25315                                  	; AL = 1 if it was (country depenced) YES character
 25316                                  
 25317                                  	; MSDOS 3.3
 25318                                  	;call	UPCONV
 25319                                  
 25320                                  	; 19/03/2023	
 25321                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25322                                  	;cmp	al,[CAPITAL_N]
 25323                                  	;jne	short CHECK_Y
 25324                                  	;retn
 25325                                  ;CHECK_Y:
 25326                                  	;cmp	al,[CAPITAL_Y]
 25327                                  	;pushf
 25328                                  	;call	CRLF2
 25329                                  	;popf
 25330                                  	;jne	short ASKAGN
 25331                                  
 25332                                  check_yn:
 25333                                  	; 19/03/2023
 25334                                  	;cmp	al,0	; NO character
 25335 00003553 08C0                    	or	al,al
 25336 00003555 74C9                    	jz	short answ_no
 25337                                  	;cmp	al,1	 ;YES character
 25338 00003557 FEC8                    	dec	al ; 1 -> 0 --> zf = 1
 25339 00003559 9C                      	pushf
 25340 0000355A E89CF0                  	call	CRLF2
 25341 0000355D 9D                      	popf
 25342 0000355E 75D2                    	jnz	short askagn
 25343                                  noprmpt:
 25344 00003560 B413                    	mov	ah,FCB_Delete ; 13h
 25345 00003562 BA5C00                  	mov	dx,FCB ; 5Ch
 25346 00003565 CD21                    	int	21h	; DOS -	DELETE FILE via	FCB
 25347                                  			; DS:DX	-> FCB with filename field filled with
 25348                                  			; template for deletion ('?' wildcard allowed,but not '*')
 25349                                  			; Return: AL = 00h file	found,FFh file	not found
 25350 00003567 FEC0                    	inc	al
 25351 00003569 7403                    	jz	short eraerr
 25352                                  	; 26/04/2023
 25353                                  	;call	RestUDir
 25354                                  ;answ_no:
 25355                                  	;retn
 25356 0000356B E945EF                  	jmp	RestUDir ; 26/04/2023
 25357                                  
 25358                                  	; 19/03/2023
 25359                                  	; MSDOS 6.0
 25360                                  eraerr:
 25361                                  	;invoke	set_ext_error_msg
 25362                                  				;AN022; set up the extended error
 25363 0000356E E89CE7                  	call	Set_Ext_Error_Msg
 25364 00003571 52                      	push	dx		;AN022; save message
 25365                                  	;invoke	RESTUDIR
 25366 00003572 E83EEF                  	call	RestUDir
 25367 00003575 5A                      	pop	dx		;AN022; restore message
 25368                                  	
 25369 00003576 833E[757F]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 25370                                  				;AN022; convert no more files to
 25371 0000357B 7506                    	jne	short cerrorj2	;AN022;  file not found
 25372 0000357D C706[757F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
 25373                                  				;AN000; get message number in control block
 25374                                  cerrorj2:
 25375 00003583 E9F4F3                  	jmp	cerror
 25376                                  	
 25377                                  	; 19/03/2023
 25378                                  	; MSDOS 3.3
 25379                                  ;ERAERR:	
 25380                                  	;mov	ah,Set_DMA ; 1Ah
 25381                                  	;mov	dx,FCB ; 5Ch
 25382                                  	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 25383                                  	;			; DS:DX	-> disk	transfer buffer
 25384                                  	;mov	ah,Dir_Search_First ; 11h
 25385                                  	;int	21h		; DOS -	SEARCH FIRST USING FCB
 25386                                  	;			; DS:DX	-> FCB
 25387                                  	;push	ax
 25388                                  	;call	RESTUDIR
 25389                                  	;pop	ax
 25390                                  	;mov	dx,FNOTFOUNDPTR
 25391                                  	;inc	al
 25392                                  	;jz	short CERRORJ
 25393                                  	;mov	dx,ACCDENPTR
 25394                                  	;jmp	CERROR
 25395                                  
 25396                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25397                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h
 25398                                  
 25399                                  ; ****************************************************************
 25400                                  ; *
 25401                                  ; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
 25402                                  ; *
 25403                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25404                                  ; *		 user for Y/N where necessary. If an error occurs
 25405                                  ; *		 set up and error message and transfer control
 25406                                  ; *		 to CERROR.
 25407                                  ; *
 25408                                  ; * INPUT:	 FCB at 5Ch set up with filename(s) entered
 25409                                  ; *		 Current directory set to entered directory
 25410                                  ; *
 25411                                  ; * OUTPUT:	 none
 25412                                  ; *
 25413                                  ; ****************************************************************
 25414                                  
 25415                                  	; 19/03/2023
 25416                                  slashp_erase:				;AN000; entry point
 25417                                  	;invoke	build_dir_string	;AN000; set up current directory string for output
 25418 00003586 E8DDE8                  	call	build_dir_string
 25419                                  
 25420 00003589 B41A                    	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
 25421                                  	;mov	dx,offset trangroup:destdir
 25422 0000358B BA[A68B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25423 0000358E CD21                    	int	21h			;AN000;
 25424                                  
 25425                                  	;mov	ah,11h
 25426 00003590 B411                    	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
 25427 00003592 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
 25428 00003595 CD21                    	int	21h			;AN000;
 25429 00003597 FEC0                    	inc	al			;AN000; did an error occur
 25430                                  	;jz	short eraerr		;AN022; go to error exit
 25431                                  	; 26/04/2023
 25432 00003599 7502                    	jnz	short delete_prompt_loop
 25433                                  
 25434                                  	; 26/04/2023
 25435                                  stop_del:
 25436 0000359B EBD1                    	jmp	short eraerr		;AN022; go to error exit - need long jmp
 25437                                  
 25438                                  delete_prompt_loop:			;AN000;
 25439                                  	;mov	si,offset trangroup:destdir+1
 25440 0000359D BE[A78B]                	mov	si,DESTDIR+1		;AN000; set up FCB as source
 25441                                  	;mov	di,offset trangroup:dest
 25442 000035A0 BF[768B]                	mov	di,DEST			;AN000; set up dest as target
 25443 000035A3 A0[E58A]                	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
 25444 000035A6 AA                      	stosb				;AN000;   of DEST
 25445                                  	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
 25446 000035A7 E87BF0                  	call	FCB_TO_ASCZ
 25447                                  
 25448                                  slashp_askagn:				;AN000;
 25449 000035AA E84CF0                  	call	CRLF2			;AN000; print out carriage return, line feed
 25450                                  	;mov	dx,offset trangroup:bwdbuf
 25451 000035AD BA[E98B]                	mov	dx,BWDBUF		;AN000; print out current directory string
 25452 000035B0 89D3                    	mov	bx,dx			;AN000; get string pointer in bx
 25453 000035B2 807F0300                	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
 25454                                  					;AN000; see if only D:\,0
 25455 000035B6 7504                    	jnz	short not_del_root	;AN000; no continue
 25456 000035B8 C6470200                	mov	byte [bx+2],END_OF_LINE_OUT ; 0
 25457                                  					;AN000; yes, get rid of \ ;
 25458                                  not_del_root:				;AN000;
 25459 000035BC 8916[D08C]              	mov	[string_ptr_2],dx 	;AN000;
 25460                                  	;mov	dx,offset trangroup:string_buf_ptr
 25461 000035C0 BA[3C81]                	mov	dx,string_buf_ptr	;AN000;
 25462                                  	;invoke	std_printf		;AN000;
 25463 000035C3 E87D18                  	call	std_printf
 25464                                  	;mov	dx,offset trangroup:dest
 25465 000035C6 BA[768B]                	mov	dx,DEST			;AN000; print out file name string
 25466 000035C9 8916[D08C]              	mov	[string_ptr_2],dx 	;AN000;
 25467                                  	;mov	dx,offset trangroup:string_buf_ptr
 25468 000035CD BA[3C81]                	mov	dx,string_buf_ptr	;AN000;
 25469                                  	;invoke	std_printf		;AN000;
 25470 000035D0 E87018                  	call	std_printf
 25471                                  	;mov	dx,offset trangroup:Del_Y_N_Ptr
 25472 000035D3 BA[5180]                	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
 25473                                  	;invoke	std_printf		;AN000;
 25474 000035D6 E86A18                  	call	std_printf
 25475                                  
 25476                                  ;;M029	mov	si,80H			;AN000; set up buffer for input
 25477                                  ;;M029	mov	dx,si			;AN000;
 25478                                  ;;M029	mov	word ptr [si],combuflen ;AN000;
 25479                                  ;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
 25480                                  ;;M029	int	21h			;AN000; get input from the user
 25481                                  ;;M029	lodsw				;AN000;
 25482                                  ;;M029	or	ah,ah			;AN000; was a character entered?
 25483                                  ;;M029	jz	short slashp_askagn	;AN000; no - ask again
 25484                                  ;;M029	invoke	scanoff 		;AN000; scan off leading delimiters
 25485                                  
 25486                                  ;	Get a single character input.
 25487                                  
 25488                                  	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
 25489                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
 25490 000035D9 B8010C                  	mov	ax,0C01h
 25491 000035DC CD21                    	int	21h			;M029
 25492                                  
 25493 000035DE E87C01                  	call	char_in_xlat		;AN000; yes - upper case it
 25494                                  	;retc				;AN000; return if function not supported
 25495                                  	; 19/03/2023
 25496 000035E1 7301                    	jnc	short slashp_check_yn
 25497                                  slashp_ans_no:
 25498 000035E3 C3                      	retn
 25499                                  
 25500                                  slashp_check_yn:
 25501                                  	; 19/03/2023
 25502                                  	; AL = 0 if it was (country depended) NO character
 25503                                  	; AL = 1 if it was (country depenced) YES character
 25504                                  
 25505                                  	;cmp	al,capital_n		;AN000; was it no?
 25506                                  	;cmp	al,0
 25507 000035E4 20C0                    	and	al,al ; 0
 25508 000035E6 7420                    	jz	short next_del_file	;AN000; yes - don't delete file
 25509                                  	;cmp	al,capital_y		;AN000; was it yes?
 25510                                  	;cmp	al,1
 25511 000035E8 FEC8                    	dec	al  ; 1-> 0 --> zf = 1
 25512                                  	;jz	short delete_this_file	;AN000; yes - delete the file
 25513                                  	;jmp	short slashp_askagn	;AN000; it was neither - ask again
 25514                                  	; 19/03/2023
 25515 000035EA 75BE                    	jnz	short slashp_askagn
 25516                                  
 25517                                  delete_this_file:			;AN000;
 25518 000035EC B413                    	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
 25519                                  	;mov	dx,offset trangroup:destdir
 25520 000035EE BA[A68B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25521 000035F1 CD21                    	int	21h			;AN000;
 25522 000035F3 FEC0                    	inc	al			;AN000; did an error occur?
 25523 000035F5 7511                    	jnz	short next_del_file	;AN000; no - get next file
 25524                                  ;
 25525                                  ;M041; Begin changes
 25526                                  ; We got an error deleting the file. If this is access denied, we can go on
 25527                                  ;to the next file after printing an error message.
 25528                                  ;
 25529                                  	;invoke	Get_ext_error_number	;see what error we got
 25530 000035F7 E823E7                  	call	get_ext_error_number
 25531 000035FA 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 25532                                  					;is it access denied?
 25533 000035FD 759C                    	jne	short stop_del		;no, some other error
 25534                                  	;invoke	CrLf2			;print a CR-LF
 25535 000035FF E8F7EF                  	call	CRLF2
 25536                                  	;invoke set_ext_error_msg	;error message
 25537 00003602 E808E7                  	call	Set_Ext_Error_Msg
 25538                                  	;invoke	std_eprintf		;"Access denied"
 25539 00003605 E83318                  	call	std_eprintf
 25540                                  	; 26/04/2023
 25541                                  	;jmp	short next_del_file	;try next file
 25542                                  	; 26/04/2023
 25543                                  ;stop_del:
 25544                                  ;;
 25545                                  ;;M041; End changes
 25546                                  ;;
 25547                                  ;	jmp	eraerr			;AN022; go to error exit - need long jmp
 25548                                  
 25549                                  next_del_file:				;AN000;
 25550                                  ;
 25551                                  ; M050 - begin
 25552                                  ; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
 25553                                  ;       with /protect+ and /light+ makes it intercept all
 25554                                  ;       deletes. This hook does not save and restore the DTA correctly.
 25555                                  ;       They save the DWORD in a WORD by mistake! They save both the
 25556                                  ;       segment and the offset in the SAME variable (WORD)!!!
 25557                                  ;
 25558 00003608 B41A                    	mov	ah,Set_DMA ; 1Ah
 25559                                  	;mov	dx,offset trangroup:destdir
 25560 0000360A BA[A68B]                	mov	dx,DESTDIR
 25561 0000360D CD21                    	int	21h
 25562                                  ;
 25563                                  ; M050 - end
 25564                                  
 25565 0000360F B412                    	mov	ah,Dir_Search_Next ; 12h
 25566                                  					;AN000; search for another file
 25567 00003611 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000;
 25568 00003614 CD21                    	int	21h			;AN000;
 25569 00003616 FEC0                    	inc	al			;AN000; was a file found?
 25570                                  	;jz	short slash_p_exit	;AN000; no - exit
 25571                                  	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
 25572                                  	; 26/04/2023
 25573 00003618 7583                    	jnz	short delete_prompt_loop
 25574                                  
 25575                                  slash_p_exit:
 25576                                  	;invoke	get_ext_error_number	;AN022; get the extended error number
 25577 0000361A E800E7                  	call	get_ext_error_number
 25578 0000361D 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
 25579 00003620 7403                    	jz	short good_erase_exit 	;AN022; yes - clean exit
 25580 00003622 E938E4                  	jmp	extend_setup		;AN022; go issue error message
 25581                                  
 25582                                  good_erase_exit:
 25583                                  	;invoke	restudir		;AN000; we're finished - restore user's dir
 25584 00003625 E88BEE                  	call	RestUDir
 25585                                  	;call	CRLF2			;AN000; print out carriage return, line feed
 25586                                  	;retn				;AN000; exit
 25587                                  	; 19/03/2023
 25588 00003628 E9CEEF                  	jmp	CRLF2
 25589                                  
 25590                                  ; =============== S U B	R O U T	I N E =======================================
 25591                                  
 25592                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 25593                                  
 25594                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25595                                  _ECHO:
 25596 0000362B E89900                  	call	ON_OFF
 25597 0000362E 7212                    	jb	short DOEMES
 25598 00003630 8E1E[E08A]              	mov	ds,[RESSEG]
 25599 00003634 7506                    	jnz	short ECH_OFF
 25600 00003636 800E[A001]01            	or	byte [EchoFlag],1
 25601 0000363B C3                      	retn
 25602                                  
 25603                                  ECH_OFF:
 25604 0000363C 8026[A001]FE            	and	byte [EchoFlag],0FEh
 25605 00003641 C3                      	retn
 25606                                  
 25607                                  	; 19/03/2023
 25608                                  	; MSDOS 6.0 (& MSDOS 5.0)
 25609                                  ;CERRORJ:
 25610                                  	;jmp	cerror
 25611                                  
 25612                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 25613                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 25614                                  
 25615                                  DOEMES:
 25616                                  	; 19/03/2023
 25617                                  	; MSDOS 6.0
 25618                                  	;cmp	cl,0		;AC000; was anything on the line?
 25619 00003642 20C9                    	and	cl,cl
 25620 00003644 7409                    	jz	short PECHO	; just display current state.
 25621 00003646 BA8200                  	mov	dx,82h		; Skip one char after "ECHO"
 25622 00003649 E806F0                  	call	CRPRINT
 25623 0000364C E9AAEF                  	jmp	CRLF2
 25624                                  
 25625                                  	; 19/03/2023
 25626                                  	; MSDOS 3.3
 25627                                  	;call	MOVE_TO_FIRST_ARG
 25628                                  	;jz	short PECHO
 25629                                  	;mov	dx,82h
 25630                                  	;call	CRPRINT
 25631                                  	;jmp	CRLF2
 25632                                  
 25633                                  PECHO:
 25634                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25635 0000364F 8E1E[E08A]              	mov	ds,[RESSEG]
 25636 00003653 8A1E[A001]              	mov	bl,[EchoFlag]
 25637 00003657 0E                      	push	cs
 25638 00003658 1F                      	pop	ds
 25639 00003659 80E301                  	and	bl,1
 25640 0000365C BA[F880]                	mov	dx,EchoMes_Ptr
 25641 0000365F EB24                    	jmp	short PYN
 25642                                  
 25643                                  ; ---------------------------------------------------------------------------
 25644                                  
 25645                                  	; 19/03/2023
 25646                                  	; MSDOS 3.3
 25647                                  CERRORJ:
 25648 00003661 E916F3                  	jmp	cerror
 25649                                  
 25650                                  ; =============== S U B	R O U T	I N E =======================================
 25651                                  
 25652                                  	; 19/03/2023
 25653                                  	; MSDOS 3.3
 25654                                  ;MOVE_TO_FIRST_ARG:
 25655                                  	;mov	si,81h
 25656                                  	;call	SCANOFF
 25657                                  	;cmp	al,0Dh
 25658                                  	;retn
 25659                                  
 25660                                  ; =============== S U B	R O U T	I N E =======================================
 25661                                  
 25662                                  CNTRLC:
 25663 00003664 E86000                  	call	ON_OFF
 25664 00003667 B80133                  	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
 25665 0000366A 720C                    	jc	short PCNTRLC
 25666 0000366C 7505                    	jnz	short CNTRLC_OFF
 25667 0000366E B201                    	mov	dl,1
 25668 00003670 CD21                    	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 25669                                  			; AL = 00h get state / 01h set state / 02h set AND get
 25670                                  			; DL = 00h for OFF or 01h for ON
 25671 00003672 C3                      	retn
 25672                                  
 25673                                  ; ---------------------------------------------------------------------------
 25674                                  
 25675                                  CNTRLC_OFF:
 25676 00003673 30D2                    	xor	dl,dl
 25677 00003675 CD21                    	int	21h		; Turn off ^C check
 25678 00003677 C3                      	retn
 25679                                  
 25680                                  ; ---------------------------------------------------------------------------
 25681                                  
 25682                                  PCNTRLC:
 25683                                  	; 19/03/2023
 25684                                  	; MSDOS 6.0
 25685                                  	;cmp	cl,0		;AC000; rest of line blank?
 25686 00003678 08C9                    	or	cl,cl
 25687 0000367A 75E5                    	jnz	short CERRORJ 	; no, oops!
 25688                                  
 25689                                  	; 19/03/2023
 25690                                  	; MSDOS 3.3
 25691                                  	;call	MOVE_TO_FIRST_ARG
 25692                                  	;jnz	short CERRORJ
 25693                                  ;pccont:
 25694                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25695 0000367C 30C0                    	xor	al,al
 25696 0000367E CD21                    	int	21h		; get Ctrl-Break state (ah=33h)
 25697 00003680 88D3                    	mov	bl,dl
 25698 00003682 BA[DC80]                	mov	dx,CtrlcMes_Ptr
 25699                                  
 25700                                  ; ---------------------------------------------------------------------------
 25701                                  
 25702                                  PYN:	; write "ON" or "OFF" state 
 25703                                  
 25704                                  	; 26/04/2023
 25705                                  	; 19/03/2023
 25706                                  	; MSDOS 3.3
 25707                                  	;call	STD_PRINTF
 25708                                  	;mov	dx,ONMES_PTR	;AC000; get ON pointer
 25709                                  	;or	bl,bl
 25710                                  	;jnz	short PRINTVAL
 25711                                  	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
 25712                                  	
 25713                                  	; 26/04/2023
 25714                                  	; 19/03/2023
 25715                                  	; MSDOS 6.0
 25716 00003685 BE[0981]                	mov	si,ONMES_PTR
 25717 00003688 08DB                    	or	bl,bl
 25718 0000368A 7503                    	jnz	short PRINTVAL
 25719 0000368C BE[0681]                	mov	si,OFFMES_PTR
 25720                                  PRINTVAL:
 25721                                  	; 19/03/2023
 25722                                  	; MSDOS 3.3
 25723                                  	;jmp	STD_PRINTF
 25724                                  
 25725                                  	; 19/03/2023
 25726                                  	; MSDOS 6.0
 25727 0000368F 52                      	push	dx		;AN000; save offset of message block
 25728 00003690 89D3                    	mov	bx,dx		;AN000; save offset value
 25729 00003692 AD                      	lodsw			;AN000; get message number of on or off
 25730 00003693 B6FF                    	mov	dh,util_msg_class ; -1 ; 0FFh
 25731                                  				;AN000; this is a utility message
 25732 00003695 E89218                  	call	TSYSGETMSG	;AN000; get the address of the message
 25733                                  	;add	bx,5
 25734 00003698 83C305                  	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
 25735                                  	
 25736 0000369B 8937                    	mov	[bx],si		;AN000; put the offset in the message block
 25737 0000369D 5A                      	pop	dx		;AN000; get message back
 25738 0000369E E8A217                  	call	std_printf	;AC000; go print message
 25739 000036A1 C7070000                	mov	word [bx],0	;AN000; zero out message pointer
 25740 000036A5 C3                      	retn			;AN000; exit
 25741                                  
 25742                                  ; =============== S U B	R O U T	I N E =======================================
 25743                                  
 25744                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
 25745                                  VERIFY:
 25746 000036A6 E81E00                  	call	ON_OFF
 25747 000036A9 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 25748 000036AC 720A                    	jc	short PVERIFY
 25749 000036AE 7503                    	jnz	short VER_OFF
 25750 000036B0 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
 25751                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 25752 000036B2 C3                      	retn
 25753                                  
 25754                                  ; ---------------------------------------------------------------------------
 25755                                  
 25756                                  VER_OFF:
 25757 000036B3 FEC8                    	dec	al
 25758 000036B5 CD21                    	int	21h		; Turn off verify after write
 25759 000036B7 C3                      	retn
 25760                                  
 25761                                  ; ---------------------------------------------------------------------------
 25762                                  
 25763                                  PVERIFY:
 25764                                  	; 19/03/2023
 25765                                  	; MSDOS 6.0
 25766                                  	;cmp	cl,0		;AC000; is rest of line blank?
 25767 000036B8 20C9                    	and	cl,cl
 25768 000036BA 75A5                    	jnz	short CERRORJ 	; nope...
 25769                                  
 25770                                  	 ;19/03/2023
 25771                                  	; MSDOS 3.3
 25772                                  	;call	MOVE_TO_FIRST_ARG
 25773                                  	;jnz	short CERRORJ
 25774                                  
 25775 000036BC B454                    	mov	ah,Get_Verify_On_Write ; 54h
 25776 000036BE CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 25777                                  				; Return: AL = 00h if flag OFF
 25778                                  				; AL = 01h if flag ON
 25779 000036C0 88C3                    	mov	bl,al
 25780 000036C2 BA[EA80]                	mov	dx,VeriMes_Ptr
 25781 000036C5 EBBE                    	jmp	short PYN
 25782                                  
 25783                                  ; =============== S U B	R O U T	I N E =======================================
 25784                                  
 25785                                  ; ****************************************************************
 25786                                  ; *
 25787                                  ; * ROUTINE:	 ON_OFF
 25788                                  ; *
 25789                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 25790                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 25791                                  ; *		 routines.
 25792                                  ; *
 25793                                  ; * INPUT:	 command line at offset 81H
 25794                                  ; *		 PARSE_BREAK control block
 25795                                  ; *
 25796                                  ; * OUTPUT:	 If carry is clear
 25797                                  ; *		    If ON is found
 25798                                  ; *		       Zero flag set
 25799                                  ; *		    If OFF is found
 25800                                  ; *		       Zero flag clear
 25801                                  ; *		 If carry set
 25802                                  ; *		    If nothing on command line
 25803                                  ; *		       CL set to zero
 25804                                  ; *		    If error
 25805                                  ; *		       CL contains error value from parse
 25806                                  ; *
 25807                                  ; ****************************************************************
 25808                                  
 25809                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25810                                  ON_OFF:
 25811 000036C7 BE8100                  	mov	si,81h
 25812                                  
 25813                                  	; 19/03/2023
 25814                                  	; MSDOS 3.3
 25815                                  	;call	SCANOFF		; scan off leading blanks & equal
 25816                                  	;cmp	al,0Dh		; are we at end of line?
 25817                                  	;je	short BAD_ONF	; yes, return error
 25818                                  	;lodsw
 25819                                  	;or	ax,2020h	; convert to lowercase
 25820                                  	;cmp	ax,6E6Fh ;'on'
 25821                                  	;je	short ON_CHECK
 25822                                  	;cmp	ax,666Fh ;'of'
 25823                                  	;jne	short BAD_ONF
 25824                                  	;lodsb
 25825                                  	;or	al,20h		; convert to lowercase		
 25826                                  	;cmp	al,66h	 ; 'f'
 25827                                  	;jne	short BAD_ONF	
 25828                                  	;or	al,66h ; or al,'f'
 25829                                  	;jmp	short OFF_CHECK
 25830                                  ;ON_CHECK:
 25831                                  	;xor	al,al
 25832                                  ;OFF_CHECK:
 25833                                  	;lahf
 25834                                  	;mov	bx,ax
 25835                                  	;call	SCANOFF		; scan off leading blanks & equal
 25836                                  	;cmp	al,0Dh		; are we at end of line?	
 25837                                  	;jne	short BAD_ONF	; no, return error
 25838                                  	;mov	ax,bx
 25839                                  	;sahf
 25840                                  	;clc
 25841                                  	;retn
 25842                                  
 25843                                  	; 19/03/2023
 25844                                  	; MSDOS 6.0
 25845                                  scan_on_off:			;AN032; scan off leading blanks & equal
 25846 000036CA AC                      	lodsb			;AN032; get a char
 25847                                  	;cmp	al,blank	;AN032; if whitespace
 25848 000036CB 3C20                    	cmp	al,20h
 25849 000036CD 74FB                    	je	short scan_on_off
 25850                                  				;AN032;    keep scanning
 25851 000036CF 3C09                    	cmp	al,tab_chr	;AN032; if tab
 25852                                  	;cmp	al,09h
 25853 000036D1 74F7                    	je	short scan_on_off
 25854                                  				;AN032;    keep scanning
 25855                                  	;cmp	al,equal_chr	;AN032; if equal char
 25856 000036D3 3C3D                    	cmp	al,'=' ; 3Dh
 25857 000036D5 7401                    	je	short parse_on_off
 25858                                  				;AN032;    start parsing
 25859 000036D7 4E                      	dec	si		;AN032; if none of above - back up
 25860                                  
 25861                                  parse_on_off:			;AN032;    and start parsing
 25862 000036D8 BF[E984]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 25863 000036DB 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 25864 000036DD 31D2                    	xor	dx,dx		;AN000;
 25865 000036DF E88E0C                  	call	cmd_parse	;AC000; call parser
 25866                                  	;cmp	ax,-1 ; 0FFFFh
 25867 000036E2 83F8FF                  	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 25868 000036E5 742E                    	je	short BADONF	;AC000; yes, return error
 25869                                  	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
 25870                                  	;cmp	ax,0
 25871 000036E7 21C0                    	and	ax,ax ; ax = 0 ?
 25872 000036E9 7404                    	jz	short on_off_there
 25873                                  				;AN000; no - continue
 25874 000036EB 89C1                    	mov	cx,ax		;AN000; yes - set cl to error code
 25875 000036ED EB26                    	jmp	short BADONF	;AN000; return error
 25876                                  
 25877                                  on_off_there:
 25878 000036EF 803E[1096]FF            	cmp	byte [PARSE1_CODE],-1 ; 0FFh
 25879                                  				;AN014; was a valid positional present?
 25880 000036F4 7505                    	jnz	short good_on_off
 25881                                  				;AN014; yes - continue
 25882 000036F6 B90A00                  	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
 25883                                  	;mov	cx,10 ; 0Ah
 25884 000036F9 EB1A                    	jmp	short BADONF	;AN014; return error
 25885                                  
 25886                                  good_on_off:				;AN014;
 25887 000036FB 31C0                    	xor	ax,ax		;AC000; set up return code for
 25888 000036FD 0A06[1096]              	or	al,[PARSE1_CODE]
 25889                                  				;AC000;    ON or OFF in AX
 25890 00003701 9C                      	pushf			;AN000; save flags
 25891 00003702 BF[E984]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 25892 00003705 31D2                    	xor	dx,dx		;AN000;
 25893 00003707 E8660C                  	call	cmd_parse	;AN000; call parser
 25894 0000370A 83F8FF                  	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 25895                                  	;cmp	ax,-1 ; 0FFFFh
 25896 0000370D 7503                    	jne	short BADONF_flags
 25897                                  				;AN000; NO, return error
 25898 0000370F 9D                      	popf			;AN000; restore flags
 25899 00003710 F8                      	clc			;AC000; no error
 25900                                  	;jmp	short on_off_end
 25901                                  				;AN000; return to caller
 25902                                  	; 26/04/2023
 25903 00003711 C3                      	retn
 25904                                  
 25905                                  BADONF_flags:
 25906 00003712 89C1                    	mov	cx,ax
 25907 00003714 9D                      	popf
 25908                                  
 25909                                  ; ---------------------------------------------------------------------------
 25910                                  
 25911                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 25912                                  ; and return the error
 25913                                  
 25914                                  BADONF:
 25915 00003715 BA[B980]                	mov	dx,bad_on_off_ptr
 25916 00003718 F9                      	stc
 25917                                  on_off_end:
 25918 00003719 C3                      	retn
 25919                                  
 25920                                  ; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25921                                  %if 0
 25922                                  
 25923                                  ;============================================================================
 25924                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 25925                                  ;============================================================================
 25926                                  ; 02/10/2018 - Retro DOS v3.0
 25927                                  
 25928                                  ; Print volume ID info
 25929                                  
 25930                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 25931                                  
 25932                                  ; ---------------------------------------------------------------------------
 25933                                  
 25934                                  PRINTVOL:
 25935                                  	push	ax		; AX return from SEARCH_FIRST for VOL ID
 25936                                  	mov	al,[FCB] ; 5Ch	; get drive letter
 25937                                  	add	al,'@'
 25938                                  	cmp	al,'@'
 25939                                  	jnz	short DRVOK
 25940                                  	mov	al,[CURDRV]
 25941                                  	add	al,[CAPITAL_A]
 25942                                  DRVOK:
 25943                                  	mov	[VOL_DRV],al	; get drive letter into argument
 25944                                  	pop	ax		; get return code back
 25945                                  	mov	dx,NOVOL ; "has	no label" 
 25946                                  	or	al,al		; volume label found?
 25947                                  	jnz	short PRINTVOL2	; print no volume message
 25948                                  GOODVOL:
 25949                                  	; MSDOS 3.3
 25950                                  	mov	di,CHARBUF
 25951                                  	mov	dx,di
 25952                                  	mov	si,IS	; "is "
 25953                                  	call	STRCPY
 25954                                  	dec	di
 25955                                  	mov	si,DIRBUF+8
 25956                                  	mov	cx,11
 25957                                  	rep	movsb
 25958                                  	xor	ax,ax
 25959                                  	;xor	al,al  ; MSDOS 6.0
 25960                                  	stosb			; store a zero to terminate the string
 25961                                  PRINTVOL2:
 25962                                  	mov	[VOLNAME_ADDR],dx
 25963                                  	mov	dx,VOLMESPTR
 25964                                  	jmp	PRINTF_CRLF
 25965                                  
 25966                                  	; MSDOS 6.0
 25967                                  ;drvok:
 25968                                  ;	mov	vol_drv,al	;AC000; get drive letter into argument
 25969                                  ;	pop	ax		;AC000; get return code back
 25970                                  ;	or	al,al		;AC000; volume label found?
 25971                                  ;	jz	Get_vol_name	;AC000; volume label exists - go get it
 25972                                  ;	mov	dx,offset trangroup:VolMes_ptr_2 
 25973                                  ;				;AC000; set up no volume message
 25974                                  ;	jmp	short print_serial ;AC000; go print it
 25975                                  ;
 25976                                  ;Get_vol_name:
 25977                                  ;	mov	di,offset trangroup:charbuf
 25978                                  ;	mov	dx,di
 25979                                  ;	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 25980                                  ;	mov	cx,11				;AN000;  3/3/KK
 25981                                  ;	rep	movsb				;AN000;  3/3/KK
 25982                                  ;
 25983                                  ;	xor	al,al		;AC000; store a zero to terminate the string
 25984                                  ;	stosb
 25985                                  ;	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 25986                                  ;
 25987                                  ;PRINT_SERIAL:
 25988                                  ;
 25989                                  ;; Attempt to get the volume serial number from the disk.  If an error
 25990                                  ;; occurs, do not print volume serial number.
 25991                                  ;
 25992                                  ;	push	dx		;AN000; save message offset
 25993                                  ;	mov	ax,(GetSetMediaID SHL 8) 
 25994                                  ;				;AC036; Get the volume serial info
 25995                                  ;	mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 25996                                  ;	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 25997                                  ;	int	21h		;AN000; do the call
 25998                                  ;	pop	dx		;AN000; get message offset back
 25999                                  ;	jc	printvol_end	;AN000; if error, just go print label
 26000                                  ;	call	std_printf	;AC000; go print volume message
 26001                                  ;	mov	al,blank	;AN051; Print out a blank
 26002                                  ;	invoke	print_char	;AN051;   before volume message
 26003                                  ;	mov	dx,offset trangroup:VolSerMes_ptr 
 26004                                  ;				;AN000; get serial number message
 26005                                  ;printvol_end:
 26006                                  ;	jmp	std_printf	;AC000; go print and exit
 26007                                  
 26008                                  %endif
 26009                                  
 26010                                  ;============================================================================
 26011                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 26012                                  ;============================================================================
 26013                                  ; 02/10/2018 - Retro DOS v3.0
 26014                                  
 26015                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 26016                                  
 26017                                  ; =============== S U B	R O U T	I N E =======================================
 26018                                  
 26019                                  	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26020                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
 26021                                  	
 26022                                  PRINT_DATE:
 26023                                  	; 20/03/2023
 26024                                  	; MSDOS 3.3
 26025                                  	;push	es
 26026                                  	;push	di
 26027                                  	;push	cs
 26028                                  	;pop	es
 26029                                  	;mov	di,ARG_BUF
 26030                                  	;mov	ah,Get_Date ; 2Ah
 26031                                  	;int	21h	; DOS -	GET CURRENT DATE
 26032                                  	;		; Return: DL = day,DH = month,	CX = year
 26033                                  	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
 26034                                  	;cbw
 26035                                  	;call	GETDATE
 26036                                  	;call	P_DATE
 26037                                  	;xor	al,al
 26038                                  	;stosb
 26039                                  	;mov	dx,ARG_BUF_PTR
 26040                                  	;call	STD_PRINTF
 26041                                  		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 26042                                  	;pop	es ; !!??!! 
 26043                                  	;pop	di
 26044                                  	;retn
 26045                                  
 26046                                  	; 20/03/2023
 26047                                  	; MSDOS 6.0
 26048 0000371A 06                      	push	es
 26049 0000371B 57                      	push	di
 26050 0000371C 0E                      	push	cs
 26051 0000371D 07                      	pop	es
 26052 0000371E E81300                  	call	GetDate 		; get date
 26053 00003721 86F2                    	xchg	dh,dl			;AN000; switch month & day
 26054 00003723 890E[7081]              	mov	[promptDat_yr],cx 	;AC000; put year into message control block
 26055 00003727 8916[7281]              	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
 26056 0000372B BA[6081]                	mov	dx,promptdat_ptr	;AC000; set up message for output
 26057 0000372E E81217                  	call	std_printf
 26058                                  	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
 26059                                  	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
 26060 00003731 5F                      	pop	di			;AC000; restore di,es
 26061 00003732 07                      	pop	es			;AC000;
 26062 00003733 C3                      	retn
 26063                                  
 26064                                  ; ---------------------------------------------------------------------------
 26065                                  
 26066                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26067                                  
 26068                                  ;GETDATE:
 26069                                  	; 21/03/2023
 26070                                  	; MSDOS 3.3
 26071                                  	;mov	si,ax
 26072                                  	;shl	si,1
 26073                                  	;add	si,ax
 26074                                  	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 26075                                  	;mov	bx,cx
 26076                                  	;mov	cx,3
 26077                                  	;rep	movsb
 26078                                  	;mov	al,' '
 26079                                  	;stosb
 26080                                  	;retn
 26081                                  
 26082                                  	; 21/03/2023
 26083                                  	; MSDOS 6.0
 26084                                  
 26085                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 26086                                  ; for output. Date will be returned in CX,DX.
 26087                                  
 26088                                  GetDate:
 26089 00003734 BF[4C8C]                	mov	di,Arg_Buf		;AC000; target for day of week
 26090 00003737 B42A                    	mov	ah,Get_Date ;2Ah	;AC000; get current date
 26091 00003739 CD21                    	int	21h			;AC000; Get date in CX:DX
 26092 0000373B 98                      	cbw				;AC000;
 26093 0000373C 51                      	push	cx			;AN000; save date returned in
 26094 0000373D 52                      	push	dx			;AN000;  CX:DX
 26095 0000373E 89C6                    	mov	si,ax
 26096 00003740 D1E6                    	shl	si,1
 26097 00003742 01C6                    	add	si,ax			; SI=AX*3
 26098 00003744 89F1                    	mov	cx,si			;AN000; save si
 26099 00003746 A1[2C80]                	mov	ax,[WeekTab]		;AN000; get message number of weektab
 26100 00003749 B6FF                    	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
 26101 0000374B 57                      	push	di			;AN000; save argument buffer
 26102 0000374C E8DB17                  	call	TSYSGETMSG		;AN000; get the address of the message
 26103 0000374F 5F                      	pop	di			;AN000; retrieve argument buffer
 26104 00003750 01CE                    	add	si,cx			;AC000; get day of week
 26105 00003752 B90300                  	mov	cx,3
 26106 00003755 F3A4                      	rep	movsb
 26107 00003757 B000                    	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
 26108 00003759 AA                      	stosb
 26109 0000375A 5A                      	pop	dx			;AN000; get back date
 26110 0000375B 59                      	pop	cx			;AN000;
 26111 0000375C C3                      	retn
 26112                                  
 26113                                  ; =============== S U B	R O U T	I N E =======================================
 26114                                  
 26115                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26116                                  
 26117                                  	; MSDOS 6.0
 26118                                  
 26119                                  ; This routine determines whether the character in AL is a
 26120                                  ; Yes or No character. On return, if AL=0, the character is
 26121                                  ; No, if AL=1, the character is Yes.
 26122                                  
 26123                                  ;	assume	ds:trangroup
 26124                                  
 26125                                  char_in_xlat:	; proc	near
 26126                                  	; 21/03/2023
 26127 0000375D 88C2                    	mov	dl,al			;AC000; get character into DX
 26128 0000375F 30F6                    	xor	dh,dh			;AC000;
 26129                                  	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
 26130 00003761 B82365                  	mov	ax,6523h
 26131 00003764 CD21                    	int	21h			;AC000;
 26132 00003766 C3                      	retn
 26133                                  
 26134                                  ;char_in_xlat	endp
 26135                                  
 26136                                  ;============================================================================
 26137                                  ; TENV.ASM, MSDOS 6.0, 1991
 26138                                  ;============================================================================
 26139                                  ; 02/10/2018 - Retro DOS v3.0
 26140                                  
 26141                                  ;	Environment utilities and misc. routines
 26142                                  
 26143                                  ; MSDOS 6.0
 26144                                  ; ****************************************************************
 26145                                  ; *
 26146                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 26147                                  ; *
 26148                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 26149                                  ; *		 the character in AL from the file upper case table
 26150                                  ; *		 in DOS if character if above  ascii 128, else
 26151                                  ; *		 subtracts 20H if between "a" and "z".
 26152                                  ; *
 26153                                  ; * INPUT:	 AL	      char to be upper cased
 26154                                  ; *		 FUCASE_ADDR  set to the file upper case table
 26155                                  ; *
 26156                                  ; * OUTPUT:	 AL	      upper cased character
 26157                                  ; *
 26158                                  ; ****************************************************************
 26159                                  ;
 26160                                  ;assume	ds:trangroup				;AN000;
 26161                                  ;
 26162                                  ;upconv	proc	near				;AN000;
 26163                                  ;
 26164                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 26165                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 26166                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 26167                                  ;	push	ds				;AN000;
 26168                                  ;	push	bx				;AN000;
 26169                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 26170                                  ;assume	ds:resgroup				;AN000;
 26171                                  ;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
 26172                                  ;	add	bx,2				;AN000;  skip over first word
 26173                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 26174                                  ;	pop	bx				;AN000;
 26175                                  ;	pop	ds				;AN000;
 26176                                  ;assume	ds:trangroup				;AN000;
 26177                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 26178                                  ;
 26179                                  ;oth_fucase:					;AN000;
 26180                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 26181                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 26182                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 26183                                  ;	ja	upconv_end			;AC000;
 26184                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 26185                                  ;
 26186                                  ;upconv_end:					;AN000;
 26187                                  ;	ret
 26188                                  ;
 26189                                  ;upconv	endp					;AN000;
 26190                                  
 26191                                  
 26192                                  ; =============== S U B	R O U T	I N E =======================================
 26193                                  
 26194                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 26195                                  
 26196                                  ; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26197                                  %if 0
 26198                                  
 26199                                  UPCONV:
 26200                                  	cmp	al,80h
 26201                                  	jb	short OTH_UCASE
 26202                                  	sub	al,80h
 26203                                  	push	ds
 26204                                  	push	bx
 26205                                  	mov	ds,[RESSEG]
 26206                                  	lds	bx,[UPPERCASETBL]
 26207                                  	add	bx,2
 26208                                  	xlat
 26209                                  	pop	bx
 26210                                  	pop	ds
 26211                                  	jmp	short UPCONV_RETN
 26212                                  
 26213                                  OTH_UCASE:
 26214                                  	cmp	al,'a'
 26215                                  	jb	short UPCONV_RETN
 26216                                  	cmp	al,'z'
 26217                                  	ja	short UPCONV_RETN
 26218                                  	sub	al,20h
 26219                                  
 26220                                  UPCONV_RETN:
 26221                                  	retn
 26222                                  
 26223                                  %endif
 26224                                  
 26225                                  ;============================================================================
 26226                                  ; COPY.ASM, MSDOS 6.0, 1991
 26227                                  ;============================================================================
 26228                                  ; 01/10/2018 - Retro DOS v3.0
 26229                                  
 26230                                  ;	title	COMMAND COPY routines.
 26231                                  
 26232                                  ;/*
 26233                                  ; *                      Microsoft Confidential
 26234                                  ; *                      Copyright (C) Microsoft Corporation 1991
 26235                                  ; *                      All Rights Reserved.
 26236                                  ; */
 26237                                  
 26238                                  ;***	COPY.ASM
 26239                                  
 26240                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 26241                                  
 26242                                  
 26243                                  ;***	MODIFICATION HISTORY
 26244                                  
 26245                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 26246                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 26247                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 26248                                  ;	     to tokens which begin with path characters so that PARSELINE
 26249                                  ;	     will work correctly.
 26250                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 26251                                  ;	     individual tokens. That distinction is no longer needed for
 26252                                  ;	     FOR loop processing.
 26253                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
 26254                                  ;	     1 when Cparse is called from COPY.
 26255                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 26256                                  ;	     mod. It now is conditional on flag like previous mod.
 26257                                  ;11/21/83 NP  Added printf
 26258                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 26259                                  ;	     be added to a token.
 26260                                  ;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
 26261                                  ;	     NOTE: DestHand is the destination handle. There are two
 26262                                  ;	     special values: -1 meaning destination was never opened and
 26263                                  ;	     0 which means that the destination has been openned and
 26264                                  ;	     closed.
 26265                                  ;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
 26266                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 26267                                  ;	     lost on large and multiple file (wildcard) copies.
 26268                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 26269                                  ;	     destination are not equal.
 26270                                  ;
 26271                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 26272                                  ;	     first source file AND we run out of disk space before
 26273                                  ;	     completing the concatenation, restore the first source
 26274                                  ;	     file as best we can. See SeekEnd and CopErr. Bug #859.
 26275                                  ;
 26276                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 26277                                  ;		instead of compatibility mode. This gives lesser sharing
 26278                                  ;		violations when files are opened for read on a copy.
 26279                                  
 26280                                  ; ---------------------------------------------------------------------------
 26281                                  ;***	COPY CODE
 26282                                  ; ---------------------------------------------------------------------------
 26283                                  
 26284                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 26285                                  
 26286                                  ; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26287                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h
 26288                                  
 26289                                  COPY:
 26290                                  	; 	Initialize internal variables.
 26291                                  
 26292 00003767 31C0                    	xor	ax,ax		; AX = 0
 26293 00003769 A3[D28C]                	mov	[Copy_num],ax	; # files copied (destinations) = 0
 26294 0000376C A3[008E]                	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 26295 0000376F A3[4C8D]                	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
 26296 00003772 A2[FF8A]                	mov	[CFLAG],al	; 'destination file created' = false
 26297 00003775 A3[038B]                	mov	[NXTADD],ax	; ptr into TPA buffer = 0
 26298 00003778 A3[FB8A]                	mov	[DestSwitch],ax	; destination switches = none
 26299 0000377B A3[168E]                	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 26300 0000377E A3[E98C]                	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
 26301 00003781 A2[008B]                	mov	[DestClosed],al	; 'destination file closed' = false
 26302 00003784 A2[E88C]                	mov	[DestSiz],al	; length of destination pathname = 0
 26303 00003787 A2[4B8D]                	mov	[SrcSiz],al	; length of source pathname = 0
 26304 0000378A A2[EB8C]                	mov	[DestInfo],al	; destination pathname flags = none
 26305 0000378D A2[4E8D]                	mov	[SrcInfo],al	; source pathname flags = none
 26306 00003790 A2[028E]                	mov	[INEXACT],al	; 'inexact copy' = false
 26307 00003793 A2[E78C]                	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
 26308 00003796 A2[4A8D]                	mov	[SrcVars],al	; 'source pathname is directory' = false
 26309 00003799 A2[C289]                	mov	[USERDIR1],al	; saved working directory = null
 26310 0000379C A2[038E]                	mov	[NOWRITE],al	; 'no write' (source = dest) = false
 26311 0000379F A2[F38A]                	mov	[RDEOF],al	; 'read end of file' = false
 26312 000037A2 A3[A68D]                	mov	[SRCHAND],ax	; source handle = 0
 26313 000037A5 A3[0B8E]                	mov	[CPDATE],ax	; copy date = 0
 26314 000037A8 A3[0D8E]                	mov	[CPTIME],ax	; copy time = 0
 26315 000037AB A2[A88D]                	mov	[SRCISDEV],al	; 'source is device' = false
 26316                                  	; 23/03/2023
 26317                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
 26318 000037AE A2[138E]                	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 26319 000037B1 A3[0F8E]                	mov	[OFilePtr_Lo],ax
 26320 000037B4 A3[118E]                	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 26321 000037B7 A2[078E]                	mov	[TERMREAD],al	; 'terminate read' = false
 26322 000037BA A2[458C]                	mov	[comma],al	; '"+,," found' = false
 26323 000037BD A2[468C]                	mov	[plus_comma],al ; '"+,," found last time' = false (?)
 26324 000037C0 A2[528E]                	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
 26325 000037C3 A3[FD8A]                	mov	[AllSwitch],ax	; all switches = none
 26326 000037C6 A2[F68A]                	mov	[ArgC],al	; source/dest argument count = 0
 26327 000037C9 A2[098E]                	mov	[PLUS],al	; '"+" in command line' = false
 26328 000037CC A2[048E]                	mov	[BINARY],al	; 'binary copy' = false
 26329 000037CF A2[088E]                	mov	[ASCII],al	; 'ascii copy' = false
 26330 000037D2 A3[0C8B]                	mov	[FileCnt],ax	; # files copied (destinations) = 0
 26331 000037D5 A3[058E]                	mov	[WRITTEN],ax	; 'destination written to' = false
 26332 000037D8 A2[F58A]                	mov	[Concat],al	; 'concatenating' = false
 26333 000037DB A2[478D]                	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 26334 000037DE A3[488D]                	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0,
 26335                                  
 26336                                  	;	Initialize buffers with double-nulls.
 26337                                  
 26338 000037E1 A3[A98D]                	mov	[ScanBuf],ax
 26339 000037E4 A3[EC8C]                	mov	[DestBuf],ax
 26340 000037E7 A3[4F8D]                	mov	[SrcBuf],ax
 26341 000037EA A3[2F8C]                	mov	[SDIRBUF],ax
 26342 000037ED A3[E98B]                	mov	[DIRBUF],ax
 26343 000037F0 A3[A68B]                	mov	[DestFcb],ax
 26344                                  
 26345 000037F3 A2[0A8E]                	mov	[objcnt],al	; # CParse cmd-line objects found = 0
 26346                                  		
 26347 000037F6 48                      	dec	ax ; -1		; AX = 0FFFFh
 26348 000037F7 A3[438D]                	mov	[DESTHAND],ax	; destination handle = 'never opened'
 26349 000037FA A2[058B]                	mov	[FRSTSRCH],al	; 'first search for source' = true
 26350 000037FD A2[468D]                	mov	[FIRSTDEST],al	; 'first time for dest' = true
 26351 00003800 A2[E78C]                	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
 26352                                  		
 26353 00003803 BE8100                  	mov	si,81h		; SI = ptr to command line
 26354                                  	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 26355                                  	; 23/03/2023
 26356 00003806 B32B                    	mov	bl,'+'
 26357 00003808 FE06[518E]              	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
 26358 0000380C C606[D48C]01            	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true
 26359                                  
 26360                                  	;*	Scan the command line for destination information.
 26361                                  
 26362                                  DESTSCAN:
 26363 00003811 31ED                    	xor	bp,bp			; BP = switch flag accumulator
 26364 00003813 BF[A98D]                	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
 26365                                  	; 23/03/2023
 26366 00003816 8936[488C]              	mov	[parse_last],si		;AN018; save cmd line ptr
 26367 0000381A E88E09                  	call	cparse			; parse next object
 26368 0000381D 9C                      	pushf				; save CParse flags
 26369 0000381E FE06[0A8E]              	inc	byte [objcnt]		; count object
 26370 00003822 F6C780                  	test	bh,80h
 26371 00003825 7405                    	jz	short NOCOPY		; no "+" delimiter
 26372 00003827 C606[098E]01            	mov	byte [PLUS],1		; "+" delimiter occurred
 26373                                  NOCOPY:
 26374 0000382C F6C701                  	test	bh,1
 26375 0000382F 742E                    	jz	short TESTP2		; not a switch
 26376                                  
 26377                                  	;	Found a switch.
 26378                                  
 26379                                  	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
 26380                                  	; MSDOS 6.0
 26381 00003831 F7C51000                	test	bp,10h
 26382                                  	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
 26383 00003835 740B                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26384 00003837 F606[FD8A]10            	test	byte [AllSwitch],10h
 26385                                  	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
 26386 0000383C 7404                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26387                                  ;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
 26388                                  	;or	bp,FBadSwitch		;AN018; Set up bad switch
 26389 0000383E 81CD0040                	or	bp,4000h
 26390                                  NOT_SLASHV:
 26391 00003842 092E[FB8A]              	or	[DestSwitch],bp		; assume destination
 26392 00003846 092E[FD8A]              	or	[AllSwitch],bp		; keep tabs on all switches
 26393                                  
 26394                                  	; 2303/2023
 26395                                  	; MSDOS 6.0
 26396                                  	;test	bp,not SwitchCopy	;AN018; Bad switch?
 26397 0000384A F7C5E37F                	test	bp,7FE3h ; test bp,~SwitchCopy
 26398 0000384E 740A                    	jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
 26399 00003850 9D                      	popf				;AN018; fix up stack
 26400 00003851 B80300                  	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
 26401 00003854 E896E9                  	call	setup_parse_error_msg	;AN018; setup to print the message
 26402 00003857 E920F1                  	jmp	cerror			;AC018; exit
 26403                                  NOT_BAD_SWITCH:
 26404 0000385A 9D                      	popf				; restore CParse flags
 26405 0000385B 7233                    	jc	short CHECKDONE		; found CR
 26406 0000385D EBB2                    	jmp	short DESTSCAN		; continue scanning for destination
 26407                                  TESTP2:
 26408 0000385F 9D                      	popf				; restore CParse flags
 26409 00003860 722E                    	jc	short CHECKDONE		; found CR
 26410 00003862 F6C780                  	test	bh,80h
 26411 00003865 7504                    	jnz	short GOTPLUS		; found a "+pathname" argument
 26412 00003867 FE06[F68A]              	inc	byte [ArgC]		; count independent pathname args
 26413                                  GOTPLUS:
 26414 0000386B 56                      	push	si			; save cmd line ptr
 26415 0000386C A1[168E]                	mov	ax,[STARTEL]		; AX = ptr to last path element
 26416 0000386F BE[A98D]                	mov	si,ScanBuf		; SI = ptr to path string
 26417 00003872 29F0                    	sub	ax,si			; AX = offset of last element
 26418 00003874 BF[EC8C]                	mov	di,DestBuf		; DI = ptr to destination buf
 26419 00003877 01F8                    	add	ax,di			; AX = ptr to last element in
 26420                                  					;  destination path buffer
 26421 00003879 A3[E98C]                	mov	[DestTail],ax		; save ptr to last element
 26422 0000387C 880E[E88C]              	mov	[DestSiz],cl		; save path string length
 26423 00003880 41                      	inc	cx			; CX = mov length (incl null)
 26424 00003881 F3A4                    	rep	movsb			; DestBuf = possible destination path
 26425 00003883 883E[EB8C]              	mov	[DestInfo],bh		; save CParse info flags
 26426 00003887 C706[FB8A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26427 0000388D 5E                      	pop	si			; SI = ptr into cmd line again
 26428 0000388E EB81                    	jmp	short DESTSCAN		;AC018; continue scanning for dest
 26429                                  
 26430                                  CHECKDONE:
 26431                                  	;	We reached the CR. The destination scan is finished.
 26432                                  
 26433                                  	;	Disallow "copy file1+" as file overwriting itself.
 26434                                  	;
 26435                                  	;	(Note that "copy file1+file2+" will be accepted, and
 26436                                  	;	equivalent to "copy file1+file2".)
 26437                                  
 26438                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 26439                                  	;	through this check, since the switch would count
 26440                                  	;	as another object in ObjCnt.
 26441                                  
 26442 00003890 803E[098E]01            	cmp	byte [PLUS],1		; "+" with
 26443 00003895 7514                    	jnz	short CDCONT
 26444 00003897 803E[F68A]01            	cmp	byte [ArgC],1		; one arg,
 26445 0000389C 750D                    	jnz	short CDCONT
 26446 0000389E 803E[0A8E]02            	cmp	byte [objcnt],2		; two objects..
 26447 000038A3 7506                    	jnz	short CDCONT
 26448 000038A5 BA[9E7F]                	mov	dx,OVERWR_PTR
 26449 000038A8 E91A06                  	jmp	COPYERR			; is file overwrite
 26450                                  
 26451                                  CDCONT:
 26452 000038AB A0[098E]                	mov	al,[PLUS]		; AL = '"+" occurred'
 26453 000038AE A2[F58A]                	mov	[Concat],al		; if "+" occurred, we're concatenating
 26454 000038B1 D0E0                    	shl	al,1
 26455 000038B3 D0E0                    	shl	al,1
 26456 000038B5 A2[028E]                	mov	[INEXACT],al		; therefore making an inexact copy
 26457                                  	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
 26458 000038B8 A0[F68A]                	mov	al,[ArgC]		; AL = # independent arguments
 26459                                  
 26460                                  	; 23/03/2023
 26461                                  	; MSDOS 3.3		
 26462                                  	;or	al,al
 26463                                  	;jz	short CERROR4J
 26464                                  	; MSDOS 6.0
 26465 000038BB 08C0                    	or	al,al
 26466 000038BD 750B                    	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
 26467                                  		
 26468 000038BF BA[757F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26469 000038C2 C706[757F]0200          	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
 26470                                  	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
 26471 000038C8 EB0D                    	jmp	short CERROR_PARSEJ	; take parse error exit		
 26472                                  
 26473                                  	; more than 0 args; check if too many
 26474                                  TRY_TOO_MANY:
 26475 000038CA 3C02                    	cmp	al,2
 26476 000038CC 7611                    	jbe	short ACOUNTOK		; <= 2 arguments - ok
 26477                                  
 26478                                  	; 23/03/2023
 26479                                  	; MSDOS 6.0
 26480 000038CE BA[757F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26481 000038D1 C706[757F]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 26482                                  	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
 26483                                  CERROR_PARSEJ:
 26484 000038D7 C606[737F]02            	mov	byte [msg_disp_class],parse_msg_class ; 2
 26485                                  					; parse error message	
 26486                                  CERROR4J:
 26487 000038DC E99BF0                  	jmp	cerror
 26488                                  
 26489                                  ACOUNTOK:
 26490 000038DF BD[E78C]                	mov	bp,DestVars		; BP = base of dest variables
 26491                                  
 26492 000038E2 3C01                    	cmp	al,1
 26493 000038E4 7520                    	jnz	short GOT2ARGS
 26494                                  
 26495                                  	;	Only one independent pathname argument on command line.
 26496                                  	;	Set destination to d:*.*, where d: is current drive.
 26497                                  
 26498                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 26499                                  	;	The two files would be appended as d:file1, rather than x:file1.
 26500                                  
 26501 000038E6 A0[F48A]                	mov	al,[CURDRV]		; AL = current drive (0 = A)
 26502                                  	;add	al,[CAPITAL_A]		; AL = current drive letter
 26503                                  	; 23/03/2023
 26504 000038E9 0441                    	add	al,'A'
 26505 000038EB B43A                    	mov	ah,':'			; AX = "d:"
 26506                                  	;mov	byte [bp+1],2
 26507 000038ED C6460102                	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 26508                                  
 26509 000038F1 BF[EC8C]                	mov	di,DestBuf		; ES:DI = ptr to dest path buf
 26510 000038F4 AB                      	stosw				; store "d:"
 26511                                  		
 26512 000038F5 C706[FB8A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26513                                  	;mov	byte [bp+4],2		
 26514 000038FB C6460402                	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26515                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26516                                  	;mov	byte [bp+0],0		
 26517 000038FF C6460000                	mov	byte [bp],0
 26518 00003903 E87608                  	call	SETSTARS		; add wildcards
 26519                                  GOT2ARGS:
 26520                                  	;	If destination pathname is "d:", add full wildcard filename
 26521                                  
 26522                                  	;cmp	byte [bp+1],2
 26523 00003906 807E0102                	cmp	byte [bp+VARSTRUC.SIZ],2
 26524 0000390A 7516                    	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 26525 0000390C B03A                    	mov	al,':'  ; 3Ah
 26526 0000390E 3806[ED8C]              	cmp	byte [DestBuf+1],al
 26527 00003912 750E                    	jnz	short NOTSHORTDEST	; it's just a 2-character filename
 26528                                  	;or	byte [bp+4],2
 26529 00003914 804E0402                	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26530 00003918 BF[EE8C]                	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
 26531                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26532                                  	;mov	byte [bp+0],0		
 26533 0000391B C6460000                	mov	byte [bp],0
 26534 0000391F E85A08                  	call	SETSTARS		; add wildcards
 26535                                  NOTSHORTDEST:
 26536                                  	;	If destination pathname ends with "\", try to make
 26537                                  	;	sure it's "d:\".
 26538                                  
 26539                                  	;mov	di,[bp+2]
 26540 00003922 8B7E02                  	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 26541 00003925 803D00                  	cmp	byte [di],0
 26542 00003928 7515                    	jnz	short CHKSWTCHES	; not a null, so last char not "\"
 26543                                  
 26544 0000392A BA[B080]                	mov	dx,badcd_ptr
 26545 0000392D B03A                    	mov	al,':'
 26546 0000392F 3845FE                  	cmp	[di-2],al
 26547 00003932 75A8                    	jne	short CERROR4J		; it's not "d:\", exit with error msg
 26548                                  	;mov	byte [bp+0],2
 26549                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 26550 00003934 C6460002                	mov	byte [bp],2
 26551                                  	;or	byte [bp+4],6
 26552 00003938 804E0406                	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 26553                                  					  ;  path character
 26554 0000393C E83D08                  	call	SETSTARS		; add wildcards
 26555                                  CHKSWTCHES:
 26556                                  	;	We have enough information about the destination for now.
 26557                                  
 26558                                  	;	Turn on verify if requested. Save the current verify flag.
 26559                                  
 26560                                  	; 23/03/2023
 26561                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
 26562                                  	;mov	dx,BADPARMPTR
 26563                                  	
 26564 0000393F A1[FD8A]                	mov	ax,[AllSwitch]		; AX = all switch flags
 26565                                  
 26566                                  	; 23/03/2023
 26567                                  	; MSDOS 3.3
 26568                                  	;;test	ax,~SWITCHCOPY ; 7FE3h
 26569                                  	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 26570                                  	;jnz	short CERROR4J
 26571                                  	
 26572                                  	; 23/03/2023
 26573                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26574                                  	;test	ax,SwitchV ; 10h
 26575                                  	; 18/04/2023
 26576                                  	;test	ax,10h
 26577 00003942 A810                    	test	al,10h  ; test al,SwitchV
 26578 00003944 7414                    	jz	short NOVERIF		; no /v, no verify
 26579                                  
 26580 00003946 B454                    	mov	ah,Get_Verify_On_Write ; 54h
 26581 00003948 CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 26582                                  				; Return: AL = 00h if flag OFF
 26583                                  				; AL = 01h if flag ON
 26584 0000394A 1E                      	push	ds
 26585 0000394B 8E1E[E08A]              	mov	ds,[RESSEG]
 26586 0000394F 30E4                    	xor	ah,ah
 26587 00003951 A3[A801]                	mov	[VerVal],ax		; save current verify flag
 26588 00003954 1F                      	pop	ds
 26589 00003955 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 26590 00003958 CD21                    	int	21h		; DOS -	SET VERIFY FLAG
 26591                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 26592                                  NOVERIF:
 26593                                  	;*	Scan for first source.
 26594                                  
 26595 0000395A 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 26596 0000395C BE8100                  	mov	si,81h			; SI = ptr into command line
 26597                                  	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 26598                                  	; 23/03/2023
 26599 0000395F B32B                    	mov	bl,'+' ; 2Bh
 26600                                  SCANFSRC:
 26601 00003961 BF[A98D]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 26602 00003964 E84408                  	call	cparse			; parse first source pathname
 26603 00003967 F6C701                  	test	bh,1			; switch?
 26604 0000396A 75F5                    	jnz	short SCANFSRC		; yes, try again
 26605 0000396C 092E[FB8A]              	or	[DestSwitch],bp		; include copy-wide switches on dest
 26606                                  
 26607                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 26608                                  
 26609                                  	; 23/03/2023
 26610 00003970 F7C50800                	test	bp,8
 26611                                  	;test	bp,SWITCHB
 26612 00003974 750C                    	jnz	short NOSETCASC		; /b - explicit binary copy
 26613 00003976 803E[F58A]00            	cmp	byte [Concat],0
 26614 0000397B 7405                    	jz	short NOSETCASC		; we're not concatenating
 26615 0000397D C606[088E]04            	mov	byte [ASCII],4
 26616                                  	;mov	byte [ASCII],SWITCHA	; set ascii copy
 26617                                  NOSETCASC:
 26618 00003982 E8B503                  	call	SOURCE_SET		; set source variables
 26619 00003985 E84400                  	call	FRSTSRC			; set up first source copy
 26620 00003988 E99500                  	jmp	FIRSTENT		; jump into the copy loop
 26621                                  
 26622                                  ; ---------------------------------------------------------------------------
 26623                                  
 26624                                  	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26625                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
 26626                                  ENDCOPY:
 26627                                  	;*	End of the road. Close destination, display # files
 26628                                  	;	copied (meaning # destinations), and go back to main
 26629                                  	;	transient COMMAND code.
 26630                                  
 26631 0000398B E8C102                  	call	CLOSEDEST
 26632                                  ENDCOPY2:
 26633 0000398E BA[A77F]                	mov	dx,copied_ptr
 26634 00003991 8B36[0C8B]              	mov	si,[FileCnt]
 26635 00003995 8936[D28C]              	mov	[Copy_num],si
 26636 00003999 E8A714                  	call	std_printf
 26637 0000399C E965C7                  	jmp	TCOMMAND		; stack could be messed up
 26638                                  
 26639                                  ; ---------------------------------------------------------------------------
 26640                                  
 26641                                  SRCNONEXIST:
 26642                                  	;*	Source doesn't exist. If concatenating, ignore and continue.
 26643                                  	;	Otherwise, say 'file not found' and quit.
 26644                                  
 26645 0000399F 803E[F58A]00            	cmp	byte [Concat],0
 26646 000039A4 7543                    	jne	short NEXTSRC		; concatenating - go on to next source
 26647                                  
 26648                                  	; 24/03/2023
 26649                                  	; MSDOS 3.3
 26650                                  	;mov	dx,SRCBUF
 26651                                  	;mov	[STRING_PTR_1],dx
 26652                                  	;mov	dx,STRINGBUF1PTR
 26653                                  	;call	STD_PRINTF
 26654                                  	;mov	dx,FNOTFOUNDPTR
 26655                                  	;jmp	COPYERR
 26656                                  
 26657                                  	; 24/*03/2023
 26658                                  	; MSDOS 6.0
 26659                                  	;	Set up error message.
 26660 000039A6 C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 26661                                  				  	; extended error msg
 26662 000039AB BA[757F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26663 000039AE C706[757F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 26664                                  					; 'file not found' msg#
 26665 000039B4 C706[D08C][4F8D]        	mov	word [string_ptr_2],SrcBuf
 26666                                  					; point at bad pathname
 26667 000039BA C606[777F]01            	mov	byte [extend_buf_sub],one_subst ; 1
 26668                                  					; 1 substitution
 26669 000039BF E90305                  	jmp	COPYERR			; print msg and clean up
 26670                                  
 26671                                  ; ---------------------------------------------------------------------------
 26672                                  
 26673                                  SOURCEPROC:
 26674                                  
 26675                                  	;*	Preparatory processing for each source file.
 26676                                  	;	Called at FrstSrc for first source file.
 26677                                  
 26678 000039C2 E87503                  	call	SOURCE_SET		; set source variables & ascii/binary
 26679 000039C5 803E[F58A]00            	cmp	byte [Concat],0
 26680 000039CA 750B                    	jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 26681                                  
 26682                                  ; ---------------------------------------------------------------------------
 26683                                  
 26684                                  FRSTSRC:
 26685 000039CC 31C0                    	xor	ax,ax
 26686 000039CE A2[FF8A]                	mov	[CFLAG],al		; 'destination not created'
 26687 000039D1 A3[038B]                	mov	[NXTADD],ax		; copy buffer ptr = 0
 26688 000039D4 A2[008B]                	mov	[DestClosed],al		; 'destination not closed'
 26689                                  
 26690                                  LEAVECFLAG:
 26691 000039D7 8936[008E]              	mov	[SRCPT],si		; save cmd-line ptr
 26692 000039DB BF[C289]                	mov	di,USERDIR1		; DI = ptr to buf for user's 
 26693                                  						;   current dir
 26694 000039DE BD[4A8D]                	mov	bp,SrcVars		; BP = base of source variables
 26695 000039E1 E84606                  	call	BUILDPATH		; cd to source dir, figure
 26696                                  						;   out stuff about source
 26697 000039E4 8B36[4C8D]              	mov	si,[SrcTail]		; SI = ptr to source filename
 26698 000039E8 C3                      	retn
 26699                                  
 26700                                  ; ---------------------------------------------------------------------------
 26701                                  
 26702                                  	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26703                                  NEXTSRC:
 26704                                  	;*	Next source. Come here after handling each pathname.
 26705                                  	;	We're done unless there are additional source pathnames
 26706                                  	;	to be appended.
 26707                                  	;
 26708                                  	;	Note that all files matching an ambiguous pathname
 26709                                  	;	are processed before coming here.
 26710                                  
 26711 000039E9 803E[098E]00            	cmp	byte [PLUS],0
 26712                                  	;jne	short MORECP		; copying "+" sources - keep going
 26713                                  	; 26/04/2023
 26714                                  ;ENDCOPYJ2:
 26715                                  	;jmp	short ENDCOPY
 26716 000039EE 749B                    	je	short ENDCOPY
 26717                                  MORECP:
 26718 000039F0 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 26719 000039F2 8B36[008E]              	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 26720                                  	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 26721 000039F6 B32B                    	mov	bl,'+' ; 2Bh
 26722                                  SCANSRC:
 26723 000039F8 BF[A98D]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 26724 000039FB E8AD07                  	call	cparse			; parse first source name
 26725                                  	;jb	short ENDCOPYJ2		; CR found - we're done
 26726                                  	; 26/04/2023
 26727 000039FE 728B                    	jb	short ENDCOPY
 26728                                  
 26729 00003A00 F6C780                  	test	bh,80h
 26730                                  	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 26731                                  	; 26/04/2023
 26732 00003A03 7486                    	jz	short ENDCOPY
 26733                                  
 26734 00003A05 F6C701                  	test	bh,1
 26735 00003A08 75EE                    	jnz	short SCANSRC		; switch found - keep looking
 26736                                  
 26737                                  	;	ScanBuf contains the next source pathname.
 26738                                  
 26739 00003A0A E8B5FF                  	call	SOURCEPROC		; prepare this source
 26740 00003A0D 803E[458C]01            	cmp	byte [comma],1		; was +,, found last time?
 26741 00003A12 7507                    	jnz	short NOSTAMP		;  no - try for a file
 26742 00003A14 C606[468C]01            	mov	byte [plus_comma],1	; yes - set flag
 26743 00003A19 EB84                    	jmp	short SRCNONEXIST	; we know we won't find it
 26744                                  
 26745                                  NOSTAMP:
 26746 00003A1B C606[468C]00            	mov	byte [plus_comma],0	; reset +,, flag
 26747                                  
 26748                                  ; ---------------------------------------------------------------------------
 26749                                  
 26750                                  FIRSTENT:
 26751                                  
 26752                                  ;M047
 26753                                  ; The only case we need to worry about is when the source is wildcarded and
 26754                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 26755                                  ;concatenation. We check for this case.
 26756                                  ;
 26757                                  ;NB: This change has been backed out and replaced by M048. This is not the
 26758                                  ;right place to do this check.
 26759                                  
 26760                                  	;	This is where we enter the loop with the first source.
 26761                                  
 26762 00003A20 BF5C00                  	mov	di,FCB ; 5Ch		; DI = ptr to FCB
 26763 00003A23 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 26764 00003A26 CD21                    	int	21h		; DOS -	PARSE FILENAME
 26765                                  				; DS:SI	-> string to parse
 26766                                  				; ES:DI	-> buffer to fill with unopened	FCB
 26767                                  				; AL = bit mask	to control parsing
 26768 00003A28 803C00                  	cmp	byte [si],0		; did we parse the whole thing?
 26769 00003A2B 7516                    	jne	short SRCHDONE		; no, error, simulate 'not found'
 26770 00003A2D A1[4F8D]                	mov	ax,[SrcBuf]		; AX = possible "d:"
 26771 00003A30 80FC3A                  	cmp	ah,':'
 26772 00003A33 7402                    	je	short DRVSPEC1		; AX = definite "d:"
 26773 00003A35 B040                    	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
 26774                                  DRVSPEC1:
 26775 00003A37 0C20                    	or	al,20h			; AL = lowercase drive letter
 26776 00003A39 2C60                    	sub	al,60h			; AL = drive id (0=current,1=A,..)
 26777                                  	;mov	[5Ch],al
 26778 00003A3B A25C00                  	mov	[FCB],al		; put drive id in FCB
 26779                                  
 26780                                  	;	FCB contains drive and filename to search.
 26781                                  		
 26782 00003A3E B411                    	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'	
 26783 00003A40 E8FC00                  	call	SEARCH
 26784                                  SRCHDONE:
 26785 00003A43 9C                      	pushf				; save flags from Search
 26786 00003A44 E85FEA                  	call	RestUDir1		; restore users current directory
 26787 00003A47 9D                      	popf				; restore flags from search
 26788 00003A48 7403                    	jz	short NEXTAMBIG0	; found the source - continue
 26789 00003A4A E952FF                  	jmp	SRCNONEXIST		; didn't find the source
 26790                                  
 26791                                  NEXTAMBIG0:
 26792 00003A4D 30C0                    	xor	al,al
 26793 00003A4F 8606[058B]              	xchg	al,[FRSTSRCH]
 26794 00003A53 08C0                    	or	al,al
 26795 00003A55 740B                    	jz	short NEXTAMBIG
 26796                                  SETNMEL:
 26797 00003A57 B90C00                  	mov	cx,12
 26798 00003A5A BF[2F8C]                	mov	di,SDIRBUF
 26799 00003A5D BE[E98B]                	mov	si,DIRBUF
 26800 00003A60 F3A4                    	rep	movsb			; save very first source name
 26801                                  NEXTAMBIG:
 26802 00003A62 30C0                    	xor	al,al
 26803 00003A64 A2[038E]                	mov	[NOWRITE],al		; turn off nowrite
 26804 00003A67 8B3E[4C8D]              	mov	di,[SrcTail]
 26805 00003A6B BE[EA8B]                	mov	si,DIRBUF+1
 26806 00003A6E E8B4EB                  	call	FCB_TO_ASCZ		; SrcBuf has complete name
 26807                                  MELDO:
 26808 00003A71 803E[F58A]00            	cmp	byte [Concat],0
 26809 00003A76 7507                    	jnz	short SHOWCPNAM		; concatenating - show name
 26810 00003A78 F606[4E8D]02            	test	byte [SrcInfo],2	; wildcard - show name
 26811 00003A7D 7409                    	jz	short DOREAD
 26812                                  SHOWCPNAM:
 26813                                  	; 25/03/2023
 26814                                  	; MSDOS 3.3
 26815                                  	;mov	dx,SRCBUF
 26816                                  	;mov	[STRING_PTR_2],dx
 26817                                  	;mov	dx,STRINGBUF2PTR
 26818                                  	;call	STD_PRINTF
 26819                                  	;call	CRLF2
 26820                                  	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
 26821                                  	; MSDOS 6.0 (& MSDOS 5.0
 26822 00003A7F BA[2081]                	mov	dx,file_name_ptr
 26823 00003A82 E8BE13                  	call	std_printf
 26824 00003A85 E871EB                  	call	CRLF2
 26825                                  DOREAD:
 26826 00003A88 E8C500                  	call	DOCOPY
 26827 00003A8B 803E[F58A]00            	cmp	byte [Concat],0
 26828 00003A90 750A                    	jnz	short NODCLOSE		; concatenating - don't close dest
 26829                                  
 26830 00003A92 E8BA01                  	call	CLOSEDEST		; close current destination
 26831 00003A95 7205                    	jc	short NODCLOSE		; concatenating - dest not closed
 26832                                  
 26833 00003A97 C606[FF8A]00            	mov	byte [CFLAG],0		; 'destination not created'
 26834                                  NODCLOSE:
 26835 00003A9C 803E[F58A]00            	cmp	byte [Concat],0		
 26836 00003AA1 740A                    	jz	short NOFLUSH
 26837                                  
 26838                                  ;	Concatenating - flush output between source files so LostErr
 26839                                  ;	stuff works correctly.
 26840                                  
 26841                                  	;invoke	FlshFil  ; MSDOS 6.0
 26842                                  	; 25/03/2023
 26843 00003AA3 E8E202                  	call	FlshFil
 26844                                  	;call	FLUSHFIL ; MSDOS 3.3
 26845                                  
 26846 00003AA6 F606[478D]FF            	test	byte [MELCOPY],0FFh
 26847                                  	;jz	short NOFLUSH
 26848                                  	;jmp	short DOMELCOPY
 26849                                  	; 25/03/2023
 26850 00003AAB 750C                    	jnz	short DOMELCOPY
 26851                                  NOFLUSH:
 26852 00003AAD E88300                  	call	SEARCHNEXT		; try next match
 26853 00003AB0 755D                    	jnz	short NEXTSRCJ		; not found - finished with 
 26854                                  					;   this source spec
 26855 00003AB2 C606[008B]00            	mov	byte [DestClosed],0	; 'destination not closed'
 26856 00003AB7 EBA9                    	jmp	short NEXTAMBIG		; do next ambig match
 26857                                  
 26858                                  DOMELCOPY:
 26859 00003AB9 803E[478D]FF            	cmp	byte [MELCOPY],0FFh
 26860 00003ABE 740D                    	je	short CONTMEL
 26861 00003AC0 8B36[008E]              	mov	si,[SRCPT]
 26862 00003AC4 8936[488D]              	mov	[MELSTART],si
 26863 00003AC8 C606[478D]FF            	mov	byte [MELCOPY],0FFh
 26864                                  
 26865                                  CONTMEL:
 26866 00003ACD 31ED                    	xor	bp,bp
 26867 00003ACF 8B36[008E]              	mov	si,[SRCPT]
 26868                                  	;mov	bl,[PLUS_CHR]
 26869                                  	; 25/03/2023
 26870 00003AD3 B32B                    	mov	bl,'+'
 26871                                  SCANSRC2:
 26872 00003AD5 BF[A98D]                	mov	di,ScanBuf
 26873 00003AD8 E8D006                  	call	cparse
 26874 00003ADB F6C780                  	test	bh,80h
 26875 00003ADE 7432                    	jz	short NEXTMEL		; no "+" - go back to start
 26876 00003AE0 F6C701                  	test	bh,1
 26877 00003AE3 75F0                    	jnz	short SCANSRC2		; switch - keep scanning
 26878 00003AE5 E8DAFE                  	call	SOURCEPROC
 26879 00003AE8 E8BBE9                  	call	RestUDir1
 26880 00003AEB BF[6A8B]                	mov	di,DESTFCB2
 26881 00003AEE B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 26882 00003AF1 CD21                    	int	21h		; DOS -	PARSE FILENAME
 26883                                  				; DS:SI	-> string to parse
 26884                                  				; ES:DI	-> buffer to fill with unopened	FCB
 26885                                  				; AL = bit mask	to control parsing
 26886 00003AF3 BB[308C]                	mov	bx,SDIRBUF+1
 26887 00003AF6 BE[6B8B]                	mov	si,DESTFCB2+1
 26888 00003AF9 8B3E[4C8D]              	mov	di,[SrcTail]
 26889                                  
 26890 00003AFD E8FB04                  	call	BUILDNAME
 26891                                  
 26892 00003B00 803E[F58A]00            	cmp	byte [Concat],0
 26893 00003B05 7405                    	je	short MELDOJ		; not concatenating - continue
 26894                                  
 26895                                  	;	Yes, turn off nowrite because this part of the code 
 26896                                  	;	is only reached after the first file has been dealt with.
 26897                                  
 26898 00003B07 C606[038E]00            	mov	byte [NOWRITE],0
 26899                                  MELDOJ:
 26900 00003B0C E962FF                  	jmp	MELDO
 26901                                  NEXTSRCJ:
 26902 00003B0F E9D7FE                  	jmp	NEXTSRC
 26903                                  
 26904                                  NEXTMEL:
 26905 00003B12 E83A01                  	call	CLOSEDEST
 26906 00003B15 31C0                    	xor	ax,ax
 26907 00003B17 A2[FF8A]                	mov	[CFLAG],al
 26908 00003B1A A3[038B]                	mov	[NXTADD],ax
 26909 00003B1D A2[008B]                	mov	[SPECDRV],al
 26910 00003B20 8B36[488D]              	mov	si,[MELSTART]
 26911 00003B24 8936[008E]              	mov	[SRCPT],si
 26912 00003B28 E80800                  	call	SEARCHNEXT
 26913 00003B2B 7403                    	jz	short SETNMELJ
 26914 00003B2D E95EFE                  	jmp	ENDCOPY2
 26915                                  SETNMELJ:
 26916 00003B30 E924FF                  	jmp	SETNMEL
 26917                                  
 26918                                  ; ---------------------------------------------------------------------------
 26919                                  
 26920                                  SEARCHNEXT:
 26921 00003B33 B412                    	mov	ah,Dir_Search_Next ; 12h
 26922 00003B35 F606[4E8D]02            	test	byte [SrcInfo],2
 26923 00003B3A 7503                    	jnz	short SEARCH		; do search-next if ambig
 26924 00003B3C 08E4                    	or	ah,ah			; reset zero flag
 26925 00003B3E C3                      	retn
 26926                                  
 26927                                  ; ---------------------------------------------------------------------------
 26928                                  
 26929                                  SEARCH:
 26930 00003B3F 50                      	push	ax
 26931 00003B40 B41A                    	mov	ah,Set_DMA ; 1Ah
 26932 00003B42 BA[E98B]                	mov	dx,DIRBUF	; put result of search in dirbuf
 26933 00003B45 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 26934                                  			; DS:DX	-> disk	transfer buffer
 26935 00003B47 58                      	pop	ax		; restore search first/next command
 26936 00003B48 BA5C00                  	mov	dx,FCB ; 5Ch
 26937 00003B4B CD21                    	int	21h		; Do the search
 26938 00003B4D 08C0                    	or	al,al
 26939 00003B4F C3                      	retn
 26940                                  
 26941                                  ; ---------------------------------------------------------------------------
 26942                                  
 26943                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26944                                  DOCOPY:
 26945 00003B50 BE[4F8D]                	mov	si,SrcBuf	; do name translate of source
 26946 00003B53 BF[0E88]                	mov	di,SRCXNAME	; save for name comparison
 26947 00003B56 B460                    	mov	ah,xNameTrans ; 60h
 26948 00003B58 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 26949                                  			; DS:SI	-> ASCIZ relative path string or directory name
 26950                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 26951 00003B5A C606[F38A]00            	mov	byte [RDEOF],0	; no EOF yet
 26952                                  
 26953                                  	; MSDOS 6.0
 26954                                  	;mov	ax,ExtOpen shl 8	; open the file
 26955                                  	; 26/03/2023
 26956 00003B5F B8006C                  	mov	ax,6C00h
 26957                                  ;M046
 26958                                  ; For reads, the sharing mode should be deny none so that any process can
 26959                                  ;open this file again in any other sharing mode. This is mainly to allow
 26960                                  ;multiple command.com's to access the same file without getting sharing
 26961                                  ;violations
 26962                                  ;
 26963                                  	;mov	bx,deny_none|read_open_mode
 26964 00003B62 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 26965 00003B65 31C9                    	xor	cx,cx			; no special files
 26966                                  	;mov	dx,read_open_flag	; set up open flags
 26967 00003B67 BA0101                  	mov	dx,101h
 26968 00003B6A CD21                    	int	21h
 26969                                  	; 26/03/2023
 26970 00003B6C 7230                    	jc	short Error_On_Source
 26971                                  	;jnc	short OPENOK
 26972                                  
 26973                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 26974                                  	;	They asked for it...
 26975                                  
 26976                                  	;jmp	short Error_On_Source ;AC022; clean up and exit
 26977                                  
 26978                                  	; 26/03/2023
 26979                                  	; MSDOS 3.3
 26980                                  	;mov	dx,SRCBUF
 26981                                  	;mov	ax,OPEN*256 ; 3D00h
 26982                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 26983                                  	;			; DS:DX	-> ASCIZ filename
 26984                                  	;			; AL = access mode
 26985                                  	;			; 0 - read
 26986                                  	;jnc	short OPENOK
 26987                                  	;call	GET_EXT_ERR_NUMBER
 26988                                  	;pushf
 26989                                  	;cmp	ax,65
 26990                                  	;jnz	short DOCOPY_ERR
 26991                                  	;mov	dx,ACCDENPTR
 26992                                  	;call	STD_PRINTF
 26993                                  ;DOCOPY_ERR:
 26994                                  	;popf
 26995                                  	;retn
 26996                                  
 26997                                  	; 26/03/2023
 26998                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26999                                  OPENOK:
 27000 00003B6E 89C3                    	mov	bx,ax
 27001 00003B70 891E[A68D]              	mov	[SRCHAND],bx		; save handle
 27002 00003B74 B80057                  	mov	ax,File_Times*256 ; 5700h
 27003 00003B77 CD21                    	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 27004                                  				; BX = file handle
 27005                                  
 27006 00003B79 7223                    	jc	short Error_On_Source  ; MSDOS 6.0
 27007                                  
 27008 00003B7B 8916[0B8E]              	mov	[CPDATE],dx		; save date
 27009 00003B7F 890E[0D8E]              	mov	[CPTIME],cx		; save time
 27010                                  
 27011                                  	; MSDOS 6.0
 27012                                  	;jmp	short No_Copy_Xa 	; (xa copy code removed)
 27013                                  	; 26/04/2023
 27014                                  No_Copy_Xa:
 27015                                  	; 26/03/2023
 27016                                  	;mov	bx,[SRCHAND]		;AN022; get handle back
 27017                                  
 27018                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27019 00003B83 B80044                  	mov	ax,(IOCTL<<8) ; 4400h
 27020 00003B86 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27021                                  				; BX = file or device handle
 27022                                  	;and	dl,devid_ISDEV ; 80h
 27023                                  	; 18/04/2023
 27024 00003B88 80E280                  	and	dl,80h ; devid_ISDEV
 27025 00003B8B 8816[A88D]              	mov	[SRCISDEV],dl		; set source info
 27026 00003B8F 7436                    	jz	short COPYLP		; source not a device
 27027 00003B91 803E[048E]00            	cmp	byte [BINARY],0
 27028 00003B96 742F                    	je	short COPYLP		; ascii device ok
 27029 00003B98 BA[D980]                	mov	dx,INBDEV_PTR		; cannot do binary input
 27030 00003B9B E92703                  	jmp	COPYERR
 27031                                  
 27032                                  Error_On_Source:			;AN022; we have a BAD error
 27033 00003B9E E86CE1                  	call	Set_Ext_Error_Msg	;AN022; set up the error message
 27034 00003BA1 C706[D08C][4F8D]        	mov	word [string_ptr_2],SrcBuf
 27035                                  				;AN022; get address of failed string
 27036 00003BA7 C606[777F]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27037                                  				;AN022; put number of subst in control block
 27038 00003BAC E88C12                  	call	std_eprintf		;AN022; print it
 27039                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27040 00003BAF 8B1E[A68D]              	mov	bx,[SRCHAND]
 27041                                  	;cmp	word [SRCHAND],0	;AN022; did we open the file?
 27042                                  	;je	short No_Close_Src	;AN022; no - don't close
 27043 00003BB3 09DB                    	or	bx,bx
 27044 00003BB5 7403                    	jz	short No_Close_Src
 27045                                  	;call	CLOSESRC		;AN022; clean up
 27046                                  	; 26/03/2023
 27047 00003BB7 E89000                  	call	CLOSESRC2 ; bx = [SRCHAND]
 27048                                  No_Close_Src:				;AN022;
 27049 00003BBA 803E[FF8A]00            	cmp	byte [CFLAG],0		;AN022; was destination created?
 27050 00003BBF 7403                    	je	short EndCopyJ3		;AN022; no - just cleanup and exit
 27051 00003BC1 E9C7FD                  	jmp	ENDCOPY			;AN022; clean up concatenation and exit
 27052                                  EndCopyJ3:				;AN022;
 27053 00003BC4 E9C7FD                  	jmp	ENDCOPY2		;AN022;
 27054                                  
 27055                                  	; 26/04/2023
 27056                                  ;No_Copy_Xa:
 27057                                  ;	; 26/03/2023
 27058                                  ;	;mov	bx,[SRCHAND]		;AN022; get handle back
 27059                                  ;
 27060                                  ;	; MSDOS 3.3 (& MSDOS 6.0)
 27061                                  ;	mov	ax,(IOCTL<<8) ; 4400h
 27062                                  ;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27063                                  ;				; BX = file or device handle
 27064                                  ;	;and	dl,devid_ISDEV ; 80h
 27065                                  ;	; 18/04/2023
 27066                                  ;	and	dl,80h ; devid_ISDEV
 27067                                  ;	mov	[SRCISDEV],dl		; set source info
 27068                                  ;	jz	short COPYLP		; source not a device
 27069                                  ;	cmp	byte [BINARY],0
 27070                                  ;	je	short COPYLP		; ascii device ok
 27071                                  ;	mov	dx,INBDEV_PTR		; cannot do binary input
 27072                                  ;	jmp	COPYERR
 27073                                  
 27074                                  COPYLP:
 27075                                  	; 26/03/2023
 27076 00003BC7 8B1E[A68D]              	mov	bx,[SRCHAND] ; ? ; 26/03/2023
 27077 00003BCB 8B0E[018B]              	mov	cx,[BYTCNT]
 27078 00003BCF 8B16[038B]              	mov	dx,[NXTADD]
 27079 00003BD3 29D1                    	sub	cx,dx			; compute available space
 27080 00003BD5 750E                    	jnz	short GOTROOM
 27081 00003BD7 E8AE01                  	call	FlshFil   ; MSDOS 6.0
 27082                                  	;call	FLUSHFIL  ; MSDOS 3.3
 27083 00003BDA 803E[078E]00            	cmp	byte [TERMREAD],0
 27084 00003BDF 7565                    	jne	short CLOSESRC		; give up
 27085 00003BE1 8B0E[018B]              	mov	cx,[BYTCNT]
 27086                                  GOTROOM:
 27087 00003BE5 1E                      	push	ds
 27088 00003BE6 8E1E[E28A]              	mov	ds,[TPA]
 27089 00003BEA B43F                    	mov	ah,READ ; 3Fh
 27090 00003BEC CD21                    	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 27091                                  				; BX = file handle,CX = number of bytes to read
 27092                                  				; DS:DX	-> buffer
 27093 00003BEE 1F                      	pop	ds
 27094                                  	;jc	short CLOSESRC	; MSDOS 3.3
 27095                                  	; 26/03/2023
 27096 00003BEF 72AD                    	jc	short Error_On_Source ; MSDOS 6.0
 27097 00003BF1 89C1                    	mov	cx,ax			; get count
 27098 00003BF3 E351                    	jcxz	CLOSESRC		; no more to read
 27099 00003BF5 803E[A88D]00            	cmp	byte [SRCISDEV],0
 27100 00003BFA 7507                    	jne	short NOTESTA		; is a device, ascii mode
 27101 00003BFC 803E[088E]00            	cmp	byte [ASCII],0
 27102 00003C01 741B                    	je	short BINREAD
 27103                                  NOTESTA:
 27104 00003C03 89CA                    	mov	dx,cx
 27105 00003C05 8B3E[038B]              	mov	di,[NXTADD]
 27106 00003C09 B01A                    	mov	al,1Ah
 27107 00003C0B 06                      	push	es
 27108 00003C0C 8E06[E28A]              	mov	es,[TPA]		; scan for EOF
 27109 00003C10 F2AE                    	repne	scasb
 27110 00003C12 07                      	pop	es
 27111 00003C13 7505                    	jnz	short USEALL
 27112 00003C15 FE06[F38A]              	inc	byte [RDEOF]
 27113 00003C19 41                      	inc	cx
 27114                                  USEALL:
 27115 00003C1A 29CA                    	sub	dx,cx
 27116 00003C1C 89D1                    	mov	cx,dx
 27117                                  BINREAD:
 27118 00003C1E 030E[038B]              	add	cx,[NXTADD]
 27119 00003C22 890E[038B]              	mov	[NXTADD],cx
 27120 00003C26 3B0E[018B]              	cmp	cx,[BYTCNT]		; is buffer full?
 27121 00003C2A 720C                    	jb	short TESTDEV		; if not, we may have found eof
 27122                                  	; 26/03/2023
 27123 00003C2C E85901                  	call	FlshFil
 27124                                  	;call	FLUSHFIL
 27125 00003C2F 803E[078E]00            	cmp	byte [TERMREAD],0
 27126 00003C34 7510                    	jne	short CLOSESRC		; give up
 27127 00003C36 EB8F                    	jmp	short COPYLP
 27128                                  TESTDEV:
 27129 00003C38 803E[A88D]00            	cmp	byte [SRCISDEV],0	; if file then EOF
 27130 00003C3D 7407                    	je	short CLOSESRC
 27131 00003C3F 803E[F38A]00            	cmp	byte [RDEOF],0
 27132 00003C44 7481                    	je	short COPYLP		; on device, go till ^Z
 27133                                  CLOSESRC:
 27134 00003C46 8B1E[A68D]              	mov	bx,[SRCHAND]
 27135                                  CLOSESRC2:
 27136 00003C4A B43E                    	mov	ah,CLOSE ; 3Eh
 27137 00003C4C CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27138                                  				; BX = file handle
 27139                                  CLOSESRCDEST_RETN:
 27140 00003C4E C3                      	retn
 27141                                  
 27142                                  ; ---------------------------------------------------------------------------
 27143                                  
 27144                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27145                                  CLOSEDEST:
 27146                                  
 27147                                  	;	We are called to close the destination.
 27148                                  	;	We need to note whether or not there is any internal data left
 27149                                  	;	to be flushed out.
 27150                                  
 27151 00003C4F 803E[008B]00            	cmp	byte [DestClosed],0
 27152 00003C54 75F8                    	jne	short CLOSESRCDEST_RETN	; don't double close
 27153 00003C56 A0[FB8A]                	mov	al,[DestSwitch]
 27154 00003C59 E8C502                  	call	SETASC			; check for b or a switch
 27155 00003C5C 742E                    	jz	short BINCLOS		;   on destination
 27156 00003C5E 8B1E[038B]              	mov	bx,[NXTADD]
 27157                                  ;
 27158                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 27159                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 27160                                  ;just return without appending a ^Z incorrectly for the first file (since we
 27161                                  ;are concatenating now). Also, in case it is a single file copy, we will
 27162                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 27163                                  ;performance overhead on single ASCII file copies which now always involve
 27164                                  ;2 writes instead of 1 before. Is this really that important?
 27165                                  ;
 27166                                  ;M048;	cmp	bx,[BYTCNT]		; is memory full?
 27167                                  ;M048;	jne	short PutZ
 27168                                  
 27169                                  	; 26/03/2023
 27170                                  	; MSDOS 3.3
 27171                                  	;cmp	bx,[BYTCNT]		; is memory full?
 27172                                  	;jne	short PUTZ
 27173                                  
 27174                                  	; 26/03/2023
 27175 00003C62 E81601                  	call	TRYFLUSH		; flush (and double-check for concat)	
 27176 00003C65 7402                    	jz	short NOCONC
 27177                                  CONCHNG:
 27178 00003C67 F9                      	stc
 27179 00003C68 C3                      	retn
 27180                                  
 27181                                  NOCONC:	
 27182 00003C69 31DB                    	xor	bx,bx
 27183                                  PUTZ:
 27184 00003C6B 1E                      	push	ds
 27185 00003C6C 8E1E[E28A]              	mov	ds,[TPA]
 27186 00003C70 C7071A00                	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 27187 00003C74 1F                      	pop	ds
 27188 00003C75 FF06[038B]              	inc	word [NXTADD]	; make sure our ^z gets written	
 27189 00003C79 C606[038E]00            	mov	byte [NOWRITE],0
 27190 00003C7E A1[058E]                	mov	ax,[WRITTEN]
 27191 00003C81 0306[038B]              	add	ax,[NXTADD]
 27192 00003C85 7205                    	jc	short BINCLOS	; > 1
 27193 00003C87 83F801                  	cmp	ax,1
 27194 00003C8A 740C                    	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 27195                                  BINCLOS:
 27196 00003C8C E8EC00                  	call	TRYFLUSH
 27197 00003C8F 75D6                    	jnz	short CONCHNG
 27198                                  
 27199                                  	; 26/04/2023
 27200 00003C91 833E[058E]00            	cmp	word [WRITTEN],0
 27201                                  	; 26/03/2023
 27202 00003C96 7503                    	jnz	short NO_FORGET
 27203                                  FORGETITJ:
 27204                                  	;jz	short FORGETIT	; never wrote nothing
 27205                                  	; 26/03/2023
 27206 00003C98 E98500                  	jmp	FORGETIT ; 18/04/2023
 27207                                  NO_FORGET:			; wrote something
 27208 00003C9B 8B1E[438D]              	mov	bx,[DESTHAND]
 27209 00003C9F 8B0E[0D8E]              	mov	cx,[CPTIME]
 27210 00003CA3 8B16[0B8E]              	mov	dx,[CPDATE]
 27211 00003CA7 803E[028E]00            	cmp	byte [INEXACT],0 ; copy not exact?
 27212 00003CAC 7431                    	je	short DODCLOSE	; if no, copy date & time
 27213 00003CAE B42C                    	mov	ah,Get_Time ; 2Ch
 27214 00003CB0 CD21                    	int	21h		; DOS -	GET CURRENT TIME
 27215                                  				; Return: CH = hours,CL = minutes,DH = seconds
 27216                                  				; DL = hundredths of seconds
 27217 00003CB2 D0E1                    	shl	cl,1
 27218 00003CB4 D0E1                    	shl	cl,1		; left justify min in cl
 27219 00003CB6 D1E1                    	shl	cx,1
 27220 00003CB8 D1E1                    	shl	cx,1
 27221 00003CBA D1E1                    	shl	cx,1		; hours to high 5 bits, min to 5-10
 27222 00003CBC D0EE                    	shr	dh,1		; divide seconds by 2 (now 5 bits)
 27223 00003CBE 08F1                    	or	cl,dh		; and stick into low 5 bits of cx
 27224 00003CC0 51                      	push	cx		; save packed time
 27225 00003CC1 B42A                    	mov	ah,Get_Date ; 2Ah
 27226 00003CC3 CD21                    	int	21h		; DOS -	GET CURRENT DATE
 27227                                  				; Return: DL = day,DH = month,	CX = year
 27228                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 27229 00003CC5 81E9BC07                	sub	cx,1980
 27230 00003CC9 86E9                    	xchg	ch,cl
 27231 00003CCB D1E1                    	shl	cx,1		; year to high 7 bits
 27232 00003CCD D0E6                    	shl	dh,1		; month to high 3 bits
 27233 00003CCF D0E6                    	shl	dh,1
 27234 00003CD1 D0E6                    	shl	dh,1
 27235 00003CD3 D0E6                    	shl	dh,1
 27236 00003CD5 D0E6                    	shl	dh,1		; most sig bit of month in carry
 27237 00003CD7 80D500                  	adc	ch,0		; put that bit next to year
 27238 00003CDA 08F2                    	or	dl,dh		; or low three of month into day
 27239 00003CDC 88EE                    	mov	dh,ch		; get year and high bit of month
 27240 00003CDE 59                      	pop	cx
 27241                                  DODCLOSE:
 27242 00003CDF 83FB00                  	cmp	bx,0
 27243 00003CE2 7E36                    	jle	short CLOSEDONE
 27244 00003CE4 B80157                  	mov	ax,(File_Times<<8)|1 ; 5701h
 27245 00003CE7 CD21                    	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 27246                                  				; BX = file handle,CX = time to be set
 27247                                  				; DX = date to be set
 27248                                  	; 26/03/2023
 27249                                  	; MSDOS 6.0
 27250 00003CE9 721A                    	jc	short Cleanup_Err ;AN022; handle error
 27251                                  
 27252                                  	;	See if the destination has *anything* in it.
 27253                                  	;	If not, just close and delete it.
 27254                                  
 27255 00003CEB B80242                  	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 27256 00003CEE 31D2                    	xor	dx,dx
 27257 00003CF0 89D1                    	mov	cx,dx
 27258 00003CF2 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 27259                                  			; AL = method: offset from end of file
 27260                                  	;	DX:AX is file size
 27261                                  
 27262 00003CF4 09C2                    	or	dx,ax
 27263 00003CF6 9C                      	pushf
 27264 00003CF7 B80044                  	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 27265 00003CFA CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27266                                  			; BX = file or device handle
 27267 00003CFC 52                      	push	dx		; save them away
 27268 00003CFD B43E                    	mov	ah,CLOSE ; 3Eh
 27269 00003CFF CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27270                                  			; BX = file handle
 27271 00003D01 5A                      	pop	dx
 27272                                  
 27273                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27274                                  	; MSDOS 6.0
 27275 00003D02 730D                    	jnc	short Close_Cont ;AN022; handle error on close
 27276 00003D04 9D                      	popf			;AN022; get the flags back
 27277                                  Cleanup_Err: 			;AN022;
 27278 00003D05 E85A00                  	call	CleanUpErr	;AN022; attempt to delete the target
 27279                                  	; 26/03/2023
 27280                                  	;call	DestDelete	;AN022; attempt to delete the target
 27281                                  	;jmp	short FILECLOSED
 27282                                  	;			;AN022; close the file
 27283                                  	; 26/03/2023
 27284                                  DestDel_fclosed:
 27285 00003D08 E82700                  	call	DestDelete
 27286                                  FILECLOSED:
 27287 00003D0B FE06[008B]              	inc	byte [DestClosed]
 27288                                  RET50:
 27289 00003D0F F8                      	clc
 27290 00003D10 C3                      	retn
 27291                                  	
 27292                                  Close_Cont:			;AN022; no error - co
 27293                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27294 00003D11 9D                      	popf
 27295 00003D12 7506                    	jnz	short CLOSEDONE
 27296 00003D14 F7C28000                	test	dx,80h		; is the destination a device?
 27297                                  	;jnz	short CLOSEDONE	; yes, copy succeeded
 27298                                  	;call	DestDelete
 27299                                  	;jmp	short FILECLOSED
 27300                                  	; 26/03/2023
 27301 00003D18 74EE                    	jz	short DestDel_fclosed
 27302                                  CLOSEDONE:
 27303 00003D1A FF06[0C8B]              	inc	word [FileCnt]
 27304                                  	; 26/03/2023
 27305 00003D1E EBEB                    	jmp	short FILECLOSED
 27306                                  	
 27307                                  ;FILECLOSED:
 27308                                  ;	inc	byte [DestClosed]
 27309                                  ;RET50:
 27310                                  	;clc
 27311                                  	;retn
 27312                                  
 27313                                  FORGETIT:
 27314 00003D20 8B1E[438D]              	mov	bx,[DESTHAND]
 27315 00003D24 E8B8FF                  	call	DODCLOSE	 ; close the dest	
 27316 00003D27 E80800                  	call	DestDelete
 27317 00003D2A C706[0C8B]0000          	mov	word [FileCnt],0 ; no files transferred
 27318 00003D30 EBDD                    	jmp	short RET50
 27319                                  
 27320                                  ; ---------------------------------------------------------------------------
 27321                                  
 27322                                  	; 26/03/2023
 27323                                  DestDelete:
 27324 00003D32 BA[EC8C]                	mov	dx,DestBuf
 27325 00003D35 B441                    	mov	ah,Unlink ; 41h
 27326 00003D37 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 27327                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 27328                                  			;		(no wildcards allowed)
 27329 00003D39 C3                      	retn
 27330                                  
 27331                                  ; ---------------------------------------------------------------------------
 27332                                  
 27333                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27334                                  SOURCE_SET:
 27335 00003D3A 56                      	push	si
 27336 00003D3B A1[168E]                	mov	ax,[STARTEL]
 27337 00003D3E BE[A98D]                	mov	si,ScanBuf	; adjust to copy
 27338 00003D41 29F0                    	sub	ax,si
 27339 00003D43 BF[4F8D]                	mov	di,SrcBuf
 27340 00003D46 01F8                    	add	ax,di
 27341 00003D48 A3[4C8D]                	mov	[SrcTail],ax
 27342 00003D4B 880E[4B8D]              	mov	[SrcSiz],cl	; save its size
 27343 00003D4F 41                      	inc	cx		; include the nul
 27344 00003D50 F3A4                    	rep	movsb		; save this source
 27345 00003D52 883E[4E8D]              	mov	[SrcInfo],bh	; save info about it
 27346 00003D56 5E                      	pop	si
 27347 00003D57 89E8                    	mov	ax,bp		; switches so far
 27348 00003D59 E8C501                  	call	SETASC		; set a,b switches accordingly
 27349 00003D5C E845EA                  	call	SWITCH		; get any more switches on this arg
 27350                                  	;call	SETASC		; set
 27351                                  	;retn
 27352                                  	; 26/03/2023
 27353 00003D5F E9BF01                  	jmp	SETASC
 27354                                  
 27355                                  ; =============== S U B	R O U T	I N E =======================================
 27356                                  
 27357                                  ; MSDOS 6.0
 27358                                  
 27359                                  ;****************************************************************
 27360                                  ;*
 27361                                  ;* ROUTINE:	CleanupErr
 27362                                  ;*
 27363                                  ;* FUNCTION:	Issues extended error message for destination
 27364                                  ;*		if not alreay issued
 27365                                  ;*
 27366                                  ;* INPUT:	return from INT 21
 27367                                  ;*
 27368                                  ;* OUTPUT:	none
 27369                                  ;*
 27370                                  ;****************************************************************
 27371                                  
 27372                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27373                                  	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
 27374                                  CleanUpErr:	; proc	near		;AN022;
 27375                                  
 27376 00003D62 803E[528E]00            	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
 27377 00003D67 7511                    	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
 27378 00003D69 E8A1DF                  	call	Set_Ext_Error_Msg	;AN022; set up error message
 27379 00003D6C C706[D08C][EC8C]        	mov	word [string_ptr_2],DestBuf 
 27380                                  					;AN022; get address of failed string
 27381 00003D72 C606[777F]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27382                                  					;AN022; put number of subst in control block
 27383 00003D77 E8C110                  	call	std_eprintf		;AN022; issue the error message
 27384                                  CleanupErr_Cont:			;AN022;
 27385 00003D7A C3                      	retn				;AN022; return to caller
 27386                                  
 27387                                  ;CleanUpErr	endp			;AN022;
 27388                                  
 27389                                  ;============================================================================
 27390                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 27391                                  ;============================================================================
 27392                                  ; 01/10/2018 - Retro DOS v3.0
 27393                                  
 27394                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 27395                                  
 27396                                  ; =============== S U B	R O U T	I N E =======================================
 27397                                  
 27398                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 27399                                  ;
 27400                                  ;	EXIT	ZR set if concatenate flag unchanged
 27401                                  
 27402                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27403                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
 27404                                  TRYFLUSH:
 27405 00003D7B A0[F58A]                	mov	al,[Concat]
 27406 00003D7E 50                      	push	ax
 27407                                  	;call	FLUSHFIL
 27408 00003D7F E80600                  	call	FlshFil
 27409 00003D82 58                      	pop	ax
 27410 00003D83 3A06[F58A]              	cmp	al,[Concat]
 27411 00003D87 C3                      	retn
 27412                                  
 27413                                  ; =============== S U B	R O U T	I N E =======================================
 27414                                  
 27415                                  	; 26/03/2023
 27416                                  	; MSDOS 3.3
 27417                                  ;FLUSHFIL:
 27418                                  	;mov	al,[BINARY]
 27419                                  	;mov	ah,[ASCII]
 27420                                  	;push	ax
 27421                                  	;call	FLSHFIL
 27422                                  	;pop	ax
 27423                                  	;mov	[ASCII],ah
 27424                                  	;mov	[BINARY],al
 27425                                  	;retn
 27426                                  
 27427                                  ; =============== S U B	R O U T	I N E =======================================
 27428                                  
 27429                                  ;***	Flshfil - write out any data remaining in copy buffer.
 27430                                  ;
 27431                                  ;	Inputs:
 27432                                  ;	  [NXTADD] = No. of bytes to write
 27433                                  ;	  [CFLAG] <> 0 if file has been created
 27434                                  ;	Outputs:
 27435                                  ;	  [NXTADD] = 0
 27436                                  
 27437                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27438                                  FlshFil:
 27439 00003D88 C606[078E]00            	mov	byte [TERMREAD],0
 27440 00003D8D 803E[FF8A]00            	cmp	byte [CFLAG],0
 27441 00003D92 7403                    	jz	short NotExists
 27442 00003D94 E99600                  	jmp	Exists
 27443                                  NotExists:
 27444 00003D97 E8A101                  	call	BUILDDEST		; find out all about the destination
 27445 00003D9A E8FB03                  	call	COMPNAME		; source and dest. the same?
 27446 00003D9D 7519                    	jnz	short ProcDest		; if not, go ahead
 27447 00003D9F 803E[A88D]00            	cmp	byte [SRCISDEV],0
 27448 00003DA4 7512                    	jnz	short ProcDest		; same name on device ok
 27449 00003DA6 803E[F58A]00            	cmp	byte [Concat],0		; concatenation?
 27450 00003DAB BA[9E7F]                	mov	dx,OVERWR_PTR
 27451                                  	;je	short COPERR		; not concatenating - overwrite error
 27452                                  	; 26/03/2023
 27453 00003DAE 7503                    	jne	short No_Concat_Err
 27454 00003DB0 E91201                  	jmp	COPYERR
 27455                                  	
 27456                                  No_Concat_Err:	; concatenating
 27457 00003DB3 C606[038E]01            	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
 27458                                  ProcDest:
 27459                                  	; MSDOS 6.0
 27460                                  	;mov	ax,(ExtOpen<<8)		; open the file
 27461                                  	; 26/03/2023
 27462 00003DB8 B8006C                  	mov	ax,6C00h
 27463 00003DBB BE[EC8C]                	mov	si,DestBuf		; get file name
 27464                                  ;M046
 27465                                  ; For writes, we want to deny writes by anyone else at the same time that we
 27466                                  ;are writing to it. For instance, on a network, 2 workstations could try
 27467                                  ;writing to the same file. Also, because we opened the source file with
 27468                                  ;DENY NONE, it is fine if the source and destination files are the same as
 27469                                  ;would happen when we append to an existing file.
 27470                                  
 27471                                  	; 26/03/2023
 27472                                  	;mov	bx,deny_write|write_open_mode
 27473 00003DBE BB2100                  	mov	bx,21h			; get open mode for copy; M046
 27474 00003DC1 31C9                    	xor	cx,cx			; no special files
 27475                                  	;mov	dx,write_open_flag	; set up open flags
 27476 00003DC3 BA0101                  	mov	dx,101h	
 27477                                  
 27478 00003DC6 803E[038E]00            	cmp	byte [NOWRITE],0
 27479 00003DCB 7503                    	jne	short DoDestOpen	; don't actually create if nowrite set
 27480                                  	;mov	dx,creat_open_flag	; set up create flags
 27481 00003DCD BA1201                  	mov	dx,112h
 27482                                  
 27483                                  	; 26/03/2023
 27484                                  	; MSDOS 3.3
 27485                                  	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 27486                                  	;cmp	byte [NOWRITE],0
 27487                                  	;jne	short DODESTOPEN
 27488                                  	;mov	ah,CREAT ; 3Ch
 27489                                  	;xor	cx,cx
 27490                                  ;DODESTOPEN:
 27491                                  	;mov	dx,DESTBUF
 27492                                  	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 27493                                  	;		; CX = attributes for file
 27494                                  	;		; DS:DX	-> ASCIZ filename (may include drive and path)
 27495                                  
 27496                                  ; 26/03/2023
 27497                                  ;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 27498                                  ;	;mov	dx,FULDIRPTR
 27499                                  ;	;call	GET_EXT_ERR_NUMBER
 27500                                  ;	;jc	short COPERR
 27501                                  ;
 27502                                  ;	; 01/10/2018
 27503                                  ;	;jnc	short DEST_OPEN_OKAY
 27504                                  ;		
 27505                                  ;	;mov	dx,FULDIRPTR
 27506                                  ;	;call	GET_EXT_ERR_NUMBER
 27507                                  ;	;jmp	short COPERR
 27508                                  ;
 27509                                  ;	jc	short DEST_OPEN_ERROR
 27510                                  
 27511                                  	; 26/03/2023
 27512                                  DoDestOpen:
 27513 00003DD0 CD21                    	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
 27514                                  			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
 27515                                  			; BH = flags
 27516                                  			; CX = create attribute
 27517                                  			; DL = action if file exists/does not exists
 27518                                  			; DH = 00h (reserved), DS:SI -> ASCIZ file name
 27519                                  
 27520                                  ;	We assume that the error is normal.
 27521                                  ;	TriageError will correct the DX value appropriately.
 27522                                  	
 27523 00003DD2 7311                    	jnc	short Dest_Open_Okay
 27524                                  Xa_Set_Error:				;AN030; error occurred on XA
 27525 00003DD4 E836DF                  	call	Set_Ext_Error_Msg	;AN030; get extended error
 27526                                  
 27527                                  	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
 27528                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
 27529                                  Ext_Err_Set:				;AN030;
 27530 00003DD7 C706[D08C][EC8C]        	mov	word [string_ptr_2],DestBuf
 27531                                  					;AN000; get address of failed string
 27532 00003DDD C606[777F]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27533                                  					;AN030; put number of subst in control block
 27534                                  CopErrJ2:				;AN030;
 27535 00003DE2 E9E000                  	jmp	COPYERR			;AN030; go issue message
 27536                                  
 27537                                  ;DEST_OPEN_OKAY:
 27538                                  	; 26/03/2023
 27539                                  Dest_Open_Okay:
 27540 00003DE5 A3[438D]                	mov	[DESTHAND],ax		; save handle
 27541 00003DE8 C606[FF8A]01            	mov	byte [CFLAG],1		; destination now exists
 27542 00003DED 89C3                    	mov	bx,ax
 27543 00003DEF B80044                  	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
 27544 00003DF2 CD21                    	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 27545                                  			   	; BX = file or device handle
 27546                                  
 27547 00003DF4 8816[458D]              	mov	[DESTISDEV],dl		; set dest info
 27548                                  	; 18/04/2023
 27549 00003DF8 F6C280                  	test	dl,80h
 27550                                  	;test	dl,devid_ISDEV
 27551 00003DFB 7430                    	jz	short Exists		; Dest not a device
 27552                                  
 27553                                  ;	Destination is device.
 27554                                  
 27555 00003DFD A0[FB8A]                	mov	al,byte [DestSwitch]
 27556                                  	; 26/03/2023
 27557 00003E00 240C                    	and	al,0Ch
 27558                                  	;and	al,SWITCHA+SWITCHB ; 4+8
 27559 00003E02 7509                    	jnz	short TestBoth
 27560 00003E04 A0[088E]                	mov	al,[ASCII]		; neither set, use current setting
 27561 00003E07 0A06[048E]              	or	al,[BINARY]
 27562 00003E0B 7416                    	jz	short ExSetA		; neither set, default to ascii
 27563                                  TestBoth:
 27564 00003E0D 7A1E                    	jpe	short Exists		; both are set, ignore
 27565 00003E0F A808                    	test	al,8
 27566                                  	;test	al,SWITCHB
 27567 00003E11 741A                    	jz	short Exists
 27568                                  	;mov	ax,(IOCTL shl 8) or 1
 27569 00003E13 B80144                  	mov	ax,(IOCTL<<8)|1 ; 4401h
 27570 00003E16 30F6                    	xor	dh,dh
 27571                                  	; 18/04/2023
 27572 00003E18 80CA20                  	or	dl,20h
 27573                                  	;or	dl,devid_RAW
 27574 00003E1B 8816[458D]              	mov	[DESTISDEV],dl
 27575 00003E1F CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 27576                                  			; BX = device handle,DH = 0
 27577                                  			; DL = device information to set (bits 0-7 from	function 0)
 27578 00003E21 EB0A                    	jmp	short Exists
 27579                                  
 27580                                  	; 26/03/2023
 27581                                  	; 01/10/2018 - Retro DOS v3.0 modification
 27582                                  ;DEST_OPEN_ERROR:
 27583                                  	;mov	dx,FULDIRPTR
 27584                                  	;call	GET_EXT_ERR_NUMBER
 27585                                  ;COPERR:
 27586                                  	; 26/03/2023
 27587                                  ;CopyErrj:
 27588                                  	;jmp	short COPYERR
 27589                                  
 27590                                  ExSetA:
 27591                                  ;	What we read in may have been in binary mode, flag zapped write OK
 27592                                  
 27593 00003E23 C606[088E]04            	mov	byte [ASCII],4
 27594                                  	;mov	byte [ASCII],SWITCHA	; set ascii mode
 27595 00003E28 800E[028E]04            	or	byte [INEXACT],4
 27596                                  	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
 27597                                  Exists:
 27598 00003E2D 803E[038E]00            	cmp	byte [NOWRITE],0
 27599 00003E32 7524                    	jnz	short NoChecking	; if nowrite don't bother with name check
 27600 00003E34 803E[468C]01            	cmp	byte [plus_comma],1	; don't check if just doing +,,
 27601 00003E39 741D                    	jz	short NoChecking
 27602 00003E3B E85A03                  	call	COMPNAME		; source and dest. the same?
 27603 00003E3E 7518                    	jnz	short NoChecking	; if not, go ahead
 27604 00003E40 803E[A88D]00            	cmp	byte [SRCISDEV],0
 27605 00003E45 7511                    	jne	short NoChecking	; same name on device ok
 27606                                  
 27607                                  ;	At this point we know in append (would have gotten overwrite error
 27608                                  ;	on first destination create otherwise), and user trying to specify
 27609                                  ;	destination which has been scribbled already (if dest had been named
 27610                                  ;	first, NoWrite would be set).
 27611                                  
 27612 00003E47 BA[A17F]                	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
 27613                                  	;invoke	Std_EprintF		;ac022;
 27614                                  	; 26/03/2023
 27615 00003E4A E8EE0F                  	call	std_eprintf ; MSDOS 6.0 (& 5.0)
 27616                                  	;call	STD_PRINTF  ; MSDOS 3.3	
 27617 00003E4D C706[038B]0000          	mov	word [NXTADD],0		; set return
 27618 00003E53 FE06[078E]              	inc	byte [TERMREAD]		; tell read to give up
 27619                                  Ret60:
 27620 00003E57 C3                      	retn
 27621                                  
 27622                                  NoChecking:
 27623 00003E58 8B1E[438D]              	mov	bx,[DESTHAND]		; get handle
 27624 00003E5C 31C9                    	xor	cx,cx
 27625 00003E5E 870E[038B]              	xchg	cx,[NXTADD]
 27626 00003E62 E3F3                    	jcxz	Ret60			; if nothing to write, forget it
 27627 00003E64 FF06[058E]              	inc	word [WRITTEN]		; flag that we wrote something
 27628 00003E68 803E[038E]00            	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 27629 00003E6D 7514                    	jnz	short SeekEnd
 27630 00003E6F 31D2                    	xor	dx,dx
 27631 00003E71 1E                      	push	ds
 27632 00003E72 8E1E[E28A]              	mov	ds,[TPA]
 27633 00003E76 B440                    	mov	ah,Write ; 40h
 27634 00003E78 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 27635                                  			; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 27636 00003E7A 1F                      	pop	ds
 27637 00003E7B BA[897F]                	mov	dx,NOSPACE_PTR
 27638                                  	;jc	short COPERRP		; failure
 27639                                  	; 26/03/2023
 27640                                  	; MSDOS 6.0
 27641 00003E7E 7326                    	jnc	short NoChecking2
 27642 00003E80 E951FF                  	jmp	Xa_Set_Error
 27643                                  
 27644                                  	; 18/04/2023
 27645                                  	; 26/03/2023
 27646                                  SeekEnd:
 27647 00003E83 31D2                    	xor	dx,dx
 27648 00003E85 87D1                    	xchg	dx,cx
 27649                                  	;mov	ax,(LSEEK shl 8) or 1
 27650 00003E87 B80142                  	mov	ax,(LSEEK<<8)|1 ; 4201h
 27651 00003E8A CD21                    	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 27652                                  				; AL = method: offset from present location
 27653                                  
 27654                                  	; 26/03/2023
 27655                                  	; MSDOS 6.0
 27656                                  
 27657                                  ;	Save the file pointer in DX:AX to restore the file
 27658                                  ;	with in case the copy should fail.
 27659                                  
 27660 00003E8C A3[0F8E]                	mov	[OFilePtr_Lo],ax
 27661 00003E8F 8916[118E]              	mov	[OFilePtr_Hi],dx
 27662                                  
 27663                                  	; 26/03/2023
 27664                                  	; MSDOS 3.3  MSDOS 6.0
 27665                                  
 27666 00003E93 803E[F38A]00            	cmp	byte [RDEOF],0
 27667 00003E98 740B                    	jz	short Retz60
 27668                                  
 27669                                  ;	^Z has been read - we must set the file size to the current
 27670                                  ;	file pointer location
 27671                                  
 27672 00003E9A B440                    	mov	ah,Write ; 40h
 27673 00003E9C CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 27674                                  				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 27675                                  
 27676                                  	; 26/03/2023
 27677                                  	; MSDOS 6.0
 27678 00003E9E 727E                    	jc	short Xa_Set_Error_Jmp	;AC022; failure
 27679                                  
 27680                                  ;	Make note that ^Z was removed, in case the
 27681                                  ;	copy should fail and we need to restore the file.
 27682                                  
 27683 00003EA0 C606[138E]1A            	mov	byte [OCtrlZ],1Ah
 27684                                  Retz60:
 27685 00003EA5 C3                      	retn
 27686                                  
 27687                                  NoChecking2:
 27688 00003EA6 29C1                    	sub	cx,ax
 27689 00003EA8 74AD                    	jz	short Ret60		; wrote all supposed to
 27690                                  	; 18/04/2023
 27691 00003EAA F606[458D]80            	test	byte [DESTISDEV],80h ; devid_ISDEV
 27692                                  	;test	byte [DESTISDEV],devid_ISDEV ;80h
 27693 00003EAF 7414                    	jz	short COPYERR		; is a file, error
 27694 00003EB1 F606[458D]20            	test	byte [DESTISDEV],20h  ; devid_RAW
 27695                                  	;test	byte [DESTISDEV],devid_RAW ; 20h
 27696 00003EB6 750A                    	jnz	short DevWrtErr	; is a raw device, error
 27697 00003EB8 803E[028E]00            	cmp	byte [INEXACT],0
 27698 00003EBD 7598                    	jnz	short Ret60		; inexact so ok
 27699 00003EBF 49                      	dec	cx
 27700                                  ;Retz60:
 27701 00003EC0 7495                    	jz	short Ret60		; wrote one byte less (the ^z)		
 27702                                  
 27703                                  DevWrtErr:
 27704 00003EC2 BA[0C81]                	mov	dx,DEVWMES_PTR
 27705                                  	; 26/03/2023
 27706                                  COPYERR:
 27707                                  	;invoke	Std_EPrintF		;AC022;
 27708 00003EC5 E8730F                  	call	std_eprintf  ; MSDOS 6.0
 27709                                  	;call	STD_PRINTF   ; MSDOS 3.3
 27710                                  CopErrP:
 27711 00003EC8 FE06[008B]              	inc	byte [DestClosed]
 27712 00003ECC 803E[FF8A]00            	cmp	byte [CFLAG],0
 27713 00003ED1 7448                    	jz	short EndCopyJ		; never actually got it open
 27714 00003ED3 8B1E[438D]              	mov	bx,[DESTHAND]
 27715 00003ED7 83FB00                  	cmp	bx,0
 27716 00003EDA 7E33                    	jle	short NoClose
 27717                                  
 27718                                  ;	Check to see if we should save part of the destination file.
 27719                                  
 27720                                  	; 26/03/2023
 27721                                  	; MSDOS 6.0
 27722 00003EDC 8B0E[118E]              	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
 27723 00003EE0 8B16[0F8E]              	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
 27724                                  			
 27725 00003EE4 89C8                    	mov	ax,cx
 27726 00003EE6 09D0                    	or	ax,dx
 27727 00003EE8 7421                    	jz	short ceClose		; null file ptr means nothing to save
 27728                                  
 27729                                  ;	Destination was also the first source. Do the best we can to
 27730                                  ;	restore it. Truncate it back to the size we took from it (which
 27731                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 27732                                  ;	file). If a Ctrl-Z was originally read, put it back.
 27733                                  
 27734 00003EEA B80042                  	mov	ax,(LSEEK<<8) ; 4200h
 27735 00003EED CD21                    	int	21h
 27736                                  
 27737 00003EEF 31C9                    	xor	cx,cx			; CX = # bytes to write = 0
 27738 00003EF1 B440                    	mov	ah,Write ; 40h
 27739 00003EF3 CD21                    	int	21h			; truncate file
 27740                                  
 27741 00003EF5 803E[138E]00            	cmp	byte [OCtrlZ],0
 27742 00003EFA 7408                    	je	short ceClose0		; no ctrl-z removed from original
 27743 00003EFC 41                      	inc	cx			; CX = # bytes to write = 1
 27744 00003EFD BA[138E]                	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
 27745 00003F00 B440                    	mov	ah,Write ; 40h
 27746 00003F02 CD21                    	int	21h			; write ctrl-z
 27747                                  ceClose0:
 27748 00003F04 B43E                    	mov	ah,CLOSE ; 3Eh
 27749 00003F06 CD21                    	int	21h			; close it
 27750                                  ;;	;mov	byte [CFLAG],0
 27751 00003F08 E980FA                  	jmp	ENDCOPY			; and go home
 27752                                  
 27753                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27754                                  ceClose:
 27755 00003F0B B43E                    	mov	ah,CLOSE ; 3Eh		; close the file
 27756 00003F0D CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27757                                  				; BX = file handle
 27758                                  NoClose:
 27759 00003F0F BA[EC8C]                	mov	dx,DestBuf
 27760 00003F12 B441                    	mov	ah,Unlink ; 41h 	; and delete it
 27761 00003F14 CD21                    	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 27762                                  				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 27763 00003F16 C606[FF8A]00            	mov	byte [CFLAG],0
 27764                                  EndCopyJ:
 27765 00003F1B E96DFA                  	jmp	ENDCOPY
 27766                                  
 27767                                  Xa_Set_Error_Jmp:			;AN022; go set up error message
 27768 00003F1E E9B3FE                  	jmp	Xa_Set_Error
 27769                                  
 27770                                  ;============================================================================
 27771                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 27772                                  ;============================================================================
 27773                                  ; 01/10/2018 - Retro DOS v3.0
 27774                                  
 27775                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 27776                                  
 27777                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27778                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h
 27779                                  
 27780                                  ; =============== S U B	R O U T	I N E =======================================
 27781                                  
 27782                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 27783                                  ;
 27784                                  ;	Given switch vector in AX,
 27785                                  ;	  Set Ascii flag if /a is set
 27786                                  ;	  Clear Ascii flag if /b is set
 27787                                  ;	  Binary set if /b specified
 27788                                  ;	  Leave Ascii unchanged if neither or both are set
 27789                                  ; 	Also sets Inexact if Ascii is ever set. 
 27790                                  ;	AL = Ascii on exit, flags set
 27791                                  
 27792                                  	; 26/03/2023
 27793                                  SETASC:
 27794                                  	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 27795 00003F21 240C                    	and	al,0Ch ; 4+8
 27796 00003F23 7A10                    	jpe	short LOADSW	; even parity - both or neither
 27797 00003F25 50                      	push	ax
 27798                                  	;and	al,SWITCHB  ; 8
 27799 00003F26 2408                    	and	al,8
 27800 00003F28 A2[048E]                	mov	[BINARY],al
 27801 00003F2B 58                      	pop	ax
 27802                                  	;and	al,SWITCHA
 27803 00003F2C 2404                    	and	al,4	
 27804 00003F2E A2[088E]                	mov	[ASCII],al
 27805 00003F31 0806[028E]              	or	[INEXACT],al
 27806                                  LOADSW:
 27807 00003F35 A0[088E]                	mov	al,[ASCII]
 27808 00003F38 08C0                    	or	al,al
 27809 00003F3A C3                      	retn
 27810                                  
 27811                                  ; =============== S U B	R O U T	I N E =======================================
 27812                                  
 27813                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27814                                  BUILDDEST:
 27815 00003F3B 803E[E78C]FF            	cmp	byte [DestIsDir],-1 ; 0FFh
 27816 00003F40 750C                    	jnz	short KNOWABOUTDEST	; figuring already done
 27817 00003F42 BF[C289]                	mov	di,USERDIR1
 27818 00003F45 BD[E78C]                	mov	bp,DestVars
 27819 00003F48 E8DF00                  	call	BUILDPATH
 27820 00003F4B E858E5                  	call	RestUDir1
 27821                                  
 27822                                  ;	We now know all about the destination
 27823                                  
 27824                                  KNOWABOUTDEST:
 27825 00003F4E 30C0                    	xor	al,al
 27826 00003F50 8606[468D]              	xchg	al,[FIRSTDEST]
 27827 00003F54 08C0                    	or	al,al
 27828 00003F56 7503                    	jnz	short FIRSTDST
 27829 00003F58 E98C00                  	jmp	NOFIRSTDEST
 27830                                  
 27831                                  FIRSTDST:
 27832                                  ;	Create an fcb of the original dest.
 27833                                  
 27834 00003F5B 8B36[E98C]              	mov	si,[DestTail]
 27835 00003F5F BF[A68B]                	mov	di,DestFcb
 27836 00003F62 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27837 00003F65 CD21                    	int	21h		; DOS -	PARSE FILENAME
 27838                                  				; DS:SI	-> string to parse
 27839                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27840                                  				; AL = bit mask	to control parsing
 27841 00003F67 803C00                  	cmp	byte [si],0
 27842 00003F6A 7406                    	jz	short GOODPARSE
 27843                                  
 27844                                  	; 27/03/2023	
 27845                                  	; MSDOS 6.0
 27846                                  	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
 27847                                  	
 27848 00003F6C BA[8F7F]                	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
 27849 00003F6F E953FF                  	jmp	COPYERR			;AN052;
 27850                                  GOODPARSE:
 27851 00003F72 A1[EC8C]                	mov	ax,[DestBuf]		; AX = possible "d:"
 27852 00003F75 80FC3A                  	cmp	ah,':'
 27853 00003F78 7402                    	jz	short DRVSPEC4
 27854 00003F7A B040                    	mov	al,'@'  ; 40h
 27855                                  DRVSPEC4:
 27856                                  ;	AX = "d:" for following FCB drive computation
 27857                                  
 27858 00003F7C 8A0E[088E]              	mov	cl,[ASCII]		; CL = saved Ascii flag
 27859 00003F80 0C20                    	or	al,20h
 27860 00003F82 2C60                    	sub	al,60h
 27861 00003F84 A2[A68B]                	mov	[DestFcb],al		; store drive # in FCB
 27862                                  
 27863                                  ;*	Figure out what copy mode we're in.
 27864                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 27865                                  ;	+n stands for additional sources delimited by +'s.
 27866                                  ;
 27867                                  ;	copy a b	not concatenating
 27868                                  ;	copy a *	not concatenating
 27869                                  ;	copy * a	concatenating
 27870                                  ;	copy * *	not concatenating
 27871                                  ;	copy a+n b	concatenating
 27872                                  ;	copy *+n a	concatenating
 27873                                  ;	copy *+n *	concatenating, Mel Hallerman style
 27874                                  
 27875                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 27876                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 27877                                  
 27878 00003F87 A0[EB8C]                	mov	al,[DestInfo]		; AL = destination CParse flags
 27879 00003F8A 8A26[4E8D]              	mov	ah,[SrcInfo]		; AH = source CParse flags
 27880 00003F8E 250202                  	and	ax,202h			; AH,AL = source,dest wildcard flags
 27881 00003F91 08C0                    	or	al,al
 27882 00003F93 7413                    	jz	short NOTMELCOPY 	; no destination wildcard
 27883                                  
 27884                                  ;	Destination is wildcarded.
 27885                                  	
 27886 00003F95 38E0                    	cmp	al,ah
 27887 00003F97 750F                    	jnz	short NOTMELCOPY ; no source wildcard
 27888                                  
 27889                                  ;	Source and destination are both wildcarded.
 27890                                  
 27891 00003F99 803E[098E]00            	cmp	byte [PLUS],0
 27892 00003F9E 7408                    	jz	short NOTMELCOPY	; no +'s in source
 27893                                  
 27894                                  ;	Source and destination are wildcarded, and source includes +'s.
 27895                                  ;	It's Mel Hallorman copy time.
 27896                                  
 27897 00003FA0 FE06[478D]              	inc	byte [MELCOPY]		; 'Mel copy' = true
 27898 00003FA4 30C0                    	xor	al,al
 27899 00003FA6 EB06                    	jmp	short SETCONC
 27900                                  
 27901                                  NOTMELCOPY:
 27902 00003FA8 3402                    	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
 27903 00003FAA 20E0                    	and	al,ah
 27904 00003FAC D0E8                    	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
 27905                                  					;   (implies concatenation)
 27906                                  SETCONC:
 27907 00003FAE 0A06[098E]              	or	al,[PLUS]		; "+" always infers concatenation
 27908                                  
 27909                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 27910                                  
 27911 00003FB2 A2[F58A]                	mov	[Concat],al
 27912 00003FB5 D0E0                    	shl	al,1
 27913 00003FB7 D0E0                    	shl	al,1
 27914 00003FB9 A2[028E]                	mov	[INEXACT],al		; concatenation -> inexact copy
 27915 00003FBC 803E[048E]00            	cmp	byte [BINARY],0
 27916 00003FC1 7524                    	jne	short NOFIRSTDEST 	; explicit binary copy	
 27917                                  
 27918 00003FC3 A2[088E]                	mov	[ASCII],al		; otherwise, concatenate in ascii mode	
 27919 00003FC6 08C9                    	or	cl,cl
 27920 00003FC8 751D                    	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly	
 27921 00003FCA 08C0                    	or	al,al
 27922 00003FCC 7419                    	jz	short NOFIRSTDEST 	; Ascii flag did not change state
 27923                                  
 27924                                  ;	At this point there may already be binary read data in the read
 27925                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 27926                                  ;	amount of data in the buffer correctly.
 27927                                  
 27928 00003FCE 8B0E[038B]              	mov	cx,[NXTADD]
 27929 00003FD2 E313                    	jcxz	NOFIRSTDEST		; no data, everything ok
 27930 00003FD4 B01A                    	mov	al,1Ah
 27931 00003FD6 06                      	push	es
 27932 00003FD7 31FF                    	xor	di,di
 27933 00003FD9 8E06[E28A]              	mov	es,[TPA]
 27934 00003FDD F2AE                    	repne	scasb			; scan for EOF
 27935 00003FDF 07                      	pop	es
 27936 00003FE0 7505                    	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
 27937 00003FE2 4F                      	dec	di			; point at ^z
 27938 00003FE3 893E[038B]              	mov	[NXTADD],di		; new buffer length
 27939                                  
 27940                                  NOFIRSTDEST:
 27941 00003FE7 BB[EA8B]                	mov	bx,DIRBUF+1		; Source of replacement chars
 27942 00003FEA 803E[F58A]00            	cmp	byte [Concat],0
 27943 00003FEF 7403                    	jz	short GOTCHRSRC		; Not a concat
 27944 00003FF1 BB[308C]                	mov	bx,SDIRBUF+1		; Source of replacement chars
 27945                                  GOTCHRSRC:
 27946 00003FF4 BE[A78B]                	mov	si,DestFcb+1		; Original dest name
 27947 00003FF7 8B3E[E98C]              	mov	di,[DestTail]		; Where to put result
 27948                                  
 27949                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 27950                                  
 27951                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27952                                  BUILDNAME:
 27953 00003FFB B90800                  	mov	cx,8
 27954                                  BUILDMAIN:
 27955 00003FFE AC                      	lodsb
 27956 00003FFF 3C3F                    	cmp	al,'?'
 27957 00004001 7502                    	jne	short NOTAMBIG
 27958 00004003 8A07                    	mov	al,[bx]
 27959                                  NOTAMBIG:
 27960 00004005 3C20                    	cmp	al,' '
 27961 00004007 7401                    	je	short NOSTORE
 27962 00004009 AA                      	stosb
 27963                                  NOSTORE:
 27964 0000400A 43                      	inc	bx
 27965 0000400B E2F1                    	loop	BUILDMAIN
 27966 0000400D B103                    	mov	cl,3
 27967                                  	;mov	al,' ' ; 20h
 27968                                  	;cmp	[si],al
 27969                                  	; 27/03/2023
 27970 0000400F 803C20                  	cmp	byte [si],20h ; ' '
 27971 00004012 7412                    	je	short ENDDEST		; No extension
 27972                                  	;mov	al,[DOT_CHR]
 27973                                  	; 27/03/2023
 27974 00004014 B02E                    	mov	al,'.' ; 2Eh ; dot_chr
 27975 00004016 AA                      	stosb
 27976                                  BUILDEXT:
 27977 00004017 AC                      	lodsb
 27978 00004018 3C3F                    	cmp	al,'?'
 27979 0000401A 7502                    	jne	short NOTAMBIGE
 27980 0000401C 8A07                    	mov	al,[bx]
 27981                                  NOTAMBIGE:
 27982 0000401E 3C20                    	cmp	al,' '
 27983 00004020 7401                    	je	short NOSTOREE
 27984 00004022 AA                      	stosb
 27985                                  NOSTOREE:
 27986 00004023 43                      	inc	bx
 27987 00004024 E2F1                    	loop	BUILDEXT
 27988                                  ENDDEST:
 27989 00004026 30C0                    	xor	al,al
 27990 00004028 AA                      	stosb				; NUL terminate
 27991 00004029 C3                      	retn
 27992                                  
 27993                                  ; =============== S U B	R O U T	I N E =======================================
 27994                                  	
 27995                                  	; 28/03/2023
 27996                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27997                                  BUILDPATH:
 27998 0000402A F6460402                	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
 27999 0000402E 7543                    	jnz	short NOTPFILE		; If ambig don't bother with open
 28000 00004030 89EA                    	mov	dx,bp			; Set DX to spec
 28001 00004032 83C205                  	add	dx,VARSTRUC.BUF 	; add dx,5
 28002                                  
 28003                                  	; 27/03/2023
 28004                                  	; MSDOS 6.0
 28005 00004035 57                      	push	di			;AN000;
 28006 00004036 B8006C                  	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
 28007                                  	;mov	bx,deny_none|read_open_mode
 28008 00004039 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 28009 0000403C 31C9                    	xor	cx,cx			;AN000; no special files
 28010 0000403E 89D6                    	mov	si,dx			;AN030; get file name offset
 28011                                  	;mov	dx,read_open_flag	;AN000; set up open flags
 28012 00004040 BA0101                  	mov	dx,101h
 28013 00004043 CD21                    	INT	21h
 28014 00004045 5F                      	pop	di			;AN000;
 28015 00004046 7315                    	jnc	short PURE_FILE		;AN022; is pure file
 28016 00004048 E8D2DC                  	call	get_ext_error_number	;AN022; get the extended error
 28017                                  	;cmp	ax,2
 28018 0000404B 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
 28019 0000404E 7423                    	jz	short NOTPFILE		;AN022;
 28020                                  	;cmp	ax,3
 28021 00004050 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28022 00004053 741E                    	jz	short NOTPFILE		;AN022;
 28023                                  	;cmp	ax,5
 28024 00004055 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28025 00004058 7419                    	jz	short NOTPFILE		;AN022;
 28026 0000405A E900DA                  	jmp	extend_setup		;AN022; exit with error
 28027                                  
 28028                                  	; 27/03/2023
 28029                                  	; MSDOS 3.3
 28030                                  	;mov	ax,OPEN*256 ; 3D00h
 28031                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 28032                                  	;			; DS:DX	-> ASCIZ filename
 28033                                  	;			; AL = access mode
 28034                                  	;			; 0 - read
 28035                                  	;jc	short NOTPFILE
 28036                                  
 28037                                  PURE_FILE:
 28038 0000405D 89C3                    	mov	bx,ax
 28039 0000405F B80044                  	mov	ax,IOCTL*256 ; 4400h
 28040 00004062 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28041                                  				; BX = file or device handle
 28042 00004064 B43E                    	mov	ah,CLOSE ;3Eh
 28043 00004066 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28044                                  				; BX = file handle
 28045                                  	; 18/04/2023
 28046 00004068 F6C280                  	test	dl,80h
 28047                                  	;test	dl,devid_ISDEV ; test dl,80h
 28048 0000406B 7553                    	jnz	short ISADEV
 28049 0000406D F6460404                	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 28050 00004071 744D                    	jz	short ISADEV
 28051                                  NOTPFILE:
 28052 00004073 8B5605                  	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 28053                                  	
 28054                                  	; 27/03/2023	
 28055                                  	; MSDOS 6.0
 28056 00004076 80FA00                  	cmp	dl,0		     	;AN034; If no drive specified, get
 28057 00004079 7405                    	je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 28058                                  
 28059 0000407B 80FE3A                  	cmp	dh,':'
 28060 0000407E 7402                    	je	short DRVSPEC5
 28061                                  SET_DRIVE_SPEC:
 28062 00004080 B240                    	mov	dl,'@' ; 40h
 28063                                  DRVSPEC5:
 28064 00004082 80CA20                  	or	dl,20h
 28065 00004085 80EA60                  	sub	dl,60h		; A = 1
 28066 00004088 E84BE5                  	call	SAVUDIR1
 28067                                  	
 28068                                  	; 27/03/2023
 28069                                  	; MSDOS 6.0
 28070 0000408B 7306                    	jnc	short CURDIR_OK		;AN022; if error - exit
 28071 0000408D E88DDC                  	call	get_ext_error_number	;AN022; get the extended error
 28072 00004090 E9CAD9                  	jmp	extend_setup		;AN022; exit with error
 28073                                  
 28074                                  CURDIR_OK:
 28075 00004093 89EA                    	mov	dx,bp
 28076                                  	;add	dx,5
 28077 00004095 83C205                  	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 28078                                  	;mov	bh,[bp+4]
 28079 00004098 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28080 0000409B 80E706                  	and	bh,6
 28081 0000409E 80FF06                  	cmp	bh,6			; Ambig and path ?
 28082 000040A1 7518                    	jne	short CHECKAMB		; jmp if no
 28083                                  	;mov	si,[bp+2]
 28084 000040A3 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28085 000040A6 B33A                    	mov	bl,':'
 28086 000040A8 385CFE                  	cmp	[si-2],bl
 28087 000040AB 7506                    	jne	short KNOWNOTSPEC
 28088                                  	;mov	byte [bp+VARSTRUC.ISDIR],2
 28089                                  					; Know is d:/file
 28090                                  	;mov	byte [bp+0],2
 28091 000040AD C6460002                	mov	byte [bp],2
 28092 000040B1 EB05                    	jmp	short DOPCDJ
 28093                                  KNOWNOTSPEC:
 28094                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 28095                                  					; Know is path/file
 28096                                  	;mov	byte [bp+0],1		
 28097 000040B3 C6460001                	mov	byte [bp],1
 28098 000040B7 4E                      	dec	si
 28099                                  DOPCDJ:
 28100 000040B8 E98500                  	jmp	DOPCD
 28101                                  CHECKAMB:
 28102 000040BB 80FF02                  	cmp	bh,2
 28103 000040BE 7505                    	jnz	short CHECKCD
 28104                                  ISSIMPFILE:
 28105                                  ISADEV:
 28106                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28107                                  	;mov	byte [bp+0],0		
 28108 000040C0 C6460000                	mov	byte [bp],0
 28109 000040C4 C3                      	retn
 28110                                  CHECKCD:
 28111 000040C5 E84AEC                  	call	SetRest1
 28112 000040C8 B43B                    	mov	ah,CHDir ; 3Bh
 28113 000040CA CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28114                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28115 000040CC 723B                    	jb	short NOTPDIR
 28116 000040CE 89D7                    	mov	di,dx
 28117 000040D0 31C0                    	xor	ax,ax
 28118 000040D2 89C1                    	mov	cx,ax
 28119 000040D4 49                      	dec	cx
 28120 000040D5 F2AE                    	repne	scasb
 28121                                  
 28122                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28123                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
 28124                                  	; MSDOS 6.0
 28125                                  Kloop:					;AN000;  3/3/KK
 28126 000040D7 268A05                  	mov	al,[es:di]		;AN000;  3/3/KK
 28127 000040DA 47                      	inc	di			;AN000;  3/3/KK
 28128 000040DB 08C0                    	or	al,al			;AN000;  3/3/KK
 28129 000040DD 740C                    	jz	short DONE		;AN000;  3/3/KK
 28130 000040DF 30E4                    	xor	ah,ah			;AN000;  3/3/KK
 28131 000040E1 E800E3                  	call	testkanj		;AN000;  3/3/KK
 28132 000040E4 74F1                    	jz	short Kloop		;AN000;  3/3/KK
 28133 000040E6 47                      	inc	di			;AN000;  3/3/KK
 28134 000040E7 FEC4                    	inc	ah			;AN000;  3/3/KK
 28135 000040E9 EBEC                    	jmp	short Kloop		;AN000;  3/3/KK
 28136                                  DONE:
 28137 000040EB 4F                      	dec	di
 28138 000040EC A0[E58A]                	mov	al,[DIRCHAR]
 28139                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28140                                  	;mov	byte [bp+0],2
 28141 000040EF C6460002                	mov	byte [bp],2
 28142                                  	; 27/03/2023
 28143                                  	; MSDOS 6.0
 28144 000040F3 08E4                    	or	ah,ah			;AN000; 3/3/KK
 28145 000040F5 7505                    	jnz	short _STORE_PCHAR	;AN000; 3/3/KK	 this is the tra
 28146                                  	;
 28147 000040F7 3A45FF                  	cmp	al,[di-1]
 28148 000040FA 7405                    	jz	short GOTSRCSLSH
 28149                                  _STORE_PCHAR:
 28150 000040FC AA                      	stosb
 28151                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 28152                                  	;mov	byte [bp+0],1
 28153 000040FD C6460001                	mov	byte [bp],1
 28154                                  GOTSRCSLSH:
 28155                                  	;or	byte [bp+4],6
 28156 00004101 804E0406                	or 	byte [bp+VARSTRUC.INFO],6 
 28157 00004105 E87400                  	call	SETSTARS
 28158                                  NOTPDIR_RETN:
 28159 00004108 C3                      	retn
 28160                                  
 28161                                  	; 28/03/2023
 28162                                  NOTPDIR:
 28163                                  	; MSDOS 6.0
 28164 00004109 E811DC                  	call	get_ext_error_number	;AN022; get the extended error
 28165                                  	;cmp	ax,3
 28166 0000410C 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28167 0000410F 7405                    	je	short NOTPDIR_TRY	;AN022;
 28168                                  	;cmp	ax,5
 28169 00004111 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28170 00004114 7560                    	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
 28171                                  NOTPDIR_TRY:
 28172                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28173                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28174                                  	;mov	byte [bp+0],0
 28175 00004116 C6460000                	mov	byte [bp],0
 28176                                  	;mov	bh,[bp+4]
 28177 0000411A 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28178 0000411D F6C704                  	test	bh,4
 28179 00004120 74E6                    	jz	short NOTPDIR_RETN	; Know pure file, no path seps
 28180                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28181                                  	;mov	byte [bp+0],2		
 28182 00004122 C6460002                	mov	byte [bp],2
 28183                                  	;mov	si,[bp+2]
 28184 00004126 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28185 00004129 803C00                  	cmp	byte [si],0
 28186 0000412C 744B                    	je	short BADCDERRJ2	; Trailing '/'	
 28187                                  	;mov	bl,[DOT_CHR]
 28188                                  	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 28189                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 28190 0000412E B32E                    	mov	bl,'.'  ; 2Eh ; dot_chr
 28191 00004130 381C                    	cmp	[si],bl
 28192 00004132 7445                    	je	short BADCDERRJ2	; If . or .. pure cd should have worked
 28193 00004134 B33A                    	mov	bl,':'  ; 3Ah
 28194 00004136 385CFE                  	cmp	[si-2],bl
 28195 00004139 7405                    	je	short DOPCD		; Know d:/file
 28196                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 
 28197                                  					; Know path/file
 28198                                  	;mov	byte [bp+0],1
 28199 0000413B C6460001                	mov	byte [bp],1
 28200 0000413F 4E                      	dec	si			; Point at last '/'
 28201                                  DOPCD:
 28202 00004140 30DB                    	xor	bl,bl
 28203 00004142 861C                    	xchg	bl,[si]			; Stick in a NUL
 28204 00004144 E8CBEB                  	call	SetRest1
 28205                                  
 28206                                  	; 28/03/2023
 28207                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28208 00004147 39F2                    	cmp	dx,si			;AN000;  3/3/KK
 28209 00004149 771B                    	ja	short LookBack		;AN000;  3/3/KK
 28210 0000414B 56                      	push	si			;AN000;  3/3/KK
 28211 0000414C 51                      	push	cx			;AN000;  3/3/KK
 28212 0000414D 89F1                    	mov	cx,si			;AN000;  3/3/KK
 28213 0000414F 89D6                    	mov	si,dx			;AN000;  3/3/KK
 28214                                  Kloop2: 				;AN000;  3/3/KK
 28215 00004151 AC                      	lodsb				;AN000;  3/3/KK
 28216 00004152 E88FE2                  	call	testkanj		;AN000;  3/3/KK
 28217 00004155 7409                    	jz	short NotKanj4		;AN000;  3/3/KK
 28218 00004157 AC                      	lodsb				;AN000;  3/3/KK
 28219 00004158 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28220 0000415A 72F5                    	jb	short Kloop2		;AN000;  3/3/KK
 28221 0000415C 59                      	pop	cx			;AN000;  3/3/KK
 28222 0000415D 5E                      	pop	si			;AN000;  3/3/KK
 28223 0000415E EB0B                    	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
 28224                                  					;		 trailing path sep
 28225                                  NotKanj4:				;AN000;  3/3/KK
 28226 00004160 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28227 00004162 72ED                    	jb	short Kloop2		;AN000;  3/3/KK
 28228 00004164 59                      	pop	cx			;AN000;  3/3/KK
 28229 00004165 5E                      	pop	si			;AN000;  3/3/KK
 28230                                  LookBack:				;AN000;  3/3/KK
 28231                                  	; 28/03/2023
 28232                                  	; MSDOS 3.3 & MSDOS 6.0
 28233 00004166 3A5CFF                  	cmp	bl,[si-1]		; if double slash, then complain.
 28234 00004169 740E                    	je	short BADCDERRJ2
 28235                                  DoCdr:
 28236 0000416B B43B                    	mov	ah,CHDir ; 3Bh
 28237 0000416D CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28238                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28239 0000416F 861C                    	xchg	bl,[si]
 28240 00004171 7395                    	jnc	short NOTPDIR_RETN
 28241                                  	
 28242                                  	; 28/03/2023
 28243                                  	; MSDOS 3.3
 28244                                  ;BADCDERRJ2:
 28245                                  	;stc
 28246                                  	;jmp	BADCDERR
 28247                                  
 28248                                  	; 28/03/2023
 28249                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28250 00004173 E8A7DB                  	call	get_ext_error_number	;AN022; get the extended error
 28251                                  EXTEND_SETUPJ:					;AN022;
 28252 00004176 E9E4D8                  	jmp	extend_setup		;AN022; go issue the error message
 28253                                  BADCDERRJ2:
 28254 00004179 E9DED8                  	jmp	badpath_err		;AC022; go issue path not found message
 28255                                  
 28256                                  ; =============== S U B	R O U T	I N E =======================================
 28257                                  
 28258                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28259                                  SETSTARS:
 28260                                  	;mov	[bp+2],di
 28261 0000417C 897E02                  	mov	[bp+VARSTRUC.TTAIL],di
 28262                                  	;add	byte [bp+1],12
 28263 0000417F 8046010C                	add	byte [bp+VARSTRUC.SIZ],12
 28264                                  	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 28265                                  	; 28/03/2023
 28266                                  	; MSDOS 6.0
 28267 00004183 B83F2E                  	mov	ax,dot_qmark ; 2E3Fh
 28268                                  	;mov	ax,'?.' ; dot_qmark
 28269                                  
 28270 00004186 B90800                  	mov	cx,8
 28271 00004189 F3AA                    	rep	stosb
 28272 0000418B 86C4                    	xchg	al,ah
 28273 0000418D AA                      	stosb
 28274 0000418E 86C4                    	xchg	al,ah
 28275 00004190 B103                    	mov	cl,3
 28276 00004192 F3AA                    	rep	stosb
 28277 00004194 30C0                    	xor	al,al
 28278 00004196 AA                      	stosb
 28279 00004197 C3                      	retn
 28280                                  
 28281                                  ; =============== S U B	R O U T	I N E =======================================
 28282                                  
 28283                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28284                                  COMPNAME:
 28285 00004198 BE[EC8C]                	mov	si,DestBuf	; do name translate of target
 28286 0000419B BF[6588]                	mov	di,TRGXNAME	; save for name comparison
 28287 0000419E B460                    	mov	ah,xNameTrans ; 60h
 28288 000041A0 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 28289                                  			; DS:SI	-> ASCIZ relative path string or directory name
 28290                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 28291 000041A2 BE[0E88]                	mov	si,SRCXNAME	; get name translate of source
 28292 000041A5 BF[6588]                	mov	di,TRGXNAME	; get name translate of target
 28293                                  	;call	STRCOMP
 28294                                  	;retn
 28295                                  	; 28/03/2023
 28296 000041A8 E99DE4                  	jmp	STRCOMP
 28297                                  
 28298                                  ;============================================================================
 28299                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 28300                                  ;============================================================================
 28301                                  ; 30/09/2018 - Retro DOS v3.0
 28302                                  ; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28303                                  
 28304                                  ;-----------------------------------------------------------------------;
 28305                                  ; ENTRY:								;
 28306                                  ;	DS:SI	Points input buffer					;
 28307                                  ;	ES:DI	Points to the token buffer				;
 28308                                  ;	BL	Special delimiter for this call 			;
 28309                                  ;		    Always checked last 				;
 28310                                  ;		    set it to space if there is no special delimiter	;
 28311                                  ; EXIT: 								;
 28312                                  ;	DS:SI	Points to next char in the input buffer 		;
 28313                                  ;	ES:DI	Points to the token buffer				;
 28314                                  ;	[STARTEL] Points to start of last element of path in token	;
 28315                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 28316                                  ;	CX	Character count 					;
 28317                                  ;	BH	Condition Code						;
 28318                                  ;			Bit 1H of BH set if switch character		;
 28319                                  ;				Token buffer contains char after	;
 28320                                  ;				switch character			;
 28321                                  ;				BP has switch bits set (ORing only)	;
 28322                                  ;			Bit 2H of BH set if ? or * in token		;
 28323                                  ;				if * found element ? filled		;
 28324                                  ;			Bit 4H of BH set if path sep in token		;
 28325                                  ;			Bit 80H of BH set if the special delimiter	;
 28326                                  ;			   was skipped at the start of this token	;
 28327                                  ;		Token buffer always starts d: for non switch tokens	;
 28328                                  ;	CARRY SET							;
 28329                                  ;	    if CR on input						;
 28330                                  ;		token buffer not altered				;
 28331                                  ;									;
 28332                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 28333                                  ; MODIFIES:								;
 28334                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 28335                                  ;									;
 28336                                  ;-----------------------------------------------------------------------;
 28337                                  
 28338                                  ; Modifications to cparse: recognition of right and left parentheses
 28339                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 28340                                  ;
 28341                                  ; Both modifications were installed in the course of adding a coherent
 28342                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 28343                                  ; structure for command-line arguments. This parser relies on cparse to
 28344                                  ; recognize individual tokens.
 28345                                  ;
 28346                                  ; To process for-loops correctly, parentheses must therefore be
 28347                                  ; recognized as tokens. The upper-case conversion code was removed so
 28348                                  ; that commands (such as for and echo) would be able to use the "original"
 28349                                  ; text of the command line.
 28350                                  ;
 28351                                  ; Note also the modification to prevent the automatic conversion of colons
 28352                                  ; into spaces WITHIN THE SOURCE TEXT!
 28353                                  ;
 28354                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 28355                                  ; on the command line.
 28356                                  ;
 28357                                  ; Alan L, OS/MSDOS				    14 August 1983
 28358                                  
 28359                                  ; ---------------------------------------------------------------------------
 28360                                  
 28361                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 28362                                  
 28363                                  ;FSWITCH	EQU	8000h
 28364                                  ;FBADSWITCH	EQU	4000h
 28365                                  
 28366                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 28367                                  
 28368                                  ; =============== S U B	R O U T	I N E =======================================
 28369                                  		
 28370                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28371                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh
 28372                                  
 28373                                  cparse:
 28374 000041AB 31C0                    	xor	ax,ax
 28375 000041AD 893E[168E]              	mov	[STARTEL],di		; No path element (Is DI correct?)
 28376 000041B1 A2[198E]                	mov	[ELPOS],al		; Start in 8 char prefix
 28377                                  	; MSDOS 3.3
 28378                                  	;mov	[SOURCE],al		
 28379                                  	; MSDOS 6.0
 28380 000041B4 A2[1A8E]                	mov	[SKPDEL], al		; No skip delimiter yet
 28381 000041B7 88C7                    	mov	bh,al			; Init nothing
 28382 000041B9 9C                      	pushf				; save flags
 28383 000041BA 57                      	push	di			; save the token buffer addrss
 28384 000041BB 31C9                    	xor	cx,cx			; no chars in token buffer
 28385 000041BD 880E[458C]              	mov	[comma],cl		; reset comma flag
 28386                                  moredelim:
 28387 000041C1 AC                      	lodsb
 28388 000041C2 E849E4                  	call	DELIM
 28389 000041C5 751D                    	jnz	short SCANCDONE
 28390 000041C7 3C20                    	cmp	al,' '
 28391 000041C9 74F6                    	jz	short moredelim
 28392 000041CB 3C09                    	cmp	al,9
 28393 000041CD 74F2                    	jz	short moredelim
 28394                                  	;xchg	al,[SOURCE]
 28395                                  	; 28/03/2023
 28396 000041CF 8606[1A8E]              	xchg	al,[SKPDEL]
 28397 000041D3 08C0                    	or	al,al
 28398 000041D5 74EA                    	jz	short moredelim		; One non space/tab delimiter allowed
 28399 000041D7 F6C780                  	test	bh,80h			; has a special char been found?
 28400 000041DA 7405                    	jz	short no_comma		; no - just exit
 28401 000041DC C606[458C]01            	mov	byte [comma],1		; set comma flag
 28402                                  no_comma:
 28403 000041E1 E92A01                  	jmp	x_done			; Nul argument
 28404                                  
 28405                                  SCANCDONE:
 28406                                  	; 28/03/2023
 28407                                  	; MSDOS 6.0
 28408                                  	; -----------------------------------
 28409                                  	; Mod to avoid upper-case conversion.
 28410                                  	; -----------------------------------
 28411                                  	; MSDOS 3.3
 28412                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28413                                  	;jnz	short cpcont1		; 3/3/KK
 28414                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28415                                  cpcont1:
 28416                                  	; -----------------------------------
 28417                                  	; 28/03/2023
 28418 000041E4 38D8                    	cmp	al,bl			; Special delimiter?
 28419 000041E6 7505                    	jne	short nospec
 28420 000041E8 80CF80                  	or	bh,80h
 28421 000041EB EBD4                    	jmp	short moredelim
 28422                                  nospec:
 28423 000041ED 3C0D                    	cmp	al,0Dh			; a CR?
 28424 000041EF 7503                    	jne	short ncperror
 28425 000041F1 E91501                  	jmp	cperror
 28426                                  ncperror:
 28427 000041F4 3A06[E48A]              	cmp	al,[SWITCHAR]		; is the char the switch char?
 28428 000041F8 7503                    	jne	short na_switch		; yes, process...
 28429 000041FA E91401                  	jmp	a_switch
 28430                                  na_switch:
 28431 000041FD B23A                    	mov	dl,':'
 28432 000041FF 3814                    	cmp	[si],dl
 28433 00004201 751D                    	jne	short anum_chard	; Drive not specified
 28434                                  	; 28/03/2023
 28435                                  	; MSDOS 6.0 
 28436 00004203 803E[D48C]01            	cmp	byte [cpyflag],1	; 3/3/KK
 28437 00004208 7503                    	jne	short cpcont2		; 3/3/KK
 28438 0000420A E801E2                  	call	UPCONV			; 3/3/KK
 28439                                  cpcont2:
 28440 0000420D E85901                  	call	move_char
 28441 00004210 AC                      	lodsb				; Get the ':'
 28442 00004211 E85501                  	call	move_char
 28443 00004214 893E[168E]              	mov	[STARTEL],di
 28444 00004218 C606[188E]00            	mov	byte [ELCNT],0
 28445 0000421D E9B300                  	jmp	anum_test
 28446                                  anum_chard:
 28447 00004220 893E[168E]              	mov	[STARTEL],di
 28448 00004224 C606[188E]00            	mov	byte [ELCNT],0		; Store of this char sets it to one
 28449 00004229 803E[D48C]01            	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
 28450 0000422E 751D                    	jnz	short anum_char		; No, don't add drive spec.
 28451 00004230 E861E4                  	call	pathchrcmp		; Starts with a pathchar?
 28452 00004233 7518                    	jnz	short anum_char		; no
 28453 00004235 50                      	push	ax
 28454 00004236 A0[F48A]                	mov	al,[CURDRV]		; Insert drive spec
 28455                                  	;add	al,[CAPITAL_A]
 28456                                  	; 28/03/2023
 28457                                  	; MSDOS 6.0
 28458 00004239 0441                    	add	al,'A' ; 41h
 28459 0000423B E82B01                  	call	move_char
 28460 0000423E B03A                    	mov	al,':' ; 3Ah
 28461 00004240 E82601                  	call	move_char
 28462 00004243 58                      	pop	ax
 28463 00004244 893E[168E]              	mov	[STARTEL],di
 28464 00004248 C606[188E]00            	mov	byte [ELCNT],0
 28465                                  anum_char:
 28466                                  	; 28/03/2023
 28467                                  	; MSDOS 6.0
 28468 0000424D E894E1                  	call	testkanj		;AC048			
 28469 00004250 7406                    	jz	short NOTKANJ		;AC048;
 28470 00004252 E81401                  	call	move_char
 28471 00004255 AC                      	lodsb
 28472 00004256 EB78                    	jmp	short notspecial
 28473                                  
 28474                                  NOTKANJ:				;AN048; If not kanji
 28475 00004258 803E[D48C]01            	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
 28476 0000425D 7503                    	jne	short TESTDOT 		;AN048;
 28477 0000425F E8ACE1                  	call	UPCONV			;AN048; upper case the char
 28478                                  TESTDOT:
 28479                                  	; 28/03/2023
 28480                                  	;cmp	al,dot_chr  ; 2Eh
 28481 00004262 3C2E                    	cmp	al,'.'
 28482 00004264 7509                    	jne	short testquest
 28483 00004266 FE06[198E]              	inc	byte [ELPOS] 		; flag in extension
 28484 0000426A C606[188E]FF            	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 28485                                  testquest:
 28486 0000426F 3C3F                    	cmp	al,'?'  ; 3Fh
 28487 00004271 7503                    	jnz	short testsplat
 28488 00004273 80CF02                  	or	bh,2
 28489                                  testsplat:
 28490                                  	;cmp	al,[STAR]
 28491 00004276 3C2A                    	cmp	al,star	; 2Ah
 28492                                  	; 27/04/2023
 28493                                  	;cmp	al,'*' 
 28494 00004278 7530                    	jne	short testpath
 28495 0000427A 80CF02                  	or	bh,2
 28496 0000427D 803E[518E]00            	cmp	byte [expand_star],0
 28497 00004282 7504                    	jne	short expand_filename
 28498 00004284 EB24                    	jmp	short testpath
 28499                                  
 28500                                  BADPERR2J:
 28501                                  	;jmp	BADPERR2
 28502                                  	; 28/03/2023
 28503                                  	; MSDOS 6.0
 28504 00004286 EB75                    	jmp	short BADPERR2
 28505                                  
 28506                                  expand_filename:
 28507 00004288 B407                    	mov	ah,7
 28508 0000428A 803E[198E]00            	cmp	byte [ELPOS],0
 28509 0000428F 7402                    	jz	short gotelcnt
 28510 00004291 B402                    	mov	ah,2
 28511                                  gotelcnt:
 28512 00004293 B03F                    	mov	al,'?'
 28513 00004295 2A26[188E]              	sub	ah,[ELCNT]
 28514 00004299 72EB                    	jb	short BADPERR2J
 28515 0000429B 86E1                    	xchg	ah,cl
 28516 0000429D E309                    	jcxz	testpathx
 28517                                  qmove:
 28518 0000429F 86E1                    	xchg	ah,cl
 28519 000042A1 E8C500                  	call	move_char
 28520 000042A4 86E1                    	xchg	ah,cl
 28521 000042A6 E2F7                    	loop	qmove
 28522                                  testpathx:
 28523 000042A8 86E1                    	xchg	ah,cl
 28524                                  testpath:
 28525 000042AA E8E7E3                  	call	pathchrcmp
 28526 000042AD 7521                    	jnz	short notspecial
 28527 000042AF 80CF04                  	or	bh,4
 28528 000042B2 803E[518E]00            	cmp	byte [expand_star],0
 28529 000042B7 7405                    	jz	short no_err_check
 28530 000042B9 F6C702                  	test	bh,2			; If just hit a '/', cannot have ? or * yet
 28531 000042BC 7545                    	jnz	short BADPERR
 28532                                  no_err_check:
 28533 000042BE 893E[168E]              	mov	[STARTEL],di	  	; New element
 28534 000042C2 FF06[168E]              	inc	word [STARTEL]	  	; Point to char after /
 28535 000042C6 C606[188E]FF            	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
 28536 000042CB C606[198E]00            	mov	byte [ELPOS],0
 28537                                  notspecial:
 28538 000042D0 E89600                  	call	move_char		; just an alphanum string
 28539                                  anum_test:
 28540 000042D3 AC                      	lodsb
 28541                                  
 28542                                  	; 28/03/2023
 28543                                  	; MSDOS 6.0
 28544                                  	; -----------------------------------
 28545                                  	; Mod to avoid upper-case conversion.
 28546                                  	; -----------------------------------
 28547                                  	; MSDOS 3.3
 28548                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28549                                  	;jnz	short cpcont3		; 3/3/KK
 28550                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28551                                  cpcont3:
 28552                                  	; -----------------------------------
 28553                                  
 28554 000042D4 E837E3                  	call	DELIM
 28555 000042D7 7435                    	jz	short x_done
 28556 000042D9 3C0D                    	cmp	al,0Dh
 28557 000042DB 7431                    	je	short x_done
 28558 000042DD 3A06[E48A]              	cmp	al,[SWITCHAR]
 28559 000042E1 742B                    	je	short x_done
 28560 000042E3 38D8                    	cmp	al,bl
 28561 000042E5 7427                    	je	short x_done
 28562 000042E7 3C3A                    	cmp	al,':'			; ':' allowed as trailer because of devices
 28563                                  	; 28/03/2023
 28564                                  	; MSDOS 3.3
 28565                                  	;jnz	short ANUM_CHARJ 
 28566                                  	; MSDOS 6.0
 28567 000042E9 7403                    	je	short FOO15
 28568 000042EB E95FFF                  	jmp	anum_char
 28569                                  
 28570                                  ; Modification made for parseline.
 28571                                  ; Why would it be necessary to change colons to spaces? In this
 28572                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 28573                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 28574                                  
 28575                                  FOO15:
 28576 000042EE 803E[D48C]02            	cmp	byte [cpyflag],2
 28577 000042F3 7505                    	jnz	short cpcont4
 28578 000042F5 E87100                  	call	move_char
 28579 000042F8 EBD9                    	jmp	short anum_test
 28580                                  cpcont4:
 28581 000042FA 46                      	inc	si			; Skip the ':'
 28582 000042FB EB11                    	jmp	short x_done
 28583                                  
 28584                                  	; 28/03/2023
 28585                                  ;ANUM_CHARJ:
 28586                                  	;jmp	anum_char
 28587                                  
 28588                                  BADPERR2:
 28589 000042FD BA[867F]                	mov	dx,BADCPMES_PTR
 28590 00004300 E977E6                  	jmp	cerror
 28591                                  
 28592                                  BADPERR:
 28593                                  	; 28/03/2023
 28594                                  	;jmp	BADCDERR  ; MSDOS 3.3	
 28595                                  BADCDERR:
 28596                                  	; MSDOS 6.0
 28597 00004303 BA[B080]                	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
 28598 00004306 E971E6                  	jmp	cerror			;AC022;  message
 28599                                  	
 28600                                  cperror:
 28601 00004309 4E                      	dec	si			; adjust the pointer
 28602 0000430A 5F                      	pop	di			; retrive token buffer address
 28603 0000430B 9D                      	popf				; restore flags
 28604 0000430C F9                      	stc				; set the carry bit
 28605 0000430D C3                      	retn
 28606                                  
 28607                                  x_done:
 28608 0000430E 4E                      	dec	si			; adjust for next round
 28609                                  
 28610                                  ; Mod to recognize right and left parens as integral tokens.
 28611                                  ;x_done2:
 28612 0000430F EB51                    	jmp	short out_token
 28613                                  
 28614                                  a_switch:
 28615 00004311 80CF01                  	or	bh,1			; Indicate switch
 28616                                  	;or	bp,FSWITCH ; 8000h
 28617                                  	; 28/03/2023
 28618 00004314 81CD0080                	or	bp,8000h
 28619 00004318 E8EBE2                  	call	scanoff
 28620 0000431B 46                      	inc	si
 28621                                  	; 28/03/2023
 28622                                  	; MSDOS 6.0
 28623 0000431C E8C5E0                  	call	testkanj		;AN057; See if DBCS lead byte
 28624 0000431F 740D                    	jz	short a_switch_notkanj	;AN057; no - continue processing
 28625 00004321 E84500                  	call	move_char		;AN057; DBCS - store first byte
 28626 00004324 AC                      	lodsb				;AN057; get second byte
 28627 00004325 E84100                  	call	move_char		;AN057; store second byte
 28628                                  	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
 28629 00004328 81CD0040                	or	bp,4000h
 28630 0000432C EB34                    	jmp	short out_token 	;AN057; don't bother checking switch
 28631                                  a_switch_notkanj:			;AN057;
 28632 0000432E 3C0D                    	cmp	al,0Dh
 28633 00004330 7509                    	jne	short Store_swt
 28634 00004332 B000                    	mov	al,0
 28635 00004334 AA                      	stosb
 28636                                  	;or	bp,FBADSWITCH ; 4000h
 28637 00004335 81CD0040                	or	bp,4000h
 28638 00004339 EBCE                    	jmp	short cperror		; Trailing switch character error
 28639                                  					;   BP = fSwitch but no switch
 28640                                  					;   bit is set (unknown switch)
 28641                                  Store_swt:
 28642 0000433B E82B00                  	call	move_char		; store the character
 28643                                  
 28644                                  ; This upconv call must stay. It is used to identify copy-switches
 28645                                  ; on the command line, and won't store anything into the output buffer.
 28646                                  
 28647                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
 28648                                  	; 28/03/2023
 28649 0000433E E8CDE0                  	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
 28650                                  	
 28651 00004341 06                      	push	es
 28652 00004342 57                      	push	di
 28653 00004343 51                      	push	cx
 28654 00004344 0E                      	push	cs
 28655 00004345 07                      	pop	es
 28656                                  	; 28/03/2023
 28657                                  	; MSDOS 3.3
 28658                                  	;mov	di,SWITCH_LIST ; "VBAPW"
 28659                                  	; MSDOS 6.0
 28660 00004346 BF[AB84]                	mov	di,switch_list ; "?VBAPW"
 28661                                  	; MSDOS 3.3
 28662                                  	;mov	cx,SWCOUNT ; 5
 28663                                  	; MSDOS 6.0
 28664 00004349 B90600                  	mov	cx,6  ; SWCOUNT = 6
 28665                                  	;or	bp,FBADSWITCH  ; 4000h
 28666 0000434C 81CD0040                	or	bp,4000h
 28667 00004350 F2AE                    	repne	scasb
 28668 00004352 750B                    	jnz	short out_tokenp
 28669                                  	;and	bp,~FBADSWITCH ; 0BFFFh
 28670 00004354 81E5FFBF                	and	bp,0BFFFh
 28671 00004358 B80100                  	mov	ax,1
 28672 0000435B D3E0                    	shl	ax,cl
 28673 0000435D 09C5                    	or	bp,ax
 28674                                  out_tokenp:
 28675 0000435F 59                      	pop	cx
 28676 00004360 5F                      	pop	di
 28677 00004361 07                      	pop	es
 28678                                  out_token:
 28679 00004362 B000                    	mov	al,0			; null at the end
 28680 00004364 AA                      	stosb
 28681 00004365 5F                      	pop	di			; restore token buffer pointer	
 28682 00004366 9D                      	popf
 28683 00004367 F8                      	clc				; clear carry flag
 28684 00004368 C3                      	retn
 28685                                  
 28686                                  ; =============== S U B	R O U T	I N E =======================================
 28687                                  
 28688                                  	; 28/03/2023
 28689                                  move_char:
 28690 00004369 AA                      	stosb				; store char in token buffer
 28691 0000436A 41                      	inc	cx			; increment char count
 28692 0000436B FE06[188E]              	inc	byte [ELCNT]		; increment element count for * substi
 28693 0000436F C3                      	retn
 28694                                  
 28695                                  ;============================================================================
 28696                                  ; PARSE.ASM, MSDOS 6.0, 1991
 28697                                  ;============================================================================
 28698                                  ; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28699                                  
 28700                                  ; -----------------------------
 28701                                  ; (PSDATA.INC, MSDOS 6.0, 1991)
 28702                                  ; -----------------------------
 28703                                  
 28704                                  ;**** Equation field
 28705                                  ;-------- Character code definition
 28706                                  
 28707                                  $P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
 28708                                  $P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
 28709                                  $P_Period	   equ	"."             ;AN020;
 28710                                  $P_Slash	   equ	"/"             ;AN020;
 28711                                  $P_Space	   equ	" "             ;AN000; SBCS blank
 28712                                  $P_Comma	   equ	","             ;AN000;
 28713                                  $P_Switch	   equ	"/"             ;AN000;
 28714                                  $P_Keyword	   equ	"="             ;AN000;
 28715                                  $P_Colon	   equ	":"             ;AN000;
 28716                                  $P_Plus 	   equ	"+"             ;AN000;
 28717                                  $P_Minus	   equ	"-"             ;AN000;
 28718                                  $P_Rparen	   equ	")"             ;AN000;
 28719                                  $P_Lparen	   equ	"("             ;AN000;
 28720                                  ;(deleted ;AN025;) $P_SQuote	      equ  "'"
 28721                                  $P_DQuote	   equ	'"'             ;AN000;
 28722                                  $P_NULL 	   equ	0		;AN000;
 28723                                  $P_TAB		   equ	9		;AN000;
 28724                                  $P_CR		   equ	0Dh		;AN000;
 28725                                  $P_LF		   equ	0Ah		;AN000;
 28726                                  $P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 28727                                  
 28728                                  $P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 28729                                  $P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 28730                                  
 28731                                  $P_error_filespec  equ  1
 28732                                  
 28733                                  ;----------------------------------------------------------------------------
 28734                                  ; PARMS LABEL	BYTE
 28735                                  ;	DW	PARMSX
 28736                                  ;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
 28737                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 28738                                  ;	DB	" .. "          ; EXTRA DELIMITER LIST,
 28739                                  ;				; TYPICAL ARE ";", "="
 28740                                  ;				; "," & WHITESPACE ALWAYS
 28741                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 28742                                  ;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 28743                                  ;----------------------------------------------------------------------------
 28744                                  
 28745                                  struc $P_PARMS_BLK			;AN000;
 28746 00000000 ????                    .$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 28747 00000002 ??                      .$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
 28748 00000003 ??                      .$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 28749                                  endstruc 				;AN000;
 28750                                  
 28751                                  $P_Len_PARMS	   equ	4		;AN000;
 28752                                  $P_I_Use_Default   equ	0		;AN000; no extra stuff specified
 28753                                  $P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
 28754                                  $P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 28755                                  
 28756                                  ;----------------------------------------------------------------------------
 28757                                  ; PARMSX LABEL	BYTE
 28758                                  ;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
 28759                                  ;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
 28760                                  ;	:				; REPEATS maxp-1 TIMES
 28761                                  ;	DB	maxs			; # OF SWITCHES
 28762                                  ;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
 28763                                  ;	:				; REPEATS maxs-1 TIMES
 28764                                  ;	DB	maxk			; # OF KEYWORD
 28765                                  ;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
 28766                                  ;	:				; REPEATS maxk-1 TIMES
 28767                                  ;----------------------------------------------------------------------------
 28768                                  
 28769                                  struc $P_PARMSX_BLK			;AN000;
 28770 00000000 ??                      .$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
 28771 00000001 ??                      .$P_MaxP: 	 resb 1			;AN000; Maximum positional number
 28772 00000002 ??                      .$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
 28773                                  endstruc				;AN000;
 28774                                  
 28775                                  ; 31/03/2023
 28776                                  ;----------------------------------------------------------------------------
 28777                                  ; << Control field definition >>
 28778                                  ;
 28779                                  ;CONTROL   LABEL   BYTE
 28780                                  ;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
 28781                                  ;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 28782                                  ;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 28783                                  ;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 28784                                  ;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 28785                                  ;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 28786                                  ;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 28787                                  ;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 28788                                  ;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 28789                                  ;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 28790                                  ;				; 0010H=IGNORE ":" AT END IN MATCH
 28791                                  ;				; 0002H=REPEATS ALLOWED
 28792                                  ;				; 0001H=OPTIONAL
 28793                                  ;	   DW FUNCTION_FLAGS
 28794                                  ;				; 0001H=CAP RESULT BY FILE TABLE
 28795                                  ;				; 0002H=CAP RESULT BY CHAR TABLE
 28796                                  ;				; 0010H=REMOVE ":" AT END
 28797                                  ; (tm10)			; 0020H=colon is not necessary for switch
 28798                                  ;
 28799                                  ;	   DW RESULT		; RESULT BUFFER
 28800                                  ;	   DW VALUES		; VALUE LISTS
 28801                                  ;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 28802                                  ;	   DB "...",0		; IF n >0, KEYWORD 1
 28803                                  ;	   :
 28804                                  ;
 28805                                  ;Note:
 28806                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 28807                                  ;      DATE bit simalteniously.
 28808                                  ;
 28809                                  ;      The parser examins each bit along with the following priority.
 28810                                  ;
 28811                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 28812                                  ;      FILE SPEC -> SIMPLE STRING.
 28813                                  ;
 28814                                  ;
 28815                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 28816                                  ;      in the result buffer is capitalized.
 28817                                  ;
 28818                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 28819                                  ;
 28820                                  ;
 28821                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 28822                                  ;      switch, for example, '/A', then STRING points to;
 28823                                  ;
 28824                                  ;		DB    1 	; number of following synonyms
 28825                                  ;		DB   '/A',0
 28826                                  ;
 28827                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 28828                                  ;
 28829                                  ;		DB    1 	; number of following synonyms
 28830                                  ;		DB   'CODEPAGE=',0
 28831                                  ;
 28832                                  ;
 28833                                  ;    - "..." must consist of upper case characters only because the parser
 28834                                  ;      performs pattern matching after converting input to upper case (by
 28835                                  ;      using the current country upper case table)
 28836                                  ;
 28837                                  ;
 28838                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 28839                                  ;      example /A and /B, the format will be;
 28840                                  ;
 28841                                  ;		DB    2 	; number of following synonyms
 28842                                  ;		DB    '/A',0
 28843                                  ;		DB    '/B',0
 28844                                  ;----------------------------------------------------------------------------
 28845                                  
 28846                                  ;**** Match_Flags
 28847                                  
 28848                                  $P_Num_Val	   equ	8000h		;AN000; Numeric Value
 28849                                  $P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 28850                                  $P_Simple_S	   equ	2000h		;AN000; Simple string
 28851                                  $P_Date_S	   equ	1000h		;AN000; Date string
 28852                                  $P_Time_S	   equ	0800h		;AN000; Time string
 28853                                  $P_Cmpx_S	   equ	0400h		;AN000; Complex string
 28854                                  $P_File_Spc	   equ	0200h		;AN000; File Spec
 28855                                  $P_Drv_Only	   equ	0100h		;AN000; Drive Only
 28856                                  $P_Qu_String	   equ	0080h		;AN000; Quoted string
 28857                                  $P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 28858                                  $P_Repeat	   equ	0002h		;AN000; Repeat allowed
 28859                                  $P_Optional	   equ	0001h		;AN000; Optional
 28860                                  
 28861                                  ;**** Function flags
 28862                                  
 28863                                  $P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 28864                                  $P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 28865                                  $P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 28866                                  $P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 28867                                  
 28868                                  ;-------------------------------- Control block structure
 28869                                  struc $P_CONTROL_BLK
 28870 00000000 ????                    .$P_Match_Flag:	   resw 1		;AN000; Controls type matched
 28871 00000002 ????                    .$P_Function_Flag: resw 1		;AN000; Function should be taken
 28872 00000004 ????                    .$P_Result_Buf:	   resw 1		;AN000; Result buffer address
 28873 00000006 ????                    .$P_Value_List:	   resw 1		;AN000; Value list address
 28874 00000008 ??                      .$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
 28875 00000009 ??                      .$P_KEYorSW:	   resb 1		;AN000; keyword or sw
 28876                                  endstruc
 28877                                  
 28878                                  ; 31/03/2023
 28879                                  ;----------------------------------------------------------------------------
 28880                                  ;
 28881                                  ;VALUES LABEL	BYTE
 28882                                  ;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
 28883                                  ;	+-
 28884                                  ;	| DB	nrng		; NUMBER OF RANGES
 28885                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
 28886                                  ;	| +DD	X,Y		; RANGE OF VALUES
 28887                                  ;	|	:
 28888                                  ;	| DB	nnval		; NUMBER OF CHOICES
 28889                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
 28890                                  ;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
 28891                                  ;	|	:
 28892                                  ;	| DB	nstrval 	; NUMBER OF CHOICES
 28893                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
 28894                                  ;	| +DW	STRING		; SPECIFIC CHOICE IF STING
 28895                                  ;	+-	:
 28896                                  ;
 28897                                  ;STRING DB	"...",0		; ASCIIZ STRING IMAGE
 28898                                  ;
 28899                                  ;Note:
 28900                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 28901                                  ;      when no choice lists are provided.
 28902                                  ;
 28903                                  ;    - STRING must consist of upper case characters only because the parser
 28904                                  ;      performs pattern matching after converting input to upper case (by
 28905                                  ;      using the current country upper case table)
 28906                                  ;----------------------------------------------------------------------------
 28907                                  
 28908                                  $P_nval_None	equ 0		;AN000; no value list ID
 28909                                  $P_nval_Range	equ 1		;AN000; range list ID
 28910                                  $P_nval_Value	equ 2		;AN000; value list ID
 28911                                  $P_nval_String	equ 3		;AN000; string list ID
 28912                                  $P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
 28913                                  $P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
 28914                                  $P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
 28915                                  $P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.
 28916                                  
 28917                                  struc $P_VAL_LIST
 28918 00000000 ??                      .$P_NumofList:	resb 1		;AN000; number of following choice
 28919 00000001 ????                    .$P_Val_XL:	resw 1		;AN000; lower word of value
 28920 00000003 ????                    .$P_Val_XH:	resw 1		;AN000; higher word of value
 28921 00000005 ????                    .$P_Val_YL:	resw 1		;AN000; lower word of another value
 28922 00000007 ????                    .$P_Val_YH:	resw 1		;AN000; higher word of another value
 28923                                  endstruc
 28924                                  
 28925                                  ; 31/03/2023
 28926                                  ;----------------------------------------------------------------------------
 28927                                  ;
 28928                                  ;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 28929                                  ;	DB	type			; TYPE RETURNED: 0=RESERVED,
 28930                                  ;					;	1=NUMBER, 2=LIST INDEX,
 28931                                  ;					;	3=STRING, 4=COMPLEX,
 28932                                  ;					;	5=FILESPEC, 6=DRIVE
 28933                                  ;					;	7=DATE, 8=TIME
 28934                                  ;					;	9=QUOTED STRING
 28935                                  ;	DB	ITEM_TAG		; MATCHED ITEM TAG
 28936                                  ;
 28937                                  ;	dw	synonym@		; es:@ points to found SYNONYM if provided.
 28938                                  ;
 28939                                  ;       +-
 28940                                  ;       | DD	n			; VALUE IF NUMBER
 28941                                  ;       | or
 28942                                  ;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
 28943                                  ;       |				; (ES presents Segment address)
 28944                                  ;       | or
 28945                                  ;       |	DD STRING		; OFFSET OF STRING VALUE
 28946                                  ;       | or
 28947                                  ;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 28948                                  ;       | or
 28949                                  ;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
 28950                                  ;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
 28951                                  ;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
 28952                                  ;       | or
 28953                                  ;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
 28954                                  ;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
 28955                                  ;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
 28956                                  ;       |	DB HUNDREDTHS ;(0-99)
 28957                                  ;       +-
 28958                                  ;
 28959                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 28960                                  ;      list.
 28961                                  ;
 28962                                  ;      YEAR: If the input value for the year is less than 100, parser
 28963                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
 28964                                  ;	     the year value, he returns 1987.
 28965                                  ;----------------------------------------------------------------------------
 28966                                  
 28967                                  ;-------------------------------- Result block structure
 28968                                  struc $P_RESULT_BLK;
 28969 00000000 ??                      .$P_Type:	 resb 1		;AN000; Type returned
 28970 00000001 ??                      .$P_Item_Tag:	 resb 1		;AN000; Matched item tag
 28971 00000002 ????                    .$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 28972 00000004 ????????                .$P_Picked_Val:	 resb 4		;AN000; value
 28973                                  endstruc
 28974                                  
 28975                                  ;**** values for the type field in the result block
 28976                                  
 28977                                  $P_EOL		 equ 0		;AN000; End of line
 28978                                  $P_Number	 equ 1		;AN000; Number
 28979                                  $P_List_Idx	 equ 2		;AN000; List Index
 28980                                  $P_String	 equ 3		;AN000; String
 28981                                  $P_Complex	 equ 4		;AN000; Complex
 28982                                  $P_File_Spec	 equ 5		;AN000; File Spec
 28983                                  $P_Drive	 equ 6		;AN000; Drive
 28984                                  $P_Date_F	 equ 7		;AN000; Date
 28985                                  $P_Time_F	 equ 8		;AN000; Time
 28986                                  $P_Quoted_String equ 9		;AN000; Quoted String
 28987                                  
 28988                                  $P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found
 28989                                  
 28990                                  ;**** Return code
 28991                                  ;
 28992                                  ; following return code will be returned in the AX register.
 28993                                  
 28994                                  $P_No_Error	 equ 0		;AN000; No error
 28995                                  $P_Too_Many	 equ 1		;AN000; Too many operands
 28996                                  $P_Op_Missing	 equ 2		;AN000; Required operand missing
 28997                                  $P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
 28998                                  $P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
 28999                                  $P_Out_Of_Range  equ 6		;AN000; Out of range specified
 29000                                  $P_Not_In_Val	 equ 7		;AN000; Not in value list provided
 29001                                  $P_Not_In_Str	 equ 8		;AN000; Not in string list provided
 29002                                  $P_Syntax	 equ 9		;AN000; Syntax error
 29003                                  $P_RC_EOL	 equ -1		;AN000; End of command line
 29004                                  
 29005                                  ;in second byte of $P_Flags, referenced as $P_Flags2:
 29006                                  $P_equ		 equ 01h	;AN000; "=" packed in string buffet
 29007                                  $P_Neg		 equ 02h	;AN000; Negative value
 29008                                  $P_Time12	 equ 04h	;AN000; set when PM is specified
 29009                                  $P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
 29010                                  $P_SW_Cmp	 equ 10h	;AN000; set when switch compare
 29011                                  $P_Extra	 equ 20h	;AN000; set when extra delimiter found
 29012                                  $P_SW		 equ 40h	;AN000; set when switch found (tm08)
 29013                                  $P_Signed	 equ 80h	;AN000; signed numeric specified
 29014                                  
 29015                                  ;-------- Masks
 29016                                  $P_Make_Lower	 equ 20h	;AN000; make lower case character
 29017                                  $P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character
 29018                                  
 29019                                  ;-------------
 29020                                  
 29021                                  struc $P_DOS_TBL
 29022 00000000 ??                      .$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
 29023 00000001 ????                    .$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
 29024 00000003 ????                    .$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
 29025                                  endstruc
 29026                                  
 29027                                  $P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
 29028                                  				;AN000; following parameters are set
 29029                                  				;AN000; to get casemap table.
 29030                                  $P_DOSTBL_Def	 equ -1		;AN000; get default
 29031                                  $P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
 29032                                  $P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
 29033                                  $P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
 29034                                  				; By this call following information
 29035                                  				; is returned.
 29036                                  
 29037                                  ; 03/04/2023
 29038                                  ;-------------------------------- country dependent information
 29039                                  
 29040                                  $P_DOS_Get_CDI	equ 3800h
 29041                                  
 29042                                  struc $P_CDI
 29043 00000000 ????                    .$P_CDI_DateF:	resw 1		;AN000;
 29044 00000002 ????????                .$P_CDI_Money:	resb 4		;AN000;
 29045 00000006 ????                    .$P_CDI_1000:	resb 2		;AN000;
 29046 00000008 ????                    .$P_CDI_Dec:	resb 2		;AN000;
 29047 0000000A ????                    .$P_CDI_DateS:	resb 2		;AN000;
 29048 0000000C ????                    .$P_CDI_TimeS:	resb 2		;AN000;
 29049 0000000E ??                      		resb 1		;AN000;
 29050 0000000F ??                      		resb 1		;AN000;
 29051 00000010 ??                      .$P_CDI_TimeF:	resb 1		;AN000;
 29052 00000011 ????????                		resw 2		;AN000;
 29053 00000015 ????                    		resb 2		;AN000;
 29054 00000017 <res Ah>                		resw 5		;AN000;
 29055                                  endstruc
 29056                                  
 29057                                  $P_Date_MDY	equ 0		;AN000;
 29058                                  $P_Date_DMY	equ 1		;AN000;
 29059                                  $P_Date_YMD	equ 2		;AN000;
 29060                                  
 29061                                  ; ----------------------------
 29062                                  ; (PARSE.ASM, MSDOS 6.0, 1991)
 29063                                  ; ----------------------------
 29064                                  
 29065                                  ;***********************************************************************
 29066                                  ; SysParse;
 29067                                  ;
 29068                                  ;  Function : Parser Entry
 29069                                  ;
 29070                                  ;  Input: DS:SI -> command line
 29071                                  ;	  ES:DI -> parameter block
 29072                                  ;	  psdata_seg -> psdata.inc
 29073                                  ;	  CX = operand ordinal
 29074                                  ;
 29075                                  ;	  Note:  ES is the segment containing all the control blocks defined
 29076                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 29077                                  ;		 is in DS.
 29078                                  ;
 29079                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 29080                                  ;		    invalid value list. But this parser does NOT implement
 29081                                  ;		    this feature. Therefore CY always zero.
 29082                                  ;
 29083                                  ;	   CY = 0   AX = return code
 29084                                  ;		    BL = terminated delimiter code
 29085                                  ;		    CX = new operand ordinal
 29086                                  ;		    SI = set past scaned operand
 29087                                  ;		    DX = selected result buffer
 29088                                  ;
 29089                                  ; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
 29090                                  ;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
 29091                                  ;	$P_Chk_Sw_Control, $P_Fill_Result
 29092                                  ;
 29093                                  ; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
 29094                                  ;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
 29095                                  ;
 29096                                  ;-------- Modification History -----------------------------------------
 29097                                  ;
 29098                                  ;  4/04/87 : Created by K. K,
 29099                                  ;  4/28/87 : $P_Val_YH assemble error (tm01)
 29100                                  ;	   : JMP SHORT assemble error (tm02)
 29101                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 29102                                  ;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 29103                                  ;	     DateSW equ 1)	      (tm04)
 29104                                  ;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 29105                                  ;				      (tm05) in PSDATA.INC
 29106                                  ;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
 29107                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 29108                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 29109                                  ;	     value-list block	      (tm07)
 29110                                  ;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
 29111                                  ;	     switch (keyword) or not. If there is, backup si for next call
 29112                                  ;	     (tm08)
 29113                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 29114                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 29115                                  ;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
 29116                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 29117                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 29118                                  ;	     in user's routines. $P_Chk_DBCS (tm11)
 29119                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 29120                                  ;					  (tm12)
 29121                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 29122                                  ;					  (tm13)
 29123                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 29124                                  ;					  (tm14)
 29125                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 29126                                  ;					  (tm15)
 29127                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 29128                                  ;
 29129                                  ;  7/24/87 : Quoted strings being returned with quotes.
 29130                                  ;
 29131                                  ;  7/28/87 : Kerry S (;AN018;)
 29132                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 29133                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 29134                                  ;	     affected: $P_Chk_SW_Control.
 29135                                  ;
 29136                                  ;  7/29/87 : Kerry S (;AN019;)
 29137                                  ;	     Now allow the optional bit in match flags for switches.  This
 29138                                  ;	     allows the switch to be encountered with a value or without a
 29139                                  ;	     value and no error is returned.
 29140                                  ;
 29141                                  ;
 29142                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 29143                                  ;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
 29144                                  ;	     within a date response, instead of checking just for the one
 29145                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 29146                                  ;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
 29147                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 29148                                  ;
 29149                                  ;  9/1/87  : Kerry S (;AN021)
 29150                                  ;	     In PROC $P_String_Comp, when comparing the switch or keyword on
 29151                                  ;	     the command line with the string in the control block the
 29152                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 29153                                  ;	     on the command line and assuming a match.	This allowed a shorter
 29154                                  ;	     string on the command line than in the synonym list in the control
 29155                                  ;	     block.  I put in a test for a null in the control block so the
 29156                                  ;	     string in the control block must be the same length as the string
 29157                                  ;	     preceeding the colon or equal on the command line.
 29158                                  ;
 29159                                  ;  8/28/87 : Kerry S (;AN022;)
 29160                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 29161                                  ;	     problems for people who included it themselves in a segment other
 29162                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 29163                                  ;	     segment.
 29164                                  ;
 29165                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 29166                                  ;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 29167                                  ;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
 29168                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 29169                                  ;	     Created FLag, in $P_time_Format PROC, to request the delim in
 29170                                  ;	     BL be used if TIME is being parsed.
 29171                                  ;
 29172                                  ;  9/24/87 : Ed K
 29173                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 29174                                  ;	     invocations with their normally expanded code; made comments
 29175                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 29176                                  ;
 29177                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 29178                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 29179                                  ;	     pointed to by non-existant CONTROL.
 29180                                  ;
 29181                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 29182                                  ;	     A quoted text string can be framed only by double quote.  Remove
 29183                                  ;	     support to frame quoted text string with single quote.
 29184                                  ;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
 29185                                  ;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
 29186                                  ;	     single quote in PROC prologues are left as is for history reasons.
 29187                                  ;
 29188                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 29189                                  ;	     quote chars within a quoted string is supposed to be reported as
 29190                                  ;	     one quote character, but is reported as two quotes.  This changed
 29191                                  ;	     two instructions in PROC $P_Quoted_Str.
 29192                                  ;
 29193                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 29194                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 29195                                  ;
 29196                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 29197                                  ;
 29198                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 29199                                  ;	     psdata buffer should have psdata_seg.
 29200                                  ;
 29201                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 29202                                  ;	     positional missing.
 29203                                  ;
 29204                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 29205                                  ;	     as a line delimiter, should use carriage return.
 29206                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 29207                                  ;
 29208                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 29209                                  ;
 29210                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 29211                                  ;	     endless loop since SI is returned still pointing to start
 29212                                  ;	     of that parm.
 29213                                  ;
 29214                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 29215                                  ;	     Vector to returned string has CS instead of Psdata_Seg, but
 29216                                  ;	     when tried to fix it on previous version, changed similar
 29217                                  ;	     but wrong place.
 29218                                  ;
 29219                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 29220                                  ;	     delimiters between hours, minutes, seconds for time. And period
 29221                                  ;	     and comma are valid delimiters between seconds and 100th second.
 29222                                  ;
 29223                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 29224                                  ;	     in a filespec, then flag an error.
 29225                                  ;
 29226                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 29227                                  ;	     indexed off of the psdata_seg equate instead of the DS register.
 29228                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 29229                                  ;  -->	     local parser data. Why were some references to local data changed
 29230                                  ;	     to do this before, but not all ?????
 29231                                  ;
 29232                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 29233                                  ;
 29234                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
 29235                                  ;
 29236                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 29237                                  ;
 29238                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 29239                                  ;
 29240                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 29241                                  ;	     separator in TIME before hundredths field.
 29242                                  ;
 29243                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 29244                                  ;			strings as keywords.
 29245                                  ;
 29246                                  ;***********************************************************************
 29247                                  
 29248                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29249                                  cmd_parse:
 29250                                  	;call	sysparse
 29251                                  	;retn
 29252                                  
 29253                                  ; -----------------------------------
 29254                                  
 29255                                  	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29256                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h
 29257                                  
 29258                                  sysparse:
 29259 00004370 2EC706[3886]0000        	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
 29260 00004377 2E890E[C286]            	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
 29261 0000437C 2E8926[C486]            	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
 29262 00004381 2E8936[C686]            	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
 29263                                  $P_Redo_Time:				;AN039; try to parse time again
 29264 00004386 FC                      	cld				;AN000; confirm forward direction
 29265 00004387 2E890E[2B86]            	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
 29266                                  	;mov	word [cs:$P_RC],$P_No_Error
 29267 0000438C 2EC706[2D86]0000        	mov	word [cs:$P_RC],0	;AC034; Assume no error
 29268 00004393 2EC706[4086]0000        	mov	word [cs:$P_Found_SYNONYM],0
 29269                                  					;AC034; initalize synonym pointer
 29270 0000439A 2EC706[3186]0000        	mov	word [cs:$P_DX],0	;AC034; (tm15)
 29271                                  
 29272                                  ;M029 -- Begin changes
 29273                                  ; The table of special chars $P_FileSp_Char should be initialized on every
 29274                                  ;entry to SysParse. This is in the non-checksum region and any program that
 29275                                  ;corrupts this table but does not corrupt the checksum region will leave
 29276                                  ;command.com parsing in an inconsistent state.
 29277                                  ; NB: The special characters string has been hardcoded here. If any change
 29278                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 29279                                  
 29280 000043A1 2EC706[FD86]5B5D        	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
 29281 000043A8 2EC706[FF86]7C3C        	mov	word [cs:$P_FileSp_Char+2], '|<'
 29282 000043AF 2EC706[0187]3E2B        	mov	word [cs:$P_FileSp_Char+4], '>+'
 29283 000043B6 2EC706[0387]3D3B        	mov 	word [cs:$P_FileSp_Char+6], '=;'
 29284                                  
 29285                                  ;M029 -- End of changes
 29286                                  
 29287 000043BD E83809                  	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
 29288 000043C0 7312                    	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse
 29289                                  
 29290                                  ;--------------------------- End of Line
 29291                                  	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
 29292 000043C2 B8FFFF                  	mov	ax,0FFFFh
 29293 000043C5 53                      	push	bx			;AN000;
 29294                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29295 000043C6 268B1D                  	mov	bx,[es:di]		;AN000; Get the PARMSX address to
 29296                                  	
 29297                                  	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
 29298 000043C9 263A0F                  	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
 29299 000043CC 7304                    	jae	short $P_Fin		;AN000; positional found.
 29300                                  
 29301                                  	;mov	ax,2
 29302 000043CE B80200                  	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
 29303                                  	; 27/04/2023
 29304 000043D1 F8                      	clc
 29305                                  $P_Fin: 				;AN000;
 29306 000043D2 5B                      	pop	bx			;AN000;
 29307                                  	;jmp	$P_Single_Exit		;AN000; return to the caller
 29308                                  	; 27/04/2023
 29309                                  	; cf = 0
 29310                                  	;clc
 29311 000043D3 C3                      	retn
 29312                                  
 29313                                  ;---------------------------
 29314                                  $P_Start:				;AN000;
 29315 000043D4 2E8936[3A86]            	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034;  save ptr to command line for later use by complex,
 29316 000043D9 53                      	push	bx			;AN000; quoted string or file spec.
 29317 000043DA 57                      	push	di			;AN000;
 29318 000043DB 55                      	push	bp			;AN000;
 29319 000043DC 8D1E[4286]              	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
 29320 000043E0 2EF606[3986]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29321                                  	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
 29322 000043E6 7543                    	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
 29323                                  $P_Pack_Loop:				;AN000;
 29324 000043E8 AC                      	lodsb				;AN000; Pick a operand from buffer
 29325 000043E9 E8C109                  	call	$P_Chk_Switch		;AN000; Check switch character
 29326 000043EC 723C                    	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 29327                                  
 29328 000043EE E82909                  	call	$P_Chk_EOL		;AN000; Check EOL character
 29329 000043F1 7437                    	je	short $P_Pack_End_BY_EOL ;AN000; need backup si
 29330                                  
 29331 000043F3 E85609                  	call	$P_Chk_Delim		;AN000; Check delimiter
 29332 000043F6 7518                    	jne	short $P_PL01 		;AN000; If no, process next byte
 29333                                  
 29334 000043F8 2EF606[3986]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29335                                  	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
 29336 000043FE 7505                    	jnz	short $P_Pack_End_backup_si
 29337                                  					;AN000; (tm08)
 29338 00004400 E8F508                  	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
 29339 00004403 EB26                    	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end
 29340                                  
 29341                                  $P_Pack_End_backup_si:			;AN000; (tm08)
 29342 00004405 2EF606[3986]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
 29343                                  	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
 29344 0000440B 741E                    	jz	short $P_Pack_End	;AN000; (tm08)
 29345                                  
 29346 0000440D 4E                      	dec	si			;AN000; (tm08)
 29347 0000440E EB1B                    	jmp	short $P_Pack_End	;AN025; (tm08)
 29348                                  $P_PL01:				;AN000;
 29349 00004410 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 29350                                  	;cmp	al,'='
 29351 00004413 3C3D                    	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
 29352 00004415 7506                    	jne	short $P_PL00 		;AN000; then
 29353                                  
 29354 00004417 2E800E[3986]01          	or	byte [cs:$P_Flags2],$P_equ
 29355                                  	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
 29356                                  $P_PL00:				;AN000;
 29357 0000441D 43                      	inc	bx			;AN000; ready to see next byte
 29358 0000441E E8B709                  	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 29359 00004421 73C5                    	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte
 29360                                  
 29361 00004423 AC                      	lodsb				;AN000; if yes, store
 29362 00004424 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 29363 00004427 43                      	inc	bx			;AN000; update pointer
 29364 00004428 EBBE                    	jmp	short $P_Pack_Loop	;AN000; process to next byte
 29365                                  
 29366                                  $P_Pack_End_BY_EOL:			;AN000;
 29367 0000442A 4E                      	dec	si			;AN000; backup si pointer
 29368                                  $P_Pack_End:				;AN000;
 29369 0000442B 2E8936[2F86]            	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
 29370                                  	;mov	byte [cs:bx],0
 29371 00004430 2EC60700                	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
 29372 00004434 2E891E[3E86]            	mov	[cs:$P_Save_EOB],bx
 29373                                  					;AC034; 3/17/87 keep the address for later use of complex
 29374                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29375 00004439 268B1D                  	mov	bx,[es:di]		;AN000; get PARMSX address
 29376 0000443C 8D36[4286]              	lea	si,$P_STRING_BUF	;AC034;
 29377                                  	;cmp	byte [cs:si],'/'
 29378 00004440 2E803C2F                	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
 29379 00004444 7436                    	je	short $P_SW_Manager	;AN000; if yes, process as switch
 29380                                  
 29381 00004446 2E803C22                	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
 29382 0000444A 7408                    	je	short $P_Positional_Manager
 29383                                  					;M005;if so, process as one!
 29384 0000444C 2EF606[3986]01          	test	byte [cs:$P_Flags2],$P_equ
 29385                                  	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
 29386 00004452 7554                    	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword
 29387                                  
 29388                                  $P_Positional_Manager:			;AN000; else process as positional
 29389                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29390 00004454 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29391 00004458 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29392 0000445A 2E3906[2B86]            	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
 29393 0000445F 7312                    	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many
 29394                                  
 29395 00004461 2EA1[2B86]              	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
 29396 00004465 D1E0                    	shl	ax,1			;AN000; ax = ax*2
 29397 00004467 43                      	inc	bx			;AC035; add '2' to
 29398 00004468 43                      	inc	bx			;AC035;  BX reg
 29399                                  					;AN000; now bx points to 1st CONTROL
 29400 00004469 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 29401 0000446B 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 29402 0000446E E88800                  	call	$P_Chk_Pos_Control	;AN000; Do process for positional
 29403 00004471 EB69                    	jmp	short $P_Return_to_Caller
 29404                                  					;AN000; and return to the caller
 29405                                  $P_Too_Many_Error:			;AN000;
 29406                                  	;mov	word [cs:$P_RC],1
 29407 00004473 2EC706[2D86]0100        	mov	word [cs:$P_RC],$P_Too_Many
 29408                                  					;AC034; set exit code
 29409 0000447A EB60                    	jmp	short $P_Return_to_Caller
 29410                                  					;AN000; and return to the caller
 29411                                  $P_SW_Manager:				;AN000;
 29412                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29413 0000447C 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29414 00004480 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29415 00004482 40                      	inc	ax			;AN000;
 29416 00004483 D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 29417 00004485 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 29418 00004487 268A0F                  	mov	cl,[es:bx]		;AN000;
 29419 0000448A 30ED                    	xor	ch,ch			;AN000; cx = maxs
 29420 0000448C 09C9                    	or	cx,cx			;AN000; at least one switch ?
 29421 0000448E 740F                    	jz	short $P_SW_Not_Found 	;AN000;
 29422 00004490 43                      	inc	bx			;AN000; now bx points to 1st CONTROL address
 29423                                  $P_SW_Mgr_Loop: 			;AN000;
 29424 00004491 53                      	push	bx			;AN000;
 29425 00004492 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 29426 00004495 E8C300                  	call	$P_Chk_SW_Control	;AN000; do process for switch
 29427 00004498 5B                      	pop	bx			;AN000;
 29428 00004499 7341                    	jnc	short $P_Return_to_Caller
 29429                                  					;AN000; if the CONTROL is for the switch, exit
 29430 0000449B 43                      	inc	bx			;AC035; add '2' to
 29431 0000449C 43                      	inc	bx			;AC035;  BX reg
 29432                                  					;AN000; else bx points to the next CONTROL
 29433 0000449D E2F2                    	loop	$P_SW_Mgr_Loop		;AN000; and loop
 29434                                  $P_SW_Not_Found:			;AN000;
 29435                                  	;mov	word [cs:$P_RC],3
 29436 0000449F 2EC706[2D86]0300        	mov	word [cs:$P_RC],$P_Not_In_SW
 29437                                  					;AC034; here no CONTROL for the switch has
 29438 000044A6 EB34                    	jmp	short $P_Return_to_Caller0
 29439                                  					;AN000; not been found, means error.
 29440                                  $P_Key_Manager: 			;AN000;
 29441                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29442 000044A8 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29443 000044AC 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29444 000044AE 40                      	inc	ax			;AN000;
 29445 000044AF D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 29446 000044B1 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 29447 000044B3 268A07                  	mov	al,[es:bx]		;AN000;
 29448 000044B6 30E4                    	xor	ah,ah			;AN000; ax = maxs
 29449 000044B8 D1E0                    	shl	ax,1			;AN000;
 29450 000044BA 40                      	inc	ax			;AN000; ax = ax*2+1
 29451 000044BB 01C3                    	add	bx,ax			;AN000; now bx points to maxk
 29452 000044BD 268A0F                  	mov	cl,[es:bx]		;AN000;
 29453 000044C0 30ED                    	xor	ch,ch			;AN000; cx = maxk
 29454 000044C2 09C9                    	or	cx,cx			;AN000; at least one keyword ?
 29455 000044C4 740F                    	jz	short $P_Key_Not_Found	;AN000;
 29456 000044C6 43                      	inc	bx			;AN000; now bx points to 1st CONTROL
 29457                                  $P_Key_Mgr_Loop:			;AN000;
 29458 000044C7 53                      	push	bx			;AN000;
 29459 000044C8 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 29460 000044CB E85A00                  	call	$P_Chk_Key_Control	;AN000; do process for keyword
 29461 000044CE 5B                      	pop	bx			;AN000;
 29462 000044CF 730B                    	jnc	short $P_Return_to_Caller
 29463                                  					;AN000; if the CONTROL is for the keyword, exit
 29464 000044D1 43                      	inc	bx			;AC035; add '2' to
 29465 000044D2 43                      	inc	bx			;AC035;  BX reg
 29466                                  					;AN000; else bx points to the next CONTROL
 29467 000044D3 E2F2                    	loop	$P_Key_Mgr_Loop 	;AN000; and loop
 29468                                  $P_Key_Not_Found:			;AN000;
 29469                                  	;mov	word [cs:$P_RC],4
 29470 000044D5 2EC706[2D86]0400        	mov	word [cs:$P_RC],$P_Not_In_Key
 29471                                  					;AC034; here no CONTROL for the keyword has
 29472                                  $P_Return_to_Caller0:
 29473                                  $P_Return_to_Caller:			;AN000; not been found, means error.
 29474 000044DC 5D                      	pop	bp			;AN000;
 29475 000044DD 5F                      	pop	di			;AN000;
 29476 000044DE 5B                      	pop	bx			;AN000;
 29477 000044DF 2E8B0E[2B86]            	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
 29478 000044E4 2EA1[2D86]              	mov	ax,[cs:$P_RC]		;AC034; return exit code
 29479 000044E8 2E8B36[2F86]            	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
 29480 000044ED 2E8B16[3186]            	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
 29481 000044F2 2E8A1E[3386]            	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
 29482                                  $P_Single_Exit: 			;AN000;
 29483 000044F7 F8                      	clc				;AN000;
 29484 000044F8 C3                      	retn				;AN000;
 29485                                  
 29486                                  ;***********************************************************************
 29487                                  ; $P_Chk_Pos_Control
 29488                                  ;
 29489                                  ; Function: Parse CONTROL block for a positional
 29490                                  ;
 29491                                  ; Input:     ES:BX -> CONTROL block
 29492                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29493                                  ;
 29494                                  ; Output:    None
 29495                                  ;
 29496                                  ; Use:	 $P_Fill_Result, $P_Check_Match_Flags
 29497                                  ;
 29498                                  ; Vars: $P_Ordinal(W), $P_RC(W)
 29499                                  ;***********************************************************************
 29500                                  
 29501                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29502                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h
 29503                                  
 29504                                  $P_Chk_Pos_Control:
 29505 000044F9 50                      	push	ax			;AN000;
 29506                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 29507 000044FA 268B07                  	mov	ax,[es:bx]		;AN000;
 29508                                  	;test	ax,2
 29509 000044FD A90200                  	test	ax,$P_Repeat		;AN000; repeat allowed ?
 29510 00004500 7505                    	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL
 29511                                  
 29512 00004502 2EFF06[2B86]            	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
 29513                                  $P_CPC00:				;AN000;
 29514                                  	;cmp	byte [cs:si],0
 29515 00004507 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
 29516 0000450B 7516                    	jne	short $P_CPC01		;AN000;
 29517                                  
 29518                                  	;test	ax,1
 29519 0000450D A90100                  	test	ax,$P_Optional		;AN000; yes, then is it optional ?
 29520 00004510 7509                    	jnz	short $P_CPC02		;AN000;
 29521                                  
 29522 00004512 2EC706[2D86]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 29523                                  					;AC034; no, then error	 3/17/87
 29524 00004519 EB0B                    	jmp	short $P_CPC_Exit	;AN000;
 29525                                  $P_CPC02:				;AN000;
 29526                                  	; 27/04/2023
 29527                                  	;push	ax ; *			;AN000;
 29528                                  	;
 29529                                  	;;mov	al,3
 29530                                  	;mov	al,$P_String		;AN000; if it is optional return NULL
 29531                                  	;;mov	ah,0FFh
 29532                                  	;mov	ah,$P_No_Tag		;AN000; no item tag indication
 29533                                  	;31/03/2023
 29534 0000451B B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 29535 0000451E E89700                  	call	$P_Fill_Result		;AN000;
 29536                                  	; 27/04/2023
 29537                                  	;pop	ax ; *			;AN000;
 29538 00004521 EB03                    	jmp	short $P_CPC_Exit	;AN000;
 29539                                  $P_CPC01:				;AN000;
 29540 00004523 E81301                  	call	$P_Check_Match_Flags	;AN000;
 29541                                  $P_CPC_Exit:				;AN000;
 29542 00004526 58                      	pop	ax			;AN000;
 29543 00004527 C3                      	retn				;AN000;
 29544                                  
 29545                                  ;***********************************************************************
 29546                                  ; $P_Chk_Key_Control
 29547                                  ;
 29548                                  ; Function: Parse CONTROL block for a keyword
 29549                                  ;
 29550                                  ; Input:     ES:BX -> CONTROL block
 29551                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29552                                  ;
 29553                                  ; Output:    CY = 1 : not match
 29554                                  ;
 29555                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 29556                                  ;
 29557                                  ; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 29558                                  ;***********************************************************************
 29559                                  
 29560                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29561                                  $P_Chk_Key_Control:			;AN000;
 29562 00004528 F9                      	stc				;AN000;this logic works when the KeySW
 29563 00004529 C3                      	retn				;AN000;is reset.
 29564                                  
 29565                                  ;***********************************************************************
 29566                                  ; $P_Search_KEYorSW:
 29567                                  ;
 29568                                  ; Function: Seach specified keyword or switch from CONTROL
 29569                                  ;
 29570                                  ; Input:     ES:BX -> CONTROL block
 29571                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29572                                  ;
 29573                                  ; Output:    CY = 1 : not match
 29574                                  ;
 29575                                  ; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
 29576                                  ;***********************************************************************
 29577                                  
 29578                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29579                                  
 29580                                  $P_Search_KEYorSW:
 29581 0000452A 55                      	push	bp			;AN000;
 29582 0000452B 51                      	push	cx			;AN000;
 29583 0000452C 268A4F08                	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
 29584                                  	;mov	cl,[es:bx+8]		;AN000; Get synonym count
 29585 00004530 30ED                    	xor	ch,ch			;AN000; and set it to cx
 29586 00004532 09C9                    	or	cx,cx			;AN000; No synonyms specified ?
 29587 00004534 740E                    	jz	short $P_KEYorSW_Not_Found
 29588                                  					;AN000; then indicate not found by CY
 29589 00004536 268D6F09                	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
 29590                                  	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
 29591                                  $P_KEYorSW_Loop:			;AN000;
 29592 0000453A E8F803                  	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 29593 0000453D 7308                    	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 29594 0000453F E80D00                  	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
 29595 00004542 E2F6                    	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
 29596                                  $P_KEYorSW_Not_Found:			;AN000;
 29597 00004544 F9                      	stc				;AN000; indicate not found in synonym list
 29598 00004545 EB05                    	jmp	short $P_KEYorSW_Exit	;AN000; and exit
 29599                                  $P_KEYorSW_Found:			;AN000;
 29600 00004547 2E892E[4086]            	mov	[cs:$P_Found_SYNONYM],bp
 29601                                  					;AC034; set synonym pointer
 29602                                  	; 27/04/2023
 29603                                  	; cf = 0
 29604                                  	;clc				;AN000; indicate found
 29605                                  $P_KEYorSW_Exit:			;AN000;
 29606 0000454C 59                      	pop	cx			;AN000;
 29607 0000454D 5D                      	pop	bp			;AN000;
 29608 0000454E C3                      	retn				;AN000;
 29609                                  
 29610                                  ;***********************************************************************
 29611                                  ; $P_MoveBP_NUL
 29612                                  ;***********************************************************************
 29613                                  
 29614                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29615                                  
 29616                                  $P_MoveBP_NUL:
 29617                                  $P_MBP_Loop:				;AN000;
 29618                                  	;cmp	byte [es:bp+0],0
 29619 0000454F 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
 29620 00004554 7403                    	je	short $P_MBP_Exit	;AN000; to the synomym list
 29621 00004556 45                      	inc	bp			;AN000; until
 29622 00004557 EBF6                    	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
 29623                                  $P_MBP_Exit:				;AN000;
 29624 00004559 45                      	inc	bp			;AN000; bp points to next to NULL
 29625 0000455A C3                      	retn				;AN000;
 29626                                  
 29627                                  ;***********************************************************************
 29628                                  ; $P_Chk_SW_Control
 29629                                  ;
 29630                                  ; Function: Parse CONTROL block for a switch
 29631                                  ;
 29632                                  ; Input:     ES:BX -> CONTROL block
 29633                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29634                                  ;
 29635                                  ; Output:    CY = 1 : not match
 29636                                  ;
 29637                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 29638                                  ;
 29639                                  ; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 29640                                  ;***********************************************************************
 29641                                  
 29642                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29643                                  
 29644                                  $P_Chk_SW_Control:
 29645 0000455B 2E800E[3986]10          	or	byte [cs:$P_Flags2],$P_SW_Cmp
 29646                                  	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
 29647 00004561 E8C6FF                  	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 29648 00004564 7251                    	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 29649                                  
 29650 00004566 2E8026[3986]EF          	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
 29651                                  	;and	byte [cs:$P_Flags2],0EFh
 29652                                  					;AC034; reset the indicator previously set
 29653 0000456C 50                      	push	ax			;AN000;       /switch:
 29654 0000456D 2EA1[3C86]              	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
 29655 00004571 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 29656 00004573 2E0106[3A86]            	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 29657 00004578 58                      	pop	ax			;AN000;
 29658                                  
 29659 00004579 2E8B36[3C86]            	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
 29660                                  	;cmp	byte [cs:si],0
 29661 0000457E 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
 29662 00004582 7525                    	jne	short $P_CSW00		;AN000; if yes, process match flags
 29663                                  
 29664                                  	;cmp	byte [cs:si],':'
 29665 00004584 2E807CFF3A              	cmp	byte [cs:si-1],$P_Colon
 29666                                  					;AN000; if no, the switch terminated by colon ?
 29667 00004589 7509                    	jne	short $P_Chk_if_data_required
 29668                                  					;AN000; if yes,
 29669                                  
 29670 0000458B 2EC706[2D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 29671                                  	;mov	word [cs:$P_RC],9	;AC034; return syntax error
 29672 00004592 EB1A                    	jmp	short $P_Chk_SW_Exit	;AN000;
 29673                                  
 29674                                  $P_Chk_if_data_required:		;AN018; no data, no colon
 29675                                  	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
 29676                                  	; 27/04/2023
 29677 00004594 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 29678 00004598 7414                    	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 29679                                  
 29680                                  	;;test	word [es:bx],1 ; $P_Optional
 29681                                  	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 29682 0000459A 26F60701                	test	byte [es:bx],$P_Optional
 29683                                  					;AN019; see if no value is valid
 29684 0000459E 750E                    	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 29685                                  
 29686 000045A0 2EC706[2D86]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 29687                                  	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
 29688 000045A7 EB05                    	jmp	short $P_Chk_SW_Exit	;AN018;
 29689                                  
 29690                                  $P_CSW00:				;AN000;
 29691 000045A9 E88D00                  	call	$P_Check_Match_Flags	;AN000; process match flag
 29692 000045AC F8                      	clc				;AN000; indicate match
 29693                                  	;jmp	short $P_Chk_SW_Single_Exit
 29694 000045AD C3                      	retn	; 31/03/2023		;AN000;
 29695                                  	; 31/03/2023
 29696                                  ;$P_Chk_SW_Err0: 			;AN000;
 29697                                  ;	stc				;AN000; not found in switch synonym list
 29698                                  ;	;jmp	short $P_Chk_SW_Single_Exit
 29699                                  ;	retn	; 31/03/2023		;AN000;
 29700                                  	
 29701                                  $P_Chk_SW_Exit: 			;AN000;
 29702 000045AE 50                      	push	ax			;AN000;
 29703                                  	; 31/03/2023
 29704 000045AF B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 29705                                  	;;mov	al,3
 29706                                  	;;mov	ah,0FFh
 29707                                  	;mov	al,$P_String		;AN000; set
 29708                                  	;mov	ah,$P_No_Tag		;AN000;    result
 29709 000045B2 E80300                  	call	$P_Fill_Result		;AN000; 	 buffer
 29710 000045B5 58                      	pop	ax			;AN000;
 29711 000045B6 F8                      	clc				;AN000;
 29712                                  	; 31/03/2023
 29713                                  $P_Chk_SW_Err0:
 29714                                  $P_Chk_SW_Single_Exit:			;AN000;
 29715 000045B7 C3                      	retn				;AN000;
 29716                                  
 29717                                  ;***********************************************************************
 29718                                  ; $P_Fill_Result
 29719                                  ;
 29720                                  ; Function: Fill the result buffer
 29721                                  ;
 29722                                  ; Input:    AH = Item tag
 29723                                  ;	    AL = type
 29724                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 29725                                  ;		  AL = 2: DX has index(offset) into value list
 29726                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 29727                                  ;		  AL = 7: DX has year, CL has month and CH has date
 29728                                  ;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
 29729                                  ;			  amd CH has hundredths
 29730                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
 29731                                  ;	    ES:BX -> CONTROL block
 29732                                  ;
 29733                                  ; Output:   None
 29734                                  ;
 29735                                  ; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
 29736                                  ;
 29737                                  ; Vars: $P_DX(W)
 29738                                  ;***********************************************************************
 29739                                  
 29740                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29741                                  
 29742                                  $P_Fill_Result:
 29743 000045B8 57                      	push	di			;AN000;
 29744 000045B9 268B7F04                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
 29745                                  	;mov	di,[es:bx+4]		;AN000; di points to result buffer
 29746 000045BD 2E893E[3186]            	mov	[cs:$P_DX],di		;AC034; set returned result address
 29747                                  	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
 29748                                  	;;mov	[es:di],al		;AN000; store type
 29749                                  	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
 29750                                  	;;mov	[es:di+1],ah		;AN000; store item tag
 29751                                  	; 31/03/2023
 29752 000045C2 268905                  	mov	[es:di],ax
 29753 000045C5 50                      	push	ax			;AN000;
 29754 000045C6 2EA1[4086]              	mov	ax,[cs:$P_Found_SYNONYM]
 29755                                  					;AC034; if yes,
 29756 000045CA 26894502                	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
 29757                                  	;mov	[es:di+2],ax		;AN000;   then set it to the result
 29758 000045CE 58                      	pop	ax			;AN000;
 29759                                  $P_RLT04:				;AN000;
 29760                                  	;cmp	al,1
 29761 000045CF 3C01                    	cmp	al,$P_Number		;AN000; if number
 29762 000045D1 750A                    	jne	short $P_RLT00		;AN000;
 29763                                  $P_RLT02:				;AN000;
 29764 000045D3 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 29765                                  	;mov	[es:di+4],dx		;AN000; then store 32bit
 29766 000045D7 26894D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
 29767                                  	;mov	[es:di+6],cx		;AN000;	number
 29768 000045DB EB5A                    	jmp	short $P_RLT_Exit	;AN000;
 29769                                  $P_RLT00:				;AN000;
 29770                                  	;cmp	al,2
 29771 000045DD 3C02                    	cmp	al,$P_List_Idx		;AN000; if list index
 29772 000045DF 7506                    	jne	short $P_RLT01		;AN000;
 29773 000045E1 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 29774                                  	;mov	[es:di+4],dx		;AN000; then store list index
 29775 000045E5 EB50                    	jmp	short $P_RLT_Exit	;AN000;
 29776                                  $P_RLT01:				;AN000;
 29777                                  	;cmp	al,7
 29778 000045E7 3C07                    	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
 29779 000045E9 74E8                    	je	short $P_RLT02		;AN000;
 29780                                  	;cmp	al,8
 29781 000045EB 3C08                    	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
 29782 000045ED 74E4                    	je	short $P_RLT02		;AN000;
 29783                                  	;cmp	al,6
 29784 000045EF 3C06                    	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
 29785 000045F1 7506                    	jne	short $P_RLT03		;AN000;
 29786                                  
 29787 000045F3 26885504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
 29788                                  	;mov	[es:di+4],dl		;AN000; store drive number
 29789 000045F7 EB3E                    	jmp	short $P_RLT_Exit	;AN000;
 29790                                  
 29791                                  $P_RLT03:				;AN000;
 29792                                  	;cmp	al,4
 29793 000045F9 3C04                    	cmp	al,$P_Complex		;AN000; complex format ?
 29794 000045FB 750F                    	jne	short $P_RLT05		;AN000;
 29795                                  
 29796 000045FD 2EA1[3A86]              	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
 29797 00004601 40                      	inc	ax			;AN000; skip left Parentheses
 29798 00004602 26894504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
 29799                                  	;mov	[es:di+4],ax		;AN000; store offset
 29800 00004606 268C5D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
 29801                                  	;mov	[es:di+6],ds		;AN000; store segment
 29802 0000460A EB2B                    	jmp	short $P_RLT_Exit	;AN000;
 29803                                  
 29804                                  $P_RLT05:				;AN000;
 29805                                  ;------------------------  AL = 3, 5, or 9
 29806 0000460C 26897504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
 29807                                  	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
 29808 00004610 268C4D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
 29809                                  	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF
 29810                                  
 29811 00004614 50                      	push	ax			;AN000;
 29812 00004615 26F6470201              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
 29813                                  	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
 29814 0000461A 7404                    	jz	short $P_RLT_CAP00	;AN000;
 29815                                  
 29816                                  	;mov	al,4
 29817 0000461C B004                    	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
 29818 0000461E EB09                    	jmp	short $P_RLT_CAP02	;AN000;
 29819                                  
 29820                                  $P_RLT_CAP00:				;AN000;
 29821 00004620 26F6470202              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
 29822                                  	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
 29823 00004625 7405                    	jz	short $P_RLT_CAP01	;AN000;
 29824                                  
 29825                                  	;mov	al,2
 29826 00004627 B002                    	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
 29827                                  $P_RLT_CAP02:				;AN000;
 29828 00004629 E80C01                  	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
 29829                                  $P_RLT_CAP01:				;AN000;
 29830 0000462C 58                      	pop	ax			;AN000;
 29831 0000462D 26F6470210              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
 29832                                  	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
 29833 00004632 7403                    	jz	short $P_RLT_Exit	;AN000;
 29834                                  
 29835 00004634 E8DD00                  	call	$P_Remove_Colon 	;AN000; then process it.
 29836                                  $P_RLT_Exit:				;AN000;
 29837 00004637 5F                      	pop	di			;AN000;
 29838 00004638 C3                      	retn				;AN000;
 29839                                  
 29840                                  ;***********************************************************************
 29841                                  ; $P_Check_Match_Flags
 29842                                  ;
 29843                                  ; Function:  Check the mutch_flags and make the exit code and set the
 29844                                  ;	     result buffer
 29845                                  ;
 29846                                  ;	    Check for types in this order:
 29847                                  ;		Complex
 29848                                  ;		Date
 29849                                  ;		Time
 29850                                  ;		Drive
 29851                                  ;		Filespec
 29852                                  ;		Quoted String
 29853                                  ;		Simple String
 29854                                  ;
 29855                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 29856                                  ;	     ES:BX -> CONTROL block
 29857                                  ;
 29858                                  ; Output:    None
 29859                                  ;
 29860                                  ; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
 29861                                  ;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
 29862                                  ;	     $P_Drive_Format
 29863                                  ;***********************************************************************
 29864                                  
 29865                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29866                                  
 29867                                  $P_Check_Match_Flags:
 29868 00004639 2EC606[0687]00          	mov	byte [cs:$P_err_flag],$P_NULL ; 0
 29869                                  					;AN033;AC034;; clear filespec error flag.
 29870 0000463F 50                      	push	ax			;AN000;
 29871                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 29872 00004640 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 29873 00004643 09C0                    	or	ax,ax			;AC035; test ax for zero
 29874 00004645 7518                    	jnz	short $P_Mat		;AN000; (tm12)
 29875 00004647 50                      	push	ax			;AN000; (tm12)
 29876 00004648 53                      	push	bx			;AN000; (tm12)
 29877 00004649 52                      	push	dx			;AN000; (tm12)
 29878 0000464A 57                      	push	di			;AN000; (tm12)
 29879 0000464B 2EC706[2D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 29880                                  	;mov	word [cs:$P_RC],9	;AC034; (tm12)
 29881                                  	; 31/03/2023
 29882 00004652 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 29883                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
 29884                                  	;mov	al,$P_String ; 3	;AN000; (tm12)
 29885 00004655 E860FF                  	call	$P_Fill_Result		;AN000; (tm12)
 29886 00004658 5F                      	pop	di			;AN000; (tm12)
 29887 00004659 5A                      	pop	dx			;AN000; (tm12)
 29888 0000465A 5B                      	pop	bx			;AN000; (tm12)
 29889 0000465B 58                      	pop	ax			;AN000; (tm12)
 29890                                  	;jmp	short $P_Bridge 	;AC035; (tm12)
 29891                                  	; 31/03/2023
 29892                                  $P_Bridge:	; 18/04/2023		;AN000;
 29893 0000465C E99C00                  	jmp	$P_Match_Exit		;AN000; (tm02)
 29894                                  $P_Mat: 				;AN000; (tm12)
 29895                                  $P_Match01:				;AN000;
 29896                                  	;test	ax,1000h
 29897 0000465F A90010                  	test	ax,$P_Date_S		;AN000; Date string
 29898 00004662 7412                    	jz	short $P_Match02	;AN000;
 29899 00004664 2EC706[2D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 29900                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 29901 0000466B E86503                  	call	$P_Date_Format		;AN000; do process
 29902 0000466E 2E833E[2D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 29903                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 29904                                  	; 18/04/2023
 29905 00004674 75E6                    	jne	short $P_Bridge		;AN000;
 29906                                  $P_Match02:				;AN000;
 29907                                  	;test	ax,800h
 29908 00004676 A90008                  	test	ax,$P_Time_S		;AN000; Time string
 29909 00004679 7412                    	jz	short $P_Match03	;AN000;
 29910 0000467B 2EC706[2D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 29911                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 29912 00004682 E86004                  	call	$P_Time_Format		;AN000; do process
 29913 00004685 2E833E[2D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 29914                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 29915                                  	;jne	short $P_Bridge		;AN000; (tm09)
 29916                                  	;jmp	short $P_Match03	;AN025; (tm09)
 29917                                  	; 31/03/2023
 29918 0000468B 756E                    	jne	short $P_Match_Exit
 29919                                  ;$P_Bridge:				;AN000;
 29920                                  	;jmp	short $P_Match_Exit	;AN000; (tm02)
 29921                                  $P_Match03:				;AN000;
 29922                                  	;test	ax,8000h
 29923 0000468D A90080                  	test	ax,$P_Num_Val		;AN000; Numeric value
 29924 00004690 7412                    	jz	short $P_Match04	;AN000;
 29925 00004692 2EC706[2D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 29926                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 29927 00004699 E82C01                  	call	$P_Value		;AN000; do process
 29928 0000469C 2E833E[2D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 29929                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 29930 000046A2 7557                    	jne	short $P_Match_Exit	;AN000;
 29931                                  $P_Match04:				;AN000;
 29932                                  	;test	ax,4000h
 29933 000046A4 A90040                  	test	ax,$P_SNum_Val		;AN000; Signed numeric value
 29934 000046A7 7412                    	jz	short $P_Match05	;AN000;
 29935 000046A9 2EC706[2D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 29936                                  					;AC034; assume no error
 29937 000046B0 E8F100                  	call	$P_SValue		;AN000; do process
 29938 000046B3 2E833E[2D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 29939                                  					;AC034; if error, examine the next type
 29940 000046B9 7540                    	jne	short $P_Match_Exit	;AN000;
 29941                                  $P_Match05:				;AN000;
 29942                                  	;test	ax,100h
 29943 000046BB A90001                  	test	ax,$P_Drv_Only		;AN000; Drive only
 29944 000046BE 7415                    	jz	short $P_Match06	;AN000;
 29945 000046C0 2EC706[2D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 29946                                  					;AC034; assume no error
 29947 000046C7 E86805                  	call	$P_File_Format		;AN000; 1st, call file format
 29948 000046CA E8E905                  	call	$P_Drive_Format 	;AN000; check drive format, next
 29949 000046CD 2E833E[2D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 29950                                  					;AC034; if error, examinee the next type
 29951 000046D3 7526                    	jne	short $P_Match_Exit	;AN000;
 29952                                  $P_Match06:				;AN000;
 29953                                  	;test	ax,200h
 29954 000046D5 A90002                  	test	ax,$P_File_Spc		;AN000; File spec
 29955 000046D8 7412                    	jz	short $P_Match07	;AN000;
 29956 000046DA 2EC706[2D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 29957                                  					;AC034; assume no error
 29958 000046E1 E84E05                  	call	$P_File_Format		;AN000; do process
 29959 000046E4 2E833E[2D86]09          	cmp	word [cs:$P_RC],$P_Syntax
 29960                                  					;AC034; if error, examine the next type
 29961 000046EA 750F                    	jne	short $P_Match_Exit	;AN000;
 29962                                  $P_Match07:				;AN000;
 29963                                  $P_Match08:				;AN000;
 29964                                  	;test	ax,2000h
 29965 000046EC A90020                  	test	ax,$P_Simple_S		;AN000; Simple string
 29966 000046EF 740A                    	jz	short $P_Match09	;AN000;
 29967 000046F1 2EC706[2D86]0000        	mov	word [cs:$P_RC],$P_No_Error
 29968                                  					;AC034; assume no error
 29969 000046F8 E8D601                  	call	$P_Simple_String	;AN000; do process
 29970                                  $P_Match09:				;AN000;
 29971                                  $P_Match_Exit:				;AN000;
 29972 000046FB 2E833E[0687]01          	cmp	word [cs:$P_err_flag],$P_error_filespec
 29973                                  	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
 29974 00004701 750F                    	jne	short $P_Match2_Exit	;AN033; no, continue
 29975 00004703 2E833E[2D86]00          	cmp	word [cs:$P_RC],$P_No_Error
 29976                                  	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
 29977 00004709 7507                    	jne	short $P_Match2_Exit	;AN033; no, continue
 29978 0000470B 2EC706[2D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 29979                                  	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
 29980                                  $P_Match2_Exit: 			;AN033;
 29981 00004712 58                      	pop	ax			;AN000;
 29982 00004713 C3                      	retn
 29983                                  
 29984                                  ;***********************************************************************
 29985                                  ; $P_Remove_Colon;
 29986                                  ;
 29987                                  ; Function: Remove colon at end
 29988                                  ;
 29989                                  ; Input:    psdata_seg:SI points to string buffer to be examineed
 29990                                  ;
 29991                                  ; Output:   None
 29992                                  ;
 29993                                  ; Use:	$P_Chk_DBCS
 29994                                  ;***********************************************************************
 29995                                  
 29996                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29997                                  
 29998                                  $P_Remove_Colon:
 29999 00004714 50                      	push	ax			;AN000;
 30000 00004715 56                      	push	si			;AN000;
 30001                                  $P_RCOL_Loop:				;AN000;
 30002 00004716 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30003 00004719 08C0                    	or	al,al			;AN000; end of string ?
 30004 0000471B 740F                    	jz	short $P_RCOL_Exit	;AN000; if yes, just exit
 30005                                  
 30006 0000471D 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
 30007 0000471F 750E                    	jne	short $P_RCOL00		;AN000;
 30008                                  
 30009                                  	;cmp	byte [cs:si+1],0
 30010 00004721 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
 30011 00004726 7507                    	jne	short $P_RCOL00		;AN000; no, then next char
 30012                                  
 30013 00004728 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
 30014                                  	; 31/03/2023
 30015                                  	;jmp	short $P_RCOL_Exit	;AN000; and exit.
 30016                                  $P_RCOL_Exit:
 30017 0000472C 5E                      	pop	si
 30018 0000472D 58                      	pop	ax
 30019 0000472E C3                      	retn
 30020                                  
 30021                                  $P_RCOL00:				;AN000;
 30022 0000472F E8A606                  	call	$P_Chk_DBCS		;AN000; if not colon, then check if
 30023 00004732 7301                    	jnc	short $P_RCOL01		;AN000; DBCS leading byte.
 30024                                  
 30025 00004734 46                      	inc	si			;AN000; if yes, skip trailing byte
 30026                                  $P_RCOL01:				;AN000;
 30027 00004735 46                      	inc	si			;AN000; si points to next byte
 30028 00004736 EBDE                    	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered
 30029                                  
 30030                                  	; 31/03/2023
 30031                                  ;$P_RCOL_Exit:				;AN000;
 30032                                  	;pop	si			;AN000;
 30033                                  	;pop	ax			;AN000;
 30034                                  	;retn
 30035                                  
 30036                                  ;***********************************************************************
 30037                                  ; $P_Do_CAPS_String;
 30038                                  ;
 30039                                  ; Function: Perform capitalization along with the file case map table
 30040                                  ;	    or character case map table.
 30041                                  ;
 30042                                  ; Input:    AL = 2 : Use character table
 30043                                  ;	    AL = 4 : Use file table
 30044                                  ;	    psdata_seg:SI points to string buffer to be capitalized
 30045                                  ;
 30046                                  ; Output:   None
 30047                                  ;
 30048                                  ; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
 30049                                  ;***********************************************************************
 30050                                  
 30051                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30052                                  
 30053                                  $P_Do_CAPS_String:
 30054 00004738 56                      	push	si			;AN000;
 30055 00004739 52                      	push	dx			;AN000;
 30056 0000473A 88C2                    	mov	dl,al			;AN000; save info id
 30057                                  $P_DCS_Loop:				;AN000;
 30058 0000473C 2E8A04                  	mov	al,[cs:si]		;AN000; load character and
 30059 0000473F E89606                  	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
 30060 00004742 720C                    	jc	short $P_DCS00		;AN000; if yes, do not need CAPS
 30061                                  
 30062 00004744 08C0                    	or	al,al			;AN000; end of string ?
 30063 00004746 740C                    	jz	short $P_DCS_Exit	;AN000; then exit.
 30064                                  
 30065 00004748 E80C00                  	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 30066 0000474B 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 30067 0000474E EB01                    	jmp	short $P_DCS01		;AN000; process nexit
 30068                                  $P_DCS00:				;AN000;
 30069 00004750 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 30070                                  $P_DCS01:				;AN000;
 30071 00004751 46                      	inc	si			;AN000; si point to next byte
 30072 00004752 EBE8                    	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
 30073                                  $P_DCS_Exit:				;AN000;
 30074 00004754 5A                      	pop	dx			;AN000;
 30075 00004755 5E                      	pop	si			;AN000;
 30076 00004756 C3                      	retn
 30077                                  
 30078                                  ;***********************************************************************
 30079                                  ; $P_Do_CAPS_Char;
 30080                                  ;
 30081                                  ; Function: Perform capitalization along with the file case map table
 30082                                  ;	    or character case map table.
 30083                                  ;
 30084                                  ; Input:    DL = 2 : Use character table
 30085                                  ;	    DL = 4 : Use file table
 30086                                  ;	    AL = character to be capitalized
 30087                                  ;
 30088                                  ; Output:   None
 30089                                  ;
 30090                                  ; Use:	INT 21h /w AH=65h
 30091                                  ;***********************************************************************
 30092                                  
 30093                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30094                                  
 30095                                  $P_Do_CAPS_Char:
 30096 00004757 3C80                    	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
 30097 00004759 730B                    	jae	short $P_DCC_Go		;AN000;
 30098                                  
 30099 0000475B 3C61                    	cmp	al,"a"  ; 61h		;AN000; if no,
 30100 0000475D 7244                    	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 30101                                  
 30102 0000475F 3C7A                    	cmp	al,"z"  ; 7Ah		;AN000;
 30103 00004761 7740                    	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS
 30104                                  
 30105 00004763 24DF                    	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
 30106                                  	;jmp	short $P_CAPS_Ret	;AN000;
 30107                                  	; 18/04/2023
 30108 00004765 C3                      	retn
 30109                                  
 30110                                  $P_DCC_Go:				;AN000;
 30111 00004766 53                      	push	bx			;AN000;
 30112 00004767 06                      	push	es			;AN000;
 30113 00004768 57                      	push	di			;AN000;
 30114                                  	; 18/04/2023
 30115 00004769 8D3E[F886]              	lea	di,$P_File_CAP_Ptr	;AC034;
 30116 0000476D 80FA04                  	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
 30117 00004770 7404                    	je	short $P_DCC00		;AN000;
 30118                                  	; 27/04/2023
 30119 00004772 8D3E[F386]              	lea	di,[$P_Char_CAP_Ptr]	;AC034; or use char CAPS table ?
 30120                                  $P_DCC00:				;AN000;
 30121 00004776 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 30122 00004779 7417                    	je	short $P_DCC01		;AN000; if no,
 30123                                  
 30124                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 30125                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 30126                                  ; call, regardless of what base register is currently be defined as PSDATA_SEG.
 30127                                  
 30128 0000477B 50                      	push	ax			;AN000; get CAPS table thru DOS call
 30129 0000477C 51                      	push	cx			;AN000;
 30130 0000477D 52                      	push	dx			;AN000;
 30131 0000477E 0E                      	push	cs			;AC036; pass current base seg into
 30132                                  					;(Note: this used to push CS. BUG...
 30133 0000477F 07                      	pop	es			;AN000;   ES reg, required for
 30134                                  					;get extended country information
 30135                                  	; 31/03/2023
 30136 00004780 B465                    	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
 30137                                  	;mov	ah,65h
 30138 00004782 88D0                    	mov	al,dl			;AN000; upper case table
 30139                                  	;mov	bx,-1 ; 0FFFFh
 30140                                  	;mov	cx,5
 30141                                  	;mov	dx,-1
 30142 00004784 BBFFFF                  	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
 30143 00004787 B90500                  	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
 30144 0000478A BAFFFF                  	mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
 30145                                  					;DI already set to point to buffer
 30146 0000478D CD21                    	int	21h			;AN000; es:di point to buffer that
 30147                                  					;now has been filled in with info
 30148 0000478F 5A                      	pop	dx			;AN000;
 30149 00004790 59                      	pop	cx			;AN000;
 30150 00004791 58                      	pop	ax			;AN000;
 30151                                  
 30152                                  $P_DCC01:				;AN000;
 30153                                  
 30154                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 30155                                  ; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
 30156                                  ; regardless of which base reg is currently the PSDATA_SEG reg.
 30157                                  
 30158 00004792 2E8B5D01                	mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 30159                                  	;mov	bx,[cs:di+1]		;AN000; get offset of table
 30160 00004796 2E8E4503                	mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
 30161                                  	;mov	es,[cs:di+3]		;AN000; get segment of table
 30162 0000479A 43                      	inc	bx			;AC035; add '2' to
 30163 0000479B 43                      	inc	bx			;AC035;  BX reg
 30164                                  					;AN000; skip length field
 30165 0000479C 2C80                    	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
 30166                                  	;xlat	es:[bx] 		;AN000; perform case map
 30167                                  	; 31/03/2023
 30168 0000479E 26D7                    	es	xlat
 30169                                  
 30170 000047A0 5F                      	pop	di			;AN000;
 30171 000047A1 07                      	pop	es			;AN000;
 30172 000047A2 5B                      	pop	bx			;AN000;
 30173                                  $P_CAPS_Ret:				;AN000;
 30174 000047A3 C3                      	retn
 30175                                  
 30176                                  ;***********************************************************************
 30177                                  ; $P_Value / $P_SValue
 30178                                  ;
 30179                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
 30180                                  ;	     and make result buffer.
 30181                                  ;	     $P_SValue is an entry point for the signed value
 30182                                  ;	     and this will simply call $P_Value after the handling
 30183                                  ;	     of the sign character, "+" or "-"
 30184                                  ;
 30185                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30186                                  ;	     ES:BX -> CONTROL block
 30187                                  ;
 30188                                  ; Output:    None
 30189                                  ;
 30190                                  ; Use:	$P_Fill_Result, $P_Check_OVF
 30191                                  ;
 30192                                  ; Vars: $P_RC(W), $P_Flags(RW)
 30193                                  ;***********************************************************************
 30194                                  
 30195                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30196                                  $P_SValue:
 30197 000047A4 50                      	push	ax			;AN000;
 30198                                  	;or	byte [cs:$P_Flags2],80h
 30199 000047A5 2E800E[3986]80          	or	byte [cs:$P_Flags2],$P_Signed
 30200                                  					;AC034; indicate a signed numeric
 30201                                  	;and	byte [cs:$P_Flags2],0FDh
 30202 000047AB 2E8026[3986]FD          	and	byte [cs:$P_Flags2],0FFh-$P_Neg
 30203                                  					;AC034; assume positive value
 30204 000047B1 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 30205 000047B4 3C2B                    	cmp	al,'+' ; 2Bh
 30206                                  	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
 30207 000047B6 740A                    	je	short $P_SVal00		;AN000;
 30208                                  
 30209 000047B8 3C2D                    	cmp	al,'-' ; 2Dh
 30210                                  	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
 30211 000047BA 7507                    	jne	short $P_Sval01		;AN000; else
 30212                                  
 30213 000047BC 2E800E[3986]02          	or	byte [cs:$P_Flags2],$P_Neg ; 2
 30214                                  					;AC034; set this is negative value
 30215                                  $P_SVal00:				;AN000;
 30216 000047C2 46                      	inc	si			;AN000; skip sign char
 30217                                  $P_Sval01:				;AN000;
 30218 000047C3 E80200                  	call	$P_Value		;AN000; and process value
 30219 000047C6 58                      	pop	ax			;AN000;
 30220 000047C7 C3                      	retn				;AN000;
 30221                                  
 30222                                  ;***********************************************************************
 30223                                  
 30224                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30225                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h
 30226                                  
 30227                                  $P_Value:
 30228 000047C8 50                      	push	ax			;AN000;
 30229 000047C9 51                      	push	cx			;AN000;
 30230 000047CA 52                      	push	dx			;AN000;
 30231 000047CB 56                      	push	si			;AN000;
 30232 000047CC 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 30233 000047CE 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 30234 000047D0 53                      	push	bx			;AN000; save control pointer
 30235                                  $P_Value_Loop:				;AN000;
 30236 000047D1 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30237 000047D4 08C0                    	or	al,al			;AN000; end of line ?
 30238 000047D6 7442                    	jz	short $P_Value00	;AN000;
 30239                                  
 30240 000047D8 E8EB00                  	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 30241 000047DB 7239                    	jc	short $P_Value_Err0	;AN000;
 30242                                  
 30243 000047DD 30E4                    	xor	ah,ah			;AN000;
 30244 000047DF 89C5                    	mov	bp,ax			;AN000; save binary number
 30245 000047E1 D1E2                    	shl	dx,1			;AN000; to have 2*x
 30246 000047E3 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30247 000047E5 E8CC00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30248 000047E8 722C                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30249                                  
 30250 000047EA 89D3                    	mov	bx,dx			;AN000; save low(2*x)
 30251 000047EC 89C8                    	mov	ax,cx			;AN000; save high(2*x)
 30252 000047EE D1E2                    	shl	dx,1			;AN000; to have 4*x
 30253 000047F0 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30254 000047F2 E8BF00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30255 000047F5 721F                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30256                                  
 30257 000047F7 D1E2                    	shl	dx,1			;AN000; to have 8*x
 30258 000047F9 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30259 000047FB E8B600                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30260 000047FE 7216                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30261                                  
 30262 00004800 01DA                    	add	dx,bx			;AN000; now have 10*x
 30263 00004802 11C1                    	adc	cx,ax			;AN000; 32bit ADD
 30264 00004804 E8AD00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30265 00004807 720D                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30266                                  
 30267 00004809 01EA                    	add	dx,bp			;AN000; Add the current one degree decimal
 30268 0000480B 83D100                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 30269 0000480E E8A300                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30270 00004811 7203                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30271                                  
 30272 00004813 46                      	inc	si			;AN000; update pointer
 30273 00004814 EBBB                    	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
 30274                                  
 30275                                  $P_Value_Err0:				;AN000;
 30276 00004816 5B                      	pop	bx			;AN000;
 30277 00004817 E98800                  	jmp	$P_Value_Err		;AN000; Bridge
 30278                                  
 30279                                  $P_Value00:				;AN000;
 30280 0000481A 5B                      	pop	bx			;AN000; restore control pointer
 30281 0000481B 2EF606[3986]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2 
 30282                                  					;AC034; here cx,dx = 32bit value
 30283 00004821 740A                    	jz	short $P_Value01	;AN000; was it negative ?
 30284                                  
 30285 00004823 F7D1                    	not	cx			;AN000; +
 30286 00004825 F7D2                    	not	dx			;AN000; |- Make 2's complement
 30287 00004827 83C201                  	add	dx,1			;AN000; |
 30288 0000482A 83D100                  	adc	cx,0			;AN000; +
 30289                                  $P_Value01:				;AN000; / nval =0
 30290 0000482D 268B7706                	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30291                                  	;mov	si,[es:bx+6]		;AN000; si points to value list
 30292 00004831 268A04                  	mov	al,[es:si]		;AN000; get nval
 30293 00004834 3C00                    	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
 30294 00004836 7505                    	jne	short $P_Value02	;AN000;
 30295                                  
 30296                                  	;mov	al,$P_Number	; 1	;AN000; Set type
 30297                                  	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
 30298                                  	; 31/03/2023
 30299 00004838 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30300 0000483B EB6F                    	jmp	short $P_Value_Exit	;AN000;
 30301                                  
 30302                                  $P_Value02:				;AN000; / nval = 1
 30303 0000483D 46                      	inc	si			;AN000;
 30304 0000483E 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 30305 00004841 3C00                    	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
 30306 00004843 745D                    	je	short $P_Value03	;AN000; (tm07)
 30307                                  
 30308 00004845 46                      	inc	si			;AN000; si points to 1st item_tag
 30309                                  $P_Val02_Loop:				;AN000;
 30310 00004846 2EF606[3986]80          	test	byte [cs:$P_Flags2],$P_Signed ; 80h
 30311                                  	;test	byte [cs:$P_Flags2],80h	;AC034;
 30312 0000484C 751E                    	jnz	short $P_Val02_Sign	;AN000;
 30313                                  
 30314 0000484E 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30315                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30316 00004852 723B                    	jb	short $P_Val02_Next	;AN000;
 30317 00004854 7706                    	ja	short $P_Val_In		;AN000;
 30318                                  
 30319 00004856 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30320                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30321 0000485A 7233                    	jb	short $P_Val02_Next	;AN000;
 30322                                  
 30323                                  $P_Val_In:				;AN000;
 30324 0000485C 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30325                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
 30326 00004860 772D                    	ja	short $P_Val02_Next	;AN000;
 30327 00004862 7224                    	jb	short $P_Val_Found	;AN000;
 30328                                  
 30329 00004864 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30330                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30331 00004868 7725                    	ja	short $P_Val02_Next	;AN000;
 30332                                  
 30333 0000486A EB1C                    	jmp	short $P_Val_Found	;AN000;
 30334                                  
 30335                                  $P_Val02_Sign:				;AN000;
 30336 0000486C 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30337                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30338 00004870 7C1D                    	jl	short $P_Val02_Next	;AN000;
 30339 00004872 7F06                    	jg	short $P_SVal_In	;AN000;
 30340                                  
 30341 00004874 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30342                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30343 00004878 7C15                    	jl	short $P_Val02_Next	;AN000;
 30344                                  
 30345                                  $P_SVal_In:				;AN000;
 30346 0000487A 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30347                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
 30348 0000487E 7F0F                    	jg	short $P_Val02_Next	;AN000;
 30349 00004880 7C06                    	jl	short $P_Val_Found	;AN000;
 30350                                  
 30351 00004882 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30352                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30353 00004886 7F07                    	jg	short $P_Val02_Next	;AN000;
 30354                                  
 30355                                  	;jmp	short $P_Val_Found	;AN000;
 30356                                  	; 27/04/2023
 30357                                  $P_Val_Found:				;AN000;
 30358 00004888 B001                    	mov	al,$P_Number ; 1	;AN000;
 30359 0000488A 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30360 0000488D EB1D                    	jmp	short $P_Value_Exit	;AN000;
 30361                                  
 30362                                  $P_Val02_Next:				;AN000;
 30363 0000488F 83C609                  	add	si,$P_Len_Range ; 9 	;AN000;
 30364 00004892 FEC8                    	dec	al			;AN000; loop nrng times in AL
 30365 00004894 75B0                    	jnz	short $P_Val02_Loop	;AN000;
 30366                                  					; / Not found
 30367 00004896 2EC706[2D86]0600        	mov	word [cs:$P_RC],$P_Out_Of_Range
 30368                                  	;mov	word [cs:$P_RC],6	;AC034;
 30369                                  	
 30370                                  	;mov	al,$P_Number ; 1	;AN000;
 30371                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30372                                  	; 31/03/2023
 30373 0000489D B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30374 000048A0 EB0A                    	jmp	short $P_Value_Exit	;AN000;
 30375                                  
 30376                                  	; 27/04/2023
 30377                                  ;$P_Val_Found:				;AN000;
 30378                                  	;mov	al,$P_Number ; 1	;AN000;
 30379                                  	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30380                                  	;jmp	short $P_Value_Exit	;AN000;
 30381                                  
 30382                                  $P_Value03:				;AN000; / nval = 2
 30383                                  $P_Value04:				;AN000; / nval = 3 or else
 30384                                  $P_Value_Err:				;AN000;
 30385 000048A2 2EC706[2D86]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 30386                                  					;AC034;
 30387                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30388                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30389                                  	; 31/03/2023
 30390 000048A9 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30391                                  $P_Value_Exit:				;AN000;
 30392 000048AC E809FD                  	call	$P_Fill_Result		;AN000;
 30393 000048AF 5E                      	pop	si			;AN000;
 30394 000048B0 5A                      	pop	dx			;AN000;
 30395 000048B1 59                      	pop	cx			;AN000;
 30396 000048B2 58                      	pop	ax			;AN000;
 30397 000048B3 C3                      	retn				;AN000;
 30398                                  
 30399                                  ;***********************************************************************
 30400                                  ; $P_Check_OVF
 30401                                  ;
 30402                                  ; Function:  Check if overflow is occurred with consideration of
 30403                                  ;	     signed or un-signed numeric value
 30404                                  ;
 30405                                  ; Input:     Flag register
 30406                                  ;
 30407                                  ; Output:    CY = 1  :	Overflow
 30408                                  ;
 30409                                  ; Vars:     $P_Flags(R)
 30410                                  ;***********************************************************************
 30411                                  
 30412                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30413                                  $P_Check_OVF:
 30414 000048B4 9C                      	pushf				;AN000;
 30415 000048B5 2EF606[3986]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2
 30416                                  					;AC034; is it negative value ?
 30417 000048BB 7502                    	jnz	short $P_COVF		;AN000; if no, check overflow
 30418 000048BD 9D                      	popf				;AN000; by the CY bit
 30419 000048BE C3                      	retn				;AN000;
 30420                                  $P_COVF:				;AN000;
 30421 000048BF 9D                      	popf				;AN000; else,
 30422 000048C0 7002                    	jo	short $P_COVF00		;AN000; check overflow by the OF
 30423 000048C2 F8                      	clc				;AN000; indicate it with CY bit
 30424 000048C3 C3                      	retn				;AN000; CY=0 means no overflow
 30425                                  $P_0099Err:	; 31/03/2023
 30426                                  $P_COVF00:				;AN000;
 30427 000048C4 F9                      	stc				;AN000; and CY=1 means overflow
 30428                                  $P_0099Err2:	; 31/03/2023
 30429 000048C5 C3                      	retn				;AN000;
 30430                                  
 30431                                  ;***********************************************************************
 30432                                  ; $P_0099;
 30433                                  ;
 30434                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 30435                                  ;
 30436                                  ; Input:     AL = character code
 30437                                  ;
 30438                                  ; Output:    CY = 1 : AL is not number
 30439                                  ;	     CY = 0 : AL contains binary value
 30440                                  ;***********************************************************************
 30441                                  
 30442                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30443                                  $P_0099:
 30444 000048C6 3C30                    	cmp	al,"0"                  ;AN000;
 30445                                  	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30446                                  	; 31/03/2023
 30447 000048C8 72FB                    	jb	short $P_0099Err2
 30448                                  
 30449 000048CA 3C39                    	cmp	al,"9"                  ;AN000;
 30450 000048CC 77F6                    	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30451                                  
 30452 000048CE 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 30453                                  	; 31/03/2023
 30454                                  	;clc				;AN000; indicate no error
 30455 000048D0 C3                      	retn				;AN000;
 30456                                  	 ;31/03/2023
 30457                                  ;$P_0099Err:				;AN000;
 30458                                  ;	stc				;AN000; indicate error
 30459                                  ;	retn				;AN000;
 30460                                  
 30461                                  ;***********************************************************************
 30462                                  ; $P_Simple_String
 30463                                  ;
 30464                                  ; Function:  See value list for the simple string
 30465                                  ;	     and make result buffer.
 30466                                  ;
 30467                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30468                                  ;	     ES:BX -> CONTROL block
 30469                                  ;
 30470                                  ; Output:    None
 30471                                  ;
 30472                                  ; Use:	$P_Fill_Result, $P_String_Comp
 30473                                  ;
 30474                                  ; Vars: $P_RC(W)
 30475                                  ;***********************************************************************
 30476                                  
 30477                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30478                                  
 30479                                  $P_Simple_String:
 30480 000048D1 50                      	push	ax			;AN000;
 30481 000048D2 53                      	push	bx			;AN000;
 30482 000048D3 52                      	push	dx			;AN000;
 30483 000048D4 57                      	push	di			;AN000;
 30484 000048D5 268B7F06                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30485                                  	;mov	di,[es:bx+6]		;AN000; di points to value list
 30486 000048D9 268A05                  	mov	al,[es:di]		;AN000; get nval
 30487 000048DC 08C0                    	or	al,al			;AN000; no value list ?
 30488 000048DE 7502                    	jnz	short $P_Sim00		;AN000; then
 30489                                  	; 31/03/2023
 30490                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30491 000048E0 EB48                    	jmp	short $P_Sim_Exit	;AN000; and set result buffer
 30492                                  $P_Sim00:				;AN000;
 30493 000048E2 3C03                    	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
 30494 000048E4 753D                    	jne	short $P_Sim01		;AN000; if no, syntax error
 30495                                  
 30496 000048E6 47                      	inc	di			;AN000;
 30497 000048E7 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 30498 000048EA B409                    	mov	ah,$P_Len_Range ; 9	;AN000;
 30499 000048EC F6E4                    	mul	ah			;AN000;  Skip nrng field
 30500 000048EE 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 30501 000048EF 01C7                    	add	di,ax			;AN000; di points to nnval
 30502 000048F1 268A05                  	mov	al,[es:di]		;AN000; get nnval
 30503 000048F4 B405                    	mov	ah,$P_Len_Value ; 5	;AN000;
 30504 000048F6 F6E4                    	mul	ah			;AN000; Skip nnval field
 30505 000048F8 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 30506 000048F9 01C7                    	add	di,ax			;AN000; di points to nstrval
 30507 000048FB 268A05                  	mov	al,[es:di]		;AN000; get nstrval
 30508 000048FE 47                      	inc	di			;AC035; add '2' to
 30509 000048FF 47                      	inc	di			;AC035;  DI reg
 30510                                  					;AN000; di points to 1st string in list
 30511                                  $P_Sim_Loop:				;AN000;
 30512 00004900 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 30513 00004903 E82F00                  	call	$P_String_Comp		;AN000; compare it with operand
 30514 00004906 7310                    	jnc	short $P_Sim_Found	;AN000; found on list ?
 30515                                  
 30516 00004908 83C703                  	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
 30517 0000490B FEC8                    	dec	al			;AN000; loop nstval times in AL
 30518 0000490D 75F1                    	jnz	short $P_Sim_Loop	;AN000;
 30519                                  					;AN000; / Not found
 30520 0000490F 2EC706[2D86]0800        	mov	word [cs:$P_RC],$P_Not_In_Str
 30521                                  	;mov	[cs:$P_RC],8		;AC034;
 30522                                  	; 31/03/2023
 30523                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30524 00004916 EB12                    	jmp	short $P_Sim_Exit	;AN000;
 30525                                  $P_Sim_Found:				;AN000;
 30526 00004918 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 30527 0000491C B002                    	mov	al,$P_List_Idx	; 2	;AN000;
 30528 0000491E 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 30529 00004921 EB0A                    	jmp	short $P_Sim_Exit0	;AN000;
 30530                                  $P_Sim01:				;AN000;
 30531 00004923 2EC706[2D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 30532                                  	;mov	word [cs:$P_RC],9	;AC034;
 30533                                  $P_Sim_Exit:
 30534                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30535                                  ;$P_Sim_Exit:				;AN000;
 30536                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30537                                  	; 31/03/2023
 30538 0000492A B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30539                                  $P_Sim_Exit0:				;AN000;
 30540 0000492D E888FC                  	call	$P_Fill_Result		;AN000;
 30541 00004930 5F                      	pop	di			;AN000;
 30542 00004931 5A                      	pop	dx			;AN000;
 30543 00004932 5B                      	pop	bx			;AN000;
 30544 00004933 58                      	pop	ax			;AN000;
 30545 00004934 C3                      	retn				;AN000;
 30546                                  
 30547                                  ;***********************************************************************
 30548                                  ; $P_String_Comp:
 30549                                  ;
 30550                                  ; Function:  Compare two string
 30551                                  ;
 30552                                  ; Input:     psdata_seg:SI -> 1st string
 30553                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 30554                                  ;	     ES:BX -> CONTROL block
 30555                                  ;
 30556                                  ; Output:    CY = 1 if not match
 30557                                  ;
 30558                                  ; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
 30559                                  ;
 30560                                  ; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
 30561                                  ;***********************************************************************
 30562                                  
 30563                                  	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30564                                  
 30565                                  $P_String_Comp:
 30566 00004935 50                      	push	ax			;AN000;
 30567 00004936 55                      	push	bp			;AN000;
 30568 00004937 52                      	push	dx			;AN000;
 30569 00004938 56                      	push	si			;AN000;
 30570 00004939 B202                    	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
 30571                                  $P_SCOM_Loop:				;AN000;
 30572 0000493B 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 30573 0000493E E89704                  	call	$P_Chk_DBCS		;AN000; DBCS ?
 30574 00004941 723C                    	jc	short $P_SCOM00		;AN000; yes,DBCS
 30575                                  
 30576 00004943 E811FE                  	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 30577                                  	
 30578 00004946 2EF606[3986]08          	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
 30579                                  					;AC034; keyword search ?
 30580 0000494C 740D                    	jz	short $P_SCOM04		;AN000;
 30581                                  
 30582                                  	;cmp	al,'=' ; 3Dh
 30583 0000494E 3C3D                    	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
 30584 00004950 751F                    	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 30585                                  
 30586 00004952 26807E0100              	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
 30587 00004957 7562                    	jne	short $P_SCOM_Differ	;AN021;
 30588                                  
 30589 00004959 EB13                    	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list
 30590                                  
 30591                                  $P_SCOM04:				;AN000;
 30592 0000495B 2EF606[3986]10          	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
 30593                                  					;AC034; switch search ?
 30594 00004961 740E                    	jz	short $P_SCOM03		;AN000;
 30595                                  
 30596 00004963 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
 30597 00004965 750A                    	jne	short $P_SCOM03		;AN000; continue compares
 30598                                  
 30599 00004967 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
 30600 0000496C 754D                    	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 30601                                  
 30602                                  $P_SCOM05:				;AN000;   found a match
 30603 0000496E 46                      	inc	si			;AN000; si points to just after "=" or ":"
 30604 0000496F EB58                    	jmp	short $P_SCOM_Same	;AN000; exit
 30605                                  
 30606                                  $P_SCOM03:				;AN000;
 30607 00004971 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 30608 00004975 751D                    	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 30609                                  
 30610 00004977 08C0                    	or	al,al			;AN000; end of line
 30611 00004979 744E                    	jz	short $P_SCOM_Same	;AN000; if so, exit
 30612                                  
 30613 0000497B 46                      	inc	si			;AN000; update operand pointer
 30614 0000497C 45                      	inc	bp			;AN000;    and synonym pointer
 30615 0000497D EB13                    	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 30616                                  
 30617                                  $P_SCOM00:				;AN000; Here al is DBCS leading byte
 30618 0000497F 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 30619 00004983 7536                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different
 30620                                  
 30621 00004985 46                      	inc	si			;AN000; else, load next byte
 30622 00004986 2E8A04                  	mov	al,[cs:si]		;AN000; and
 30623 00004989 45                      	inc	bp			;AN000;
 30624 0000498A 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 30625 0000498E 752B                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too
 30626                                  
 30627 00004990 46                      	inc	si			;AN000; else update operand pointer
 30628 00004991 45                      	inc	bp			;AN000; 	and synonym pointer
 30629                                  $P_SCOM01:				;AN000;
 30630 00004992 EBA7                    	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 30631                                  
 30632                                  $P_SCOM_Differ0:			;AN000;
 30633 00004994 2EF606[3986]40          	test	byte [cs:$P_Flags2],$P_SW ; 40h 
 30634                                  	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
 30635 0000499A 740E                    	jz	short $P_not_applicable	;AN000;(tm10)
 30636                                  
 30637                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 30638                                  	;;test	word [es:bx+2],20h	;AN000;(tm10)
 30639                                  	; 03/04/2023
 30640 0000499C 26F6470220              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary	
 30641 000049A1 7407                    	jz	short $P_not_applicable	;AN000;(tm10)
 30642                                  
 30643 000049A3 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
 30644 000049A8 741F                    	je	short $P_SCOM_Same	;AN025;(tm10)
 30645                                  
 30646                                  $P_not_applicable:			;AN000;(tm10)
 30647                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 30648                                  	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
 30649                                  	; 03/04/2023
 30650 000049AA 26F60710                	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 30651 000049AE 740B                    	jz	short $P_SCOM_Differ	;AN000; if no, say different.
 30652                                  
 30653 000049B0 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
 30654 000049B2 750A                    	jne	short $P_SCOM02		;AN000;    subseqently
 30655                                  
 30656 000049B4 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
 30657                                  	;jne	short $P_SCOM_Differ	;AN000; if no, say different
 30658                                  	;jmp	short $P_SCOM_Same	;AN000; else, say same
 30659                                  	; 01/04/2023
 30660 000049B9 740E                    	je	short $P_SCOM_Same
 30661                                  $P_SCOM_Differ:
 30662 000049BB F9                      	stc
 30663 000049BC EB10                    	jmp	short $P_SCOM_Exit
 30664                                  
 30665                                  $P_SCOM02:				;AN000;
 30666 000049BE 3C00                    	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
 30667 000049C0 75F9                    	jne	short $P_SCOM_Differ	;AN000;
 30668                                  
 30669                                  	;cmp	byte [es:bp],':'
 30670 000049C2 26807E003A              	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
 30671                                  	;je	short $p_SCOM_Same	;AN000; else, say same
 30672                                  	; 01/04/2023
 30673 000049C7 75F2                    	jne	short $P_SCOM_Differ
 30674                                  ;$P_SCOM_Differ: 			;AN000;
 30675                                  	;stc				;AN000; indicate not found
 30676                                  	;jmp	short $P_SCOM_Exit	;AN000;
 30677                                  
 30678                                  $P_SCOM_Same:				;AN000;
 30679 000049C9 2E8936[3C86]            	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
 30680                                  	; 01/04/2023
 30681                                  	;clc
 30682                                  	; cf = 0			;AN000; indicate found
 30683                                  $P_SCOM_Exit:				;AN000;
 30684 000049CE 5E                      	pop	si			;AN000;
 30685 000049CF 5A                      	pop	dx			;AN000;
 30686 000049D0 5D                      	pop	bp			;AN000;
 30687 000049D1 58                      	pop	ax			;AN000;
 30688 000049D2 C3                      	retn				;AN000;
 30689                                  
 30690                                  ;***********************************************************************
 30691                                  ; $P_Date_Format
 30692                                  ;
 30693                                  ; Function:  Convert a date string to DOS date format for int 21h
 30694                                  ;	     with format validation.
 30695                                  ;
 30696                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30697                                  ;	     ES:BX -> CONTROL block
 30698                                  ;
 30699                                  ; Output:    None
 30700                                  ;
 30701                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
 30702                                  ;
 30703                                  ; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
 30704                                  ;***********************************************************************
 30705                                  
 30706                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30707                                  
 30708                                  $P_Date_Format:
 30709 000049D3 50                      	push	ax			;AN000;
 30710 000049D4 51                      	push	cx			;AN000;
 30711 000049D5 52                      	push	dx			;AN000;
 30712 000049D6 56                      	push	si			;AN000;
 30713 000049D7 53                      	push	bx			;AN000;
 30714 000049D8 56                      	push	si			;AN000;
 30715 000049D9 E89F00                  	call	$P_Set_CDI		;AN000; set country dependent information before process
 30716                                  	; 03/04/2023
 30717                                  	;pop	si			;AN000;
 30718                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 30719                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 30720                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 30721 000049DC 31F6                    	xor	si,si
 30722 000049DE 2E8936[EB86]            	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
 30723 000049E3 2E8936[ED86]            	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
 30724                                  	;mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
 30725 000049E8 5E                      	pop	si
 30726 000049E9 E8A900                  	call	$P_Get_DecNum		;AN000; get 1st number
 30727 000049EC 7218                    	jc	short $P_DateF_Err0	;AN000;-----------------------+
 30728 000049EE 2EA3[EB86]              	mov	[cs:$P_1st_Val],ax	;AC034;			      |
 30729 000049F2 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 30730 000049F4 741A                    	jz	short $P_DateF_YMD	;AN000; 		      |
 30731 000049F6 E89C00                  	call	$P_Get_DecNum		;AN000; get 2nd number	      |
 30732 000049F9 726D                    	jc	short $P_DateF_Error	;AN000; 		      |
 30733 000049FB 2EA3[ED86]              	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
 30734 000049FF 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 30735 00004A01 740D                    	jz	short $P_DateF_YMD	;AN000; 		      |
 30736 00004A03 E88F00                  	call	$P_Get_DecNum		;AN000; get 3rd number	      |
 30737                                  $P_DateF_Err0:				;AN000; Bridge	  <-----------+
 30738 00004A06 7260                    	jc	short $P_DateF_Error	;AN000;
 30739 00004A08 2EA3[EF86]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 30740 00004A0C 08DB                    	or	bl,bl			;AN000; end of line ?
 30741 00004A0E 7558                    	jnz	short $P_DateF_Error	;AN000;
 30742                                  $P_DateF_YMD:				;AN000;
 30743 00004A10 2E8B1E[C986]            	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
 30744                                  	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
 30745 00004A15 83FB02                  	cmp	bx,$P_Date_YMD ; 2	;AN000;
 30746 00004A18 7422                    	je	short $P_DateF00	;AN000;
 30747 00004A1A 2EA1[EB86]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 30748 00004A1E 08E4                    	or	ah,ah			;AN000;
 30749 00004A20 7546                    	jnz	short $P_DateF_Error	;AN000;
 30750 00004A22 88C1                    	mov	cl,al			;AN000; set month
 30751 00004A24 2EA1[ED86]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 30752 00004A28 08E4                    	or	ah,ah			;AN000; if overflow, error.
 30753 00004A2A 753C                    	jnz	short $P_DateF_Error	;AN000;
 30754 00004A2C 88C5                    	mov	ch,al			;AN000; set date
 30755 00004A2E 2E8B16[EF86]            	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
 30756 00004A33 83FB01                  	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
 30757 00004A36 7502                    	jne	short $P_DateF01	;AN000; if it is DMY
 30758 00004A38 86E9                    	xchg	ch,cl			;AN000;  then swap M <-> D
 30759                                  $P_DateF01:				;AN000;
 30760 00004A3A EB19                    	jmp	short $P_DateF02	;AN000;
 30761                                  $P_DateF00:				;AN000; / here format = YMD
 30762 00004A3C 2E8B16[EB86]            	mov	dx,[cs:$P_1st_Val]	;AC034; set year
 30763 00004A41 2EA1[ED86]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 30764 00004A45 08E4                    	or	ah,ah			;AN000; if overflow, error
 30765 00004A47 751F                    	jnz	short $P_DateF_Error	;AN000;
 30766                                  
 30767 00004A49 88C1                    	mov	cl,al			;AN000; set month
 30768 00004A4B 2EA1[EF86]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 30769 00004A4F 08E4                    	or	ah,ah			;AN000; if overflow, error
 30770 00004A51 7515                    	jnz	short $P_DateF_Error	;AN000;
 30771 00004A53 88C5                    	mov	ch,al			;AN000; set date
 30772                                  $P_DateF02:				;AN000;
 30773 00004A55 83FA64                  	cmp	dx,100			;AN000; year is less that 100 ?
 30774 00004A58 7304                    	jae	short $P_DateF03	;AN000;
 30775 00004A5A 81C26C07                	add	dx,1900 		;AN000; set year 19xx
 30776                                  $P_DateF03:				;AN000;
 30777 00004A5E 5B                      	pop	bx			;AN000; recover CONTROL block
 30778 00004A5F 5E                      	pop	si			;AN000; recover string pointer
 30779                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 30780                                  	;mov	al,$P_Date_F ; 7	;AN000;   result
 30781                                  	; 03/04/2023
 30782 00004A60 B807FF                  	mov	ax,($P_No_Tag<<8)+$P_Date_F
 30783 00004A63 E852FB                  	call	$P_Fill_Result		;AN000;        buffer
 30784 00004A66 EB0F                    	jmp	short $P_Date_Format_Exit
 30785                                  					;AN000;	to Date
 30786                                  $P_DateF_Error: 			;AN000;
 30787 00004A68 5B                      	pop	bx			;AN000; recover CONTROL block
 30788 00004A69 5E                      	pop	si			;AN000; recover string pointer
 30789                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 30790                                  	;mov	al,$P_String ; 3	;AN000;   result
 30791                                  	; 03/04/2023
 30792 00004A6A B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30793 00004A6D E848FB                  	call	$P_Fill_Result		;AN000; 	buffer
 30794                                  					;AN000; to string
 30795 00004A70 2EC706[2D86]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 30796                                  					;AC034; indicate syntax error
 30797                                  $P_Date_Format_Exit:			;AN000;
 30798 00004A77 5A                      	pop	dx			;AN000;
 30799 00004A78 59                      	pop	cx			;AN000;
 30800 00004A79 58                      	pop	ax			;AN000;
 30801 00004A7A C3                      	retn				;AN000;
 30802                                  
 30803                                  ;***********************************************************************
 30804                                  ; $P_Set_CDI:
 30805                                  ;
 30806                                  ; Function: Read CDI from DOS if it has not been read yet
 30807                                  ;
 30808                                  ; Input:    None
 30809                                  ;
 30810                                  ; Output:   psdata_seg:SI -> CDI
 30811                                  ;
 30812                                  ; Use:	INT 21h w/ AH = 38h
 30813                                  ;***********************************************************************
 30814                                  
 30815                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30816                                  $P_Set_CDI:
 30817                                  	; 18/04/2023
 30818 00004A7B 8D36[C986]              	lea	si,$P_Country_Info	;AC034;
 30819                                  	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
 30820 00004A7F 2E833CFF                	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
 30821                                  					;AN000; already read ?
 30822                                  	;je	short $P_Read_CDI	;AN000;
 30823                                  	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
 30824                                  	; 03/04/2023
 30825 00004A83 750F                    	jne	short $P_Set_CDI_Exit
 30826                                  $P_Read_CDI:				;AN000; else read CDI thru DOS
 30827 00004A85 1E                      	push	ds			;AN000;
 30828 00004A86 52                      	push	dx			;AN000;
 30829 00004A87 50                      	push	ax			;AN000;
 30830 00004A88 0E                      	push	cs			;AC023;
 30831 00004A89 1F                      	pop	ds			;AN000; set segment register
 30832                                  	;mov	ax,3800h
 30833 00004A8A B80038                  	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
 30834 00004A8D 89F2                    	mov	dx,si			;AN000; set offset of CDI in local data area
 30835 00004A8F CD21                    	int	21h			;AN000;
 30836 00004A91 58                      	pop	ax			;AN000;
 30837 00004A92 5A                      	pop	dx			;AN000;
 30838 00004A93 1F                      	pop	ds			;AN000;
 30839                                  $P_Set_CDI_Exit:			;AN000;
 30840 00004A94 C3                      	retn				;AN000;
 30841                                  
 30842                                  ;***********************************************************************
 30843                                  ; $P_Get_DecNum:
 30844                                  ;
 30845                                  ; Function:  Read a chcrater code from psdata_seg:SI until specified delimiter
 30846                                  ;	     or NULL encountered. And make a decimal number.
 30847                                  ;
 30848                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30849                                  ;
 30850                                  ; Output:    BL = delimiter code or NULL
 30851                                  ;	     AX = Decimal number
 30852                                  ;	     SI advanced to the next number
 30853                                  ;	     CY = 1 : Syntax error, AL = Latest examineed number
 30854                                  ;
 30855                                  ; Use:	$P_0099
 30856                                  ;***********************************************************************
 30857                                  
 30858                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30859                                  $P_Get_DecNum:
 30860 00004A95 51                      	push	cx			;AN000;
 30861 00004A96 52                      	push	dx			;AN000;
 30862 00004A97 31C9                    	xor	cx,cx			;AN000; cx will have final value
 30863                                  $P_GetNum_Loop: 			;AN000;
 30864 00004A99 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 30865 00004A9C 08C0                    	or	al,al			;AN000; end of line ?
 30866 00004A9E 7438                    	jz	short $P_GetNum00	;AN000; if yes, exit
 30867 00004AA0 2E803E[C886]00          	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
 30868 00004AA6 740B                    	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023
 30869                                  
 30870                                  ; Determine which delimiter(s) to check for. Colon & period  or period only
 30871                                  	;cmp	bl,$P_colon_period
 30872 00004AA8 80FB01                  	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
 30873 00004AAB 750E                    	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period
 30874                                  
 30875 00004AAD 3C3A                    	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
 30876 00004AAF 742B                    	je	short $P_GetNum01	;AN032; ;yes, exit
 30877                                  
 30878                                  	; 03/04/2023
 30879 00004AB1 EB08                    	jmp	short $P_Do_Time_Delim1
 30880                                  ;$P_Do_Time_Delim1:			;AN000;
 30881                                  	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
 30882                                  	;je	short $P_GetNum01	;AC023; yes, exit
 30883                                  	;
 30884                                  	;jmp	short $P_Neither_Delims ;AN023;
 30885                                  
 30886                                  $P_Do_Date_Delims:			;AN000;
 30887                                  ;Regardless of the date delimiter character specified in the country
 30888                                  ;dependent information, check for the presence of any one of these
 30889                                  ;three field delimiters: "-", "/", or ".".
 30890 00004AB3 3C2D                    	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
 30891 00004AB5 7425                    	je	short $P_GetNum01	;AN020;if yes, exit
 30892                                  
 30893 00004AB7 3C2F                    	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
 30894 00004AB9 7421                    	je	short $P_GetNum01	;AN020;if yes, exit
 30895                                  
 30896                                  $P_Do_Time_Delim1:  ; 03/04/2023
 30897 00004ABB 3C2E                    	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
 30898 00004ABD 741D                    	je	short $P_GetNum01	;AN000; if yes, exit
 30899                                  
 30900                                  $P_Neither_Delims:			;AN023;
 30901 00004ABF E804FE                  	call	$P_0099 		;AN000; convert it to binary
 30902 00004AC2 721C                    	jc	short $P_GetNum_Exit	;AN000; if error exit
 30903                                  
 30904 00004AC4 B400                    	mov	ah,0			;AN000;
 30905 00004AC6 91                      	xchg	ax,cx			;AN000;
 30906 00004AC7 BA0A00                  	mov	dx,10			;AN000;
 30907 00004ACA F7E2                    	mul	dx			;AN000; ax = ax * 10
 30908 00004ACC 09D2                    	or	dx,dx			;AN000; overflow
 30909 00004ACE 750F                    	jnz	short $P_GetNum02	;AN000; then exit
 30910                                  
 30911 00004AD0 01C8                    	add	ax,cx			;AN000;
 30912 00004AD2 720C                    	jc	short $P_GetNum_Exit	;AN000;
 30913                                  
 30914 00004AD4 91                      	xchg	ax,cx			;AN000;
 30915 00004AD5 46                      	inc	si			;AN000;
 30916 00004AD6 EBC1                    	jmp	short $P_GetNum_Loop	;AN000;
 30917                                  
 30918                                  $P_GetNum00:				;AN000;
 30919 00004AD8 88C3                    	mov	bl,al			;AN000; set bl to NULL
 30920                                  	;03/04/2023
 30921                                  	; cf=0
 30922                                  	;clc				;AN000; indicate no error
 30923 00004ADA EB04                    	jmp	short $P_GetNum_Exit	;AN000;
 30924                                  
 30925                                  $P_GetNum01:				;AN000;
 30926 00004ADC 46                      	inc	si			;AN000; si points to next number
 30927                                  	;03/04/2023
 30928                                  	; cf=0
 30929                                  	;clc				;AN000; indicate no error
 30930 00004ADD EB01                    	jmp	short $P_GetNum_Exit	;AN000;
 30931                                  
 30932                                  $P_GetNum02:				;AN000;
 30933 00004ADF F9                      	stc				;AN000; indicate error
 30934                                  $P_GetNum_Exit: 			;AN000;
 30935 00004AE0 89C8                    	mov	ax,cx			;AN000;return value
 30936 00004AE2 5A                      	pop	dx			;AN000;
 30937 00004AE3 59                      	pop	cx			;AN000;
 30938 00004AE4 C3                      	retn				;AN000;
 30939                                  
 30940                                  ;***********************************************************************
 30941                                  ; $P_Time_Format
 30942                                  ;
 30943                                  ; Function:  Convert a time string to DOS time format for int 21h
 30944                                  ;	     with format validation.
 30945                                  ;
 30946                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30947                                  ;	     ES:BX -> CONTROL block
 30948                                  ;
 30949                                  ; Output:    None
 30950                                  ;
 30951                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
 30952                                  ;
 30953                                  ; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
 30954                                  ;	$P_3rd_Val(RW), $P_4th_Val(RW)
 30955                                  ;***********************************************************************
 30956                                  
 30957                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30958                                  
 30959                                  $P_Time_Format:				;AN000;
 30960 00004AE5 50                      	push	ax			;AN000;
 30961 00004AE6 51                      	push	cx			;AN000;
 30962 00004AE7 52                      	push	dx			;AN000;
 30963 00004AE8 56                      	push	si			;AN000;
 30964 00004AE9 53                      	push	bx			;AN000;
 30965 00004AEA 56                      	push	si			;AN000;
 30966 00004AEB E88DFF                  	call	$P_Set_CDI		;AN000; Set country independent
 30967                                  					; information before process
 30968                                  	;test	byte [cs:si+11h], 1
 30969 00004AEE 2EF6441001              	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
 30970                                  					;AN000; 24 hour system
 30971 00004AF3 5E                      	pop	si			;AN000;
 30972 00004AF4 7503                    	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
 30973 00004AF6 E8F800                  	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
 30974                                  $P_TimeF00:				;AN000;
 30975                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 30976                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 30977                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 30978                                  	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
 30979                                  	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
 30980                                  	; 03/04/2023
 30981 00004AF9 31DB                    	xor	bx,bx
 30982 00004AFB 2E891E[EB86]            	mov	[cs:$P_1st_Val],bx ; 0
 30983 00004B00 2E891E[ED86]            	mov	[cs:$P_2nd_Val],bx ; 0
 30984 00004B05 2E891E[EF86]            	mov	[cs:$P_3rd_Val],bx ; 0
 30985 00004B0A 2E891E[F186]            	mov	[cs:$P_4th_Val],bx ; 0
 30986                                  	;inc	bl
 30987                                  	;mov	[cs:$P_Got_Time],bl ; 1
 30988                                  
 30989                                  	;mov	bl,$P_colon_period
 30990                                  	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
 30991                                  					; delimiters between hours,
 30992                                  					;  minutes,seconds
 30993                                  	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
 30994 00004B0F FEC3                    	inc	bl ; bl = 1
 30995 00004B11 2E881E[C886]            	mov	[cs:$P_Got_Time],bl ; 1
 30996                                  	;
 30997 00004B16 E87CFF                  	call	$P_Get_DecNum		;AN000; get 1st number
 30998 00004B19 725D                    	jc	short $P_TimeF_Err0	;AN000;
 30999 00004B1B 2EA3[EB86]              	mov	[cs:$P_1st_Val],ax	;AC034;
 31000 00004B1F 08DB                    	or	bl,bl			;AN000; end of line ?
 31001 00004B21 745F                    	jz	short $P_TimeF_Rlt	;AN000;
 31002 00004B23 E86FFF                  	call	$P_Get_DecNum		;AN000; get 2nd number
 31003 00004B26 7250                    	jc	short $P_TimeF_Err0	;AC038; if OK
 31004 00004B28 2EA3[ED86]              	mov	[cs:$P_2nd_Val],ax	;AC034;
 31005 00004B2C 08DB                    	or	bl,bl			;AN000; end of line ?
 31006 00004B2E 7452                    	jz	short $P_TimeF_Rlt	;AN000;
 31007 00004B30 B302                    	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
 31008 00004B32 E860FF                  	call	$P_Get_DecNum		;AN000; get 3rd number
 31009 00004B35 7241                    	jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
 31010 00004B37 2EA3[EF86]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31011 00004B3B 08DB                    	or	bl,bl			;AN000; end of line ?
 31012 00004B3D 7536                    	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
 31013                                  					;AN039;   GO TO 4TH NUMBER
 31014                                  	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
 31015 00004B3F 2EF606[3886]02          	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
 31016                                  					;AN039;    BEEN REPEATED?
 31017 00004B45 753B                    	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
 31018                                  					;AN039;   the end of line
 31019                                  					;AN039; no, time has not been repeated
 31020 00004B47 2E8B36[2F86]            	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
 31021                                  					;AN039;   in command line
 31022 00004B4C 807CFF2C                	cmp	byte [si-1],$P_Comma ; ','
 31023                                  					;AN039; look at delimiter
 31024                                  					;AN039;   from command line
 31025 00004B50 7530                    	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
 31026                                  					;AN039;  really end of line
 31027                                  					;AN039; is comma before hundredths,
 31028                                  					;AN039;   redo TIME
 31029 00004B52 C644FF2E                	mov	byte [si-1],$P_Period ; '.' 
 31030                                  					;AN039; change that ambiguous
 31031                                  					;AN039;    comma to a decimal point
 31032                                  					;AN039;     parse can understand
 31033 00004B56 2EC706[3886]0000        	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
 31034                                  	;or	byte [cs:$P_Flags1],$P_Time_Again
 31035 00004B5D 2E800E[3886]02          	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
 31036                                  					;AN039; is being repeated
 31037 00004B63 2E8B0E[C286]            	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
 31038 00004B68 2E8B26[C486]            	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
 31039                                  					;AN039;   OF STACK FROM SP
 31040 00004B6D 2E8B36[C686]            	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
 31041                                  					;AN039;   PARSE POINTER FROM SI
 31042 00004B72 E911F8                  	jmp	$P_Redo_Time		;AN039; go try TIME again
 31043                                  $P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
 31044 00004B75 E81DFF                  	call	$P_Get_DecNum		;AN000; get 4th number
 31045                                  $P_TimeF_Err0:				;AN000; Bridge
 31046 00004B78 725E                    	jc	short $P_TimeF_Error	;AN000;
 31047                                  	;
 31048 00004B7A 2EA3[F186]              	mov	[cs:$P_4th_Val],ax	;AC034;
 31049 00004B7E 08DB                    	or	bl,bl			;AN000; After hundredth, no data allowed
 31050 00004B80 7556                    	jnz	short $P_TimeF_Error	;AN000; if some, then error
 31051                                  $P_TimeF_Rlt:				;AN000;
 31052 00004B82 2EA1[EB86]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31053 00004B86 08E4                    	or	ah,ah			;AN000; if overflow then error
 31054 00004B88 754E                    	jnz	short $P_TimeF_Err	;AN000;
 31055                                  	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
 31056 00004B8A 2EF606[3886]01          	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
 31057 00004B90 7408                    	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
 31058                                  					;since "AM" was specified,
 31059 00004B92 3C0C                    	cmp	al,12			;AN038: if hour specified as later than noon
 31060 00004B94 7742                    	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
 31061 00004B96 7502                    	jne	short $P_Time_notAM	;AN038; for noon exactly,
 31062 00004B98 30C0                    	xor	al,al			;AN038; set hour = zero
 31063                                  $P_Time_notAM:				;AN038;
 31064                                  	;test	byte [cs:$P_Flags2],$P_Time12
 31065 00004B9A 2EF606[3986]04          	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
 31066 00004BA0 740C                    	jz	short $P_TimeSkip00	;AN000; then
 31067 00004BA2 3C0C                    	cmp	al,12			;AN038; if 12:00 o'clock already
 31068 00004BA4 7408                    	je	short $P_TimeSkip00	;AN038; it is PM already
 31069 00004BA6 040C                    	add	al,12			;AN000; add 12 hours to make it afternoon
 31070 00004BA8 722E                    	jc	short $P_TimeF_Err	;AN000; if overflow then error
 31071 00004BAA 3C18                    	cmp	al,24			;AN038; after adding 12, now cannot be >24
 31072 00004BAC 772A                    	ja	short $P_TimeF_Err	;AN038; if too big, error
 31073                                  $P_TimeSkip00:				;AN000;
 31074 00004BAE 88C2                    	mov	dl,al			;AN000; set hour
 31075 00004BB0 2EA1[ED86]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31076 00004BB4 08E4                    	or	ah,ah			;AN000; if overflow then error
 31077 00004BB6 7520                    	jnz	short $P_TimeF_Err	;AN000;
 31078 00004BB8 88C6                    	mov	dh,al			;AN000; set minute
 31079 00004BBA 2EA1[EF86]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31080 00004BBE 08E4                    	or	ah,ah			;AN000; if overflow then error
 31081 00004BC0 7516                    	jnz	short $P_TimeF_Err	;AN000;
 31082 00004BC2 88C1                    	mov	cl,al			;AN000; set second
 31083 00004BC4 2EA1[F186]              	mov	ax,[cs:$P_4th_Val]	;AC034;
 31084 00004BC8 08E4                    	or	ah,ah			;AN000; if overflow then error
 31085 00004BCA 750C                    	jnz	short $P_TimeF_Err	;AN000;
 31086 00004BCC 88C5                    	mov	ch,al			;AN000; set hundredth
 31087 00004BCE 5B                      	pop	bx			;AN000; recover CONTROL block
 31088 00004BCF 5E                      	pop	si			;AN000; recover string pointer
 31089                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31090                                  	;mov	al,$P_Time_F ; 8 	;AN000;   result
 31091                                  	; 03/04/2023
 31092 00004BD0 B808FF                  	mov	ax,($P_No_Tag<<8)+$P_Time_F
 31093 00004BD3 E8E2F9                  	call	$P_Fill_Result		;AN000;        buffer
 31094 00004BD6 EB0F                    	jmp	short $P_Time_Format_Exit
 31095                                  					;AN000; to time
 31096                                  $P_TimeF_Error: 			;AN000;
 31097                                  $P_TimeF_Err:				;AN000;
 31098 00004BD8 5B                      	pop	bx			;AN000; recover CONTROL block
 31099 00004BD9 5E                      	pop	si			;AN000; recover string pointer
 31100                                  	;mov	ah,$P_No_Tag		;AN000; set
 31101                                  	;mov	al,$P_String		;AN000;     result
 31102                                  	; 03/04/2023
 31103 00004BDA B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31104 00004BDD E8D8F9                  	call	$P_Fill_Result		;AN000; 	  buffer
 31105                                  					;AN000; to string
 31106 00004BE0 2EC706[2D86]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9	
 31107                                  					;AC034; return syntax error
 31108                                  $P_Time_Format_Exit:			;AN000;
 31109 00004BE7 2EC606[C886]00          	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
 31110 00004BED 5A                      	pop	dx			;AN000;
 31111 00004BEE 59                      	pop	cx			;AN000;
 31112 00004BEF 58                      	pop	ax			;AN000;
 31113 00004BF0 C3                      	retn
 31114                                  
 31115                                  ;***********************************************************************
 31116                                  ; $P_Time_2412:
 31117                                  ;
 31118                                  ; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
 31119                                  ;
 31120                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31121                                  ;
 31122                                  ; Output:    Set $P_Time12 flag when the string is terminated by "p"
 31123                                  ;	     or "pm"
 31124                                  ;
 31125                                  ; Vars:  $P_Flags(W)
 31126                                  ;***********************************************************************
 31127                                  
 31128                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31129                                  
 31130                                  $P_Time_2412:				;AN000;
 31131 00004BF1 50                      	push	ax			;AN000;
 31132 00004BF2 56                      	push	si			;AN000;
 31133                                  $P_T12_Loop:				;AN000;
 31134 00004BF3 2E8A04                  	mov	al,[cs:si]		;AN000; Move
 31135 00004BF6 46                      	inc	si			;AN000;     si
 31136 00004BF7 08C0                    	or	al,al			;AN000;       to
 31137 00004BF9 75F8                    	jnz	short $P_T12_Loop	;AN000; 	end of string
 31138                                  
 31139 00004BFB 2E8A44FE                	mov	al,[cs:si-2]		;AN000; get char just before NULL
 31140                                  	;or	al,20h
 31141 00004BFF 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31142 00004C01 3C70                    	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
 31143 00004C03 7425                    	je	short $P_T1200		;AN000;
 31144                                  
 31145 00004C05 3C61                    	cmp	al,"a"                  ;AN000; only "a" of "am" ?
 31146 00004C07 7413                    	je	short $P_T1201		;AN000;
 31147                                  
 31148 00004C09 3C6D                    	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
 31149 00004C0B 751A                    	jne	short $P_T12_Exit	;AN000;
 31150                                  
 31151 00004C0D 4E                      	dec	si			;AN000;
 31152 00004C0E 2E8A44FE                	mov	al,[cs:si-2]		;AN000;
 31153                                  	;or	al,20h
 31154 00004C12 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31155 00004C14 3C70                    	cmp	al,"p"                  ;AN000; "p" of "pm" ?
 31156 00004C16 7412                    	je	short $P_T1200		;AN000;
 31157                                  
 31158 00004C18 3C61                    	cmp	al,"a"                  ;AN000; "a" of "am" ?
 31159                                  	;je	short $P_T1201		;AN000; go process "a"
 31160                                  	;jmp	short $P_T12_Exit	;AN000; no special chars found
 31161                                  	; 05/04/2023
 31162 00004C1A 750B                    	jne	short $P_T12_Exit
 31163                                  
 31164                                  ;$P_T1200:				;AN000; "P" found
 31165                                  	;;or	byte [cs:$P_Flags2],$P_Time12
 31166                                  	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31167                                  	;jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31168                                  
 31169                                  $P_T1201:				;AN000; "A" found
 31170                                  	;or	byte [cs:$P_Flags1],$P_Time12AM
 31171 00004C1C 2E800E[3886]01          	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
 31172                                  $P_Tclr_chr:				;AN038;
 31173 00004C22 2EC644FE00              	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
 31174                                  $P_T12_Exit:				;AN000;
 31175 00004C27 5E                      	pop	si			;AN000;
 31176 00004C28 58                      	pop	ax			;AN000;
 31177 00004C29 C3                      	retn				;AN000;
 31178                                  
 31179                                  	; 05/04/2023
 31180                                  $P_T1200:				;AN000; "P" found
 31181                                  	;or	byte [cs:$P_Flags2],$P_Time12
 31182 00004C2A 2E800E[3986]04          	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31183 00004C30 EBF0                    	jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31184                                  
 31185                                  ;***********************************************************************
 31186                                  ; $P_File_Format;
 31187                                  ;
 31188                                  ; Function:  Check if the input string is valid file spec format.
 31189                                  ;	     And set the result buffer.
 31190                                  ;
 31191                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31192                                  ;	     ES:BX -> CONTROL block
 31193                                  ;
 31194                                  ; Output:    None
 31195                                  ;
 31196                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
 31197                                  ;
 31198                                  ; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
 31199                                  ;	$P_SaveSI_Cmpx(R)
 31200                                  ;***********************************************************************
 31201                                  
 31202                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31203                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
 31204                                  $P_File_Format:
 31205 00004C32 50                      	push	ax			;AN000;
 31206 00004C33 57                      	push	di			;AN000;
 31207 00004C34 56                      	push	si			;AN000;
 31208 00004C35 2E8B3E[3A86]            	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
 31209 00004C3A 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31210 00004C3D 08C0                    	or	al,al			;AN000; end of line ?
 31211 00004C3F 7413                    	je	short $P_FileF_Err	;AN000; if yes, error exit
 31212 00004C41 E85D00                  	call	$P_FileSp_Chk		;AN000; else, check if file special character
 31213 00004C44 7523                    	jne	short $P_FileF03	;AN000; if yes,
 31214 00004C46 2EC606[0687]01          	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
 31215                                  					;AN033;AC034;; set error flag- bad char.
 31216 00004C4C 5E                      	pop	si			;AN033;
 31217 00004C4D 2EC60400                	mov	byte [cs:si],$P_NULL	;AN033;
 31218 00004C51 5F                      	pop	di			;AN033;
 31219 00004C52 EB3E                    	jmp	short $P_FileF02	;AN033;
 31220                                  $P_FileF_Err:				;AN000;
 31221 00004C54 5E                      	pop	si			;AN000;
 31222 00004C55 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000;
 31223 00004C59 5F                      	pop	di			;AN000;
 31224                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 31225                                  	;test	word [es:bx],1		;AN000; is it optional ?
 31226 00004C5A 26F60701                	test	byte [es:bx],$P_Optional ; 1
 31227 00004C5E 7532                    	jnz	short $P_FileF02	;AN000;
 31228 00004C60 2EC706[2D86]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 31229                                  	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
 31230 00004C67 EB29                    	jmp	short $P_FileF02	;AN000;
 31231                                  $P_FileF03:				;AN000;
 31232 00004C69 58                      	pop	ax			;AN000; discard save si
 31233 00004C6A 56                      	push	si			;AN000; save new si
 31234                                  $P_FileF_Loop1: 			;AN000;
 31235 00004C6B 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 31236 00004C6E 08C0                    	or	al,al			;AN000; end of line ?
 31237 00004C70 741E                    	jz	short $P_FileF_RLT	;AN000;
 31238 00004C72 E82C00                  	call	$P_FileSp_Chk		;AN000; File special character ?
 31239 00004C75 740B                    	jz	short $P_FileF00	;AN000;
 31240 00004C77 E85E01                  	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
 31241 00004C7A 7302                    	jnc	short $P_FileF01	;AN000;
 31242 00004C7C 47                      	inc	di			;AN000; if yes, skip next byte
 31243 00004C7D 46                      	inc	si			;AN000;
 31244                                  $P_FileF01:				;AN000;
 31245 00004C7E 47                      	inc	di			;AN000;
 31246 00004C7F 46                      	inc	si			;AN000;
 31247 00004C80 EBE9                    	jmp	short $P_FileF_Loop1	;AN000;
 31248                                  $P_FileF00:				;AN000;
 31249 00004C82 2EA2[3386]              	mov	[cs:$P_Terminator],al	;AC034;
 31250 00004C86 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; update end of string
 31251 00004C8A 47                      	inc	di			;AN000;
 31252 00004C8B 2E893E[2F86]            	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
 31253                                  $P_FileF_RLT:				;AN000;
 31254 00004C90 5E                      	pop	si			;AN000;
 31255 00004C91 5F                      	pop	di			;AN000;
 31256                                  $P_FileF02:				;AN000;
 31257 00004C92 58                      	pop	ax			;AN000; (tm14)
 31258                                  	;;test	ax,200h
 31259                                  	;test	ax,$P_File_Spc		;AN000; (tm14)
 31260                                  	; 05/04/2023
 31261 00004C93 F6C402                  	test	ah,($P_File_Spc>>8)
 31262 00004C96 7408                    	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
 31263 00004C98 50                      	push	ax			;AN000; (tm14)
 31264                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31265                                  	;mov	al,$P_File_Spec ; 5 	;AN000;    result
 31266                                  	; 05/04/2023
 31267 00004C99 B805FF                  	mov	ax,($P_No_Tag<<8)+$P_File_Spec
 31268 00004C9C E819F9                  	call	$P_Fill_Result		;AN000; 	buffer to file spec
 31269 00004C9F 58                      	pop	ax			;AN000;
 31270                                  $P_Drv_Only_Exit:			;AN000; (tm14)
 31271 00004CA0 C3                      	retn				;AN000;
 31272                                  
 31273                                  ;***********************************************************************
 31274                                  ; $P_FileSp_Chk
 31275                                  ;
 31276                                  ; Function:  Check if the input byte is one of file special characters
 31277                                  ;
 31278                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31279                                  ;	     AL = character code to be examineed
 31280                                  ;
 31281                                  ; Output:    ZF = 1 , AL is one of special characters
 31282                                  ;***********************************************************************
 31283                                  
 31284                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31285                                  $P_FileSp_Chk:
 31286 00004CA1 53                      	push	bx			;AN000;
 31287 00004CA2 51                      	push	cx			;AN000;
 31288                                  	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
 31289 00004CA3 8D1E[FD86]              	lea	bx,$P_FileSp_Char
 31290 00004CA7 B90900                  	mov	cx,$P_FileSp_Len ; 9
 31291                                  	;mov	cx,9			;AN000; load length of it
 31292                                  $P_FileSp_Loop: 			;AN000;
 31293 00004CAA 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 31294 00004CAD 7404                    	je	short $P_FileSp_Exit	;AN000;
 31295 00004CAF 43                      	inc	bx			;AN000;
 31296 00004CB0 E2F8                    	loop	$P_FileSp_Loop		;AN000;
 31297 00004CB2 41                      	inc	cx			;AN000; reset ZF
 31298                                  $P_FileSp_Exit: 			;AN000;
 31299 00004CB3 59                      	pop	cx			;AN000;
 31300 00004CB4 5B                      	pop	bx			;AN000;
 31301 00004CB5 C3                      	retn				;AN000;
 31302                                  
 31303                                  ;***********************************************************************
 31304                                  ; $P_Drive_Format;
 31305                                  ;
 31306                                  ; Function:  Check if the input string is valid drive only format.
 31307                                  ;	     And set the result buffer.
 31308                                  ;
 31309                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31310                                  ;	     ES:BX -> CONTROL block
 31311                                  ;
 31312                                  ; Output:    None
 31313                                  ;
 31314                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS
 31315                                  ;
 31316                                  ; Vars: $P_RC(W)
 31317                                  ;***********************************************************************
 31318                                  
 31319                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31320                                  $P_Drive_Format:
 31321 00004CB6 50                      	push	ax			;AN000;
 31322 00004CB7 52                      	push	dx			;AN000;
 31323 00004CB8 2E8A04                  	mov	al,[cs:si]		;AN000;
 31324 00004CBB 08C0                    	or	al,al			;AN000; if null string
 31325 00004CBD 7436                    	jz	short $P_Drv_Exit	;AN000; do nothing
 31326 00004CBF E81601                  	call	$P_Chk_DBCS		;AN000; is it leading byte ?
 31327 00004CC2 722A                    	jc	short $P_Drv_Err	;AN000;
 31328                                  	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
 31329 00004CC4 2E837C013A              	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
 31330 00004CC9 740D                    	je	short $P_DrvF00		;AN000;
 31331                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31332                                  	;test	word [es:bx],10h	;AN000; colon can be ignored?
 31333 00004CCB 26F60710                	test	byte [es:bx],$P_Ig_Colon ; 10h
 31334 00004CCF 741D                    	jz	short $P_Drv_Err	;AN000;
 31335 00004CD1 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
 31336 00004CD6 7516                    	jne	short $P_Drv_Err	;AN000;
 31337                                  $P_DrvF00:				;AN000;
 31338 00004CD8 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case
 31339 00004CDA 3C61                    	cmp	al,"a" ; 61h            ;AN000; drive letter must
 31340 00004CDC 7210                    	jb	short $P_Drv_Err	;AN000; in range of
 31341 00004CDE 3C7A                    	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
 31342 00004CE0 770C                    	ja	short $P_Drv_Err	;AN000; if no, error
 31343 00004CE2 2C60                    	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
 31344 00004CE4 88C2                    	mov	dl,al			;AN000; set
 31345                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
 31346                                  	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
 31347                                  	; 05/04/2023
 31348 00004CE6 B806FF                  	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
 31349 00004CE9 E8CCF8                  	call	$P_Fill_Result		;AN000; 	       to drive
 31350 00004CEC EB07                    	jmp	short $P_Drv_Exit	;AN000;
 31351                                  $P_Drv_Err:				;AN000;
 31352 00004CEE 2EC706[2D86]0900        	mov	word [cs:$P_RC],$P_Syntax
 31353                                  	;mov	word [cs:$P_RC],9	;AC034;
 31354                                  $P_Drv_Exit:				;AN000;
 31355 00004CF5 5A                      	pop	dx			;AN000;
 31356 00004CF6 58                      	pop	ax			;AN000;
 31357 00004CF7 C3                      	retn				;AN000;
 31358                                  
 31359                                  ;***********************************************************************
 31360                                  ; $P_Skip_Delim;
 31361                                  ;
 31362                                  ; Function: Skip delimiters specified in the PARMS list, white space
 31363                                  ;	    and comma.
 31364                                  ;
 31365                                  ; Input:    DS:SI -> Command String
 31366                                  ;	    ES:DI -> Parameter List
 31367                                  ;
 31368                                  ; Output:   CY = 1 if the end of line encounterd
 31369                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 31370                                  ;	    AL = Last examineed character
 31371                                  ;
 31372                                  ; Use:	    $P_Chk_EOL, $P_Chk_Delim,
 31373                                  ;
 31374                                  ; Vars:     $P_Flags(R)
 31375                                  ;***********************************************************************
 31376                                  
 31377                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31378                                  
 31379                                  $P_Skip_Delim:				;AN000;
 31380                                  $P_Skip_Delim_Loop:			;AN000;
 31381 00004CF8 AC                      	lodsb				;AN000;
 31382 00004CF9 E81E00                  	call	$P_Chk_EOL		;AN000; is it EOL character ?
 31383 00004CFC 7416                    	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 31384                                  
 31385 00004CFE E84B00                  	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
 31386 00004D01 7514                    	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off
 31387                                  
 31388 00004D03 2EF606[3986]20          	test	byte [cs:$P_Flags2],$P_Extra
 31389                                  	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
 31390 00004D09 74ED                    	jz	short $P_Skip_Delim_Loop
 31391                                  					;AN000; if no, loop
 31392 00004D0B 2EF606[3986]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ
 31393                                  	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
 31394                                  	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 31395                                  	;dec	si ; *			;AN000; backup si for next call (tm08)
 31396                                  	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
 31397                                  	; 05/04/2023
 31398 00004D11 7505                    	jnz	short $P_Skip_Delim_Exit ; cf = 0
 31399                                  $P_Exit_At_Extra:			;AN000;
 31400                                  	; cf = 0
 31401                                  	;clc				;AN000; indicate extra delim
 31402 00004D13 C3                      	retn				;AN000;
 31403                                  
 31404                                  $P_Skip_Delim_CY:			;AN000;
 31405 00004D14 F9                      	stc				;AN000; indicate EOL
 31406 00004D15 EB01                    	jmp	short $P_Skip_Delim_Exit
 31407                                  					;AN000;
 31408                                  $P_Skip_Delim_NCY:			;AN000;
 31409 00004D17 F8                      	clc				;AN000; indicate non delim
 31410                                  $P_Skip_Delim_Exit:			;AN000; in this case, need
 31411 00004D18 4E                      	dec	si ; *			;AN000;  backup index pointer
 31412 00004D19 C3                      	retn				;AN000;
 31413                                  	; 05/04/2023
 31414                                  ;$P_Exit_At_Extra:			;AN000;
 31415                                  	;clc				;AN000; indicate extra delim
 31416                                  	;retn				;AN000;
 31417                                  
 31418                                  ;***********************************************************************
 31419                                  ; $P_Chk_EOL;
 31420                                  ;
 31421                                  ; Function: Check if AL is one of End of Line characters.
 31422                                  ;
 31423                                  ; Input:    AL = character code
 31424                                  ;	    ES:DI -> Parameter List
 31425                                  ;
 31426                                  ; Output:   ZF = 1 if one of End of Line characters
 31427                                  ;***********************************************************************
 31428                                  
 31429                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31430                                  
 31431                                  $P_Chk_EOL:
 31432 00004D1A 53                      	push	bx			;AN000;
 31433 00004D1B 51                      	push	cx			;AN000;
 31434 00004D1C 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
 31435 00004D1E 7429                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31436 00004D20 3C00                    	cmp	al,$P_NULL ; 0		;AN000; zero ?
 31437 00004D22 7425                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31438 00004D24 26807D0202              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
 31439                                  	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
 31440 00004D29 721E                    	jb	short $P_Chk_EOL_Exit 	;AN000;
 31441 00004D2B 31DB                    	xor	bx,bx			;AN000;
 31442 00004D2D 268A5D03                	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 31443                                  	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
 31444 00004D31 83C304                  	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
 31445 00004D34 26803900                	cmp	byte [es:bx+di],$P_I_Use_Default
 31446                                  	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
 31447 00004D38 740D                    	je	short $P_Chk_EOL_NZ	;AN000;
 31448 00004D3A 31C9                    	xor	cx,cx			;AN000; Get number of extra chcracter
 31449 00004D3C 268A09                  	mov	cl,[es:bx+di]		;AN000;
 31450                                  $P_Chk_EOL_Loop:			;AN000;
 31451 00004D3F 43                      	inc	bx			;AN000;
 31452 00004D40 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 31453 00004D43 7404                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31454 00004D45 E2F8                    	loop	$P_Chk_EOL_Loop 	;AN000;
 31455                                  $P_Chk_EOL_NZ:				;AN000;
 31456 00004D47 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
 31457                                  $P_Chk_EOL_Exit:			;AN000;
 31458 00004D49 59                      	pop	cx			;AN000;
 31459 00004D4A 5B                      	pop	bx			;AN000;
 31460 00004D4B C3                      	retn				;AN000;
 31461                                  
 31462                                  ;***********************************************************************
 31463                                  ; $P_Chk_Delim;
 31464                                  ;
 31465                                  ; Function: Check if AL is one of delimiter characters.
 31466                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 31467                                  ;	    blanks.
 31468                                  ;
 31469                                  ; Input:    AL = character code
 31470                                  ;	    DS:SI -> Next Character
 31471                                  ;	    ES:DI -> Parameter List
 31472                                  ;
 31473                                  ; Output:   ZF = 1 if one of delimiter characters
 31474                                  ;	    SI points to the next character
 31475                                  ; Vars:  $P_Terminator(W), $P_Flags(W)
 31476                                  ;***********************************************************************
 31477                                  
 31478                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31479                                  
 31480                                  $P_Chk_Delim:
 31481 00004D4C 53                      	push	bx			;AN000;
 31482 00004D4D 51                      	push	cx			;AN000;
 31483 00004D4E 2EC606[3386]20          	mov	byte [cs:$P_Terminator],$P_Space ; 20h
 31484                                  					;AC034; Assume terminated by space
 31485 00004D54 2E8026[3986]DF          	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
 31486                                  					;AC034;
 31487 00004D5A 3C20                    	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
 31488 00004D5C 7436                    	je	short $P_Chk_Delim_Exit	;AN000;
 31489                                  
 31490 00004D5E 3C09                    	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
 31491 00004D60 7432                    	je	short $P_Chk_Delim_Exit	;AN000;
 31492                                  
 31493 00004D62 3C2C                    	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
 31494 00004D64 7431                    	je	short $P_Chk_Delim_Exit0
 31495                                  					;AN000;
 31496                                  $P_Chk_Delim00: 			;AN000;
 31497 00004D66 3C20                    	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
 31498 00004D68 750C                    	jne	short $P_Chk_Delim01	;AN000;
 31499 00004D6A 803C20                  	cmp	byte [si],20h ; $P_DBSP2
 31500                                  					;AN000; 2nd byte of DBCS Space ?
 31501 00004D6D 7507                    	jne	short $P_Chk_Delim01	;AN000;
 31502 00004D6F B020                    	mov	al,$P_Space ; 20h	;AN000;
 31503 00004D71 46                      	inc	si			;AN000; make si point to next character
 31504 00004D72 38C0                    	cmp	al,al			;AN000; Set ZF
 31505 00004D74 EB1E                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 31506                                  
 31507                                  $P_Chk_Delim01: 			;AN000;
 31508                                  	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
 31509 00004D76 26807D0201              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
 31510                                  	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
 31511 00004D7B 7217                    	jb	short $P_Chk_Delim_Exit	;AN000;
 31512                                  
 31513 00004D7D 31C9                    	xor	cx,cx			;AN000;
 31514 00004D7F 268A4D03                	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 31515                                  	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
 31516 00004D83 09C9                    	or	cx,cx			;AN000; No extra Delim character ?
 31517 00004D85 740B                    	jz	short $P_Chk_Delim_NZ	;AN000;
 31518                                  
 31519 00004D87 BB0300                  	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 31520                                  $P_Chk_Delim_Loop:			;AN000;
 31521 00004D8A 43                      	inc	bx			;AN000;
 31522 00004D8B 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 31523 00004D8E 7407                    	je	short $P_Chk_Delim_Exit0
 31524                                  					;AN000;
 31525 00004D90 E2F8                    	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 31526                                  
 31527                                  $P_Chk_Delim_NZ:			;AN000;
 31528 00004D92 3C20                    	cmp	al,$P_Space ; 20h	;AN000; reset ZF
 31529                                  $P_Chk_Delim_Exit:			;AN000;
 31530 00004D94 59                      	pop	cx			;AN000;
 31531 00004D95 5B                      	pop	bx			;AN000;
 31532 00004D96 C3                      	retn				;AN000;
 31533                                  
 31534                                  $P_Chk_Delim_Exit0:			;AN000;
 31535 00004D97 2EA2[3386]              	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
 31536 00004D9B 2EF606[3986]01          	test	byte [cs:$P_Flags2],$P_equ
 31537                                  	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
 31538 00004DA1 7506                    	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 31539                                  
 31540 00004DA3 2E800E[3986]20          	or	byte [cs:$P_Flags2],$P_Extra ; 20h
 31541                                  	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
 31542                                  $P_No_Set_Extra:			;AN027;
 31543 00004DA9 38C0                    	cmp	al,al			;AN000; set ZF
 31544 00004DAB EBE7                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 31545                                  
 31546                                  ;***********************************************************************
 31547                                  ; $P_Chk_Switch;
 31548                                  ;
 31549                                  ; Function: Check if AL is the switch character not in first position of
 31550                                  ;	    $P_STRING_BUF
 31551                                  ;
 31552                                  ; Input:    AL = character code
 31553                                  ;	    BX = current pointer within $P_String_Buf
 31554                                  ;	    SI =>next char on command line (following the one in AL)
 31555                                  ;
 31556                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 31557                                  ;		 position, and has no chance of being part of a date string,
 31558                                  ;		 i.e. should be treated as a delimiter.
 31559                                  ;
 31560                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 31561                                  ;		 position, or is a slash but may be part of a date string, i.e.
 31562                                  ;		 should not be treated as a delimiter.
 31563                                  ;
 31564                                  ; Vars:  $P_Terminator(W)
 31565                                  ;
 31566                                  ; Use:	 $P_0099
 31567                                  ;***********************************************************************
 31568                                  
 31569                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31570                                  
 31571                                  $P_Chk_Switch:
 31572                                  	; 18/04/2023
 31573 00004DAD 8D2E[4286]              	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
 31574                                  
 31575 00004DB1 39EB                    	cmp	bx,bp			;AN000;
 31576 00004DB3 7418                    	je	short $P_STRUC_L2	;AN000;
 31577                                  
 31578 00004DB5 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 31579 00004DB7 7512                    	jne	short $P_STRUC_L5	;AN000;
 31580                                  
 31581 00004DB9 F9                      	stc				;AN020;not in first position and is slash, now see if might be in date string
 31582 00004DBA 50                      	push	ax			;AN020;save input char
 31583 00004DBB 2E8A47FF                	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
 31584 00004DBF E804FB                  	call	$P_0099 		;AN020;return carry set if not numeric
 31585 00004DC2 7205                    	jc	short $P_STRUC_L7	;AN000;
 31586                                  
 31587 00004DC4 8A04                    	mov	al,[si]			;AN020;AL=char after the current char
 31588 00004DC6 E8FDFA                  	call	$P_0099			;AN020;return carry set if not numeric
 31589                                  $P_STRUC_L7:				;AN000;
 31590 00004DC9 58                      	pop	ax			;AN020;restore AL to input char
 31591                                  	;jmp	short $P_STRUC_L1	;AN000;
 31592                                  	; 18/04/2023
 31593 00004DCA C3                      	retn
 31594                                  
 31595                                  $P_STRUC_L5:				;AN000;
 31596 00004DCB F8                      	clc				;AN020;not a slash
 31597                                  	;jmp	short $P_STRUC_L1	;AN000;
 31598                                  	 ;18/04/2023
 31599 00004DCC C3                      	retn
 31600                                  
 31601                                  $P_STRUC_L2:				;AN000;
 31602 00004DCD 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 31603                                  	;jne	short $P_STRUC_L12	;AN000;
 31604                                  	; 18/04/2023
 31605 00004DCF 75FA                    	jne	short $P_STRUC_L5
 31606                                  
 31607 00004DD1 2E800E[3986]40          	or	byte [cs:$P_Flags2],$P_SW
 31608                                  	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
 31609                                  	; 18/04/2023
 31610                                  ;$P_STRUC_L12:				;AN000;
 31611                                  	;clc				;AN020;CF=0 indicating first char
 31612                                  $P_STRUC_L1:				;AN000;
 31613 00004DD7 C3                      	retn				;AN000;
 31614                                  
 31615                                  ;**************************************************************************
 31616                                  ; $P_Chk_DBCS:
 31617                                  ;
 31618                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 31619                                  ;
 31620                                  ;  Input:
 31621                                  ;	  AL	= Code to be examineed
 31622                                  ;
 31623                                  ;  Output:
 31624                                  ;	  If CF is on then a lead byte of DBCS
 31625                                  ;
 31626                                  ; Use: INT 21h w/AH=63
 31627                                  ;
 31628                                  ; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
 31629                                  ;***************************************************************************
 31630                                  
 31631                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31632                                  
 31633                                  $P_Chk_DBCS:
 31634 00004DD8 1E                      	push	ds			;AN000;
 31635 00004DD9 56                      	push	si			;AN000;
 31636 00004DDA 53                      	push	bx			;AN000; (tm11)
 31637 00004DDB 2E833E[3686]00          	cmp	word [cs:$P_DBCSEV_SEG],0
 31638                                  					;AC034; ALREADY SET ?
 31639 00004DE1 7527                    	jne	short $P_DBCS00		;AN000;
 31640 00004DE3 50                      	push	ax			;AN000;
 31641 00004DE4 1E                      	push	ds			;AN000; (tm11)
 31642 00004DE5 51                      	push	cx			;AN000;
 31643 00004DE6 52                      	push	dx			;AN000;
 31644 00004DE7 57                      	push	di			;AN000;
 31645 00004DE8 55                      	push	bp			;AN000;
 31646 00004DE9 06                      	push	es			;AN000;
 31647 00004DEA 31F6                    	xor	si,si			;AN000;
 31648 00004DEC 8EDE                    	mov	ds,si			;AN000;
 31649                                  	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
 31650 00004DEE B80063                  	mov	ax,6300h
 31651 00004DF1 CD21                    	int	21h			;AN000;
 31652 00004DF3 8CDB                    	mov	bx,ds			;AN000; (tm11)
 31653 00004DF5 09DB                    	or	bx,bx			;AN000; (tm11)
 31654 00004DF7 07                      	pop	es			;AN000;
 31655 00004DF8 5D                      	pop	bp			;AN000;
 31656 00004DF9 5F                      	pop	di			;AN000;
 31657 00004DFA 5A                      	pop	dx			;AN000;
 31658 00004DFB 59                      	pop	cx			;AN000;
 31659 00004DFC 1F                      	pop	ds			;AN000; (tm11)
 31660 00004DFD 58                      	pop	ax			;AN000;
 31661 00004DFE 7429                    	jz	short $P_NON_DBCS	;AN000;
 31662                                  $P_DBCS02:				;AN000;
 31663 00004E00 2E8936[3486]            	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
 31664 00004E05 2E891E[3686]            	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 31665                                  $P_DBCS00:				;AN000;
 31666 00004E0A 2E8B36[3486]            	mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
 31667 00004E0F 2E8E1E[3686]            	mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
 31668                                  $P_DBCS_LOOP:				;AN000;
 31669 00004E14 833C00                  	cmp	word [si],0 		;AN000; zero vector ?
 31670 00004E17 7410                    	je	short $P_NON_DBCS	;AN000; then exit
 31671 00004E19 3A04                    	cmp	al,[si] 		;AN000;
 31672 00004E1B 7208                    	jb	short $P_DBCS01		;AN000; Check if AL is in
 31673 00004E1D 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 31674 00004E20 7703                    	ja	short $P_DBCS01		;AN000;      the vector
 31675 00004E22 F9                      	stc				;AN000; if yes, indicate DBCS and exit
 31676 00004E23 EB04                    	jmp	short $P_DBCS_EXIT	;AN000;
 31677                                  $P_DBCS01:				;AN000;
 31678 00004E25 46                      	inc	si			;AC035; add '2' to
 31679 00004E26 46                      	inc	si			;AC035;  SI reg
 31680                                  					;AN000; get next vector
 31681 00004E27 EBEB                    	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found
 31682                                  
 31683                                  $P_NON_DBCS:				;AN000;
 31684                                  	; 18/04/2023
 31685                                  	; cf=0
 31686                                  	;clc				;AN000; indicate SBCS
 31687                                  $P_DBCS_EXIT:				;AN000;
 31688 00004E29 5B                      	pop	bx			;AN000; (tm11)
 31689 00004E2A 5E                      	pop	si			;AN000;
 31690 00004E2B 1F                      	pop	ds			;AN000;
 31691 00004E2C C3                      	retn				;AN000;
 31692                                  
 31693                                  ;============================================================================
 31694                                  ; TPARSE.ASM, MSDOS 6.0, 1991
 31695                                  ;============================================================================
 31696                                  ; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31697                                  
 31698                                  ; ****************************************************************
 31699                                  ; *
 31700                                  ; * ROUTINE:	 CMD_PARSE
 31701                                  ; *
 31702                                  ; * FUNCTION:	 Interface for transient COMMAND to invoke
 31703                                  ; *		 SYSPARSE.
 31704                                  ; *
 31705                                  ; * INPUT:	 inputs to SYSPARSE
 31706                                  ; *
 31707                                  ; * OUTPUT:	 outputs from SYSPARSE
 31708                                  ; *
 31709                                  ; ****************************************************************
 31710                                  
 31711                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31712                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
 31713                                  ;cmd_parse:
 31714                                  	;call	sysparse		;AN000;
 31715                                  	;retn				;AN000;
 31716                                  	; 06/04/2023
 31717                                  	;jmp	sysparse
 31718                                  
 31719                                  append_parse:
 31720 00004E2D E840F5                  	call	sysparse		;AN010;
 31721 00004E30 CB                      	retf				;AN010;
 31722                                  
 31723                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31724                                  %if 0
 31725                                  
 31726                                  ;============================================================================
 31727                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 31728                                  ;============================================================================
 31729                                  ; 30/09/2018 - Retro DOS v3.0
 31730                                  
 31731                                  ; BREAK	<Message Printing Routine>
 31732                                  
 31733                                  ;
 31734                                  ;	MSDOS V3.00 PRINT
 31735                                  ;
 31736                                  ;	Message Printing Routine
 31737                                  ;
 31738                                  
 31739                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 31740                                  ;
 31741                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 31742                                  ;
 31743                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 31744                                  ;
 31745                                  ; Characters are output to PFHandle according to the
 31746                                  ; specifications contained in the Control String.
 31747                                  ;
 31748                                  ; The conversion characters are as follow:
 31749                                  ;
 31750                                  ;               %c - output the next argument as a character
 31751                                  ;               %s - output the next argument as a string
 31752                                  ;               %x - output the next argument as a hexidecimal number
 31753                                  ;                    using abcedf
 31754                                  ;               %X - output the next argument as a hexidecimal number
 31755                                  ;                    using ABCDEF
 31756                                  ;               %d - output the next argument as a decimal number
 31757                                  ;
 31758                                  ;
 31759                                  ; Other format specifiers that may precede the conversion character are:
 31760                                  ;
 31761                                  ;               - (minus sign) - causes the field to be left-adjusted
 31762                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 31763                                  ;               n - digit specifing the minimum field width (default to 1)
 31764                                  ;               L - specifing a long integer
 31765                                  ;
 31766                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 31767                                  ;   to an argument list.
 31768                                  ;
 31769                                  ;   ____________________
 31770                                  ;   |   Ret Addr       |      <= SP
 31771                                  ;   --------------------
 31772                                  ;   |  Ptr to Arg List |
 31773                                  ;   --------------------
 31774                                  ;
 31775                                  ;   And the argument list contains the following:
 31776                                  ;
 31777                                  ;       String_ptr                  (a pointer to the control string)
 31778                                  ;       Arg 1
 31779                                  ;       Arg 2
 31780                                  ;         .
 31781                                  ;         .
 31782                                  ;         .
 31783                                  ;       Arg n-1
 31784                                  ;       Arg n
 31785                                  ;
 31786                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 31787                                  ;   or character.
 31788                                  ;
 31789                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 31790                                  
 31791                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 31792                                  
 31793                                  ; =============== S U B	R O U T	I N E =======================================
 31794                                  
 31795                                  PRINTF_INIT:
 31796                                  	call	STD_PRINTF
 31797                                  	retf
 31798                                  
 31799                                  ; =============== S U B	R O U T	I N E =======================================
 31800                                  
 31801                                  PRINTF_CRLF:
 31802                                  	call	STD_PRINTF
 31803                                  	;call	CRLF2
 31804                                  	;retn
 31805                                  	; 07/04/2023
 31806                                  	jmp	CRLF2
 31807                                  
 31808                                  ; =============== S U B	R O U T	I N E =======================================
 31809                                  
 31810                                  STD_EPRINTF:
 31811                                  	mov	word [cs:PRINTF_HANDLE],2
 31812                                  	jmp	short new_printf
 31813                                  
 31814                                  ; =============== S U B	R O U T	I N E =======================================
 31815                                  
 31816                                  STD_PRINTF:
 31817                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 31818                                  
 31819                                  	mov	word [cs:PRINTF_HANDLE],1
 31820                                  NEW_PRINTF:				;Save the callers' registers
 31821                                  	cld
 31822                                  	push	dx
 31823                                  	push	bp
 31824                                  	mov	bp,sp
 31825                                  	push	cx
 31826                                  	push	bx
 31827                                  	push	ax
 31828                                  	push	di
 31829                                  	push	si
 31830                                  	push	es
 31831                                  	push	ds
 31832                                  	push	cs
 31833                                  	pop	es		;ES points to Printf segment
 31834                                  	mov	di,PRINTF_BUF	;DI points to the output buffer
 31835                                  	mov	bp,[bp+2]  ; dx ;BP points to the argument list
 31836                                  	;mov	si,[ds:bp+0]	;SI points to the control string
 31837                                  	mov	si,[ds:bp] ; bp
 31838                                  	add	bp,2
 31839                                  	xor	bx,bx
 31840                                  	call	CLEAR_FLAGS	; initialize the world
 31841                                  
 31842                                  GET_CHAR:
 31843                                  	lodsb			;Get a character
 31844                                  	cmp	al,'%'		;Is it a conversion specifier?
 31845                                  	jz	short CONV_CHAR	;Yes - find out which one
 31846                                  	or	al,al		;Is it the end of the control string?
 31847                                  	jz	short PRINTF_DONE ;Yes - then we're done
 31848                                  PRINTF_PERCENT:				
 31849                                  	call	OUTCHR		;Otherwise store the character
 31850                                  	jmp	short GET_CHAR	;And go get another
 31851                                  
 31852                                  PRINTF_DONE:
 31853                                  	call	FLUSH
 31854                                  	pop	ds
 31855                                  	pop	es
 31856                                  	pop	si
 31857                                  	pop	di
 31858                                  	pop	ax
 31859                                  	pop	bx
 31860                                  	pop	cx
 31861                                  	pop	bp
 31862                                  	pop	dx
 31863                                  	retn
 31864                                  
 31865                                  CONV_CHAR:
 31866                                  	mov	byte [cs:PRINTF_LEFT],0
 31867                                  
 31868                                  NXT_CONV_CHAR:	
 31869                                  	;Look for any format specifiers preceeding the conversion character
 31870                                  	lodsb
 31871                                  	cmp	al,'%'			;Just print the %
 31872                                  	jz	short PRINTF_PERCENT
 31873                                  	cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 31874                                  	jz	short LEFT_ADJ
 31875                                  	cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 31876                                  	jz	short CONV_CHAR
 31877                                  	cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 31878                                  	jz	short LONG_INT
 31879                                  	cmp	al,[cs:char_l]	 ; "l"		
 31880                                  	jz	short LONG_INT
 31881                                  	cmp	al,'0'			;Is it a precision specification
 31882                                  	jb	short LOOK_CONV_CHAR
 31883                                  	cmp	al,'9'
 31884                                  	ja	short LOOK_CONV_CHAR
 31885                                  	cmp	al,'0'
 31886                                  	jnz	short NOT_PAD
 31887                                  	cmp	word [cs:PRINTF_WIDTH],0
 31888                                  	jnz	short NOT_PAD
 31889                                  	mov	ah,'0'
 31890                                  	mov	[cs:PAD_CHAR],ah
 31891                                  NOT_PAD:					;Adjust decimal place on precision
 31892                                  	push	ax
 31893                                  	mov	ax,[cs:PRINTF_WIDTH]
 31894                                  	mov	cx,10
 31895                                  	mul	cx
 31896                                  	pop	dx
 31897                                  	xor	dh,dh
 31898                                  	sub	dl,'0'
 31899                                  	add	ax,dx
 31900                                  	mov	[cs:PRINTF_WIDTH],ax	;And save the total
 31901                                  	jmp	short NXT_CONV_CHAR
 31902                                  
 31903                                  LEFT_ADJ:
 31904                                  	mov	byte [cs:PRINTF_LEFT],1
 31905                                  	jmp	short NXT_CONV_CHAR
 31906                                  
 31907                                  LONG_INT:
 31908                                  	or	byte [cs:PRINTF_LONG],1
 31909                                  	jmp	short NXT_CONV_CHAR
 31910                                  
 31911                                  LOOK_CONV_CHAR:
 31912                                  	and	al,0DFh
 31913                                  	cmp	al,[cs:CHAR_X]	 ; "X"
 31914                                  	jz	short HEX_UP
 31915                                  	cmp	al,[cs:CHAR_D]	 ; "D"
 31916                                  	jz	short DECIMAL
 31917                                  	cmp	al,[cs:CHAR_C]	 ; "C"
 31918                                  	jz	short C_PUT_CHAR
 31919                                  	cmp	al,[cs:CHAR_S]	 ; "S"
 31920                                  	jz	short S_PUT_STRG
 31921                                  	call	CLEAR_FLAGS
 31922                                  	jmp	GET_CHAR
 31923                                  
 31924                                  HEX_UP:
 31925                                  	mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 31926                                  	jmp	short CONV_TO_NUM
 31927                                  DECIMAL:
 31928                                  	mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 31929                                  	jmp	short CONV_TO_NUM
 31930                                  
 31931                                  C_PUT_CHAR:
 31932                                  	call	NEXT_CHRS
 31933                                  	mov	al,dl
 31934                                  	call	OUTCHR
 31935                                  	call	CLEAR_FLAGS
 31936                                  	jmp	GET_CHAR
 31937                                  
 31938                                  S_PUT_STRG:
 31939                                  	push	si			;Save pointer to control string
 31940                                  	call	NEXT_CHRS
 31941                                  	mov	si,dx
 31942                                  S_PUT_1:
 31943                                  	mov	cx,[cs:PRINTF_WIDTH]
 31944                                  	or	cx,cx
 31945                                  	jz	short S_PUT_2
 31946                                  	cmp	byte [cs:PRINTF_LEFT],0
 31947                                  	jnz	short S_PUT_2
 31948                                  	call	PAD_STRING
 31949                                  S_PUT_2:
 31950                                  	push	si
 31951                                  S_PUT_3:
 31952                                  	lodsb
 31953                                  	or	al,al
 31954                                  	jz	short S_PUT_4
 31955                                  	call	OUTCHR			;Put it into our buffer
 31956                                  	jmp	short S_PUT_3
 31957                                  S_PUT_4:
 31958                                  	pop	si
 31959                                  	cmp	byte [cs:PRINTF_LEFT],0
 31960                                  	jz	short C_S_END
 31961                                  	mov	cx,[cs:PRINTF_WIDTH]
 31962                                  	or	cx,cx
 31963                                  	jz	short C_S_END
 31964                                  	call	PAD_STRING
 31965                                  C_S_END:
 31966                                  	pop	si			;Restore control string pointer
 31967                                  	call	CLEAR_FLAGS
 31968                                  	jmp	GET_CHAR		;Go get another character	
 31969                                  
 31970                                  
 31971                                  ; =============== S U B	R O U T	I N E =======================================
 31972                                  
 31973                                  PAD_STRING:
 31974                                  	xor	dx,dx
 31975                                  	push	si
 31976                                  
 31977                                  COUNT_LOOP:
 31978                                  	lodsb
 31979                                  	or	al,al
 31980                                  	jz	short COUNT_DONE
 31981                                  	inc	dx
 31982                                  	jmp	short COUNT_LOOP
 31983                                  
 31984                                  COUNT_DONE:
 31985                                  	pop	si
 31986                                  	sub	cx,dx
 31987                                  	jbe	short COUNT_RET
 31988                                  	call	PAD
 31989                                  
 31990                                  COUNT_RET:
 31991                                  	retn
 31992                                  
 31993                                  ; ---------------------------------------------------------------------------
 31994                                  
 31995                                  CONV_TO_NUM:
 31996                                  	call	NEXT_CHRS
 31997                                  	mov	ax,dx
 31998                                  	xor	dx,dx
 31999                                  	cmp	byte [cs:PRINTF_LONG],0 
 32000                                  			;Is this is a short or long integer?
 32001                                  	jz	short NOT_LONG_INT
 32002                                  	call	NEXT_CHRS
 32003                                  
 32004                                  NOT_LONG_INT:
 32005                                  	push	bx
 32006                                  	push	si
 32007                                  	mov	si,[cs:PRINTF_BASE]
 32008                                  	mov	cx,[cs:PRINTF_WIDTH]
 32009                                  	call	PNUM
 32010                                  	pop	si
 32011                                  	pop	bx
 32012                                  	call	PAD
 32013                                  	call	CLEAR_FLAGS
 32014                                  	jmp	GET_CHAR
 32015                                  
 32016                                  
 32017                                  ; =============== S U B	R O U T	I N E =======================================
 32018                                  
 32019                                  PNUM:
 32020                                  	dec	cx
 32021                                  	push	ax
 32022                                  	mov	ax,dx
 32023                                  	xor	dx,dx
 32024                                  	div	si
 32025                                  	mov	bx,ax
 32026                                  	pop	ax
 32027                                  	div	si
 32028                                  	xchg	bx,dx
 32029                                  	push	ax
 32030                                  	or	ax,dx
 32031                                  	pop	ax
 32032                                  	jz	short DO_PAD
 32033                                  	push	bx
 32034                                  	call	PNUM
 32035                                  	pop	bx
 32036                                  	jmp	short REM
 32037                                  
 32038                                  DO_PAD:
 32039                                  	cmp	byte [cs:PRINTF_LEFT],0
 32040                                  	jnz	short REM
 32041                                  	call	PAD
 32042                                  REM:
 32043                                  	cmp	bl,10
 32044                                  	jb	short NOT_HEX
 32045                                  	add	bx,6
 32046                                  NOT_HEX:
 32047                                  	mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 32048                                  	push	cx
 32049                                  	call	OUTCHR
 32050                                  	pop	cx
 32051                                  	retn
 32052                                  
 32053                                  ; =============== S U B	R O U T	I N E =======================================
 32054                                  
 32055                                  PAD:
 32056                                  	or	cx,cx
 32057                                  	jle	short PAD_DONE
 32058                                  	mov	al,[cs:PAD_CHAR]
 32059                                  PAD_LOOP:
 32060                                  	push	cx
 32061                                  	call	OUTCHR
 32062                                  	pop	cx
 32063                                  	loop	PAD_LOOP
 32064                                  PAD_DONE:
 32065                                  	retn
 32066                                  
 32067                                  ; =============== S U B	R O U T	I N E =======================================
 32068                                  
 32069                                  OUTCHR:
 32070                                  	stosb
 32071                                  	cmp	di,PRINTF_BUF_END ; SRCXNAME
 32072                                  	je	short FLUSH
 32073                                  OUTCHR_RETN:
 32074                                  	retn
 32075                                  
 32076                                  ; =============== S U B	R O U T	I N E =======================================
 32077                                  
 32078                                  FLUSH:
 32079                                  	mov	cx,PRINTF_BUF
 32080                                  	xchg	cx,di
 32081                                  	sub	cx,di
 32082                                  	jz	short OUTCHR_RETN
 32083                                  WRITE_CHARS:
 32084                                  	push	bx
 32085                                  	mov	bx,[cs:PRINTF_HANDLE]
 32086                                  	push	ds
 32087                                  	push	cs
 32088                                  	pop	ds
 32089                                  	mov	dx,PRINTF_BUF
 32090                                  	mov	ah,Write ; 40h
 32091                                  	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 32092                                  				; BX = file handle, CX = number	of bytes to write,
 32093                                  				; DS:DX -> buffer
 32094                                  	jnb	short FOOB2_1
 32095                                  	call	GET_EXT_ERR_NUMBER
 32096                                  	cmp	ax,6
 32097                                  	jz	short FOOB2_4
 32098                                  	jmp	short FOOB2_2
 32099                                  
 32100                                  FOOB2_1:
 32101                                  	cmp	cx,ax
 32102                                  	jz	short FOOB2_4
 32103                                  FOOB2_2:
 32104                                  	mov	bx,dx
 32105                                  	add	bx,ax
 32106                                  	cmp	byte [bx],1Ah
 32107                                  	jz	short FOOB2_4
 32108                                  	pop	ds
 32109                                  	pop	bx
 32110                                  	mov	es,[cs:RESSEG]
 32111                                  	mov	dx,NOSPACEPTR
 32112                                  	test	byte [es:PIPEFLAG],0FFh
 32113                                  	jz	short PRINT_ERR_EXIT
 32114                                  	call	PIPEOFF
 32115                                  	mov	dx,PIPEEMESPTR
 32116                                  PRINT_ERR_EXIT:	
 32117                                  	jmp	CERROR
 32118                                  
 32119                                  FOOB2_4:
 32120                                  	pop	ds
 32121                                  	pop	bx
 32122                                  	retn
 32123                                  
 32124                                  ; =============== S U B	R O U T	I N E =======================================
 32125                                  
 32126                                  NEXT_CHRS:
 32127                                  	push	si		;Save pointer to control string
 32128                                  	mov	si,bx		;Get index into argument list
 32129                                  	add	bx,2		;Increment the index
 32130                                  	mov	si,[ds:bp+si]	; Get pointer to next argument
 32131                                  	mov	dx,[si]		; Get (address of the) next argument			
 32132                                  	pop	si
 32133                                  	retn
 32134                                  
 32135                                  ; =============== S U B	R O U T	I N E =======================================
 32136                                  
 32137                                  CLEAR_FLAGS:
 32138                                  	xor	ax,ax
 32139                                  	mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 32140                                  	mov	[cs:PRINTF_LONG],al	;Reset long flag
 32141                                  	mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 32142                                  	mov	al,' '			
 32143                                  	mov	[cs:PAD_CHAR],al 	;Reset padding character
 32144                                  	retn
 32145                                  
 32146                                  ; ---------------------------------------------------------------------------
 32147                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 32148                                  
 32149                                  	; times 7 db 0
 32150                                  
 32151                                  %endif
 32152                                  
 32153                                  ;============================================================================
 32154                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 32155                                  ;============================================================================
 32156                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32157                                  
 32158                                  ; ----------------------------
 32159                                  ; MSDOS 6.0, MSGSERV.ASM, 1991
 32160                                  ; ----------------------------
 32161                                  
 32162                                  ;; Replacable parameters are described by a sublist structure
 32163                                  
 32164                                  struc $M_SUBLIST_STRUC		;;AN000;;
 32165 00000000 ??                       .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32166 00000001 ??                       .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32167 00000002 ????????                 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32168 00000006 ??                       .$M_S_ID:	resb 1		;;AN000;; n of %n
 32169 00000007 ??                       .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32170 00000008 ??                       .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32171 00000009 ??                       .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32172 0000000A ??                       .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32173                                  endstruc
 32174                                  
 32175                                  ; ---------------------------------------------------------------------------
 32176                                  ; ---------------------------------------------------------------------------
 32177                                  
 32178                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32179                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh
 32180                                  
 32181                                  Printf_Init:
 32182 00004E31 E80F00                  	call	std_printf
 32183 00004E34 CB                      	retf
 32184                                  
 32185                                  Printf_Crlf:
 32186 00004E35 E80B00                  	call	std_printf
 32187                                  	;call	CRLF2
 32188                                  	;retn
 32189                                  	; 07/04/2023
 32190 00004E38 E9BED7                  	jmp	CRLF2
 32191                                  
 32192                                  
 32193                                  ;****************************************************************
 32194                                  ;*
 32195                                  ;* ROUTINE:	STD_PRINTF/STD_EPRINTF
 32196                                  ;*
 32197                                  ;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
 32198                                  ;*		Set up substitutions if utility message.  Make
 32199                                  ;*		sure any changes to message variables in TDATA
 32200                                  ;*		are reset to avoid reloading the transient.
 32201                                  ;*
 32202                                  ;* INPUT:	Msg_Disp_Class	-  set to message class
 32203                                  ;*		Msg_Cont_Flag	-  set to control flags
 32204                                  ;*		DS	points to transient segment
 32205                                  ;*
 32206                                  ;*		if utility message:
 32207                                  ;*		DX	points to a block with message number
 32208                                  ;*			(word), number of substitutions (byte),
 32209                                  ;*			followed by substitution list if there
 32210                                  ;*			are substitutions.  If substitutions
 32211                                  ;*			are not in transient segment they must
 32212                                  ;*			be set.
 32213                                  ;*		else
 32214                                  ;*		AX	set to message number
 32215                                  ;*
 32216                                  ;* OUTPUT:	none
 32217                                  ;*
 32218                                  ;****************************************************************
 32219                                  
 32220                                  std_eprintf:
 32221 00004E3B C706[0C88]0200          	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
 32222 00004E41 EB06                    	jmp	short new_printf		;AC000;
 32223                                  
 32224                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32225                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h
 32226                                  
 32227                                  std_printf:
 32228 00004E43 C706[0C88]0100          	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT
 32229                                  
 32230                                  new_printf:
 32231 00004E49 50                      	push	ax				;AN000;save registers
 32232 00004E4A 53                      	push	bx				;AN000;
 32233 00004E4B 51                      	push	cx				;AN000;
 32234 00004E4C 06                      	push	es				;AN000;get local ES
 32235 00004E4D 1E                      	push	ds				;AN000;
 32236 00004E4E 07                      	pop	es				;AN000;
 32237 00004E4F 57                      	push	di				;AN000;
 32238 00004E50 56                      	push	si				;AN000;
 32239 00004E51 52                      	push	dx				;AN000;
 32240                                  
 32241                                  	; 07/04/2023
 32242                                  	;mov	word [print_err_flag],0		;AN000;
 32243 00004E52 31C9                    	xor	cx,cx
 32244 00004E54 890E[568E]              	mov	[print_err_flag],cx ; 0
 32245                                  
 32246 00004E58 89D6                    	mov	si,dx				;AN000;Get offset of message number
 32247 00004E5A AD                      	lodsw					;AN000;load message number
 32248 00004E5B 50                      	push	ax				;AN000;save it
 32249 00004E5C AC                      	lodsb					;AN000;get number of substitutions
 32250 00004E5D 88C1                    	mov	cl,al				;AN000;set up CX as # of subst
 32251                                  	; 07/04/2023
 32252                                  	;xor	ch,ch				;AN000;SI now points to subst list
 32253 00004E5F 58                      	pop	ax				;AN000;get message number back
 32254                                  	;cmp	cx,0				;AN000;Any substitutions?
 32255                                  	; 07/04/2023
 32256 00004E60 21C9                    	and	cx,cx
 32257 00004E62 745C                    	jz	short ready_to_print		;AN000;No - continue
 32258                                  
 32259 00004E64 BF[588E]                	mov	di,subst_buffer			;AN061; Get address of message subst buffer
 32260 00004E67 57                      	push	di				;AN061; save it
 32261 00004E68 51                      	push	cx				;AN061; save number of subst
 32262                                  
 32263                                  move_subst:
 32264 00004E69 51                      	push	cx				;AN061;save number of subst
 32265 00004E6A 89F3                    	mov	bx,si				;AN061;save start of sublist
 32266                                  	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
 32267                                  	; 07/04/2023
 32268 00004E6C B10B                    	mov	cl,parm_block_size ; 11
 32269 00004E6E F3A4                    	rep	movsb				;AN061;move sublist
 32270                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32271 00004E70 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32272                                  	;test	byte [bx+7],4			;AN061;are we doing date/time?
 32273 00004E74 7406                    	jz	short move_subst_cont 		;AN061;no - no need to reset
 32274                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
 32275                                  	;mov	word [bx+2],0			;AN061;reset original date or time to 0
 32276 00004E76 894F02                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
 32277                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32278                                  	;mov	word [bx+4],0			;AN061;
 32279 00004E79 894F04                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0
 32280                                  
 32281                                  move_subst_cont:				;AN061;
 32282 00004E7C 59                      	pop	cx				;AN061;get number of subst back
 32283 00004E7D E2EA                    	loop	move_subst			;AN061;move cx sublists
 32284                                  
 32285 00004E7F 59                      	pop	cx				;AN061;get number of subst
 32286 00004E80 50                      	push	ax				;AN061;save message number
 32287 00004E81 803E[737F]FF            	cmp	byte [msg_disp_class],util_msg_class
 32288                                  	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
 32289 00004E86 740C                    	je	short check_fix			;AN061;YES - go see if substitutions
 32290                                  	;mov	byte [msg_flag],1 ; ext_msg_class
 32291 00004E88 C606[528E]01            	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
 32292 00004E8D BF[757F]                	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
 32293 00004E90 31C0                    	xor	ax,ax				;AN061;clear ax register
 32294 00004E92 AB                      	stosw					;AN061;clear out message number
 32295 00004E93 AA                      	stosb					;AN061;clear out subst count
 32296                                  
 32297                                  check_fix:					;AN061;
 32298 00004E94 58                      	pop	ax				;AN061;get message number back
 32299 00004E95 5F                      	pop	di				;AN061;get start of sublists
 32300 00004E96 89FE                    	mov	si,di				;AN061;get into SI for msgserv
 32301 00004E98 89F3                    	mov	bx,si				;AN061;get into BX for addressing
 32302 00004E9A 51                      	push	cx				;AN061;save number of subst
 32303                                  
 32304                                  set_subst:					;AN061;store the segment of the subst
 32305 00004E9B 837F0400                	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32306                                  	;cmp	word [bx+4],0			;AN061;was it set already?
 32307 00004E9F 7509                    	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
 32308 00004EA1 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32309                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32310                                  	;test	byte [bx+7],4			;AN061;don't replace if date or time
 32311 00004EA5 7503                    	jnz	short subst_seg_set		;AN061;yes - skip it
 32312 00004EA7 8C4F04                  	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
 32313                                  	;mov	word [bx+4],cs			;AN061;set segment value
 32314                                  
 32315                                  subst_seg_set:					;AN061;
 32316 00004EAA 83C30B                  	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
 32317 00004EAD E2EC                    	loop	set_subst			;AN061;loop CX times
 32318 00004EAF 59                      	pop	cx				;AN061;get number of subst back
 32319                                  
 32320 00004EB0 89F3                    	mov	bx,si				;AN061;get start of sublist to BX
 32321 00004EB2 817F02[D08C]            	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
 32322                                  	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
 32323 00004EB7 7507                    	jne	short ready_to_print		;AN061;no - we already have address
 32324                                  	; 01/05/2023
 32325 00004EB9 8B16[D08C]              	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
 32326 00004EBD 895702                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
 32327                                  						;AN061;put it into the subst block
 32328                                  	;mov	[bx+2],dx
 32329                                  
 32330                                  ready_to_print:
 32331 00004EC0 8B1E[0C88]              	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
 32332 00004EC4 8A16[747F]              	mov	dl,[msg_cont_flag]		;AN000;set up control flag
 32333 00004EC8 8A36[737F]              	mov	dh,[msg_disp_class]		;AN000;set up display class
 32334 00004ECC C606[747F]00            	mov	byte [msg_cont_flag],0 ; no_cont_flag
 32335                                  						;AN061;reset flags to avoid
 32336 00004ED1 C606[737F]FF            	mov	byte [msg_disp_class],util_msg_class
 32337                                  	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload
 32338                                  
 32339 00004ED6 1E                      	push	ds				;AN026;
 32340 00004ED7 06                      	push	es				;AN026;
 32341                                  
 32342 00004ED8 E83702                  	call	SYSDISPMSG			;AN000;call Rod
 32343                                  
 32344 00004EDB 07                      	pop	es				;AN026; restore registers
 32345 00004EDC 1F                      	pop	ds				;AN026;
 32346                                  
 32347 00004EDD 7303                    	jnc	short print_success		;AN000; everything went okay
 32348 00004EDF A3[568E]                	mov	[print_err_flag],ax		;AN000;
 32349                                  
 32350                                  print_success:
 32351 00004EE2 5A                      	pop	dx				;AN061;restore dx
 32352 00004EE3 5E                      	pop	si				;AN000;restore registers
 32353 00004EE4 5F                      	pop	di				;AN000;
 32354 00004EE5 07                      	pop	es				;AN000;restore registers
 32355 00004EE6 59                      	pop	cx				;AN000;
 32356 00004EE7 5B                      	pop	bx				;AN000;
 32357 00004EE8 58                      	pop	ax				;AN000;
 32358 00004EE9 833E[568E]00            	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
 32359 00004EEE 7501                    	jnz	short print_err			;AN000;
 32360                                  
 32361 00004EF0 C3                      	retn					;AC000;
 32362                                  
 32363                                  print_err:
 32364 00004EF1 0E                      	push	cs
 32365 00004EF2 07                      	pop	es
 32366 00004EF3 833E[0C88]02            	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
 32367 00004EF8 7503                    	jne	short not_stderr		;AN026;no - continue
 32368 00004EFA E907B2                  	jmp	TCOMMAND			;AN026;Yes - hopless - just exit
 32369                                  
 32370                                  not_stderr:
 32371 00004EFD A1[568E]                	mov	ax,[print_err_flag]		;AN026;get extended error number back
 32372 00004F00 8E06[E08A]              	mov	es,[RESSEG]			; No, set up for error, load the
 32373                                  						;  right error msg, and jmp to cerror.
 32374 00004F04 26F606[1802]FF          	test	byte [es:PipeFlag],-1 ; 0FFh
 32375 00004F0A 7408                    	jz	short _go_to_error
 32376 00004F0C E896E0                  	call	PipeOff
 32377 00004F0F BA[D680]                	mov	dx,PIPEEMES_PTR
 32378 00004F12 EB0B                    	jmp	short print_err_exit			;AC000;
 32379                                  
 32380                                  _go_to_error:
 32381 00004F14 C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class
 32382                                  	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
 32383 00004F19 BA[757F]                	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
 32384 00004F1C A3[757F]                	mov	[extend_buf_ptr],ax		;AN000; get message number in control block
 32385                                  
 32386                                  print_err_exit: 				;AC000;
 32387 00004F1F 0E                      	push	cs
 32388 00004F20 07                      	pop	es
 32389 00004F21 E956DA                  	jmp	cerror
 32390                                  
 32391                                  ;****************************************************************
 32392                                  ;*
 32393                                  ;* ROUTINE:	TSYSLOADMSG
 32394                                  ;*
 32395                                  ;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
 32396                                  ;*		names since these routines are also used in the
 32397                                  ;*		resident.
 32398                                  ;*
 32399                                  ;* INPUT:	Inputs to SYSLOADMSG
 32400                                  ;*
 32401                                  ;* OUTPUT:	Outputs from SYSLOADMSG
 32402                                  ;*
 32403                                  ;****************************************************************
 32404                                  
 32405                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32406                                  TSYSLOADMSG:
 32407 00004F24 53                      	push	bx				;AN000;
 32408 00004F25 E80800                  	call	SYSLOADMSG			;AN000; call routine
 32409 00004F28 5B                      	pop	bx				;AN000;
 32410 00004F29 C3                      	retn					;AN000; exit
 32411                                  
 32412                                  ;****************************************************************
 32413                                  ;*
 32414                                  ;* ROUTINE:	TSYSGETMSG
 32415                                  ;*
 32416                                  ;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
 32417                                  ;*		names since these routines are also used in the
 32418                                  ;*		resident.
 32419                                  ;*
 32420                                  ;* INPUT:	Inputs to SYSGETMSG
 32421                                  ;*
 32422                                  ;* OUTPUT:	Outputs from SYSGETMSG
 32423                                  ;*
 32424                                  ;****************************************************************
 32425                                  
 32426                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32427                                  TSYSGETMSG:
 32428 00004F2A 51                      	push	cx				;AN000;
 32429 00004F2B E8B500                  	call	SYSGETMSG			;AN000; call routine
 32430 00004F2E 59                      	pop	cx				;AN000;
 32431 00004F2F C3                      	retn					;AN000; exit
 32432                                  
 32433                                  ;============================================================================
 32434                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 32435                                  ;============================================================================
 32436                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32437                                  
 32438                                  ; ---------------------------------------------------------------------------
 32439                                  ; MODULE NAME: MSGSERV.SAL
 32440                                  ;
 32441                                  ; DESCRIPTIVE NAME: Message Services SALUT file
 32442                                  ;
 32443                                  ; FUNCTION: This module incorporates all the messages services and
 32444                                  ;	    is called upon at build time to INCLUDE the code requested
 32445                                  ;	    by a utility. Code is requested using the macro MSG_SERVICES.
 32446                                  ;
 32447                                  ; ENTRY POINT: Since this a collection of subroutines, entry point is at
 32448                                  ;	    requested procedure.
 32449                                  ;
 32450                                  ; INPUT: Since this a collection of subroutines, input is dependent on
 32451                                  ;	    function requested.
 32452                                  ;
 32453                                  ; EXIT-NORMAL: In all cases, CARRY FLAG = 0
 32454                                  ;
 32455                                  ; EXIT-ERROR: In all cases, CARRY FLAG = 1
 32456                                  ;
 32457                                  ; INTERNAL REFERENCES: (list of included subroutines)
 32458                                  ;
 32459                                  ;	- SYSLOADMSG
 32460                                  ;	- SYSDISPMSG
 32461                                  ;	- SYSGETMSG
 32462                                  ;
 32463                                  ; EXTERNAL REFERENCES: None
 32464                                  ;
 32465                                  ; NOTES: At build time, some modules must be included. These are only included
 32466                                  ;	 once using assembler switches. Other logic is included at the request
 32467                                  ;	 of the utility.
 32468                                  ;
 32469                                  ;	 COMR and COMT are assembler switches to conditionally assemble code
 32470                                  ;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
 32471                                  ;	 storage and multiple EQUates.
 32472                                  ;
 32473                                  ; REVISION HISTORY: Created MAY 1987
 32474                                  ;
 32475                                  ;     Label: DOS - - Message Retriever
 32476                                  ;	     (c) Copyright 1988 Microsoft
 32477                                  ; ---------------------------------------------------------------------------
 32478                                  
 32479                                  ;	Revision History
 32480                                  ;	================
 32481                                  ;
 32482                                  ;	M007	SR	08/24/90	Fixed bug #1818 -- changed
 32483                                  ;				$M_DISPLAY_H_STRING to properly
 32484                                  ;				handle Ctrl-Z being passed
 32485                                  ;
 32486                                  ;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
 32487                                  ;				these routines are no longer assembled.
 32488                                  ;
 32489                                  ;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
 32490                                  ;				CR-LF string also gets reinitialized
 32491                                  ;				on every cycle.
 32492                                  ;
 32493                                  ;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
 32494                                  ;				& $_MSG_NUM also in SYSLOADMSG.
 32495                                  
 32496                                  ; ---------------------------------------------------------------------------
 32497                                  
 32498                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32499                                  
 32500                                  ;;; Replacable parameters are described by a sublist structure
 32501                                  ;
 32502                                  ;struc $M_SUBLIST_STRUC		;;AN000;;
 32503                                  ; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32504                                  ; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32505                                  ; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32506                                  ; .$M_S_ID:	resb 1		;;AN000;; n of %n
 32507                                  ; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32508                                  ; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32509                                  ; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32510                                  ; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32511                                  ;endstruc
 32512                                  
 32513                                  ;; Each class will be defined by this structure.
 32514                                  
 32515                                  struc $M_CLASS_ID		;;AN000;;
 32516 00000000 ??                       .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 32517 00000001 ????                     .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 32518 00000003 ??                       .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 32519                                   .size:
 32520                                  endstruc
 32521                                  
 32522                                  $M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;
 32523                                  
 32524                                  ;; Each message will be defined by this structure.
 32525                                  
 32526                                  struc $M_ID			;;AN000;;
 32527 00000000 ????                     .$M_NUM:	resw 1		;;AN000;; Message Number
 32528 00000002 ????                     .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 32529                                   .size:	
 32530                                  endstruc
 32531                                  
 32532                                  $M_ID_SZ	EQU  $M_ID.size	;;AN000;;
 32533                                  
 32534                                  ; ---------------------------
 32535                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 32536                                  ; ---------------------------
 32537                                  $M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;
 32538                                  
 32539                                  ; --------------------------- 
 32540                                  
 32541                                  ; 07/04/2023
 32542                                  $M_NUM_CLS equ 3
 32543                                  
 32544                                  ;; Resident data area definition of variables
 32545                                  
 32546                                  struc $M_RES_ADDRS			;;AN000;;
 32547 00000000 ????????                 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 32548 00000004 ????????                 .$M_EXT_FILE:	    resd 1		;;AN001;;
 32549 00000008 ????????                 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 32550 0000000C ????????                 .$M_EXT_TERM:	    resd 1		;;AN000;;
 32551 00000010 ????????                 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 32552 00000014 ????????                 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 32553 00000018 ????????                 .$M_PARSE_TERM:    resd 1		;;AN000;;
 32554 0000001C ????????                 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 32555 00000020 ????????                 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 32556 00000024 ????????                 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 32557 00000028 ????????                 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 32558 0000002C <res Ch>                 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 32559 00000038 ????????                 .$M_CLS_TERM:	    resd 1		;;AN000;;
 32560 0000003C ????????                 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 32561 00000040 ????                     .$M_HANDLE:	    resw 1 		;;AN000;;
 32562 00000042 ??                       .$M_SIZE:	    resb 1		;;AN000;;
 32563 00000043 ????                     .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 32564 00000045 ??                       .$M_CLASS:	    resb 1		;;AN004;; Saved class
 32565 00000046 ????                     .$M_RETURN_ADDR:   resw 1		;;AN000;;
 32566 00000048 ????                     .$M_MSG_NUM:	    resw 1		;;AN000;;
 32567 0000004A ????                     .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 32568 0000004C <res 40h>                .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 32569 0000008C ??                       .$M_BUF_TERM:	    resb 1		;;AN000;;
 32570                                   .size:
 32571                                  endstruc				;;AN000;;
 32572                                  
 32573                                  $M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;
 32574                                  
 32575                                  ;; Important fields of the Get Country Information call
 32576                                  
 32577                                  struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 32578 00000000 <res 4Ch>                .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
 32579                                  					;;AN000;; Go past first part of struc
 32580 0000004C ????                     .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 32581 0000004E ??????????               .$M_CURR_SEPARA:   resb 5		;;AN000;;
 32582 00000053 ????                     .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 32583 00000055 ????                     .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 32584 00000057 ????                     .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 32585 00000059 ????                     .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 32586 0000005B ??                       .$M_CURR_FORMAT:   resb 1		;;AN000;;
 32587 0000005C ??                       .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 32588 0000005D ??                       .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
 32589                                  endstruc				;;AN000;;
 32590                                  
 32591                                  ; ---------------------------------------------------------------------------
 32592                                  
 32593                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32594                                  ;;
 32595                                  ;;	PROC NAME: SYSLOADMSG
 32596                                  ;;
 32597                                  ;;	FUNCTION:
 32598                                  ;;	INPUTS:
 32599                                  ;;
 32600                                  ;;	OUTPUTS:
 32601                                  ;;
 32602                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32603                                  
 32604                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32605                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h
 32606                                  
 32607                                  SYSLOADMSG:
 32608 00004F30 50                      	push	ax				;;AN000;
 32609 00004F31 53                      	push	bx				;;AN000;
 32610 00004F32 52                      	push	dx				;;AN000;
 32611 00004F33 06                      	push	es				;;AN000;
 32612 00004F34 57                      	push	di				;;AN000;
 32613 00004F35 31C9                    	xor	cx,cx				;;AN000;  Reset to zero
 32614 00004F37 8EC1                    	mov	es,cx				;;AN000;
 32615 00004F39 31FF                    	xor	di,di				;;AN000;
 32616 00004F3B B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 32617 00004F3E B200                    	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
 32618 00004F40 CD2F                    	int	2Fh				;;AN000;; Private interface
 32619                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32620                                  		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
 32621                                  		; Return: ES:DI -> error table
 32622                                  	
 32623 00004F42 8C06[1187]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
 32624                                  	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
 32625 00004F46 893E[0F87]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
 32626                                  	;mov	[$M_RT+8],di			;;AN000;;
 32627                                  
 32628 00004F4A B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 32629 00004F4D B202                    	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
 32630 00004F4F CD2F                    	int	2Fh				;;AN000;; Private interface
 32631                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32632                                  		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
 32633                                  		; ES:DI -> error table
 32634                                  
 32635 00004F51 8C06[1987]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
 32636                                  	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
 32637 00004F55 893E[1787]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
 32638                                  	;mov	[$M_RT+16],di			;;AN000;;
 32639                                  
 32640 00004F59 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 32641 00004F5C B204                    	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
 32642 00004F5E CD2F                    	int	2Fh				;;AN000;; Private interface
 32643                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32644                                  		; DL = subfunction - get ??? error table
 32645                                  		; ES:DI -> error table
 32646                                  
 32647 00004F60 8C06[2987]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
 32648                                  	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
 32649 00004F64 893E[2787]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
 32650                                  	;mov	[$M_RT+32],di			;;AN000;;
 32651                                  
 32652 00004F68 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 32653 00004F6B B206                    	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
 32654 00004F6D CD2F                    	int	2Fh					     ;;AN001;; Private interface
 32655                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32656                                  		; DL = subfunction - get ??? error table
 32657                                  		; ES:DI -> error table
 32658                                  
 32659 00004F6F 8C06[0D87]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
 32660                                  	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
 32661 00004F73 893E[0B87]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
 32662                                  	;mov	[$M_RT+4],di			;;AN001;;
 32663                                  
 32664 00004F77 E8D42F                  	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
 32665                                  						;;AN000;;
 32666 00004F7A 8C06[0987]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
 32667                                  	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
 32668 00004F7E 893E[0787]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
 32669                                  	;mov	[$M_RT+0],di			;;AN000;;
 32670 00004F82 8C06[2587]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
 32671                                  	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
 32672 00004F86 893E[2387]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
 32673                                  	;mov	[$M_RT+28],di			;;AN000;;
 32674                                  
 32675 00004F8A E8DF2F                  	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)
 32676                                  
 32677 00004F8D 8C06[1D87]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
 32678                                  	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
 32679 00004F91 893E[1B87]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
 32680                                  	;mov	[$M_RT+20],di			;;AN000;;
 32681                                  
 32682 00004F95 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 32683 00004F98 B208                    	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
 32684 00004F9A CD2F                    	int	2Fh				;;AN001;; Private interface
 32685                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32686                                  		; DL = subfunction - get ??? error table
 32687                                  		; ES:DI -> error table
 32688                                  
 32689 00004F9C 8C06[3187]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
 32690                                  	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
 32691 00004FA0 893E[2F87]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
 32692                                  	;mov	[$M_RT+40],di			;;AN001;;
 32693                                  
 32694                                  ;M016; M020
 32695                                  ; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
 32696                                  ;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.
 32697                                  
 32698 00004FA4 C706[4A87]0D0A          	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
 32699                                  	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
 32700 00004FAA C606[9387]24            	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
 32701                                  	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
 32702 00004FAF C706[4F87]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 32703                                  	;mov	word [$M_RT+72],0		; M020
 32704 00004FB5 C706[5187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 32705                                  	;mov	word [$M_RT+74],10		; M020
 32706                                  
 32707                                  	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
 32708                                  	; --------------------------
 32709                                  	; MSDOS 6.0 SYSMSG.INC, 1991
 32710                                  	; --------------------------
 32711                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h
 32712                                  
 32713                                  	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
 32714 00004FBB E8312F                  	call    $M_CLS_3			; Get addressibility to class F
 32715 00004FBE 893E[3387]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
 32716                                  	;mov	[$M_RT+44],di
 32717                                  	
 32718 00004FC2 E80600                  	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector
 32719                                  
 32720                                  	; 15/04/2023
 32721                                  	;clc					;;AN000;; Make sure carry is clear
 32722                                  	;jc	short $MIF20
 32723                                  	
 32724 00004FC5 5F                      	pop	di				;;AN000;; Restore REGS
 32725 00004FC6 07                      	pop	es				;;AN000;;
 32726 00004FC7 5A                      	pop	dx				;;AN000;;
 32727 00004FC8 5B                      	pop	bx				;;AN000;;
 32728 00004FC9 58                      	pop	ax				;;AN000;;
 32729                                  	;jmp	short $MEN20
 32730                                  	; 15/04/2023
 32731 00004FCA C3                      	retn
 32732                                  
 32733                                  	; 15/04/2023
 32734                                  ;$MIF20:
 32735                                  	;add	sp,10				;;AN000;;
 32736                                  	;stc					;;AN000;; Reset carry flag
 32737                                  ;$MEN20:
 32738                                  	;retn					;;AN000;;
 32739                                  
 32740                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32741                                  ;;
 32742                                  ;;  Proc Name:	$M_GET_DBCS_VEC
 32743                                  ;;
 32744                                  ;;  Function:	Get the DBCS vector and save it for later use
 32745                                  ;;
 32746                                  ;;  Inputs:	None
 32747                                  ;;
 32748                                  ;;  Outputs:	None
 32749                                  ;;
 32750                                  ;;  Regs Changed:
 32751                                  ;;
 32752                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32753                                  
 32754                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32755                                  
 32756                                  $M_GET_DBCS_VEC:
 32757 00004FCB 50                      	push	ax				;;AN000;; Save character to check
 32758 00004FCC 56                      	push	si				;;AN000;;
 32759 00004FCD 1E                      	push	ds				;;AN000;;
 32760 00004FCE B80063                  	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
 32761 00004FD1 CD21                    	int	21h				;;AN000;; Get environment pointer
 32762 00004FD3 1E                      	push	ds				;;AN000;; Get environment pointer
 32763 00004FD4 07                      	pop	es				;;AN000;; Get environment pointer
 32764 00004FD5 1F                      	pop	ds				;;AN000;; Get environment pointer
 32765 00004FD6 7208                    	jc	short $MIF23
 32766                                  	
 32767 00004FD8 8936[4387]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
 32768                                  	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
 32769 00004FDC 8C06[4587]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
 32770                                  	;mov	word [$M_RT+62],es		;;AN000;;
 32771                                  $MIF23:
 32772 00004FE0 5E                      	pop	si				;;AN000;;
 32773 00004FE1 58                      	pop	ax				;;AN000;; Retrieve character to check
 32774 00004FE2 C3                      	retn					;;AN000;; Return
 32775                                  
 32776                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32777                                  ;;
 32778                                  ;;  Proc Name:	SYSGETMSG
 32779                                  ;;
 32780                                  ;;  Function:	The GET service returns the segment, offset and size of the
 32781                                  ;;		message text to the caller based on a message number.
 32782                                  ;;		The GET function will not display the message thus assumes
 32783                                  ;;		caller will handle replaceable parameters.
 32784                                  ;;
 32785                                  ;;  Inputs:
 32786                                  ;;
 32787                                  ;;  Outputs:
 32788                                  ;;
 32789                                  ;;  Psuedocode:
 32790                                  ;;		Call $M_GET_MSG_ADDRESS
 32791                                  ;;		IF MSG_NUM exists THEN
 32792                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
 32793                                  ;;		   CARRY_FLAG = 0
 32794                                  ;;		ELSE
 32795                                  ;;		   CARRY_FLAG = 1
 32796                                  ;;		ENDIF
 32797                                  ;;
 32798                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32799                                  
 32800                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32801                                  
 32802                                  	utility_msg_class equ 0FFh ; 18/04/2023
 32803                                  
 32804                                  SYSGETMSG:
 32805                                  	;; Save registers needed later
 32806 00004FE3 50                      	push	ax				;;AN000;; Save changed regs
 32807 00004FE4 06                      	push	es				;;AN000;;
 32808 00004FE5 57                      	push	di				;;AN000;;
 32809 00004FE6 55                      	push	bp				;;AN000;;
 32810                                  
 32811 00004FE7 E81400                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 32812 00004FEA 720D                    	jc	short $MIF31
 32813                                  	
 32814 00004FEC 80FEFF                  	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
 32815 00004FEF F8                      	clc					;;AN000;;
 32816 00004FF0 7403                    	je	short $MIF32			;;AN000;;
 32817                                  
 32818 00004FF2 06                      	push	es				;;AN000;;
 32819                                  	;pop	ds				;;AN000;;
 32820 00004FF3 EB01                    	jmp	short $MEN32
 32821                                  $MIF32:
 32822 00004FF5 0E                      	push	cs				;;AN000;;			
 32823                                  	;pop	ds				;;AN000;;
 32824                                  $MEN32:
 32825                                  	; 07/04/2023
 32826 00004FF6 1F                      	pop	ds
 32827 00004FF7 89FE                    	mov	si,di				;;AN000;; Return message in DS:SI
 32828                                  $MIF31:
 32829 00004FF9 5D                      	pop	bp				;;AN000;; Restore changed regs
 32830 00004FFA 5F                      	pop	di				;;AN000;;
 32831 00004FFB 07                      	pop	es				;;AN000;;
 32832 00004FFC 58                      	pop	ax				;;AN000;;
 32833 00004FFD C3                      	retn					;;AN000;; Return
 32834                                  
 32835                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32836                                  ;;
 32837                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
 32838                                  ;;
 32839                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
 32840                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
 32841                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
 32842                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
 32843                                  ;;	REGS CHANGED: ES,DI,CX
 32844                                  ;;
 32845                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32846                                  
 32847                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32848                                  
 32849                                  $M_GET_MSG_ADDRESS:
 32850 00004FFE 56                      	push	si				;;AN000;;
 32851 00004FFF 53                      	push	bx				;;AN000;;
 32852 00005000 31F6                    	xor	si,si				;;AN000;; Use SI as an index
 32853 00005002 31C9                    	xor	cx,cx				;;AN000;; Use CX as an size
 32854                                  $MDO36:
 32855 00005004 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
 32856 00005007 7508                    	jne	short $MIF37			;;AN000;; No			
 32857                                  	
 32858                                  	; 07/04/2023
 32859                                  	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 32860 00005009 8BBC[3387]              	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
 32861                                  	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
 32862 0000500D 89FB                    	mov	bx,di				;;AN000;;
 32863 0000500F EB21                    	jmp	short $MEN37
 32864                                  $MIF37:
 32865 00005011 F6C602                  	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
 32866 00005014 7406                    	jz	short $MIF39
 32867                                  	
 32868                                  	; 07/04/2023
 32869                                  	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 32870 00005016 C4BC[1787]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
 32871                                  	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
 32872                                  	
 32873                                  	; 07/04/2023
 32874                                  	;mov	bx,es ; *			;;AN000;;
 32875 0000501A EB14                    	jmp	short $MEN39
 32876                                  $MIF39:
 32877 0000501C 83F813                  	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
 32878 0000501F 720B                    	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;
 32879                                  
 32880 00005021 83F827                  	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
 32881 00005024 7706                    	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;
 32882                                  
 32883                                  	; 07/04/2023
 32884                                  	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 32885 00005026 C4BC[2387]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
 32886                                  	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
 32887                                  	
 32888                                  	; 07/04/2023
 32889                                  	;mov	bx,es ; *			;;AN000;;
 32890 0000502A EB04                    	jmp	short $MEN41
 32891                                  $MIF41:
 32892                                  	; 07/04/2023
 32893                                  	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 32894 0000502C C4BC[0787]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
 32895                                  	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
 32896                                  	
 32897                                  	; 07/04/2023
 32898                                  	;mov	bx,es ; *			;;AN000;;
 32899                                  $MEN41:
 32900                                  $MEN39:
 32901                                  	; 07/04/2023
 32902 00005030 8CC3                    	mov	bx,es ; *
 32903                                  $MEN37:						;;AN000;;
 32904 00005032 83FBFF                  	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
 32905 00005035 7515                    	jne	short $MIF46			;;AN000;; No
 32906                                  
 32907 00005037 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
 32908 0000503A 7503                    	jne	short $MIF47			;;AN000;; No
 32909 0000503C F9                      	stc		     ; **-		;;AN000;; Set the carry flag
 32910                                  	; 07/04/2023
 32911                                  	;jmp	short $MEN47 ; **-
 32912 0000503D EB1B                    	jmp	short $MEN36 ; **-
 32913                                  $MIF47:
 32914 0000503F A3[4F87]                	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],AX
 32915                                  	;mov	[$M_RT+72],ax			;;AN000;; Save message number
 32916 00005042 B8FFFF                  	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
 32917 00005045 BD0100                  	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
 32918 00005048 31F6                    	xor	si,si				;;AN000;; Reset the SI index to start again
 32919                                  	; 28/04/2023
 32920                                  	; 07/04/2023
 32921                                  	;clc	; **+				;;AN000;;
 32922                                  ;$MEN47:
 32923                                  	;jmp	short $MEN46 ; ***
 32924 0000504A EB0A                    	jmp	short $MEN47 ; ***
 32925                                  $MIF46:
 32926                                  	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
 32927 0000504C 21DB                    	and	bx,bx ; 0 ?
 32928 0000504E 7403                    	jz	short $MIF51			;;AN000;; No
 32929                                  	
 32930 00005050 E84D00                  	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
 32931                                  $MIF51:
 32932 00005053 83C604                  	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
 32933                                  	; 07/04/2023
 32934                                  	;clc					;;AN000;;
 32935                                  ;$MEN46:
 32936                                  	;jc	short $MEN36 ; **- ; **+	;;AN000;;
 32937                                  $MEN47:	; 07/04/2023	; **+
 32938 00005056 09C9                    	or	cx,cx				;;AN000;; Was the message found?
 32939                                  	;jnz	short $MXL2			;;AN000;; Yes
 32940                                  	;jmp	short $MDO36
 32941                                  	; 07/04/2023
 32942 00005058 74AA                    	jz	short $MDO36	
 32943                                  $MXL2:
 32944                                  $MEN36:
 32945 0000505A 9C                      	pushf 					;;AN006;; Save the flag state
 32946                                  	
 32947 0000505B 80FE01                  	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
 32948                                  	;jne	short $MIF56			;;AN006;; No
 32949                                  	; 28/04/2023
 32950 0000505E 752A                    	jne	short $M_MYRET	
 32951                                  
 32952 00005060 52                      	push	dx				;;AN006;; Save all needed registers
 32953 00005061 55                      	push	bp				;;AN006;;
 32954 00005062 51                      	push	cx				;;AN006;;
 32955 00005063 06                      	push	es				;;AN006;;
 32956 00005064 57                      	push	di				;;AN006;;
 32957 00005065 50                      	push	ax				;;AN006;;
 32958                                  
 32959 00005066 B80005                  	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
 32960 00005069 CD2F                    	int	2Fh				;;AN006;;
 32961                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
 32962                                  		; Return: AL = 00h not installed, OK to install
 32963                                  		; 01h not installed, can't install
 32964                                  		; FFh installed
 32965                                  
 32966 0000506B 3CFF                    	cmp	al, 0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
 32967 0000506D 58                      	pop	ax				;;AN006;; Restore msg number
 32968 0000506E 7513                    	jne	short $MIF57			;;AN006;; No (not installed)
 32969                                  
 32970 00005070 89C3                    	mov	bx,ax				;;AN006;; BX is the extended error number
 32971 00005072 B80205                  	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
 32972 00005075 CD2F                    	int	2Fh				;;AN006;; Call IFSFUNC
 32973                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER
 32974                                  
 32975                                  	;jmp	short $MEN57			;;AN006;;
 32976                                  	; 28/04/2023
 32977 00005077 720B                    	jc	short $MEN57
 32978                                  $MIF60:
 32979 00005079 83C406                  	add	sp,6				;;AN006;; Throw away old pointer
 32980 0000507C E81200                  	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 32981                                  $MEN60:
 32982 0000507F 5D                      	pop	bp				;;AN006;; Restore other Regs
 32983 00005080 5A                      	pop	dx				;;AN006;;
 32984                                  $MIF56:
 32985                                  	; 07/04/2023
 32986                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 32987 00005081 EB07                    	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 32988                                  
 32989                                  $MIF57:
 32990 00005083 F9                      	stc					;;AN006;; Carry conditon
 32991                                  $MEN57:
 32992                                  	; 28/04/2023
 32993                                  	;jnc	short $MIF60			;;AN006;;
 32994                                  
 32995 00005084 5F                      	pop	di				;;AN006;;
 32996 00005085 07                      	pop	es				;;AN006;; Restore old pointer
 32997 00005086 59                      	pop	cx				;;AN006;;
 32998 00005087 EBF6                    	jmp	short $MEN60
 32999                                  
 33000                                  ;$MIF60:
 33001                                  ;	add	sp,6				;;AN006;; Throw away old pointer
 33002                                  ;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33003                                  ;$MEN60:
 33004                                  ;	pop	bp				;;AN006;; Restore other Regs
 33005                                  ;	pop	dx				;;AN006;;
 33006                                  ;$MIF56:
 33007                                  ;	; 07/04/2023
 33008                                  ;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33009                                  ;	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33010                                  
 33011                                  ; 07/04/2023
 33012                                  ; ---------------------------
 33013                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33014                                  ; ---------------------------
 33015                                  	; $M_POPF macro
 33016                                  	;jmp	short $+3
 33017                                  m_popf_iret:
 33018 00005089 CF                      	iret
 33019                                  $M_MYRET:
 33020 0000508A 0E                      	push	cs
 33021 0000508B E8FBFF                  	call	m_popf_iret
 33022                                  	;;; end macro	
 33023                                  ; ---------------------------
 33024                                  
 33025 0000508E 5B                      	pop	bx				;;AN000;;
 33026 0000508F 5E                      	pop	si				;;AN000;;
 33027 00005090 C3                      	retn					;;AN000;; Return ES:DI pointing to the message
 33028                                  
 33029                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33030                                  
 33031                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33032                                  $M_SET_LEN_IN_CX:			
 33033 00005091 57                      	push	di				;;AN006;; Save position
 33034 00005092 50                      	push	ax				;;AN006;;
 33035 00005093 B9FFFF                  	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
 33036 00005096 30C0                    	xor	al,al				;;AN006;; Prepare compare register
 33037 00005098 F2AE                    	repne	scasb				;;AN006;; Scan for zero
 33038 0000509A F7D1                    	not	cx				;;AN006;; Change decrement into number
 33039 0000509C 49                      	dec	cx				;;AN006;; Don't include the zero
 33040 0000509D 58                      	pop	ax				;;AN006;;
 33041 0000509E 5F                      	pop	di				;;AN006;; Restore position
 33042 0000509F C3                      	retn					;;AN006;;
 33043                                  
 33044                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33045                                  ;;
 33046                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
 33047                                  ;;
 33048                                  ;;	FUNCTION:  To scan thru message headers until message is found
 33049                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
 33050                                  ;;		   CX contains the number of messages in class
 33051                                  ;;		   DH contains the message class
 33052                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
 33053                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
 33054                                  ;;
 33055                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33056                                  
 33057                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33058                                  
 33059                                  $M_FIND_SPECIFIED_MSG:
 33060 000050A0 83FB01                  	cmp	bx,1				;;AN004;; Do we have an address to CALL?
 33061 000050A3 751F                    	jne	short $MIF64
 33062 000050A5 833E[2F87]FF            	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
 33063                                  	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
 33064 000050AA 7518                    	jne	short $MIF64
 33065                                  
 33066 000050AC 83F8FF                  	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
 33067 000050AF 750B                    	jne	short $MIF65
 33068                                  	
 33069 000050B1 50                      	push	ax				;;AN004;; Reset the special message number
 33070 000050B2 A1[4F87]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 33071                                  	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
 33072 000050B5 FF1E[2F87]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33073                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33074 000050B9 58                      	pop	ax				;;AN004;; Reset the special message number
 33075                                  	; 28/04/2023
 33076 000050BA EB04                    	jmp	short $MEN65
 33077                                  	; 18/04/2023
 33078                                  	;jmp	short $MEN64
 33079                                  $MIF65:
 33080 000050BC FF1E[2F87]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33081                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33082                                  $MEN65:
 33083                                  	; 28/04/2023
 33084 000050C0 7344                    	jnc	short $MIF75
 33085                                  	;
 33086 000050C2 EB19                    	jmp	short $MEN64 ; $MDO76		;;AN004;;
 33087                                  $MIF64:
 33088 000050C4 31C9                    	xor	cx,cx				;;AN002;; CX = 0 will allow us to
 33089 000050C6 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33090 000050C9 7406                    	je	short $MIF69
 33091                                  	
 33092 000050CB 268A4D03                	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33093                                  	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
 33094 000050CF EB09                    	jmp	short $MEN69
 33095                                  $MIF69:
 33096                                  	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
 33097                                  	;cmp	[cs:di+0],dh
 33098 000050D1 2E3835                  	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
 33099 000050D4 7504                    	jne	short $MIF71
 33100                                  
 33101 000050D6 2E8A4D03                	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33102                                  	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
 33103                                  $MIF71:						;;AN001;;
 33104                                  $MEN69:
 33105 000050DA 83C704                  	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
 33106                                  	; 02/05/2023
 33107                                  	;stc					;;AN004;; Flag that we haven't found anything yet
 33108                                  $MEN64:
 33109                                  	;jnc	short $MIF75
 33110                                  	; 28/04/2023
 33111                                  	; (or instruction clears carry flag)
 33112                                  	;clc					;;AN004;; No, reset carry
 33113                                  $MDO76:
 33114 000050DD 09C9                    	or	cx,cx				;;AN000;; Do we have any to check?
 33115 000050DF 7417                    	jz	short $MEN76
 33116                                  
 33117 000050E1 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33118 000050E4 7405                    	je	short $MIF78
 33119                                  
 33120                                  	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
 33121 000050E6 263B05                  	cmp	ax,[es:di]
 33122 000050E9 EB03                    	jmp	short $MEN78
 33123                                  $MIF78:
 33124                                  	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
 33125 000050EB 2E3B05                  	cmp	ax,[cs:di]
 33126                                  $MEN78:
 33127                                  	;jne	short $MIF76
 33128                                  	;jmp	short $MSR76
 33129                                  	; 07/04/2023
 33130 000050EE 740B                    	je	short $MSR76 ; *
 33131                                  $MIF76:
 33132 000050F0 49                      	dec	cx				;;AN000;; No, well do we have more to check?
 33133 000050F1 7405                    	jz	short $MEN76
 33134                                  
 33135 000050F3 83C704                  	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
 33136 000050F6 EBE5                    	jmp	short $MDO76			;;AN000;;
 33137                                  $MEN76:
 33138 000050F8 F9                      	stc					;;AN000;;
 33139                                  ;$MSR76:	; 07/04/2023
 33140                                  	;jc	short $MIF86			;;AN000;;
 33141                                  	; 07/04/2023
 33142                                  	;jc	short $MIF91
 33143 000050F9 EB11                    	jmp	short $MIF91 ;*
 33144                                  $MSR76:	; 07/04/2023 ; *	
 33145 000050FB 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
 33146                                  	; 07/04/2023
 33147                                  	;clc					;;AN001;;
 33148 000050FE 7502                    	jne	short $MIF87
 33149                                  
 33150 00005100 0E                      	push	cs				;;AN000;;
 33151 00005101 07                      	pop	es				;;AN000;; Return ES:DI pointing to the message
 33152                                  $MIF87:
 33153                                  	;add	di,[es:di+2]
 33154 00005102 26037D02                	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
 33155                                  $MIF86:
 33156                                  ;$MIF75:
 33157                                  	; 02/05/2023
 33158                                  	;jc	short $MIF91
 33159                                  $MIF75:	; 28/04/2023
 33160 00005106 30ED                    	xor	ch,ch				;;AN000;;
 33161 00005108 268A0D                  	mov	cl,[es:di]			;;AN000;; Move size into CX
 33162 0000510B 47                      	inc	di				;;AN000;; Increment past length
 33163                                  $MIF91:
 33164 0000510C C606[4987]00            	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
 33165                                  	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
 33166 00005111 C3                      	retn					;;AN000;; Return
 33167                                  
 33168                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33169                                  ;;
 33170                                  ;;  Proc Name:	SYSDISPMSG
 33171                                  ;;
 33172                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
 33173                                  ;;		requested by the caller. It also provides function to display
 33174                                  ;;		messages when handles are not applicable (ie. DOS function calls
 33175                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
 33176                                  ;;		defined previous to entry.
 33177                                  ;;
 33178                                  ;;		It is assumes that a PRELOAD function has already determined
 33179                                  ;;		the addressibilty internally to the message retriever services.
 33180                                  ;;  Inputs:
 33181                                  ;;
 33182                                  ;;  Outputs:
 33183                                  ;;
 33184                                  ;;  Psuedocode:
 33185                                  ;;		Save registers needed later
 33186                                  ;;		Get address of the message requested
 33187                                  ;;		IF Message number exists THEN
 33188                                  ;;		  IF replacable parameters were specified THEN
 33189                                  ;;		     Display message with replacable parms
 33190                                  ;;		  ELSE
 33191                                  ;;		     Display string without replacable parms
 33192                                  ;;		  ENDIF
 33193                                  ;;		  IF character input was requested THEN
 33194                                  ;;		     Wait for character input
 33195                                  ;;		  ENDIF
 33196                                  ;;		  Clear CARRY FLAG
 33197                                  ;;		ELSE
 33198                                  ;;		   Set CARRY FLAG
 33199                                  ;;		ENDIF
 33200                                  ;;		Return
 33201                                  ;;
 33202                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33203                                  
 33204                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33205                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h
 33206                                  
 33207                                  SYSDISPMSG:
 33208                                  	;; Save registers and values needed later
 33209 00005112 50                      	push	ax				;;AN000;; Save changed REGs
 33210 00005113 53                      	push	bx				;;AN000;;
 33211 00005114 51                      	push	cx				;;AN000;;
 33212 00005115 55                      	push	bp				;;AN000;;
 33213 00005116 57                      	push	di				;;AN000;; Save pointer to input buffer (offset)
 33214 00005117 06                      	push	es				;;AN000;; Save pointer to input buffer (segment)
 33215 00005118 52                      	push	dx				;;AN000;; Save Input/Class request
 33216                                  
 33217 00005119 89CD                    	mov	bp,cx				;;AN000;; Use BP to hold replace count
 33218 0000511B 891E[4787]              	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
 33219                                  	;mov	[$M_RT+64],bx			;;AN000;; Save handle
 33220 0000511F 8836[4C87]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
 33221                                  	;mov	[$M_RT+69],dh			;;AN004;; Save class
 33222                                  
 33223                                  	;; Get address of the message requested
 33224 00005123 E8D8FE                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33225 00005126 09C9                    	or	cx,cx				;;AN000;; Was message found?
 33226 00005128 7420                    	jz	short $MIF93
 33227                                  						;;AN000;; Yes, Message address in ES:DI
 33228                                  	
 33229                                  	;; Test if replacable parameters were specified
 33230 0000512A 09ED                    	or	bp,bp				;;AN000;; Were replacable parameters requested
 33231 0000512C 7505                    	jnz	short $MIF94
 33232                                  
 33233                                  	;; Display string without replacable parms
 33234 0000512E E82100                  	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
 33235 00005131 EB03                    	jmp	short $MEN94
 33236                                  $MIF94:
 33237                                  	;; Display message with replacable parms
 33238 00005133 E88401                  	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
 33239                                  $MEN94:
 33240 00005136 720D                    	jc	short $MIF97
 33241 00005138 5A                      	pop	dx				;;AN000;; Get Input/Class request
 33242 00005139 E8F500                  	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
 33243 0000513C 07                      	pop	es				;;AN000;; Get location of input buffer (if specified)
 33244 0000513D 5F                      	pop	di				;;AN000;;
 33245                                  	;jmp	short $MEN97 ; ***
 33246                                  	; 08/04/2023
 33247                                  	;jmp	short $MEN93 ; **
 33248                                  
 33249                                  	; 08/04/2023
 33250                                  ;$MEN93:
 33251 0000513E 720D                    	jc	short $MIF104
 33252                                  ;$MEN97:
 33253 00005140 5D                      	pop	bp				;;AN000;;
 33254 00005141 59                      	pop	cx				;;AN000;;
 33255 00005142 5B                      	pop	bx				;;AN000;;
 33256 00005143 58                      	pop	ax				;;AN000;;
 33257 00005144 C3                      	retn
 33258                                   
 33259                                  $MIF97:
 33260                                  	; 08/04/2023
 33261                                  	;add	sp,6				;;AN000;;
 33262                                  	;stc					;;AN000;; Reset carry flag
 33263                                  ;$MEN97: ; ***
 33264                                  	;jmp	short $MEN93
 33265                                  	; 08/04/2023
 33266                                  	;jmp	short $MIF104
 33267                                  	; 08/04/2023
 33268 00005145 83C40E                  	add	sp,14 ; 6+8
 33269 00005148 F9                      	stc
 33270 00005149 C3                      	retn
 33271                                  $MIF93:
 33272                                  	; 08/04/2023
 33273                                  	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
 33274                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
 33275 0000514A 07                      	pop	es				;;AN000;; Get pointer to input buffer (segment)
 33276 0000514B 5F                      	pop	di				;;AN000;; Get base pointer to first sublist (offset)
 33277 0000514C 5A                      	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
 33278                                  	;stc	; * 				;;AN000;; Set carry flag
 33279                                  	; 08/04/2023
 33280                                  	;jmp short $MIF104 ; *
 33281                                  
 33282                                  ;$MEN93: ; **
 33283                                  ;	jc	short $MIF104
 33284                                  ;$MEN97: ; 08/04/2023
 33285                                  ;	pop	bp				;;AN000;;
 33286                                  ;	pop	cx				;;AN000;;
 33287                                  ;	pop	bx				;;AN000;;
 33288                                  ;	pop	ax				;;AN000;;
 33289                                  ;	;jmp	short $MEN104
 33290                                  ;	; 08/04/2023
 33291                                  ;	retn
 33292                                  
 33293                                  $MIF104: ; *
 33294 0000514D 83C408                  	add	sp,8				;;AN000;; Eliminate from stack
 33295 00005150 F9                      	stc					;;AN000;;
 33296                                  $MEN104:
 33297 00005151 C3                      	retn					;;AN000;; Return
 33298                                  
 33299                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33300                                  ;;
 33301                                  ;;	PROC NAME: $M_DISPLAY_STRING
 33302                                  ;;
 33303                                  ;;	FUNCTION:  Will display or write string
 33304                                  ;;	INPUTS:    ES:DI points to beginning of message
 33305                                  ;;		   CX contains the length of string to write (if applicable)
 33306                                  ;;	OUTPUTS:   None
 33307                                  ;;	REGS Revised: None
 33308                                  ;;
 33309                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33310                                  
 33311                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33312                                  
 33313                                  $M_DISPLAY_STRING:
 33314 00005152 50                      	push	ax				;;AN000;;
 33315 00005153 53                      	push	bx				;;AN000;;
 33316 00005154 52                      	push	dx				;;AN000;;
 33317 00005155 8B1E[4787]              	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
 33318                                  	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
 33319                                  	
 33320 00005159 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
 33321 0000515C 7505                    	jne	short $MIF107
 33322                                  
 33323 0000515E E82600                  	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
 33324 00005161 EB03                    	jmp	short $MEN107
 33325                                  $MIF107:
 33326 00005163 E86E00                  	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
 33327                                  $MEN107:
 33328 00005166 730D                    	jnc	short $MIF110
 33329                                  	
 33330 00005168 B459                    	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
 33331                                  	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
 33332                                  	; 08/04/2023
 33333 0000516A 31DB                    	xor	bx,bx
 33334 0000516C CD21                    	int	21h				;;AN000;;
 33335                                  		; DOS - 3+ - GET EXTENDED ERROR CODE
 33336                                  		; BX = version code (0000h for DOS 3.x)
 33337 0000516E 30E4                    	xor	ah,ah				;;AN000;; Clear AH
 33338                                  $MEN110: ; 08/04/2023 ; ***
 33339 00005170 83C406                  	add	sp,6				;;AN000;; Clean up stack
 33340 00005173 F9                      	stc					;;AN000;; Flag that there was an error
 33341                                  	;jmp	short $MEN110 ; ****
 33342                                  	; 08/04/2023
 33343 00005174 C3                      	retn
 33344                                  $MIF110:
 33345                                  	;cmp	bx,$M_NO_HANDLE
 33346 00005175 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
 33347 00005178 7409                    	je	short $MIF112 ; *  ; cf = 0
 33348 0000517A 39C8                    	cmp	ax,cx				;;AN001;; Was it ALL written?
 33349 0000517C 7405                    	je	short $MIF113 ; ** ; cf = 0
 33350 0000517E E8A700                  	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
 33351                                  	;add	sp,6				;;AN001;; Clean up stack
 33352                                  	;stc					;;AN001;; Flag that there was an error
 33353                                  	; 08/04/2023
 33354 00005181 EBED                    	jmp	short $MEN110 ; ***
 33355                                  	; 08/04/2023
 33356                                  ;$MIF112:
 33357                                  ;$MEN110: ; ****
 33358                                  	;jc	short $MIF117
 33359                                  $MIF112: ; 08/04/2023	; *
 33360                                  $MIF113:	; **
 33361 00005183 5A                      	pop	dx				;;AN000;; Restore regs
 33362 00005184 5B                      	pop	bx				;;AN000;;
 33363 00005185 58                      	pop	ax				;;AN000;;
 33364                                  $MIF117:
 33365 00005186 C3                      	retn
 33366                                  
 33367                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33368                                  ;;
 33369                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
 33370                                  ;;
 33371                                  ;;	FUNCTION:  Will display a $ terminated string
 33372                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
 33373                                  ;;	OUTPUTS:   None
 33374                                  ;;	REGS USED: AX,DX
 33375                                  ;;
 33376                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33377                                  
 33378                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33379                                  
 33380                                  $M_DISPLAY_$_STRING:
 33381 00005187 1E                      	push	ds				;;AN000;;
 33382 00005188 06                      	push	es				;;AN000;;
 33383 00005189 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33384                                  
 33385                                  	; 08/04/2023
 33386 0000518A B402                    	mov	ah,2 ; DOS_DISP_CHAR
 33387                                  
 33388                                  	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
 33389 0000518C 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR
 33390 0000518F 7518                    	jne	short $MIF119			;;AN000;; No
 33391                                  	
 33392                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33393 00005191 268A15                  	mov	dl,[es:di]			;;AN000;; Get the character
 33394 00005194 CD21                    	int	21h				;;AN000;; Write character
 33395                                  		; DOS - DISPLAY OUTPUT
 33396                                  		; DL = character to send to standard output
 33397 00005196 1F                      	pop	ds				;;AN000;;
 33398 00005197 88D0                    	mov	al,dl				;;AN000;; Get the character in AL
 33399 00005199 E8AC00                  	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
 33400 0000519C 1E                      	push	ds				;;AN000;;
 33401 0000519D 06                      	push	es				;;AN000;;
 33402 0000519E 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33403 0000519F 7316                    	jnc	short $MIF120 ; *
 33404                                  
 33405 000051A1 268A5501                	mov	dl,[es:di+1]			;;AN000;; Get the next character
 33406 000051A5 CD21                    	int	21h				;;AN000;; Write character
 33407                                  		; DOS - DISPLAY OUTPUT
 33408                                  		; DL = character to send to standard output
 33409                                  	; 08/04/2023
 33410                                  	;clc					;;AN000;; Clear the DBCS indicator
 33411                                  ;$MIF120:
 33412 000051A7 EB0D                    	jmp	short $MEN119
 33413                                  $MIF119:
 33414                                  	; 08/04/2023
 33415                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33416                                  ;$MDO123:
 33417 000051A9 09C9                    	or	cx,cx				;;AN002;; Are there any left to display?
 33418                                  	;jz	short $MEN123
 33419                                  	; 18/04/2023
 33420 000051AB 740A                    	jz	short $MIF120 ; cf = 0
 33421                                  $MDO123: ; 08/04/2023
 33422 000051AD 268A15                  	mov	dl,[es:di]			;;AN002;; Get the character
 33423 000051B0 CD21                    	int	21h				;;AN002;; Display the character
 33424                                  		; DOS - DISPLAY OUTPUT
 33425                                  		; DL = character to send to standard output
 33426 000051B2 47                      	inc	di				;;AN002;; Set pointer to next character
 33427 000051B3 49                      	dec	cx				;;AN002;; Count this character
 33428 000051B4 75F7                    	jnz	short $MDO123
 33429                                  ;$MEN123:
 33430                                  $MEN119:
 33431 000051B6 F8                      	clc					;;AN000;;Char functions used don't return carry as error
 33432                                  $MIF120: ; 08/04/2023 ; *
 33433 000051B7 1F                      	pop	ds				;;AN000;;
 33434 000051B8 C3                      	retn
 33435                                  
 33436                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33437                                  ;;
 33438                                  ;; Scan_ctrlZ: This routine looks through the string to be printed and 
 33439                                  ;; truncates it at the Ctrl-Z if any present.
 33440                                  ;;
 33441                                  ;;	ENTRY:	ds:dx = String to be displayed
 33442                                  ;;		cx = number of chars to be displayed
 33443                                  ;;
 33444                                  ;;	EXIT:	cx = number of chars to be displayed
 33445                                  ;;
 33446                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33447                                  
 33448                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33449                                  scan_ctrlz:
 33450 000051B9 57                      	push	di
 33451 000051BA 50                      	push	ax
 33452 000051BB 06                      	push	es
 33453 000051BC 53                      	push	bx
 33454                                  
 33455 000051BD 89D7                    	mov	di,dx
 33456 000051BF 1E                      	push	ds
 33457 000051C0 07                      	pop	es   			;es:di points at string
 33458                                  
 33459 000051C1 89CB                    	mov	bx,cx			;save current count
 33460                                  
 33461 000051C3 B01A                    	mov	al,1Ah	; Ctrl-Z
 33462 000051C5 FC                      	cld
 33463 000051C6 F2AE                    	repne	scasb			;find first Ctrl-Z
 33464 000051C8 7503                    	jnz	short noCtrlZ		;no CtrlZ found in string
 33465                                  
 33466 000051CA 29CB                    	sub	bx,cx
 33467 000051CC 4B                      	dec	bx			;bx = new count to display
 33468                                  noCtrlZ:
 33469 000051CD 89D9                    	mov	cx,bx			;cx = actual display count
 33470                                  
 33471 000051CF 5B                      	pop	bx
 33472 000051D0 07                      	pop	es
 33473 000051D1 58                      	pop	ax
 33474 000051D2 5F                      	pop	di
 33475                                  $MIF127:	; 08/04/2023
 33476 000051D3 C3                      	retn
 33477                                  
 33478                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33479                                  ;;
 33480                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
 33481                                  ;;
 33482                                  ;;	FUNCTION:  Will display a string to a specified handle
 33483                                  ;;	INPUTS:    ES:DI points to beginning of message
 33484                                  ;;		   CX contains the number of bytes to write
 33485                                  ;;		   BX contains the handle to write to
 33486                                  ;;	OUPUTS:    None
 33487                                  ;;	REGS USED: AX,DX
 33488                                  ;;
 33489                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33490                                  
 33491                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33492                                  
 33493                                  $M_DISPLAY_H_STRING:
 33494 000051D4 31C0                    	xor	ax,ax			;;AN002;; Set number of bytes written to 0
 33495 000051D6 09C9                    	or	cx,cx			;;AN002;; For performance, don't write if not necessary
 33496 000051D8 74F9                    	jz	short $MIF127
 33497                                  	
 33498 000051DA 1E                      	push	ds			;;AN000;;
 33499 000051DB 06                      	push	es			;;AN000;;
 33500 000051DC 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33501                                  	
 33502 000051DD B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 33503 000051DF 89FA                    	mov	dx,di			;;AN000;; Pointer to data to write
 33504                                  
 33505 000051E1 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
 33506 000051E4 7528                    	jne	short $MIF128		;;AN000;; No
 33507                                  
 33508 000051E6 CD21                    	int	21h			;;AN000;; Write character
 33509                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 33510                                  		; BX = file handle, CX = number of bytes to writ
 33511                                  
 33512 000051E8 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33513 000051E9 50                      	push	ax			;;AN000;;
 33514 000051EA 268A05                  	mov	al,[es:di] 		;;AN000;; Get the character
 33515 000051ED E85800                  	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
 33516 000051F0 58                      	pop	ax			;;AN000;;
 33517 000051F1 1E                      	push	ds			;;AN000;;
 33518 000051F2 06                      	push	es			;;AN000;;
 33519 000051F3 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33520 000051F4 7306                    	jnc	short $MIF129
 33521                                  	
 33522 000051F6 F8                      	clc				;;AN000;; Clear the DBCS indicator
 33523 000051F7 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 33524 000051F9 42                      	inc	dx			;;AN000;; Point to next character
 33525 000051FA CD21                    	int	21h			;;AN000;; Write character
 33526                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 33527                                  		; BX = file handle, CX = number of bytes to write, 
 33528                                  $MIF129:
 33529                                  ;SR;
 33530                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
 33531                                  ;0 chars written making the caller think there was an error writing. To 
 33532                                  ;avoid this, we check if the single char was a Ctrl-Z and if so, return that
 33533                                  ;the char was written, thus fooling the caller.
 33534                                  
 33535 000051FC 9C                      	pushf				;save flags
 33536 000051FD 26803D1A                	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
 33537 00005201 7502                    	jne	short m_popf_j		;no, continue
 33538                                  
 33539 00005203 89C8                    	mov	ax,cx			;yes, fake as if it was written
 33540                                  m_popf_j:
 33541                                  	; 08/04/2023
 33542                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33543 00005205 EB01                    	jmp	short m_popf		;restore flags
 33544                                  
 33545                                  ; 07/04/2023
 33546                                  ; ---------------------------
 33547                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33548                                  ; ---------------------------
 33549                                  	; $M_POPF macro
 33550                                  	;jmp	short $+3
 33551                                  intret:
 33552 00005207 CF                      	iret
 33553                                  m_popf:
 33554 00005208 0E                      	push	cs
 33555 00005209 E8FBFF                  	call	intret
 33556                                  	;;; end macro	
 33557                                  ; ---------------------------
 33558                                  
 33559 0000520C EB18                    	jmp	short $MEN128
 33560                                  
 33561                                  $MIF128:
 33562                                  ;SR;
 33563                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
 33564                                  ;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
 33565                                  
 33566 0000520E 55                      	push	bp			; M007
 33567 0000520F 51                      	push	cx
 33568 00005210 E8A6FF                  	call	scan_ctrlz		;cx = count without Ctrl-Z
 33569 00005213 89CD                    	mov	bp,cx			;store no ^Z count in bp ;M007
 33570 00005215 59                      	pop	cx			;get old count back ;M007
 33571                                  	
 33572 00005216 CD21                    	int	21h			;;AN000;; Write String at DS:SI to handle
 33573                                  	;jnc	short chk_count		;no error, adjust return count
 33574                                  	;jmp	short m_cnt_ok		;error, return with carry set;M007
 33575                                  	; 08/04/2023
 33576 00005218 720B                    	jc	short m_cnt_ok 
 33577                                  ;M007
 33578                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
 33579                                  ;return count will be much less and if this returns to the caller we can get
 33580                                  ;spurious error messages. We check here if the count returned is same as
 33581                                  ;original count or same as the count if we stop at Ctrl-Z. In the second
 33582                                  ;case, we fake it as if all bytes have been written. If the return count
 33583                                  ;does not match either count, then we had some other disk error (such as
 33584                                  ;insufficient disk space) and we pass it through
 33585                                  
 33586                                  chk_count:
 33587 0000521A 39C1                    	cmp	cx,ax			;have all bytes been written?;M007
 33588 0000521C 7407                    	je	short m_cnt_ok		;there was an error writing ;M007
 33589 0000521E 39C5                    	cmp	bp,ax			;count = Ctrl-Z count? ;M007
 33590 00005220 F8                      	clc				;no error either way ;M007
 33591 00005221 7502                    	jne	short m_cnt_ok		;no, pass it through ;M007
 33592 00005223 89C8                    	mov	ax,cx			;return old count ;M007
 33593                                  m_cnt_ok:				; M007
 33594 00005225 5D                      	pop	bp			; M007
 33595                                  $MEN128:
 33596 00005226 1F                      	pop	ds			;;AN000;;
 33597                                  ;$MIF127: ; 08/04/2023
 33598 00005227 C3                      	retn
 33599                                  
 33600                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33601                                  ;;
 33602                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
 33603                                  ;;
 33604                                  ;;	FUNCTION:  Will set registers for extended error #39
 33605                                  ;;	INPUTS:    None
 33606                                  ;;	OUPUTS:    AX,BX,CX set
 33607                                  ;;	REGS USED:
 33608                                  ;;
 33609                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33610                                  
 33611                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33612                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
 33613                                  $M_GET_EXT_ERR_39:
 33614 00005228 B82700                  	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
 33615                                  	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
 33616 0000522B BB0400                  	mov	bx,4			;AN001; Set BH=1 BL=4
 33617                                  	;mov	ch,LOCUS_39		;AN001; Set CH=1
 33618 0000522E B501                    	mov	ch,1			;AN001;
 33619 00005230 C3                      	retn				;AN001;
 33620                                  
 33621                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33622                                  ;;
 33623                                  ;;	PROC NAME: $M_ADD_CRLF
 33624                                  ;;
 33625                                  ;;	FUNCTION:  Will decide whether to display a CRLF
 33626                                  ;;	INPUTS:    DX contains the Input/Class requested
 33627                                  ;;	OUTPUTS:   None
 33628                                  ;;	REGS Revised: CX,ES,DI
 33629                                  ;;
 33630                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33631                                  
 33632                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33633                                  
 33634                                  $M_ADD_CRLF:
 33635                                  	;cmp	dh,0FFh
 33636 00005231 80FEFF                  	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
 33637 00005234 7411                    	je	short $MIF134		;;AN004;; Yes
 33638 00005236 F6C680                  	test	dh,80h; $M_NO_CRLF_MASK	;;AN004;; Are we to supress the CR LF?
 33639 00005239 750C                    	jnz	short $MIF135
 33640                                  					;;AN004;; No	
 33641 0000523B 1E                      	push	ds			;;AN004;;
 33642 0000523C 07                      	pop	es			;;AN004;; Set ES to data segment
 33643 0000523D 8D3E[4A87]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
 33644                                  	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
 33645 00005241 B90200                  	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
 33646 00005244 E80BFF                  	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
 33647                                  $MIF135:
 33648                                  $MIF134:
 33649 00005247 C3                      	retn				;;AN004;; Return
 33650                                  
 33651                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33652                                  ;;
 33653                                  ;;	PROC NAME: $M_IS_IT_DBCS
 33654                                  ;;
 33655                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
 33656                                  ;;	INPUTS:    AL contains the byte to be checked
 33657                                  ;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
 33658                                  ;;		   Carry flag = 1 if byte IS in DBCS range
 33659                                  ;;	REGS USED: All restored
 33660                                  ;;
 33661                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33662                                  
 33663                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33664                                  
 33665                                  $M_IS_IT_DBCS:
 33666 00005248 06                      	push	es			;;AN000;; Save Extra Segment register
 33667 00005249 57                      	push	di			;;AN000;; Save DI register
 33668                                  
 33669 0000524A C43E[4387]              	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
 33670                                  	;les	di,[$M_RT+60]		;;AN000;;
 33671 0000524E 09FF                    	or	di,di			;;AN000;; Was the DBCS vector set?
 33672 00005250 7417                    	jz	short $MIF138		;;AN000;; No
 33673                                  $MDO139:
 33674 00005252 26833D00                	cmp	word [es:di],0 ; $M_DBCS_TERM
 33675                                  					;;AN000;; Is this the terminating flag?
 33676 00005256 F8                      	clc				;;AN000;;
 33677 00005257 7410                    	jz	short $MEN139
 33678                                  					;;AN000;; No
 33679 00005259 263A05                  	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
 33680 0000525C 7207                    	jnae	short $MIF141 ; jb	;;AN000;; No		
 33681 0000525E 263A4501                	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
 33682 00005262 7701                    	jnbe	short $MIF141 ; ja	;;AN000;; No
 33683                                  					;;AN000;; Yes
 33684 00005264 F9                      	stc				;;AN000;; Set carry flag
 33685                                  $MIF141:
 33686 00005265 47                      	inc	di			;;AN000;;
 33687 00005266 47                      	inc	di			;;AN000;;
 33688 00005267 EBE9                    	jmp	short $MDO139		;;AN000;; Go to next vector
 33689                                  $MEN139:
 33690                                  $MIF138:
 33691 00005269 5F                      	pop	di			;;AN000;; Restore DI register
 33692 0000526A 07                      	pop	es			;;AN000;; Restore Extra Segment register
 33693 0000526B C3                      	retn				;;AN000;; Return
 33694                                  
 33695                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33696                                  ;;
 33697                                  ;;	PROC NAME: $M_CONVERT2ASC
 33698                                  ;;
 33699                                  ;;	FUNCTION: Convert a binary number to a ASCII string
 33700                                  ;;	INPUTS: DX:AX contains the number to be converted
 33701                                  ;;		$M_RT_DIVISOR contains the divisor
 33702                                  ;;	OUTPUTS: CX contains the number of characters
 33703                                  ;;		Top of stack  --> Last character
 33704                                  ;;				     . . .
 33705                                  ;;		Bot of stack  --> First character
 33706                                  ;;	REGS USED:
 33707                                  ;;
 33708                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33709                                  
 33710                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33711                                  
 33712                                  $M_CONVERT2ASC:
 33713 0000526C 8F06[4D87]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 33714                                  	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
 33715                                  	
 33716 00005270 31DB                    	xor	bx,bx				;;AN000;; Use BX as a swapping register
 33717 00005272 93                      	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
 33718 00005273 92                      	xchg	ax,dx				;;AN000;;	  - High Word in AX
 33719                                  $MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
 33720 00005274 F736[5187]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 33721                                  	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
 33722 00005278 93                      	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
 33723                                  						;;AN000;;  and save reduced High Word in BX
 33724 00005279 F736[5187]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 33725                                  	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor
 33726                                  
 33727 0000527D 83FA09                  	cmp	dx,9				;;AN000;; Make a digit of the remainder
 33728 00005280 7605                    	jna	short $MIF146			;;AN000;; 0-9
 33729 00005282 80C237                  	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
 33730 00005285 EB03                    	jmp	short $MEN146
 33731                                  $MIF146:
 33732 00005287 80C230                  	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
 33733                                  $MEN146:
 33734 0000528A 52                      	push	dx				;;AN000;; Save the digit on the stack
 33735 0000528B 41                      	inc	cx				;;AN000;; Count that digit
 33736 0000528C 09C0                    	or	ax,ax				;;AN000;; Are we done?
 33737 0000528E 7504                    	jnz	short $MLL149			;;AN000;; No
 33738 00005290 09DB                    	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
 33739 00005292 741F                    	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
 33740                                  $MLL149:
 33741 00005294 83F903                  	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
 33742                                  ; 28/04/2023
 33743 00005297 740A                    	je	short $MIF153
 33744                                  ;	jne	short $MIF150			;;AN000;; No
 33745                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 33746                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 33747                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 33748                                  ;	;jne	short $MIF151
 33749                                  ;	; 09/04/2023
 33750                                  ;	jne	short $MEN150
 33751                                  ;						;;AN000;; Yes
 33752                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 33753                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 33754                                  ;	inc	cx				;;AN000;;
 33755                                  ;$MIF151:
 33756                                  ;	jmp	short $MEN150
 33757                                  
 33758                                  $MIF150:
 33759 00005299 83F906                  	cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 33760                                  ; 28/04/2023
 33761 0000529C 7405                    	je	short $MIF153
 33762                                  ;	jne	short $MIF154			;;AN000;; No
 33763                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 33764                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 33765                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 33766                                  ;	;jne	short $MIF155			;;AN000;; No
 33767                                  ;	; 09/04/2023
 33768                                  ;	jne	short $MEN154
 33769                                  ;						;;AN000;; Yes				
 33770                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 33771                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 33772                                  ;	inc	cx				;;AN000;;
 33773                                  ;$MIF155:
 33774                                  ;	jmp	short $MEN154
 33775                                  
 33776                                  $MIF154:
 33777 0000529E 83F909                  	cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 33778 000052A1 750B                    	jne	short $MIF158			;;AN000;; No  
 33779                                  ; 28/04/2023
 33780                                  $MIF153:
 33781                                  	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 33782 000052A3 807C0A2C                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 33783                                  	;cmp	byte [si+0Ah],',' ; $M_COMMA
 33784 000052A7 7505                    	jne	short $MIF159			;;AN000;; No
 33785                                  						;;AN000;; Yes
 33786 000052A9 FF36[5A87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 33787                                  	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 33788 000052AD 41                      	inc	cx				;;AN000;;
 33789                                  $MIF159:
 33790                                  $MIF158:
 33791                                  $MEN154:
 33792                                  $MEN150:					;;AN000;;
 33793 000052AE 93                      	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
 33794                                  						;;AN000;;  and Revised Low Word
 33795 000052AF 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 33796                                  	; 28/04/2023
 33797 000052B1 EBC1                    	jmp	short $MDO145
 33798                                  ;$MEN145:
 33799                                  	; 28/04/2023
 33800                                  	;xor	ax,ax				;;AN000;; Reset remainder
 33801                                  $MEN145: ; 09/04/2023 ; * ; ax = 0
 33802 000052B3 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 33803 000052B5 FF36[4D87]              	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 33804                                  	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
 33805 000052B9 C3                      	retn					;;AN000;; Return
 33806                                  
 33807                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33808                                  ;;
 33809                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
 33810                                  ;;
 33811                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
 33812                                  ;;	INPUTS:    ES:DI points to beginning of message
 33813                                  ;;		   DS:SI points to first sublist structure in chain
 33814                                  ;;		   BX contains the handle to write to (if applicable)
 33815                                  ;;		   CX contains the length of string to write (before substitutions)
 33816                                  ;;		   BP contains the count of replacables
 33817                                  ;;
 33818                                  ;;	OUTPUTS:
 33819                                  ;;	REGS USED: All
 33820                                  ;;
 33821                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33822                                  
 33823                                  	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33824                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh
 33825                                  
 33826                                  $M_DISPLAY_MESSAGE:
 33827                                  ; $DO						;;AN000;; Note: DS:SI -> message
 33828                                  $MDO165:
 33829 000052BA 31D2                    	xor	dx,dx				;;AN000;; Set size = 0
 33830 000052BC 09C9                    	or	cx,cx				;;AN000;; Are we finished the message yet?
 33831                                  ;; $IF NZ					;;AN000;; No
 33832 000052BE 7421                    	jz	short $MIF166			;;AN000;; Yes
 33833 000052C0 B425                    	mov	ah,"%"				;;AN000;; Prepare to scan for %
 33834 000052C2 B000                    	mov	al,0				;;AN004;;
 33835                                  ;; $DO						;;AN000;; Scan through string until %
 33836                                  $MDO167:
 33837 000052C4 263825                  	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
 33838                                  ;; $LEAVE E,AND					;;AN000;; No
 33839 000052C7 750A                    	jne	short $MLL168
 33840 000052C9 26386501                	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
 33841                                  ;; $LEAVE NE,AND				;;AN000;; No
 33842 000052CD 7404                    	je	short $MLL168
 33843                                  
 33844 000052CF 38E0                    	cmp	al,ah				;;AN000;; Was the character before a %
 33845                                  ;; $LEAVE NE					;;AN000;; No, GREAT found it
 33846 000052D1 750E                    	jne	short MEN167
 33847                                  $MLL168:
 33848 000052D3 268A05                  	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
 33849 000052D6 E86FFF                  	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
 33850                                  ;;; $IF C					;;AN004;; Yes
 33851 000052D9 7301                    	jnc	short $MIF169
 33852 000052DB 47                      	inc	di				;;AN004;; Increment past second part
 33853                                  ;;; $ENDIF					;;AN004;;
 33854                                  $MIF169:
 33855 000052DC 47                      	inc	di				;;AN000;; Next character in string
 33856 000052DD 42                      	inc	dx				;;AN000;; Size = Size + 1
 33857 000052DE 49                      	dec	cx				;;AN000;; Decrement total size
 33858                                  ;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
 33859 000052DF 75E3                    	jnz	short $MDO167
 33860                                  $MEN167:
 33861                                  ;; $ENDIF					;;AN000;;
 33862                                  $MIF166:
 33863 000052E1 56                      	push	si				;;AN000;; Save beginning of sublists
 33864 000052E2 87CA                    	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
 33865 000052E4 09ED                    	or	bp,bp				;;AN000;; Do we have any replacables to do?
 33866                                  ;; $IF NZ					;;AN000;; Yes
 33867 000052E6 7431                    	jz	short $MIF173
 33868 000052E8 4D                      	dec	bp				;;AN000;; Decrement number of replacables
 33869                                  
 33870                                  ;; Search through sublists to find applicable one
 33871                                  
 33872 000052E9 833E[4F87]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 33873                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 33874                                  ;;; $IF E					;;AN000;; No
 33875 000052EE 7529                    	jne	short $MIF174
 33876                                  ;;; $SEARCH					;;AN000;;
 33877                                  $MDO175:
 33878                                  	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
 33879 000052F0 8A4406                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
 33880                                  	;mov	al,[si+6]
 33881 000052F3 0430                    	add	al,30h				;;AN000;; Convert to ASCII
 33882                                  	; 28/04/2023					
 33883 000052F5 263A4501                	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
 33884                                  ;;; $EXITIF E					;;AN000;;
 33885                                  	;jne	short $MIF175
 33886                                  ;;; $ORELSE					;;AN000;; No
 33887                                  	;jmp	short $MSR175
 33888                                  	; 28/04/2023
 33889 000052F9 741E                    	je	short $MSR175
 33890                                  $MIF175:
 33891 000052FB 3C30                    	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
 33892                                  ;;; $LEAVE E,AND				;;AN000;; Yes
 33893 000052FD 7504                    	jne	short $MLL178
 33894 000052FF 09D2                    	or	dx,dx				;;AN000;; Are we at the end of the message?
 33895                                  ;;; $LEAVE Z					;;AN000;; No
 33896 00005301 7404                    	jz	short $MEN175
 33897                                  $MLL178:
 33898                                  	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
 33899                                  	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
 33900                                  	;;add	si,[si+0]
 33901 00005303 0334                    	add	si,[si]
 33902                                  ;;; ENDLOOP					;;AN000;; Yes
 33903 00005305 EBE9                    	jmp	short $MDO175
 33904                                  $MEN175:
 33905 00005307 803E[4C87]FF            	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
 33906                                  	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
 33907                                  ;;;; $IF E					;;AN004;; Yes
 33908 0000530C 7508                    	jne	short $MIF180
 33909 0000530E 42                      	inc	dx				;;AN000;; Remember to display CR,LF
 33910 0000530F 42                      	inc	dx				;;AN000;;  at the end of the message
 33911 00005310 49                      	dec	cx				;;AN000;; Adjust message length
 33912 00005311 49                      	dec	cx				;;AN000;;
 33913 00005312 4F                      	dec	di				;;AN000;; Adjust ending address of message
 33914 00005313 4F                      	dec	di				;;AN000;;
 33915                                  ;;;; $ELSE					;;AN004;; No
 33916 00005314 EB03                    	jmp	short $MEN180
 33917                                  $MIF180:
 33918 00005316 BAFFFF                  	mov	dx,-1 				;;AN004;; Set special case
 33919                                  ;;;; $ENDIF					;;AN004;;
 33920                                  $MEN180:
 33921                                  ;;; $ENDSRCH					;;AN000;;
 33922                                  $MSR175:
 33923                                  ;; $ENDIF					;;AN000;;
 33924                                  $MIF174:
 33925                                  ; $ENDIF					;;AN000;;
 33926                                  $MIF173:
 33927                                  ;; Prepare and display this part of message
 33928                                  
 33929 00005319 57                      	push	di				;;AN000;; Save pointer to replace number
 33930 0000531A 29CF                    	sub	di,cx				;;AN000;; Determine beginning of string
 33931 0000531C E833FE                  	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
 33932 0000531F 5F                      	pop	di				;;AN000;; Get back pointer to replace number
 33933 00005320 59                      	pop	cx				;;AN000;; Clean up stack in case error
 33934                                  ; $LEAVE C,LONG					;;AN000;; Fail if carry was set
 33935                                  	;jnc	short $MXL3
 33936                                  	;jmp	$MEN165
 33937                                  	; 02/05/2023
 33938 00005321 7214                    	jc	short $MEN165
 33939                                  $MXL3:
 33940 00005323 51                      	push	cx				;;AN000;;
 33941                                  
 33942                                  ;; Save and reset pointer registers
 33943                                  
 33944 00005324 89D1                    	mov	cx,dx				;;AN000;; Get the size of the rest of the message
 33945                                  	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
 33946 00005326 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
 33947                                  	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
 33948                                  ; $IF NE					;;AN000;; No
 33949 0000532A 7412                    	je	short $MIF187			;;AN000;; Yes			
 33950 0000532C 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 33951                                  ;; $IF NZ					;;AN000;; No
 33952 0000532E 7406                    	jz	short $MIF188			;;AN000;; Yes
 33953 00005330 49                      	dec	cx				;;AN000;; Decrement total size (%)
 33954 00005331 49                      	dec	cx				;;AN000;; Decrement total size (#)
 33955 00005332 47                      	inc	di				;;AN000;; Go past %
 33956 00005333 47                      	inc	di				;;AN000;; Go past replace number
 33957                                  ;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
 33958                                  	;jmp	short $MEN188
 33959                                  	; 28/04/2023
 33960 00005334 EB15                    	jmp	short $MEN187
 33961                                  $MIF188:
 33962 00005336 5E                      	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 33963                                  ;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
 33964                                  $MEN188:
 33965                                  ; $ELSE 					;;AN000;;
 33966                                  	;jmp	short $MEN187
 33967                                  	; 28/04/2023
 33968                                  	; zf = 1
 33969                                  	;jmp	short $MEN165 
 33970                                  
 33971                                  ; 28/04/2023
 33972                                  $MXL4:
 33973                                  $MLL214:
 33974                                  $MEN165:
 33975 00005337 C706[4F87]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 33976                                  	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 33977                                  						;;AN000;; Reset message number to null
 33978 0000533D C3                      	retn					;;AN000;; Return
 33979                                  
 33980                                  $MIF187:
 33981 0000533E 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 33982                                  ;; $IF Z					;;AN004;; No
 33983                                  	;jnz	short $MIF192
 33984                                  	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 33985                                  ;; $ELSE					;;AN000;; No
 33986                                  	;jmp	short $MEN192
 33987                                  	; 28/04/2023
 33988 00005340 74F4                    	jz	short $MIF188
 33989                                  $MIF192:
 33990 00005342 83F9FF                  	cmp	cx,-1				;;AN004;; Are we at the end of the message?
 33991                                  ;;; $IF Z					;;AN004;; No
 33992 00005345 7502                    	jnz	short $MIF194
 33993 00005347 31C9                    	xor	cx,cx				;;AN004;;
 33994                                  ;;; $ENDIF					;;AN000;;
 33995                                  $MIF194:
 33996 00005349 09FF                    	or	di,di				;;AN004;; Turn ZF off
 33997                                  ;; $ENDIF					;;AN000;;
 33998                                  $MEN192:
 33999                                  ; $ENDIF					;;AN000;; Note this will not leave because INC
 34000                                  $MEN187:
 34001                                  ; $LEAVE Z					;;AN000;;
 34002 0000534B 74EA                    	jz	short $MEN165
 34003                                  	;
 34004 0000534D 55                      	push	bp				;;AN000;; Save the replace count
 34005 0000534E 57                      	push	di				;;AN000;; Save location to complete message
 34006 0000534F 06                      	push	es				;;AN000;;
 34007 00005350 51                      	push	cx				;;AN000;; Save size of the rest of the message
 34008 00005351 31C9                    	xor	cx,cx				;;AN000;; Reset CX used for character count
 34009                                  
 34010                                  ;; Determine what action is required on parameter
 34011                                  
 34012 00005353 833E[4F87]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34013                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34014                                  ; $IF E						;;AN000;;
 34015 00005358 753B                    	jne	short $MIF199
 34016                                  
 34017                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34018 0000535A F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34019                                  	;test	byte [si+7],0Fh			;;AN000;;
 34020                                  ;; $IF Z					;;AN000;;
 34021 0000535E 7508                    	jnz	short $MIF200
 34022                                  
 34023                                  ;; Character type requested
 34024                                  
 34025                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34026 00005360 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34027                                  	;les	di,[si+2]
 34028 00005363 E84801                  	call	$M_CHAR_REPLACE			;;AN000;;
 34029                                  ;; $ELSE					;;AN000;; Get the rest of the message to display
 34030 00005366 EB28                    	jmp	short $MEN200
 34031                                  $MIF200:
 34032                                  ;; ENDIF					;;AN000;;
 34033                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34034 00005368 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34035                                  	;test	byte [si+7],0Dh			;;AN000;;
 34036                                  ;; $IF Z,OR					;;AN000;;
 34037 0000536C 740C                    	jz	short $MLL202
 34038                                  	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
 34039 0000536E F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34040                                  	;test	byte [si+7],0Eh			;;AN000;;
 34041                                  ;;; $IF Z,OR					;;AN000;;
 34042 00005372 7406                    	jz	short $MLL202
 34043                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
 34044 00005374 F644070C                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
 34045                                  	;test	byte [si+7],0Ch			;;AN000;;
 34046                                  ;;;; $IF Z 					;;AN000;;
 34047 00005378 7508                    	jnz	short $MIF202
 34048                                  $MLL202:
 34049                                  
 34050                                  ;; Numeric type requested
 34051                                  
 34052                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34053 0000537A C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34054 0000537D E85601                  	call	$M_BIN2ASC_REPLACE		;;AN000;;
 34055                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34056 00005380 EB0E                    	jmp	short $MEN202
 34057                                  $MIF202:
 34058                                  ;;;; ENDIF					;;AN000;;
 34059                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
 34060 00005382 F644070B                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
 34061                                  	;test	byte [si+7],0Bh			;;AN000;;
 34062                                  ;;;; $IF E					;;AN000;;
 34063 00005386 7505                    	jnz	short $MIF204
 34064                                  
 34065                                  ;; Date type requested
 34066                                  
 34067 00005388 E8BE01                  	call	$M_DATE_REPLACE			;;AN000;;
 34068                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34069 0000538B EB03                    	jmp	short $MEN204
 34070                                  $MIF204:					;;AN000;;
 34071                                  
 34072                                  ;; Time type requested (Default if we have not matched until here)
 34073                                  
 34074 0000538D E87002                  	call	$M_TIME_REPLACE			;;AN000;;
 34075                                  
 34076                                  ;;;; $ENDIF					;;AN000;;
 34077                                  $MEN204:
 34078                                  ;;; $ENDIF					;;AN000;;
 34079                                  $MEN202:
 34080                                  ;; $ENDIF					;;AN000;;
 34081                                  $MEN200:
 34082                                  
 34083                                  ;; With the replace information of the Stack, display the replaceable field
 34084                                  
 34085 00005390 E85F00                  	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace
 34086                                  
 34087                                  ;; None of the above - Extended/Parse replace
 34088                                  ; $ELSE 					;;AN000;;
 34089 00005393 EB03                    	jmp	short $MEN199
 34090                                  $MIF199:
 34091 00005395 E81600                  	call	$M_EXT_PAR_REPLACE		;;AN000;;
 34092                                  ; $ENDIF					;;AN000;;
 34093                                  $MEN199:
 34094                                  
 34095                                  ;; We must go back and complete the message after the replacable parameter if there is any left
 34096                                  
 34097                                  ; $IF NC					;;AN000;; IF there was an error displaying then EXIT
 34098 00005398 7207                    	jc	short $MIF211
 34099                                  	;
 34100 0000539A 59                      	pop	cx				;;AN000;; Get size of the rest of the message
 34101 0000539B 07                      	pop	es				;;AN000;; Get address of the rest of the message
 34102 0000539C 5F                      	pop	di				;;AN000;;
 34103 0000539D 5D                      	pop	bp				;;AN000;; Get replacment count
 34104 0000539E 5E                      	pop	si				;;AN000;; ELSE get address of first sublist structure
 34105                                  ; $ELSE						;;AN000;;
 34106 0000539F EB03                    	jmp	short $MEN211
 34107                                  $MIF211:
 34108 000053A1 83C40A                  	add	sp,10				;;AN000;; Clean up stack if error
 34109                                  	; 28/04/2023
 34110                                  	;stc					;;AN000;;
 34111                                  ; $ENDIF					;;AN000;;
 34112                                  $MEN211:
 34113 000053A4 833E[4F87]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34114                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34115                                  ; $ENDDO NE,OR					;;AN000;;
 34116 000053A9 758C                    	jne	short $MLL214
 34117                                  ; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
 34118                                  	; 10/04/2023
 34119                                  	;jc	short $MXL4
 34120 000053AB E90CFF                  	jmp	$MDO165
 34121                                  
 34122                                  ; 28/04/2023
 34123                                  ;$MXL4:
 34124                                  ;$MLL214:
 34125                                  ;$MEN165:
 34126                                  ;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34127                                  ;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34128                                  ;						;;AN000;; Reset message number to null
 34129                                  ;	retn					;;AN000;; Return
 34130                                  
 34131                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34132                                  ;;
 34133                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
 34134                                  ;;
 34135                                  ;;	FUNCTION:
 34136                                  ;;	INPUTS:
 34137                                  ;;	OUPUTS:
 34138                                  ;;
 34139                                  ;;	REGS USED:
 34140                                  ;;
 34141                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34142                                  
 34143                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34144                                  
 34145                                  $M_EXT_PAR_REPLACE:
 34146 000053AE 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34147 000053B0 A1[4F87]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 34148                                  	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
 34149 000053B3 C706[5187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34150                                  	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
 34151 000053B9 E8B0FE                  	call	$M_CONVERT2ASC			;;AN000;;
 34152                                  $MDO215:
 34153 000053BC 58                      	pop	ax				;;AN000;; Get character in register
 34154 000053BD 8887[5387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34155                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34156 000053C1 43                      	inc	bx				;;AN000;; Increase buffer count
 34157 000053C2 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34158 000053C5 7503                    	jne	short $MIF216			;;AN000;; No
 34159 000053C7 E80D00                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34160                                  $MIF216:
 34161 000053CA FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34162 000053CC 75EE                    	jnz	short $MDO215
 34163                                  
 34164 000053CE B80D0A                  	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
 34165 000053D1 8987[5387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
 34166                                  	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
 34167 000053D5 43                      	inc	bx				;;AN000;; Increase buffer count
 34168 000053D6 43                      	inc	bx				;;AN000;; Increase buffer count
 34169                                  	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34170                                  	;retn					;;AN000::
 34171                                  	; 11/04/2023
 34172                                  	;jmp	$M_FLUSH_BUF
 34173                                  
 34174                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34175                                  ;;
 34176                                  ;;	PROC NAME: $M_FLUSH_BUFFER
 34177                                  ;;
 34178                                  ;;	FUNCTION: Display the contents of the temporary buffer
 34179                                  ;;	INPUTS: DI contains the number of bytes to display
 34180                                  ;;	OUTPUTS: BX reset to zero
 34181                                  ;;
 34182                                  ;;	REGS USED:
 34183                                  ;;
 34184                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34185                                  	
 34186                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34187                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h
 34188                                  
 34189                                  $M_FLUSH_BUF:
 34190 000053D7 51                      	push	cx				;;AN000;; Save changed regs
 34191 000053D8 06                      	push	es				;;AN000;;
 34192 000053D9 57                      	push	di				;;AN000;;
 34193 000053DA 1E                      	push	ds				;;AN000;; Set ES pointing to buffer
 34194 000053DB 07                      	pop	es				;;AN000;;
 34195 000053DC 89D9                    	mov	cx,bx				;;AN000;; Set number of bytes to display
 34196 000053DE 31DB                    	xor	bx,bx				;;AN000;; Reset buffer counter
 34197 000053E0 8D3E[5387]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34198                                  	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
 34199 000053E4 E86BFD                  	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
 34200 000053E7 7204                    	jc	short $MIF314
 34201 000053E9 5F                      	pop	di				;;AN000;; No, Restore changed regs
 34202 000053EA 07                      	pop	es				;;AN000;;
 34203 000053EB 59                      	pop	cx				;;AN000;;
 34204                                  	;jmp	short $MEN314
 34205                                  	; 11/04/2023
 34206 000053EC C3                      	retn
 34207                                  $MIF314:
 34208 000053ED 83C406                  	add	sp,6				;;AN000;; Fix stack
 34209 000053F0 F9                      	stc					;;AN000;;
 34210                                  $MEN314:
 34211 000053F1 C3                      	retn					;;AN000;; Return
 34212                                  
 34213                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34214                                  ;;
 34215                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34216                                  
 34217                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34218                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h
 34219                                  
 34220                                  $M_DISPLAY_REPLACE:
 34221 000053F2 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34222                                  	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
 34223 000053F4 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
 34224                                  	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
 34225 000053F8 7511                    	jne	short $MIF276
 34226                                  	
 34227 000053FA C787[5387]202D          	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
 34228                                  	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
 34229                                  	
 34230 00005400 43                      	inc	bx				;;AN000;; Increment count
 34231 00005401 43                      	inc	bx				;;AN000;; Increment count
 34232                                  	
 34233 00005402 C687[5387]20            	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h; $M_SPACE
 34234                                  	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
 34235                                  	
 34236 00005407 43                      	inc	bx				;;AN000;; Increment count
 34237 00005408 E8CCFF                  	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
 34238                                  $MIF276:
 34239 0000540B 5D                      	pop	bp				;;AN000;; Remember the return address
 34240 0000540C 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34241 0000540E 31D2                    	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack
 34242                                  
 34243 00005410 880E[4987]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
 34244                                  	;mov	[$M_RT+66],cl
 34245                                  	
 34246                                  	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
 34247 00005414 8A4409                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
 34248                                  	;mov	al,[si+9]
 34249                                  	
 34250 00005417 38C8                    	cmp	al,cl				;;AN000;; Do we need pad chars added?
 34251 00005419 761E                    	jna	short $MIF278
 34252 0000541B 28C8                    	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
 34253 0000541D 88C6                    	mov	dh,al				;;AN000;; Save the number of pad characters
 34254                                  	
 34255                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34256 0000541F F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34257                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
 34258 00005423 7414                    	jz	short $MIF279			;;AN000;; No
 34259                                  $MDO280:
 34260                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34261 00005425 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34262                                  	;mov	al,[si+0Ah]
 34263 00005428 8887[5387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34264                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34265                                  	
 34266 0000542C 43                      	inc	bx				;;AN000;;
 34267 0000542D 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
 34268 00005430 7503                    	jne	short $MIF281
 34269 00005432 E8A2FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34270                                  $MIF281:
 34271 00005435 FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34272 00005437 75EC                    	jnz	short $MDO280
 34273                                  $MIF279:
 34274                                  $MIF278:
 34275                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
 34276 00005439 807C0800                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
 34277                                  	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
 34278 0000543D 740C                    	je	short $MIF286
 34279                                  	
 34280                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
 34281 0000543F 384C08                  	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
 34282                                  	;;cmp	byte [si+8],cl
 34283 00005442 7307                    	jnb	short $MIF287
 34284                                  
 34285                                  	; 03/05/2023
 34286                                  	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
 34287                                  	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34288                                  	;;sub	cl,[si+8]
 34289 00005444 88CA                    	mov	dl,cl				;;AN000;; Remember how many chars to pop off
 34290                                  	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
 34291                                  	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34292                                  	;;mov	cl,[si+8]
 34293                                  	; 03/05/2023
 34294 00005446 8A4C08                  	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34295 00005449 28CA                    	sub	dl,cl
 34296                                  $MIF287:
 34297                                  $MIF286:
 34298 0000544B 09C9                    	or	cx,cx				;;AN000;;
 34299 0000544D 7424                    	jz	short $MIF290			;;AN000;;
 34300                                  $MDO291:
 34301                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
 34302 0000544F F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34303                                  	;test	byte [si+7],0Fh			;;AN000;;
 34304 00005453 750C                    	jnz	short $MIF292
 34305                                  
 34306                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34307 00005455 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34308                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
 34309 00005459 7406                    	jz	short $MIF292			;;AN000;; No
 34310                                  
 34311 0000545B 268A05                  	mov	al,[es:di]			;;AN000;; Get first character from string
 34312 0000545E 47                      	inc	di				;;AN000;; Next character in string
 34313 0000545F EB01                    	jmp	short $MEN292
 34314                                  $MIF292:
 34315 00005461 58                      	pop	ax				;;AN000;; Get character in register
 34316                                  $MEN292:
 34317                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34318 00005462 8887[5387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34319                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34320                                  	; 03/05/2023
 34321 00005466 43                      	inc	bx				;;AN000;; Increase buffer count
 34322 00005467 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34323 0000546A 7503                    	jne	short $MIF295			;;AN000;;
 34324 0000546C E868FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34325                                  $MIF295:
 34326 0000546F FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34327 00005471 75DC                    	jnz	short $MDO291
 34328                                  $MIF290:
 34329                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34330 00005473 F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34331                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
 34332 00005477 7518                    	jnz	short $MIF299			;;AN000;; Yes
 34333 00005479 08F6                    	or	dh,dh				;;AN000;; Do we need pad chars added?
 34334 0000547B 7414                    	jz	short $MIF300
 34335                                  $MDO301:
 34336                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34337 0000547D 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34338                                  	;mov	al,[si+0Ah]
 34339                                  
 34340                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34341 00005480 8887[5387]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34342                                  	; 03/05/2023
 34343                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34344                                  
 34345 00005484 43                      	inc	bx				;;AN000;;
 34346 00005485 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
 34347 00005488 7503                    	jne	short $MIF302			;;AN000;; No
 34348                                  						;;AN000;; Yes
 34349 0000548A E84AFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34350                                  $MIF302:
 34351 0000548D FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34352 0000548F 75EC                    	jnz	short $MDO301			;;AN000;;
 34353                                  $MIF300:
 34354                                  $MIF299:
 34355                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34356 00005491 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34357                                  	;test	byte [si+7],0Fh			;;AN000;;
 34358 00005495 7506                    	jnz	short $MIF307
 34359                                  	
 34360                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34361 00005497 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34362                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
 34363                                  	; 11/04/2023
 34364                                  	;jz	short $MIF307			;;AN000;;
 34365                                  	;jmp	short $MEN307			;;AN000;;
 34366 0000549B 750C                    	jnz	short $MEN307
 34367                                  $MIF307:
 34368 0000549D 08D2                    	or	dl,dl				;;AN000;;
 34369 0000549F 7408                    	jz	short $MIF309			;;AN000;;
 34370                                  $MDO310:
 34371 000054A1 8F06[4D87]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34372                                  	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
 34373 000054A5 FECA                    	dec	dl				;;AN000;; Are we done?
 34374 000054A7 75F8                    	jnz	short $MDO310
 34375                                  $MIF309:
 34376                                  $MEN307:
 34377 000054A9 E82BFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
 34378 000054AC 55                      	push	bp				;;AN000;; Restore the return address
 34379 000054AD C3                      	retn					;;AN000;;
 34380                                  
 34381                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34382                                  ;;
 34383                                  ;;	PROC NAME: $M_CHAR_REPLACE
 34384                                  ;;
 34385                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
 34386                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34387                                  ;;		ES:DI contains the VALUE from SUBLIST
 34388                                  ;;	OUTPUTS: CX contains number of characters on stack
 34389                                  ;;		 Top of stack  --> Last character
 34390                                  ;;					. . .
 34391                                  ;;		 Bot of stack  --> First character
 34392                                  ;;
 34393                                  ;;	OTHER REGS Revised: AX
 34394                                  ;;
 34395                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34396                                  
 34397                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34398                                  
 34399                                  $M_CHAR_REPLACE:
 34400 000054AE 5D                      	pop	bp				;;AN000;; Save return address
 34401                                  	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
 34402 000054AF F6440730                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
 34403                                  	;test	byte [si+7],30h			;;AN000;; Was Character specified?
 34404 000054B3 7512                    	jnz	short $MIF317			;;AN000;; No
 34405 000054B5 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34406 000054B8 50                      	push	ax				;;AN000;; Put it on the stack
 34407 000054B9 41                      	inc	cx				;;AN000;; Increase the count
 34408 000054BA E88BFD                  	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
 34409 000054BD 7306                    	jnc	short $MIF318
 34410 000054BF 268A4501                	mov	al,[es:di+1]			;;AN000;; Get the next character
 34411 000054C3 50                      	push	ax				;;AN000;; Put it on the stack
 34412 000054C4 F8                      	clc					;;AN000;; Clear the carry
 34413                                  $MIF318:
 34414 000054C5 EB0D                    	jmp	short $MEN317
 34415                                  $MIF317:
 34416                                  $MDO321:
 34417 000054C7 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34418 000054CA 08C0                    	or	al,al				;;AN000;; Is it the NULL?
 34419 000054CC 7404                    	jz	short $MEN321			;;AN000;; Yes
 34420 000054CE 47                      	inc	di				;;AN000;; Next character
 34421 000054CF 41                      	inc	cx				;;AN000;; Increment the count
 34422 000054D0 EBF5                    	jmp	short $MDO321
 34423                                  $MEN321:
 34424 000054D2 29CF                    	sub	di,cx				;;AN000;; Set DI at the beginning of the string
 34425                                  $MEN317:
 34426 000054D4 55                      	push	bp				;;AN000;; Restore return address
 34427 000054D5 C3                      	retn					;;AN000;;	
 34428                                  
 34429                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34430                                  ;;
 34431                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
 34432                                  ;;
 34433                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
 34434                                  ;;		  and prepare to display
 34435                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34436                                  ;;		ES:DI contains the VALUE from SUBLIST
 34437                                  ;;	OUTPUTS: CX contains number of characters on stack
 34438                                  ;;		 Top of stack  --> Last character
 34439                                  ;;					. . .
 34440                                  ;;		 Bot of stack  --> First character
 34441                                  ;;	OTHER REGS Revised: BX,DX,AX
 34442                                  ;;
 34443                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34444                                  
 34445                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34446                                  
 34447                                  $M_BIN2ASC_REPLACE:
 34448 000054D6 5D                      	pop	bp				;;AN000;; Save return address
 34449 000054D7 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34450 000054D9 31C0                    	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
 34451 000054DB C706[5187]1000          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
 34452                                  	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor
 34453                                  
 34454 000054E1 31DB                    	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)
 34455                                  
 34456                                  	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
 34457 000054E3 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 34458                                  	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
 34459 000054E7 7511                    	jnz	short $MIF325			;;AN000;; No
 34460                                  	
 34461 000054E9 268A05                  	mov	al,[es:di]			;;AN000;; Setup byte in AL
 34462                                  
 34463                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34464 000054EC F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34465                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
 34466 000054F0 753D                    	jnz	short $MIF326			;;AN000;; No
 34467                                  			 
 34468 000054F2 A880                    	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
 34469 000054F4 7433                    	jz	short $MIF327			;;AN000;; No
 34470                                  						;;AN000;; Yes				
 34471                                  	; 12/04/2023
 34472                                  	;inc	bx				;;AN000;; Remember that it was negative
 34473 000054F6 247F                    	and	al,01111111b			;;AN000;; Make it positive
 34474                                  
 34475                                  	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
 34476                                  	;jmp	short $MIF327
 34477 000054F8 EB2E                    	jmp	short $MIF350 ; inc bx
 34478                                  
 34479                                  ; 12/04/2023
 34480                                  %if 0
 34481                                  
 34482                                  $MIF327:
 34483                                  $MIF335:	; 12/04/2023
 34484                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34485                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34486                                  $MIF326:
 34487                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34488                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34489                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34490                                  	jnz	short $MIF330			;;AN000;; No
 34491                                  						;;AN000;; Yes
 34492                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34493                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34494                                  $MIF330:
 34495                                  	jmp	short $MEN325
 34496                                  
 34497                                  %endif
 34498                                  
 34499                                  $MIF325:
 34500                                  	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
 34501 000054FA F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34502                                  	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
 34503 000054FE 7513                    	jnz	short $MIF333			;;AN000;; No
 34504                                  						;;AN000;; Yes
 34505 00005500 268B05                  	mov	ax,[es:di]			;;AN000;; Setup byte in AL
 34506                                  
 34507                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34508 00005503 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34509                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 34510 00005507 7526                    	jnz	short $MIF334			;;AN000;; No
 34511                                  						;;AN000;; Yes
 34512 00005509 F6C480                  	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
 34513 0000550C 741B                    	jz	short $MIF335			;;AN000;; No
 34514                                  						;;AN000;; Yes
 34515                                  	; 12/04/2023
 34516                                  	;inc	bx				;;AN000;; Remember that it was negative
 34517 0000550E 80E47F                  	and	ah,01111111b			;;AN000;; Make it positive
 34518                                  
 34519                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 34520                                  	;jmp	short $MIF335
 34521 00005511 EB15                    	jmp	short $MIF350 ; inc bx
 34522                                  
 34523                                  ; 12/04/2023
 34524                                  %if 0
 34525                                  
 34526                                  $MIF335:
 34527                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34528                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34529                                  $MIF334:
 34530                                  	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
 34531                                  	jnz	short $MIF338
 34532                                  
 34533                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34534                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34535                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34536                                  	jnz	short $MIF338			;;AN000;; No
 34537                                  						;;AN000;; Yes
 34538                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34539                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34540                                  $MIF338:
 34541                                  	jmp	short $MEN333			;;AN000;;
 34542                                  %endif
 34543                                  
 34544                                  $MIF333:
 34545 00005513 268B05                  	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
 34546 00005516 268B5502                	mov	dx,[es:di+2]			;;AN000;;
 34547                                  
 34548                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34549 0000551A F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34550                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 34551 0000551E 750F                    	jnz	short $MIF341			;;AN000;; No
 34552                                  						;;AN000;; Yes
 34553 00005520 F6C680                  	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
 34554 00005523 7404                    	jz	short $MIF342			;;AN000;; No
 34555                                  						;;AN000;; Yes
 34556                                  	; 12/04/2023
 34557                                  	;inc	bx				;;AN000;; Remember that it was negative
 34558 00005525 80E67F                  	and	dh,01111111b			;;AN000;; Make it positive
 34559                                  	
 34560                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 34561                                  $MIF350:
 34562 00005528 43                      	inc	bx
 34563                                  $MIF342:
 34564                                  	; 12/04/2023
 34565                                  $MIF327:
 34566                                  $MIF335:
 34567 00005529 C706[5187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34568                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34569                                  $MIF341:
 34570                                  $MIF326:
 34571                                  	; 18/04/2023
 34572                                  $MIF334:
 34573                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34574 0000552F F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34575                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34576 00005533 7506                    	jnz	short $MIF345			;;AN000;; No
 34577                                  						;;AN000;; Yes
 34578 00005535 C706[5187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34579                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34580                                  $MIF345:
 34581                                  $MEN333:
 34582                                  $MEN325:
 34583 0000553B E82EFD                  	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string
 34584                                  
 34585 0000553E 09DB                    	or	bx,bx				;;AN000;; Was number negative?
 34586 00005540 7405                    	jz	short $MIF349			;;AN000;; No
 34587                                  						;;AN000;; Yes
 34588 00005542 31D2                    	xor	dx,dx				;;AN000;;
 34589 00005544 B22D                    	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
 34590 00005546 52                      	push	dx				;;AN000;;
 34591                                  $MIF349:
 34592 00005547 55                      	push	bp				;;AN000;; Restore return address
 34593 00005548 C3                      	retn					;;AN000;; Return
 34594                                  
 34595                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34596                                  ;;
 34597                                  ;;	PROC NAME: $M_DATE_REPLACE
 34598                                  ;;
 34599                                  ;;	FUNCTION: Convert a date to a decimal ASCII string using current
 34600                                  ;;		  country format and prepare to display
 34601                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34602                                  ;;		ES:DI points at VALUE from SUBLIST
 34603                                  ;;	OUTPUTS: CX contains number of characters on stack
 34604                                  ;;		 Top of stack  --> Last character
 34605                                  ;;					. . .
 34606                                  ;;		 Bot of stack  --> First character
 34607                                  ;;	OTHER REGS Revised: DX,AX
 34608                                  ;;
 34609                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34610                                  
 34611                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34612                                  $M_DATE_REPLACE:
 34613 00005549 5D                      	pop	bp				;;AN000;; Save return address
 34614                                  
 34615 0000554A C706[5187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34616                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 34617                                  	
 34618 00005550 E86700                  	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
 34619                                  						;;AN000;; All O.K.?
 34620 00005553 31D2                    	xor	dx,dx				;;AN000;; Reset DX value
 34621                                  	; 12/04/2023
 34622                                  	;xor	ax,ax				;;AN000;; Reset AX value
 34623                                  	
 34624                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
 34625                                  	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
 34626                                  	;jne	short $MIF351
 34627                                  	; 12/04/2023
 34628 00005555 A1[5387]                	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 34629 00005558 09C0                    	or	ax,ax
 34630 0000555A 751D                    	jnz	short $MIF351
 34631                                  
 34632 0000555C E87200                  	call	$M_YEAR				;;AN000;; Get Year
 34633 0000555F E88100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34634                                  
 34635 00005562 FF36[5E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34636                                  	;push	word [$M_RT+87]			;;AN000;;
 34637                                  	
 34638 00005566 41                      	inc	cx				;;AN000;; Increment count
 34639 00005567 31C0                    	xor	ax,ax				;;AN000;; Reset AX value
 34640                                  
 34641 00005569 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34642                                  	;mov	al,[si+5]			;;AN000;; Get Day
 34643 0000556C E87400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34644                                  	
 34645 0000556F FF36[5E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34646                                  	;push	word [$M_RT+87]			;;AN000;;
 34647                                  
 34648 00005573 41                      	inc	cx				;;AN000;; Increment count
 34649 00005574 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34650                                  	;mov	al,[si+4]			;;AN000;; Get Month
 34651                                  	; 12/04/2023
 34652                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34653 00005577 EB3C                    	jmp	short $MIF354 ; **
 34654                                  $MIF351:
 34655                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
 34656                                  	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
 34657                                  	;jne	short $MIF353
 34658                                  	; 12/04/2023
 34659                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 34660 00005579 48                      	dec	ax 
 34661 0000557A 751D                    	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1
 34662                                  
 34663 0000557C E85200                  	call	$M_YEAR				;;AN000;; Get Year
 34664 0000557F E86100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34665                                  
 34666 00005582 FF36[5E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34667                                  	;push	word [$M_RT+87]			;;AN000;;
 34668                                  	
 34669 00005586 41                      	inc	cx				;;AN000;; Increment count
 34670 00005587 31C0                    	xor	ax,ax				;;AN000;; Reset AX
 34671                                  
 34672 00005589 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34673                                  	;mov	al,[si+4]			;;AN000;; Get Month
 34674 0000558C E85400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34675                                  
 34676 0000558F FF36[5E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34677                                  	;push	word [$M_RT+87]			;;AN000;;
 34678                                  
 34679 00005593 41                      	inc	cx				;;AN000;;
 34680                                  	      
 34681 00005594 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34682                                  	;mov	al,[si+5]			;;AN000;; Get Day
 34683                                  
 34684                                  	; 12/04/2023
 34685                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34686 00005597 EB1C                    	jmp	short $MIF354 ; **
 34687                                  	; 12/04/2023
 34688                                  $MIF352:
 34689                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
 34690 00005599 48                      	dec	ax
 34691                                  	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
 34692                                  	;xor	ax,ax
 34693                                  	;jmp	short $MIF355
 34694                                  	; 12/04/2023
 34695 0000559A 751C                    	jnz	short $MIF355
 34696                                  $MIF353:
 34697                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
 34698                                  	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
 34699                                  	;jne	short $MIF355
 34700                                  
 34701 0000559C 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34702                                  	;mov	al,[si+5]			;;AN000;; Get Day
 34703 0000559F E84100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34704                                  	
 34705 000055A2 FF36[5E87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34706                                  	;push	word [$M_RT+87]			;;AN000;;
 34707                                  
 34708 000055A6 41                      	inc	cx				;;AN000;;
 34709                                  
 34710 000055A7 8A4404                  	 mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34711                                  	;mov	al,[si+4]			;;AN000;; Get Month
 34712 000055AA E83600                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34713                                  	
 34714 000055AD FF36[5E87]              	 push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34715                                  	;push	word [$M_RT+87]			;;AN000;;
 34716                                  	
 34717 000055B1 41                      	inc	cx				;;AN000;;
 34718                                  
 34719 000055B2 E81C00                  	call	$M_YEAR				;;AN000;; Get Year
 34720                                  	; 12/04/2023
 34721                                  $MIF354:
 34722 000055B5 E82B00                  	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
 34723                                  $MIF355:
 34724 000055B8 55                      	push	bp				;;AN000;; Restore return address
 34725 000055B9 C3                      	retn					;;AN000;; Return
 34726                                  
 34727                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34728                                  ;;
 34729                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34730                                  
 34731                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34732                                  $M_GET_DATE:
 34733                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 34734                                  	;mov	al,0 				;;AN000;; Get current country info
 34735                                  	; 12/04/2023
 34736 000055BA B80038                  	mov	ax,3800h
 34737                                  	;
 34738 000055BD 8D16[5387]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34739                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 34740 000055C1 CD21                    	int	21h				;;AN000;;
 34741 000055C3 730B                    	jnc	short $MIF357
 34742                                  	;
 34743 000055C5 C706[5387]0000          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
 34744                                  	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
 34745 000055CB C606[5E87]2D            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
 34746                                  	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
 34747                                  $MIF357:
 34748 000055D0 C3                      	retn					;;AN000;;
 34749                                  
 34750                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34751                                  ;;
 34752                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34753                                  
 34754                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34755                                  $M_YEAR:
 34756 000055D1 8B4402                  	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34757                                  	;mov	ax,[si+2]			;;AN000;; Get Year
 34758                                  
 34759                                  	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
 34760 000055D4 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34761                                  	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
 34762 000055D8 7508                    	jnz	short $MIF359			;;AN000;; No
 34763                                  						;;AN000;; Yes
 34764 000055DA 83F863                  	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 34765 000055DD 7603                    	jna	short $MIF360			;;AN000;;
 34766 000055DF B86300                  	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 34767                                  $MIF360:
 34768                                  $MIF359:
 34769 000055E2 C3                      	retn					;;AN000;;
 34770                                  
 34771                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34772                                  ;;
 34773                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34774                                  
 34775                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34776                                  $M_CONVERTDATE:
 34777                                  $M_CONVERTTIME: ; *!*!  ; 12/04/2023
 34778 000055E3 8F06[5387]              	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34779                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 34780 000055E7 880E[4987]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 34781                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 34782 000055EB E87EFC                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 34783 000055EE 49                      	dec	cx				;;AN000;; Test if size only grew by 1
 34784 000055EF 3A0E[4987]              	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 34785 000055F3 7505                    	jne	short $MIF363			;;AN000;; No
 34786 000055F5 B83000                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 34787 000055F8 50                      	push	ax				;;AN000;; Save it
 34788 000055F9 41                      	inc	cx				;;AN000;; Count it
 34789                                  $MIF363:
 34790 000055FA 41                      	inc	cx				;;AN000;; Restore CX
 34791 000055FB FF36[5387]              	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34792                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 34793 000055FF C3                      	retn
 34794                                  
 34795                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34796                                  ;;
 34797                                  ;;	PROC NAME: $M_TIME_REPLACE
 34798                                  ;;
 34799                                  ;;	FUNCTION: Convert a time to a decimal ASCII string
 34800                                  ;;		  and prepare to display
 34801                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34802                                  ;;		ES:DI points at VALUE from SUBLIST
 34803                                  ;;	OUTPUTS: CX contains number of characters on stack
 34804                                  ;;		 Top of stack  --> Last character
 34805                                  ;;					. . .
 34806                                  ;;		 Bot of stack  --> First character
 34807                                  ;;	REGS USED: BP,CX,AX
 34808                                  ;;
 34809                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34810                                  
 34811                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM							     ;;
 34812                                  $M_TIME_REPLACE:
 34813 00005600 5D                      	pop	bp				;;AN000;; Save return address
 34814                                  
 34815 00005601 C706[5187]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34816                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 34817                                  
 34818 00005607 E87800                  	call	$M_GET_TIME			;;AN000;; All O.K.?
 34819                                  
 34820                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 34821 0000560A F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
 34822                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 34823 0000560E 741A                    	jz	short $MIF365			;;AN000;; No
 34824                                  						;;AN000;; Yes
 34825 00005610 803E[6487]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 34826                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 34827 00005615 7513                    	jne	short $MIF366			;;AN000;; No
 34828                                  						;;AN000;; Yes
 34829 00005617 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34830                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 34831 0000561A 3C0C                    	cmp	al,12				;;AN000;; Is hour 12 or less?
 34832 0000561C 7C04                    	jl	short $MLL367 ; jnge		;;AN000;; Yes	
 34833 0000561E 3C17                    	cmp	al,23				;;AN000;; Is hour 24 or greater?
 34834 00005620 7E04                    	jng	short $MIF367 ; jle		;;AN000;; No
 34835                                  $MLL367:
 34836 00005622 B061                    	mov	al,'a'	; $M_AM			;;AN000;;
 34837                                  	;push	ax				;;AN000;; Push an "a" to represent AM.
 34838                                  	;inc	cx				;;AN000;;
 34839                                  	;jmp	short $MEN367			;;AN000;;
 34840                                  	; 12/04/2023
 34841 00005624 EB02                    	jmp	short $MEN367 ; *
 34842                                  $MIF367:
 34843 00005626 B070                    	mov	al,'p'	; $M_PM			;;AN000;;
 34844                                  $MEN367:	; * ; 12/04/2023
 34845 00005628 50                      	push	ax				;;AN000;; Push an "p" to represent PM.
 34846 00005629 41                      	inc	cx				;;AN000;;
 34847                                  ;$MEN367:
 34848                                  $MIF366:
 34849                                  $MIF365:					;;AN000;;
 34850 0000562A 31C0                    	xor	ax,ax				;;AN000;;
 34851 0000562C 31D2                    	xor	dx,dx				;;AN000;;
 34852                                  	
 34853                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 34854 0000562E F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 34855                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 34856 00005632 740B                    	jz	short $MIF372			;;AN000;;
 34857                                  
 34858 00005634 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34859                                  	;mov	al,[si+5]			;;AN000;; Get Hundreds
 34860 00005637 E8A9FF                  	call	$M_CONVERTTIME			;;AN000;;
 34861                                  
 34862 0000563A FF36[5C87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
 34863                                  	;push	word [$M_RT+85]			;;AN000;;
 34864 0000563E 41                      	inc	cx				;;AN000;;
 34865                                  $MIF372:
 34866                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 34867 0000563F F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 34868                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 34869 00005643 7506                    	jnz	short $MLL374			;;AN000;; No
 34870                                  
 34871                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
 34872 00005645 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34873                                  	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
 34874 00005649 740B                    	jz	short $MIF374			;;AN000;; No
 34875                                  $MLL374:
 34876 0000564B 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34877                                  	;mov	al,[si+4]			;;AN000;; Get Seconds
 34878 0000564E E892FF                  	call	$M_CONVERTTIME			;;AN000;;
 34879                                  
 34880 00005651 FF36[6087]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 34881                                  	;push	word [$M_RT+89]			;;AN000;;
 34882 00005655 41                      	inc	cx				;;AN000;;
 34883                                  $MIF374:	;;  Do Hour/Min (12 Hour)
 34884 00005656 8A4403                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
 34885                                  	;mov	al,[si+3]			;;AN000;; Get Minutes
 34886 00005659 E887FF                  	call	$M_CONVERTTIME			;;AN000;;
 34887                                  
 34888 0000565C FF36[6087]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 34889                                  	;push	word [$M_RT+89]			;;AN000;;
 34890 00005660 41                      	inc	cx				;;AN000;;
 34891                                  
 34892 00005661 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34893                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 34894                                  
 34895                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 34896 00005664 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
 34897                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 34898 00005668 7413                    	jz	short $MIF376			;;AN000;; No
 34899                                  
 34900 0000566A 803E[6487]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 34901                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 34902 0000566F 750C                    	jne	short $MIF377			;;AN000;; No
 34903                                  
 34904 00005671 3C0D                    	cmp	al,13				;;AN000;; Is hour less than 12?
 34905 00005673 7C02                    	jnge	short $MIF378 ; jl
 34906 00005675 2C0C                    	sub	al,12				;;AN000;; Set to a 12 hour value
 34907                                  $MIF378:
 34908                                  	;cmp	al,0				;;AN000;; Is hour less than 12?
 34909                                  	;jne	short $MIF380			;;AN000;; No
 34910                                  	; 12/04/2023
 34911 00005677 20C0                    	and	al,al
 34912 00005679 7502                    	jnz	short $MIF380	
 34913 0000567B B00C                    	mov	al,12				;;AN000;; Set to a 12 hour value
 34914                                  $MIF380:
 34915                                  $MIF377:
 34916                                  $MIF376:
 34917 0000567D E8ECFB                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
 34918 00005680 55                      	push	bp				;;AN000;; Restore return address
 34919 00005681 C3                      	retn					;;AN000;; Return
 34920                                  
 34921                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34922                                  ;;
 34923                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34924                                  
 34925                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34926                                  $M_GET_TIME:
 34927                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 34928                                  	;mov	al,0 				;;AN000;; Get current country info
 34929                                  	; 12/04/2023
 34930 00005682 B80038                  	mov	ax,3800h
 34931                                  	;
 34932 00005685 8D16[5387]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34933                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 34934 00005689 CD21                    	int	21h				;;AN000;;
 34935 0000568B 7310                    	jnc	short $MIF384
 34936                                  
 34937 0000568D C706[6487]0100          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
 34938                                  	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
 34939 00005693 C606[6087]3A            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
 34940                                  	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
 34941 00005698 C606[5C87]2E            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
 34942                                  	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
 34943                                  $MIF384:
 34944 0000569D C3                      	retn					;;AN000;;
 34945                                  
 34946                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34947                                  ;;
 34948                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34949                                  
 34950                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34951                                  
 34952                                  ; 12/04/2023 
 34953                                  ;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
 34954                                  %if 0
 34955                                  $M_CONVERTTIME:
 34956                                  $M_CONVERTDATE: ; *!*!  ; 12/04/2023
 34957                                  	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34958                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 34959                                  	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 34960                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 34961                                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 34962                                  	dec	cx				;;AN000;; Test if size only grew by 1
 34963                                  	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 34964                                  	jne	short $MIF386			;;AN000;; No
 34965                                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 34966                                  	push	ax				;;AN000;; Save it
 34967                                  	inc	cx				;;AN000;; Count itount it
 34968                                  $MIF386:
 34969                                  	inc	cx				;;AN000;; Restore CX
 34970                                  	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34971                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 34972                                  	retn
 34973                                  %endif
 34974                                  
 34975                                  ; ----------------------------
 34976                                  ; MSDOS 6.0, TPRINTF.ASM, 1991
 34977                                  ; ----------------------------
 34978                                  ; include msgdcl.inc
 34979                                  ; ----------------------------
 34980                                  
 34981                                  ;============================================================================
 34982                                  ; LOADHIGH.ASM, MSDOS 6.0, 1991
 34983                                  ;============================================================================
 34984                                  ; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34985                                  
 34986                                  ; This is a new module added to support loading programs into UMBs provided
 34987                                  ; by DOS 5.0. 
 34988                                  ; ---------------------------------------------------------------------------
 34989                                  ; Usage:
 34990                                  ;
 34991                                  ; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
 34992                                  ;
 34993                                  ; <filespec> has to be a filename that is not wildcarded.
 34994                                  
 34995                                  ; ---------------------------------------------------------------------------
 34996                                  ;
 34997                                  ;	Revision History
 34998                                  ;	================
 34999                                  ;
 35000                                  ;	M009	SR	08/01/90	Set flags to indicate that we are
 35001                                  ;				loading and high and also remember
 35002                                  ;				current UMB state.
 35003                                  ;
 35004                                  ;	M016	SR	08/09/90	Give special error message on attempt
 35005                                  ;				to loadhigh batch files and invalid
 35006                                  ;				filename on Loadhigh command line.
 35007                                  ;
 35008                                  ;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
 35009                                  ;				after the program name also as part
 35010                                  ;				of the command line being passed to
 35011                                  ;				the program to be invoked.
 35012                                  ;
 35013                                  ; ---------------------------------------------------------------------------
 35014                                  
 35015                                  ; ---------------------------------------------------------------------------
 35016                                  ;
 35017                                  ;	include highload.inc		; Grab code for ParseVar and such
 35018                                  
 35019                                  iCmdLine	equ	81h		; PSP:81h points to command-line
 35020                                  
 35021                                  ;
 35022                                  ; ---------------------------------------------------------------------------
 35023                                  
 35024                                  ;****	LoadHigh -- Main routine for Loadhigh command
 35025                                  ;
 35026                                  ;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
 35027                                  ;		CS = DS = SS = TRANGROUP
 35028                                  ;
 35029                                  ;	EXIT	None
 35030                                  ;
 35031                                  ;	USED	ax, bx, cx, dx, si, di, es
 35032                                  ;
 35033                                  ;	ERROR EXITS
 35034                                  ;		Message pointers are setup at the error locations and then
 35035                                  ;	we jump back to CERROR which is the transient error recycle point.
 35036                                  ;	Apart from parse errors, the other errors handled are too many
 35037                                  ;	switches anf invalid filenames.
 35038                                  ;
 35039                                  ;	EFFECTS
 35040                                  ;		The allocation strategy and the state of the arena chain are
 35041                                  ;	put in the requested state according to the given options. If a 
 35042                                  ;	filename is also given, it is executed as well.
 35043                                  ; ---------------------------------------------------------------------------
 35044                                  
 35045                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35046                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
 35047                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35048                                  LoadHigh:
 35049 0000569E 1E                      	push	ds
 35050 0000569F 07                      	pop	es
 35051                                  
 35052 000056A0 E86B00                  	call	SkipLhDelims
 35053                                  
 35054                                  ;Get command tail to be passed to the program. This includes any whitespace
 35055                                  ;chars between the program name and its parameters as well.
 35056                                  ;On return, ds:si points at the start of the command tail.
 35057                                  
 35058 000056A3 56                      	push	si
 35059 000056A4 E81400                  	call	ParseLhCmd
 35060 000056A7 5E                      	pop	si
 35061 000056A8 720E                    	jc	short LhErr
 35062                                  	
 35063 000056AA E87900                  	call	SetupCmdLine		;setup pgm's command line
 35064                                  
 35065 000056AD E8CC00                  	call	SetupPath		;setup path for file
 35066 000056B0 7206                    	jc	short LhErr		;file not found
 35067                                  
 35068                                  ;Set allocation strategy to HighFirst and link in UMBs for exec. This will
 35069                                  ;be reset after return from the Exec
 35070                                  ;We will also set a resident flag to indicate that UMBs were activated for
 35071                                  ;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
 35072                                  
 35073 000056B2 E8AA00                  	call	HideUMBs		;prepare upper-memory for load
 35074                                  
 35075 000056B5 E96FD2                  	jmp	LH_EXECUTE		;go and exec file ;M051
 35076                                  
 35077                                  LhErr:
 35078                                  ;The error message has been setup at this stage
 35079                                  
 35080 000056B8 E9BFD2                  	jmp	cerror			;print error message and recycle 
 35081                                  
 35082                                  ; ---------------------------------------------------------------------------
 35083                                  					
 35084                                  ;*** 	ParseLhCmd - parses any command-line options
 35085                                  ;
 35086                                  ;	ENTRY	None
 35087                                  ;
 35088                                  ;	EXIT	Carry clear -- command line parsed successfully
 35089                                  ;		Carry set -- appropriate error message setup
 35090                                  ;
 35091                                  ;	USED	ax, si
 35092                                  ;
 35093                                  ;	EFFECTS
 35094                                  ;		Options set up (see highvar.inc)
 35095                                  ;		Filename to be executed setup
 35096                                  ;
 35097                                  ;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
 35098                                  ;	then calls ParseVar itself to actually parse the commmand-line.  On
 35099                                  ;	return from ParseVar, DS:SI will point to the beginning of the child
 35100                                  ;	module's name on the command-line; thus it calls LhCopyFilename to
 35101                                  ;	prepare the command-line for that program.
 35102                                  ; ---------------------------------------------------------------------------
 35103                                  
 35104                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35105                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
 35106                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35107                                  ParseLhCmd:
 35108                                  	;mov	si,81h
 35109 000056BB BE8100                  	mov	si,iCmdLine	;ds:si points at command line
 35110                                  
 35111 000056BE C706[F78A]0000          	mov	word [COMSW],0
 35112 000056C4 BF[1C86]                	mov	di,Parse_LoadHi
 35113 000056C7 31C9                    	xor	cx,cx
 35114 000056C9 E812CB                  	call	Parse_With_Msg
 35115 000056CC 83F8FF                  	cmp	ax,0FFFFh ; -1
 35116 000056CF 740A                    	jz	short PLhCmd2
 35117 000056D1 83F800                  	cmp	ax,0
 35118 000056D4 7504                    	jnz	short PLhCmd1
 35119 000056D6 89D3                    	mov	bx,dx
 35120                                  	; 14/04/2023
 35121                                  	;call	LhCopyFilename
 35122                                  	;; 13/04/2023
 35123                                  	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
 35124                                  	;;jmp	short PLhCmd2
 35125                                  	;retn
 35126                                  	; 14/04/2023
 35127 000056D8 EB02                    	jmp	short LhCopyFilename
 35128                                  PLhCmd1:
 35129 000056DA F9                      	stc
 35130                                  PLhCmd2:
 35131 000056DB C3                      	retn
 35132                                  
 35133                                  ; ---------------------------------------------------------------------------
 35134                                  
 35135                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35136                                  
 35137                                  ; ---------------------------------------------------------------------------
 35138                                  ; HIGHlOAD.INC, MSDOS 6.0, 1992
 35139                                  ; ---------------------------------------------------------------------------
 35140                                  
 35141                                  	; 13/04/2023
 35142                                  	; MSDOS 5.0 COMMAND.COM only !
 35143                                  	; (Procedure names are not from original Microsoft source code!)
 35144                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35145                                  ;set_strategy:
 35146                                  	;mov	ax,5800h	; DOS_CHECK_STRATEGY
 35147                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35148                                  	;		; AL = function code: get allocation strategy
 35149                                  	;mov	bx,ax
 35150                                  	;or	bx,80h
 35151                                  	;mov	ax,5801h	; DOS_SET_STRATEGY
 35152                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35153                                  	;		; AL = function code: set allocation strategy
 35154                                  	;retn
 35155                                  
 35156                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35157                                  ;set_umblink:
 35158                                  	;mov	ax,5803h	; DOS_SET_UMBLINK
 35159                                  	;mov	bx,1
 35160                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35161                                  	;		; AL = function code: (DOS 5beta) set UMB link state
 35162                                  	;retn
 35163                                  
 35164                                  ; ---------------------------------------------------------------------------
 35165                                  
 35166                                  ;***	LhCopyFilename -- copy filename from command line to buffer
 35167                                  ;
 35168                                  ;	ENTRY	ds:si points at primary argument (filename)
 35169                                  ;
 35170                                  ;	EXIT	Carry set -- filename has wildcards.  In this event, DX will
 35171                                  ;				already contain an appropriate error number.
 35172                                  ;		Carry clear -- filename has been copied as needed; DS:SI
 35173                                  ;				points to first character (most likely space)
 35174                                  ;				after filename.
 35175                                  ;
 35176                                  ;	USED	ax, si
 35177                                  ;
 35178                                  ;	EFFECTS
 35179                                  ;		ExecPath contains the filename
 35180                                  ;
 35181                                  ; If there are any wildcards in the filename, then we have an error
 35182                                  ; ---------------------------------------------------------------------------
 35183                                  
 35184                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35185                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
 35186                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35187                                  LhCopyFilename:
 35188 000056DC 1E                      	push	ds
 35189 000056DD 56                      	push	si
 35190 000056DE 57                      	push	di
 35191 000056DF C57704                  	lds	si,[bx+4]
 35192 000056E2 BF[088A]                	mov	di,EXECPATH
 35193                                  lhcpfn1:
 35194 000056E5 AC                      	lodsb
 35195 000056E6 3C2A                    	cmp	al,2Ah ; '*'
 35196 000056E8 740D                    	jz	short lhfilerr
 35197 000056EA 3C3F                    	cmp	al,3Fh ; '?'
 35198 000056EC 7409                    	jz	short lhfilerr
 35199 000056EE AA                      	stosb
 35200 000056EF 08C0                    	or	al,al
 35201 000056F1 75F2                    	jnz	short lhcpfn1
 35202                                  	; 14/04/2023
 35203                                  	; cf = 0
 35204                                  	;clc
 35205                                  lhfilerr2:
 35206 000056F3 5F                      	pop	di
 35207 000056F4 5E                      	pop	si
 35208 000056F5 1F                      	pop	ds
 35209 000056F6 C3                      	retn
 35210                                  lhfilerr:
 35211 000056F7 BA[DF81]                	mov	dx,LhInvFil_Ptr
 35212 000056FA F9                      	stc
 35213 000056FB EBF6                    	jmp	short lhfilerr2
 35214                                  
 35215                                  ; ---------------------------------------------------------------------------
 35216                                  	
 35217                                  	; 14/04/2023
 35218                                  	; 13/04/2023
 35219                                  	; MSDOS 5.0 COMMAND.COM only !
 35220                                  	; (Procedure name is not from original Microsoft source code!)
 35221                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35222                                  set_strategy:
 35223 000056FD B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35224 00005700 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35225                                  			; AL = function code: get allocation strategy
 35226 00005702 89C3                    	mov	bx,ax
 35227 00005704 81CB8000                	or	bx,80h
 35228 00005708 B80158                  	mov	ax,5801h	; DOS_SET_STRATEGY
 35229 0000570B CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35230                                  			; AL = function code: set allocation strategy
 35231 0000570D C3                      	retn
 35232                                  
 35233                                  ; ---------------------------------------------------------------------------
 35234                                  
 35235                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35236                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
 35237                                  	; MSDOS 5.0 COMMAND.COM only !
 35238                                  	; (Procedure name is not from original Microsoft source code!)
 35239                                  SkipLhDelims:
 35240 0000570E BE8100                  	mov	si,81h
 35241 00005711 E8F2CE                  	call	scanoff
 35242                                  stfn1:
 35243 00005714 AC                      	lodsb
 35244 00005715 E8F6CE                  	call	DELIM
 35245 00005718 740A                    	jz	short stfn2
 35246 0000571A 3C0D                    	cmp	al,0Dh
 35247 0000571C 7406                    	jz	short stfn2
 35248 0000571E 3A06[E48A]              	cmp	al,[SWITCHAR]
 35249 00005722 75F0                    	jnz	short stfn1
 35250                                  stfn2:
 35251 00005724 4E                      	dec	si
 35252 00005725 C3                      	retn
 35253                                  
 35254                                  ; ---------------------------------------------------------------------------
 35255                                  
 35256                                  ;***	SetupCmdLine -- prepare command line for the program
 35257                                  ;
 35258                                  ;	ENTRY	{es/ds}:si = points just after the end of the child program
 35259                                  ;
 35260                                  ;	EXIT	None
 35261                                  ;
 35262                                  ;	USED
 35263                                  ;
 35264                                  ;	EFFECTS		
 35265                                  ;		The rest of the command line following the pgm name is 
 35266                                  ;	moved to the top of the command line buffer (at TRANGROUP:81h)
 35267                                  ;	and a new command line length is put in
 35268                                  ; ---------------------------------------------------------------------------
 35269                                  
 35270                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35271                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
 35272                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35273                                  SetupCmdLine:
 35274                                  	;mov	di,81h
 35275 00005726 BF8100                  	mov	di,iCmdLine
 35276 00005729 30C9                    	xor	cl,cl
 35277 0000572B FEC9                    	dec	cl			;just CR means count = 0
 35278                                  SetCmdL1:
 35279 0000572D AC                      	lodsb
 35280 0000572E AA                      	stosb
 35281 0000572F FEC1                    	inc	cl			;update count
 35282                                  	; 14/04/2023
 35283                                  	; * ; MSDOS 6.0 only !
 35284                                  	;or	al, al	; *
 35285                                  	;jz	short SetCmdL2 ; *
 35286 00005731 3C0D                    	cmp	al,0Dh			;carriage return?
 35287 00005733 75F8                    	jnz	short SetCmdL1		;no, continue storing
 35288                                  SetCmdL2:
 35289 00005735 26880E8000              	mov	[es:80h],cl		;store new cmd line length
 35290 0000573A C3                      	retn
 35291                                  
 35292                                  ; ---------------------------------------------------------------------------
 35293                                  
 35294                                  ;***	LhSetupErrMsg -- Sets up error messages
 35295                                  ;
 35296                                  ;	ENTRY	ax = error message number
 35297                                  ;
 35298                                  ;	EXIT	None
 35299                                  ;
 35300                                  ;	USED	dx
 35301                                  ;
 35302                                  ;	EFFECTS
 35303                                  ;		Everything setup to display error message
 35304                                  ; ---------------------------------------------------------------------------
 35305                                  	
 35306                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35307                                  LhSetupErrMsg:
 35308 0000573B C606[737F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 35309 00005740 BA[757F]                	mov	dx,extend_buf_ptr
 35310 00005743 A3[757F]                	mov	[extend_buf_ptr],ax
 35311 00005746 C3                      	retn
 35312                                  
 35313                                  ; ---------------------------------------------------------------------------
 35314                                  
 35315                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35316                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
 35317                                  	; MSDOS 5.0 COMMAND.COM only !
 35318                                  	; (Procedure name is not from original Microsoft source code!)
 35319                                  check_umblink:
 35320 00005747 B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35321 0000574A CD21                    	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35322                                  			 ; AL = function code: get allocation strategy
 35323 0000574C 88C3                    	mov	bl,al
 35324 0000574E B80258                  	mov	ax,5802h	; DOS_CHECK_UMBLINK
 35325 00005751 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35326                                  			; AL = function code: (DOS 5beta) get UMB link state
 35327 00005753 88C7                    	mov	bh,al
 35328 00005755 93                      	xchg	ax,bx
 35329 00005756 D0C0                    	rol	al,1
 35330 00005758 2401                    	and	al,1
 35331 0000575A D0E4                    	shl	ah,1
 35332 0000575C 08E0                    	or	al,ah
 35333 0000575E C3                      	retn
 35334                                  
 35335                                  ; ---------------------------------------------------------------------------
 35336                                  
 35337                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35338                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
 35339                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35340                                  HideUMBs:
 35341 0000575F 1E                      	push	ds
 35342 00005760 E8E4FF                  	call	check_umblink
 35343 00005763 8E1E[E08A]              	mov	ds,[RESSEG]
 35344 00005767 A2[3A04]                	mov	[fInHigh],al
 35345 0000576A 800E[3A04]80            	or	byte [fInHigh],80h
 35346 0000576F 1F                      	pop	ds
 35347 00005770 E88AFF                  	call	set_strategy
 35348                                  	;call	set_umblink
 35349                                  	;retn
 35350                                  	; 14/04/023
 35351                                  	;jmp	short set_ubmlink
 35352                                  
 35353                                  ; ---------------------------------------------------------------------------
 35354                                  
 35355                                  	; 14/04/2023
 35356                                  	; 13/04/2023
 35357                                  	; MSDOS 5.0 COMMAND.COM only !
 35358                                  	; (Procedure name is not from original Microsoft source code!)
 35359                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35360                                  set_umblink:
 35361 00005773 B80358                  	mov	ax,5803h	; DOS_SET_UMBLINK
 35362 00005776 BB0100                  	mov	bx,1
 35363 00005779 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35364                                  			; AL = function code: (DOS 5beta) set UMB link state
 35365 0000577B C3                      	retn
 35366                                  
 35367                                  ; ---------------------------------------------------------------------------
 35368                                  
 35369                                  ;***	SetupPath -- Do path search for the file to be executed
 35370                                  ;
 35371                                  ;	ENTRY	None
 35372                                  ;
 35373                                  ;	EXIT	Carry set if file not found or not executable file
 35374                                  ;
 35375                                  ;	EFFECTS
 35376                                  ;		ExecPath contains the full path of the file to be executed
 35377                                  ; ---------------------------------------------------------------------------
 35378                                  
 35379                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35380                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
 35381                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35382                                  SetupPath:
 35383                                  
 35384                                  ;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
 35385                                  ;because the path search routine that we are about to invoke expects the
 35386                                  ;filename to search for to be argv[0].
 35387                                  ;
 35388                                  ;If our new argv[0] starts with a switcharacter, it's an option... skip right
 35389                                  ;over it by doing the whole move again (smaller, of course, this time).
 35390                                  
 35391                                  
 35392                                  	;mov	ax,arg.argvcnt		;total number of arguments
 35393                                  	; 14/04/2023
 35394                                  	;mov	ax,[ARG_ARGVCNT]
 35395 0000577C A1[2F91]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 35396                                  
 35397 0000577F 48                      	dec	ax			;less one - skip "LoadHigh"
 35398                                  	;mov	bx,SIZE Argv_ele
 35399 00005780 BB0B00                  	mov	bx,ARGV_ELE.SIZE ; 11
 35400                                  	;mov	bx,11
 35401 00005783 F7E3                    	mul	bx			;dx:ax = size of argument lists
 35402                                  
 35403                                  	; 14/04/2023
 35404 00005785 89C1                    	mov	cx,ax			;size to move
 35405                                  
 35406                                  	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
 35407                                  	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
 35408 00005787 BF[6F8E]                	mov	di,ARG	
 35409 0000578A 89FE                    	mov	si,di			;
 35410                                  	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
 35411 0000578C 83C60B                  	add	si,ARGV_ELE.SIZE ; 11
 35412                                  	
 35413                                  	; 14/04/2023
 35414                                  	;mov	cx,ax
 35415                                  
 35416 0000578F FC                      	cld
 35417 00005790 F3A4                    	rep	movsb			;Move the argument list
 35418                                  	
 35419                                  	;dec	arg.argvcnt		;Fake one less argument, and
 35420                                  	;dec	word [ARG_ARGVCNT]
 35421 00005792 FF0E[2F91]              	dec	word [ARG+ARG_UNIT.argvcnt]
 35422                                  	
 35423                                  ; Done moving... argv[0] is now the child program's name, and [1] its first arg
 35424                                  
 35425 00005796 E817DA                  	call	path_search		;look in the path
 35426                                  
 35427                                  ;ax = 0, no file found
 35428                                  ;ax < 4, batch file found -- cant be executed
 35429                                  ;ax = 4,8 => .com or .exe file found
 35430                                  
 35431 00005799 09C0                    	or	ax,ax			;any file found?
 35432 0000579B 740B                    	jz	short no_exec_file	;no, error
 35433                                  
 35434 0000579D 83F804                  	cmp	ax,4			;executable file?
 35435                                  	;jl	short no_exec_bat	;no, indicate fail ; M016
 35436                                  	;clc
 35437                                  	;retn
 35438                                  	; 14/04/2023
 35439 000057A0 7201                    	jb	short no_exec_bat
 35440 000057A2 C3                      	retn 
 35441                                  
 35442                                  no_exec_bat:
 35443 000057A3 BA[DC81]                	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
 35444 000057A6 EB06                    	jmp	short lhsp_errret	;return error; M016
 35445                                  
 35446                                  no_exec_file:
 35447 000057A8 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 35448 000057AB E88DFF                  	call	LhSetupErrMsg		;setup error message
 35449                                  lhsp_errret:				; M016
 35450 000057AE F9                      	stc
 35451 000057AF C3                      	retn
 35452                                  
 35453                                  ;============================================================================
 35454                                  ; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
 35455                                  ;============================================================================
 35456                                  ; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35457                                  
 35458                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h
 35459                                  
 35460                                  ; ---------------------------------------------------------------------------
 35461                                  ; Class 3 message table/structure
 35462                                  ; ---------------------------------------------------------------------------
 35463                                  
 35464                                  $M_CLASS_3_STRUC:
 35465 000057B0 FF                      	db 0FFh			; $M_CLASS_ID (Class identifer)
 35466 000057B1 0500                    	dw 5			; $M_COMMAND_VER (COMMAND.COM version)
 35467 000057B3 A2                      	db 162			; Total number of messages
 35468                                  $M_ID_3_1:
 35469                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
 35470 000057B4 FC03                    	dw 1020			; Message Number = 1020
 35471 000057B6 8802                    	dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
 35472                                  $M_ID_3_2:
 35473 000057B8 F703                    	dw 1015			; Message Number = 1015
 35474 000057BA 9402                    	dw MSG_1015-$+2 ; 294h  ; Message offset from message number (5A4Ch+0294h=5CE0h)
 35475                                  $M_ID_3_3:	; 26/04/2023
 35476 000057BC EC03B402                	dw 1004,MSG_1004-$ ; 692
 35477 000057C0 0204CA02                	dw 1026,MSG_1026-$ ; 714
 35478 000057C4 0704DA02                	dw 1031,MSG_1031-$ ; 730
 35479 000057C8 0B04E502                	dw 1035,MSG_1035-$ ; 741
 35480 000057CC 2604F002                	dw 1062,MSG_1062-$ ; 752
 35481 000057D0 0404FB02                	dw 1028,MSG_1028-$ ; 763
 35482 000057D4 15041903                	dw 1045,MSG_1045-$ ; 793
 35483 000057D8 11043203                	dw 1041,MSG_1041-$ ; 818
 35484 000057DC 12045003                	dw 1042,MSG_1042-$ ; 848
 35485                                  $M_ID_3_12:
 35486 000057E0 13046703                	dw 1043,MSG_1043-$ ; 871
 35487 000057E4 EA038303                	dw 1002,MSG_1002-$ ; 899
 35488 000057E8 EB03A703                	dw 1003,MSG_1003-$ ; 935
 35489 000057EC EF03BF03                	dw 1007,MSG_1007-$ ; 959
 35490 000057F0 F003D603                	dw 1008,MSG_1008-$ ; 982
 35491 000057F4 F103E803                	dw 1009,MSG_1009-$ ; 1000
 35492 000057F8 F203F903                	dw 1010,MSG_1010-$ ; 1017
 35493 000057FC F3031504                	dw 1011,MSG_1011-$ ; 1045
 35494 00005800 F6032C04                	dw 1014,MSG_1014-$ ; 1068
 35495 00005804 F8033904                	dw 1016,MSG_1016-$ ; 1081
 35496 00005808 F9035F04                	dw 1017,MSG_1017-$ ; 1119
 35497 0000580C FA038004                	dw 1018,MSG_1018-$ ; 1152
 35498                                  $M_ID_3_24:
 35499 00005810 FB039004                	dw 1019,MSG_1019-$ ; 1168
 35500 00005814 FD039804                	dw 1021,MSG_1021-$ ; 1176
 35501 00005818 FE03B204                	dw 1022,MSG_1022-$ ; 1202
 35502 0000581C FF03D504                	dw 1023,MSG_1023-$ ; 1237
 35503 00005820 0004FD04                	dw 1024,MSG_1024-$ ; 1277
 35504 00005824 01041005                	dw 1025,MSG_1025-$ ; 1296
 35505 00005828 03042405                	dw 1027,MSG_1027-$ ; 1316
 35506 0000582C 05044105                	dw 1029,MSG_1029-$ ; 1345
 35507 00005830 06044F05                	dw 1030,MSG_1030-$ ; 1359
 35508 00005834 08045A05                	dw 1032,MSG_1032-$ ; 1370
 35509 00005838 09046E05                	dw 1033,MSG_1033-$ ; 1390
 35510 0000583C 0A048005                	dw 1034,MSG_1034-$ ; 1408
 35511 00005840 0C049205                	dw 1036,MSG_1036-$ ; 1426
 35512 00005844 0D04A305                	dw 1037,MSG_1037-$ ; 1443
 35513 00005848 0E04B005                	dw 1038,MSG_1038-$ ; 1456
 35514 0000584C 0F04BF05                	dw 1039,MSG_1039-$ ; 1471
 35515                                  $M_ID_3_40:
 35516 00005850 1004F805                	dw 1040,MSG_1040-$ ; 1528
 35517 00005854 14040906                	dw 1044,MSG_1044-$ ; 1545
 35518 00005858 16041906                	dw 1046,MSG_1046-$ ; 1561
 35519 0000585C 17044C06                	dw 1047,MSG_1047-$ ; 1612
 35520 00005860 18046106                	dw 1048,MSG_1048-$ ; 1633
 35521 00005864 19046F06                	dw 1049,MSG_1049-$ ; 1647
 35522 00005868 1A047506                	dw 1050,MSG_1050-$ ; 1653
 35523 0000586C 1B049006                	dw 1051,MSG_1051-$ ; 1680
 35524 00005870 1C049D06                	dw 1052,MSG_1052-$ ; 1693
 35525 00005874 1D04B006                	dw 1053,MSG_1053-$ ; 1712
 35526 00005878 1E04D206                	dw 1054,MSG_1054-$ ; 1746
 35527                                  $M_ID_3_51:
 35528 0000587C 1F04F506                	dw 1055,MSG_1055-$ ; 1781
 35529 00005880 2004FF06                	dw 1056,MSG_1056-$ ; 1791
 35530 00005884 21040A07                	dw 1057,MSG_1057-$ ; 1802
 35531 00005888 23041307                	dw 1059,MSG_1059-$ ; 1811
 35532 0000588C 24041407                	dw 1060,MSG_1060-$ ; 1812
 35533 00005890 25041407                	dw 1061,MSG_1061-$ ; 1812
 35534 00005894 27042A07                	dw 1063,MSG_1063-$ ; 1834
 35535 00005898 28042907                	dw 1064,MSG_1064-$ ; 1833
 35536 0000589C 29042807                	dw 1065,MSG_1065-$ ; 1832
 35537 000058A0 2A042707                	dw 1066,MSG_1066-$ ; 1831
 35538 000058A4 2B042607                	dw 1067,MSG_1067-$ ; 1830
 35539 000058A8 2C042407                	dw 1068,MSG_1068-$ ; 1828
 35540 000058AC 2D042B07                	dw 1069,MSG_1069-$ ; 1835
 35541 000058B0 2E042B07                	dw 1070,MSG_1070-$ ; 1835
 35542 000058B4 2F042A07                	dw 1071,MSG_1071-$ ; 1834
 35543 000058B8 30042907                	dw 1072,MSG_1072-$ ; 1833
 35544                                  $M_ID_3_67:
 35545 000058BC 31042E07                	dw 1073,MSG_1073-$ ; 1838
 35546 000058C0 32043307                	dw 1074,MSG_1074-$ ; 1843
 35547 000058C4 33043807                	dw 1075,MSG_1075-$ ; 1848
 35548 000058C8 34043A07                	dw 1076,MSG_1076-$ ; 1850
 35549 000058CC 35043907                	dw 1077,MSG_1077-$ ; 1849
 35550 000058D0 36043D07                	dw 1078,MSG_1078-$ ; 1853
 35551 000058D4 37045407                	dw 1079,MSG_1079-$ ; 1876
 35552 000058D8 38045B07                	dw 1080,MSG_1080-$ ; 1883
 35553 000058DC 39046D07                	dw 1081,MSG_1081-$ ; 1901
 35554 000058E0 3C049407                	dw 1084,MSG_1084-$ ; 1940
 35555 000058E4 4204A007                	dw 1090,MSG_1090-$ ; 1952
 35556 000058E8 4304AA07                	dw 1091,MSG_1091-$ ; 1962
 35557 000058EC 4404B407                	dw 1092,MSG_1092-$ ; 1972
 35558 000058F0 4504BE07                	dw 1093,MSG_1093-$ ; 1982
 35559 000058F4 4604CF07                	dw 1094,MSG_1094-$ ; 1999
 35560 000058F8 4704E807                	dw 1095,MSG_1095-$ ; 2024
 35561 000058FC 48040108                	dw 1096,MSG_1096-$ ; 2049
 35562                                  $M_ID_3_84:
 35563 00005900 B0042E08                	dw 1200,MSG_1200-$ ; 2094
 35564 00005904 14052B08                	dw 1300,MSG_1300-$ ; 2091
 35565 00005908 2805AE08                	dw 1320,MSG_1320-$ ; 2222
 35566 0000590C 2905EA08                	dw 1321,MSG_1321-$ ; 2282
 35567 00005910 3C055709                	dw 1340,MSG_1340-$ ; 2391
 35568 00005914 3D05AF09                	dw 1341,MSG_1341-$ ; 2479
 35569 00005918 3E050E0A                	dw 1342,MSG_1342-$ ; 2574
 35570 0000591C 50059C0A                	dw 1360,MSG_1360-$ ; 2716
 35571 00005920 7805B40A                	dw 1400,MSG_1400-$ ; 2740
 35572 00005924 7905420B                	dw 1401,MSG_1401-$ ; 2882
 35573 00005928 7A05A70B                	dw 1402,MSG_1402-$ ; 2983
 35574 0000592C 7B051A0C                	dw 1403,MSG_1403-$ ; 3098
 35575 00005930 7C05580C                	dw 1404,MSG_1404-$ ; 3160
 35576 00005934 8C05DC0C                	dw 1420,MSG_1420-$ ; 3292
 35577 00005938 A005630D                	dw 1440,MSG_1440-$ ; 3427
 35578 0000593C A1058D0D                	dw 1441,MSG_1441-$ ; 3469
 35579                                  $M_ID_3_100:
 35580 00005940 B4050D0E                	dw 1460,MSG_1460-$ ; 3597
 35581 00005944 B5056E0E                	dw 1461,MSG_1461-$ ; 3694
 35582 00005948 B605EE0E                	dw 1462,MSG_1462-$ ; 3822
 35583 0000594C C8053A0F                	dw 1480,MSG_1480-$ ; 3898
 35584 00005950 C905D90F                	dw 1481,MSG_1481-$ ; 4057
 35585 00005954 CA053310                	dw 1482,MSG_1482-$ ; 4147
 35586 00005958 CB059110                	dw 1483,MSG_1483-$ ; 4241
 35587 0000595C CC050811                	dw 1484,MSG_1484-$ ; 4360
 35588 00005960 CD05C411                	dw 1485,MSG_1485-$ ; 4548
 35589 00005964 CE055C12                	dw 1486,MSG_1486-$ ; 4700
 35590 00005968 CF05EF12                	dw 1487,MSG_1487-$ ; 4847
 35591 0000596C D0055213                	dw 1488,MSG_1488-$ ; 4946
 35592                                  $M_ID_3_112:
 35593 00005970 DC05E113                	dw 1500,MSG_1500-$ ; 5089
 35594 00005974 F0051C14                	dw 1520,MSG_1520-$ ; 5148
 35595 00005978 04065614                	dw 1540,MSG_1540-$ ; 5206
 35596 0000597C 0506B014                	dw 1541,MSG_1541-$ ; 5296
 35597 00005980 06061815                	dw 1542,MSG_1542-$ ; 5400
 35598 00005984 18065015                	dw 1560,MSG_1560-$ ; 5456
 35599 00005988 19068415                	dw 1561,MSG_1561-$ ; 5508
 35600 0000598C 1A06FD15                	dw 1562,MSG_1562-$ ; 5629
 35601 00005990 1B062916                	dw 1563,MSG_1563-$ ; 5673
 35602 00005994 1C065016                	dw 1564,MSG_1564-$ ; 5712
 35603 00005998 1D068A16                	dw 1565,MSG_1565-$ ; 5770
 35604 0000599C 1E06BB16                	dw 1566,MSG_1566-$ ; 5819
 35605 000059A0 1F06E416                	dw 1567,MSG_1567-$ ; 5860
 35606 000059A4 20065A17                	dw 1568,MSG_1568-$ ; 5978
 35607 000059A8 2C06A317                	dw 1580,MSG_1580-$ ; 6051
 35608                                  $M_ID_3_127:
 35609 000059AC 4006E717                	dw 1600,MSG_1600-$ ; 6119
 35610 000059B0 41060018                	dw 1601,MSG_1601-$ ; 6144
 35611 000059B4 42065018                	dw 1602,MSG_1602-$ ; 6224
 35612 000059B8 54069A18                	dw 1620,MSG_1620-$ ; 6298
 35613 000059BC 5506EE18                	dw 1621,MSG_1621-$ ; 6382
 35614 000059C0 56066C19                	dw 1622,MSG_1622-$ ; 6508
 35615 000059C4 6806B419                	dw 1640,MSG_1640-$ ; 6580
 35616 000059C8 6906E519                	dw 1641,MSG_1641-$ ; 6629
 35617 000059CC 7C06651A                	dw 1660,MSG_1660-$ ; 6757
 35618 000059D0 9006A81A                	dw 1680,MSG_1680-$ ; 6824
 35619 000059D4 A406CA1A                	dw 1700,MSG_1700-$ ; 6858
 35620 000059D8 B806781B                	dw 1720,MSG_1720-$ ; 7032
 35621 000059DC CC06C71B                	dw 1740,MSG_1740-$ ; 7111
 35622 000059E0 CD061F1C                	dw 1741,MSG_1741-$ ; 7199
 35623 000059E4 E0068E1C                	dw 1760,MSG_1760-$ ; 7310
 35624 000059E8 F406D71C                	dw 1780,MSG_1780-$ ; 7383
 35625                                  $M_ID_3_143:
 35626 000059EC 08073F1D                	dw 1800,MSG_1800-$ ; 7487
 35627 000059F0 0907891D                	dw 1801,MSG_1801-$ ; 7561
 35628 000059F4 1C07DD1D                	dw 1820,MSG_1820-$ ; 7645
 35629 000059F8 1D07211E                	dw 1821,MSG_1821-$ ; 7713
 35630 000059FC 3007A81E                	dw 1840,MSG_1840-$ ; 7848
 35631 00005A00 4407EF1E                	dw 1860,MSG_1860-$ ; 7919
 35632 00005A04 4507461F                	dw 1861,MSG_1861-$ ; 8006
 35633 00005A08 4607891F                	dw 1862,MSG_1862-$ ; 8073
 35634 00005A0C 47070320                	dw 1863,MSG_1863-$ ; 8195
 35635 00005A10 4807A220                	dw 1864,MSG_1864-$ ; 8354
 35636 00005A14 49070521                	dw 1865,MSG_1865-$ ; 8453
 35637 00005A18 4A076C21                	dw 1866,MSG_1866-$ ; 8556
 35638 00005A1C 5807D021                	dw 1880,MSG_1880-$ ; 8656
 35639 00005A20 59074422                	dw 1881,MSG_1881-$ ; 8772
 35640 00005A24 5A07BE22                	dw 1882,MSG_1882-$ ; 8894
 35641 00005A28 5B071123                	dw 1883,MSG_1883-$ ; 8977
 35642 00005A2C 6C07B023                	dw 1900,MSG_1900-$ ; 9136
 35643 00005A30 8007C423                	dw 1920,MSG_1920-$ ; 9156
 35644 00005A34 8107F023                	dw 1921,MSG_1921-$ ; 9200
 35645                                  $M_ID_3_162:
 35646 00005A38 8207                    	dw 1922			; Message Number = 1922
 35647 00005A3A 4324                    	dw MSG_1922-$ ; 9285	; Message offset from message number (5CCCh+2445h=8111h)
 35648                                  
 35649                                  ; ---------------------------------------------------------------------------
 35650                                  ; Class 3 messages
 35651                                  ; ---------------------------------------------------------------------------
 35652                                  	
 35653                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35654                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h
 35655                                  
 35656                                  MSG_1020:	; COMMON4
 35657 00005A3C 0F                      	db 15	; (MSG_1015-MSG_1020)-1
 35658 00005A3D 253120627974657320-     	db '%1 bytes free',0Dh,0Ah
 35658 00005A46 667265650D0A       
 35659                                  MSG_1015:	; COMMON18
 35660 00005A4C 23                      	db 35
 35661 00005A4D 46696C652063616E6E-     	db 'File cannot be copied onto itself',0Dh,0Ah
 35661 00005A56 6F7420626520636F70-
 35661 00005A5F 696564206F6E746F20-
 35661 00005A68 697473656C660D0A   
 35662                                  MSG_1004:	; COMMON20
 35663 00005A70 19                      	db 25
 35664 00005A71 496E73756666696369-     	db 'Insufficient disk space',0Dh,0Ah
 35664 00005A7A 656E74206469736B20-
 35664 00005A83 73706163650D0A     
 35665                                  MSG_1026:	; COMMON22
 35666 00005A8A 13                      	db 19
 35667 00005A8B 496E76616C69642063-     	db 'Invalid code page',0Dh,0Ah
 35667 00005A94 6F646520706167650D-
 35667 00005A9D 0A                 
 35668                                  MSG_1031:	; COMMON23
 35669 00005A9E 0E                      	db 14
 35670 00005A9F 496E76616C69642064-     	db 'Invalid date',0Dh,0Ah
 35670 00005AA8 6174650D0A         
 35671                                  MSG_1035:	; COMMON24
 35672 00005AAD 0E                      	db 14
 35673 00005AAE 496E76616C69642074-     	db 'Invalid time',0Dh,0Ah
 35673 00005AB7 696D650D0A         
 35674                                  MSG_1062:	; COMMON25
 35675 00005ABC 0E                      	db 14
 35676 00005ABD 496E76616C69642070-     	db 'Invalid path',0Dh,0Ah
 35676 00005AC6 6174680D0A         
 35677                                  MSG_1028:	; COMMON28
 35678 00005ACB 21                      	db 33
 35679 00005ACC 507265737320616E79-     	db 'Press any key to continue . . .',0Dh,0Ah
 35679 00005AD5 206B657920746F2063-
 35679 00005ADE 6F6E74696E7565202E-
 35679 00005AE7 202E202E0D0A       
 35680                                  MSG_1045:	; COMMON32
 35681 00005AED 1C                      	db 28
 35682 00005AEE 556E61626C6520746F-     	db 'Unable to create directory',0Dh,0Ah
 35682 00005AF7 206372656174652064-
 35682 00005B00 69726563746F72790D-
 35682 00005B09 0A                 
 35683                                  MSG_1041:	; COMMON33
 35684 00005B0A 21                      	db 33
 35685 00005B0B 566F6C756D6520696E-     	db 'Volume in drive %1 has no label',0Dh,0Ah
 35685 00005B14 206472697665202531-
 35685 00005B1D 20686173206E6F206C-
 35685 00005B26 6162656C0D0A       
 35686                                  MSG_1042:	; COMMON34
 35687 00005B2C 1A                      	db 26
 35688 00005B2D 566F6C756D6520696E-     	db 'Volume in drive %1 is %2',0Dh,0Ah
 35688 00005B36 206472697665202531-
 35688 00005B3F 2069732025320D0A   
 35689                                  MSG_1043:	; COMMON36
 35690 00005B47 1F                      	db 31  ; (MSG_1002-MSG_1043)-1
 35691 00005B48 566F6C756D65205365-     	db 'Volume Serial Number is %1-%2',0Dh,0Ah
 35691 00005B51 7269616C204E756D62-
 35691 00005B5A 65722069732025312D-
 35691 00005B63 25320D0A           
 35692                                  MSG_1002:
 35693 00005B67 27                              db 39
 35694 00005B68 4475706C6963617465-     	db 'Duplicate file name or file not found',0Dh,0Ah
 35694 00005B71 2066696C65206E616D-
 35694 00005B7A 65206F722066696C65-
 35694 00005B83 206E6F7420666F756E-
 35694 00005B8C 640D0A             
 35695                                  MSG_1003:
 35696 00005B8F 1B                      	db 27
 35697 00005B90 496E76616C69642070-     	db 'Invalid path or file name',0Dh,0Ah
 35697 00005B99 617468206F72206669-
 35697 00005BA2 6C65206E616D650D0A 
 35698                                  MSG_1007:
 35699 00005BAB 1A                      	db 26
 35700 00005BAC 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
 35700 00005BB5 7669726F6E6D656E74-
 35700 00005BBE 2073706163650D0A   
 35701                                  MSG_1008:
 35702 00005BC6 15                      	db 21
 35703 00005BC7 46696C652063726561-     	db 'File creation error',0Dh,0Ah
 35703 00005BD0 74696F6E206572726F-
 35703 00005BD9 720D0A             
 35704                                  MSG_1009:
 35705 00005BDC 14                      	db 20  ; (MSG_1010-MSG_1009)-1
 35706 00005BDD 42617463682066696C-     	db 'Batch file missing',0Dh,0Ah
 35706 00005BE6 65206D697373696E67-
 35706 00005BEF 0D0A               
 35707                                  MSG_1010:
 35708 00005BF1 1F                      	db 31
 35709 00005BF2 0D0A                    	db 0Dh,0Ah
 35710 00005BF4 496E73657274206469-     	db 'Insert disk with batch file',0Dh,0Ah
 35710 00005BFD 736B20776974682062-
 35710 00005C06 617463682066696C65-
 35710 00005C0F 0D0A               
 35711                                  MSG_1011:
 35712 00005C11 1A                      	db 26
 35713 00005C12 42616420636F6D6D61-     	db 'Bad command or file name',0Dh,0Ah
 35713 00005C1B 6E64206F722066696C-
 35713 00005C24 65206E616D650D0A   
 35714                                  MSG_1014:	; EXTEND5
 35715 00005C2C 10                      	db 16
 35716 00005C2D 416363657373206465-     	db 'Access denied ',0Dh,0Ah
 35716 00005C36 6E696564200D0A     
 35717                                  MSG_1016:
 35718 00005C3D 29                      	db 41
 35719 00005C3E 436F6E74656E74206F-     	db 'Content of destination lost before copy',0Dh,0Ah
 35719 00005C47 662064657374696E61-
 35719 00005C50 74696F6E206C6F7374-
 35719 00005C59 206265666F72652063-
 35719 00005C62 6F70790D0A         
 35720                                  MSG_1017:
 35721 00005C67 24                      	db 36
 35722 00005C68 496E76616C69642066-     	db 'Invalid filename or file not found',0Dh,0Ah
 35722 00005C71 696C656E616D65206F-
 35722 00005C7A 722066696C65206E6F-
 35722 00005C83 7420666F756E640D0A 
 35723                                  MSG_1018:
 35724 00005C8C 13                      	db 19
 35725 00005C8D 25312066696C652873-     	db '%1 file(s) copied',0Dh,0Ah
 35725 00005C96 2920636F706965640D-
 35725 00005C9F 0A                 
 35726                                  MSG_1019:
 35727 00005CA0 0B                      	db 11
 35728 00005CA1 25312066696C652873-     	db '%1 file(s) '
 35728 00005CAA 2920               
 35729                                  MSG_1021:	; EXTEND15
 35730 00005CAC 1D                      	db 29
 35731 00005CAD 496E76616C69642064-     	db 'Invalid drive specification',0Dh,0Ah
 35731 00005CB6 726976652073706563-
 35731 00005CBF 696669636174696F6E-
 35731 00005CC8 0D0A               
 35732                                  MSG_1022:
 35733 00005CCA 26                      	db 38
 35734 00005CCB 436F64652070616765-     	db 'Code page %1 not prepared for system',0Dh,0Ah
 35734 00005CD4 202531206E6F742070-
 35734 00005CDD 726570617265642066-
 35734 00005CE6 6F722073797374656D-
 35734 00005CEF 0D0A               
 35735                                  MSG_1023:
 35736 00005CF1 2B                      	db 43
 35737 00005CF2 436F64652070616765-     	db 'Code page %1 not prepared for all devices',0Dh,0Ah
 35737 00005CFB 202531206E6F742070-
 35737 00005D04 726570617265642066-
 35737 00005D0D 6F7220616C6C206465-
 35737 00005D16 76696365730D0A     
 35738                                  MSG_1024:
 35739 00005D1D 16                      	db 22
 35740 00005D1E 41637469766520636F-     	db 'Active code page: %1',0Dh,0Ah
 35740 00005D27 646520706167653A20-
 35740 00005D30 25310D0A           
 35741                                  MSG_1025:
 35742 00005D34 17                      	db 23
 35743 00005D35 4E4C5346554E43206E-     	db 'NLSFUNC not installed',0Dh,0Ah
 35743 00005D3E 6F7420696E7374616C-
 35743 00005D47 6C65640D0A         
 35744                                  MSG_1027:
 35745 00005D4C 20                      	db 32
 35746 00005D4D 43757272656E742064-     	db 'Current drive is no longer valid'
 35746 00005D56 72697665206973206E-
 35746 00005D5F 6F206C6F6E67657220-
 35746 00005D68 76616C6964         
 35747                                  MSG_1029:
 35748 00005D6D 11                      	db 17
 35749 00005D6E 4C6162656C206E6F74-     	db 'Label not found',0Dh,0Ah
 35749 00005D77 20666F756E640D0A   
 35750                                  MSG_1030:
 35751 00005D7F 0E                      	db 14
 35752 00005D80 53796E746178206572-     	db 'Syntax error',0Dh,0Ah
 35752 00005D89 726F720D0A         
 35753                                  MSG_1032:
 35754 00005D8E 17                      	db 23
 35755 00005D8F 43757272656E742064-     	db 'Current date is %1 %2',0Dh,0Ah
 35755 00005D98 617465206973202531-
 35755 00005DA1 2025320D0A         
 35756                                  MSG_1033:
 35757 00005DA6 15                      	db 21
 35758 00005DA7 53756E4D6F6E547565-     	db 'SunMonTueWedThuFriSat'
 35758 00005DB0 576564546875467269-
 35758 00005DB9 536174             
 35759                                  MSG_1034:
 35760 00005DBC 15                      	db 21
 35761 00005DBD 456E746572206E6577-     	db 'Enter new date (%1): '
 35761 00005DC6 206461746520282531-
 35761 00005DCF 293A20             
 35762                                  MSG_1036:
 35763 00005DD2 14                      	db 20
 35764 00005DD3 43757272656E742074-     	db 'Current time is %1',0Dh,0Ah
 35764 00005DDC 696D65206973202531-
 35764 00005DE5 0D0A               
 35765                                  MSG_1037:
 35766 00005DE7 10                      	db 16
 35767 00005DE8 456E746572206E6577-     	db 'Enter new time: '
 35767 00005DF1 2074696D653A20     
 35768                                  MSG_1038:
 35769 00005DF8 12                              db 18
 35770 00005DF9 2C2020202044656C65-     	db ',    Delete (Y/N)?'
 35770 00005E02 74652028592F4E293F 
 35771                                  MSG_1039:
 35772 00005E0B 3C                              db 60
 35773 00005E0C 416C6C2066696C6573-     	db 'All files in directory will be deleted!',0Dh,0Ah
 35773 00005E15 20696E206469726563-
 35773 00005E1E 746F72792077696C6C-
 35773 00005E27 2062652064656C6574-
 35773 00005E30 6564210D0A         
 35774 00005E35 41726520796F752073-     	db 'Are you sure (Y/N)?'
 35774 00005E3E 7572652028592F4E29-
 35774 00005E47 3F                 
 35775                                  MSG_1040:
 35776 00005E48 14                      	db 20
 35777 00005E49 4D532D444F53205665-     	db 'MS-DOS Version %1.%2'
 35777 00005E52 7273696F6E2025312E-
 35777 00005E5B 2532               
 35778                                  MSG_1044:
 35779 00005E5D 13                      	db 19
 35780 00005E5E 496E76616C69642064-     	db 'Invalid directory',0Dh,0Ah
 35780 00005E67 69726563746F72790D-
 35780 00005E70 0A                 
 35781                                  MSG_1046:
 35782 00005E71 36                      	db 54
 35783 00005E72 496E76616C69642070-     	db 'Invalid path, not directory,',0Dh,0Ah
 35783 00005E7B 6174682C206E6F7420-
 35783 00005E84 6469726563746F7279-
 35783 00005E8D 2C0D0A             
 35784 00005E90 6F7220646972656374-     	db 'or directory not empty',0Dh,0Ah
 35784 00005E99 6F7279206E6F742065-
 35784 00005EA2 6D7074790D0A       
 35785                                  MSG_1047:
 35786 00005EA8 18                      	db 24
 35787 00005EA9 4D7573742073706563-     	db 'Must specify ON or OFF',0Dh,0Ah
 35787 00005EB2 696679204F4E206F72-
 35787 00005EBB 204F46460D0A       
 35788                                  MSG_1048:
 35789 00005EC1 11                      	db 17
 35790 00005EC2 4469726563746F7279-     	db 'Directory of %1',0Dh,0Ah
 35790 00005ECB 206F662025310D0A   
 35791                                  MSG_1049:
 35792 00005ED3 09                      	db 9
 35793 00005ED4 4E6F20506174680D0A      	db 'No Path',0Dh,0Ah
 35794                                  MSG_1050:
 35795 00005EDD 1E                      	db 30
 35796 00005EDE 496E76616C69642064-     	db 'Invalid drive in search path',0Dh,0Ah
 35796 00005EE7 7269766520696E2073-
 35796 00005EF0 656172636820706174-
 35796 00005EF9 680D0A             
 35797                                  MSG_1051:
 35798 00005EFC 10                      	db 16
 35799 00005EFD 496E76616C69642064-     	db 'Invalid device',0Dh,0Ah
 35799 00005F06 65766963650D0A     
 35800                                  MSG_1052:
 35801 00005F0D 16                      	db 22
 35802 00005F0E 464F522063616E6E6F-     	db 'FOR cannot be nested',0Dh,0Ah
 35802 00005F17 74206265206E657374-
 35802 00005F20 65640D0A           
 35803                                  MSG_1053:
 35804 00005F24 25                      	db 37
 35805 00005F25 496E7465726D656469-     	db 'Intermediate file error during pipe',0Dh,0Ah
 35805 00005F2E 6174652066696C6520-
 35805 00005F37 6572726F7220647572-
 35805 00005F40 696E6720706970650D-
 35805 00005F49 0A                 
 35806                                  MSG_1054:
 35807 00005F4A 26                      	db 38
 35808 00005F4B 43616E6E6F7420646F-     	db 'Cannot do binary reads from a device',0Dh,0Ah
 35808 00005F54 2062696E6172792072-
 35808 00005F5D 656164732066726F6D-
 35808 00005F66 206120646576696365-
 35808 00005F6F 0D0A               
 35809                                  
 35810                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
 35811                                  MSG_1055:
 35812 00005F71 0D                      	db 13
 35813 00005F72 425245414B20697320-     	db 'BREAK is %1',0Dh,0Ah
 35813 00005F7B 25310D0A           
 35814                                  MSG_1056:
 35815 00005F7F 0E                      	db 14
 35816 00005F80 564552494659206973-     	db 'VERIFY is %1',0Dh,0Ah
 35816 00005F89 2025310D0A         
 35817                                  MSG_1057:
 35818 00005F8E 0C                      	db 12
 35819 00005F8F 4543484F2069732025-     	db 'ECHO is %1',0Dh,0Ah
 35819 00005F98 310D0A             
 35820                                  MSG_1059:
 35821 00005F9B 04                      	db 4
 35822 00005F9C 6F666600                	db 'off',0
 35823                                  MSG_1060:
 35824 00005FA0 03                      	db 3
 35825 00005FA1 6F6E00                  	db 'on',0
 35826                                  MSG_1061:
 35827 00005FA4 19                      	db 25
 35828 00005FA5 4572726F7220777269-     	db 'Error writing to device',0Dh,0Ah
 35828 00005FAE 74696E6720746F2064-
 35828 00005FB7 65766963650D0A     
 35829                                  MSG_1063:
 35830 00005FBE 02                      	db 2
 35831 00005FBF 2531                    	db '%1'
 35832                                  MSG_1064:
 35833 00005FC1 02                      	db 2
 35834 00005FC2 2531                    	db '%1'
 35835                                  MSG_1065:
 35836 00005FC4 02                      	db 2
 35837 00005FC5 2531                    	db '%1'
 35838                                  MSG_1066:
 35839 00005FC7 02                      	db 2
 35840 00005FC8 2531                    	db '%1'
 35841                                  MSG_1067:
 35842 00005FCA 01                      	db 1
 35843 00005FCB 09                      	db 9
 35844                                  MSG_1068:
 35845 00005FCC 0A                      	db 10
 35846 00005FCD 203C4449523E202020-     	db ' <DIR>    '
 35846 00005FD6 20                 
 35847                                  MSG_1069:
 35848 00005FD7 03                      	db 3
 35849 00005FD8 082008                  	db 8, 20h, 8
 35850                                  MSG_1070:	; CRLF		
 35851 00005FDB 02                      	db 2
 35852 00005FDC 0D                      	db 0Dh
 35853 00005FDD 0A                      	db 0Ah
 35854                                  MSG_1071:
 35855 00005FDE 02                      	db 2
 35856 00005FDF 2531                    	db '%1'
 35857                                  MSG_1072:
 35858 00005FE1 08                      	db 8
 35859 00005FE2 6D6D2D64642D7979        	db 'mm-dd-yy'
 35860                                  MSG_1073:
 35861 00005FEA 08                      	db 8
 35862 00005FEB 64642D6D6D2D7979        	db 'dd-mm-yy'
 35863                                  MSG_1074:
 35864 00005FF3 08                      	db 8
 35865 00005FF4 79792D6D6D2D6464        	db 'yy-mm-dd'
 35866                                  MSG_1075:
 35867 00005FFC 05                      	db 5
 35868 00005FFD 2531202532              	db '%1 %2'
 35869                                  MSG_1076:
 35870 00006002 02                      	db 2
 35871 00006003 2531                    	db '%1'
 35872                                  MSG_1077:
 35873 00006005 07                      	db 7
 35874 00006006 20253120202532          	db ' %1  %2'
 35875                                  MSG_1078:
 35876 0000600D 1A                      	db 26
 35877 0000600E 4469726563746F7279-     	db 'Directory already exists',0Dh,0Ah
 35877 00006017 20616C726561647920-
 35877 00006020 6578697374730D0A   
 35878                                  MSG_1079:
 35879 00006028 0A                      	db 10
 35880 00006029 25312062797465730D-     	db '%1 bytes',0Dh,0Ah
 35880 00006032 0A                 
 35881                                  MSG_1080:
 35882 00006033 15                      	db 21
 35883 00006034 546F74616C2066696C-     	db 'Total files listed:',0Dh,0Ah
 35883 0000603D 6573206C6973746564-
 35883 00006046 3A0D0A             
 35884                                  MSG_1081:
 35885 00006049 2A                      	db 42
 35886 0000604A 284572726F72206F63-     	db '(Error occurred in environment variable)',0Dh,0Ah
 35886 00006053 63757272656420696E-
 35886 0000605C 20656E7669726F6E6D-
 35886 00006065 656E74207661726961-
 35886 0000606E 626C65290D0A       
 35887                                  MSG_1084:
 35888 00006074 0F                      	db 15
 35889 00006075 28636F6E74696E7569-     	db '(continuing %1)'
 35889 0000607E 6E6720253129       
 35890                                  MSG_1090:
 35891 00006084 0D                      	db 13
 35892 00006085 5265766973696F6E20-     	db 'Revision %1',0Dh,0Ah
 35892 0000608E 25310D0A           
 35893                                  MSG_1091:
 35894 00006092 0D                      	db 13
 35895 00006093 444F5320697320696E-     	db 'DOS is in ROM'
 35895 0000609C 20524F4D           
 35896                                  MSG_1092:
 35897 000060A0 0D                      	db 13
 35898 000060A1 444F5320697320696E-     	db 'DOS is in HMA'
 35898 000060AA 20484D41           
 35899                                  MSG_1093:
 35900 000060AE 14                      	db 20
 35901 000060AF 444F5320697320696E-     	db 'DOS is in low memory'
 35901 000060B8 206C6F77206D656D6F-
 35901 000060C1 7279               
 35902                                  MSG_1094:
 35903 000060C3 1C                      	db 28
 35904 000060C4 43616E6E6F74204C6F-     	db 'Cannot Loadhigh batch file',0Dh,0Ah
 35904 000060CD 616468696768206261-
 35904 000060D6 7463682066696C650D-
 35904 000060DF 0A                 
 35905                                  MSG_1095:
 35906 000060E0 1C                      	db 28
 35907 000060E1 4C6F6164486967683A-     	db 'LoadHigh: Invalid filename',0Dh,0Ah
 35907 000060EA 20496E76616C696420-
 35907 000060F3 66696C656E616D650D-
 35907 000060FC 0A                 
 35908                                  MSG_1096:
 35909 000060FD 30                      	db 48
 35910 000060FE 43616E6E6F74206F70-     	db 'Cannot open specified country information file',0Dh,0Ah
 35910 00006107 656E20737065636966-
 35910 00006110 69656420636F756E74-
 35910 00006119 727920696E666F726D-
 35910 00006122 6174696F6E2066696C-
 35910 0000612B 650D0A             
 35911                                  
 35912                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
 35913                                  MSG_1200:
 35914 0000612E 00                      	db 0	; /? unimplemented
 35915                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C3h)
 35916                                  MSG_1300:
 35917 0000612F 86                      	db 134
 35918 00006130 53657473206F722063-     	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
 35918 00006139 6C6561727320657874-
 35918 00006142 656E64656420435452-
 35918 0000614B 4C2B4320636865636B-
 35918 00006154 696E672E0D0A       
 35919 0000615A 0D0A                    	db 0Dh,0Ah
 35920 0000615C 425245414B205B4F4E-     	db 'BREAK [ON | OFF]',0Dh,0Ah
 35920 00006165 207C204F46465D0D0A 
 35921 0000616E 0D0A                    	db 0Dh,0Ah
 35922 00006170 547970652042524541-     	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
 35922 00006179 4B20776974686F7574-
 35922 00006182 206120706172616D65-
 35922 0000618B 74657220746F206469-
 35922 00006194 73706C617920746865-
 35922 0000619D 2063757272656E7420-
 35922 000061A6 425245414B20736574-
 35922 000061AF 74696E672E0D0A     
 35923                                  MSG_1320:
 35924 000061B6 3F                      	db 63
 35925 000061B7 446973706C61797320-     	db 'Displays or sets the active code page number.',0Dh,0Ah
 35925 000061C0 6F7220736574732074-
 35925 000061C9 686520616374697665-
 35925 000061D2 20636F646520706167-
 35925 000061DB 65206E756D6265722E-
 35925 000061E4 0D0A               
 35926 000061E6 0D0A                    	db 0Dh,0Ah
 35927 000061E8 43484350205B6E6E6E-     	db 'CHCP [nnn]',0Dh,0Ah
 35927 000061F1 5D0D0A             
 35928 000061F4 0D0A                    	db 0Dh,0Ah
 35929                                  MSG_1321:
 35930 000061F6 70                      	db 112
 35931 000061F7 20206E6E6E20202053-     	db '  nnn   Specifies a code page number.',0Dh,0Ah
 35931 00006200 706563696669657320-
 35931 00006209 6120636F6465207061-
 35931 00006212 6765206E756D626572-
 35931 0000621B 2E0D0A             
 35932 0000621E 0D0A                    	db 0Dh,0Ah
 35933 00006220 547970652043484350-     	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
 35933 00006229 20776974686F757420-
 35933 00006232 6120706172616D6574-
 35933 0000623B 657220746F20646973-
 35933 00006244 706C61792074686520-
 35933 0000624D 61637469766520636F-
 35933 00006256 64652070616765206E-
 35933 0000625F 756D6265722E0D0A   
 35934                                  MSG_1340:
 35935 00006267 5B                      	db 91
 35936 00006268 446973706C61797320-     	db 'Displays the name of or changes the current directory.',0Dh,0Ah
 35936 00006271 746865206E616D6520-
 35936 0000627A 6F66206F7220636861-
 35936 00006283 6E6765732074686520-
 35936 0000628C 63757272656E742064-
 35936 00006295 69726563746F72792E-
 35936 0000629E 0D0A               
 35937 000062A0 0D0A                    	db 0Dh,0Ah
 35938 000062A2 4348444952205B6472-     	db 'CHDIR [drive:][path]',0Dh,0Ah
 35938 000062AB 6976653A5D5B706174-
 35938 000062B4 685D0D0A           
 35939 000062B8 43484449525B2E2E5D-     	db 'CHDIR[..]',0Dh,0Ah
 35939 000062C1 0D0A               
 35940                                  MSG_1341:
 35941 000062C3 62                      	db 98
 35942 000062C4 4344205B6472697665-     	db 'CD [drive:][path]',0Dh,0Ah
 35942 000062CD 3A5D5B706174685D0D-
 35942 000062D6 0A                 
 35943 000062D7 43445B2E2E5D0D0A        	db 'CD[..]',0Dh,0Ah
 35944 000062DF 0D0A                    	db 0Dh,0Ah
 35945 000062E1 20202E2E2020205370-     	db '  ..   Specifies that you want to change to the parent directory.'
 35945 000062EA 656369666965732074-
 35945 000062F3 68617420796F752077-
 35945 000062FC 616E7420746F206368-
 35945 00006305 616E676520746F2074-
 35945 0000630E 686520706172656E74-
 35945 00006317 206469726563746F72-
 35945 00006320 792E               
 35946 00006322 0D0A                    	db 0Dh,0Ah
 35947 00006324 0D0A                    	db 0Dh,0Ah
 35948                                  MSG_1342:
 35949 00006326 91                      	db 145
 35950 00006327 547970652043442064-     	db 'Type CD drive: to display the current directory in the specified '
 35950 00006330 726976653A20746F20-
 35950 00006339 646973706C61792074-
 35950 00006342 68652063757272656E-
 35950 0000634B 74206469726563746F-
 35950 00006354 727920696E20746865-
 35950 0000635D 207370656369666965-
 35950 00006366 6420               
 35951 00006368 64726976652E0D0A        	db 'drive.',0Dh,0Ah
 35952 00006370 547970652043442077-     	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
 35952 00006379 6974686F7574207061-
 35952 00006382 72616D657465727320-
 35952 0000638B 746F20646973706C61-
 35952 00006394 792074686520637572-
 35952 0000639D 72656E742064726976-
 35952 000063A6 6520616E6420646972-
 35952 000063AF 6563746F72792E0D0A 
 35953                                  MSG_1360:
 35954 000063B8 1B                      	db 27
 35955 000063B9 436C65617273207468-     	db 'Clears the screen.',0Dh,0Ah
 35955 000063C2 652073637265656E2E-
 35955 000063CB 0D0A               
 35956 000063CD 0D0A                    	db 0Dh,0Ah
 35957 000063CF 434C530D0A              	db 'CLS',0Dh,0Ah
 35958                                  MSG_1400:
 35959 000063D4 91                      	db 145
 35960 000063D5 436F70696573206F6E-     	db 'Copies one or more files to another location.',0Dh,0Ah
 35960 000063DE 65206F72206D6F7265-
 35960 000063E7 2066696C657320746F-
 35960 000063F0 20616E6F7468657220-
 35960 000063F9 6C6F636174696F6E2E-
 35960 00006402 0D0A               
 35961 00006404 0D0A                    	db 0Dh,0Ah
 35962 00006406 434F5059205B2F4120-     	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 35962 0000640F 7C202F425D20736F75-
 35962 00006418 726365205B2F41207C-
 35962 00006421 202F425D205B2B2073-
 35962 0000642A 6F75726365205B2F41-
 35962 00006433 207C202F425D205B2B-
 35962 0000643C 202E2E2E5D5D205B64-
 35962 00006445 657374696E6174696F-
 35962 0000644E 6E0D0A             
 35963 00006451 20205B2F41207C202F-     	db '  [/A | /B]] [/V]',0Dh,0Ah
 35963 0000645A 425D5D205B2F565D0D-
 35963 00006463 0A                 
 35964 00006464 0D0A                    	db 0Dh,0Ah
 35965                                  MSG_1401:
 35966 00006466 68                      	db 104
 35967 00006467 2020736F7572636520-     	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
 35967 00006470 202020202020537065-
 35967 00006479 636966696573207468-
 35967 00006482 652066696C65206F72-
 35967 0000648B 2066696C657320746F-
 35967 00006494 20626520636F706965-
 35967 0000649D 642E0D0A           
 35968 000064A1 20202F412020202020-     	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
 35968 000064AA 202020202020496E64-
 35968 000064B3 69636174657320616E-
 35968 000064BC 204153434949207465-
 35968 000064C5 78742066696C652E0D-
 35968 000064CE 0A                 
 35969                                  MSG_1402:
 35970 000064CF 76                      	db 118
 35971 000064D0 20202F422020202020-     	db '  /B           Indicates a binary file.',0Dh,0Ah
 35971 000064D9 202020202020496E64-
 35971 000064E2 696361746573206120-
 35971 000064EB 62696E617279206669-
 35971 000064F4 6C652E0D0A         
 35972 000064F9 202064657374696E61-     	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
 35972 00006502 74696F6E2020537065-
 35972 0000650B 636966696573207468-
 35972 00006514 65206469726563746F-
 35972 0000651D 727920616E642F6F72-
 35972 00006526 2066696C656E616D65-
 35972 0000652F 20666F722074686520-
 35972 00006538 6E65772066696C6528-
 35972 00006541 73292E0D0A         
 35973                                  MSG_1403:	
 35974 00006546 41                      	db 65
 35975 00006547 20202F562020202020-     	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
 35975 00006550 202020202020566572-
 35975 00006559 696669657320746861-
 35975 00006562 74206E65772066696C-
 35975 0000656B 657320617265207772-
 35975 00006574 697474656E20636F72-
 35975 0000657D 726563746C792E0D0A 
 35976 00006586 0D0A                    	db 0Dh,0Ah
 35977                                  MSG_1404:
 35978 00006588 87                      	db 135
 35979 00006589 546F20617070656E64-     	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
 35979 00006592 2066696C65732C2073-
 35979 0000659B 706563696679206120-
 35979 000065A4 73696E676C65206669-
 35979 000065AD 6C6520666F72206465-
 35979 000065B6 7374696E6174696F6E-
 35979 000065BF 2C20627574206D756C-
 35979 000065C8 7469706C652066696C-
 35979 000065D1 65730D0A           
 35980 000065D5 666F7220736F757263-     	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
 35980 000065DE 6520287573696E6720-
 35980 000065E7 77696C646361726473-
 35980 000065F0 206F722066696C6531-
 35980 000065F9 2B66696C65322B6669-
 35980 00006602 6C653320666F726D61-
 35980 0000660B 74292E0D0A         
 35981                                  MSG_1420:
 35982 00006610 8A                      	db 138
 35983 00006611 4368616E6765732074-     	db 'Changes the terminal device used to control your system.',0Dh,0Ah
 35983 0000661A 6865207465726D696E-
 35983 00006623 616C20646576696365-
 35983 0000662C 207573656420746F20-
 35983 00006635 636F6E74726F6C2079-
 35983 0000663E 6F7572207379737465-
 35983 00006647 6D2E0D0A           
 35984 0000664B 0D0A                    	db 0Dh,0Ah
 35985 0000664D 435454592064657669-     	db 'CTTY device',0Dh,0Ah
 35985 00006656 63650D0A           
 35986 0000665A 0D0A                    	db 0Dh,0Ah
 35987 0000665C 202064657669636520-     	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
 35987 00006665 202054686520746572-
 35987 0000666E 6D696E616C20646576-
 35987 00006677 69636520796F752077-
 35987 00006680 616E7420746F207573-
 35987 00006689 652C20737563682061-
 35987 00006692 7320434F4D312E0D0A 
 35988                                  MSG_1440:
 35989 0000669B 2D                      	db 45
 35990 0000669C 446973706C61797320-     	db 'Displays or sets the date.',0Dh,0Ah
 35990 000066A5 6F7220736574732074-
 35990 000066AE 686520646174652E0D-
 35990 000066B7 0A                 
 35991 000066B8 0D0A                    	db 0Dh,0Ah
 35992 000066BA 44415445205B646174-     	db 'DATE [date]',0Dh,0Ah
 35992 000066C3 655D0D0A           
 35993 000066C7 0D0A                    	db 0Dh,0Ah
 35994                                  MSG_1441:
 35995 000066C9 83                      	db 131
 35996 000066CA 547970652044415445-     	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
 35996 000066D3 20776974686F757420-
 35996 000066DC 706172616D65746572-
 35996 000066E5 7320746F2064697370-
 35996 000066EE 6C6179207468652063-
 35996 000066F7 757272656E74206461-
 35996 00006700 74652073657474696E-
 35996 00006709 6720616E640D0A     
 35997 00006710 612070726F6D707420-     	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
 35997 00006719 666F722061206E6577-
 35997 00006722 206F6E652E20205072-
 35997 0000672B 65737320454E544552-
 35997 00006734 20746F206B65657020-
 35997 0000673D 7468652073616D6520-
 35997 00006746 646174652E0D0A     
 35998                                  MSG_1460:	
 35999 0000674D 64                      	db 100
 36000 0000674E 44656C65746573206F-     	db 'Deletes one or more files.',0Dh,0Ah
 36000 00006757 6E65206F72206D6F72-
 36000 00006760 652066696C65732E0D-
 36000 00006769 0A                 
 36001 0000676A 0D0A                    	db 0Dh,0Ah
 36002 0000676C 44454C205B64726976-     	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
 36002 00006775 653A5D5B706174685D-
 36002 0000677E 66696C656E616D6520-
 36002 00006787 5B2F505D0D0A       
 36003 0000678D 4552415345205B6472-     	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
 36003 00006796 6976653A5D5B706174-
 36003 0000679F 685D66696C656E616D-
 36003 000067A8 65205B2F505D0D0A   
 36004 000067B0 0D0A                    	db 0Dh,0Ah
 36005                                  MSG_1461:
 36006 000067B2 83                      	db 131
 36007 000067B3 20205B64726976653A-     	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
 36007 000067BC 5D5B706174685D6669-
 36007 000067C5 6C656E616D65202053-
 36007 000067CE 706563696669657320-
 36007 000067D7 7468652066696C6528-
 36007 000067E0 732920746F2064656C-
 36007 000067E9 6574652E2020537065-
 36007 000067F2 63696679206D756C74-
 36007 000067FB 69706C650D0A       
 36008 00006801 202020202020202020-     	db '                          files by using wildcards.',0Dh,0Ah
 36008 0000680A 202020202020202020-
 36008 00006813 202020202020202066-
 36008 0000681C 696C65732062792075-
 36008 00006825 73696E672077696C64-
 36008 0000682E 63617264732E0D0A   
 36009                                  MSG_1462:
 36010 00006836 4F                      	db 79
 36011 00006837 20202F502020202020-     	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
 36011 00006840 202020202020202020-
 36011 00006849 202020202020202050-
 36011 00006852 726F6D70747320666F-
 36011 0000685B 7220636F6E6669726D-
 36011 00006864 6174696F6E20626566-
 36011 0000686D 6F72652064656C6574-
 36011 00006876 696E67206561636820-
 36011 0000687F 66696C652E0D0A     
 36012                                  MSG_1480:
 36013 00006886 A2                      	db 162
 36014 00006887 446973706C61797320-     	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 36014 00006890 61206C697374206F66-
 36014 00006899 2066696C657320616E-
 36014 000068A2 642073756264697265-
 36014 000068AB 63746F726965732069-
 36014 000068B4 6E2061206469726563-
 36014 000068BD 746F72792E0D0A     
 36015 000068C4 0D0A                    	db 0Dh,0Ah
 36016 000068C6 444952205B64726976-     	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
 36016 000068CF 653A5D5B706174685D-
 36016 000068D8 5B66696C656E616D65-
 36016 000068E1 5D205B2F505D205B2F-
 36016 000068EA 575D205B2F415B5B3A-
 36016 000068F3 5D6174747269627574-
 36016 000068FC 65735D5D0D0A       
 36017 00006902 20205B2F4F5B5B3A5D-     	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
 36017 0000690B 736F72746F72646572-
 36017 00006914 5D5D205B2F535D205B-
 36017 0000691D 2F425D205B2F4C5D0D-
 36017 00006926 0A                 
 36018 00006927 0D0A                    	db 0Dh,0Ah
 36019                                  MSG_1481:
 36020 00006929 5D                      	db 93
 36021 0000692A 20205B64726976653A-     	db '  [drive:][path][filename]',0Dh,0Ah
 36021 00006933 5D5B706174685D5B66-
 36021 0000693C 696C656E616D655D0D-
 36021 00006945 0A                 
 36022 00006946 202020202020202020-     	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
 36022 0000694F 202020202053706563-
 36022 00006958 696669657320647269-
 36022 00006961 76652C206469726563-
 36022 0000696A 746F72792C20616E64-
 36022 00006973 2F6F722066696C6573-
 36022 0000697C 20746F206C6973742E-
 36022 00006985 0D0A               
 36023                                  MSG_1482:
 36024 00006987 61                      	db 97
 36025 00006988 20202F502020202020-     	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
 36025 00006991 202020202050617573-
 36025 0000699A 657320616674657220-
 36025 000069A3 656163682073637265-
 36025 000069AC 656E66756C206F6620-
 36025 000069B5 696E666F726D617469-
 36025 000069BE 6F6E2E0D0A         
 36026 000069C3 20202F572020202020-     	db '  /W          Uses wide list format.',0Dh,0Ah
 36026 000069CC 202020202055736573-
 36026 000069D5 2077696465206C6973-
 36026 000069DE 7420666F726D61742E-
 36026 000069E7 0D0A               
 36027                                  MSG_1483:	
 36028 000069E9 7A                      	db 122
 36029 000069EA 20202F412020202020-     	db '  /A          Displays files with specified attributes.',0Dh,0Ah
 36029 000069F3 202020202044697370-
 36029 000069FC 6C6179732066696C65-
 36029 00006A05 732077697468207370-
 36029 00006A0E 656369666965642061-
 36029 00006A17 747472696275746573-
 36029 00006A20 2E0D0A             
 36030 00006A23 202061747472696275-     	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
 36030 00006A2C 746573202020442020-
 36030 00006A35 4469726563746F7269-
 36030 00006A3E 657320202020202020-
 36030 00006A47 202020202020202020-
 36030 00006A50 522020526561642D6F-
 36030 00006A59 6E6C792066696C6573-
 36030 00006A62 0D0A               
 36031                                  MSG_1484:
 36032 00006A64 BF                      	db 191
 36033 00006A65 202020202020202020-     	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
 36033 00006A6E 202020202020482020-
 36033 00006A77 48696464656E206669-
 36033 00006A80 6C6573202020202020-
 36033 00006A89 202020202020202020-
 36033 00006A92 41202046696C657320-
 36033 00006A9B 726561647920666F72-
 36033 00006AA4 20617263686976696E-
 36033 00006AAD 670D0A             
 36034 00006AB0 202020202020202020-     	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
 36034 00006AB9 202020202020532020-
 36034 00006AC2 53797374656D206669-
 36034 00006ACB 6C6573202020202020-
 36034 00006AD4 202020202020202020-
 36034 00006ADD 2D2020507265666978-
 36034 00006AE6 206D65616E696E6720-
 36034 00006AEF 226E6F74220D0A     
 36035 00006AF6 20202F4F2020202020-     	db '  /O          List by files in sorted order.',0Dh,0Ah
 36035 00006AFF 20202020204C697374-
 36035 00006B08 2062792066696C6573-
 36035 00006B11 20696E20736F727465-
 36035 00006B1A 64206F726465722E0D-
 36035 00006B23 0A                 
 36036                                  MSG_1485:
 36037 00006B24 9B                      	db 155
 36038 00006B25 2020736F72746F7264-     	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 36038 00006B2E 6572202020204E2020-
 36038 00006B37 4279206E616D652028-
 36038 00006B40 616C70686162657469-
 36038 00006B49 632920202020202020-
 36038 00006B52 53202042792073697A-
 36038 00006B5B 652028736D616C6C65-
 36038 00006B64 737420666972737429-
 36038 00006B6D 0D0A               
 36039 00006B6F 202020202020202020-     	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 36039 00006B78 202020202020452020-
 36039 00006B81 427920657874656E73-
 36039 00006B8A 696F6E2028616C7068-
 36039 00006B93 616265746963292020-
 36039 00006B9C 442020427920646174-
 36039 00006BA5 6520262074696D6520-
 36039 00006BAE 286561726C69657374-
 36039 00006BB7 206669727374290D0A 
 36040                                  MSG_1486:
 36041 00006BC0 96                      	db 150
 36042 00006BC1 202020202020202020-     	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 36042 00006BCA 202020202020472020-
 36042 00006BD3 47726F757020646972-
 36042 00006BDC 6563746F7269657320-
 36042 00006BE5 666972737420202020-
 36042 00006BEE 2D2020507265666978-
 36042 00006BF7 20746F207265766572-
 36042 00006C00 7365206F726465720D-
 36042 00006C09 0A                 
 36043 00006C0A 20202F532020202020-     	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
 36043 00006C13 202020202044697370-
 36043 00006C1C 6C6179732066696C65-
 36043 00006C25 7320696E2073706563-
 36043 00006C2E 696669656420646972-
 36043 00006C37 6563746F727920616E-
 36043 00006C40 6420616C6C20737562-
 36043 00006C49 6469726563746F7269-
 36043 00006C52 65732E0D0A         
 36044                                  MSG_1487:
 36045 00006C57 66                      	db 102
 36046 00006C58 20202F422020202020-     	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
 36046 00006C61 202020202055736573-
 36046 00006C6A 206261726520666F72-
 36046 00006C73 6D617420286E6F2068-
 36046 00006C7C 656164696E6720696E-
 36046 00006C85 666F726D6174696F6E-
 36046 00006C8E 206F722073756D6D61-
 36046 00006C97 7279292E0D0A       
 36047 00006C9D 20202F4C2020202020-     	db '  /L          Uses lowercase.',0Dh,0Ah
 36047 00006CA6 202020202055736573-
 36047 00006CAF 206C6F776572636173-
 36047 00006CB8 652E0D0A           
 36048 00006CBC 0D0A                    	db 0Dh,0Ah
 36049                                  MSG_1488:
 36050 00006CBE 92                      	db 146
 36051 00006CBF 537769746368657320-     	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 36051 00006CC8 6D6179206265207072-
 36051 00006CD1 6573657420696E2074-
 36051 00006CDA 686520444952434D44-
 36051 00006CE3 20656E7669726F6E6D-
 36051 00006CEC 656E74207661726961-
 36051 00006CF5 626C652E20204F7665-
 36051 00006CFE 72726964650D0A     
 36052 00006D05 707265736574207377-     	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 36052 00006D0E 697463686573206279-
 36052 00006D17 20707265666978696E-
 36052 00006D20 6720616E7920737769-
 36052 00006D29 746368207769746820-
 36052 00006D32 2D202868797068656E-
 36052 00006D3B 292D2D666F72206578-
 36052 00006D44 616D706C652C202F2D-
 36052 00006D4D 572E0D0A           
 36053                                  MSG_1500:
 36054 00006D51 3E                      	db 62
 36055 00006D52 517569747320746865-     	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
 36055 00006D5B 20434F4D4D414E442E-
 36055 00006D64 434F4D2070726F6772-
 36055 00006D6D 616D2028636F6D6D61-
 36055 00006D76 6E6420696E74657270-
 36055 00006D7F 7265746572292E0D0A 
 36056 00006D88 0D0A                    	db 0Dh,0Ah
 36057 00006D8A 455849540D0A            	db 'EXIT',0Dh,0Ah
 36058                                  MSG_1520:
 36059 00006D90 3D                      	db 61
 36060 00006D91 437265617465732061-     	db 'Creates a directory.',0Dh,0Ah
 36060 00006D9A 206469726563746F72-
 36060 00006DA3 792E0D0A           
 36061 00006DA7 0D0A                    	db 0Dh,0Ah
 36062 00006DA9 4D4B444952205B6472-     	db 'MKDIR [drive:]path',0Dh,0Ah
 36062 00006DB2 6976653A5D70617468-
 36062 00006DBB 0D0A               
 36063 00006DBD 4D44205B6472697665-     	db 'MD [drive:]path',0Dh,0Ah
 36063 00006DC6 3A5D706174680D0A   
 36064                                  MSG_1540:
 36065 00006DCE 5D                      	db 93
 36066 00006DCF 446973706C61797320-     	db 'Displays or sets a search path for executable files.',0Dh,0Ah
 36066 00006DD8 6F7220736574732061-
 36066 00006DE1 207365617263682070-
 36066 00006DEA 61746820666F722065-
 36066 00006DF3 786563757461626C65-
 36066 00006DFC 2066696C65732E0D0A 
 36067 00006E05 0D0A                    	db 0Dh,0Ah
 36068 00006E07 50415448205B5B6472-     	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
 36068 00006E10 6976653A5D70617468-
 36068 00006E19 5B3B2E2E2E5D5D0D0A 
 36069 00006E22 50415448203B0D0A        	db 'PATH ;',0Dh,0Ah
 36070 00006E2A 0D0A                    	db 0Dh,0Ah
 36071                                  MSG_1541:
 36072 00006E2C 6B                      	db 107
 36073 00006E2D 547970652050415448-     	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
 36073 00006E36 203B20746F20636C65-
 36073 00006E3F 617220616C6C207365-
 36073 00006E48 617263682D70617468-
 36073 00006E51 2073657474696E6773-
 36073 00006E5A 20616E642064697265-
 36073 00006E63 6374204D532D444F53-
 36073 00006E6C 20746F207365617263-
 36073 00006E75 680D0A             
 36074 00006E78 6F6E6C7920696E2074-     	db 'only in the current directory.',0Dh,0Ah
 36074 00006E81 68652063757272656E-
 36074 00006E8A 74206469726563746F-
 36074 00006E93 72792E0D0A         
 36075                                  MSG_1542:	
 36076 00006E98 3B                      	db 59
 36077 00006E99 547970652050415448-     	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
 36077 00006EA2 20776974686F757420-
 36077 00006EAB 706172616D65746572-
 36077 00006EB4 7320746F2064697370-
 36077 00006EBD 6C6179207468652063-
 36077 00006EC6 757272656E74207061-
 36077 00006ECF 74682E0D0A         
 36078                                  MSG_1560:
 36079 00006ED4 37                      	db 55
 36080 00006ED5 4368616E6765732074-     	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
 36080 00006EDE 6865204D532D444F53-
 36080 00006EE7 20636F6D6D616E6420-
 36080 00006EF0 70726F6D70742E0D0A 
 36081 00006EF9 0D0A                    	db 0Dh,0Ah
 36082 00006EFB 50524F4D5054205B74-     	db 'PROMPT [text]',0Dh,0Ah
 36082 00006F04 6578745D0D0A       
 36083 00006F0A 0D0A                    	db 0Dh,0Ah
 36084                                  MSG_1561:	
 36085 00006F0C 7C                      	db 124
 36086 00006F0D 202074657874202020-     	db '  text    Specifies a new command prompt.',0Dh,0Ah
 36086 00006F16 205370656369666965-
 36086 00006F1F 732061206E65772063-
 36086 00006F28 6F6D6D616E64207072-
 36086 00006F31 6F6D70742E0D0A     
 36087 00006F38 0D0A                    	db 0Dh,0Ah
 36088 00006F3A 50726F6D7074206361-     	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
 36088 00006F43 6E206265206D616465-
 36088 00006F4C 207570206F66206E6F-
 36088 00006F55 726D616C2063686172-
 36088 00006F5E 61637465727320616E-
 36088 00006F67 642074686520666F6C-
 36088 00006F70 6C6F77696E67207370-
 36088 00006F79 656369616C20636F64-
 36088 00006F82 65733A0D0A         
 36089 00006F87 0D0A                    	db 0Dh,0Ah
 36090                                  MSG_1562:
 36091 00006F89 2F                      	db 47
 36092 00006F8A 202024512020203D20-     	db '  $Q   = (equal sign)',0Dh,0Ah
 36092 00006F93 28657175616C207369-
 36092 00006F9C 676E290D0A         
 36093 00006FA1 202024242020202420-     	db '  $$   $ (dollar sign)',0Dh,0Ah
 36093 00006FAA 28646F6C6C61722073-
 36093 00006FB3 69676E290D0A       
 36094                                  MSG_1563:
 36095 00006FB9 2A                      	db 42
 36096 00006FBA 202024542020204375-     	db '  $T   Current time',0Dh,0Ah
 36096 00006FC3 7272656E742074696D-
 36096 00006FCC 650D0A             
 36097 00006FCF 202024442020204375-     	db '  $D   Current date',0Dh,0Ah
 36097 00006FD8 7272656E7420646174-
 36097 00006FE1 650D0A             
 36098                                  MSG_1564:
 36099 00006FE4 3D                      	db 61
 36100 00006FE5 202024502020204375-     	db '  $P   Current drive and path',0Dh,0Ah
 36100 00006FEE 7272656E7420647269-
 36100 00006FF7 766520616E64207061-
 36100 00007000 74680D0A           
 36101 00007004 202024562020204D53-     	db '  $V   MS-DOS version number',0Dh,0Ah
 36101 0000700D 2D444F532076657273-
 36101 00007016 696F6E206E756D6265-
 36101 0000701F 720D0A             
 36102                                  MSG_1565:
 36103 00007022 34                      	db 52
 36104 00007023 2020244E2020204375-     	db '  $N   Current drive',0Dh,0Ah
 36104 0000702C 7272656E7420647269-
 36104 00007035 76650D0A           
 36105 00007039 202024472020203E20-     	db '  $G   > (greater-than sign)',0Dh,0Ah
 36105 00007042 28677265617465722D-
 36105 0000704B 7468616E207369676E-
 36105 00007054 290D0A             
 36106                                  MSG_1566:
 36107 00007057 2C                      	db 44
 36108 00007058 2020244C2020203C20-     	db '  $L   < (less-than sign)',0Dh,0Ah
 36108 00007061 286C6573732D746861-
 36108 0000706A 6E207369676E290D0A 
 36109 00007073 202024422020207C20-     	db '  $B   | (pipe)',0Dh,0Ah
 36109 0000707C 2870697065290D0A   
 36110                                  MSG_1567:
 36111 00007084 79                      	db 121
 36112 00007085 202024482020204261-     	db '  $H   Backspace (erases previous character)',0Dh,0Ah
 36112 0000708E 636B73706163652028-
 36112 00007097 657261736573207072-
 36112 000070A0 6576696F7573206368-
 36112 000070A9 61726163746572290D-
 36112 000070B2 0A                 
 36113 000070B3 202024452020204573-     	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
 36113 000070BC 6361706520636F6465-
 36113 000070C5 202841534349492063-
 36113 000070CE 6F6465203237290D0A 
 36114 000070D7 2020245F2020204361-     	db '  $_   Carriage return and linefeed',0Dh,0Ah
 36114 000070E0 727269616765207265-
 36114 000070E9 7475726E20616E6420-
 36114 000070F2 6C696E65666565640D-
 36114 000070FB 0A                 
 36115 000070FC 0D0A                    	db 0Dh,0Ah
 36116                                  MSG_1568:
 36117 000070FE 4C                      	db 76
 36118 000070FF 547970652050524F4D-     	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
 36118 00007108 505420776974686F75-
 36118 00007111 7420706172616D6574-
 36118 0000711A 65727320746F207265-
 36118 00007123 736574207468652070-
 36118 0000712C 726F6D707420746F20-
 36118 00007135 746865206465666175-
 36118 0000713E 6C742073657474696E-
 36118 00007147 672E0D0A           
 36119                                  MSG_1580:
 36120 0000714B 47                      	db 71
 36121 0000714C 52656D6F7665732028-     	db 'Removes (deletes) a directory.',0Dh,0Ah
 36121 00007155 64656C657465732920-
 36121 0000715E 61206469726563746F-
 36121 00007167 72792E0D0A         
 36122 0000716C 0D0A                    	db 0Dh,0Ah
 36123 0000716E 524D444952205B6472-     	db 'RMDIR [drive:]path',0Dh,0Ah
 36123 00007177 6976653A5D70617468-
 36123 00007180 0D0A               
 36124 00007182 5244205B6472697665-     	db 'RD [drive:]path',0Dh,0Ah
 36124 0000718B 3A5D706174680D0A   
 36125                                  MSG_1600:
 36126 00007193 1C                      	db 28
 36127 00007194 52656E616D65732061-     	db 'Renames a file or files.',0Dh,0Ah
 36127 0000719D 2066696C65206F7220-
 36127 000071A6 66696C65732E0D0A   
 36128 000071AE 0D0A                    	db 0Dh,0Ah
 36129                                  MSG_1601:
 36130 000071B0 53                      	db 83
 36131 000071B1 52454E414D45205B64-     	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
 36131 000071BA 726976653A5D5B7061-
 36131 000071C3 74685D66696C656E61-
 36131 000071CC 6D65312066696C656E-
 36131 000071D5 616D65320D0A       
 36132 000071DB 52454E205B64726976-     	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
 36132 000071E4 653A5D5B706174685D-
 36132 000071ED 66696C656E616D6531-
 36132 000071F6 2066696C656E616D65-
 36132 000071FF 320D0A             
 36133 00007202 0D0A                    	db 0Dh,0Ah
 36134                                  MSG_1602:
 36135 00007204 4D                      	db 77
 36136 00007205 4E6F74652074686174-     	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 36136 0000720E 20796F752063616E6E-
 36136 00007217 6F7420737065636966-
 36136 00007220 792061206E65772064-
 36136 00007229 72697665206F722070-
 36136 00007232 61746820666F722079-
 36136 0000723B 6F7572206465737469-
 36136 00007244 6E6174696F6E206669-
 36136 0000724D 6C652E0D0A         
 36137                                  MSG_1620:
 36138 00007252 57                      	db 87
 36139 00007253 446973706C6179732C-     	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
 36139 0000725C 20736574732C206F72-
 36139 00007265 2072656D6F76657320-
 36139 0000726E 4D532D444F5320656E-
 36139 00007277 7669726F6E6D656E74-
 36139 00007280 207661726961626C65-
 36139 00007289 732E0D0A           
 36140 0000728D 0D0A                    	db 0Dh,0Ah
 36141 0000728F 534554205B76617269-     	db 'SET [variable=[string]]',0Dh,0Ah
 36141 00007298 61626C653D5B737472-
 36141 000072A1 696E675D5D0D0A     
 36142 000072A8 0D0A                    	db 0Dh,0Ah
 36143                                  MSG_1621:
 36144 000072AA 81                      	db 129
 36145 000072AB 20207661726961626C-     	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
 36145 000072B4 652020537065636966-
 36145 000072BD 696573207468652065-
 36145 000072C6 6E7669726F6E6D656E-
 36145 000072CF 742D7661726961626C-
 36145 000072D8 65206E616D652E0D0A 
 36146 000072E1 2020737472696E6720-     	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
 36146 000072EA 202020537065636966-
 36146 000072F3 696573206120736572-
 36146 000072FC 696573206F66206368-
 36146 00007305 617261637465727320-
 36146 0000730E 746F2061737369676E-
 36146 00007317 20746F207468652076-
 36146 00007320 61726961626C652E0D-
 36146 00007329 0A                 
 36147 0000732A 0D0A                    	db 0Dh,0Ah
 36148                                  MSG_1622:
 36149 0000732C 4B                      	db 75
 36150 0000732D 547970652053455420-     	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
 36150 00007336 776974686F75742070-
 36150 0000733F 6172616D6574657273-
 36150 00007348 20746F20646973706C-
 36150 00007351 617920746865206375-
 36150 0000735A 7272656E7420656E76-
 36150 00007363 69726F6E6D656E7420-
 36150 0000736C 7661726961626C6573-
 36150 00007375 2E0D0A             
 36151                                  MSG_1640:
 36152 00007378 34                      	db 52
 36153 00007379 446973706C61797320-     	db 'Displays or sets the system time.',0Dh,0Ah
 36153 00007382 6F7220736574732074-
 36153 0000738B 68652073797374656D-
 36153 00007394 2074696D652E0D0A   
 36154 0000739C 0D0A                    	db 0Dh,0Ah
 36155 0000739E 54494D45205B74696D-     	db 'TIME [time]',0Dh,0Ah
 36155 000073A7 655D0D0A           
 36156 000073AB 0D0A                    	db 0Dh,0Ah
 36157                                  MSG_1641:
 36158 000073AD 83                      	db 131
 36159 000073AE 547970652054494D45-     	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
 36159 000073B7 2077697468206E6F20-
 36159 000073C0 706172616D65746572-
 36159 000073C9 7320746F2064697370-
 36159 000073D2 6C6179207468652063-
 36159 000073DB 757272656E74207469-
 36159 000073E4 6D652073657474696E-
 36159 000073ED 6720616E6420612070-
 36159 000073F6 726F6D70740D0A     
 36160 000073FD 666F722061206E6577-     	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
 36160 00007406 206F6E652E20205072-
 36160 0000740F 65737320454E544552-
 36160 00007418 20746F206B65657020-
 36160 00007421 7468652073616D6520-
 36160 0000742A 74696D652E0D0A     
 36161                                  MSG_1660:
 36162 00007431 46                      	db 70
 36163 00007432 446973706C61797320-     	db 'Displays the contents of a text file.',0Dh,0Ah
 36163 0000743B 74686520636F6E7465-
 36163 00007444 6E7473206F66206120-
 36163 0000744D 746578742066696C65-
 36163 00007456 2E0D0A             
 36164 00007459 0D0A                    	db 0Dh,0Ah
 36165 0000745B 54595045205B647269-     	db 'TYPE [drive:][path]filename',0Dh,0Ah
 36165 00007464 76653A5D5B70617468-
 36165 0000746D 5D66696C656E616D65-
 36165 00007476 0D0A               
 36166                                  MSG_1680:
 36167 00007478 25                      	db 37
 36168 00007479 446973706C61797320-     	db 'Displays the MS-DOS version.',0Dh,0Ah
 36168 00007482 746865204D532D444F-
 36168 0000748B 532076657273696F6E-
 36168 00007494 2E0D0A             
 36169 00007497 0D0A                    	db 0Dh,0Ah
 36170 00007499 5645520D0A              	db 'VER',0Dh,0Ah
 36171                                  MSG_1700:
 36172 0000749E B1                      	db 177
 36173 0000749F 54656C6C73204D532D-     	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
 36173 000074A8 444F53207768657468-
 36173 000074B1 657220746F20766572-
 36173 000074BA 696679207468617420-
 36173 000074C3 796F75722066696C65-
 36173 000074CC 732061726520777269-
 36173 000074D5 7474656E20636F7272-
 36173 000074DE 6563746C7920746F20-
 36173 000074E7 610D0A             
 36174 000074EA 6469736B2E0D0A          	db 'disk.',0Dh,0Ah
 36175 000074F1 0D0A                    	db 0Dh,0Ah
 36176 000074F3 564552494659205B4F-     	db 'VERIFY [ON | OFF]',0Dh,0Ah
 36176 000074FC 4E207C204F46465D0D-
 36176 00007505 0A                 
 36177 00007506 0D0A                    	db 0Dh,0Ah
 36178 00007508 547970652056455249-     	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
 36178 00007511 465920776974686F75-
 36178 0000751A 74206120706172616D-
 36178 00007523 6574657220746F2064-
 36178 0000752C 6973706C6179207468-
 36178 00007535 652063757272656E74-
 36178 0000753E 205645524946592073-
 36178 00007547 657474696E672E0D0A 
 36179                                  MSG_1720:              
 36180 00007550 52                      	db 82
 36181 00007551 446973706C61797320-     	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
 36181 0000755A 746865206469736B20-
 36181 00007563 766F6C756D65206C61-
 36181 0000756C 62656C20616E642073-
 36181 00007575 657269616C206E756D-
 36181 0000757E 6265722C2069662074-
 36181 00007587 686579206578697374-
 36181 00007590 2E0D0A             
 36182 00007593 0D0A                    	db 0Dh,0Ah
 36183 00007595 564F4C205B64726976-     	db 'VOL [drive:]',0Dh,0Ah
 36183 0000759E 653A5D0D0A         
 36184                                  MSG_1740:
 36185 000075A3 5B                      	db 91
 36186 000075A4 43616C6C73206F6E65-     	db 'Calls one batch program from another.',0Dh,0Ah
 36186 000075AD 206261746368207072-
 36186 000075B6 6F6772616D2066726F-
 36186 000075BF 6D20616E6F74686572-
 36186 000075C8 2E0D0A             
 36187 000075CB 0D0A                    	db 0Dh,0Ah
 36188 000075CD 43414C4C205B647269-     	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
 36188 000075D6 76653A5D5B70617468-
 36188 000075DF 5D66696C656E616D65-
 36188 000075E8 205B62617463682D70-
 36188 000075F1 6172616D6574657273-
 36188 000075FA 5D0D0A             
 36189 000075FD 0D0A                    	db 0Dh,0Ah
 36190                                  MSG_1741:
 36191 000075FF 72                      	db 114
 36192 00007600 202062617463682D70-     	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
 36192 00007609 6172616D6574657273-
 36192 00007612 202020537065636966-
 36192 0000761B 69657320616E792063-
 36192 00007624 6F6D6D616E642D6C69-
 36192 0000762D 6E6520696E666F726D-
 36192 00007636 6174696F6E20726571-
 36192 0000763F 756972656420627920-
 36192 00007648 7468650D0A         
 36193 0000764D 202020202020202020-     	db '                     batch program.',0Dh,0Ah
 36193 00007656 202020202020202020-
 36193 0000765F 202020626174636820-
 36193 00007668 70726F6772616D2E0D-
 36193 00007671 0A                 
 36194                                  MSG_1760:	
 36195 00007672 4C                      	db 76
 36196 00007673 5265636F7264732063-     	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
 36196 0000767C 6F6D6D656E74732028-
 36196 00007685 72656D61726B732920-
 36196 0000768E 696E20612062617463-
 36196 00007697 682066696C65206F72-
 36196 000076A0 20434F4E4649472E53-
 36196 000076A9 59532E0D0A         
 36197 000076AE 0D0A                    	db 0Dh,0Ah
 36198 000076B0 52454D205B636F6D6D-     	db 'REM [comment]',0Dh,0Ah
 36198 000076B9 656E745D0D0A       
 36199                                  MSG_1780:
 36200 000076BF 6B                      	db 107
 36201 000076C0 53757370656E647320-     	db 'Suspends processing of a batch program and displays the message "'
 36201 000076C9 70726F63657373696E-
 36201 000076D2 67206F662061206261-
 36201 000076DB 7463682070726F6772-
 36201 000076E4 616D20616E64206469-
 36201 000076ED 73706C617973207468-
 36201 000076F6 65206D657373616765-
 36201 000076FF 2022               
 36202 00007701 507265737320616E79-     	db 'Press any',0Dh,0Ah
 36202 0000770A 0D0A               
 36203 0000770C 6B657920746F20636F-     	db 'key to continue...."',0Dh,0Ah
 36203 00007715 6E74696E75652E2E2E-
 36203 0000771E 2E220D0A           
 36204 00007722 0D0A                    	db 0Dh,0Ah
 36205 00007724 50415553450D0A          	db 'PAUSE',0Dh,0Ah
 36206                                  MSG_1800:
 36207 0000772B 4D                      	db 77
 36208 0000772C 446973706C61797320-     	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
 36208 00007735 6D657373616765732C-
 36208 0000773E 206F72207475726E73-
 36208 00007747 20636F6D6D616E642D-
 36208 00007750 6563686F696E67206F-
 36208 00007759 6E206F72206F66662E-
 36208 00007762 0D0A               
 36209 00007764 0D0A                    	db 0Dh,0Ah
 36210 00007766 20204543484F205B4F-     	db '  ECHO [ON | OFF]',0Dh,0Ah
 36210 0000776F 4E207C204F46465D0D-
 36210 00007778 0A                 
 36211                                  MSG_1801:
 36212 00007779 57                      	db 87
 36213 0000777A 20204543484F205B6D-     	db '  ECHO [message]',0Dh,0Ah
 36213 00007783 6573736167655D0D0A 
 36214 0000778C 0D0A                    	db 0Dh,0Ah
 36215 0000778E 54797065204543484F-     	db 'Type ECHO without parameters to display the current echo setting.'
 36215 00007797 20776974686F757420-
 36215 000077A0 706172616D65746572-
 36215 000077A9 7320746F2064697370-
 36215 000077B2 6C6179207468652063-
 36215 000077BB 757272656E74206563-
 36215 000077C4 686F2073657474696E-
 36215 000077CD 672E               
 36216 000077CF 0D0A                    	db 0Dh,0Ah
 36217                                  MSG_1820:
 36218 000077D1 47                      	db 71
 36219 000077D2 44697265637473204D-     	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
 36219 000077DB 532D444F5320746F20-
 36219 000077E4 61206C6162656C6C65-
 36219 000077ED 64206C696E6520696E-
 36219 000077F6 206120626174636820-
 36219 000077FF 70726F6772616D2E0D-
 36219 00007808 0A                 
 36220 00007809 0D0A                    	db 0Dh,0Ah
 36221 0000780B 474F544F206C616265-     	db 'GOTO label',0Dh,0Ah
 36221 00007814 6C0D0A             
 36222 00007817 0D0A                    	db 0Dh,0Ah
 36223                                  MSG_1821:
 36224 00007819 8A                      	db 138
 36225 0000781A 20206C6162656C2020-     	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
 36225 00007823 205370656369666965-
 36225 0000782C 732061207465787420-
 36225 00007835 737472696E67207573-
 36225 0000783E 656420696E20746865-
 36225 00007847 206261746368207072-
 36225 00007850 6F6772616D20617320-
 36225 00007859 61206C6162656C2E0D-
 36225 00007862 0A                 
 36226 00007863 0D0A                    	db 0Dh,0Ah
 36227 00007865 596F75207479706520-     	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
 36227 0000786E 61206C6162656C206F-
 36227 00007877 6E2061206C696E6520-
 36227 00007880 627920697473656C66-
 36227 00007889 2C20626567696E6E69-
 36227 00007892 6E6720776974682061-
 36227 0000789B 20636F6C6F6E2E0D0A 
 36228                                  MSG_1840:
 36229 000078A4 4A                      	db 74
 36230 000078A5 4368616E6765732074-     	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
 36230 000078AE 686520706F73697469-
 36230 000078B7 6F6E206F6620726570-
 36230 000078C0 6C61636561626C6520-
 36230 000078C9 706172616D65746572-
 36230 000078D2 7320696E2061206261-
 36230 000078DB 7463682066696C652E-
 36230 000078E4 0D0A               
 36231 000078E6 0D0A                    	db 0Dh,0Ah
 36232 000078E8 53484946540D0A          	db 'SHIFT',0Dh,0Ah
 36233                                  MSG_1860:
 36234 000078EF 5A                      	db 90
 36235 000078F0 506572666F726D7320-     	db 'Performs conditional processing in batch programs.',0Dh,0Ah
 36235 000078F9 636F6E646974696F6E-
 36235 00007902 616C2070726F636573-
 36235 0000790B 73696E6720696E2062-
 36235 00007914 617463682070726F67-
 36235 0000791D 72616D732E0D0A     
 36236 00007924 0D0A                    	db 0Dh,0Ah
 36237 00007926 4946205B4E4F545D20-     	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
 36237 0000792F 4552524F524C455645-
 36237 00007938 4C206E756D62657220-
 36237 00007941 636F6D6D616E640D0A 
 36238                                  MSG_1861:
 36239 0000794A 46                      	db 70
 36240 0000794B 4946205B4E4F545D20-     	db 'IF [NOT] string1==string2 command',0Dh,0Ah
 36240 00007954 737472696E67313D3D-
 36240 0000795D 737472696E67322063-
 36240 00007966 6F6D6D616E640D0A   
 36241 0000796E 4946205B4E4F545D20-     	db 'IF [NOT] EXIST filename command',0Dh,0Ah
 36241 00007977 45584953542066696C-
 36241 00007980 656E616D6520636F6D-
 36241 00007989 6D616E640D0A       
 36242 0000798F 0D0A                    	db 0Dh,0Ah
 36243                                  MSG_1862:
 36244 00007991 7D                      	db 125
 36245 00007992 20204E4F5420202020-     	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
 36245 0000799B 202020202020202020-
 36245 000079A4 202053706563696669-
 36245 000079AD 65732074686174204D-
 36245 000079B6 532D444F532073686F-
 36245 000079BF 756C64206361727279-
 36245 000079C8 206F75742074686520-
 36245 000079D1 636F6D6D616E64206F-
 36245 000079DA 6E6C790D0A         
 36246 000079DF 202020202020202020-     	db '                    if the condition is false.',0Dh,0Ah
 36246 000079E8 202020202020202020-
 36246 000079F1 202069662074686520-
 36246 000079FA 636F6E646974696F6E-
 36246 00007A03 2069732066616C7365-
 36246 00007A0C 2E0D0A             
 36247                                  MSG_1863:
 36248 00007A0F A2                      	db 162
 36249 00007A10 20204552524F524C45-     	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
 36249 00007A19 56454C206E756D6265-
 36249 00007A22 722053706563696669-
 36249 00007A2B 657320612074727565-
 36249 00007A34 20636F6E646974696F-
 36249 00007A3D 6E2069662074686520-
 36249 00007A46 6C6173742070726F67-
 36249 00007A4F 72616D2072756E2072-
 36249 00007A58 657475726E65640D0A 
 36250 00007A61 202020202020202020-     	db '                    '
 36250 00007A6A 202020202020202020-
 36250 00007A73 2020               
 36251 00007A75 616E20657869742063-     	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
 36251 00007A7E 6F646520657175616C-
 36251 00007A87 20746F206F72206772-
 36251 00007A90 656174657220746861-
 36251 00007A99 6E20746865206E756D-
 36251 00007AA2 626572207370656369-
 36251 00007AAB 666965642E0D0A     
 36252                                  MSG_1864:
 36253 00007AB2 66                      	db 102
 36254 00007AB3 2020636F6D6D616E64-     	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
 36254 00007ABC 202020202020202020-
 36254 00007AC5 202053706563696669-
 36254 00007ACE 65732074686520636F-
 36254 00007AD7 6D6D616E6420746F20-
 36254 00007AE0 6361727279206F7574-
 36254 00007AE9 206966207468652063-
 36254 00007AF2 6F6E646974696F6E20-
 36254 00007AFB 69730D0A           
 36255 00007AFF 202020202020202020-     	db '                    met.',0Dh,0Ah
 36255 00007B08 202020202020202020-
 36255 00007B11 20206D65742E0D0A   
 36256                                  MSG_1865:
 36257 00007B19 6A                      	db 106
 36258 00007B1A 2020737472696E6731-     	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
 36258 00007B23 3D3D737472696E6732-
 36258 00007B2C 202053706563696669-
 36258 00007B35 657320612074727565-
 36258 00007B3E 20636F6E646974696F-
 36258 00007B47 6E2069662074686520-
 36258 00007B50 737065636966696564-
 36258 00007B59 207465787420737472-
 36258 00007B62 696E67730D0A       
 36259 00007B68 202020202020202020-     	db '                    match.',0Dh,0Ah
 36259 00007B71 202020202020202020-
 36259 00007B7A 20206D617463682E0D-
 36259 00007B83 0A                 
 36260                                  MSG_1866:
 36261 00007B84 67                      	db 103
 36262 00007B85 202045584953542066-     	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
 36262 00007B8E 696C656E616D652020-
 36262 00007B97 202053706563696669-
 36262 00007BA0 657320612074727565-
 36262 00007BA9 20636F6E646974696F-
 36262 00007BB2 6E2069662074686520-
 36262 00007BBB 737065636966696564-
 36262 00007BC4 2066696C656E616D65-
 36262 00007BCD 0D0A               
 36263 00007BCF 202020202020202020-     	db '                    exists.',0Dh,0Ah
 36263 00007BD8 202020202020202020-
 36263 00007BE1 20206578697374732E-
 36263 00007BEA 0D0A               
 36264                                  MSG_1880:
 36265 00007BEC 77                      	db 119
 36266 00007BED 52756E732061207370-     	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
 36266 00007BF6 656369666965642063-
 36266 00007BFF 6F6D6D616E6420666F-
 36266 00007C08 722065616368206669-
 36266 00007C11 6C6520696E20612073-
 36266 00007C1A 6574206F662066696C-
 36266 00007C23 65732E0D0A         
 36267 00007C28 0D0A                    	db 0Dh,0Ah
 36268 00007C2A 464F52202576617269-     	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
 36268 00007C33 61626C6520494E2028-
 36268 00007C3C 7365742920444F2063-
 36268 00007C45 6F6D6D616E64205B63-
 36268 00007C4E 6F6D6D616E642D7061-
 36268 00007C57 72616D65746572735D-
 36268 00007C60 0D0A               
 36269 00007C62 0D0A                    	db 0Dh,0Ah
 36270                                  MSG_1881:
 36271 00007C64 7D                      	db 125
 36272 00007C65 202025766172696162-     	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
 36272 00007C6E 6C6520205370656369-
 36272 00007C77 666965732061207265-
 36272 00007C80 706C61636561626C65-
 36272 00007C89 20706172616D657465-
 36272 00007C92 722E0D0A           
 36273 00007C96 202028736574292020-     	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
 36273 00007C9F 202020205370656369-
 36273 00007CA8 666965732061207365-
 36273 00007CB1 74206F66206F6E6520-
 36273 00007CBA 6F72206D6F72652066-
 36273 00007CC3 696C65732E20205769-
 36273 00007CCC 6C646361726473206D-
 36273 00007CD5 617920626520757365-
 36273 00007CDE 642E0D0A           
 36274                                  MSG_1882:
 36275 00007CE2 56                      	db 86
 36276 00007CE3 2020636F6D6D616E64-     	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
 36276 00007CEC 202020205370656369-
 36276 00007CF5 666965732074686520-
 36276 00007CFE 636F6D6D616E642074-
 36276 00007D07 6F206361727279206F-
 36276 00007D10 757420666F72206561-
 36276 00007D19 63682066696C652E0D-
 36276 00007D22 0A                 
 36277 00007D23 2020636F6D6D616E64-     	db '  command-parameters',0Dh,0Ah
 36277 00007D2C 2D706172616D657465-
 36277 00007D35 72730D0A           
 36278                                  MSG_1883:
 36279 00007D39 A2                      	db 162
 36280 00007D3A 202020202020202020-     	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
 36280 00007D43 202020205370656369-
 36280 00007D4C 666965732070617261-
 36280 00007D55 6D6574657273206F72-
 36280 00007D5E 207377697463686573-
 36280 00007D67 20666F722074686520-
 36280 00007D70 737065636966696564-
 36280 00007D79 20636F6D6D616E642E-
 36280 00007D82 0D0A               
 36281 00007D84 0D0A                    	db 0Dh,0Ah
 36282 00007D86 546F20757365207468-     	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
 36282 00007D8F 6520464F5220636F6D-
 36282 00007D98 6D616E6420696E2061-
 36282 00007DA1 206261746368207072-
 36282 00007DAA 6F6772616D2C207370-
 36282 00007DB3 656369667920252576-
 36282 00007DBC 61726961626C652069-
 36282 00007DC5 6E7374656164206F66-
 36282 00007DCE 0D0A               
 36283 00007DD0 257661726961626C65-     	db '%variable.',0Dh,0Ah
 36283 00007DD9 2E0D0A             
 36284                                  MSG_1900:
 36285 00007DDC 17                      	db 23
 36286 00007DDD 526573657276656420-     	db 'Reserved command name',0Dh,0Ah
 36286 00007DE6 636F6D6D616E64206E-
 36286 00007DEF 616D650D0A         
 36287                                  MSG_1920:
 36288 00007DF4 2F                      	db 47
 36289 00007DF5 4C6F61647320612070-     	db 'Loads a program into the upper memory area.',0Dh,0Ah
 36289 00007DFE 726F6772616D20696E-
 36289 00007E07 746F20746865207570-
 36289 00007E10 706572206D656D6F72-
 36289 00007E19 7920617265612E0D0A 
 36290 00007E22 0D0A                    	db 0Dh,0Ah
 36291                                  MSG_1921:
 36292 00007E24 58                      	db 88
 36293 00007E25 4C4F41444849474820-     	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 36293 00007E2E 5B64726976653A5D5B-
 36293 00007E37 706174685D66696C65-
 36293 00007E40 6E616D65205B706172-
 36293 00007E49 616D65746572735D0D-
 36293 00007E52 0A                 
 36294 00007E53 4C48205B6472697665-     	db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
 36294 00007E5C 3A5D5B706174685D66-
 36294 00007E65 696C656E616D65205B-
 36294 00007E6E 706172616D65746572-
 36294 00007E77 735D0D0A           
 36295 00007E7B 0D0A                    	db 0Dh,0Ah
 36296                                  MSG_1922:
 36297 00007E7D 71                      	db 113
 36298 00007E7E 2020706172616D6574-     	db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
 36298 00007E87 657273202020537065-
 36298 00007E90 63696669657320616E-
 36298 00007E99 7920636F6D6D616E64-
 36298 00007EA2 2D6C696E6520696E66-
 36298 00007EAB 6F726D6174696F6E20-
 36298 00007EB4 726571756972656420-
 36298 00007EBD 6279207468650D0A   
 36299 00007EC5 202020202020202020-     	db '               program you want to load.',0Dh,0Ah
 36299 00007ECE 20202020202070726F-
 36299 00007ED7 6772616D20796F7520-
 36299 00007EE0 77616E7420746F206C-
 36299 00007EE9 6F61642E0D0A       
 36300                                  
 36301                                  ; ---------------------------------------------------------------------------
 36302                                  
 36303                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36304                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h
 36305                                  
 36306                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36307                                  
 36308                                  $M_CLS_3:
 36309 00007EEF 0E                      	push	cs		; CLASS_F
 36310 00007EF0 07                      	pop	es
 36311 00007EF1 8D3E[B057]              	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
 36312                                  	; 15/04/2023
 36313                                  	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
 36314 00007EF5 C3                      	retn
 36315                                  
 36316                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36317                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh
 36318                                  
 36319                                  ; ---------------------------------------------------------------------------
 36320                                  ; Class 1 messages
 36321                                  ; ---------------------------------------------------------------------------
 36322                                  	
 36323                                  $M_CLASS_1_STRUC:
 36324 00007EF6 01                      	db 1			; $M_CLASS_ID
 36325 00007EF7 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36326 00007EF9 04                      	db 4			; Class_1_MessageCount
 36327                                  $M_ID_1_1:
 36328 00007EFA 0200                    	dw 2			; Message Number = 2
 36329 00007EFC 1000                    	dw EXTEND2-$+2 ; 10h	; Message offset from message number
 36330                                  $M_ID_1_2:
 36331 00007EFE 0300                    	dw 3			; Message Number = 3
 36332 00007F00 1B00                    	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
 36333                                  $M_ID_1_3:
 36334 00007F02 0800                    	dw 8			; Message Number = 8
 36335 00007F04 2600                    	dw EXTEND8-$+2 ; 26h	; Message offset from message number
 36336                                  $M_ID_1_4:
 36337 00007F06 FFFF                    	dw 0FFFFh		; Message Number = -1
 36338 00007F08 3600                    	dw EXTEND999-$+2 ; 36h	; Message offset from message number
 36339                                  
 36340                                  ; ---------------------------------------------------------------------------
 36341                                  
 36342                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
 36343                                  EXTEND2:
 36344 00007F0A 0E                      	db 14
 36345 00007F0B 46696C65206E6F7420-     	db 'File not found'
 36345 00007F14 666F756E64         
 36346                                  EXTEND3:
 36347 00007F19 0E                      	db 14
 36348 00007F1A 50617468206E6F7420-     	db 'Path not found'
 36348 00007F23 666F756E64         
 36349                                  EXTEND8:
 36350 00007F28 13                      	db 19
 36351 00007F29 496E73756666696369-     	db 'Insufficient memory'
 36351 00007F32 656E74206D656D6F72-
 36351 00007F3B 79                 
 36352                                  EXTEND999:
 36353 00007F3C 11                      	db 17
 36354 00007F3D 457874656E64656420-     	db 'Extended Error %1'
 36354 00007F46 4572726F72202531   
 36355                                  
 36356                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36357                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h
 36358                                  
 36359                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36360                                  $M_MSGSERV_1:
 36361 00007F4E 0E                      	push	cs
 36362 00007F4F 07                      	pop	es
 36363 00007F50 8D3E[F67E]              	lea	di,$M_CLASS_1_STRUC
 36364                                  	; 15/04/2023
 36365                                  	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
 36366 00007F54 C3                      	retn
 36367                                  
 36368                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36369                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h
 36370                                  
 36371                                  ; ---------------------------------------------------------------------------
 36372                                  ; Class 2 messages
 36373                                  ; ---------------------------------------------------------------------------
 36374                                  	
 36375                                  $M_CLASS_2_STRUC:
 36376 00007F55 02                      	db 2			; $M_CLASS_ID
 36377 00007F56 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36378 00007F58 01                      	db 1			; Class_2_MessageCount
 36379                                  $M_ID_2_1:
 36380 00007F59 FFFF                    	dw 0FFFFh		; Message Number = -1
 36381 00007F5B 0400                    	dw PARSE999-$+2 ; 4	; Message offset from message number
 36382                                  ; ---------------------------------------------------------------------------
 36383                                  
 36384                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
 36385                                  PARSE999:
 36386 00007F5D 0E                      	db 14
 36387 00007F5E 506172736520457272-     	db 'Parse Error %1'
 36387 00007F67 6F72202531         
 36388                                  
 36389                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36390                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h
 36391                                  
 36392                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36393                                  $M_MSGSERV_2:
 36394 00007F6C 0E                      	push	cs
 36395 00007F6D 07                      	pop	es
 36396 00007F6E 8D3E[557F]              	lea	di,$M_CLASS_2_STRUC
 36397                                  	; 15/04/2023
 36398                                  	;add	cx,29	; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
 36399 00007F72 C3                      	retn
 36400                                  
 36401                                  ;============================================================================
 36402                                  ; TRANMSG.ASM, MSDOS 6.0, 1991
 36403                                  ;============================================================================
 36404                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36405                                  
 36406                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h
 36407                                  
 36408                                  ;****************************************************
 36409                                  ;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
 36410                                  ;****************************************************
 36411                                  
 36412                                  msg_disp_class:
 36413 00007F73 FF                      	db	util_msg_class ; 0FFh
 36414                                  msg_cont_flag:
 36415 00007F74 00                      	db	no_cont_flag ; 0
 36416                                  
 36417                                  ;  extended error string output
 36418                                  extend_buf_ptr:
 36419 00007F75 0000                    	dw	0			;AN000;set to no message
 36420                                  extend_buf_sub:
 36421 00007F77 00                      	db	0			;AN000;set to no substitutions
 36422 00007F78 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36423 00007F79 00                      	db	0			;AN000;reserved
 36424                                  extend_buf_off:
 36425 00007F7A [D08C]                  	dw	string_ptr_2		;AN000;offset of arg
 36426                                  extend_buf_seg:
 36427 00007F7C 0000                    	dw	0			;AN000;segment of arg
 36428 00007F7E 00                      	db	0			;AN000;first subst
 36429 00007F7F 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36430 00007F80 80                      	db	128			;AN000;maximum width
 36431 00007F81 00                      	db	0			;AN000;minimum width
 36432 00007F82 20                      	db	blank ; 20h		;AN000;pad character
 36433                                  
 36434                                  ;  "Duplicate file name or file not found"
 36435                                  RENERR_PTR:
 36436 00007F83 EA03                    	dw	1002			;AN000;message number
 36437 00007F85 00                      	db	no_subst ; 0		;AN000;number of subst
 36438                                  
 36439                                  ;  "Invalid path or file name"
 36440                                  BADCPMES_PTR:
 36441 00007F86 EB03                    	dw	1003			;AN000;message number
 36442 00007F88 00                      	db	no_subst ; 0		;AN000;number of subst
 36443                                  
 36444                                  ;  "Insufficient disk space"
 36445                                  NOSPACE_PTR:
 36446 00007F89 EC03                    	dw	1004			;AN000;message number
 36447 00007F8B 00                      	db	no_subst ; 0		;AN000;number of subst
 36448                                  
 36449                                  ;  "Out of environment space"
 36450                                  ENVERR_PTR:
 36451 00007F8C EF03                    	dw	1007			;AN000;message number
 36452 00007F8E 00                      	db	no_subst ; 0		;AN000;number of subst
 36453                                  
 36454                                  ;  "File creation error"
 36455                                  FULLDIR_PTR:
 36456 00007F8F F003                    	dw	1008			;AN000;message number
 36457 00007F91 00                      	db	no_subst ; 0		;AN000;number of subst
 36458                                  
 36459                                  ;  "Batch file missing",13,10
 36460                                  BADBAT_PTR:
 36461 00007F92 F103                    	dw	1009			;AN000;message number
 36462 00007F94 00                      	db	no_subst ; 0		;AN000;number of subst
 36463                                  
 36464                                  ;  "Insert disk with batch file",13,10
 36465                                  NEEDBAT_PTR:
 36466 00007F95 F203                    	dw	1010			;AN000;message number
 36467 00007F97 00                      	db	no_subst ; 0		;AN000;number of subst
 36468                                  
 36469                                  ;  "Bad command or file name",13,10
 36470                                  BADNAM_PTR:
 36471 00007F98 F303                    	dw	1011			;AN000;message number
 36472 00007F9A 00                      	db	no_subst ; 0		;AN000;number of subst
 36473                                  
 36474                                  ;  "Access denied",13,10
 36475                                  ACCDEN_PTR:
 36476 00007F9B F603                    	dw	1014			;AN000;message number
 36477 00007F9D 00                      	db	no_subst ; 0		;AN000;number of subst
 36478                                  
 36479                                  ;  "File cannot be copied onto itself",13,10
 36480                                  OVERWR_PTR:
 36481 00007F9E F703                    	dw	1015			;AN000;message number
 36482 00007FA0 00                      	db	no_subst ; 0		;AN000;number of subst
 36483                                  
 36484                                  ;  "Content of destination lost before copy",13,10
 36485                                  LOSTERR_PTR:
 36486 00007FA1 F803                    	dw	1016			;AN000;message number
 36487 00007FA3 00                      	db	no_subst ; 0		;AN000;number of subst
 36488                                  
 36489                                  ;  "Invalid filename or file not found",13,10
 36490                                  INORNOT_PTR:
 36491 00007FA4 F903                    	dw	1017			;AN000;message number
 36492 00007FA6 00                      	db	no_subst		;AN000;number of subst
 36493                                  
 36494                                  ;  "%1 File(s) copied",13,10
 36495                                  copied_ptr:
 36496 00007FA7 FA03                    	dw	1018			;AN000;message number
 36497 00007FA9 01                      	db	1			;AN000;number of subst
 36498 00007FAA 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36499 00007FAB 00                      	db	0			;AN000;reserved
 36500 00007FAC [D28C]                  	dw	Copy_num		;AN000;offset of arg
 36501 00007FAE 0000                    	dw	0			;AN000;segment of arg
 36502 00007FB0 01                      	db	1			;AN000;first subst
 36503 00007FB1 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36504                                  					;AN000;binary to decimal
 36505 00007FB2 09                      	db	9			;AN000;maximum width
 36506 00007FB3 09                      	db	9			;AN000;minimum width
 36507 00007FB4 20                      	db	blank ; 20h		;AN000;pad character
 36508                                  
 36509                                  ;  "%1 File(s) "
 36510                                  dirmes_ptr:
 36511 00007FB5 FB03                    	dw	1019			;AN000;message number
 36512 00007FB7 01                      	db	1			;AN000;number of subst
 36513 00007FB8 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36514 00007FB9 00                      	db	0			;AN000;reserved
 36515 00007FBA [D58C]                  	dw	Dir_Num			;AN000;offset of arg
 36516 00007FBC 0000                    	dw	0			;AN000;segment of arg
 36517 00007FBE 01                      	db	1			;AN000;first subst
 36518 00007FBF A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36519                                  					;AN000;binary to decimal
 36520 00007FC0 09                      	db	9			;AN000;maximum width
 36521 00007FC1 09                      	db	9			;AN000;minimum width
 36522 00007FC2 20                      	db	blank ; 20h		;AN000;pad character
 36523                                  
 36524                                  ;  "%1 bytes free",13,10
 36525                                  bytmes_ptr:
 36526 00007FC3 FC03                    	dw	1020			;AN000;message number
 36527 00007FC5 01                      	db	1			;AN000;number of subst
 36528 00007FC6 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36529 00007FC7 00                      	db	0			;AN000;reserved
 36530 00007FC8 [D78C]                  	dw	Bytes_Free		;AN000;offset of arg
 36531 00007FCA 0000                    	dw	0			;AN000;segment of arg
 36532 00007FCC 01                      	db	1			;AN000;first subst
 36533 00007FCD B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 36534                                  					;AN000;long binary to decimal
 36535 00007FCE 1C                      	db	28			;AN000;maximum width
 36536 00007FCF 1C                      	db	28			;AN000;minimum width
 36537 00007FD0 20                      	db	blank ; 20h		;AN000;pad character
 36538                                  
 36539                                  ;  "Invalid drive specification",13,10
 36540                                  baddrv_ptr:
 36541 00007FD1 FD03                    	dw	1021			;AN000;message number
 36542 00007FD3 00                      	db	no_subst ; 0		;AN000;number of subst
 36543                                  
 36544                                  ;  "Code page %1 not prepared for system",13,10
 36545                                  cp_not_set_ptr:
 36546 00007FD4 FE03                    	dw	1022			;AN000;message number
 36547 00007FD6 01                      	db	1			;AN000;number of subst
 36548 00007FD7 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36549 00007FD8 00                      	db	0			;AN000;reserved
 36550 00007FD9 [4A8C]                  	dw	system_cpage		;AN000;offset of arg
 36551 00007FDB 0000                    	dw	0			;AN000;segment of arg
 36552 00007FDD 01                      	db	1			;AN000;first subst
 36553 00007FDE A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36554                                  					;AN000;binary to decimal
 36555 00007FDF 05                      	db	5			;AN000;maximum width
 36556 00007FE0 01                      	db	1			;AN000;minimum width
 36557 00007FE1 20                      	db	blank ; 20h		;AN000;pad character
 36558                                  
 36559                                  ;  "Code page %1 not prepared for all devices",13,10
 36560                                  cp_not_all_ptr:
 36561 00007FE2 FF03                    	dw	1023			;AN000;message number
 36562 00007FE4 01                      	db	1			;AN000;number of subst
 36563 00007FE5 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 36564 00007FE6 00                      	db	0			;AN000;reserved
 36565 00007FE7 [4A8C]                  	dw	system_cpage		;AN000;offset of arg
 36566 00007FE9 0000                    	dw	0			;AN000;segment of arg
 36567 00007FEB 01                      	db	1			;AN000;first subst
 36568 00007FEC A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36569                                  					;AN000;binary to decimal
 36570 00007FED 05                      	db	5			;AN000;maximum width
 36571 00007FEE 01                      	db	1			;AN000;minimum width
 36572 00007FEF 20                      	db	blank ; 20h		;AN000;pad character
 36573                                  
 36574                                  ;  "Active code page: %1",13,10
 36575                                  cp_active_ptr:
 36576 00007FF0 0004                    	dw	1024			;AN000;message number
 36577 00007FF2 01                      	db	1			;AN000;number of subst
 36578 00007FF3 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36579 00007FF4 00                      	db	0			;AN000;reserved
 36580 00007FF5 [4A8C]                  	dw	system_cpage		;AN000;offset of arg
 36581 00007FF7 0000                    	dw	0			;AN000;segment of arg
 36582 00007FF9 01                      	db	1			;AN000;first subst
 36583 00007FFA A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36584                                  					;AN000;binary to decimal
 36585 00007FFB 05                      	db	5			;AN000;maximum width
 36586 00007FFC 01                      	db	1			;AN000;minimum width
 36587 00007FFD 20                      	db	blank ; 20h		;AN000;pad character
 36588                                  
 36589                                  ;  "NLSFUNC not installed",13,10
 36590                                  NLSFUNC_PTR:
 36591 00007FFE 0104                    	dw	1025			;AN000;message number
 36592 00008000 00                      	db	no_subst ; 0		;AN000;number of subst
 36593                                  
 36594                                  ;  "Invalid code page",13,10
 36595                                  INV_CODE_PAGE:
 36596 00008001 0204                    	dw	1026			;AN000;message number
 36597 00008003 00                      	db	no_subst ; 0		;AN000;number of subst
 36598                                  
 36599                                  ;  "Current drive is no longer valid"
 36600                                  BADCURDRV:
 36601 00008004 0304                    	dw	1027			;AN000;message number
 36602 00008006 00                      	db	no_subst ; 0		;AN000;number of subst
 36603                                  
 36604                                  ;  "Press any key to continue"
 36605                                  PAUSEMES_PTR:
 36606 00008007 0404                    	dw	1028			;AN000;message number
 36607 00008009 00                      	db	no_subst ; 0		;AN000;number of subst
 36608                                  
 36609                                  ;  "Label not found",13,10
 36610                                  BADLAB_PTR:
 36611 0000800A 0504                    	dw	1029			;AN000;message number
 36612 0000800C 00                      	db	no_subst ; 0		;AN000;number of subst
 36613                                  
 36614                                  ;  "Syntax error",13,10
 36615                                  SYNTMES_PTR:
 36616 0000800D 0604                    	dw	1030			;AN000;message number
 36617 0000800F 00                      	db	no_subst ; 0		;AN000;number of subst
 36618                                  
 36619                                  ;  "Invalid date",13,10
 36620                                  BADDAT_PTR:
 36621 00008010 0704                    	dw	1031			;AN000;message number
 36622 00008012 00                      	db	no_subst ; 0		;AN000;number of subst
 36623                                  
 36624                                  ;  "Current date is %1 %2",13,10
 36625                                  CurDat_Ptr:
 36626 00008013 0804                    	dw	1032			;AN000;message number
 36627 00008015 02                      	db	2			;AN000;number of subst
 36628 00008016 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36629 00008017 00                      	db	0			;AN000;reserved
 36630 00008018 [4C8C]                  	dw	Arg_Buf			;AN000;offset of arg
 36631 0000801A 0000                    	dw	0			;AN000;segment of arg
 36632 0000801C 01                      	db	1			;AN000;first subst
 36633 0000801D 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36634 0000801E 03                      	db	3			;AN000;maximum width
 36635 0000801F 03                      	db	3			;AN000;minimum width
 36636 00008020 20                       	db	blank ; 20h		;AN000;pad character
 36637 00008021 0B                      	db	parm_block_size 	;AN000;size of sublist
 36638 00008022 00                      	db	0			;AN000;reserved
 36639                                  CurDat_yr:
 36640 00008023 0000                    	dw	0			;AN000;year
 36641                                  CurDat_mo_day:
 36642 00008025 0000                    	dw	0			;AN000;month,day
 36643 00008027 02                      	db	2			;AN000;second subst
 36644 00008028 34                      	db	34h ; DATE_MDY_4	;AN000;date
 36645 00008029 0A                      	db	10			;AN000;maximum width
 36646 0000802A 0A                      	db	10			;AN000;minimum width
 36647 0000802B 20                      	db	blank ; 20h		;AN000;pad character
 36648                                  
 36649                                  ;  "SunMonTueWedThuFriSat"
 36650                                  WeekTab:
 36651 0000802C 0904                    	dw	1033			;AN000;message number
 36652 0000802E 00                      	db	no_subst ; 0		;AN000;number of subst
 36653                                  
 36654                                  ;  "Enter new date (%1):"
 36655                                  
 36656                                  NewDat_Ptr:
 36657 0000802F 0A04                    	dw	1034			;AN000;message number
 36658 00008031 01                      	db	1			;AN000;number of subst
 36659 00008032 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36660 00008033 00                      	db	0			;AN000;reserved
 36661                                  NewDat_Format:
 36662 00008034 0000                    	dw	0			;AN000;offset of replacement
 36663 00008036 0000                    	dw	0			;AN000;segment of arg
 36664 00008038 01                      	db	1			;AN000;first subst
 36665 00008039 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36666 0000803A 08                      	db	8			;AN000;maximum width
 36667 0000803B 08                      	db	8			;AN000;minimum width
 36668 0000803C 20                      	db	blank ; 20h		;AN000;pad character
 36669                                  
 36670                                  ;  "Invalid time",13,10
 36671                                  
 36672                                  BadTim_Ptr:
 36673 0000803D 0B04                    	dw	1035			;AN000;message number
 36674 0000803F 00                      	db	no_subst ; 0		;AN000;number of subst
 36675                                  
 36676                                  ;  "Current time is %1",13,10
 36677                                  CurTim_Ptr:
 36678 00008040 0C04                    	dw	1036			;AN000;message number
 36679 00008042 01                      	db	1			;AN000;number of subst
 36680 00008043 0B                      	db	parm_block_size 	;AN000;size of sublist
 36681 00008044 00                      	db	0			;AN000;reserved
 36682                                  CurTim_hr_min:
 36683 00008045 0000                    	dw	0			;AN000;hours,minutes
 36684                                  CurTim_Sec_hn:
 36685 00008047 0000                    	dw	0			;AN000;seconds,hundredths
 36686 00008049 01                      	db	1			;AN000;first subst
 36687 0000804A A5                      	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
 36688                                  					;AC059;time
 36689 0000804B 0C                      	db	12			;AC059;maximum width
 36690 0000804C 0C                      	db	12			;AC059;minimum width
 36691 0000804D 20                      	db	blank ; 20h		;AN000;pad character
 36692                                  
 36693                                  ;  "Enter new time:"
 36694                                  NewTim_Ptr:
 36695 0000804E 0D04                    	dw	1037			;AN000;message number
 36696 00008050 00                      	db	no_subst ; 0		;AN000;number of subst
 36697                                  
 36698                                  ;  ",    Delete (Y/N)?",13,10
 36699                                  Del_Y_N_Ptr:
 36700 00008051 0E04                    	dw	1038			;AN000;message number
 36701 00008053 00                      	db	no_subst ; 0		;AN000;number of subst
 36702                                  
 36703                                  ;  "All files in directory will be deleted!",13,10
 36704                                  ;  "Are you sure (Y/N)?",13,10
 36705                                  SureMes_Ptr:
 36706 00008054 0F04                    	dw	1039			;AN000;message number
 36707 00008056 00                      	db	no_subst ; 0		;AN000;number of subst
 36708                                  
 36709                                  ;  "Microsoft DOS Version %1.%2",13,10
 36710                                  VerMes_Ptr:
 36711 00008057 1004                    	dw	1040			;AN000;message number
 36712 00008059 02                      	db	2			;AN000;number of subst
 36713 0000805A 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 36714 0000805B 00                      	db	0			;AN000;reserved
 36715 0000805C [DB8C]                  	dw	Major_Ver_Num		;AN000;offset of arg
 36716 0000805E 0000                    	dw	0			;AN000;segment of arg
 36717 00008060 01                      	db	1			;AN000;first subst
 36718 00008061 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36719                                  					;AN000;binary to decimal
 36720 00008062 01                      	db	1			;AN000;maximum width
 36721 00008063 01                      	db	1			;AN000;minimum width
 36722 00008064 20                      	db	blank ; 20h		;AN000;pad character
 36723 00008065 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36724 00008066 00                      	db	0			;AN000;reserved
 36725 00008067 [DD8C]                  	dw	Minor_Ver_Num	;AN000;offset of arg
 36726 00008069 0000                    	dw	0			;AN000;segment of arg
 36727 0000806B 02                      	db	2			;AN000;second subst
 36728 0000806C A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36729                                  					;AN000;binary to decimal
 36730 0000806D 02                      	db	2			;AN000;maximum width
 36731 0000806E 02                      	db	2			;AN000;minimum width
 36732 0000806F 30                      	db	'0' ; 30h		;AN000;pad character
 36733                                  
 36734                                  ;  "Volume in drive %1 has no label",13,10
 36735                                  VolMes_Ptr_2:
 36736 00008070 1104                    	dw	1041			;AN000;message number
 36737 00008072 01                      	db	1			;AN000;number of subst
 36738 00008073 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 36739 00008074 00                      	db	0			;AN000;reserved
 36740 00008075 [E18C]                  	dw	vol_drv			;AN000;offset of drive
 36741 00008077 0000                    	dw	0			;AN000;segment of arg
 36742 00008079 01                      	db	1			;AN000;first subst
 36743 0000807A 00                      	db	0 ; Char_field_Char 	;AN000;character
 36744 0000807B 80                      	db	128			;AN000;maximum width
 36745 0000807C 01                      	db	1			;AN000;minimum width
 36746 0000807D 20                      	db	blank ; 20h		;AN000;pad character
 36747                                  
 36748                                  ;  "Volume in drive %1 is %2",13,10
 36749                                  VolMes_Ptr:
 36750 0000807E 1204                    	dw	1042			;AN000;message number
 36751 00008080 02                      	db	2			;AN000;number of subst
 36752 00008081 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36753 00008082 00                      	db	0			;AN000;reserved
 36754 00008083 [E18C]                  	dw	vol_drv			;AN000;offset of drive
 36755 00008085 0000                    	dw	0			;AN000;segment of arg
 36756 00008087 01                      	db	1			;AN000;first subst
 36757 00008088 00                      	db	00000000b		;AN000;character
 36758 00008089 80                      	db	128			;AN000;maximum width
 36759 0000808A 01                      	db	1			;AN000;minimum width
 36760 0000808B 20                      	db	blank ; 20h		;AN000;pad character
 36761 0000808C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36762 0000808D 00                      	db	0			;AN000;reserved
 36763 0000808E [1A8B]                  	dw	CHARBUF			;AN000;offset of string
 36764 00008090 0000                    	dw	0			;AN000;segment of arg
 36765 00008092 02                      	db	2			;AN000;second subst
 36766 00008093 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36767 00008094 80                      	db	128			;AN000;maximum width
 36768 00008095 01                      	db	1			;AN000;minimum width
 36769 00008096 20                      	db	blank ; 20h		;AN000;pad character
 36770                                  
 36771                                  ;  "Volume Serial Number is %1-%2",13,10
 36772                                  VolSerMes_Ptr:
 36773 00008097 1304                    	dw	1043			;AN000;message number
 36774 00008099 02                      	db	2			;AN000;number of subst
 36775 0000809A 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 36776 0000809B 00                      	db	0			;AN000;reserved
 36777 0000809C [3C8E]                  	dw	vol_serial+2		;AN000;offset of serial
 36778 0000809E 0000                    	dw	0			;AN000;segment of arg
 36779 000080A0 01                      	db	1			;AN000;first subst
 36780 000080A1 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word 
 36781                                  					;AN000;binary to hex
 36782 000080A2 04                      	db	4			;AN000;maximum width
 36783 000080A3 04                      	db	4			;AN000;minimum width
 36784 000080A4 30                      	db	'0' ; 30h		;AN000;pad character
 36785 000080A5 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36786 000080A6 00                      	db	0			;AN000;reserved
 36787 000080A7 [3A8E]                  	dw	vol_serial		;AN000;offset of serial
 36788 000080A9 0000                    	dw	0			;AN000;segment of arg
 36789 000080AB 02                      	db	2			;AN000;second subst
 36790 000080AC A3                      	db	0A3h ; Right_Align+Bin_Hex_Word
 36791                                  					;AN000;binary to hex
 36792 000080AD 04                      	db	4			;AN000;maximum width
 36793 000080AE 04                      	db	4			;AN000;minimum width
 36794 000080AF 30                      	db	'0' ; 30h		;AN000;pad character
 36795                                  
 36796                                  ;  "Invalid directory",13,10
 36797                                  badcd_ptr:
 36798 000080B0 1404                    	dw	1044			;AN000;message number
 36799 000080B2 00                      	db	no_subst ; 0		;AN000;number of subst
 36800                                  
 36801                                  ;  "Unable to create directory",13,10
 36802                                  badmkd_ptr:
 36803 000080B3 1504                    	dw	1045			;AN000;message number
 36804 000080B5 00                      	db	no_subst ; 0		;AN000;number of subst
 36805                                  
 36806                                  ;  "Invalid path, not directory,",13,10
 36807                                  ;  "or directory not empty",13,10
 36808                                  badrmd_ptr:
 36809 000080B6 1604                    	dw	1046			;AN000;message number
 36810 000080B8 00                      	db	no_subst ; 0		;AN000;number of subst
 36811                                  
 36812                                  ;  "Must specify ON or OFF",13,10
 36813                                  bad_on_off_ptr:
 36814 000080B9 1704                    	dw	1047			;AN000;message number
 36815 000080BB 00                      	db	no_subst ; 0		;AN000;number of subst
 36816                                  
 36817                                  ;  "Directory of %1",13,10
 36818                                  dirhead_ptr:
 36819 000080BC 1804                    	dw	1048			;AN000;message number
 36820 000080BE 01                      	db	1			;AN000;number of subst
 36821 000080BF 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 36822 000080C0 00                      	db	0			;AN000;reserved
 36823 000080C1 [E98B]                  	dw	BWDBUF			;AN000;offset of arg
 36824 000080C3 0000                    	dw	0			;AN000;segment of arg
 36825 000080C5 01                      	db	1			;AN000;first subst
 36826 000080C6 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36827 000080C7 80                      	db	128			;AN000;maximum width
 36828 000080C8 00                      	db	0			;AN000;minimum width
 36829 000080C9 20                      	db	blank ; 20h		;AN000;pad character
 36830                                  
 36831                                  ;  "No Path",13,10
 36832                                  NULLPATH_PTR:
 36833 000080CA 1904                    	dw	1049			;AN000;message number
 36834 000080CC 00                      	db	no_subst ; 0		;AN000;number of subst
 36835                                  
 36836                                  ;  "Invalid drive in search path",13,10
 36837                                  BADPMES_PTR:
 36838 000080CD 1A04                    	dw	1050			;AN000;message number
 36839 000080CF 00                      	db	no_subst ; 0		;AN000;number of subst
 36840                                  
 36841                                  ;  "Invalid device",13,10
 36842                                  BADDEV_PTR:
 36843 000080D0 1B04                    	dw	1051			;AN000;message number
 36844 000080D2 00                      	db	no_subst ; 0		;AN000;number of subst
 36845                                  
 36846                                  ;  "FOR cannot be nested",13,10
 36847                                  FORNESTMES_PTR:
 36848 000080D3 1C04                    	dw	1052			;AN000;message number
 36849 000080D5 00                      	db	no_subst ; 0		;AN000;number of subst
 36850                                  
 36851                                  ;  "Intermediate file error during pipe",13,10
 36852                                  PIPEEMES_PTR:
 36853 000080D6 1D04                    	dw	1053			;AN000;message number
 36854 000080D8 00                      	db	no_subst ; 0		;AN000;number of subst
 36855                                  
 36856                                  ;  "Cannot do binary reads from a device",13,10
 36857                                  INBDEV_PTR:
 36858 000080D9 1E04                    	dw	1054			;AN000;message number
 36859 000080DB 00                      	db	no_subst ; 0		;AN000;number of subst
 36860                                  
 36861                                  ;  "BREAK is %1",13,10
 36862                                  CtrlcMes_Ptr:
 36863 000080DC 1F04                    	dw	1055			;AN000;message number
 36864 000080DE 01                      	db	1			;AN000;number of subst
 36865 000080DF 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36866 000080E0 00                      	db	0			;AN000;reserved
 36867 000080E1 0000                    	dw	0			;AN000;offset of on/off (new)
 36868 000080E3 0000                    	dw	0			;AN000;segment of arg
 36869 000080E5 01                      	db	1			;AN000;first subst
 36870 000080E6 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36871 000080E7 80                      	db	128			;AN000;maximum width
 36872 000080E8 01                      	db	1			;AN000;minimum width
 36873 000080E9 20                      	db	blank ; 20h		;AN000;pad character
 36874                                  
 36875                                  ;  "VERIFY is %1",13,10
 36876                                  VeriMes_Ptr:
 36877 000080EA 2004                    	dw	1056			;AN000;message number
 36878 000080EC 01                      	db	1			;AN000;number of subst
 36879 000080ED 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36880 000080EE 00                      	db	0			;AN000;reserved
 36881 000080EF 0000                    	dw	0			;AN000;offset of on/off (new)
 36882 000080F1 0000                    	dw	0			;AN000;segment of arg
 36883 000080F3 01                      	db	1			;AN000;first subst
 36884 000080F4 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36885 000080F5 80                      	db	128			;AN000;maximum width
 36886 000080F6 01                      	db	1			;AN000;minimum width
 36887 000080F7 20                      	db	blank ; 20h		;AN000;pad character
 36888                                  
 36889                                  ;  "ECHO is %1",13,10
 36890                                  EchoMes_Ptr:
 36891 000080F8 2104                    	dw	1057			;AN000;message number
 36892 000080FA 01                      	db	1			;AN000;number of subst
 36893 000080FB 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36894 000080FC 00                      	db	0			;AN000;reserved
 36895 000080FD 0000                    	dw	0			;AN000;offset of on/off (new)
 36896 000080FF 0000                    	dw	0			;AN000;segment of arg
 36897 00008101 01                      	db	1			;AN000;first subst
 36898 00008102 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36899 00008103 80                      	db	128			;AN000;maximum width
 36900 00008104 01                      	db	1			;AN000;minimum width
 36901 00008105 20                      	db	blank ; 20h		;AN000;pad character
 36902                                  
 36903                                  ;  "off"
 36904                                  OFFMES_PTR:
 36905 00008106 2304                    	dw	1059			;AN000;message number
 36906 00008108 00                      	db	no_subst		;AN000;number of subst
 36907                                  
 36908                                  ;  "on"
 36909                                  ONMES_PTR:
 36910 00008109 2404                    	dw	1060			;AN000;message number
 36911 0000810B 00                      	db	no_subst ; 0		;AN000;number of subst
 36912                                  
 36913                                  ;  "Error writing to device",13,10
 36914                                  DEVWMES_PTR:
 36915 0000810C 2504                    	dw	1061			;AN000;message number
 36916 0000810E 00                      	db	no_subst ; 0		;AN000;number of subst
 36917                                  
 36918                                  ;  "Invalid path",13,10
 36919                                  INVAL_PATH_PTR:
 36920 0000810F 2604                    	dw	1062			;AN000;message number
 36921 00008111 00                      	db	no_subst ; 0		;AN000;number of subst
 36922                                  
 36923                                  ;  unformatted string output
 36924                                  arg_buf_ptr:
 36925 00008112 2704                    	dw	1063			;AN000;message number
 36926 00008114 01                      	db	1			;AN000;number of subst
 36927 00008115 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36928 00008116 00                      	db	0			;AN000;reserved
 36929 00008117 [4C8C]                  	dw	Arg_Buf 		;AN000;offset of arg
 36930 00008119 0000                    	dw	0			;AN000;segment of arg
 36931 0000811B 01                      	db	1			;AN000;first subst
 36932 0000811C 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36933 0000811D 80                      	db	128			;AN000;maximum width
 36934 0000811E 00                      	db	0			;AN000;minimum width
 36935 0000811F 20                      	db	blank ; 20h		;AN000;pad character
 36936                                  
 36937                                  ;  file name output
 36938                                  file_name_ptr:
 36939 00008120 2804                    	dw	1064			;AN000;message number
 36940 00008122 01                      	db	1			;AN000;number of subst
 36941 00008123 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36942 00008124 00                      	db	0			;AN000;reserved
 36943 00008125 [4F8D]                  	dw	SrcBuf			;AN000;offset of arg
 36944 00008127 0000                    	dw	0			;AN000;segment of arg
 36945 00008129 01                      	db	1			;AN000;first subst
 36946 0000812A 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36947 0000812B 80                      	db	128			;AN000;maximum width
 36948 0000812C 00                      	db	0			;AN000;minimum width
 36949 0000812D 20                      	db	blank ; 20h		;AN000;pad character
 36950                                  
 36951                                  ;  file size output for dir
 36952                                  disp_file_size_ptr:
 36953 0000812E 2904                    	dw	1065			;AN000;message number
 36954 00008130 01                      	db	1			;AN000;number of subst
 36955 00008131 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 36956 00008132 00                      	db	0			;AN000;reserved
 36957 00008133 [CC8C]                  	dw	File_Size_Low		;AN000;offset of arg
 36958 00008135 0000                    	dw	0			;AN000;segment of arg
 36959 00008137 01                      	db	1			;AN000;first subst
 36960 00008138 B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 36961                                  					;AN000;long binary to decimal
 36962 00008139 0A                      	db	10			;AN000;maximum width
 36963 0000813A 0A                      	db	10			;AN000;minimum width
 36964 0000813B 20                      	db	blank ; 20h		;AN000;pad character
 36965                                  
 36966                                  ;  unformatted string output
 36967                                  ; %s
 36968                                  string_buf_ptr:
 36969 0000813C 2A04                    	dw	1066			;AN000;message number
 36970 0000813E 01                      	db	1			;AN000;number of subst
 36971 0000813F 0B                      	db	parm_block_size 	;AN000;size of sublist
 36972 00008140 00                      	db	0			;AN000;reserved
 36973 00008141 [D08C]                  	dw	string_ptr_2		;AN000;offset of arg
 36974 00008143 0000                    	dw	0			;AN000;segment of arg
 36975 00008145 01                      	db	1			;AN000;first subst
 36976 00008146 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36977 00008147 80                      	db	128			;AN000;maximum width
 36978 00008148 00                      	db	0			;AN000;minimum width
 36979 00008149 20                      	db	blank ; 20h		;AN000;pad character
 36980 0000814A 00                      	db	0			;AN000;
 36981                                  
 36982                                  ;  tab character
 36983                                  tab_ptr:
 36984 0000814B 2B04                    	dw	1067			;AN000;message number
 36985 0000814D 00                      	db	no_subst ; 0		;AN000;number of subst
 36986                                  
 36987                                  ;  " <DIR>   "
 36988                                  dmes_ptr:
 36989 0000814E 2C04                    	dw	1068			;AN000;message number
 36990 00008150 00                      	db	no_subst ; 0		;AN000;number of subst
 36991                                  
 36992                                  ;  destructive back space
 36993                                  dback_ptr:
 36994 00008151 2D04                    	dw	1069			;AN000;message number
 36995 00008153 00                      	db	no_subst ; 0		;AN000;number of subst
 36996                                  
 36997                                  ;  carriage return / line feed
 36998                                  acrlf_ptr:
 36999 00008154 2E04                    	dw	1070			;AN000;message number
 37000 00008156 00                      	db	no_subst ; 0		;AN000;number of subst
 37001                                  
 37002                                  ;  "mm-dd-yy"
 37003                                  usadat_ptr:
 37004 00008157 3004                    	dw	1072			;AN000;message number
 37005 00008159 00                      	db	no_subst ; 0		;AN000;number of subst
 37006                                  
 37007                                  ;  "dd-mm-yy"
 37008                                  eurdat_ptr:
 37009 0000815A 3104                    	dw	1073			;AN000;message number
 37010 0000815C 00                      	db	no_subst ; 0		;AN000;number of subst
 37011                                  
 37012                                  ;  "yy-mm-dd"
 37013                                  japdat_ptr:
 37014 0000815D 3204                    	dw	1074			;AN000;message number
 37015 0000815F 00                      	db	no_subst ; 0		;AN000;number of subst
 37016                                  
 37017                                  ;  date string for prompt
 37018                                  promptdat_ptr:
 37019 00008160 3304                    	dw	1075			;AN000;message number
 37020 00008162 02                      	db	2			;AN000;number of subst
 37021 00008163 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37022 00008164 00                      	db	0			;AN000;reserved
 37023 00008165 [4C8C]                  	dw	Arg_Buf			;AN000;offset of arg
 37024 00008167 0000                    	dw	0			;AN000;segment of arg
 37025 00008169 01                      	db	1			;AN000;first subst
 37026 0000816A 10                      	db	10h ; Char_field_ASCIIZ ;AN000;character string
 37027 0000816B 03                      	db	3			;AN000;maximum width
 37028 0000816C 03                      	db	3			;AN000;minimum width
 37029 0000816D 20                       	db	blank ; 20h		;AN000;pad character
 37030 0000816E 0B                      	db	parm_block_size  ; 11	;AN000;size of sublist
 37031 0000816F 00                      	db	0			;AN000;reserved
 37032                                  promptDat_yr:
 37033 00008170 0000                    	dw	0			;AN000;year
 37034                                  promptDat_moday:
 37035 00008172 0000                    	dw	0			;AN000;month,day
 37036 00008174 02                      	db	2			;AN000;second subst
 37037 00008175 34                       	db	34h ; DATE_MDY_4	;AN000;date
 37038 00008176 0A                      	db	10			;AN000;maximum width
 37039 00008177 08                      	db	8			;AN000;minimum width
 37040 00008178 20                      	db	blank ; 20h		;AN000;pad character
 37041                                  
 37042                                  ;  Time for prompt
 37043                                  promtim_ptr:
 37044 00008179 3404                    	dw	1076			;AN000;message number
 37045 0000817B 01                      	db	1			;AN000;number of subst
 37046 0000817C 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37047 0000817D 00                      	db	0			;AN000;reserved
 37048                                  PromTim_hr_min:
 37049 0000817E 0000                    	dw	0			;AN000;hours,minutes
 37050                                  PromTim_Sec_hn:
 37051 00008180 0000                    	dw	0			;AN000;seconds,hundredths
 37052 00008182 01                      	db	1			;AN000;first subst
 37053 00008183 A6                      	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
 37054                                  					;AC013;time
 37055 00008184 0B                      	db	11			;AN000;maximum width
 37056 00008185 0B                      	db	11			;AC013;minimum width
 37057 00008186 20                      	db	blank ; 20h		;AN000;pad character
 37058                                  
 37059                                  ;  Date and time for DIR
 37060                                  dirdattim_ptr:
 37061 00008187 3504                    	dw	1077			;AN000;message number
 37062 00008189 02                      	db	2			;AN000;number of subst
 37063 0000818A 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37064 0000818B 00                      	db	0			;AN000;reserved
 37065                                  DirDat_Yr:
 37066 0000818C 0000                    	dw	0			;AN000;year
 37067                                  DirDat_Mo_Day:
 37068 0000818E 0000                    	dw	0			;AN000;month,day
 37069 00008190 01                      	db	1			;AN000;first subst
 37070 00008191 A4                      	db	0A4h ; Right_Align+DATE_MDY_2
 37071                                  					;AN000;date
 37072 00008192 0A                      	db	10			;AN000;maximum width
 37073 00008193 08                      	db	8			;AN000;minimum width
 37074 00008194 20                      	db	blank ; 20h		;AN000;pad character
 37075 00008195 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37076 00008196 00                      	db	0			;AN000;reserved
 37077                                  DirTim_Hr_Min:
 37078 00008197 0000                    	dw	0			;AN000;hours,minutes
 37079                                  DirTim_Sec_hn:
 37080 00008199 0000                    	dw	0			;AN000;seconds,hundredths
 37081 0000819B 02                      	db	2			;AN000;second subst
 37082 0000819C 85                      	db	85h ; Right_align+TIME_HHMM_Cty
 37083                                  					;AN000;time
 37084 0000819D 06                      	db	6			;AN000;maximum width
 37085 0000819E 06                      	db	6			;AN000;minimum width
 37086 0000819F 20                      	db	blank ; 20h		;AN000;pad character
 37087                                  
 37088                                  ;  "Directory already exists"
 37089                                  MD_EXISTS_PTR:
 37090 000081A0 3604                    	dw	1078			;AN000;message number
 37091 000081A2 00                      	db	no_subst		;AN000;number of subst
 37092                                  
 37093                                  ;  "%1 bytes",13,10
 37094                                  bytes_ptr:
 37095 000081A3 3704                    	dw	1079			; message number
 37096 000081A5 01                      	db	1			; number of subst
 37097 000081A6 0B                              db	parm_block_size ; 11	; size of sublist
 37098 000081A7 00                              db	0			; reserved
 37099 000081A8 [0E8B]                          dw	FileSiz			; offset of arg
 37100 000081AA 0000                            dw	0			; segment of arg
 37101 000081AC 01                              db	1			; first subst
 37102 000081AD B1                              db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37103                                  					; long binary to decimal
 37104 000081AE 0A                              db	10			; maximum width
 37105 000081AF 0A                              db	10			; minimum width
 37106 000081B0 20                              db	blank ; 20h		; pad character
 37107                                  
 37108                                  ;  "Total:",13,10
 37109                                  total_ptr:
 37110 000081B1 3804                    	dw	1080			; message number
 37111 000081B3 00                      	db	no_subst ; 0		; number of subst
 37112                                  
 37113                                  ;  "Error parsing environment variable:",13,10
 37114                                  errparsenv_ptr:
 37115 000081B4 3904                    	dw	1081			; message number
 37116 000081B6 00                      	db	no_subst ; 0		; number of subst
 37117                                  
 37118                                  ;  "(continuing %1)",13,10
 37119                                  dircont_ptr:
 37120 000081B7 3C04                    	dw	1084			;AN000;message number
 37121 000081B9 01                      	db	1			;AN000;number of subst
 37122 000081BA 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37123 000081BB 00                      	db	0			;AN000;reserved
 37124 000081BC [E98B]                  	dw	BWDBUF			;AN000;offset of arg
 37125 000081BE 0000                    	dw	0			;AN000;segment of arg
 37126 000081C0 01                      	db	1			;AN000;first subst
 37127 000081C1 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37128 000081C2 80                      	db	128			;AN000;maximum width
 37129 000081C3 00                      	db	0			;AN000;minimum width
 37130 000081C4 20                      	db	blank ; 20h		;AN000;pad character
 37131                                  
 37132                                  ;  "Revision %1",CR,LF
 37133                                  dosrev_ptr:
 37134 000081C5 4204                    	dw	1090
 37135 000081C7 01                      	db	1			; one substitution
 37136 000081C8 0B                      	db	parm_block_size ; 11
 37137 000081C9 00                      	db	0
 37138 000081CA [DF8C]                  	dw	One_Char_Val		; ptr to char
 37139 000081CC 0000                    	dw	0			; segment addr?
 37140 000081CE 01                      	db	1			; 1st substitution
 37141 000081CF 00                      	db	0 ; CHAR_FIELD_CHAR	; character
 37142 000081D0 01                      	db	1			; max width
 37143 000081D1 01                      	db	1			; min width
 37144 000081D2 20                      	db	blank ; 20h		; pad char
 37145                                  
 37146                                  ;  "DOS is in ROM"
 37147                                  DosRom_Ptr:
 37148 000081D3 4304                    	dw	1091
 37149 000081D5 00                      	db	no_subst ; 0		
 37150                                  
 37151                                  ;  "DOS is in HMA"
 37152                                  DosHma_Ptr:
 37153 000081D6 4404                    	dw	1092
 37154 000081D8 00                      	db	no_subst ; 0		
 37155                                  
 37156                                  ;  "DOS is in low memory"
 37157                                  DosLow_Ptr:
 37158 000081D9 4504                    	dw	1093
 37159 000081DB 00                      	db	no_subst ; 0		
 37160                                  
 37161                                  ;  "Cannot Loadhigh batch file" ;M016
 37162                                  NoExecBat_Ptr:
 37163 000081DC 4604                    	dw	1094			; M016
 37164 000081DE 00                      	db	no_subst ; 0		; M016
 37165                                  
 37166                                  ;  "LoadHigh: Invalid filename" ; M016
 37167                                  LhInvFil_Ptr:
 37168 000081DF 4704                    	dw	1095			; M016
 37169 000081E1 00                      	db	no_subst ; 0		; M016
 37170                                  
 37171                                  ;  "Could not open specified country information file" ; M045
 37172                                  NoCntry_Ptr:
 37173 000081E2 4804                    	dw	1096			; M045
 37174 000081E4 00                      	db	no_subst ; 0		; M045
 37175                                  
 37176                                  ; 15/04/2023
 37177                                  ; MSDOS 6.0 COMMAND.COM only !
 37178                                  %if 0
 37179                                  
 37180                                  ;* The next four errors emulate those reported by the normal parse
 37181                                  ;  mechanism, with a little more accurate wording; that parser has been
 37182                                  ;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
 37183                                  ;  These errors aren't normally generated by LoadHigh except by the normal
 37184                                  ;  parser, so they've been added here.
 37185                                  
 37186                                  ;  "LoadHigh: Invalid argument"
 37187                                  LhInvArg_Ptr:
 37188                                  	dw	1097
 37189                                  	db	no_subst ; 0		
 37190                                  
 37191                                  ;  "Required parameter missing"
 37192                                  ReqParmMiss:
 37193                                  	dw	1098
 37194                                  	db	no_subst ; 0		
 37195                                  
 37196                                  ;  "Unrecognized switch"
 37197                                  LhInvSwt_Ptr:
 37198                                  	dw	1099
 37199                                  	db	no_subst ; 0		
 37200                                  
 37201                                  ;  "A bad UMB number has been specified"
 37202                                  LhBadUMB_Ptr:
 37203                                  	dw	1100
 37204                                  	db	no_subst ; 0
 37205                                  %endif		
 37206                                  
 37207                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37208                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
 37209                                  ; ---------------------------------------------------------------------------
 37210                                  
 37211                                  PATH_TEXT:
 37212 000081E5 504154483D              	db	"PATH="
 37213                                  PROMPT_TEXT:
 37214 000081EA 50524F4D50543D          	db	"PROMPT="
 37215                                  COMSPECSTR:
 37216 000081F1 434F4D535045433D        	db	"COMSPEC="
 37217                                  DirEnvVar:
 37218 000081F9 444952434D443D          	db	"DIRCMD="		; DIR's environment variable
 37219                                  
 37220                                  ; 15/04/2023
 37221                                  %if 0
 37222                                  
 37223                                  ;============================================================================
 37224                                  ; TDATA.ASM, MSDOS 6.0, 1991
 37225                                  ;============================================================================
 37226                                  ; 30/09/2018 - Retro DOS v3.0
 37227                                  
 37228                                  ; TITLE	COMMAND Transient Initialized DATA
 37229                                  
 37230                                  ;The TRANDATA segment contains data that is assumed to have predefined
 37231                                  ;initial values at the beginning of each command cycle. It is
 37232                                  ;included in the transient checksum area. If values in TRANDATA
 37233                                  ;change, the transient will be reloaded for the next command cycle.
 37234                                  
 37235                                  align 16
 37236                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 37237                                  
 37238                                  PRINTF_TABLE:	db '0123456789ABCDEF'
 37239                                  _3740h:		db '%S',0
 37240                                  ARG_BUF_PTR:	dw _3740h
 37241                                  		dw _3747h
 37242                                  _3747h:		dw ARG_BUF ; _43E8h
 37243                                  _3749h:		db '%S ',0
 37244                                  STRINGBUF1PTR:	dw _3749h
 37245                                  		dw STRING_PTR_1 ; _4468h
 37246                                  _3751h:		db '%9ld',0
 37247                                  FSIZEMESPTR:	dw _3751h
 37248                                  		dw FILESIZE_L ; _446Ah
 37249                                  		dw FILESIZE_H ; _446Ch
 37250                                  _375Ch:		db '%S',0
 37251                                  STRINGBUF2PTR:	dw _375Ch
 37252                                  		dw STRING_PTR_2 ; _446Eh
 37253                                  _3763h:		db 9,0
 37254                                  TABPTR:		dw _3763h
 37255                                  _3767h:		db 0Dh,0Ah
 37256                                  		db 'Batch file missing',0Dh,0Ah,0
 37257                                  BADPATHPTR:	dw _3767h
 37258                                  _3780h:		db 0Dh,0Ah
 37259                                  		db 'Insert disk with batch file',0Dh,0Ah
 37260                                  		db 'and press any key when ready',0Dh,0Ah,0
 37261                                  INSERTDSKPTR:	dw _3780h
 37262                                  _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 37263                                  BADNAMPTR:	dw _37C0h
 37264                                  _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 37265                                  RENERRPTR:	dw _37DDh
 37266                                  _3807h:		db 'File not found',0Dh,0Ah,0
 37267                                  FNOTFOUNDPTR:	dw _3807h
 37268                                  _381Ah:		db 'Path not found',0Dh,0Ah,0
 37269                                  PNOTFOUNDPTR:	dw _381Ah
 37270                                  _382Dh:		db 'Access denied',0Dh,0Ah,0
 37271                                  ACCDENPTR:	dw _382Dh
 37272                                  _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 37273                                  NOSPACEPTR:	dw _383Fh
 37274                                  _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 37275                                  ENVERRPTR:	dw _385Bh
 37276                                  _3878h:		db 'File creation error',0Dh,0Ah,0
 37277                                  FULDIRPTR:	dw 3878h
 37278                                  _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 37279                                  OVERWRPTR:	dw _3890h
 37280                                  _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 37281                                  LOSTERRPTR:	dw _38B6h
 37282                                  _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 37283                                  INORNOTPTR:	dw _38E2h
 37284                                  _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 37285                                  COPIEDPTR:	dw _3909h
 37286                                  		dw COPY_NUM ; _4470h
 37287                                  _3922h:		db '%9d File(s) ',0
 37288                                  DIRMESPTR:	dw _3922h
 37289                                  		dw DIR_NUM  ; _4477h
 37290                                  _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 37291                                  BYTEMESPTR:	dw _3933h
 37292                                  		dw BYTES_FREE   ; _4479h
 37293                                  		dw BYTES_FREE+2 ; _447Bh
 37294                                  _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 37295                                  BADDRVPTR:	dw _394Bh
 37296                                  _396Bh:		db 0Dh,0Ah
 37297                                  		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 37298                                  CPNOTSETPTR:	dw _396Bh
 37299                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37300                                  _3999h:		db 0Dh,0Ah
 37301                                  		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 37302                                  CPNOTALLPTR:	dw _3999h
 37303                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37304                                  _39CCh:		db 0Dh,0Ah
 37305                                  		db 'Active code page: %5d',0Dh,0Ah,0
 37306                                  CPACTIVEPTR:	dw _39CCh
 37307                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37308                                  _39EAh:		db 'Current drive is no longer valid',0
 37309                                  BADCURDRVPTR:	dw _39EAh
 37310                                  _3A0Dh:		db 'Strike a key when ready . . . ',0
 37311                                  PAUSEMESPTR:	dw _3A0Dh
 37312                                  _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 37313                                  BADPARMPTR:	dw _3A2Eh
 37314                                  WEEKTAB:	db 'SunMonTueWedThuFriSat'
 37315                                  _3A59h:		db 0Dh,0Ah
 37316                                  		db 'Invalid date',0
 37317                                  BADDATPTR:	dw _3A59h
 37318                                  _3A6Ah:		db 'Current date is ',0
 37319                                  CURDATPTR:	dw _3A6Ah
 37320                                  _3A7Dh:		db 0Dh,0Ah
 37321                                  		db 'Enter new date ',0
 37322                                  NEWDATPTR:	dw _3A7Dh
 37323                                  _3A91h:		db '(mm-dd-yy): ',0
 37324                                  USADATPTR:	dw _3A91h
 37325                                  _3AA0h:		db '(dd-mm-yy): ',0
 37326                                  EURDATPTR:	dw _3AA0h
 37327                                  _3AAFh:		db '(yy-mm-dd): ',0
 37328                                  JAPDATPTR:	dw _3AAFh
 37329                                  _3ABEh:		db 0Dh,0Ah
 37330                                  		db 'Invalid time ',0
 37331                                  BADTIMPTR:	dw _3ABEh
 37332                                  _3AD0h:		db 'Current time is ',0
 37333                                  CURTIMPTR:	dw _3AD0h
 37334                                  _3AE3h:		db 0Dh,0Ah
 37335                                  		db 'Enter new time: ',0
 37336                                  NEWTIMPTR:	dw _3AE3h
 37337                                  _3AF8h:		db 'Are you sure (Y/N)?',0
 37338                                  SUREMESPTR:	dw _3AF8h
 37339                                  _3B0Eh:		db ' <DIR>   ',0
 37340                                  DMESPTR:	dw _3B0Eh
 37341                                  _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 37342                                  VERMESPTR:	dw _3B1Ah
 37343                                  		dw MAJOR_VER_NUM ; _447Dh
 37344                                  		dw MINOR_VER_NUM ; _447Fh
 37345                                  _3B4Dh:		db '%C',0
 37346                                  ONECHRVALPTR:	dw _3B4Dh
 37347                                  		dw ONE_CHAR_VAL	; _4481h
 37348                                  _3B54h:		db ' Volume in drive %c %s',0
 37349                                  VOLMESPTR:	dw _3B54h
 37350                                  		dw VOL_DRV ; _4484h
 37351                                  		dw VOLNAME_ADDR ; _4482h
 37352                                  IS:		db 'is ',0
 37353                                  NOVOL:		db 'has no label',0
 37354                                  _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 37355                                  BADCDPTR:	dw _3B82h
 37356                                  _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 37357                                  BADMKDPTR:	dw _3B98h
 37358                                  _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 37359                                  		db 'or directory not empty',0Dh,0Ah,0
 37360                                  BADRMDPTR:	dw _3BB7h
 37361                                  _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 37362                                  BADONOFFPTR:	dw _3BF0h
 37363                                  _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 37364                                  DIRHEADPTR:	dw _3C0Bh
 37365                                  		dw VOL_DIR ; _4485h
 37366                                  _3C23h:		db 'No Path',0
 37367                                  NULLPATHPTR:	dw _3C23h
 37368                                  PATH_TEXT:	db 'PATH='
 37369                                  PROMPT_TEXT:	db 'PROMPT='
 37370                                  COMSPEC_TEXT:	db 'COMSPEC='
 37371                                  _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 37372                                  BADPMESPTR:	dw _3C41h
 37373                                  _3C62h:		db 'Invalid device',0Dh,0Ah,0
 37374                                  BADDEVPTR:	dw _3C62h
 37375                                  _3C75h:		db 'Label not found',0Dh,0Ah,0
 37376                                  BADLABPTR:	dw _3C75h
 37377                                  _3C89h:		db 'Syntax error',0Dh,0Ah,0
 37378                                  SYNTMESPTR:	dw _3C89h
 37379                                  _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 37380                                  FORNESTMESTR:	dw _3C9Ah
 37381                                  _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 37382                                  INSFMEMMESPTR:	dw _3CB4h
 37383                                  _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 37384                                  PIPEEMESPTR:	dw _3CCCh
 37385                                  _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 37386                                  INBDEVPTR:	dw _3CF4h
 37387                                  _3D1Dh:		db 'BREAK is ',0
 37388                                  CTRLMESPTR:	dw _3D1Dh
 37389                                  _3D29h:		db 'VERIFY is ',0
 37390                                  VERIMESPTR:	dw _3D29h
 37391                                  _3D36h:		db 'ECHO is ',0
 37392                                  ECHOMESPTR:	dw _3D36h
 37393                                  _3D41h:		db 'off',0Dh,0Ah,0
 37394                                  OFFMESPTR:	dw _3D41h
 37395                                  _3D49h:		db 'on',0Dh,0Ah,0
 37396                                  ONMESPTR:	dw _3D49h
 37397                                  _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 37398                                  BADCPMESPTR:	dw _3D50h
 37399                                  _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 37400                                  BADARGSPTR:	dw _3D6Eh
 37401                                  _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 37402                                  DEVWMESPTR:	dw _3D8Fh
 37403                                  _3DABh:		db 0Dh,0Ah,0
 37404                                  ACRLFPTR:	dw _3DABh
 37405                                  _3DB0h:		db 8
 37406                                  		db 20h
 37407                                  		db 8
 37408                                  		db 0
 37409                                  DBACKPTR:	dw _3DB0h
 37410                                  small_y:	db 'y'
 37411                                  small_n:	db 'n'
 37412                                  CAPITAL_Y:	db 'Y'
 37413                                  CAPITAL_N:	db 'N'
 37414                                  CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 37415                                  PROMPT_TABLE:
 37416                                  		db 'B' ; 42h
 37417                                  		dw PRINT_B
 37418                                  		db 'D' ; 44h
 37419                                  		dw PRINT_DATE
 37420                                  		db 'E' ; 45h
 37421                                  		dw PRINT_ESC
 37422                                  		db 'G' ; 47h
 37423                                  		dw PRINT_G
 37424                                  		db 'H' ; 48h
 37425                                  		dw PRINT_BACK
 37426                                  		db 'L' ; 4Ch
 37427                                  		dw PRINT_L
 37428                                  		db 'N' ; 4Eh
 37429                                  		dw PRINT_DRIVE
 37430                                  		db 'P' ; 50h
 37431                                  		dw BUILD_DIR_FOR_PROMPT
 37432                                  		db 'Q' ; 51h
 37433                                  		dw PRINT_EQ
 37434                                  		db 'T' ; 54h
 37435                                  		dw PRINT_TIME
 37436                                  		db 'V' ; 56h
 37437                                  		dw PRINT_VERSION
 37438                                  		db '_' ; 5Fh
 37439                                  		dw CRLF2
 37440                                  		db '$' ; 24h
 37441                                  		dw PRINT_CHAR
 37442                                  		db 0
 37443                                  
 37444                                  		; Table of IF conditionals
 37445                                  IFTAB:
 37446                                  		db 3	; First byte is count
 37447                                  		db 'NOT'
 37448                                  		dw IFNOT
 37449                                  		db 10
 37450                                  		db 'ERRORLEVEL'
 37451                                  		dw IFERLEV
 37452                                  		db 5
 37453                                  		db 'EXIST'
 37454                                  		dw IFEXISTS
 37455                                  		db 0
 37456                                  
 37457                                  		; Table for internal command names
 37458                                  
 37459                                  COMTAB:		db 3
 37460                                  		db 'DIR'
 37461                                  		db 3
 37462                                  		dw CATALOG
 37463                                  		db 4
 37464                                  		db 'CALL'
 37465                                  		db 2
 37466                                  		dw _$CALL
 37467                                  		db 4
 37468                                  		db 'CHCP'
 37469                                  		db 2
 37470                                  		dw CHCP
 37471                                  		db 6
 37472                                  		db 'RENAME'
 37473                                  		db 1
 37474                                  		dw CRENAME
 37475                                  		db 3
 37476                                  		db 'REN'
 37477                                  		db 1
 37478                                  		dw CRENAME
 37479                                  		db 5
 37480                                  		db 'ERASE'
 37481                                  		db 1
 37482                                  		dw ERASE
 37483                                  		db 3
 37484                                  		db 'DEL'
 37485                                  		db 1
 37486                                  		dw ERASE
 37487                                  		db 4
 37488                                  		db 'TYPE'
 37489                                  		db 1
 37490                                  		dw TYPEFIL
 37491                                  		db 3
 37492                                  		db 'REM'
 37493                                  		db 2
 37494                                  		dw TCOMMAND
 37495                                  		db 4
 37496                                  		db 'COPY'
 37497                                  		db 3
 37498                                  		dw COPY
 37499                                  		db 5
 37500                                  		db 'PAUSE'
 37501                                  		db 2
 37502                                  		dw PAUSE
 37503                                  		db 4
 37504                                  		db 'DATE'
 37505                                  		db 2
 37506                                  		dw DATE
 37507                                  		db 4
 37508                                  		db 'TIME'
 37509                                  		db 0
 37510                                  		dw CTIME
 37511                                  		db 3
 37512                                  		db 'VER'
 37513                                  		db 0
 37514                                  		dw VERSION
 37515                                  		db 3
 37516                                  		db 'VOL'
 37517                                  		db 1
 37518                                  		dw VOLUME
 37519                                  		db 2
 37520                                  		db 'CD'
 37521                                  		db 1
 37522                                  		dw _$CHDIR
 37523                                  		db 5
 37524                                  		db 'CHDIR'
 37525                                  		db 1
 37526                                  		dw _$CHDIR
 37527                                  		db 2
 37528                                  		db 'MD'
 37529                                  		db 1
 37530                                  		dw _$MKDIR
 37531                                  		db 5
 37532                                  		db 'MKDIR'
 37533                                  		db 1
 37534                                  		dw _$MKDIR
 37535                                  		db 2
 37536                                  		db 'RD'
 37537                                  		db 1
 37538                                  		dw _$RMDIR
 37539                                  		db 5
 37540                                  		db 'RMDIR'
 37541                                  		db 1
 37542                                  		dw _$RMDIR
 37543                                  		db 5
 37544                                  		db 'BREAK'
 37545                                  		db 0
 37546                                  		dw CNTRLC
 37547                                  		db 6
 37548                                  		db 'VERIFY'
 37549                                  		db 0
 37550                                  		dw VERIFY
 37551                                  		db 3
 37552                                  		db 'SET'
 37553                                  		db 2
 37554                                  		dw ADD_NAME_TO_ENVIRONMENT
 37555                                  		db 6
 37556                                  		db 'PROMPT'
 37557                                  		db 2
 37558                                  		dw ADD_PROMPT
 37559                                  		db 4
 37560                                  		db 'PATH'
 37561                                  		db 2
 37562                                  		dw PATH
 37563                                  		db 4
 37564                                  		db 'EXIT'
 37565                                  		db 0
 37566                                  		dw _$EXIT
 37567                                  		db 4
 37568                                  		db 'CTTY'
 37569                                  		db 3
 37570                                  		dw CTTY
 37571                                  		db 4
 37572                                  		db 'ECHO'
 37573                                  		db 2
 37574                                  		dw _ECHO
 37575                                  		db 4
 37576                                  		db 'GOTO'
 37577                                  		db 2
 37578                                  		dw _GOTO
 37579                                  		db 5
 37580                                  		db 'SHIFT'
 37581                                  		db 2
 37582                                  		dw _SHIFT
 37583                                  		db 2
 37584                                  		db 'IF'
 37585                                  		db 2
 37586                                  		dw _$IF
 37587                                  		db 3
 37588                                  		db 'FOR'
 37589                                  		db 2
 37590                                  		dw _$FOR
 37591                                  		db 3
 37592                                  		db 'CLS'
 37593                                  		db 0
 37594                                  		dw CLS
 37595                                  		db 0
 37596                                  
 37597                                  CAPITAL_A:	db 'A'
 37598                                  VBAR:		db '|'
 37599                                  LABRACKET:	db '<' ; 3Ch
 37600                                  RABRACKET:	db '>' ; 3Eh
 37601                                  DOLLAR:		db '$'
 37602                                  LPAREN:		db '('
 37603                                  RPAREN:		db ')'
 37604                                  NULLRPAREN:	db ')' ; 29h
 37605                                  		db 0
 37606                                  IN_WORD:	db 'I','N'
 37607                                  DO_WORD	:	db 'D','O'
 37608                                  STAR:		db '*'
 37609                                  CHAR_SUB:	db '-' 
 37610                                  PLUS_CHR:	db '+'
 37611                                  CHAR_L:		db 'L'
 37612                                  char_l:		db 'l'
 37613                                  small_a:	db 'a'
 37614                                  small_z:	db 'z'
 37615                                  CHAR_D:		db 'D'
 37616                                  CHAR_C:		db 'C'
 37617                                  CHAR_S:		db 'S'
 37618                                  CHAR_X:		db 'X'
 37619                                  DOT_CHR:	db '.' 
 37620                                  DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 37621                                  		db ','
 37622                                  TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 37623                                  MNCHR:		db 'p'
 37624                                  SYSTEM_CPAGE:	db 0
 37625                                  		db 0
 37626                                  
 37627                                  COMEXT:		db '.COM'
 37628                                  EXEEXT:		db '.EXE'
 37629                                  BATEXT:		db '.BAT'
 37630                                  SWITCH_LIST:	db 'VBAPW'
 37631                                  BATBUFLEN:	dw BATLEN ; 32
 37632                                  
 37633                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 37634                                  
 37635                                  TRANDATAEND:
 37636                                  
 37637                                  %endif
 37638                                  
 37639                                  ;============================================================================
 37640                                  ; TDATA.ASM, MSDOS 6.0, 1991
 37641                                  ;============================================================================
 37642                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37643                                  
 37644                                  	; 15/04/2023
 37645 00008200 00                      	db	0
 37646 00008201 90                      align 2
 37647                                  
 37648                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
 37649                                  ; ---------------------------------------------------------------------------
 37650 00008202 00                      	db 0
 37651                                  ; Lists of help message numbers for internal commands and /?
 37652                                  
 37653                                  ;;NoHelpMsgs:
 37654 00008203 B0040000                	dw	1200,0		;M014
 37655                                  BreakHelpMsgs:
 37656 00008207 14050000                	dw	1300,0
 37657                                  ChcpHelpMsgs:
 37658 0000820B 280529050000            	dw	1320,1321,0
 37659                                  CdHelpMsgs:
 37660 00008211 3C053D053E050000        	dw	1340,1341,1342,0
 37661                                  ClsHelpMsgs:
 37662 00008219 50050000                	dw	1360,0
 37663                                  CopyHelpMsgs:
 37664 0000821D 780579057A057B057C-     	dw	1400,1401,1402,1403,1404,0
 37664 00008226 050000             
 37665                                  CttyHelpMsgs:
 37666 00008229 8C050000                	dw	1420,0
 37667                                  DateHelpMsgs:
 37668 0000822D A005A1050000            	dw	1440,1441,0
 37669                                  DelHelpMsgs:
 37670 00008233 B405B505B6050000        	dw	1460,1461,1462,0
 37671                                  DirHelpMsgs:
 37672 0000823B C805C905CA05CB05CC-     	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
 37672 00008244 05CD05CE05CF05D005 
 37673                                  	; MSDOS 6.0 COMMAND.COM
 37674                                  	;dw	1489,1490,1491,1492
 37675 0000824D 0000                    	dw	0
 37676                                  ExitHelpMsgs:
 37677 0000824F DC050000                	dw	1500,0
 37678                                  MdHelpMsgs:
 37679 00008253 F0050000                	dw	1520,0
 37680                                  PathHelpMsgs:
 37681 00008257 0406050606060000        	dw	1540,1541,1542,0
 37682                                  PromptHelpMsgs:
 37683 0000825F 180619061A061B061C-     	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
 37683 00008268 061D061E061F062006-
 37683 00008271 0000               
 37684                                  RdHelpMsgs:
 37685 00008273 2C060000                	dw	1580,0
 37686                                  RenHelpMsgs:
 37687 00008277 4006410642060000        	dw	1600,1601,1602,0
 37688                                  SetHelpMsgs:
 37689 0000827F 5406550656060000        	dw	1620,1621,1622,0
 37690                                  TimeHelpMsgs:
 37691 00008287 680669060000            	dw	1640,1641,0
 37692                                  TypeHelpMsgs:
 37693 0000828D 7C060000                	dw	1660,0
 37694                                  VerHelpMsgs:
 37695 00008291 90060000                	dw	1680,0
 37696                                  VerifyHelpMsgs:
 37697 00008295 A4060000                	dw	1700,0
 37698                                  VolHelpMsgs:
 37699 00008299 B8060000                	dw	1720,0
 37700                                  CallHelpMsgs:
 37701 0000829D CC06CD060000            	dw	1740,1741,0	;M014
 37702                                  RemHelpMsgs:
 37703 000082A3 E0060000                	dw	1760,0		;M014
 37704                                  PauseHelpMsgs:
 37705 000082A7 F4060000                	dw	1780,0		;M014
 37706                                  EchoHelpMsgs:
 37707 000082AB 080709070000            	dw	1800,1801,0	;M014
 37708                                  GotoHelpMsgs:
 37709 000082B1 1C071D070000            	dw	1820,1821,0	;M014
 37710                                  ShiftHelpMsgs:
 37711 000082B7 30070000                	dw	1840,0		;M014
 37712                                  IfHelpMsgs:
 37713 000082BB 440745074607470748-     	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
 37713 000082C4 0749074A070000     
 37714                                  ForHelpMsgs:
 37715 000082CB 580759075A075B0700-     	dw	1880,1881,1882,1883,0 ;M014
 37715 000082D4 00                 
 37716                                  TruenameHelpMsgs:
 37717 000082D5 6C070000                	 dw	1900,0		;M014
 37718                                  LoadhighHelpMsgs:
 37719 000082D9 800781078207            	dw	1920,1921,1922
 37720                                  	; MSDOS 6.0 COMMAND.COM
 37721                                  	;dw	1923,1924,1925,1926,1927 ;M014
 37722 000082DF 0000                    	dw	0
 37723                                  
 37724                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
 37725                                  CLSSTRING:
 37726 000082E1 041B5B324A              	db	4,01Bh,"[2J"		; ANSI Clear screen
 37727                                  
 37728                                  PROMPT_TABLE:
 37729 000082E6 42                      	db	"B"
 37730 000082E7 [151E]                  	dw	Print_B
 37731 000082E9 44                      	db	"D"
 37732 000082EA [1A37]                  	dw	PRINT_DATE
 37733 000082EC 45                      	db	"E"
 37734 000082ED [091E]                  	dw	PRINT_ESC
 37735 000082EF 47                      	db	"G"
 37736 000082F0 [0D1E]                  	dw	PRINT_G
 37737 000082F2 48                      	db	"H"
 37738 000082F3 [FF1D]                  	dw	PRINT_BACK
 37739 000082F5 4C                      	db	"L"
 37740 000082F6 [111E]                  	dw	PRINT_L
 37741 000082F8 4E                      	db	"N"
 37742 000082F9 [261E]                  	dw	PRINT_DRIVE
 37743 000082FB 50                      	db	"P"
 37744 000082FC [2E1E]                  	dw	build_dir_for_prompt
 37745 000082FE 51                      	db	"Q"
 37746 000082FF [051E]                  	dw	PRINT_EQ
 37747 00008301 54                      	db	"T"
 37748 00008302 [BD2F]                  	dw	PRINT_TIME
 37749 00008304 56                      	db	"V"
 37750 00008305 [951D]                  	dw	PRINT_VERSION
 37751 00008307 5F                      	db	"_"
 37752 00008308 [F925]                  	dw	CRLF2
 37753 0000830A 24                      	db	"$"
 37754 0000830B [171E]                  	dw	PRINT_CHAR
 37755 0000830D 00                      	db	0			; NUL TERMINATED
 37756                                  
 37757                                  ; Table of IF conditionals
 37758                                  IFTAB:
 37759 0000830E 034E4F54                	db	3,"NOT"			; First byte is count
 37760 00008312 [E60A]                  	dw	IFNOT
 37761 00008314 0A4552524F524C4556-     	db	10,"ERRORLEVEL"
 37761 0000831D 454C               
 37762 0000831F [A50B]                  	dw	IFERLEV
 37763 00008321 054558495354            	db	5,"EXIST"
 37764 00008327 [3A0B]                  	dw	IFEXISTS
 37765 00008329 00                      	db	0
 37766                                  
 37767                                  ; Table for internal command names
 37768                                  COMTAB:
 37769 0000832A 0344495203              	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
 37770 0000832F [6D10]                  	dw	CATALOG			; In TCMD1.ASM
 37771 00008331 [3B82]                  	dw	DirHelpMsgs
 37772                                  
 37773 00008333 0443414C4C02            	db	4,"CALL",fSwitchAllowed	; 2
 37774 00008339 [1A0C]                  	dw	_$CALL			; In TBATCH2.ASM
 37775 0000833B [9D82]                  	dw	CallHelpMsgs
 37776                                  
 37777 0000833D 044348435002            	db	4,"CHCP",fSwitchAllowed ; 2
 37778 00008343 [7420]                  	dw	CHCP			; In TCMD2B.ASM
 37779 00008345 [0B82]                  	dw	ChcpHelpMsgs
 37780                                  
 37781 00008347 0652454E414D4503        	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 37782 0000834F [6B1A]                  	dw	CRENAME			; In TCMD1.ASM
 37783 00008351 [7782]                  	dw	RenHelpMsgs
 37784                                  
 37785 00008353 0352454E03              	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 37786 00008358 [6B1A]                  	dw	CRENAME			; In TCMD1.ASM
 37787 0000835A [7782]                  	dw	RenHelpMsgs
 37788                                  	
 37789 0000835C 05455241534503          	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
 37790 00008363 [E619]                  	dw	ERASE			; In TCMD1.ASM
 37791 00008365 [3382]                  	dw	DelHelpMsgs
 37792                                  	
 37793 00008367 0344454C03              	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
 37794 0000836C [E619]                  	dw	ERASE			; In TCMD1.ASM
 37795 0000836E [3382]                  	dw	DelHelpMsgs
 37796                                  	
 37797 00008370 045459504503            	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 37798 00008376 [121B]                  	dw	TYPEFIL			; In TCMD1.ASM
 37799 00008378 [8D82]                  	dw	TypeHelpMsgs
 37800                                  	
 37801 0000837A 0352454D06              	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
 37802 0000837F [0401]                  	dw	TCOMMAND		; In TCODE.ASM
 37803 00008381 [A382]                  	dw	RemHelpMsgs
 37804                                  	
 37805 00008383 04434F505903            	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
 37806 00008389 [6737]                  	dw	COPY			; In COPY.ASM
 37807 0000838B [1D82]                  	dw	CopyHelpMsgs
 37808                                  	
 37809 0000838D 05504155534506          	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
 37810 00008394 [DA19]                  	dw	PAUSE			; In TCMD1.ASM
 37811 00008396 [A782]                  	dw	PauseHelpMsgs
 37812                                  	
 37813 00008398 044441544502            	db	4,"DATE",fSwitchAllowed	; 2
 37814 0000839E [C42E]                  	dw	DATE			; In TPIPE.ASM
 37815 000083A0 [2D82]                  	dw	DateHelpMsgs
 37816                                  	
 37817 000083A2 0454494D4502            	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
 37818 000083A8 [292F]                  	dw	CTIME			; In TPIPE.ASM
 37819 000083AA [8782]                  	dw	TimeHelpMsgs
 37820                                  	
 37821 000083AC 0356455202              	db	3,"VER",fSwitchAllowed ; 2
 37822 000083B1 [341D]                  	dw	VERSION			; In TCMD2.ASM
 37823 000083B3 [9182]                  	dw	VerHelpMsgs
 37824                                  	
 37825 000083B5 03564F4C03              	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 37826 000083BA [391C]                  	dw	VOLUME			; In TCMD1.ASM
 37827 000083BC [9982]                  	dw	VolHelpMsgs
 37828                                  	
 37829 000083BE 02434403                	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 37830 000083C2 [BF24]                  	dw	_$CHDIR			; In TENV.ASM
 37831 000083C4 [1182]                  	dw	CdHelpMsgs
 37832                                  	
 37833 000083C6 05434844495203          	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 37834 000083CD [BF24]                  	dw	_$CHDIR			; In TENV.ASM
 37835 000083CF [1182]                  	dw	CdHelpMsgs
 37836                                  	
 37837 000083D1 024D4403                	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 37838 000083D5 [2725]                  	dw	_$MKDIR			; In TENV.ASM
 37839 000083D7 [5382]                  	dw	MdHelpMsgs
 37840                                  	
 37841 000083D9 054D4B44495203          	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 37842 000083E0 [2725]                  	dw	_$MKDIR			; In TENV.ASM
 37843 000083E2 [5382]                  	dw	MdHelpMsgs
 37844                                  	
 37845 000083E4 02524403                	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 37846 000083E8 [6925]                  	dw	_$RMDIR			; In TENV.ASM
 37847 000083EA [7382]                  	dw	RdHelpMsgs
 37848                                  	
 37849 000083EC 05524D44495203          	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 37850 000083F3 [6925]                  	dw	_$RMDIR			; In TENV.ASM
 37851 000083F5 [7382]                  	dw	RdHelpMsgs
 37852                                  	
 37853 000083F7 05425245414B02          	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
 37854 000083FE [6436]                  	dw	CNTRLC			; In TUCODE.ASM
 37855 00008400 [0782]                  	dw	BreakHelpMsgs
 37856                                  	
 37857 00008402 0656455249465902        	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
 37858 0000840A [A636]                  	dw	VERIFY			; In TUCODE.ASM
 37859 0000840C [9582]                  	dw	VerifyHelpMsgs
 37860                                  	
 37861 0000840E 0353455406              	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
 37862 00008413 [2922]                  	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
 37863 00008415 [7F82]                  	dw	SetHelpMsgs
 37864                                  	
 37865 00008417 0650524F4D505406        	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
 37866 0000841F [0F22]                  	dw	ADD_PROMPT		; In TENV.ASM
 37867 00008421 [5F82]                  	dw	PromptHelpMsgs
 37868                                  	
 37869 00008423 045041544802            	db	4,"PATH",fSwitchAllowed ; 2
 37870 00008429 [951E]                  	dw	PATH			; In TCMD2.ASM
 37871 0000842B [5782]                  	dw	PathHelpMsgs
 37872                                  	
 37873 0000842D 044558495400            	db	4,"EXIT",0
 37874 00008433 [7121]                  	dw	_$EXIT			; In TCMD2.ASM
 37875 00008435 [4F82]                  	dw	ExitHelpMsgs
 37876                                  	
 37877 00008437 044354545903            	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
 37878 0000843D [D31F]                  	dw	CTTY			; In TCMD2.ASM
 37879 0000843F [2982]                  	dw	CttyHelpMsgs
 37880                                  	
 37881 00008441 044543484F06            	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
 37882 00008447 [2B36]                  	dw	_ECHO			; In TUCODE.ASM
 37883 00008449 [AB82]                  	dw	EchoHelpMsgs
 37884                                  	
 37885 0000844B 04474F544F06            	db	4,"GOTO",fSwitchAllowed+fLimitHelp
 37886 00008451 [4E0C]                  	dw	_GOTO			; In TBATCH.ASM
 37887 00008453 [B182]                  	dw	GotoHelpMsgs
 37888                                  	
 37889 00008455 05534849465402          	db	5,"SHIFT",fSwitchAllowed ; 2
 37890 0000845C [D30B]                  	dw	_SHIFT			; In TBATCH.ASM
 37891 0000845E [B782]                  	dw	ShiftHelpMsgs
 37892                                  	
 37893 00008460 02494606                	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
 37894 00008464 [7F0A]                  	dw	_$IF			; In TBATCH.ASM
 37895 00008466 [BB82]                  	dw	IfHelpMsgs
 37896                                  	
 37897 00008468 03464F5206              	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
 37898 0000846D [060F]                  	dw	_$FOR			; In TBATCH.ASM
 37899 0000846F [CB82]                  	dw	ForHelpMsgs
 37900                                  	
 37901 00008471 03434C5300              	db	3,"CLS",0
 37902 00008476 [3A1F]                  	dw	CLS			; In TCMD2.ASM
 37903 00008478 [1982]                  	dw	ClsHelpMsgs
 37904                                  	
 37905 0000847A 08545255454E414D45-     	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
 37905 00008483 03                 
 37906 00008484 [F620]                  	dw	TRUENAME		;AN000;
 37907 00008486 [D582]                  	dw	TruenameHelpMsgs
 37908                                  	
 37909 00008488 084C4F414448494748-     	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
 37909 00008491 02                 
 37910 00008492 [9E56]                  	dw	LoadHigh		; In loadhi.asm ; M003
 37911 00008494 [D982]                  	dw	LoadhighHelpMsgs	; M003
 37912                                  	
 37913 00008496 024C4802                	db	2,"LH",fSwitchAllowed ; 2	; Short form; M003
 37914 0000849A [9E56]                  	dw	LoadHigh		; In loadhi.asm ; M003
 37915 0000849C [D982]                  	dw	LoadhighHelpMsgs	; M003
 37916                                  	
 37917 0000849E 00                      	db	0			; Terminate command table
 37918                                  
 37919                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h
 37920                                  
 37921 0000849F 2E434F4D                comext:	db	".COM"
 37922 000084A3 2E455845                exeext:	db	".EXE"
 37923 000084A7 2E424154                batext:	db	".BAT"
 37924                                  
 37925                                  switch_list:
 37926 000084AB 3F5642415057            	db	"?VBAPW"		; flags we can recognize
 37927                                  
 37928                                  AttrLtrs:
 37929 000084B1 524853764441            	db	"RHSvDA"		; attribute letters for DIR
 37930                                  
 37931                                  ;	Attribute letters in AttrLtrs must appear in the order that
 37932                                  ;	attribute bits occur in the attribute byte returned by
 37933                                  ;	directory searches, starting with bit 0.
 37934                                  ;	The volume label attribute is lowercased to keep it from
 37935                                  ;	being matched (by an uppercase comparison).
 37936                                  
 37937                                  OrderLtrs:
 37938 000084B7 4E45445347              	db	"NEDSG"			; sort order letters for DIR
 37939                                  	; MSDOS 6.0 COMMAND.COM
 37940                                  	;db	"NEDSGC"		; sort order letters for DIR
 37941                                  
 37942                                  ;	Sort order letters stand for file name, extension,
 37943                                  ;	date/time, size, grouped (directory files before others),
 37944                                  ;	and compression ratio. DIR routines rely on the specific
 37945                                  ;	order of the letters in this list.
 37946                                  
 37947                                  comspec_flag:
 37948 000084BC 00                      	db	0                       ;AN071;
 37949                                  
 37950                                  BATBUFLEN:
 37951 000084BD 2000                    	dw	BatLen ; 32
 37952                                  
 37953                                  ; *****************************************************
 37954                                  ; EMG 4.00
 37955                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 37956                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 37957                                  ; *****************************************************
 37958                                  
 37959                                  ; COMMON PARSE BLOCKS
 37960                                  
 37961                                  ; Indicates no value list for PARSE.
 37962                                  
 37963                                  NO_VALUES:
 37964 000084BF 0000                    	dw	0			;AN000;  no values
 37965                                  
 37966                                  NULL_VALUE_LIST:  ; for unvalidated value
 37967 000084C1 00                       	db	0                       ; no value lists
 37968                                  
 37969                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37970                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h
 37971                                  
 37972                                  ; PARSE control block for a required file specification (upper cased)
 37973                                  
 37974                                  FILE_REQUIRED:
 37975 000084C2 0002                    	dw	0200h			;AN000;  filespec - required
 37976 000084C4 0100                    	dw	1			;AN000;  capitalize - file table
 37977 000084C6 [0F96]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 37978 000084C8 [BF84]                  	dw	NO_VALUES		;AN000;
 37979 000084CA 00                      	db	0			;AN000;  no keywords
 37980                                  
 37981                                  ; PARSE control block for an optional file specification (upper cased)
 37982                                  ; or drive number
 37983                                  
 37984                                  FILE_OPTIONAL:
 37985 000084CB 0103                    	dw	0301h			;AN000;  filespec or drive number
 37986                                  					;	 optional
 37987 000084CD 0100                    	dw	1			;AN000;  capitalize - file table
 37988 000084CF [0F96]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 37989 000084D1 [BF84]                  	dw	NO_VALUES		;AN000;
 37990 000084D3 00                      	db	0			;AN000;  no keywords
 37991                                  
 37992                                  ; PARSE control block for an optional file specification (upper cased)
 37993                                  
 37994                                  FILE_OPTIONAL2:
 37995 000084D4 0102                    	dw	0201h                   ;AN000;  filespec optional
 37996 000084D6 0100                    	dw	1                       ;AN000;  capitalize - file table
 37997 000084D8 [0F96]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 37998 000084DA [BF84]                  	dw	NO_VALUES		;AN000;
 37999 000084DC 00                      	db	0			;AN000;  no keywords
 38000                                  
 38001                                  ; PARSE control block for an optional /P switch
 38002                                  
 38003                                  SLASH_P_SWITCH:
 38004 000084DD 0000                    	dw	0			;AN000;  no match flags
 38005 000084DF 0200                    	dw	2			;AN000;  capitalize - char table
 38006 000084E1 [0F96]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38007 000084E3 [BF84]                  	dw	NO_VALUES		;AN000;
 38008 000084E5 01                      	db	1			;AN000;  1 keyword
 38009                                  SLASH_P_SYN:
 38010 000084E6 2F5000                  	db	"/P",0                  ;AN000;  /P switch
 38011                                  
 38012                                  ; PARSE BLOCK FOR BREAK, VERIFY, ECHO
 38013                                  
 38014                                  ; The following parse control block can be used for any command which
 38015                                  ; needs only the optional "ON" and "OFF" keywords as operands. Allows
 38016                                  ; the equal sign as an additional delimiter. Returns verified result
 38017                                  ; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
 38018                                  ; internal commands.
 38019                                  
 38020                                  PARSE_BREAK:
 38021 000084E9 [EC84]                  	dw	BREAK_PARMS		;AN000;
 38022 000084EB 00                      	db	0			;AN032; no extra delimiter
 38023                                  
 38024                                  BREAK_PARMS:
 38025 000084EC 0001                    	db	0,1			;AN000;  1 positional parm
 38026 000084EE [F284]                  	dw	BREAK_CONTROL1		;AN000;
 38027 000084F0 00                      	db	0			;AN000;  no switches
 38028 000084F1 00                      	db	0			;AN000;  no keywords
 38029                                  
 38030                                  BREAK_CONTROL1:
 38031 000084F2 0120                    	dw	2001h			;AN000;  string value - optional
 38032 000084F4 0200                    	dw	2			;AN000;  capitalize - char table
 38033 000084F6 [0F96]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38034 000084F8 [FB84]                  	dw	BREAK_VALUES		;AN000;
 38035 000084FA 00                      	db	0			;AN000;  no keywords
 38036                                  
 38037                                  BREAK_VALUES:
 38038 000084FB 03                      	db	3			;AN000;
 38039 000084FC 00                      	db	0			;AN000;  no ranges
 38040 000084FD 00                      	db	0			;AN000;  no numeric values
 38041 000084FE 02                      	db	2			;AN000;  2 string values
 38042 000084FF 00                      	db	0			;AN000;  returned if ON
 38043 00008500 [0585]                  	dw	BREAK_ON		;AN000;  point to ON string
 38044 00008502 66                      	db	'f'                     ;AN000;  returned if OFF
 38045 00008503 [0885]                  	dw	BREAK_OFF		;AN000;  point to OFF string
 38046                                  
 38047                                  BREAK_ON:
 38048 00008505 4F4E00                  	db	"ON",0                  ;AN000;
 38049                                  BREAK_OFF:
 38050 00008508 4F464600                	db	"OFF",0                 ;AN000;
 38051                                  
 38052                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38053                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h
 38054                                  
 38055                                  ; PARSE BLOCK FOR CHCP
 38056                                  
 38057                                  ; The following parse control block can be used for any command which
 38058                                  ; needs only one optional three digit decimal parameter for operands.
 38059                                  ; Returns verified result in PARSE1_OUTPUT. Currently used for the
 38060                                  ; CHCP internal command.
 38061                                  
 38062                                  CHCP_MINVAL	EQU	100			;AN000;
 38063                                  CHCP_MAXVAL	EQU	999			;AN000;
 38064                                  
 38065                                  PARSE_CHCP:
 38066 0000850C [0F85]                  	dw	CHCP_PARMS			;AN000;
 38067 0000850E 00                      	db	0				;AN000;  no extra delimiter
 38068                                  CHCP_PARMS:
 38069 0000850F 0001                    	db	0,1				;AN000;  1 positional parm
 38070 00008511 [1585]                  	dw	CHCP_CONTROL1			;AN000;
 38071 00008513 00                      	db	0				;AN000;  no switches
 38072 00008514 00                      	db	0				;AN000;  no keywords
 38073                                  
 38074                                  CHCP_CONTROL1:
 38075 00008515 0180                    	dw	8001h				;AN000;  numeric value - optional
 38076 00008517 0000                    	dw	0				;AN000;  no function flags
 38077 00008519 [0F96]                  	dw	PARSE1_OUTPUT			;AN000;  result buffer
 38078 0000851B [1E85]                  	dw	CHCP_VALUES			;AN000;
 38079 0000851D 00                      	db	0				;AN000;  no keywords
 38080                                  
 38081                                  CHCP_VALUES:
 38082 0000851E 01                      	db	1				;AN000;
 38083 0000851F 01                      	db	1				;AN000;  1 range
 38084 00008520 01                      	db	1				;AN000;  returned if result
 38085 00008521 64000000E7030000        	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
 38086 00008529 00                      	db	0				;AN000;  no numeric values
 38087 0000852A 00                      	db	0				;AN000;  no string values
 38088                                  
 38089                                  ; PARSE BLOCK FOR DATE
 38090                                  
 38091                                  ; The following parse control block can be used for any command which
 38092                                  ; needs only an optional date string as an operand. Returns unverified
 38093                                  ; result in DATE_OUTPUT. Currently used for the DATE internal command.
 38094                                  
 38095                                  PARSE_DATE:
 38096 0000852B [2E85]                  	dw	DATE_PARMS			;AN000;
 38097 0000852D 00                      	db	0				;AN000;  no extra delimiter
 38098                                  DATE_PARMS:
 38099 0000852E 0001                    	db	0,1				;AN000;  1 positional parm
 38100 00008530 [3485]                  	dw	DATE_CONTROL1			;AN000;
 38101 00008532 00                      	db	0				;AN000;  no switches
 38102 00008533 00                      	db	0				;AN000;  no keywords
 38103                                  
 38104                                  DATE_CONTROL1:
 38105 00008534 0110                    	dw	1001h				;AN000;  date - optional
 38106 00008536 0000                    	dw	0				;AN000;  no function flags
 38107 00008538 [1796]                  	dw	DATE_OUTPUT			;AN000;  result buffer
 38108 0000853A [BF84]                  	dw	NO_VALUES			;AN000;
 38109 0000853C 00                      	db	0				;AN000;  no keywords
 38110                                  
 38111                                  ; PARSE BLOCK FOR TIME
 38112                                  
 38113                                  ; The following parse control block can be used for any command which
 38114                                  ; needs only an optional time string as an operand. Returns unverified
 38115                                  ; result in TIME_OUTPUT. Currently used for the TIME internal command.
 38116                                  
 38117                                  PARSE_TIME:
 38118 0000853D [4085]                  	dw	TIME_PARMS			;AN000;
 38119 0000853F 00                      	db	0				;AN000;  no extra delimiter
 38120                                  TIME_PARMS:
 38121 00008540 0001                    	db	0,1				;AN000;  1 positional parm
 38122 00008542 [4685]                  	dw	TIME_CONTROL1			;AN000;
 38123 00008544 00                      	db	0				;AN000;  no switches
 38124 00008545 00                      	db	0				;AN000;  no keywords
 38125                                  
 38126                                  TIME_CONTROL1:
 38127 00008546 0108                    	dw	0801h				;AN000;  TIME - optional
 38128 00008548 0000                    	dw	0				;AN000;  no function flags
 38129 0000854A [1F96]                  	dw	TIME_OUTPUT			;AN000;  result buffer
 38130 0000854C [BF84]                  	dw	NO_VALUES			;AN000;
 38131 0000854E 00                      	db	0				;AN000;  no keywords
 38132                                  
 38133                                  ; PARSE BLOCK FOR VOL
 38134                                  
 38135                                  ; The following parse control block can be used for any command which
 38136                                  ; needs only an optional drive letter as an operand.  Returns unverified
 38137                                  ; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
 38138                                  ; internal command.
 38139                                  
 38140                                  PARSE_VOL:
 38141 0000854F [5285]                  	dw	VOL_PARMS			;AN000;
 38142 00008551 00                      	db	0				;AN000;  no extra delimiter
 38143                                  VOL_PARMS:
 38144 00008552 0001                    	db	0,1				;AN000;  1 positional parm
 38145 00008554 [5885]                  	dw	DRIVE_CONTROL1			;AN000;
 38146 00008556 00                      	db	0				;AN000;  no switches
 38147 00008557 00                      	db	0				;AN000;  no keywords
 38148                                  
 38149                                  DRIVE_CONTROL1:
 38150 00008558 0101                    	dw	0101h				;AN000;  DRIVE - optional
 38151 0000855A 0100                    	dw	1				;AN000;  capitalize - file table
 38152 0000855C [2796]                  	dw	DRIVE_OUTPUT			;AN000;  result buffer
 38153 0000855E [BF84]                  	dw	NO_VALUES			;AN000;
 38154 00008560 00                      	db	0				;AN000;  no keywords
 38155                                  
 38156                                  ; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
 38157                                  
 38158                                  ; The following parse control block can be used for any command which
 38159                                  ; needs only one required file specification as an operand. Returns a
 38160                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38161                                  ; for the MKDIR, RMDIR, and TYPE internal commands.
 38162                                  
 38163                                  PARSE_MRDIR:
 38164 00008561 [6485]                  	dw	MRDIR_PARMS			;AN000;
 38165 00008563 00                      	db	0				;AN000;  no extra delimiter
 38166                                  MRDIR_PARMS:
 38167 00008564 0101                    	db	1,1				;AN000;  1 positional parm
 38168 00008566 [C284]                  	dw	FILE_REQUIRED			;AN000;
 38169 00008568 00                      	db	0				;AN000;  no switches
 38170 00008569 00                      	db	0				;AN000;  no keywords
 38171                                  
 38172                                  ; PARSE BLOCK FOR CHDIR, TRUENAME
 38173                                  
 38174                                  ; The following parse control block can be used for any command which
 38175                                  ; needs only one optional file specification an operand. Returns a
 38176                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38177                                  ; for the CHDIR and TRUENAME internal commands.
 38178                                  
 38179                                  PARSE_CHDIR:
 38180 0000856A [6D85]                  	dw	CHDIR_PARMS			;AN000;
 38181 0000856C 00                      	db	0				;AN000;  no extra delimiter
 38182                                  CHDIR_PARMS:
 38183 0000856D 0001                    	db	0,1				;AN000;  1 positional parm
 38184 0000856F [CB84]                  	dw	FILE_OPTIONAL			;AN000;
 38185 00008571 00                      	db	0				;AN000;  no switches
 38186 00008572 00                      	db	0				;AN000;  no keywords
 38187                                  
 38188                                  ; PARSE BLOCK FOR ERASE
 38189                                  
 38190                                  ; The following parse control block is used for the DEL/ERASE internal
 38191                                  ; commands. This command has one required file specification and an
 38192                                  ; optional switch (/p) as operands. The verified switch or unverified
 38193                                  ; file specification is returned in PARSE1_OUTPUT.
 38194                                  
 38195                                  PARSE_ERASE:
 38196 00008573 [7685]                  	dw	ERASE_PARMS			;AN000;
 38197 00008575 00                      	db	0				;AN000;  no extra delimiter
 38198                                  
 38199                                  ERASE_PARMS:
 38200 00008576 0101                    	db	1,1				;AN000;  1 positional parm
 38201 00008578 [C284]                  	dw	FILE_REQUIRED			;AN000;
 38202 0000857A 01                      	db	1				;AN000;  1 switch
 38203 0000857B [DD84]                  	dw	SLASH_P_SWITCH			;AN000;
 38204 0000857D 00                      	db	0				;AN000;  no keywords
 38205                                  
 38206                                  ; PARSE BLOCK FOR DIR
 38207                                  
 38208                                  ; The following parse control block is used for the DIR internal command.
 38209                                  ; This command has one optional file specification and several optional
 38210                                  ; switches. Switches, switch values, and the filespec are returned in 
 38211                                  ; PARSE1_OUTPUT.
 38212                                  ;
 38213                                  ; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
 38214                                  ; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
 38215                                  ; do not require colons, and are not checked against a value list.
 38216                                  ;
 38217                                  ; Switch /h has been removed from the DIR command	;M008
 38218                                  ; Switch /? is no longer handled internally		;M008
 38219                                  ;
 38220                                  ; A list of pointers to all the switch synonyms is provided here to
 38221                                  ; help identify which switch has been matched.
 38222                                  
 38223                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38224                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h
 38225                                  
 38226                                  PARSE_DIR:
 38227 0000857E [8185]                  	dw	DIR_PARMS
 38228 00008580 00                      	db	0			; no extra delimiters
 38229                                  DIR_PARMS:
 38230 00008581 0001                    	db	0,1			; 1 optional positional param
 38231 00008583 [D484]                  	dw	FILE_OPTIONAL2
 38232 00008585 02                      	db	2			; 2 kinds of switches
 38233 00008586 [8B85]                  	dw	DIR_SW_VALUED
 38234 00008588 [9A85]                  	dw	DIR_SW_UNVALUED
 38235 0000858A 00                      	db	0			; no keywords
 38236                                  
 38237                                  DIR_SW_VALUED:
 38238 0000858B 0120                    	dw	2001h			; optional string value
 38239 0000858D 2100                    	dw	21h			; optional colon; capitalize 
 38240 0000858F [0F96]                  	dw	PARSE1_OUTPUT		; result buffer
 38241 00008591 [C184]                  	dw	NULL_VALUE_LIST		; don't validate value
 38242                                  
 38243 00008593 02                      	db	2
 38244                                  
 38245                                  ; MSDOS 6.0 COMMAND.COM
 38246                                  ;ifdef DBLSPACE_HOOKS
 38247                                  ;	db	3		; 3 'synonyms'
 38248                                  ;else
 38249                                  ;	db	2		; 2 'synonyms'
 38250                                  ;endif
 38251                                  
 38252                                  DIR_SW_A:
 38253 00008594 2F4100                  	db	"/A",0
 38254                                  DIR_SW_O:
 38255 00008597 2F4F00                  	db	"/O",0
 38256                                  
 38257                                  ; MSDOS 6.0 COMMAND.COM
 38258                                  ;ifdef DBLSPACE_HOOKS
 38259                                  ;DIR_SW_C	db	"/C",0
 38260                                  ;endif
 38261                                  
 38262                                  DIR_SW_UNVALUED:
 38263 0000859A 0000                    	dw	0			; no value
 38264 0000859C 0000                    	dw	0			; no format functions
 38265 0000859E [0F96]                  	dw	PARSE1_OUTPUT		; result buffer
 38266 000085A0 [BF84]                  	dw	NO_VALUES
 38267                                  
 38268                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38269                                  	;db	12
 38270                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
 38271 000085A2 0E                      	db	14		; 14 'synonyms' !?
 38272                                  
 38273                                  ; MSDOS 6.0 COMMAND.COM
 38274                                  ;ifdef DBLSPACE_HOOKS
 38275                                  ;	db	13		; 13 'synonyms'
 38276                                  ;else
 38277                                  ;	db	12		; 12 'synonyms'
 38278                                  ;endif
 38279                                  
 38280                                  DIR_SW_NEG_A:
 38281 000085A3 2F2D4100                	db	"/-A",0
 38282                                  DIR_SW_NEG_O:
 38283 000085A7 2F2D4F00                	db	"/-O",0
 38284                                  DIR_SW_S:
 38285 000085AB 2F5300                  	db	"/S",0
 38286                                  DIR_SW_NEG_S:
 38287 000085AE 2F2D5300                	db	"/-S",0
 38288                                  DIR_SW_B:
 38289 000085B2 2F4200                  	db	"/B",0
 38290                                  DIR_SW_NEG_B:
 38291 000085B5 2F2D4200                	db	"/-B",0
 38292                                  DIR_SW_W:
 38293 000085B9 2F5700                  	db	"/W",0
 38294                                  DIR_SW_NEG_W:
 38295 000085BC 2F2D5700                	db	"/-W",0
 38296                                  DIR_SW_P:
 38297 000085C0 2F5000                  	db	"/P",0
 38298                                  DIR_SW_NEG_P:
 38299 000085C3 2F2D5000                	db	"/-P",0
 38300                                  DIR_SW_L:
 38301 000085C7 2F4C00                  	db	"/L",0		;M010
 38302                                  DIR_SW_NEG_L:
 38303 000085CA 2F2D4C00                	db	"/-L",0 	;M010
 38304                                  ; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
 38305                                  ;DIR_SW_NEG_C:
 38306                                  ;	db	"/-C",0
 38307                                  
 38308                                  ; Here's a list of pointers to DIR's switch synonyms, for easier
 38309                                  ; identification. Order is critical - DIR routines rely on the
 38310                                  ; specific order in this list. Negated options appear at odd 
 38311                                  ; positions in the list, and simple on/off options appear first.
 38312                                  
 38313                                  Dir_Sw_Ptrs:
 38314                                  	; MSDOS 5.0 COMMAND.COM
 38315 000085CE [BC85]                  	dw	DIR_SW_NEG_W 
 38316                                  Dir_Sw_Ptrs_2:			; list of ptrs to switch synonyms
 38317                                  	; MSDOS 6.0 COMMAND.COM
 38318                                  	;dw	DIR_SW_NEG_C
 38319                                  	;dw	DIR_SW_C
 38320                                  	;dw	DIR_SW_NEG_W
 38321                                  	
 38322 000085D0 [B985]                  	dw	DIR_SW_W
 38323 000085D2 [C385]                  	dw	DIR_SW_NEG_P
 38324 000085D4 [C085]                  	dw	DIR_SW_P
 38325 000085D6 [AE85]                  	dw	DIR_SW_NEG_S
 38326 000085D8 [AB85]                  	dw	DIR_SW_S
 38327 000085DA [B585]                  	dw	DIR_SW_NEG_B
 38328 000085DC [B285]                  	dw	DIR_SW_B
 38329 000085DE [CA85]                  	dw	DIR_SW_NEG_L	;M010
 38330 000085E0 [C785]                  	dw	DIR_SW_L	;M010
 38331 000085E2 [A785]                  	dw	DIR_SW_NEG_O
 38332 000085E4 [9785]                  	dw	DIR_SW_O
 38333 000085E6 [A385]                  	dw	DIR_SW_NEG_A
 38334 000085E8 [9485]                  	dw	DIR_SW_A
 38335                                  
 38336                                  ; PARSE BLOCK FOR RENAME
 38337                                  
 38338                                  ; The following parse control block can be used for any command which
 38339                                  ; needs only two required file specifications as operands. Returns
 38340                                  ; pointers to the unverified string in PARSE1_OUTPUT.
 38341                                  ; Currently used for the RENAME internal command.
 38342                                  
 38343                                  PARSE_RENAME:
 38344 000085EA [ED85]                  	dw	RENAME_PARMS		;AN000;
 38345 000085EC 00                      	db	0			;AN000;  no extra delimiter
 38346                                  RENAME_PARMS:
 38347 000085ED 0202                    	db	2,2			;AN000;  2 positional parms
 38348 000085EF [C284]                  	dw	FILE_REQUIRED		;AN000;
 38349 000085F1 [C284]                  	dw	FILE_REQUIRED		;AN000;
 38350 000085F3 00                      	db	0			;AN000;  no switches
 38351 000085F4 00                      	db	0			;AN000;  no keywords
 38352                                  
 38353                                  ; PARSE BLOCK FOR CTTY
 38354                                  
 38355                                  ; The following parse control block can be used for any command which
 38356                                  ; needs one required device name as an operand. Returns a pointer to
 38357                                  ; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
 38358                                  ; internal command.
 38359                                  
 38360                                  PARSE_CTTY:
 38361 000085F5 [F885]                  	dw	CTTY_PARMS		;AN000;
 38362 000085F7 00                      	db	0			;AN000;  no extra delimiter
 38363                                  CTTY_PARMS:
 38364 000085F8 0101                    	db	1,1			;AN000;  1 positional parm
 38365 000085FA [FE85]                  	dw	CTTY_CONTROL1		;AN000;
 38366 000085FC 00                      	db	0			;AN000;  no switches
 38367 000085FD 00                      	db	0			;AN000;  no keywords
 38368                                  CTTY_CONTROL1:
 38369 000085FE 0020                    	dw	2000h			;AN000;  string value - required
 38370 00008600 1100                    	dw	11h			;AN000;  capitalize - file table
 38371                                  					;AN000;  remove colon at end
 38372 00008602 [0F96]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38373 00008604 [BF84]                  	dw	NO_VALUES		;AN000;
 38374 00008606 00                      	db	0			;AN000;  no keywords
 38375                                  
 38376                                  ; PARSE BLOCK FOR VER
 38377                                  
 38378                                  ; The following parse control block can be used for any command which
 38379                                  ; needs an optional switch "/debug". Currently used for the VER command.
 38380                                  
 38381                                  PARSE_VER:
 38382 00008607 [0A86]                  	dw	VER_PARMS
 38383 00008609 00                      	db	0			; no extra delimiters
 38384                                  VER_PARMS:
 38385 0000860A 0000                    	db	0,0			; no positional parameters
 38386 0000860C 01                      	db	1			; one switch
 38387 0000860D [1086]                  	dw	SLASH_R
 38388 0000860F 00                      	db	0			; no keywords
 38389                                  SLASH_R:
 38390 00008610 0000                    	dw	0			; no values
 38391 00008612 0200                    	dw	2			; capitalize by filename table
 38392 00008614 [0F96]                  	dw	PARSE1_OUTPUT		; result buffer
 38393 00008616 [BF84]                  	dw	NO_VALUES		; no values
 38394 00008618 01                      	db	1			; one synonym
 38395                                  SLASH_R_SYN:
 38396 00008619 2F5200                  	db	"/R",0
 38397                                  
 38398                                  ; M003 ; Start of changes for LoadHigh support
 38399                                  
 38400                                  ;Parse Control Block for LOADHIGH command
 38401                                  
 38402                                  Parse_LoadHi:
 38403 0000861C [1F86]                  	dw	LoadHi_Parms		;extended parm table
 38404 0000861E 00                      	db	0			;no extra delimiters
 38405                                  
 38406                                  LoadHi_Parms:
 38407 0000861F 0101                    	db	1,1			;min. 1 parm, max. 1 parm
 38408 00008621 [C284]                  	dw	FILE_REQUIRED		;control struc for filename
 38409 00008623 00                      	db	0			;no switches
 38410 00008624 00                      	db	0			;no keywords
 38411                                  
 38412                                  ; M003 ; End of changes for LoadHigh support
 38413                                  
 38414                                  TempVarName:
 38415 00008625 54454D503D00            	db	"TEMP=",0
 38416                                  
 38417                                  	; 16/04/2023
 38418                                  TRANDATAEND:		; TRANGROUP:88C2h
 38419                                  
 38420                                  ;============================================================================
 38421                                  ; PSDATA.INC, MSDOS 6.0, 1991
 38422                                  ;============================================================================
 38423                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38424                                  
 38425                                  ; 18/04/2023
 38426                                  TRANSPACESTART:
 38427                                  
 38428                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h
 38429                                  
 38430                                  ;********************** Local Data *************************************
 38431                                  
 38432                                  $P_ORDINAL:
 38433 0000862B 0000                    	dw	0		;AN000; Operand ordinal save area
 38434                                  $P_RC:
 38435 0000862D 0000                    	dw	0		;AN000; Return code from parser
 38436                                  $P_SI_Save:
 38437 0000862F 0000                    	dw	0		;AN000; Pointer of command buffer
 38438                                  $P_DX:
 38439 00008631 0000                    	dw	0		;AN000; Return result buffer address
 38440                                  $P_Terminator:
 38441 00008633 00                      	db	0		;AN000; Terminator code (ASCII)
 38442                                  $P_DBCSEV_OFF:
 38443 00008634 0000                    	dw	0		;AN000; Offset of DBCS EV
 38444                                  $P_DBCSEV_SEG:
 38445 00008636 0000                    	dw	0		;AN000; Segment of DBCS EV
 38446                                  $P_Flags:			;AN000; Parser internal flags
 38447                                  $P_Flags1:
 38448 00008638 00                      	db	0		;AN038; to reference first byte flags
 38449                                  $P_Flags2:
 38450 00008639 00                      	db	0		;AN038; to reference second byte flags only
 38451                                  $P_SaveSI_Cmpx:
 38452 0000863A 0000                    	dw	0		;AN000; save si for later use by complex
 38453                                  $P_KEYorSW_Ptr:
 38454 0000863C 0000                    	dw	0		;AN000; points next to "=" or ":" code
 38455                                  $P_Save_EOB:
 38456 0000863E 0000                    	dw	0		;AN000; save pointer to EOB
 38457                                  $P_Found_SYNONYM:
 38458 00008640 0000                    	dw	0		;AN000; es:@ points to found synonym
 38459                                  $P_STRING_BUF:
 38460 00008642 00<rep 80h>             	times  128 db 0		;AN000; Pick a operand from command line
 38461                                  $P_ORIG_ORD:
 38462 000086C2 0000                    	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
 38463                                  $P_ORIG_STACK:
 38464 000086C4 0000                    	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
 38465                                  $P_ORIG_SI:
 38466 000086C6 0000                    	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
 38467                                  $P_Got_Time:
 38468 000086C8 00                      	db	0		;AN023; if 1, use Time delimiters
 38469                                  $P_Country_Info:
 38470 000086C9 FFFF                    	dw	-1 ; 0FFFFh
 38471 000086CB 00<rep 20h>             	times	32 db 0	
 38472                                  $P_1st_Val:
 38473 000086EB 0000                    	dw	0		;AN000; used when process date or time
 38474                                  $P_2nd_Val:
 38475 000086ED 0000                    	dw	0		;AN000; used when process date or time
 38476                                  $P_3rd_Val:
 38477 000086EF 0000                    	dw	0		;AN000; used when process date or time
 38478                                  $P_4th_Val:
 38479 000086F1 0000                    	dw	0		;AN000; used when process date or time
 38480                                  $P_Char_CAP_Ptr:
 38481 000086F3 FF                      	db	0FFh		;AN000; info id
 38482 000086F4 0000                    	dw	0		;AN000; offset	of char case map table
 38483 000086F6 0000                    	dw	0		;AN000; segment of char case map table
 38484                                  $P_File_CAP_Ptr:
 38485 000086F8 FF                      	db	0FFh		;AN000; info id
 38486 000086F9 0000                    	dw	0		;AN000; offset	of file case map table
 38487 000086FB 0000                    	dw	0		;AN000; segment of file case map table
 38488                                  
 38489                                  	; 18/04/2023
 38490                                  ;M029
 38491                                  ;!!!WARNING!!!
 38492                                  ; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
 38493                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 38494                                  ;changes need to be made in SYSPARSE
 38495                                  
 38496                                  $P_FileSp_Char:
 38497 000086FD 5B5D7C3C3E2B3D3B22      	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 38498                                  $P_FileSp_Len equ $-$P_FileSp_Char ;AN000;
 38499                                  
 38500                                  ;filespec error flag
 38501                                  $P_err_flag:
 38502 00008706 00                      	db	0		;AN033; flag set if filespec parsing error
 38503                                  				;AN033;  was detected.
 38504                                  
 38505                                  ;============================================================================
 38506                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 38507                                  ;============================================================================
 38508                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38509                                  
 38510                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh
 38511                                  
 38512                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 38513                                  ;;
 38514                                  ;; STRUCTURE: $M_RES_ADDRS
 38515                                  ;;
 38516                                  ;; Resident data area definition of variables
 38517                                  ;;
 38518                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 38519                                  
 38520                                  $M_RT:
 38521 00008707 00<rep 8Dh>             	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0
 38522                                  
 38523                                  ;============================================================================
 38524                                  ; COPYRIGHT.INC, MSDOS 6.0, 1993
 38525                                  ;============================================================================
 38526                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38527                                  
 38528                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
 38529                                  ; ---------------------------------------------------------------------------
 38530                                  ;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
 38531                                  ;;M031 - changed copyright to 1991
 38532                                  ;;9/16 - changed verison to 6.0 and copyright to 1992
 38533                                  ;;9/21 - Added international translations, language passed through COUNTRY macro
 38534                                  ;;B49,50 - changed version to 6 and copyright to 1993
 38535                                  ; ---------------------------------------------------------------------------
 38536                                  
 38537                                  ;;ifdef USA
 38538                                  ;MsDosVer6_CCopy:
 38539                                  ;	db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
 38540                                  ;	db	"Licensed Material - Property of Microsoft "
 38541                                  ;	db	"All rights reserved "
 38542                                  ;endif
 38543                                  
 38544                                  ; 15/04/2023
 38545                                  MsDosVer5_CCopy:
 38546 00008794 4D5320444F53205665-     	db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
 38546 0000879D 7273696F6E20352E30-
 38546 000087A6 3020284329436F7079-
 38546 000087AF 726967687420313938-
 38546 000087B8 312D31393931204D69-
 38546 000087C1 63726F736F66742043-
 38546 000087CA 6F727020           
 38547 000087CE 4C6963656E73656420-     	db	"Licensed Material - Property of Microsoft "
 38547 000087D7 4D6174657269616C20-
 38547 000087E0 2D2050726F70657274-
 38547 000087E9 79206F66204D696372-
 38547 000087F2 6F736F667420       
 38548 000087F8 416C6C207269676874-     	db	"All rights reserved "
 38548 00008801 732072657365727665-
 38548 0000880A 6420               
 38549                                  ; ---------------------------------------------------------------------------
 38550                                  ; 15/04/2023
 38551                                  	; 16/04/2023 - 21/04/2023
 38552                                  	;db 	0
 38553                                  	;db	0Dh,0Ah
 38554                                  	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
 38555                                  	;db	0
 38556                                  	;db	'by Erdogan Tan - 05/05/2023'
 38557                                  	;db	0
 38558                                  
 38559                                  ;============================================================================
 38560                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 38561                                  ;============================================================================
 38562                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38563                                  
 38564                                  PRINTF_HANDLE:
 38565 0000880C 0000                    	dw	0		;AC000;
 38566                                  
 38567                                  ; 15/047/2023
 38568                                  %if 0
 38569                                  
 38570                                  ;============================================================================
 38571                                  ; TSPC.ASM, MSDOS 6.0, 1991
 38572                                  ;============================================================================
 38573                                  ; 29/09/2018 - Retro DOS v3.0
 38574                                  
 38575                                  ;TITLE	COMMAND Transient Uninitialized DATA
 38576                                  
 38577                                  ;The TRANSPACE segment contains variable data that is considered
 38578                                  ;volatile between command cycles, and therefore is not included in the
 38579                                  ;transient checksum area. Contents of these variables MUST be
 38580                                  ;initialized before use, and must not be relied upon from command
 38581                                  ;cycle to command cycle.
 38582                                  ;
 38583                                  ;No constant data values should be stored here.
 38584                                  
 38585                                  ; ---------------------------------------------------------------------------
 38586                                  ; START OF UNITIALIZED DATA
 38587                                  ; ---------------------------------------------------------------------------
 38588                                  
 38589                                  ;	times 12 db 0
 38590                                  
 38591                                  align 16
 38592                                  
 38593                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 38594                                  
 38595                                  PRINTF_LEFT:	db 0
 38596                                  PRINTF_LONG:	db 0
 38597                                  PRINTF_HEX:	db 0
 38598                                  TABLE_INDEX:	db 0
 38599                                  PRINTF_WIDTH:	dw 0
 38600                                  PRINTF_BASE:	dw 0
 38601                                  PAD_CHAR:	db 0
 38602                                  PRINTF_HANDLE:	dw 0
 38603                                  PRINTF_BUF: times 100 db 0
 38604                                  PRINTF_BUF_END: ; 30/09/2018
 38605                                  
 38606                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 38607                                  
 38608                                  SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 38609                                  TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 38610                                  UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 38611                                  COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 38612                                  USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 38613                                  EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 38614                                  RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 38615                                  
 38616                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 38617                                  HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 38618                                  RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 38619                                  TPA:		dw 0			; LTPA	    (dw 0)	
 38620                                  SWITCHAR:	db 0			; RSWITCHAR (db '-')
 38621                                  DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 38622                                  EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 38623                                  					; MYSEG1    (dw 0)	
 38624                                  RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 38625                                  					; MYSEG2    (dw 0)	
 38626                                  		dw 0			; RESTEST   (dw 0)	
 38627                                  TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 38628                                  
 38629                                  CHKDRV:		db 0
 38630                                  IFNOTFLAG:
 38631                                  FILTYP:
 38632                                  RDEOF:		db 0			; Misc flags
 38633                                  CURDRV:		db 0
 38634                                  PARM1:
 38635                                  Concat:		db 0
 38636                                  PARM2:
 38637                                  ArgC:		db 0
 38638                                  COMSW:		dw 0			; Switches between command and 1st arg
 38639                                  ARG1S:		dw 0			; Switches between 1st and 2nd arg
 38640                                  ARG2S:					; Switches after 2nd arg		
 38641                                  DestSwitch:	dw 0
 38642                                  ARGTS:
 38643                                  AllSwitch:	dw 0			; ALL switches except for COMSW
 38644                                  CFLAG:		db 0
 38645                                  DestClosed:
 38646                                  SPECDRV:	db 0
 38647                                  BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 38648                                  NXTADD:		dw 0
 38649                                  FRSTSRCH:	db 0
 38650                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 38651                                  ;PerLine:	db 0			; entries/line u.b. DIR
 38652                                  LINCNT:		db 0
 38653                                  LINLEN:		db 0
 38654                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 38655                                  FILECNT:	dw 0			; file count u.b. DIR
 38656                                  ;FileSiz:	dd 0			; file size u.b. DIR
 38657                                  
 38658                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 38659                                  ;
 38660                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 38661                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 38662                                  
 38663                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 38664                                  
 38665                                  CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 38666                                  DESTFCB2:
 38667                                  IDLEN:		db 0
 38668                                  ID:	  times	8  db 0
 38669                                  COM:	  times	3  db 0 
 38670                                  DEST:	  times 37 db 0
 38671                                  DESTNAME: times 11 db 0
 38672                                  DESTDIR:
 38673                                  DestFcb:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 38674                                  GOTOLEN:	; word
 38675                                  BWDBUF: 	; byte
 38676                                  EXEFCB: 	; word
 38677                                  DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 38678                                  
 38679                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 38680                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 38681                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 38682                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 38683                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 38684                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 38685                                  
 38686                                  SDIRBUF:  times 12 db 0	
 38687                                  _BITS:		dw 0
 38688                                  PATHCNT:	dw 0
 38689                                  PATHPOS:	dw 0
 38690                                  PATHSW:		dw 0
 38691                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 38692                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 38693                                  LINPERPAG:	db 0
 38694                                  		db 0
 38695                                  COMMA:		db 0			; flag set if +,, occurs
 38696                                  PLUS_COMMA:	db 0			; flag set if +,, occurs
 38697                                  
 38698                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 38699                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 38700                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 38701                                  
 38702                                  ARG_BUF:  times 128 db 0   ; _43E8h	
 38703                                  STRING_PTR_1:	dw 0	   ; _4468h	
 38704                                  FILESIZE_L:	dw 0	   ; _446Ah		
 38705                                  FILESIZE_H:	dw 0	   ; _446Ch	
 38706                                  STRING_PTR_2:	dw 0	   ; _446Eh	
 38707                                  
 38708                                  COPY_NUM:	dw 0
 38709                                  	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 38710                                  CPYFLAG:	db 0
 38711                                  DIR_NUM:	dw 0
 38712                                  BYTES_FREE:	dw 0
 38713                                  		dw 0
 38714                                  MAJOR_VER_NUM:	dw 0
 38715                                  MINOR_VER_NUM:	dw 0
 38716                                  ONE_CHAR_VAL:	db 0
 38717                                  		;db 0
 38718                                  VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 38719                                  VOL_DRV:	db 0
 38720                                  VOL_DIR:	dw 0 ; MSDOS 3.3
 38721                                  
 38722                                  ROM_CALL:	db 0			; flag for rom function
 38723                                  ROM_IP:		dw 0
 38724                                  ROM_CS:		dw 0
 38725                                  
 38726                                  DestVars:
 38727                                  DestIsDir:	db 0
 38728                                  DestSiz:	db 0
 38729                                  DestTail:	dw 0
 38730                                  DestInfo:	db 0
 38731                                  DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 38732                                  ENDDESTBUF:
 38733                                  
 38734                                  DESTHAND:	dw 0
 38735                                  DESTISDEV:	db 0
 38736                                  FIRSTDEST:	db 0
 38737                                  MELCOPY:	db 0
 38738                                  MELSTART:	dw 0
 38739                                  
 38740                                  SrcVars:
 38741                                  SrcIsDir:	db 0
 38742                                  SrcSiz:		db 0
 38743                                  SrcTail:	dw 0
 38744                                  SrcInfo:	db 0
 38745                                  SrcBuf:   times	DIRSTRLEN+20 db 0 ; 87
 38746                                  
 38747                                  SRCHAND:	dw 0
 38748                                  SRCISDEV:	db 0
 38749                                  
 38750                                  SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 38751                                  
 38752                                  SRCPT:		dw 0
 38753                                  INEXACT:	db 0
 38754                                  		db 0 ; MSDOS 3.3 
 38755                                  NOWRITE:	db 0
 38756                                  BINARY:		db 0
 38757                                  WRITTEN:	dw 0
 38758                                  TERMREAD:	db 0
 38759                                  ASCII:		db 0
 38760                                  PLUS:		db 0
 38761                                  OBJCNT:		db 0			; Used in copy
 38762                                  CPDATE:		dw 0
 38763                                  CPTIME:		dw 0
 38764                                  
 38765                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 38766                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 38767                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 38768                                  
 38769                                  BATHAND:	dw 0			; Batch handle
 38770                                  STARTEL:	dw 0
 38771                                  ELCNT:		db 0
 38772                                  ELPOS:		db 0
 38773                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 38774                                  MSDOS 5.0
 38775                                  SKPDEL:
 38776                                  SOURCE:   times	11 db 0
 38777                                  
 38778                                  ext_entered:	db 0			;AN005;
 38779                                  
 38780                                  ;display_ioctl	db 0			;AN000; info level
 38781                                  ;		db 0			;AN000; reserved
 38782                                  ;		dw crt_ioctl_ln		;AN000; length of data
 38783                                  ;		dw 0			;AN000; control flags
 38784                                  ;display_mode:	db 0			;AN000; display mode, colors
 38785                                  ;		db 0			;AN000; reserved
 38786                                  ;		dw 0			;AN023; colors
 38787                                  ;		dw 0			;AN000; display width (PELS)
 38788                                  ;		dw 0			;AN000; display length (PELS)
 38789                                  ;display_width:	dw 0			;AN000; display width
 38790                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 38791                                  ;
 38792                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 38793                                  ;		dw 0			;AN000; info level
 38794                                  ;vol_serial:	dd 0			;AN000; volume serial number
 38795                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 38796                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 38797                                  
 38798                                  EXPAND_STAR:	db 0
 38799                                  
 38800                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 38801                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 38802                                  ;append_exec:	db 0			;AN041; set if internal append executed
 38803                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 38804                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 38805                                  
 38806                                  COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 38807                                  
 38808                                  ; Data declarations taken out of parse.asm
 38809                                  
 38810                                  ; MSDOS 6.0
 38811                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 38812                                  ;argbufptr	dw	?		; index for argv[].argpointer
 38813                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 38814                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 38815                                  ;comptr		dw	?		; ptr into combuf
 38816                                  
 38817                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 38818                                  ARG:
 38819                                  ARG_ARGV:
 38820                                  ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 38821                                  ARGV0_ARG_FLAGS:  db 0
 38822                                  ARGV0_ARGSTARTEL: dw 0
 38823                                  ARGV0_ARGLEN:	  dw 0
 38824                                  ARGV0_ARGSW_WORD: dw 0
 38825                                  ARGV0_OCOMPTR:	  dw 0
 38826                                  
 38827                                  ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 38828                                  	  times 5 db 0
 38829                                  ARGV1_ARGSW_WORD: dw 0
 38830                                  		  dw 0
 38831                                  
 38832                                  ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 38833                                  	  times 5 db 0
 38834                                  ARGV2_ARGSW_WORD: dw 0
 38835                                  		  dw 0
 38836                                  
 38837                                  	times 671 db 0  ; ARGV[3] to ARGV[63]
 38838                                  	
 38839                                  ARG_ARGVCNT:	dw 0
 38840                                  ARG_ARGSWINFO:	dw 0
 38841                                  
 38842                                  ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 38843                                  ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 38844                                  
 38845                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 38846                                  
 38847                                  ARGBUFPTR:	dw 0			; index for argv[].argpointer
 38848                                  TPBUF:    times 128 db 0		; temporary buffer
 38849                                  LASTARG:	dw 0			; point at which to accumulate switch info
 38850                                  COMPTR:		dw 0			; ptr into combuf
 38851                                  
 38852                                  ; Data declarations taken out of path.asm
 38853                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 38854                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 38855                                  ;psep_char	DB	?			; '/' or '\'
 38856                                  ;search_best	DB	(?)			; best code, best filename so far
 38857                                  ;fname_max_len	equ	13
 38858                                  ;search_best_buf DB	fname_max_len DUP (?)
 38859                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 38860                                  ;search_error	DW	(?)			; address of error message to be printed
 38861                                  
 38862                                  FINDBUFLEN equ FIND_BUF.size ; 43
 38863                                  
 38864                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 38865                                  
 38866                                  FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 38867                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 38868                                  PATHINFO:
 38869                                  PATHINFO_0:	dw 0
 38870                                  PATHINFO_2:	dw 0
 38871                                  PATHINFO_4:	dw 0
 38872                                  PSEP_CHAR:	db 0
 38873                                  SEARCH_BEST:	db 0
 38874                                  ;FNAME_MAX_LEN equ 13
 38875                                  SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 38876                                  SEARCH_CURDIR_BUF: times 64 db 0
 38877                                  SEARCH_ERROR:	dw 0
 38878                                  
 38879                                  ; Data declarations taken out of tbatch.asm
 38880                                  
 38881                                  ;if_not_count	DW	?
 38882                                  ;
 38883                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 38884                                  ;
 38885                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 38886                                  
 38887                                  ; 31/03/2023
 38888                                  STACK:		;LABEL	WORD
 38889                                  
 38890                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 38891                                  
 38892                                  IF_NOT_COUNT:	dw 0
 38893                                  ZFLAG:		db 0
 38894                                  	  times 256 db 0 	
 38895                                  STACK:
 38896                                  
 38897                                  ;INTERNATVARS	internat_block <>
 38898                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 38899                                  ;
 38900                                  ;;		Buffer for DOS function 64h (Get extended country information)
 38901                                  ;;		subfunctions 2, 4, 6, or 7:
 38902                                  ;
 38903                                  ;CountryPtrInfo	label	byte
 38904                                  ;CountryPtrId	db	?
 38905                                  ;CountryPtr	dd	?
 38906                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 38907                                  
 38908                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 38909                                  
 38910                                  INTERNATVARS:	
 38911                                  DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 38912                                  CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 38913                                  THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 38914                                  DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 38915                                  DATE_SEP:	db 0,0			; Date separator 2 bytes
 38916                                  TIME_SEP:	db 0,0			; Time separator 2 bytes	
 38917                                  BIT_FIELD:	db 0			; Bit values
 38918                                  					;   Bit 0 = 0 if currency symbol first
 38919                                  					;	  = 1 if currency symbol last
 38920                                  					;   Bit 1 = 0 if No space after currency symbol
 38921                                  					;	  = 1 if space after currency symbol
 38922                                  CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 38923                                  TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 38924                                  MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 38925                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 38926                                  					;  in pieces.
 38927                                  DATA_SEP:	db 0,0			; Data list separator character		
 38928                                  
 38929                                  		times 8 db 0
 38930                                  ;
 38931                                  ; Max size of the block returned by the INTERNATIONAL call
 38932                                  ;
 38933                                  INTERNAT_BLOCK_SIZE EQU	32
 38934                                  
 38935                                  BATLEN equ 32
 38936                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 38937                                  
 38938                                  BATBUFPOS:	dw 0			; integer position in buffer of next byte
 38939                                  
 38940                                  BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 38941                                  
 38942                                  BATBUFEND:	dw 0
 38943                                  
 38944                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 38945                                  
 38946                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
 38947                                  
 38948                                  ; 18/04/2023
 38949                                  ; ----------------------------------------------------------------------------
 38950                                  ; 09/01/2023
 38951                                  ;TRANSPACEEND	equ $ - TRANSIENTSTART ; 18/04/2023
 38952                                  
 38953                                  %endif
 38954                                  
 38955                                  ;============================================================================
 38956                                  ; TSPC.ASM, MSDOS 6.0, 1991
 38957                                  ;============================================================================
 38958                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38959                                  
 38960                                  ;TITLE	COMMAND Transient Uninitialized DATA
 38961                                  
 38962                                  ;The TRANSPACE segment contains variable data that is considered
 38963                                  ;volatile between command cycles, and therefore is not included in the
 38964                                  ;transient checksum area. Contents of these variables MUST be
 38965                                  ;initialized before use, and must not be relied upon from command
 38966                                  ;cycle to command cycle.
 38967                                  ;
 38968                                  ;No constant data values should be stored here.
 38969                                  
 38970                                  ; ---------------------------------------------------------------------------
 38971                                  ; START OF UNITIALIZED DATA
 38972                                  ; ---------------------------------------------------------------------------
 38973                                  
 38974                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h
 38975                                  
 38976 0000880E 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 38977 00008865 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 38978 000088BC 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 38979 0000893F 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 38980 000089C2 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 38981 00008A08 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 38982 00008A8B 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 38983                                  
 38984                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 38985                                  HEADCALL:
 38986 00008ADE 0000                    	dw 0			; TRANVARS  (dw THEADFIX)
 38987 00008AE0 0000                    RESSEG:	dw 0			; MYSEG     (dw 0) 	 	
 38988 00008AE2 0000                    TPA:	dw 0			; LTPA	    (dw 0)	
 38989                                  SWITCHAR:
 38990 00008AE4 00                      	db 0			; RSWITCHAR (db '-')
 38991                                  DIRCHAR:
 38992 00008AE5 00                      	db 0			; RDIRCHAR  (db '/')
 38993                                  EXEC_ADDR:
 38994 00008AE6 00000000                	dd 0			; 	    (dw EXT_EXEC)	 
 38995                                  				; MYSEG1    (dw 0)	
 38996                                  RCH_ADDR:
 38997 00008AEA 00000000                	dd 0			;	    (dw TREMCHECK) 	
 38998                                  				; MYSEG2    (dw 0)	
 38999 00008AEE 0000                    	dw 0			; RESTEST   (dw 0)	
 39000                                  TRAN_TPA:
 39001 00008AF0 0000                    	dw 0			; RES_TPA   (dw 0)	
 39002                                  
 39003 00008AF2 00                      CHKDRV:	db 0
 39004                                  IFNOTFLAG:
 39005                                  FILTYP:
 39006 00008AF3 00                      RDEOF:	db 0			; Misc flags
 39007 00008AF4 00                      CURDRV:	db 0
 39008                                  PARM1:
 39009 00008AF5 00                      Concat:	db 0
 39010                                  PARM2:
 39011 00008AF6 00                      ArgC:	db 0
 39012 00008AF7 0000                    COMSW:	dw 0			; Switches between command and 1st arg
 39013 00008AF9 0000                    ARG1S:	dw 0			; Switches between 1st and 2nd arg
 39014                                  ARG2S:				; Switches after 2nd arg		
 39015                                  DestSwitch:
 39016 00008AFB 0000                    	dw 0
 39017                                  ARGTS:
 39018                                  AllSwitch:
 39019 00008AFD 0000                    	dw 0			; ALL switches except for COMSW
 39020 00008AFF 00                      CFLAG:	db 0
 39021                                  DestClosed:
 39022                                  SPECDRV:
 39023 00008B00 00                      	db 0
 39024 00008B01 0000                    BYTCNT:	dw 0			; Size of buffer between RES and TRANS
 39025 00008B03 0000                    NXTADD:	dw 0
 39026                                  FRSTSRCH:
 39027 00008B05 00                      	db 0
 39028                                  ; 15/04/2023
 39029                                  LeftOnLine:
 39030 00008B06 00                      	db 0			; entries left on line u.b. DIR
 39031                                  PerLine:
 39032 00008B07 00                      	db 0			; entries/line u.b. DIR
 39033 00008B08 00                      LINCNT:	db 0
 39034 00008B09 00                      LINLEN:	db 0
 39035                                  LeftOnPage:
 39036 00008B0A 0000                    	dw 0			; lines left on page u.b. DIR
 39037                                  FileCnt:
 39038 00008B0C 0000                    	dw 0			; file count u.b. DIR
 39039                                  FileSiz:
 39040 00008B0E 00000000                	dd 0			; file size u.b. DIR
 39041                                  
 39042                                  ; Note: keep FileCntTotal through csecUsedTotal together!
 39043                                  
 39044                                  FileCntTotal:
 39045 00008B12 00000000                	dd 0			; total file count u.b. DIR
 39046                                  FileSizTotal:
 39047 00008B16 00000000                	dd 0			; total file size u.b. DIR
 39048                                  
 39049                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
 39050                                  CHARBUF:
 39051 00008B1A 00<rep 50h>             	times	80 db 0		;line byte character buffer for xenix write
 39052                                  DESTFCB2:
 39053 00008B6A 00                      IDLEN:	db 0
 39054 00008B6B 00<rep 8h>              ID:	times	8  db 0
 39055 00008B73 00<rep 3h>              COM:	times	3  db 0 
 39056 00008B76 00<rep 25h>             DEST:	times	37 db 0
 39057                                  DESTNAME:
 39058 00008B9B 00<rep Bh>              	times	11 db 0
 39059                                  DESTDIR:
 39060                                  DestFcb:
 39061 00008BA6 00<rep 43h>             	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
 39062                                  GOTOLEN: ; word
 39063                                  BWDBUF:  ; byte
 39064                                  EXEFCB:  ; word
 39065 00008BE9 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 39066                                  
 39067                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 39068                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 39069                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 39070                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 39071                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 39072                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 39073                                  
 39074                                  	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39075                                  SDIRBUF:
 39076 00008C2F 00<rep Ch>              	times 12 db 0	
 39077                                  _Bits:
 39078 00008C3B 0000                    	dw 0
 39079                                  PathCnt:
 39080 00008C3D 0000                    	dw 0
 39081                                  PathPos:
 39082 00008C3F 0000                    	dw 0
 39083 00008C41 0000                    PathSw:	dw 0
 39084                                  AttrSpecified:
 39085 00008C43 00                      	db 0			; attribute bits u.b. DIR
 39086                                  AttrSelect:
 39087 00008C44 00                      	db 0			; attribute bits u.b. DIR
 39088 00008C45 00                      comma:	db 0			; flag set if +,, occurs
 39089                                  plus_comma:
 39090 00008C46 00                      	db 0			; flag set if +,, occurs
 39091                                  DirFlag:
 39092 00008C47 00                       	db 0			;AN015; set when pathcrunch called from DIR
 39093                                  parse_last:
 39094 00008C48 0000                    	dw 0			;AN018; used to hold parsing position
 39095                                  system_cpage:
 39096 00008C4A 0000                    	dw 0			;AC001; used for CHCP variable
 39097                                  Arg_Buf:
 39098 00008C4C 00<rep 80h>             	times 128 db 0	
 39099                                  File_Size_Low:
 39100 00008CCC 0000                    	dw 0	
 39101                                  File_Size_High:
 39102 00008CCE 0000                    	dw 0		
 39103                                  string_ptr_2:
 39104 00008CD0 0000                    	dw 0	
 39105                                  Copy_num:
 39106 00008CD2 0000                    	dw 0
 39107                                  cpyflag:
 39108 00008CD4 00                      	db 0
 39109                                  Dir_Num:
 39110 00008CD5 0000                    	dw 0
 39111                                  Bytes_Free:
 39112 00008CD7 00000000                	dd 0
 39113                                  
 39114                                  Major_Ver_Num:
 39115 00008CDB 0000                    	dw 0
 39116                                  Minor_Ver_Num:
 39117 00008CDD 0000                    	dw 0
 39118                                  
 39119                                  One_Char_Val:
 39120 00008CDF 00                      	db 0
 39121 00008CE0 00                      	db 0
 39122                                  vol_drv:
 39123 00008CE1 00                      	db 0
 39124                                  ROM_CALL:
 39125 00008CE2 00                      	db 0			; flag for rom function
 39126 00008CE3 0000                    ROM_IP:	dw 0
 39127 00008CE5 0000                    ROM_CS:	dw 0
 39128                                  
 39129                                  DestVars:
 39130                                  DestIsDir:
 39131 00008CE7 00                      	db 0
 39132                                  DestSiz:
 39133 00008CE8 00                      	db 0
 39134                                  DestTail:
 39135 00008CE9 0000                    	dw 0
 39136                                  DestInfo:
 39137 00008CEB 00                      	db 0
 39138                                  DestBuf:
 39139 00008CEC 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39140                                  EndDestBuf:
 39141                                  DESTHAND:
 39142 00008D43 0000                    	dw 0
 39143                                  DESTISDEV:
 39144 00008D45 00                      	db 0
 39145                                  FIRSTDEST:
 39146 00008D46 00                      	db 0
 39147                                  MELCOPY:
 39148 00008D47 00                      	db 0
 39149                                  MELSTART:
 39150 00008D48 0000                    	dw 0
 39151                                  SrcVars:
 39152                                  SrcIsDir:
 39153 00008D4A 00                      	db 0
 39154 00008D4B 00                      SrcSiz:	db 0
 39155                                  SrcTail:
 39156 00008D4C 0000                    	dw 0
 39157                                  SrcInfo:
 39158 00008D4E 00                      	db 0
 39159                                  SrcBuf:
 39160 00008D4F 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39161                                  SRCHAND:
 39162 00008DA6 0000                    	dw 0
 39163                                  SRCISDEV:
 39164 00008DA8 00                      	db 0
 39165                                  ScanBuf:
 39166 00008DA9 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39167                                  
 39168 00008E00 0000                    SRCPT:	dw 0
 39169                                  INEXACT:
 39170 00008E02 00                      	db 0
 39171                                  NOWRITE:
 39172 00008E03 00                      	db 0
 39173                                  BINARY:
 39174 00008E04 00                      	db 0
 39175                                  WRITTEN:
 39176 00008E05 0000                    	dw 0
 39177                                  TERMREAD:
 39178 00008E07 00                      	db 0
 39179 00008E08 00                      ASCII:	db 0
 39180 00008E09 00                      PLUS:	db 0
 39181 00008E0A 00                      objcnt:	db 0			; Used in copy
 39182 00008E0B 0000                    CPDATE:	dw 0
 39183 00008E0D 0000                    CPTIME:	dw 0
 39184                                  
 39185                                  OFilePtr_Lo:
 39186 00008E0F 0000                    	dw 0			; original file ptr for COPY when
 39187                                  OFilePtr_Hi:
 39188 00008E11 0000                    	dw 0			; 1st source is also destination
 39189 00008E13 00                      OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 39190                                  BATHAND:
 39191 00008E14 0000                    	dw 0			; Batch handle
 39192                                  STARTEL:
 39193 00008E16 0000                    	dw 0
 39194 00008E18 00                      ELCNT:	db 0
 39195 00008E19 00                      ELPOS:	db 0
 39196                                  
 39197                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 39198                                  ; MSDOS 5.0
 39199                                  SKPDEL:
 39200 00008E1A 00<rep Bh>              SOURCE:	times 11 db 0
 39201                                  
 39202                                  ext_entered:
 39203 00008E25 00                      	db 0			;AN005;
 39204                                  
 39205                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh
 39206                                  
 39207                                  Display_Ioctl:
 39208 00008E26 00                      	db 0			;AN000; info level
 39209 00008E27 00                      	db 0			;AN000; reserved
 39210 00008E28 0E00                    	dw crt_ioctl_ln		;AN000; length of data
 39211 00008E2A 0000                    	dw 0			;AN000; control flags
 39212                                  display_mode:
 39213 00008E2C 00                      	db 0			;AN000; display mode, colors
 39214 00008E2D 00                      	db 0			;AN000; reserved
 39215 00008E2E 0000                    	dw 0			;AN023; colors
 39216 00008E30 0000                    	dw 0			;AN000; display width (PELS)
 39217 00008E32 0000                    	dw 0			;AN000; display length (PELS)
 39218                                  display_width:
 39219 00008E34 0000                    	dw 0			;AN000; display width
 39220                                  LinPerPag:
 39221 00008E36 1900                    	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)
 39222                                  
 39223                                  vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
 39224 00008E38 0000                    	dw 0			;AN000; info level
 39225                                  vol_serial:
 39226 00008E3A 00000000                	dd 0			;AN000; volume serial number
 39227                                  vol_label:
 39228 00008E3E 20<rep Bh>              	times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39229 00008E49 20<rep 8h>              	times 8  db 20h ; " "	;AN000; file system type
 39230                                  
 39231                                  expand_star:
 39232 00008E51 00                      	db 0
 39233                                  
 39234                                  msg_flag:
 39235 00008E52 00                      	db 0			;AN022; flag set if non-utility message issued
 39236                                  Msg_Numb:
 39237 00008E53 0000                    	dw 0			;AN022; set with extended error message issued
 39238                                  append_exec:
 39239 00008E55 00                      	db 0			;AN041; set if internal append executed
 39240                                  print_err_flag:
 39241 00008E56 0000                    	dw 0			;AN000; flag set if error during sysdispmsg
 39242                                  subst_buffer:
 39243 00008E58 00<rep 16h>             	times parm_block_size*2 db 0 ; times 22 db 0 
 39244                                  				;AN061;
 39245                                  ; 15/04/2023
 39246 00008E6E 00                      KPARSE:	db 0	; 3/3/KK	
 39247                                  
 39248                                  ; Data declarations taken out of parse.asm
 39249                                  
 39250                                  ; MSDOS 6.0
 39251                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39252                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39253                                  ;tpbuf		db	128 DUP (?)	; temporary buffer
 39254                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39255                                  ;comptr		dw	?		; ptr into combuf
 39256                                  
 39257                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
 39258                                  ARG:
 39259                                  ARG_ARGV:
 39260                                  ARGV0_ARGPOINTER:
 39261 00008E6F 0000                    	dw 0	; ARGV[0]
 39262                                  ARGV0_ARG_FLAGS:
 39263 00008E71 00                      	db 0
 39264                                  ARGV0_ARGSTARTEL:
 39265 00008E72 0000                    	dw 0
 39266                                  ARGV0_ARGLEN:
 39267 00008E74 0000                    	dw 0
 39268                                  ARGV0_ARGSW_WORD:
 39269 00008E76 0000                    	dw 0
 39270                                  ARGV0_OCOMPTR:
 39271 00008E78 0000                    	dw 0
 39272                                  ARGV1_ARGPOINTER:
 39273 00008E7A 0000                    	dw 0	; ARGV[1]	
 39274 00008E7C 00<rep 5h>              	times 5 db 0
 39275                                  ARGV1_ARGSW_WORD:
 39276 00008E81 0000                    	dw 0
 39277 00008E83 0000                    	dw 0
 39278                                  ARGV2_ARGPOINTER:
 39279 00008E85 0000                    	dw 0	; ARGV[2]
 39280 00008E87 00<rep 5h>              	times 5 db 0
 39281                                  ARGV2_ARGSW_WORD:
 39282 00008E8C 0000                    	dw 0
 39283 00008E8E 0000                    	dw 0
 39284 00008E90 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 39285                                  ARG_ARGVCNT:
 39286 0000912F 0000                    	dw 0
 39287                                  ARG_ARGSWINFO:
 39288 00009131 0000                    	dw 0
 39289                                  ARG_ARGBUF:
 39290 00009133 0000<rep 100h>          	times 256 dw 0	; times ARGBLEN dw 0 
 39291                                  ARG_ARGFORCOMBUF:
 39292 00009333 00<rep 80h>             	times 128 db 0  ; times COMBUFLEN db 0 
 39293                                  
 39294                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
 39295                                  ARGBUF_PTR:
 39296 000093B3 0000                    	dw 0			; index for argv[].argpointer
 39297 000093B5 00<rep 80h>             TPBUF:	times 128 db 0		; temporary buffer
 39298                                  LASTARG:
 39299 00009435 0000                    	dw 0			; point at which to accumulate switch info
 39300 00009437 0000                    COMPTR:	dw 0			; ptr into combuf
 39301                                  
 39302                                  ; Data declarations taken out of path.asm
 39303                                  ;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
 39304                                  ;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
 39305                                  ;psep_char	DB	?		; '/' or '\'
 39306                                  ;search_best	DB	(?)		; best code, best filename so far
 39307                                  ;fname_max_len	equ	13
 39308                                  ;search_best_buf DB	fname_max_len DUP (?)
 39309                                  ;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
 39310                                  ;search_error	DW	(?)		; address of error message to be printed
 39311                                  
 39312                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39313                                  
 39314                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh
 39315                                  
 39316 00009439 00<rep 2Bh>             FBUF:	times FINDBUFLEN db 0	; times 43 db 0
 39317                                  FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
 39318                                  pathinfo:
 39319                                  ;pathinfo_0:
 39320 00009464 0000                    	dw 0
 39321                                  ;pathinfo_2:
 39322 00009466 0000                    	dw 0
 39323                                  ;pathinfo_4:
 39324 00009468 0000                    	dw 0
 39325                                  psep_char:
 39326 0000946A 00                      	db 0
 39327                                  search_best:
 39328 0000946B 00                      	db 0
 39329                                  FNAME_MAX_LEN equ 13
 39330                                  search_best_buf:
 39331 0000946C 00<rep Dh>              	times FNAME_MAX_LEN db 0 ; times 13 db 0
 39332                                  search_curdir_buf:
 39333 00009479 00<rep 40h>             	times 64 db 0
 39334                                  search_error:
 39335 000094B9 0000                    	dw 0
 39336                                  
 39337                                  ; Data declarations taken out of tbatch.asm
 39338                                  
 39339                                  ;if_not_count	DW	?
 39340                                  ;
 39341                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39342                                  ;
 39343                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39344                                  
 39345                                  ; 31/03/2023
 39346                                  ;STACK:	;LABEL	WORD
 39347                                  
 39348                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h
 39349                                  
 39350                                  IF_NOT_COUNT:
 39351 000094BB 0000                    	dw 0
 39352 000094BD 00                      zflag:	db 0
 39353 000094BE 00<rep 100h>            	times 256 db 0 
 39354                                  	; 16/04/2023
 39355                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
 39356                                  STACK:
 39357                                  
 39358                                  ;INTERNATVARS	internat_block <>
 39359                                  ;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39360                                  
 39361                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
 39362                                  INTERNATVARS:
 39363                                  		; (24+8 = 32 bytes)
 39364                                  DATE_TIME_FORMAT:
 39365 000095BE 0000                    	dw 0			; 0-USA, 1-EUR, 2-JAP
 39366                                  CURRENCY_SYM:
 39367 000095C0 0000000000              	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 39368                                  THOUS_SEP:
 39369 000095C5 0000                    	db 0,0			; Thousands separator 2 bytes
 39370                                  DECIMAL_SEP:
 39371 000095C7 0000                    	db 0,0			; Decimal separator 2 bytes
 39372                                  DATE_SEP:
 39373 000095C9 0000                    	db 0,0			; Date separator 2 bytes
 39374                                  TIME_SEP:
 39375 000095CB 0000                    	db 0,0			; Time separator 2 bytes	
 39376                                  BIT_FIELD:
 39377 000095CD 00                      	db 0			; Bit values
 39378                                  				;   Bit 0 = 0 if currency symbol first
 39379                                  				;	  = 1 if currency symbol last
 39380                                  				;   Bit 1 = 0 if No space after currency symbol
 39381                                  				;	  = 1 if space after currency symbol
 39382                                  CURRENCY_CENTS:
 39383 000095CE 00                      	db 0			; Number of places after currency dec point
 39384                                  TIME_24:
 39385 000095CF 00                      	db 0			; 1 if 24 hour time, 0 if 12 hour time
 39386                                  MAP_CALL:
 39387 000095D0 00000000                	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 39388                                  				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 39389                                  				;  in pieces.
 39390                                  DATA_SEP:
 39391 000095D4 0000                    	db 0,0			; Data list separator character		
 39392                                  
 39393 000095D6 00<rep 8h>              	times 8 db 0
 39394                                  
 39395                                  ; Max size of the block returned by the INTERNATIONAL call
 39396                                  
 39397                                  INTERNAT_BLOCK_SIZE EQU	32
 39398                                  
 39399                                  ;;	Buffer for DOS function 64h (Get extended country information)
 39400                                  ;;	subfunctions 2, 4, 6, or 7:
 39401                                  ;
 39402                                  ;CountryPtrInfo	label	byte
 39403                                  ;CountryPtrId	db	?
 39404                                  ;CountryPtr	dd	?
 39405                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 39406                                  	
 39407                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
 39408                                  CountryPtrInfo:
 39409                                  CountryPtrId:	
 39410 000095DE 00                      	db 0
 39411                                  CountryPtr:
 39412 000095DF 00000000                	dd 0
 39413                                  
 39414                                  OldCtrlCHandler:
 39415 000095E3 00000000                	dd 0			; previous int 23 vector		
 39416                                  
 39417                                  BATLEN equ 32
 39418                                  
 39419                                  BATBUFPOS:
 39420 000095E7 0000                    	dw 0			; integer position in buffer of next byte
 39421                                  
 39422 000095E9 00<rep 20h>             BATBUF:	times BATLEN db 0 ; times 32 db 0
 39423                                  BATBUFEND:
 39424 00009609 0000                    	dw 0
 39425                                  TypeFilSiz:
 39426 0000960B 00000000                	dd 0			; stores size of file to be typed
 39427                                  
 39428                                  ; *****************************************************
 39429                                  ; EMG 4.00
 39430                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 39431                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 39432                                  ; *****************************************************
 39433                                  ;
 39434                                  ; COMMON PARSE OUTPUT BLOCKS
 39435                                  
 39436                                  ; Common output blocks for PARSE number, complex, or string values.
 39437                                  
 39438                                  PARSE1_OUTPUT:
 39439                                  PARSE1_TYPE:
 39440 0000960F 00                      	db 0			;AN000;  type
 39441                                  PARSE1_CODE:
 39442 00009610 00                      	db 0			;AN000;  return value
 39443                                  PARSE1_SYN:
 39444 00009611 0000                    	dw 0			;AN000;  es offset of synonym
 39445                                  PARSE1_ADDR:
 39446 00009613 00000000                	dd 0			;AN000;  numeric value / address
 39447                                  				;	 of string value
 39448                                  
 39449                                  ;  Common output block for PARSE date strings.
 39450                                  
 39451                                  DATE_OUTPUT:
 39452                                  DATE_TYPE:
 39453 00009617 00                      	db 0			;AN000;  type
 39454 00009618 00                      	db 0			;AN000;  return value
 39455 00009619 0000                    	dw 0			;AN000;  es offset of synonym
 39456                                  DATE_YEAR:
 39457 0000961B 0000                    	dw 0			;AN000;  year
 39458                                  DATE_MONTH:
 39459 0000961D 00                      	db 0			;AN000;  month
 39460                                  DATE_DAY:
 39461 0000961E 00                      	db 0			;AN000;  day
 39462                                  
 39463                                  ;  Common output block for PARSE time strings.
 39464                                  
 39465                                  TIME_OUTPUT:
 39466                                  TIME_TYPE:
 39467 0000961F 00                      	db 0			;AN000;  type
 39468 00009620 00                      	db 0			;AN000;  return value
 39469 00009621 0000                    	dw 0			;AN000;  es offset of synonym
 39470                                  TIME_HOUR:
 39471 00009623 00                      	db 0			;AN000;  hour
 39472                                  TIME_MINUTES:
 39473 00009624 00                      	db 0			;AN000;  minutes
 39474                                  TIME_SECONDS:
 39475 00009625 00                      	db 0			;AN000;  seconds
 39476                                  TIME_FRACTION:
 39477 00009626 00                      	db 0			;AN000;  hundredths
 39478                                  
 39479                                  ;  Common output block for PARSE drive specifier (one based drive number).
 39480                                  
 39481                                  DRIVE_OUTPUT:
 39482                                  DRIVE_TYPE:
 39483 00009627 00                      	db 0			;AN000;  type
 39484                                  DRIVE_VALUE:
 39485 00009628 00                      	db 0			;AN000;  return value
 39486 00009629 0000                    	dw 0			;AN000;  es offset of synonym
 39487                                  DRIVE_NUMBER:
 39488 0000962B 00                      	db 0			;AN000;  drive number
 39489 0000962C 000000                  	db 0,0,0		;AN000;  reserved
 39490                                  
 39491                                  	; 18/04/2023
 39492                                  	; 16/04/2023
 39493                                  ;TRANSPACEEND: ; 98C5h ; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion
 39494                                  
 39495                                  ; ----------------------------------------------------------------------------
 39496                                  ; 20/04/2023
 39497                                  TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
