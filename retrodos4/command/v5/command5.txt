     1                                  ; ****************************************************************************
     2                                  ; COMMAND.COM (MSDOS 5.0 Command Interpreter) - RETRO DOS v4.0 by ERDOGAN TAN
     3                                  ; ----------------------------------------------------------------------------
     4                                  ; Last Update: 12/06/2023 (v5.0) ((Previous: 20/10/2018 COMMAND.COM v3.3))
     5                                  ; ----------------------------------------------------------------------------
     6                                  ; Beginning: 21/04/2018 (COMMAND.COM v2.11) - 11/09/2018 (COMMAND.COM v3.30)
     7                                  ; ----------------------------------------------------------------------------
     8                                  ; Assembler: NASM version 2.15 (2.11)
     9                                  ; ----------------------------------------------------------------------------
    10                                  ;	    ((nasm command5.s -l command5.lst -o COMMAND.COM)) 	
    11                                  ; ----------------------------------------------------------------------------
    12                                  ; Derived from 'COMMAND.ASM' file of MSDOS 2.11 (IBM PCDOS v2.11) source code
    13                                  ; by Microsoft, 18/08/1983
    14                                  ; ****************************************************************************
    15                                  ; Modified from 'COMMAND3.S' (MSDOS 3.3 COMMAND.COM) source code
    16                                  ; in NASM syntax (by Erdogan Tan), 20/10/2018
    17                                  ; ----------------------------------------------------------------------------
    18                                  ;; 11/09/2018 - Erdogan Tan
    19                                  ; (Note: I haven't got MSDOS 3.3 COMMAND.COM src files; so, I need to continue
    20                                  ; by using disassembled COMMAND.COM -v3.30- and MSDOS 6.0 OS source files.)
    21                                  ; ----------------------------------------------------------------------------
    22                                  ; MSDOS 6.0 source files:
    23                                  ;;============================================================================
    24                                  ; This MSDOS source code is verified & modified by using IDA Pro Disassembler
    25                                  ; (MSDOS 3.30 COMMAND.COM) output in TASM syntax (11/09/2018..29/09/2018)
    26                                  ;;============================================================================
    27                                  ;
    28                                  ; COMMAND.COM v6.0 source files:
    29                                  ;      command1.asm, command2.asm, rucode.asm, stub.asm, rdata.asm, init.asm,
    30                                  ;      iparse.asm, uinit.asm, tcode.asm, tbatch.asm, tbatch2.asm, tfor.asm,
    31                                  ;      dir.asm, cratio.asm, tcmd1b.asm, tcmd2a.asm, tcmd2b.asm, tenv.asm,
    32                                  ;      tenv2.asm, tmisc1.asm, tmisc2.asm, tpipe.asm, parse2.asm, path1.asm,
    33                                  ;      path2.asm, tucode.asm, copy.asm, copypr1.asm, copypr2.asm, cparse.asm,
    34                                  ;      tparse.asm, tprintf.asm, loadhi.asm, tdata.asm, tspc.asm
    35                                  ;
    36                                  ; COMMAND.COM v2.11 source files:
    37                                  ;      COMMAND.ASM (+ DOSYM.ASM,DEVSYM.ASM,COMSW.ASM,COMEQU.ASM,IFEQU.ASM)
    38                                  ;      RUCODE.ASM, RDATA.ASM, INIT.ASM, UINIT.ASM
    39                                  ;      TCODE.ASM, TCODE2.ASM, TCODE3.ASM, TCODE4.ASM, TCODE5.ASM,
    40                                  ;      TUCODE.ASM, COPY.ASM, COPYPROC.ASM, CPARSE.ASM, TDATA.ASM, TSPC.ASM
    41                                  ;
    42                                  ; ----------------------------------------------------------------------------
    43                                  ; 09/01/2023 - COMMAND.COM v5.0 (Multi Section Binary File Format)
    44                                  
    45                                  ;============================================================================
    46                                  ; SYSCALL.INC, MSDOS 6.0, 1991
    47                                  ;============================================================================
    48                                  ; 21/09/2018 - Retro DOS v3.0
    49                                  
    50                                  ;	SCCSID = @(#)syscall.asm	1.1 85/04/10
    51                                  ;BREAK <system call definitions>
    52                                  
    53                                  ;
    54                                  ;	Microsoft Confidential
    55                                  ;	Copyright (C) Microsoft Corporation 1991
    56                                  ;	All Rights Reserved.
    57                                  ;
    58                                  
    59                                  ;SUBTTL	system call definitions
    60                                  ;PAGE
    61                                  
    62                                  Abort				EQU 0	;  0	  0
    63                                  STD_CON_INPUT			EQU 1	;  1	  1
    64                                  Std_Con_Output			EQU 2	;  2	  2
    65                                  Std_Aux_Input			EQU 3	;  3	  3
    66                                  Std_Aux_Output			EQU 4	;  4	  4
    67                                  Std_Printer_Output		EQU 5	;  5	  5
    68                                  Raw_Con_IO			EQU 6	;  6	  6
    69                                  RAW_CON_INPUT			EQU 7	;  7	  7
    70                                  Std_Con_Input_No_Echo		EQU 8	;  8	  8
    71                                  STD_CON_STRING_OUTPUT		EQU 9	;  9	  9
    72                                  Std_Con_String_Input		EQU 10	; 10	  A
    73                                  Std_Con_Input_Status		EQU 11	; 11	  B
    74                                  STD_CON_INPUT_FLUSH		EQU 12	; 12	  C
    75                                  DISK_RESET			EQU 13	; 13	  D
    76                                  Set_Default_Drive		EQU 14	; 14	  E
    77                                  FCB_Open			EQU 15	; 15	  F
    78                                  FCB_Close			EQU 16	; 16	 10
    79                                  Dir_Search_First		EQU 17	; 17	 11
    80                                  Dir_Search_Next 		EQU 18	; 18	 12
    81                                  FCB_Delete			EQU 19	; 19	 13
    82                                  FCB_Seq_Read			EQU 20	; 20	 14
    83                                  FCB_Seq_Write			EQU 21	; 21	 15
    84                                  FCB_Create			EQU 22	; 22	 16
    85                                  FCB_Rename			EQU 23	; 23	 17
    86                                  GET_DEFAULT_DRIVE		EQU 25	; 25	 19
    87                                  Set_DMA 			EQU 26	; 26	 1A
    88                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    89                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    90                                  ;									   ;
    91                                  Get_Default_DPB 		EQU 31	; 31	 1F
    92                                  ;									   ;
    93                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
    94                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
    95                                  FCB_Random_Read 		EQU 33	; 33	 21
    96                                  FCB_Random_Write		EQU 34	; 34	 22
    97                                  Get_FCB_File_Length		EQU 35	; 35	 23
    98                                  Get_FCB_Position		EQU 36	; 36	 24
    99                                  SET_INTERRUPT_VECTOR		EQU 37	; 37	 25
   100                                  Create_Process_Data_Block	EQU 38	; 38	 26
   101                                  FCB_Random_Read_Block		EQU 39	; 39	 27
   102                                  FCB_Random_Write_Block		EQU 40	; 40	 28
   103                                  Parse_File_Descriptor		EQU 41	; 41	 29
   104                                  Get_Date			EQU 42	; 42	 2A
   105                                  Set_Date			EQU 43	; 43	 2B
   106                                  Get_Time			EQU 44	; 44	 2C
   107                                  Set_Time			EQU 45	; 45	 2D
   108                                  SET_VERIFY_ON_WRITE		EQU 46	; 46	 2E
   109                                  ; Extended functionality group
   110                                  Get_DMA 			EQU 47	; 47	 2F
   111                                  GET_VERSION			EQU 48	; 48	 30
   112                                  Keep_Process			EQU 49	; 49	 31
   113                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   114                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   115                                  ;									   ;
   116                                  Get_DPB 			EQU 50	; 50	 32
   117                                  ;									   ;
   118                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   119                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   120                                  Set_CTRL_C_Trapping		EQU 51	; 51	 33
   121                                  Get_InDOS_Flag			EQU 52	; 52	 34
   122                                  Get_Interrupt_Vector		EQU 53	; 53	 35
   123                                  Get_Drive_Freespace		EQU 54	; 54	 36
   124                                  CHAR_OPER			EQU 55	; 55	 37
   125                                  International			EQU 56	; 56	 38
   126                                  ;   Directory Group
   127                                  MKDir				EQU 57	; 57	 39
   128                                  RMDir				EQU 58	; 58	 3A
   129                                  CHDir				EQU 59	; 59	 3B
   130                                  ;   File Group
   131                                  Creat				EQU 60	; 60	 3C
   132                                  OPEN				EQU 61	; 61	 3D
   133                                  CLOSE				EQU 62	; 62	 3E
   134                                  READ				EQU 63	; 63	 3F
   135                                  Write				EQU 64	; 64	 40
   136                                  Unlink				EQU 65	; 65	 41
   137                                  LSEEK				EQU 66	; 66	 42
   138                                  CHMod				EQU 67	; 67	 43
   139                                  IOCTL				EQU 68	; 68	 44
   140                                  XDUP				EQU 69	; 69	 45
   141                                  XDup2				EQU 70	; 70	 46
   142                                  Current_Dir			EQU 71	; 71	 47
   143                                  ;    Memory Group
   144                                  ALLOC				EQU 72	; 72	 48
   145                                  DEALLOC				EQU 73	; 73	 49
   146                                  SETBLOCK			EQU 74	; 74	 4A
   147                                  ;    Process Group
   148                                  Exec				EQU 75	; 75	 4B
   149                                  EXIT				EQU 76	; 76	 4C
   150                                  WAITPROCESS			EQU 77	; 77	 4D
   151                                  Find_First			EQU 78	; 78	 4E
   152                                  ;   Special Group
   153                                  Find_Next			EQU 79	; 79	 4F
   154                                  ; SPECIAL SYSTEM GROUP
   155                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   156                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   157                                  ;									   ;
   158                                  SET_CURRENT_PDB 		EQU 80	; 80	 50
   159                                  GET_CURRENT_PDB 		EQU 81	; 81	 51
   160                                  Get_In_Vars			EQU 82	; 82	 52
   161                                  SetDPB				EQU 83	; 83	 53
   162                                  ;									   ;
   163                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   164                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   165                                  Get_Verify_On_Write		EQU 84	; 84	 54
   166                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   167                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   168                                  ;									   ;
   169                                  Dup_PDB 			EQU 85	; 85	 55
   170                                  ;									   ;
   171                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   172                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   173                                  Rename				EQU 86	; 86	 56
   174                                  File_Times			EQU 87	; 87	 57
   175                                  AllocOper			EQU 88	; 88	 58
   176                                  ; Network extention system calls
   177                                  GetExtendedError		EQU 89	; 89	 59
   178                                  CreateTempFile			EQU 90	; 90	 5A
   179                                  CreateNewFile			EQU 91	; 91	 5B
   180                                  LockOper			EQU 92	; 92	 5C Lock and Unlock
   181                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   182                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   183                                  ;									   ;
   184                                  ServerCall			EQU 93	; 93	 5D CommitAll, ServerDOSCall,
   185                                  					;	    CloseByName, CloseUser,
   186                                  					;	    CloseUserProcess,
   187                                  					;	    GetOpenFileList
   188                                  ;									   ;
   189                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   190                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   191                                  UserOper			EQU 94	; 94	 5E Get and Set
   192                                  AssignOper			EQU 95	; 95	 5F On, Off, Get, Set, Cancel
   193                                  xNameTrans			EQU 96	; 96	 60
   194                                  PathParse			EQU 97	; 97	 61
   195                                  GetCurrentPSP			EQU 98	; 98	 62
   196                                  Hongeul 			EQU 99	; 99	 63
   197                                  ECS_CALL			EQU 99	; 99	 63  ;; DBCS support
   198                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   199                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   200                                  ;									   ;
   201                                  Set_Printer_Flag		EQU 100 ; 100	 64
   202                                  ;									   ;
   203                                  ;	     C	A  V  E  A  T	  P  R	O  G  R  A  M  M  E  R		   ;
   204                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   205                                  GetExtCntry			EQU 101 ; 101	 65
   206                                  GetSetCdPg			EQU 102 ; 102	 66
   207                                  ExtHandle			EQU 103 ; 103	 67
   208                                  Commit				EQU 104 ; 104	 68
   209                                  GetSetMediaID			EQU 105 ; 105	 69
   210                                  IFS_IOCTL			EQU 107 ; 107	 6B
   211                                  ExtOpen 			EQU 108 ; 108	 6C
   212                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   213                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   214                                  ;                                                                          ;
   215                                  ;ifdef ROMEXEC
   216                                  ;ROM_FIND_FIRST			EQU 109 ; 109    6D
   217                                  ;ROM_FIND_NEXT			EQU 110 ; 110    6E
   218                                  ;ROM_EXCLUDE			EQU 111 ; 111	 6F		; M035
   219                                  ;endif
   220                                  ;                                                                          ;
   221                                  ;            C  A  V  E  A  T     P  R  O  G  R  A  M  M  E  R             ;
   222                                  ;----+----+----+----+----+----+----+----+----+----+----+----+----+----+----;
   223                                  ;
   224                                  ;
   225                                  Set_Oem_Handler 		EQU 248 ; 248	 F8
   226                                  OEM_C1				EQU 249 ; 249	 F9
   227                                  OEM_C2				EQU 250 ; 250	 FA
   228                                  OEM_C3				EQU 251 ; 251	 FB
   229                                  OEM_C4				EQU 252 ; 252	 FC
   230                                  OEM_C5				EQU 253 ; 253	 FD
   231                                  OEM_C6				EQU 254 ; 254	 FE
   232                                  OEM_C7				EQU 255 ; 255	 FF
   233                                  
   234                                  ;============================================================================
   235                                  ; DOSSYM.INC, MSDOS 6.0, 1991
   236                                  ;============================================================================
   237                                  ; 21/09/2018 - Retro DOS v3.0
   238                                  
   239                                  ;BREAK <Control character definitions>
   240                                  
   241                                  c_DEL	    EQU     7Fh 	;    ASCII rubout or delete previous char
   242                                  c_BS	    EQU     08h 	; ^H ASCII backspace
   243                                  c_CR	    EQU     0Dh 	; ^M ASCII carriage return
   244                                  c_LF	    EQU     0Ah 	; ^J ASCII linefeed
   245                                  c_ETB	    EQU     17h 	; ^W ASCII end of transmission
   246                                  c_NAK	    EQU     15h 	; ^U ASCII negative acknowledge
   247                                  c_ETX	    EQU     03h 	; ^C ASCII end of text
   248                                  c_HT	    EQU     09h 	; ^I ASCII tab
   249                                  
   250                                  ;============================================================================
   251                                  ; DIRENT.INC, MSDOS 6.0, 1991
   252                                  ;============================================================================
   253                                  ; 21/09/2018 - Retro DOS v3.0
   254                                  
   255                                  ;Break <Directory entry>
   256                                  
   257                                  ;	NOTE:  These offsets are also used in the DTA for
   258                                  ;	extended FCB SearchFirst/Next. DIR_NAME lines up
   259                                  ;	with the FCB filename field, and the rest of the
   260                                  ;	DIR_ENTRY fields follow. -DavidOls
   261                                  
   262                                  ;**	DIRENT.INC - FAT Directory Entry Definition
   263                                  ;
   264                                  ;	+---------------------------+
   265                                  ;	|  (12 BYTE) filename/ext   |	    0	    0
   266                                  ;	+---------------------------+
   267                                  ;	|     (BYTE) attributes     |	    11	    B
   268                                  ;	+---------------------------+
   269                                  ;	|    (10 BYTE) reserved     |	    12	    C
   270                                  ;	+---------------------------+
   271                                  ;	| (WORD) time of last write |	    22	    16
   272                                  ;	+---------------------------+
   273                                  ;	| (WORD) date of last write |	    24	    18
   274                                  ;	+---------------------------+
   275                                  ;	|   (WORD) First cluster    |	    26	    1A
   276                                  ;	+---------------------------+
   277                                  ;	|     (DWORD) file size     |	    28	    1C
   278                                  ;	+---------------------------+
   279                                  ;
   280                                  ;   First byte of filename  = E5 -> free directory entry
   281                                  ;			    = 00 -> end of allocated directory
   282                                  ;   Time:   Bits 0-4=seconds/2, bits 5-10=minute, 11-15=hour
   283                                  ;   Date:   Bits 0-4=day, bits 5-8=month, bits 9-15=year-1980
   284                                  ;
   285                                  
   286                                  STRUC DIR_ENTRY
   287 00000000 <res Bh>                .DIR_NAME:	RESB  11	; file name
   288 0000000B ??                      .DIR_ATTR:	RESB  1		; attribute bits
   289 0000000C ????                    .DIR_CODEPG:	RESW  1		; code page DOS 4.00
   290 0000000E ????                    .DIR_EXTCLUSTER: RESW 1		; extended attribute starting cluster
   291 00000010 ??                      .DIR_ATTR2:	RESB  1		; reserved
   292 00000011 ??????????              .DIR_PAD:	RESB  5		; reserved for expansion
   293 00000016 ????                    .DIR_TIME:	RESW  1		; time of last write
   294 00000018 ????                    .DIR_DATE:	RESW  1		; date of last write
   295 0000001A ????                    .DIR_FIRST:	RESW  1		; first allocation unit of file
   296 0000001C ????                    .DIR_SIZE_L:	RESW  1		; low 16 bits of file size
   297 0000001E ????                    .DIR_SIZE_H:	RESW  1		; high 16 bits of file size
   298                                  .size:
   299                                  
   300                                  ;	    Caution: An extended FCB SearchFirst/Next on a network
   301                                  ;	    drive under Novell Netware 286 or 386 returns the time/date
   302                                  ;	    in the SIZE fields for subdirectory files. Ordinarily,
   303                                  ;	    this field is zero for subdirectory files.
   304                                  
   305                                  ENDSTRUC
   306                                  
   307                                  ATTR_READ_ONLY	equ	 1h
   308                                  ATTR_HIDDEN	equ	 2h
   309                                  ATTR_SYSTEM	equ	 4h
   310                                  ATTR_VOLUME_ID	equ	 8h
   311                                  ATTR_DIRECTORY	equ	10h
   312                                  ATTR_ARCHIVE	equ	20h
   313                                  ATTR_DEVICE	equ	40h	; This is a VERY special bit.
   314                                  				;   NO directory entry on a disk EVER
   315                                  				;   has this bit set. It is set non-zero
   316                                  				;   when a device is found by GETPATH
   317                                  
   318                                  ATTR_ALL	equ	ATTR_HIDDEN+ATTR_SYSTEM+ATTR_DIRECTORY
   319                                  				; OR of hard attributes for FINDENTRY
   320                                  
   321                                  ATTR_IGNORE	equ	ATTR_READ_ONLY+ATTR_ARCHIVE+ATTR_DEVICE
   322                                  				; ignore this(ese) attribute(s) during
   323                                  				; search first/next
   324                                  
   325                                  ATTR_CHANGEABLE equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_SYSTEM+ATTR_ARCHIVE
   326                                  				; changeable via CHMOD
   327                                  
   328                                  DIRFREE 	equ	0E5h	; stored in dir_name[0] to indicate free slot
   329                                  
   330                                  ;============================================================================
   331                                  ; ERROR.INC, MSDOS 6.0, 1991
   332                                  ;============================================================================
   333                                  ; 21/09/2018 - Retro DOS v3.0
   334                                  
   335                                  ;**	ERROR.INC - DOS Error Codes
   336                                  ;
   337                                  ;    The newer (DOS 2.0 and above) "XENIX-style" calls
   338                                  ;    return error codes through AX.	If an error occurred then
   339                                  ;    the carry bit will be set and the error code is in AX.	If no error
   340                                  ;    occurred then the carry bit is reset and AX contains returned info.
   341                                  ;
   342                                  ;    Since the set of error codes is being extended as we extend the operating
   343                                  ;    system, we have provided a means for applications to ask the system for a
   344                                  ;    recommended course of action when they receive an error.
   345                                  ;
   346                                  ;    The GetExtendedError system call returns a universal error, an error
   347                                  ;    location and a recommended course of action.	The universal error code is
   348                                  ;    a symptom of the error REGARDLESS of the context in which GetExtendedError
   349                                  ;    is issued.
   350                                  
   351                                  
   352                                  ;	2.0 error codes
   353                                  
   354                                  error_invalid_function		EQU	1
   355                                  ERROR_FILE_NOT_FOUND		EQU	2
   356                                  ERROR_PATH_NOT_FOUND		EQU	3
   357                                  ERROR_TOO_MANY_OPEN_FILES	EQU	4
   358                                  ERROR_ACCESS_DENIED		EQU	5
   359                                  error_invalid_handle		EQU	6
   360                                  error_arena_trashed		EQU	7
   361                                  ERROR_NOT_ENOUGH_MEMORY 	EQU	8
   362                                  error_invalid_block		EQU	9
   363                                  error_bad_environment		EQU	10
   364                                  ERROR_BAD_FORMAT		EQU	11
   365                                  error_invalid_access		EQU	12
   366                                  ERROR_INVALID_DATA		EQU	13
   367                                  ;**** reserved			EQU	14	; *****
   368                                  error_invalid_drive		EQU	15
   369                                  error_current_directory 	EQU	16
   370                                  error_not_same_device		EQU	17
   371                                  ERROR_NO_MORE_FILES		EQU	18
   372                                  
   373                                  ;	These are the universal int 24 mappings for the old INT 24 set of errors
   374                                  
   375                                  ERROR_WRITE_PROTECT		EQU	19
   376                                  error_bad_unit			EQU	20
   377                                  error_not_ready 		EQU	21
   378                                  error_bad_command		EQU	22
   379                                  error_CRC			EQU	23
   380                                  error_bad_length		EQU	24
   381                                  error_Seek			EQU	25
   382                                  error_not_DOS_disk		EQU	26
   383                                  error_sector_not_found		EQU	27
   384                                  error_out_of_paper		EQU	28
   385                                  error_write_fault		EQU	29
   386                                  error_read_fault		EQU	30
   387                                  ERROR_GEN_FAILURE		EQU	31
   388                                  
   389                                  ;	the new 3.0 error codes reported through INT 24
   390                                  
   391                                  error_sharing_violation 	EQU	32
   392                                  error_lock_violation		EQU	33
   393                                  error_wrong_disk		EQU	34
   394                                  ERROR_FCB_UNAVAILABLE		EQU	35
   395                                  ERROR_SHARING_BUFFER_EXCEEDED	EQU	36
   396                                  error_Code_Page_Mismatched	EQU	37    ; DOS 4.00	;AN000;
   397                                  error_handle_EOF		EQU	38    ; DOS 4.00	;AN000;
   398                                  ERROR_HANDLE_DISK_FULL		EQU	39    ; DOS 4.00	;AN000;
   399                                  
   400                                  ;	New OEM network-related errors are 50-79
   401                                  
   402                                  error_not_supported		EQU	50
   403                                  
   404                                  error_net_access_denied		EQU	65	;M028
   405                                  
   406                                  ;	End of INT 24 reportable errors
   407                                  
   408                                  error_file_exists		EQU	80
   409                                  error_DUP_FCB			EQU	81	; *****
   410                                  error_cannot_make		EQU	82
   411                                  error_FAIL_I24			EQU	83
   412                                  
   413                                  ;	New 3.0 network related error codes
   414                                  
   415                                  error_out_of_structures 	EQU	84
   416                                  error_Already_assigned		EQU	85
   417                                  error_invalid_password		EQU	86
   418                                  error_invalid_parameter 	EQU	87
   419                                  error_NET_write_fault		EQU	88
   420                                  error_sys_comp_not_loaded	EQU	90    ; DOS 4.00	;AN000;
   421                                  
   422                                  ;============================================================================
   423                                  ; DEVSYM.INC, MSDOS 6.0, 1991
   424                                  ;============================================================================
   425                                  ; 22/09/2018 - Retro DOS v3.0
   426                                  
   427                                  ;**	DevSym.inc - Device Symbols
   428                                  
   429                                  ;	THE DEVICE TABLE LIST HAS THE FORM:
   430                                  
   431                                  STRUC SYSDEV
   432 00000000 ????????                .NEXT:	RESD 1			;POINTER TO NEXT DEVICE HEADER
   433 00000004 ????                    .ATT:	RESW 1			;ATTRIBUTES OF THE DEVICE
   434 00000006 ????                    .STRAT:	RESW 1			;STRATEGY ENTRY POINT
   435 00000008 ????                    .INT:	RESW 1			;INTERRUPT ENTRY POINT
   436 0000000A ????????????????        .NAME:	RESB 8			;NAME OF DEVICE (ONLY FIRST BYTE USED FOR BLOCK)
   437                                  .size:
   438                                  ENDSTRUC
   439                                  
   440                                  ; 24/09/2018
   441                                  DEVTYP	EQU   8000H	; BIT 15 - 1  IF CHAR, 0 IF BLOCK
   442                                  
   443                                  ;============================================================================
   444                                  ; CURDIR.INC, MSDOS 6.0, 1991
   445                                  ;============================================================================
   446                                  ; 21/09/2018 - Retro DOS v3.0
   447                                  
   448                                  DIRSTRLEN	EQU	64+3	; Max length in bytes of directory strings
   449                                  
   450                                  ;============================================================================
   451                                  ; COMEQU.ASM, MSDOS 6.0, 1991
   452                                  ;============================================================================
   453                                  ; 21/09/2018 - Retro DOS v3.0
   454                                  
   455                                  ;/*
   456                                  ; *                      Microsoft Confidential
   457                                  ; *                      Copyright (C) Microsoft Corporation 1991
   458                                  ; *                      All Rights Reserved.
   459                                  ; */
   460                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   461                                  ;	SCCSID = @(#)comequ.asm 1.1 85/05/14
   462                                  ;*************************************
   463                                  ; COMMAND EQUs which are not switch dependant
   464                                  
   465                                  ;		include	curdir.inc	; to get DIRSTRLEN
   466                                  ;		Note dossym.inc must already have been included!
   467                                  
   468                                  GET_COMMAND_STATE	equ	5500h	; check for existing COMMAND
   469                                  GET_ROMCOMMAND_STATE	equ	5501h	; check for existing ROM COMMAND
   470                                  
   471                                  SYM		EQU	">"
   472                                  
   473                                  LINESPERPAGE	EQU	25		;AC000; default lines per page
   474                                  
   475                                  NORMPERLIN	EQU	1
   476                                  WIDEPERLIN	EQU	5
   477                                  COMBUFLEN	EQU	128		; Length of commmand buffer
   478                                  BatLen		EQU	32		; buffer for batch files
   479                                  YES_ECHO	EQU	1		; echo line
   480                                  NO_ECHO 	EQU	0		; don't echo line
   481                                  No_Echo_Char	EQU	"@"             ; don't echo line if this is first char
   482                                  call_in_progress EQU	1		; indicate we're in the CALL command
   483                                  length_call	EQU	4		; length of CALL
   484                                  max_nest	EQU    10		; max # levels of batch nesting allowed
   485                                  FAIL_ALLOWED	EQU    00001000b	; critical error
   486                                  RETRY_ALLOWED	EQU    00010000b	; critical error
   487                                  IGNORE_ALLOWED	EQU    00100000b	; critical error
   488                                  nullcommand	EQU     1		; no command on command line
   489                                  END_OF_LINE	EQU    -1		;AN000; end of line return from parser
   490                                  END_OF_LINE_OUT EQU	0		;AN000; end of line for output
   491                                  END_OF_LINE_IN	EQU	0Dh		;AN000; end of line for input
   492                                  result_number	EQU	1		;AN000; number returned from parser
   493                                  result_string	EQU	3		;AN000; string returned from parser
   494                                  RESULT_FILESPEC EQU	5		;AN000; filespec returned from parser
   495                                  result_drive	EQU	6		;AN000; drive returned from parser
   496                                  result_date	EQU	7		;AN000; date returned from parser
   497                                  result_time	EQU	8		;AN000; time returned from parser
   498                                  RESULT_NO_ERROR EQU	0		;AN000; no error returned from parser
   499                                  no_cont_flag	EQU	0		;AN000; no control flags for message
   500                                  util_msg_class	EQU	-1		;AN000; message class for utility
   501                                  ext_msg_class	EQU	1		;AN000; message class for extended error
   502                                  parse_msg_class EQU	2		;AN000; message class for parse error
   503                                  crit_msg_class	EQU	3		;AN000; message class for critical error
   504                                  ext_crlf_class	EQU	081h		;AN054; message class for extended error with no CRLF
   505                                  colon_char	EQU	":"             ;AN000; colon character
   506                                  crt_ioctl_ln	EQU	14		;AN000; default length of data for display ioctl
   507                                  text_mode	EQU	1		;AN000; text mode return from ioctl
   508                                  get_generic	EQU	07Fh		;AN000; generic ioctl - get device info
   509                                  set_crit_dev	EQU	0100H		;AN000; device attribute for critical error on I/0
   510                                  mult_ansi	EQU	01Ah		;AC064; multiplex for ansi.sys
   511                                  mult_shell_get	EQU	01902h		;AC065; multiplex for Shell - get next command
   512                                  mult_shell_brk	EQU	01903h		;AN000; multiplex for Shell - ^C batch check
   513                                  shell_action	equ	0FFh		;AN000; SHELL - return for taking SHELL specific action
   514                                  bat_not_open	EQU	-1		;AN000; batch handle will be set to this if not open
   515                                  bat_open_handle EQU	19		;AN000; handle will be in this position in JFN table
   516                                  Ptr_seg_pos	equ	7		;AN000; Offset from start of message block for subst segment
   517                                  Ptr_off_pos	equ	5		;AN000; Offset from start of message block for subst offset
   518                                  %define Parm_off_pos	word [2]	;AN000; Offset from start of subst list for subst offset
   519                                  parm_block_size equ	11		;AN000; size of message subst block
   520                                  blank		equ	" "             ;AN000; blank character
   521                                  no_subst	equ	0		;AN000; no substitutions for messages
   522                                  one_subst	equ	1		;AN000; one substitution for messages
   523                                  no_handle_out	equ	-1		;AN000; use function 1 thru 12 for message retriever
   524                                  res_subst	equ	2		;AN000; offset from start of message definition to number of subst
   525                                  read_open_mode	equ   0000000000000000b ;AN024; extended open mode for read
   526                                  deny_write	equ   0000000000100000b	; deny write sharing mode ;M031
   527                                  deny_none	equ   0000000001000000b	; deny none sharing mode ;Myyy	
   528                                  read_open_flag	equ   0000000100000001b ;AN000; extended open flags for read
   529                                  write_open_mode equ   0000000000000001b ;AN024; extended open mode for read
   530                                  write_open_flag equ   0000000100000001b ;AN000; extended open flags for read
   531                                  creat_open_flag equ   0000000100010010b ;AN000; extended open flags for read
   532                                  capital_A	equ	'A'             ;AC000;
   533                                  vbar		equ	'|'             ;AC000;
   534                                  labracket	equ	'<'             ;AC000;
   535                                  rabracket	equ	'>'             ;AC000;
   536                                  dollar		equ	'$'             ;AC000;
   537                                  lparen		equ	'('             ;AC000;
   538                                  rparen		equ	')'             ;AC000;
   539                                  nullrparen	equ	29h		;AC000;
   540                                  in_word 	equ	4E49h		;AC000; 'NI'  ('IN' backwards)
   541                                  do_word 	equ	4F44h		;AC000; 'OD'  ('DO' backwards)
   542                                  star		equ	'*'             ;AC000;
   543                                  plus_chr	equ	'+'             ;AC000;
   544                                  small_a 	equ	'a'             ;AC000;
   545                                  small_z 	equ	'z'             ;AC000;
   546                                  dot_chr 	equ	'.'             ;AC000;
   547                                  tab_chr 	equ	9		;AN032;
   548                                  equal_chr	equ	'='             ;AN032;
   549                                  semicolon	equ	';'             ;AN049;
   550                                  dot_qmark	equ	2e3fh		;AC000; '.?'
   551                                  dot_colon	equ	2e3ah		;AC000; '.:'
   552                                  capital_n	equ	0		;AC000; result from Y/N call if N entered
   553                                  capital_y	equ	1		;AC000; result from Y/N call if Y entered
   554                                  AppendInstall	equ	0B700H		;AN020; append install check
   555                                  AppendDOS	equ	0B702H		;AN020; append DOS version check
   556                                  AppendGetState	equ	0B706H		;AN020; append get current state
   557                                  AppendSetState	equ	0B707H		;AN020; append set current state
   558                                  AppendTruename	equ	0B711H		;AN042; Get file's real location for Batch
   559                                  search_attr	equ	ATTR_READ_ONLY+ATTR_HIDDEN+ATTR_DIRECTORY  ;AC042;
   560                                  
   561                                  ;*************************************
   562                                  ;* PARSE ERROR MESSAGES
   563                                  ;*************************************
   564                                  
   565                                  MoreArgs_Ptr	equ	1		;AN000;"Too many parameters" message number
   566                                  LessArgs_Ptr	equ	2		;AN000;"Required parameter missing" message number
   567                                  BadSwt_Ptr	equ	3		;AN000;"Invalid switch" message number
   568                                  BadParm_Ptr	equ	10		;AN000;"Invalid parameter" message number
   569                                  
   570                                  ;*************************************
   571                                  ;* EQUATES FOR MESSAGE RETRIEVER
   572                                  ;*************************************
   573                                  
   574                                  GET_EXTENDED_MSG	EQU	0	;AN000;  get extended message address
   575                                  SET_EXTENDED_MSG	EQU	1	;AN000;  set extended message address
   576                                  GET_PARSE_MSG		EQU	2	;AN000;  get parse message address
   577                                  SET_PARSE_MSG		EQU	3	;AN000;  set parse message address
   578                                  GET_CRITICAL_MSG	EQU	4	;AN000;  get critical message address
   579                                  SET_CRITICAL_MSG	EQU	5	;AN000;  set critical message address
   580                                  MESSAGE_2F		EQU	46	;AN000;  minor code for message retriever
   581                                  
   582                                  ;*********************************
   583                                  ;* EQUATES FOR INT 10H
   584                                  ;*********************************
   585                                  
   586                                  VIDEO_IO_INT		EQU	10H	;AN000;  equate for int 10h
   587                                  SET_VIDEO_MODE		EQU	0	;AN000;  set video mode
   588                                  SET_CURSOR_POSITION	EQU	2	;AN000;  set new cursor position
   589                                  SCROLL_VIDEO_PAGE	EQU	6	;AN000;  scroll active page up
   590                                  VIDEO_ATTRIBUTE 	EQU	7	;AN000;  attribute to be used on blank line
   591                                  SET_COLOR_PALETTE	EQU	11	;AN000;  set color for video
   592                                  GET_VIDEO_STATE 	EQU	15	;AN000;  get current video state
   593                                  VIDEO_ALPHA		EQU	3	;AN000;  alpha video is 3 or below
   594                                  VIDEO_BW		EQU	7	;AN000;  mode for 80X25 black & white
   595                                  
   596                                  AltPipeChr	equ	"|"             ; alternate pipe character
   597                                  
   598                                  FCB		equ	5Ch
   599                                  
   600                                  STRUC VARSTRUC
   601 00000000 ??                      .ISDIR:		RESB	1
   602 00000001 ??                      .SIZ:		RESB	1
   603 00000002 ????                    .TTAIL:		RESW	1
   604 00000004 ??                      .INFO:		RESB	1
   605 00000005 <res 57h>               .BUF:		RESB	DIRSTRLEN + 20
   606                                  .size:
   607                                  ENDSTRUC
   608                                  ;
   609                                  ; Flags for internal command parsing
   610                                  ;
   611                                  fCheckDrive	equ	00000001b	; validate drive letter
   612                                  fSwitchAllowed	equ	00000010b	; switches allowed
   613                                  fLimitHelp	equ	00000100b	; /? must appear alone
   614                                  
   615                                  ;
   616                                  ; Test switches
   617                                  ;
   618                                  fParse		EQU	0001h		; display results of parseline
   619                                  
   620                                  ;
   621                                  ; Batch segment structure
   622                                  ;
   623                                  ;   BYTE    type of segment
   624                                  ;   BYTE    echo state of parent on entry to batch file
   625                                  ;   WORD    segment of last batch file
   626                                  ;   WORD    segment for FOR command
   627                                  ;   BYTE    FOR flag state on entry to batch file
   628                                  ;   DWORD   offset for next line
   629                                  ;   10 WORD pointers to parameters. -1 is empty parameter
   630                                  ;   ASCIZ   file name (with . and ..)
   631                                  ;   BYTES   CR-terminated parameters
   632                                  ;   BYTE    0 flag to indicate end of parameters
   633                                  ;
   634                                  
   635                                  BATCHTYPE   equ 0
   636                                  
   637                                  STRUC BATCHSEGMENT
   638 00000000 ??                      .BatType:	RESB	1		; signature
   639 00000001 ??                      .BatEchoFlag:	RESB	1		; G state of echo
   640                                  ; MSDOS 5.0 (& 6.0) - 11/01/2023
   641 00000002 ??                      .BatchEOF:	RESB	1		; records if EOF reached on file
   642 00000003 ????                    .BatLast: 	RESW	1		; G segment of last batch file
   643 00000005 ????                    .BatForPtr:	RESW	1		; G segment for FOR command
   644 00000007 ??                      .BatForFlag:	RESB	1		; G state of FOR
   645 00000008 ????????                .BatSeek:	RESD	1		; lseek position of next char
   646 0000000C <res 14h>               .BatParm:	RESW	10		; pointers to parameters
   647 00000020 ??                      .BatFile:	RESB	1		; beginning of batch file name
   648                                  .SIZE:
   649                                  ENDSTRUC
   650                                  
   651                                  ANULL		equ	0		; terminates an argv string
   652                                  ARGMAX		equ	64		; max args on a command line
   653                                  ARGBLEN 	equ	2*128		; 1char each plus term NUL
   654                                  tplen		equ	64		; max size of one argument
   655                                  arg_cnt_error	equ	1		; number of args > MAXARG
   656                                  arg_buf_ovflow	equ	2		; overflowed argbuffer
   657                                  
   658                                  STRUC ARGV_ELE				; elements in the argv array
   659 00000000 ????                    .argpointer:	RESW	1		; pointer to the argstring
   660 00000002 ??                      .argflags:	RESB	1		; cparse flags for this argstring
   661 00000003 ????                    .argstartel:	RESW	1		; the result of cparse's [STARTEL]
   662 00000005 ????                    .arglen:	RESW	1		; cparse's char count + one (for null)
   663 00000007 ????                    .argsw_word:	RESW	1		; any switches after this? what kinds?
   664 00000009 ????                    .arg_ocomptr:	RESW	1		; pointer into original command string
   665                                  .SIZE:
   666                                  ENDSTRUC
   667                                  
   668                                  STRUC ARG_UNIT
   669 00000000 <res 2C0h>              .argv:		RESB	ARGMAX * ARGV_ELE.SIZE
   670 000002C0 ????                    .argvcnt:	RESW	1		; number of arguments
   671 000002C2 ????                    .argswinfo:	RESW	1		; Switch information for entire line
   672 000002C4 <res 200h>              .argbuf:	RESW	ARGBLEN		; storage for argv strings
   673 000004C4 <res 80h>               .argforcombuf:	RESB	COMBUFLEN	; Original for loop command string
   674                                  .SIZE:
   675                                  ENDSTRUC
   676                                  
   677                                  ; Equates for initialization
   678                                  ;
   679                                  INITINIT	equ	01h		; initialization in progress
   680                                  INITSPECIAL	equ	02h		; in initialization time/date routine
   681                                  INITCTRLC	equ	04h		; already in ^C handler
   682                                  
   683                                  ;============================================================================
   684                                  ;  INTNAT.INC, MSDOS 6.0, 1991
   685                                  ;============================================================================
   686                                  ; 16/04/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 
   687                                  
   688                                  ; Current structure of the data returned by the international call
   689                                  
   690                                  struc INTERNAT_BLOCK
   691 00000000 ????                    .date_tim_format: resw 1		; 0-USA, 1-EUR, 2-JAP
   692 00000002 ??????????              .currency_sym:	resb 5			; Currency Symbol 5 bytes
   693 00000007 ????                    .thous_sep:	resb 2			; Thousands separator 2 bytes
   694 00000009 ????                    .decimal_sep:	resb 2			; Decimal separator 2 bytes
   695 0000000B ????                    .date_sep:	resb 2			; Date separator 2 bytes
   696 0000000D ????                    .time_sep:	resb 2			; Decimal separator 2 bytes
   697 0000000F ??                      .bit_field:	resb 1			; Bit values
   698                                  					;   Bit 0 = 0 if currency symbol first
   699                                  					;	  = 1 if currency symbol last
   700                                  					;   Bit 1 = 0 if No space after currency symbol
   701                                  					;	  = 1 if space after currency symbol
   702                                  .currency_cents:
   703 00000010 ??                      		resb 1			; Number of places after currency dec point
   704 00000011 ??                      .time_24:	resb 1			; 1 if 24 hour time, 0 if 12 hour time
   705 00000012 ????????                .map_call:	resw 2			; Address of case mapping call (DWORD)
   706                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
   707                                  					;  in pieces.
   708 00000016 ??                      .data_sep:	resb 1			; Data list separator character
   709 00000017 ??                      		resb 1
   710                                  endstruc
   711                                  
   712                                  ; Max size of the block returned by the INTERNATIONAL call
   713                                  
   714                                  internat_block_max equ 32
   715                                  
   716                                  ;============================================================================
   717                                  ; FIND.INC (MSDOS 3.3, 1987) - REDIRSYM.INC (MSDOS 6.0, 1991) 
   718                                  ;============================================================================
   719                                  ; 13/10/2018 - Retro DOS v3.0
   720                                  ; 16/02/2023 - Retro DOSv v4.0 (& v4.1) COMMAND.COM 
   721                                  
   722                                  ;Break	<find first/next buffer>
   723                                  
   724                                  	; MSDOS 3.3 & MSDOS 6.0
   725                                  
   726                                  struc FIND_BUF
   727 00000000 ??                      .DRIVE:	    resb 1	; drive of search
   728 00000001 <res Bh>                .NAME:	    resb 11	; formatted name
   729 0000000C ??                      .SATTR:	    resb 1	; attribute of search
   730 0000000D ????                    .LASTENT:   resw 1	; LastEnt
   731 0000000F ????                    .DIRSTART:  resw 1	; DirStart
   732 00000011 ????????                .NETID:	    resb 4	; Reserved for NET
   733 00000015 ??                      .ATTR:	    resb 1	; attribute found
   734 00000016 ????                    .TIMR:	    resw 1	; time
   735 00000018 ????                    .DATE:	    resw 1	; date
   736 0000001A ????                    .SIZE_L:    resw 1	; low(size)
   737 0000001C ????                    .SIZE_H:    resw 1	; high(size)
   738 0000001E <res Dh>                .PNAME:	    resb 13	; packed name
   739                                  .size:
   740                                  endstruc
   741                                  
   742                                  ;=============================================================================
   743                                  ; PDB.INC, MSDOS 6.0, 1991
   744                                  ;=============================================================================
   745                                  ; 24/09/2018 - Retro DOS v3.0 (08/07/2018, 'msdos3.s')
   746                                  
   747                                  ;**	Process data block (otherwise known as program header)
   748                                  
   749                                  ;	These offset are documented in the MSDOS Encyclopedia, so nothing
   750                                  ;	can be rearranged here, ever. Reserved areas are probably safe
   751                                  ;	for use.
   752                                  
   753                                  FILPERPROC	EQU     20
   754                                  
   755                                  struc PDB	; Process_data_block
   756 00000000 ????                    .EXIT_CALL:	resw 1   	; INT int_abort system terminate
   757 00000002 ????                    .BLOCK_LEN:	resw 1		; size of execution block
   758 00000004 ??                                      resb 1
   759 00000005 ??????????              .CPM_CALL:	resb 5		; ancient call to system
   760 0000000A ????????                .EXIT:		resd 1		; pointer to exit routine
   761 0000000E ????????                .CTRL_C:	resd 1		; pointer to ^C routine
   762 00000012 ????????                .FATAL_ABORT:	resd 1		; pointer to fatal error
   763 00000016 ????                    .PARENT_PID:	resw 1		; PID of parent (terminate PID)
   764 00000018 <res 14h>               .JFN_TABLE:     resb FILPERPROC ; indices into system table
   765 0000002C ????                    .ENVIRON:	resw 1		; seg addr of environment
   766 0000002E ????????                .USER_STACK:	resd 1		; stack of self during system calls
   767 00000032 ????                    .JFN_Length:	resw 1		; number of handles allowed
   768 00000034 ????????                .JFN_Pointer:	resd 1		; pointer to JFN table
   769 00000038 ????????                .Next_PDB:	resd 1		; pointer to nested PDB's
   770 0000003C ??                      .InterCon:	resb 1	; MSDOS 6.0 ; *** jh-3/28/90 *** 
   771 0000003D ??                      .Append:	resb 1	; MSDOS 6.0 ; *** Not sure if still used ***
   772 0000003E ????                    .Novell_Used:	resb 2	; MSDOS 6.0 ; Novell shell (redir) uses these
   773 00000040 ????                    .Version:	resw 1	; MSDOS 6.0 ; DOS version reported to this app
   774 00000042 <res Eh>                .PAD1:		resb 14 ; 0Eh
   775 00000050 ??????????              .CALL_SYSTEM:	resb 5		; portable method of system call
   776 00000055 ??????????????          .PAD2:		resb 7		; reserved so FCB 1 can be used as
   777                                  				;  an extended FCB
   778                                  ;endstruc 	; MSDOS 3.3
   779                                  	  	; MSDOS 6.0
   780 0000005C <res 10h>               .FCB1:		resb 16 ; 10h	; default FCB 1
   781 0000006C <res 10h>               .FCB2:		resb 16 ; 10h	; default FCB 2
   782 0000007C ????????                .PAD3:		resb 4		; not sure if this is used by PDB_FCB2
   783 00000080 <res 80h>               .TAIL:		resb 128	; command tail and default DTA
   784                                  endstruc
   785                                  
   786                                  ;=============================================================================
   787                                  ; VERSIONA.INC, MSDOS 6.0, 1991
   788                                  ;=============================================================================
   789                                  ; 24/09/2018 - Retro DOS v3.0
   790                                  
   791                                  ;major_version	equ 6		; Major DOS version
   792                                  ;minor_version	equ 0		; Minor DOS Version
   793                                  
   794                                  ;expected_version    equ     (MINOR_VERSION SHL 8)+MAJOR_VERSION
   795                                  
   796                                  ; MSDOS 3.3 COMMAND.COM
   797                                  ;MAJOR_VERSION	EQU 3
   798                                  ;MINOR_VERSION	EQU 30
   799                                  
   800                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
   801                                  MAJOR_VERSION	EQU 5		; Major DOS version
   802                                  MINOR_VERSION	EQU 0		; Minor DOS version
   803                                  
   804                                  EXPECTED_VERSION EQU (MINOR_VERSION<<8)+MAJOR_VERSION	
   805                                  
   806                                  ;-----------------------------------------------------------------------------
   807                                  ; 21/09/2018
   808                                  ;-----------------------------------------------------------------------------
   809                                  ; Retro DOS v3.0 NOTE:  
   810                                  ;	Following source code is as disassembled code of MSDOS 3.3 COMMAND.COM
   811                                  ;	with minor modifications which are done by me (Erdogan Tan).
   812                                  ;	.. but comments and descriptions are from MSDOS 6.0 COMMAND.COM
   813                                  ;	source code files (written by using MASM syntax).
   814                                  ;-----------------------------------------------------------------------------
   815                                  ; All of this Retro DOS 3.0 (2018) source code has been written by using
   816                                  ; NASM (2.11) x86 assembly language/compiler syntax.	
   817                                  ;----------------------------------------------------------------------------- 	
   818                                  
   819                                  ;=============================================================================
   820                                  ; COMMAND1.ASM, MSDOS 6.0, 1991
   821                                  ;=============================================================================
   822                                  ; 21/09/2018 - Retro DOS v3.0
   823                                  
   824                                  ;	page ,132
   825                                  ;	title	COMMAND - resident code for COMMAND.COM
   826                                  ;	name	COMMAND
   827                                  
   828                                  ;/*
   829                                  ; *                      Microsoft Confidential
   830                                  ; *                      Copyright (C) Microsoft Corporation 1991
   831                                  ; *                      All Rights Reserved.
   832                                  ; */
   833                                  
   834                                  ;*****************************************************************************
   835                                  ;
   836                                  ; MODULE:	       COMMAND.COM
   837                                  ;
   838                                  ; DESCRIPTIVE NAME:    Default DOS command interpreter
   839                                  ;
   840                                  ; FUNCTION:	       This version of COMMAND is divided into three distinct
   841                                  ;		       parts.  First is the resident portion, which includes
   842                                  ;		       handlers for interrupts	23H (Cntrl-C), 24H (fatal
   843                                  ;		       error), and 2EH (command line execute); it also has
   844                                  ;		       code to test and, if necessary, reload the transient
   845                                  ;		       portion. Following the resident is the init code, which
   846                                  ;		       is overwritten after use.  Then comes the transient
   847                                  ;		       portion, which includes all command processing (whether
   848                                  ;		       internal or external).  The transient portion loads at
   849                                  ;		       the end of physical memory, and it may be overlayed by
   850                                  ;		       programs that need as much memory as possible. When the
   851                                  ;		       resident portion of command regains control from a user
   852                                  ;		       program, a check sum is performed on the transient
   853                                  ;		       portion to see if it must be reloaded.  Thus programs
   854                                  ;		       which do not need maximum memory will save the time
   855                                  ;		       required to reload COMMAND when they terminate.
   856                                  ;
   857                                  ; ENTRY POINT:	       PROGSTART
   858                                  ;
   859                                  ; INPUT:	       command line at offset 81H
   860                                  ;
   861                                  ; EXIT_NORMAL:	       No exit from root level command processor.  Can exit
   862                                  ;		       from a secondary command processor via the EXIT
   863                                  ;		       internal command.
   864                                  ;
   865                                  ; EXIT_ERROR:	       Exit to prior command processor if possible, otherwise
   866                                  ;		       hang the system.
   867                                  ;
   868                                  ; INTERNAL REFERENCES:
   869                                  ;
   870                                  ;     ROUTINES:        See the COMMAND Subroutine Description Document
   871                                  ;		       (COMMAND.DOC)
   872                                  ;
   873                                  ;     DATA AREAS:      See the COMMAND Subroutine Description Document
   874                                  ;		       (COMMAND.DOC)
   875                                  ;
   876                                  ; EXTERNAL REFERENCES:
   877                                  ;
   878                                  ;      ROUTINES:       none
   879                                  ;
   880                                  ;      DATA AREAS:     none
   881                                  ;
   882                                  ;*****************************************************************************
   883                                  ;
   884                                  ;			      REVISION HISTORY
   885                                  ;			      ----------------
   886                                  ;
   887                                  ; DOS 1.00 to DOS 3.30
   888                                  ; --------------------------
   889                                  ; SEE REVISION LOG IN COPY.ASM ALSO
   890                                  ;
   891                                  ; REV 1.17
   892                                  ;    05/19/82  Fixed bug in BADEXE error (relocation error must return to
   893                                  ;	       resident since the EXELOAD may have overwritten the transient.
   894                                  ;
   895                                  ; REV 1.18
   896                                  ;    05/21/82  IBM version always looks on drive A
   897                                  ;	       MSVER always looks on default drive
   898                                  ;
   899                                  ; REV 1.19
   900                                  ;    06/03/82  Drive spec now entered in command line
   901                                  ;    06/07/82  Added VER command (print DOS version number) and VOL command
   902                                  ;	       (print volume label)
   903                                  ;
   904                                  ; REV 1.20
   905                                  ;    06/09/82  Prints "directory" after directories
   906                                  ;    06/13/82  MKDIR, CHDIR, PWD, RMDIR added
   907                                  ;
   908                                  ; REV 1.50
   909                                  ;	       Some code for new 2.0 DOS, sort of HACKey.  Not enough time to
   910                                  ;	       do it right.
   911                                  ;
   912                                  ; REV 1.70
   913                                  ;	       EXEC used to fork off new processes
   914                                  ;
   915                                  ; REV 1.80
   916                                  ;	       C switch for single command execution
   917                                  ;
   918                                  ; REV 1.90
   919                                  ;	       Batch uses XENIX
   920                                  ;
   921                                  ; Rev 2.00
   922                                  ;	       Lots of neato stuff
   923                                  ;	       IBM 2.00 level
   924                                  ;
   925                                  ; Rev 2.01
   926                                  ;	       'D' switch for date time suppression
   927                                  ;
   928                                  ; Rev 2.02
   929                                  ;	       Default userpath is NUL rather than BIN
   930                                  ;		       same as IBM
   931                                  ;	       COMMAND split into pieces
   932                                  ;
   933                                  ; Rev 2.10
   934                                  ;	       INTERNATIONAL SUPPORT
   935                                  ;
   936                                  ; Rev 2.50
   937                                  ;	       all the 2.x new stuff -MU
   938                                  ;
   939                                  ; Rev 3.30     (Ellen G)
   940                                  ;	       CALL internal command (TBATCH2.ASM)
   941                                  ;	       CHCP internal command (TCMD2B.ASM)
   942                                  ;	       INT 24H support of abort, retry, ignore, and fail prompt
   943                                  ;	       @ sign suppression of batch file line
   944                                  ;	       Replaceable environment value support in batch files
   945                                  ;	       INT 2FH calls for APPEND
   946                                  ;	       Lots of PTR fixes!
   947                                  ;
   948                                  ; Beyond 3.30 to forever  (Ellen G)
   949                                  ; ----------------------
   950                                  ;
   951                                  ; A000 DOS 4.00  -	Use SYSPARSE for internal commands
   952                                  ;			Use Message Retriever services
   953                                  ;			/MSG switch for resident extended error msg
   954                                  ;			Convert to new capitalization support
   955                                  ;			Better error recovery on CHCP command
   956                                  ;			Code page file tag support
   957                                  ;			TRUENAME internal command
   958                                  ;			Extended screen line support
   959                                  ;			/P switch on DEL/ERASE command
   960                                  ;			Improved file redirection error recovery
   961                                  ;	(removed)	Improved batch file performance
   962                                  ;			Unconditional DBCS support
   963                                  ;			Volume serial number support
   964                                  ;	(removed)	COMMENT=?? support
   965                                  ;
   966                                  ; A001	PTM P20 	Move system_cpage from TDATA to TSPC
   967                                  ;
   968                                  ; A002	PTM P74 	Fix PRESCAN so that redirection symbols do not
   969                                  ;			require delimiters.
   970                                  ;
   971                                  ; A003	PTM P5,P9,P111	Included in A000 development
   972                                  ;
   973                                  ; A004	PTM P86 	Fix IF command to turn off piping before
   974                                  ;			executing
   975                                  ;
   976                                  ; A005	DCR D17 	If user specifies an extension on the command
   977                                  ;			line search for that extension only.
   978                                  ;
   979                                  ; A006	DCR D15 	New message for MkDir - "Directory already
   980                                  ;			exists"
   981                                  ;
   982                                  ; A007	DCR D2		Change CTTY so that a write is done before XDUP
   983                                  ;
   984                                  ; A008	PTM P182	Change COPY to set default if invalid function
   985                                  ;			returned from code page call.
   986                                  ;
   987                                  ; A009	PTM P179	Add CRLF to invalid disk change message
   988                                  ;
   989                                  ; A010	DCR D43 	Allow APPEND to do a far call to SYSPARSE in
   990                                  ;			transient COMMAND.
   991                                  ;
   992                                  ; A011	DCR D130	Change redirection to overwrite an EOF mark
   993                                  ;			before appending to a file.
   994                                  ;
   995                                  ; A012	PTM P189	Fix redirection error recovery.
   996                                  ;
   997                                  ; A013	PTM P330	Change date format
   998                                  ;
   999                                  ; A014	PTM P455	Fix echo parsing
  1000                                  ;
  1001                                  ; A015	PTM P517	Fix DIR problem with * vs *.
  1002                                  ;
  1003                                  ; A016	PTM P354	Fix extended error message addressing
  1004                                  ;
  1005                                  ; A017	PTM P448	Fix appending to 0 length files
  1006                                  ;
  1007                                  ; A018	PTM P566,P3903	Fix parse error messages to print out parameter
  1008                                  ;			the parser fails on. Fail on duplicate switches.
  1009                                  ;
  1010                                  ; A019	PTM P542	Fix device name to be printed correctly during
  1011                                  ;			critical error
  1012                                  ;
  1013                                  ; A020	DCR D43 	Set append state off while in DIR
  1014                                  ;
  1015                                  ; A021	PTM P709	Fix CTTY printing ascii characters.
  1016                                  ;
  1017                                  ; A022	DCR D209	Enhanced error recovery
  1018                                  ;
  1019                                  ; A023	PTM P911	Fix ANSI.SYS IOCTL structure.
  1020                                  ;
  1021                                  ; A024	PTM P899	Fix EXTOPEN open modes.
  1022                                  ;
  1023                                  ; A025	PTM P922	Fix messages and optimize PARSE switches
  1024                                  ;
  1025                                  ; A026	DCR D191	Change redirection error recovery support.
  1026                                  ;
  1027                                  ; A027	PTM P991	Fix so that KAUTOBAT & AUTOEXEC are terminated
  1028                                  ;			with a carriage return.
  1029                                  ;
  1030                                  ; A028	PTM P1076	Print a blank line before printing invalid
  1031                                  ;			date and invalid time messages.
  1032                                  ;
  1033                                  ; A029	PTM P1084	Eliminate calls to parse_check_eol in DATE
  1034                                  ;			and TIME.
  1035                                  ;
  1036                                  ; A030	DCR D201	New extended attribute format.
  1037                                  ;
  1038                                  ; A031	PTM P1149	Fix DATE/TIME add blank before prompt.
  1039                                  ;
  1040                                  ; A032	PTM P931	Fix =ON, =OFF for BREAK, VERIFY, ECHO
  1041                                  ;
  1042                                  ; A033	PTM P1298	Fix problem with system crashes on ECHO >""
  1043                                  ;
  1044                                  ; A034	PTM P1387	Fix COPY D:fname+,, to work
  1045                                  ;
  1046                                  ; A035	PTM P1407	Fix so that >> (appending) to a device does
  1047                                  ;			do a read to determine eof.
  1048                                  ;
  1049                                  ; A036	PTM P1406	Use 69h instead of 44h to get volume serial
  1050                                  ;			so that ASSIGN works correctly.
  1051                                  ;
  1052                                  ; A037	PTM P1335	Fix COMMAND /C with FOR
  1053                                  ;
  1054                                  ; A038	PTM P1635	Fix COPY so that it doesn't accept /V /V
  1055                                  ;
  1056                                  ; A039	DCR D284	Change invalid code page tag from -1 to 0.
  1057                                  ;
  1058                                  ; A040	PTM P1787	Fix redirection to cause error when no file is
  1059                                  ;			specified.
  1060                                  ;
  1061                                  ; A041	PTM P1705	Close redirected files after internal APPEND
  1062                                  ;			executes.
  1063                                  ;
  1064                                  ; A042	PTM P1276	Fix problem of APPEND paths changes in batch
  1065                                  ;			files causing loss of batch file.
  1066                                  ;
  1067                                  ; A043	PTM P2208	Make sure redirection is not set up twice for
  1068                                  ;			CALL'ed batch files.
  1069                                  ;
  1070                                  ; A044	PTM P2315	Set switch on PARSE so that 0ah is not used
  1071                                  ;			as an end of line character
  1072                                  ;
  1073                                  ; A045	PTM P2560	Make sure we don't lose parse, critical error,
  1074                                  ;			and extended message pointers when we EXIT if
  1075                                  ;			COMMAND /P is the top level process.
  1076                                  ;
  1077                                  ; A046	PTM P2690	Change COPY message "fn File not found" to
  1078                                  ;			"File not found - fn"
  1079                                  ;
  1080                                  ; A047	PTM P2819	Fix transient reload prompt message
  1081                                  ;
  1082                                  ; A048	PTM P2824	Fix COPY path to be upper cased.  This was broken
  1083                                  ;			when DBCS code was added.
  1084                                  ;
  1085                                  ; A049	PTM P2891	Fix PATH so that it doesn't accept extra characters
  1086                                  ;			on line.
  1087                                  ;
  1088                                  ; A050	PTM P3030	Fix TYPE to work properly on files > 64K
  1089                                  ;
  1090                                  ; A051	PTM P3011	Fix DIR header to be compatible with prior releases.
  1091                                  ;
  1092                                  ; A052	PTM P3063,P3228 Fix COPY message for invalid filename on target.
  1093                                  ;
  1094                                  ; A053	PTM P2865	Fix DIR to work in 40 column mode.
  1095                                  ;
  1096                                  ; A054	PTM P3407	Code reduction and critical error on single line
  1097                                  ;	PTM P3672	(Change to single parser exported under P3407)
  1098                                  ;
  1099                                  ; A055	PTM P3282	Reset message service variables in INT 23h to fix
  1100                                  ;			problems with breaking out of INT 24h
  1101                                  ;
  1102                                  ; A056	PTM P3389	Fix problem of environment overlaying transient.
  1103                                  ;
  1104                                  ; A057	PTM P3384	Fix COMMAND /C so that it works if there is no space
  1105                                  ;			before the "string".  EX: COMMAND /CDIR
  1106                                  ;
  1107                                  ; A058	PTM P3493	Fix DBCS so that CPARSE eats second character of
  1108                                  ;			DBCS switch.
  1109                                  ;
  1110                                  ; A059	PTM P3394	Change the TIME command to right align the display of
  1111                                  ;			the time.
  1112                                  ;
  1113                                  ; A060	PTM P3672	Code reduction - change PARSE and EXTENDED ERROR
  1114                                  ;			messages to be disk based.  Only keep them if /MSG
  1115                                  ;			is used.
  1116                                  ;
  1117                                  ; A061	PTM P3928	Fix so that transient doesn't reload when breaking
  1118                                  ;			out of internal commands, due to substitution blocks
  1119                                  ;			not being reset.
  1120                                  ;
  1121                                  ; A062	PTM P4079	Fix segment override for fetching address of environment
  1122                                  ;			of parent copy of COMMAND when no COMSPEC exists in
  1123                                  ;			secondary copy of environment.	Change default slash in
  1124                                  ;			default comspec string to backslash.
  1125                                  ;
  1126                                  ; A063	PTM P4140	REDIRECTOR and IFSFUNC changed interface for getting
  1127                                  ;			text for critical error messages.
  1128                                  ;
  1129                                  ; A064	PTM P4934	Multiplex number for ANSI.SYS changed due to conflict
  1130                                  ;	5/20/88 	with Microsoft product already shipped.
  1131                                  ;
  1132                                  ; A065	PTM P4935	Multiplex number for SHELL changed due to conflict
  1133                                  ;	 5/20/88	with Microsoft product already shipped.
  1134                                  ;
  1135                                  ; A066	PTM P4961	DIR /W /P scrolled first line off the screen in some
  1136                                  ;	 5/24/88	cases; where the listing would barely fit without the
  1137                                  ;			header and space remaining.
  1138                                  ;
  1139                                  ; A067	PTM P5011	For /E: values of 993 to 1024 the COMSPEC was getting
  1140                                  ;	 6/6/88 	trashed.  Turns out that the SETBLOCK for the new
  1141                                  ;			environment was putting a "Z block" marker in the old
  1142                                  ;			environment.  The fix is to move to the old environment
  1143                                  ;			to the new environment before doing the SETBLOCK.
  1144                                  ;
  1145                                  ; A068  PTM P5568       IR79754 APPEND /x:on not working properly with DIR/VOL
  1146                                  ;        09/19/88       because the check for APPEND needed to be performed
  1147                                  ;                       before the DIR's findfirst.
  1148                                  ;
  1149                                  ; A069  PTM P5726       IR80540 COMSPEC_flag not properly initialized and
  1150                                  ;        10/30/88       executed.  Causing AUSTIN problem testing LAN/DW4 re-
  1151                                  ;                       loading trans w/new comspec with no user change comspec.
  1152                                  ;
  1153                                  ; A070  PTM P5734       IR80484 Batch file causes sys workspace to be corrupted.
  1154                                  ;        11/05/88       Expansion of environment variables into batch line of
  1155                                  ;                       128 chars was not being counted and "%" which should be
  1156                                  ;                       ignored were being counted.
  1157                                  ;
  1158                                  ; A071  PTM P5854       IR82061 Invalid COMMAND.COM when Word Perfect, Prompt
  1159                                  ;        03/02/89       used.  Comspec_flag was not in protected data file be-
  1160                                  ;                       ing included in checksum and was being overwritten by
  1161                                  ;                       WP.  Moved var from Tspc to Tdata so Trans would reload.
  1162                                  ;                       Also removed fix A069 (because flag now protected).
  1163                                  ;
  1164                                  ; C001  VERSION 4.1     Add new internal command - SERVICE - to display the DOS
  1165                                  ;        07/25/89       version and CSD version in U.S. date format.  Files
  1166                                  ;                       changed - TRANMSG,.SKL,COMMAND1,TDATA,TCMD2A,USA.MSG
  1167                                  ;
  1168                                  ;***********************************************************************************
  1169                                  
  1170                                  ;
  1171                                  ;	Revision History
  1172                                  ;	================
  1173                                  ;
  1174                                  ;	M021	SR	08/23/90	Fixed Ctrl-C handler to handle Ctrl-C
  1175                                  ;					at init time (date/time prompt)
  1176                                  ;
  1177                                  
  1178                                  ;
  1179                                  ;.xcref
  1180                                  ;.xlist
  1181                                  ;	include dossym.inc		; basic DOS symbol set
  1182                                  ;	include syscall.inc		; DOS function names
  1183                                  ;	include comsw.asm		; build version info
  1184                                  ;	include comequ.asm		; common command.com symbols
  1185                                  ;	include resmsg.equ		; resident message names
  1186                                  ;
  1187                                  ;	include comseg.asm		;segment ordering
  1188                                  ;.list
  1189                                  ;.cref
  1190                                  
  1191                                  ;CODERES segment public byte
  1192                                  ;CODERES ends
  1193                                  ;
  1194                                  ;DATARES 	segment public byte
  1195                                  ;		extrn	AccDen:byte
  1196                                  ;		extrn	Batch:word
  1197                                  ;		extrn	EchoFlag:byte
  1198                                  ;		extrn	ExeBad:byte
  1199                                  ;		extrn	ExecEMes:byte
  1200                                  ;		extrn	ExecErrSubst:byte
  1201                                  ;		extrn	ExtCom:byte
  1202                                  ;		extrn	ForFlag:byte
  1203                                  ;		extrn	IfFlag:byte
  1204                                  ;		extrn	InitFlag:BYTE
  1205                                  ;		extrn	Nest:word
  1206                                  ;		extrn	PipeFlag:byte
  1207                                  ;		extrn	RBadNam:byte
  1208                                  ;		extrn	RetCode:word
  1209                                  ;		extrn	SingleCom:word
  1210                                  ;		extrn	TooBig:byte
  1211                                  ;
  1212                                  ;		extrn	OldDS:word
  1213                                  ;
  1214                                  ;DATARES 	ends
  1215                                  ;
  1216                                  ;
  1217                                  ;INIT		segment public para
  1218                                  ;		extrn	ConProc:near
  1219                                  ;		extrn	Init_Contc_SpecialCase:near
  1220                                  ;INIT		ends
  1221                                  
  1222                                  ; 09/01/2023 - Erdogan Tan - Istanbul
  1223                                  ; --------------------------------------
  1224                                  ; 'command5.s' source code reference(s):
  1225                                  
  1226                                  ;	1) MSDOS 6.0 COMMAND.COM source files
  1227                                  ;	2) Disassembled MSDOS 5.0 COMMAND.COM - 11/11/1991 - 47845 bytes  
  1228                                  ;	   (Disassembler: HEX-RAYS IDA Pro Freeware Version 5.0)
  1229                                  ; ----------------------------------------------------------------------				 	 	
  1230                                  
  1231                                  ; ----------------------------------------------------------------------------
  1232                                  ; START OF RESIDENT PORTION
  1233                                  ; ----------------------------------------------------------------------------
  1234                                  ; SEGMENT - DATARES
  1235                                  ; ----------------------------------------------------------------------------
  1236                                  
  1237                                  section .RESGROUP ; vstart=100h  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) 
  1238                                  
  1239                                  ; 09/01/2023 - Retro DOS v4.0 (Modified COMMAND.COM v5.0)
  1240                                  
  1241                                  ; ----------------------------------------------------------------------------
  1242                                  ; STUB.ASM - MSDOS 6.0 - 1991
  1243                                  ; ----------------------------------------------------------------------------
  1244                                  
  1245                                  ;This file contains the low memory stub for command.com which hooks all the
  1246                                  ;entry points into the resident command.com and directs the calls to the
  1247                                  ;appropriate routines in the resident code which may be located in HIMEM. 
  1248                                  ;
  1249                                  ;The stub has been made part of the resident data and will always
  1250                                  ;be duplicated on every invocation of command.com. However, the only stubs
  1251                                  ;that actually hook the interrupt vectors belong to either the first 
  1252                                  ;command.com or to any other command.com executed with the /p switch. 
  1253                                  ;
  1254                                  ;The stub also keeps track of the current active data segment. The 
  1255                                  ;INIT code of each command.com updates this variable via an int 2fh mechanism
  1256                                  ;with its own data segment. The INIT code also updates a pointer in its data
  1257                                  ;segment to the previous resident data segment. Whenever a command.com exits,
  1258                                  ;the exit code picks up the previous data segment pointer from the current
  1259                                  ;data segment and patches it into the CurResDataSeg variable in the stub.
  1260                                  ;
  1261                                  ;Right now the stub does not bother about A20 switching. We assume
  1262                                  ;A20 is always on. It just does a far jump to the resident code with the 
  1263                                  ;value of the current data segment in one of the registers. A20 toggle 
  1264                                  ;support maybe added as a future enhancement, if the need is felt.
  1265                                  
  1266                                  	; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1267                                  
  1268                                  	[ORG 100H]
  1269                                  
  1270                                  	; 21/09/2018 - Retro DOS v3.0
  1271                                  StartCode:
  1272 00000000 E91D14                  	jmp	ConProc	; 10/01/2023 
  1273                                  
  1274                                  	; 09/01/2023
  1275                                  
  1276                                  ; Make following table word-aligned, and at the same time, provide a
  1277                                  ; signature that sysinit can use to (attempt to) validate the interpreter
  1278                                  
  1279                                  	;db	0	; MSDOS 5.0 COMMAND.COM - DATARESRES:0103h
  1280 00000003 50                      	db      ((MAJOR_VERSION&0Fh)<<4)|(MINOR_VERSION&0Fh)
  1281                                  
  1282                                  ;All the entry points declared below are patched in at INIT time with the
  1283                                  ;proper segment and offset values after the resident code segment has been
  1284                                  ;moved to its final location
  1285                                  
  1286                                  ;!!!WARNING!!!
  1287                                  ; All the dword ptrs from Int2f_Entry till MsgRetrv_Entry should be contiguous
  1288                                  ;because the init routine 'Patch_stub' (in init.asm) relies on this to patch
  1289                                  ;in the correct segments and offsets
  1290                                  
  1291                                  Int2f_Entry:
  1292 00000004 [3213]                  	dw	MsgInt2fHandler		; Address of int 2fh handler
  1293 00000006 0000                    	dw	0
  1294                                  Int2e_Entry:
  1295 00000008 [850D]                  	dw	Int_2e			; Address of int 2eh handler
  1296 0000000A 0000                    	dw	0
  1297                                  Ctrlc_Entry:
  1298 0000000C [430C]                  	dw	ContC			; Address of Ctrl-C handler
  1299 0000000E 0000                    	dw	0
  1300                                  CritErr_Entry:
  1301 00000010 [4610]                  	dw	DSKERR			; Address of critical error handler
  1302 00000012 0000                    	dw	0
  1303                                  
  1304                                  Exec_Entry:
  1305 00000014 00000000                	dd	0			; Entry from transient to Ext_Exec
  1306                                  RemCheck_Entry:
  1307 00000018 00000000                	dd	0			; Entry from transient to TRemCheck
  1308                                  TrnLodCom1_Entry:
  1309 0000001C 00000000                	dd	0			; Entry from transient to LodCom1
  1310                                  LodCom_Entry:
  1311 00000020 00000000                	dd	0			; Entry after exit from command.com
  1312                                  MsgRetrv_Entry:
  1313 00000024 00000000                	dd	0			; Entry from external to MsgRetriever
  1314                                  HeadFix_Entry:
  1315 00000028 00000000                	dd	0			; Entry from trans to HeadFix
  1316                                  UMBOff_Entry:
  1317 0000002C 00000000                	dd	0			; Entry from here to UMBOff routine; M003
  1318                                  XMMCallAddr:
  1319 00000030 00000000                	dd	0			; Call address for XMM functions
  1320                                  ComInHMA:
  1321 00000034 00                      	db	0			; Flags if command.com in HMA
  1322                                  
  1323                                  Int2f_Trap:
  1324                                  	;sti	; 19/04/2023 (MSDOS 5.0 COMMAND.COM - RESGROUP:0135h)
  1325 00000035 E86400                  	call	CheckA20
  1326 00000038 1E                      	push	ds			; push current ds value
  1327 00000039 0E                      	push	cs			; push resident data segment value
  1328                                  	;jmp	cs:Int2f_Entry
  1329 0000003A 2EFF2E[0400]            	jmp	far [cs:Int2f_Entry]
  1330                                  
  1331                                  Int2e_Trap:
  1332 0000003F FB                      	sti
  1333 00000040 E85900                  	call	CheckA20
  1334 00000043 1E                      	push	ds			; push current ds value
  1335 00000044 0E                      	push	cs			; push resident data segment value
  1336                                  	;jmp	cs:Int2e_Entry
  1337 00000045 2EFF2E[0800]            	jmp	far [cs:Int2e_Entry]
  1338                                  
  1339                                  Ctrlc_Trap:
  1340 0000004A FB                      	sti
  1341 0000004B E84E00                  	call	CheckA20
  1342 0000004E 1E                      	push	ds			; push current ds value
  1343 0000004F 0E                      	push	cs			; push resident data segment value
  1344                                  	;jmp	cs:Ctrlc_Entry
  1345 00000050 2EFF2E[0C00]            	jmp	far [cs:Ctrlc_Entry]
  1346                                  
  1347                                  CritErr_Trap:
  1348 00000055 FB                      	sti
  1349 00000056 E84300                  	call	CheckA20
  1350 00000059 1E                      	push	ds			; push current ds value
  1351 0000005A 0E                      	push	cs			; push resident data segment value
  1352                                  	;jmp	cs:CritErr_Entry
  1353 0000005B 2EFF2E[1000]            	jmp	far [cs:CritErr_Entry]
  1354                                  
  1355                                  Exec_Trap:
  1356 00000060 E83900                  	call	CheckA20
  1357 00000063 1E                      	push	ds			; push current ds value
  1358 00000064 0E                      	push	cs			; push resident data segment value
  1359                                  	;jmp	cs:Exec_Entry
  1360 00000065 2EFF2E[1400]            	jmp	far [cs:Exec_Entry]
  1361                                  
  1362                                  RemCheck_Trap:
  1363 0000006A E82F00                  	call	CheckA20
  1364 0000006D 1E                      	push	ds			; push current ds value
  1365 0000006E 0E                      	push	cs			; push resident data segment value
  1366                                  	;jmp	cs:RemCheck_Entry
  1367 0000006F 2EFF2E[1800]            	jmp	far [cs:RemCheck_Entry]
  1368                                  
  1369                                  TrnLodCom1_Trap:
  1370 00000074 E82500                  	call	CheckA20
  1371 00000077 1E                      	push	ds			; push current ds value
  1372 00000078 0E                      	push	cs			; push resident data segment value
  1373                                  	;jmp	cs:TrnLodCom1_Entry
  1374 00000079 2EFF2E[1C00]            	jmp	far [cs:TrnLodCom1_Entry]
  1375                                  
  1376                                  LodCom_Trap:
  1377 0000007E E81B00                  	call	CheckA20
  1378 00000081 1E                      	push	ds			; push current ds value
  1379 00000082 0E                      	push	cs			; push resident data segment value
  1380                                  	;jmp	cs:LodCom_Entry
  1381 00000083 2EFF2E[2000]            	jmp	far [cs:LodCom_Entry]
  1382                                  
  1383                                  MsgRetrv_Trap:
  1384 00000088 E81100                  	call	CheckA20
  1385 0000008B 1E                      	push	ds			; push current ds value
  1386 0000008C 0E                      	push	cs			; push resident data segment value
  1387                                  	;jmp	cs:MsgRetrv_Entry
  1388 0000008D 2EFF2E[2400]            	jmp	far [cs:MsgRetrv_Entry]
  1389                                  
  1390                                  HeadFix_Trap:
  1391 00000092 E80700                  	call	CheckA20
  1392 00000095 1E                      	push	ds			; push current ds value
  1393 00000096 0E                      	push	cs			; push resident data segment value
  1394                                  	;jmp	cs:HeadFix_Entry
  1395 00000097 2EFF2E[2800]            	jmp	far [cs:HeadFix_Entry]
  1396                                  
  1397                                  ; ----------------------------------------------------------------------------
  1398                                  
  1399                                  	; 09/01/2023
  1400                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:019Dh
  1401                                  
  1402                                  CheckA20:
  1403 0000009C 9C                      	pushf				; save current flags
  1404 0000009D 2E803E[3400]00          	cmp	byte [cs:ComInHMA],0	; is resident in HMA?
  1405 000000A3 7408                    	jz	short A20_on		; no, jump to resident
  1406                                  
  1407 000000A5 E80C00                  	call	QueryA20
  1408 000000A8 7303                    	jnc	short A20_on		; A20 is on, jump to resident
  1409                                  
  1410 000000AA E81800                  	call	EnableA20		; turn A20 on
  1411                                  A20_on:
  1412 000000AD 9D                      	popf				; flags have to be unchanged
  1413 000000AE C3                      	retn
  1414                                  
  1415                                  ; ----------------------------------------------------------------------------
  1416                                  
  1417                                  ; M005; This is a far jump to the actual int 2fh entry point. The renormalized
  1418                                  ; M005; int 2fh cs:ip points here. We hardcode a far jump here to the int 2fh
  1419                                  ; M005; handler. Note that we have to hardcode a jump and we cannot use any
  1420                                  ; M005; pointers because our cs is going to be different. The segment to
  1421                                  ; M005; jump to is patched in at init time. (in init.asm)
  1422                                  
  1423                                  Carousel_i2f_Hook:			; M005
  1424 000000AF EA                      	db	0EAh			; far jump opcode; M005
  1425 000000B0 [3500]                  	dw	Int2f_Trap ; DATARES	; int 2fh offset ; M005
  1426 000000B2 0000                    	dw	0			; int 2fh segment; M005
  1427                                  
  1428                                  ; ----------------------------------------------------------------------------
  1429                                  
  1430                                  XMM_QUERY_A20 equ 7 ; 09/01/2023
  1431                                  
  1432                                  QueryA20:
  1433 000000B4 53                      	push	bx
  1434 000000B5 50                      	push	ax
  1435                                  	;mov	ah,7
  1436 000000B6 B407                    	mov	ah,XMM_QUERY_A20
  1437                                  	;call	cs:XMMCallAddr
  1438 000000B8 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1439 000000BD 09C0                    	or	ax,ax
  1440 000000BF 58                      	pop	ax
  1441 000000C0 5B                      	pop	bx
  1442                                  	; 16/04/2023
  1443 000000C1 7501                    	jnz	short QA20_ON	; cf = 0	; AX = 1 => ON
  1444                                  
  1445 000000C3 F9                      	stc					; OFF
  1446                                  	;retn
  1447                                  QA20_ON:
  1448                                  	;clc					; ON
  1449 000000C4 C3                      	retn
  1450                                  
  1451                                  ; ----------------------------------------------------------------------------
  1452                                  
  1453                                  XMM_LOCAL_ENABLE_A20 equ 5
  1454                                  
  1455                                  EnableA20:
  1456 000000C5 53                      	push	bx
  1457 000000C6 50                      	push	ax
  1458                                  	;mov	ah,5
  1459 000000C7 B405                    	mov	ah,XMM_LOCAL_ENABLE_A20
  1460                                  	;call	cs:XMMCallAddr
  1461 000000C9 2EFF1E[3000]            	call	far [cs:XMMCallAddr]
  1462 000000CE 09C0                    	or	ax,ax
  1463 000000D0 7403                    	jz	short XMMerror			; AX = 0 fatal error
  1464 000000D2 58                      	pop	ax
  1465 000000D3 5B                      	pop	bx
  1466 000000D4 C3                      	retn
  1467                                  
  1468                                  ;If we get an error, we just loop forever
  1469                                  
  1470                                  XMMerror:
  1471 000000D5 EBFE                    	jmp	short XMMerror
  1472                                  
  1473                                  ; -----------------------------------------------------------------------------
  1474                                  
  1475                                  HV_Extern   equ	1
  1476                                  HV_LoadHigh equ	1
  1477                                  HV_Stub	    equ	1
  1478                                  
  1479                                  	; 09/01/2023 - Retro DOS v4.0 (& 4.1)
  1480                                  
  1481                                  ;The Exec call has to be issued from the data segment. The reason for this 
  1482                                  ;is TSRs. When a TSR does a call to terminate and stay resident, the call
  1483                                  ;returns with all registers preserved and so all our segment registers are
  1484                                  ;still set up. However, if the TSR unloads itself later on, it still 
  1485                                  ;comes back here. In this case the segment registers and the stack are
  1486                                  ;not set up and random things can happen. The only way to setup all the 
  1487                                  ;registers is to use the cs value and this can only be done when we are in
  1488                                  ;the data segment ourselves. So, this piece of code had to be moved from
  1489                                  ;the code segment to the data segment.
  1490                                  
  1491                                  Issue_Exec_Call:
  1492 000000D7 CD21                    	int 	21h
  1493                                  
  1494                                  ;We disable interrupts while changing the stack because there is a bug in 
  1495                                  ;some old 8088 processors where interrupts are let through while ss & sp
  1496                                  ;are being changed.
  1497                                  
  1498 000000D9 FA                      	cli
  1499 000000DA 0E                      	push	cs
  1500 000000DB 17                      	pop	ss
  1501                                  	;mov	sp,53Eh ; MSDOS 5.0 COMMAND.COM RESGROUP:01DFh
  1502                                  	;mov	sp,offset DATARES:RStack ; stack is set up
  1503 000000DC BC[3804]                	mov	sp,RStack		; stack is set up
  1504                                  	
  1505                                  	; 20/04/2023
  1506                                  	;sti
  1507                                  	;push	cs
  1508                                  	;pop	ds			; ds = DATARES
  1509                                  
  1510                                  ; M009; Restore UMB state to that before Exec
  1511                                  
  1512                                  	;pushf				;    This call frees HIDDEN umb's,
  1513                                  	;call	UnHideUMBs		; <- restores the memory-allocation
  1514                                  	;popf				;    strategy and link state, as app.
  1515                                  
  1516                                  	; 09/01/2023 - Retro DOS v4.0
  1517                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:01E2h
  1518                                  	; ----------------------
  1519 000000DF FB                      	sti
  1520                                  	
  1521 000000E0 0E                      	push    cs
  1522 000000E1 1F                      	pop     ds
  1523 000000E2 9C                      	pushf
  1524                                  	;mov	al,[cs:fInHigh]
  1525                                  	; 18/04/2023
  1526 000000E3 A0[3A04]                	mov	al,[fInHigh]
  1527 000000E6 A880                    	test	al,80h
  1528 000000E8 7406                    	jz      short uhu10
  1529 000000EA 247F                    	and     al,7Fh
  1530                                  	;;call	cs:UMBOff_Entry
  1531                                  	;call	far [cs:UMBOff_Entry]
  1532 000000EC FF1E[2C00]              	call	far [UMBOff_Entry]
  1533                                  uhu10:
  1534                                  	;and	byte [cs:fInHigh],7Fh
  1535                                  	; 18/04/2023
  1536 000000F0 8026[3A04]7F            	and	byte [fInHigh],7Fh
  1537 000000F5 9D                      	popf
  1538                                  	; ----------------------
  1539                                  
  1540                                  ;We now jump to the stub trap which returns us to the resident code. All
  1541                                  ;flags are preserved by the stub code.
  1542                                  
  1543 000000F6 E967FF                  	jmp	Exec_Trap
  1544                                  
  1545                                  ; ----------------------------------------------------------------------------
  1546                                  ; RDATA.ASM, MSDOS 6.0, 1992
  1547                                  ; ----------------------------------------------------------------------------
  1548                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1)
  1549                                  
  1550                                  ;***	Message substitution blocks
  1551                                  
  1552                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:01FFh (DATARES:01FFh)
  1553                                  
  1554                                  ;BlkDevErrSubst	label	byte
  1555                                  ;BlkDevErrRw	subst	<STRING,>		; "reading" or "writing"
  1556                                  ;		subst	<CHAR,DATARES:DrvLet>	; block device drive letter
  1557                                  
  1558 000000F9 02                      BlkDevErrSubst: db	2
  1559 000000FA 0000                    BlkDevErrRw:	dw	0
  1560 000000FC 01                      		db	1
  1561 000000FD [FF00]                  		dw	DrvLet
  1562                                  
  1563 000000FF 41                      DrvLet:		db	'A'			; drive letter
  1564                                  
  1565                                  
  1566                                  ;CharDevErrSubst label	byte
  1567                                  ;CharDevErrRw	subst	<STRING,>		 ; "reading" or "writing"
  1568                                  ;CharDevErrDev	subst	<STRING,DATARES:DevName> ; character device name
  1569                                  
  1570 00000100 02                      CharDevErrSubst: db	2
  1571 00000101 0000                    CharDevErrRw:	dw	0
  1572 00000103 02                      		db	2
  1573 00000104 [0601]                  		dw	DevName
  1574                                  
  1575 00000106 00<rep 8h>              DevName:	times 8 db 0  ; db 8 dup (?),0	; device name, asciiz
  1576 0000010E 00                      		db	0
  1577                                  
  1578                                  ;NeedVolSubst	label	byte
  1579                                  ;		subst	<STRING,DATARES:VolName> ; volume name
  1580                                  ;		subst	<HEX,DATARES:VolSer+2>	 ; hi word of serial #
  1581                                  ;		subst	<HEX,DATARES:VolSer>	 ; lo word of serial #
  1582                                  
  1583 0000010F 02                      NeedVolSubst:	db	2
  1584 00000110 [1801]                  		dw	VolName
  1585 00000112 03                      		db	3
  1586 00000113 [2601]                  		dw	VolSer+2
  1587 00000115 03                      		db	3
  1588 00000116 [2401]                  		dw	VolSer
  1589                                  
  1590                                  	; NOTE:	VolName and VolSer must be adjacent
  1591 00000118 00<rep Bh>              VolName:	times 11 db 0 ; db 11 dup (?),0	; volume name
  1592 00000123 00                      		db	0
  1593 00000124 00000000                VolSer:		dd	0			; volume serial #
  1594                                  
  1595 00000128 00                      CDevAt:		db	0
  1596                                  
  1597                                  ;BadFatSubst	label	byte
  1598                                  ;		subst	<CHAR,DATARES:DrvLet>	; drive letter
  1599                                  
  1600 00000129 01                      BadFatSubst:	db	1
  1601 0000012A [FF00]                  		dw	DrvLet
  1602                                  
  1603                                  ;PutBackSubst	label	byte
  1604                                  ;PutBackComSpec	subst	<STRING,>		  ; comspec string
  1605                                  ;		subst	<CHAR,DATARES:PutBackDrv> ; drive to put it in
  1606                                  
  1607 0000012C 02                      PutBackSubst:	db	2
  1608 0000012D 0000                    PutBackComSpec:	dw	0
  1609 0000012F 01                      		db	1
  1610 00000130 [3201]                  		dw	PutBackDrv
  1611                                  
  1612 00000132 20                      PutBackDrv:	db	' '			; drive letter
  1613                                  
  1614                                  ;ExecErrSubst	subst	<STRING,DATARES:SafePathBuffer>
  1615                                  
  1616 00000133 02                      ExecErrSubst:	db	2
  1617 00000134 [6303]                  		dw	SafePathBuffer
  1618                                  
  1619 00000136 00000000                NeedVol:	dd	0	; ptr to volume name from get ext err
  1620 0000013A 00                      ErrType: 	db	0	; critical error message style, 0=old, 1=new
  1621                                  
  1622 0000013B 00000000                Int_2e_Ret:	dd	0	; magic command executer return address
  1623 0000013F 0000                    Save_Pdb:	dw	0
  1624 00000141 0000                    Parent:		dw	0
  1625 00000143 00000000                OldTerm:	dd	0
  1626 00000147 0000                    ErrCd_24:	dw	0
  1627 00000149 0000                    Handle01:	dw	0
  1628 0000014B 00                      Loading:	db	0
  1629 0000014C 0000                    Batch:		dw	0	; assume no batch mode initially
  1630                                  
  1631                                  ;;;;SR;
  1632                                  ;;;; This flag has been added for a gross hack introduced in batch processing. 
  1633                                  ;;;;We use it to indicate that this batch file has no CR-LF before EOF and that
  1634                                  ;;;;we need to fake the CR-LF for the line to be properly processed
  1635                                  ;;;;
  1636                                  ;;;BatchEOF:	db	0
  1637                                  
  1638                                  	; Bugbug: ComSpec should be 64+3+12+1?
  1639                                  	; What's this comspec_end about?
  1640 0000014E 00<rep 40h>             ComSpec:	times 64 db 0 ; db 64 dup (0)
  1641 0000018E 0000                    ComSpec_End:	dw	0
  1642                                  
  1643                                  ;Trans		label	dword
  1644                                  ;		dw	TRANGROUP:Command
  1645                                  
  1646                                  Trans:		;dw	12Ch
  1647                                  		; MSDOS 5.0 COMMAND.COM RESGROUP:0296h (DATARES:0296h)
  1648 00000190 [2C01]                  		dw	COMMAND ; 16/04/2023
  1649 00000192 0000                    TrnSeg:		dw	0
  1650                                  
  1651 00000194 00                      TrnMvFlg:	db	0	; set if transient portion has been moved
  1652                                  
  1653 00000195 00                      In_Batch:	db	0	; set if we are in batch processing mode
  1654 00000196 00                      Batch_Abort:	db	0	; set if user wants to abort from batch mode
  1655                                  
  1656 00000197 00                      ComDrv:		db	0	; drive spec to load autoexec and command
  1657 00000198 0000                    MemSiz:		dw	0
  1658 0000019A 0000                    Sum:		dw	0
  1659 0000019C 01                      ExtCom:		db	1	; for init, pretend just did an external
  1660 0000019D 0000                    RetCode: 	dw	0
  1661 0000019F 00                      Crit_Err_Info:	db	0	; hold critical error flags for r,i,f
  1662                                  
  1663                                  
  1664                                  ; The echo flag needs to be pushed and popped around pipes and batch files.
  1665                                  ; We implement this as a bit queue that is shr/shl for push and pop.
  1666                                  
  1667 000001A0 01                      EchoFlag:	db	00000001b ; low bit true => echo commands
  1668 000001A1 01                      Suppress:	db	1	; used for echo, 1=echo line
  1669 000001A2 0000                    Io_Save: 	dw	0
  1670 000001A4 00                      RestDir: 	db	0
  1671 000001A5 00                      PermCom: 	db	0	; true => permanent command
  1672                                  ;SemiPermCom:	dw      -1	; MSDOS 6.0 COMMAND.COM 
  1673                                  				; true => semi-permanent command (/K)
  1674 000001A6 0000                    SingleCom:	dw	0	; true => single command version
  1675 000001A8 FFFF                    VerVal:		dw	-1
  1676 000001AA 00                      fFail:		db	0	; true => fail all int 24s
  1677 000001AB 00                      IfFlag:		db	0	; true => IF statement in progress
  1678                                  
  1679 000001AC 00                      ForFlag: 	db	0	; true => FOR statement in progress
  1680 000001AD 0000                    ForPtr:		dw	0
  1681                                  
  1682 000001AF 0000                    Nest:		dw	0	; nested batch file counter
  1683 000001B1 00                      Call_Flag:	db	0	; no CALL (batch command) in progress
  1684 000001B2 00                      Call_Batch_Flag: db	0
  1685 000001B3 0000                    Next_Batch:	dw	0	; address of next batch segment
  1686 000001B5 00                      NullFlag:	db	0	; flag if no command on command line
  1687 000001B6 00<rep 5h>              FUCase_Addr:	times 5 db 0 ; db 5 dup (0)
  1688                                  				; buffer for file ucase address
  1689                                  ; Bugbug: don't need crit_msg_ anymore?
  1690                                  
  1691 000001BB 0000                    Crit_Msg_Off:	dw	0	; saved critical error message offset
  1692 000001BD 0000                    Crit_Msg_Seg:	dw	0	; saved critical error message segment
  1693 000001BF 0000                    Dbcs_Vector_Addr: dw	0	; DBCS vector offset
  1694 000001C1 0000                    		 dw	0	; DBCS vector segment
  1695 000001C3 0000                    Append_State:	dw	0	; current state of append
  1696                                  				;  (if Append_Flag is set)
  1697 000001C5 00                      Append_Flag:	db	0	; set if append state is valid
  1698 000001C6 00                      Re_Out_App:	db	0
  1699 000001C7 00<rep 50h>             Re_OutStr:	times 64+3+13 db 0 ; db 64+3+13 dup (?)
  1700                                  
  1701                                  ; We flag the state of COMMAND in order to correctly handle the ^Cs at
  1702                                  ; various times. Here is the breakdown:
  1703                                  ;
  1704                                  ;   INITINIT	We are in the init code.
  1705                                  ;   INITSPECIAL We are in the date/time prompt
  1706                                  ;   INITCTRLC	We are handling a ^C already.
  1707                                  ;
  1708                                  ; If we get a ^C in the initialization but not in the date/time prompt, we
  1709                                  ; ignore the ^C. This is so the system calls work on nested commands.
  1710                                  ;
  1711                                  ; If we are in the date/time prompt at initialization, we stuff the user's
  1712                                  ; input buffer with a CR to pretend an empty response.
  1713                                  ;
  1714                                  ; If we are already handling a ^C, we set the carry bit and return to the user
  1715                                  ; (ourselves). We can then detect the carry set and properly retry the
  1716                                  ; operation.
  1717                                  
  1718                                  InitFlag:	;db	1
  1719 00000217 01                      		db	INITINIT
  1720                                  
  1721                                  ; Note: these two bytes are referenced as a word
  1722 00000218 00                      PipeFlag:	db	0
  1723 00000219 00                      PipeFiles:	db	0
  1724                                  
  1725                                  ; (rdata.asm, msdos 6.0, 1992)
  1726                                  ; ----------------------------------------------------------------------------
  1727                                  ; 09/01/2023 - MSDOS 5.0 COMMAND.COM RESGROUP:0320h (DATARES:0320h)
  1728                                  
  1729                                  
  1730                                  ;;SR
  1731                                  ;; Pipe1 & Pipe2 now need to store full-fledged pathnames
  1732                                  ;;
  1733                                  ;
  1734                                  ;; Bugbug: can we find any way around maintaining these
  1735                                  ;; large buffers?
  1736                                  ;
  1737                                  ;Pipe1		db	67+12 dup (?)
  1738                                  ;Pipe2		db	67+12 dup (?)
  1739                                  ;
  1740                                  ;PipePtr 	dw	?
  1741                                  ;
  1742                                  ;PipeStr 	db	129 dup (?)
  1743                                  ;
  1744                                  ;EndPipe	label	byte	; marks end of buffers; M004
  1745                                  ;
  1746                                  ;;SR;
  1747                                  ;; We can move our EndInit code into above buffers. This way, the code will
  1748                                  ;;automatically be discarded after init.
  1749                                  ;;
  1750                                  ;; M004; We overlap our code with the Pipe buffers located above by changing
  1751                                  ;; M004; the origin.
  1752                                  ;;
  1753                                  ;	ORG	Pipe1	; M004
  1754                                  ;
  1755                                  ;; Bugbug: really need a procedure header for EndInit, describing
  1756                                  ;; what it expects, what it does.
  1757                                  ;
  1758                                  
  1759                                  ; 09/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  1760                                  
  1761                                  Pipe1	equ	EndInit
  1762                                  Pipe2	equ	Pipe1+67+12
  1763                                  PipePtr	equ	Pipe2+67+12
  1764                                  PipeStr	equ	PipePtr+2
  1765                                  EndPipe	equ	PipeStr+129	; EndInit+289
  1766                                  
  1767                                  ; Bugbug: really need a procedure header for EndInit, describing
  1768                                  ; what it expects, what it does.
  1769                                  
  1770                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0320h 
  1771                                  
  1772                                  EndInit:
  1773 0000021A 1E                      	push	ds
  1774 0000021B 06                      	push	es		; save segments
  1775 0000021C 0E                      	push	cs
  1776 0000021D 1F                      	pop	ds		
  1777                                  	;assume	ds:RESGROUP
  1778                                  
  1779                                  ; M004; Save size of transient here before INIT segment is deallocated
  1780                                  
  1781 0000021E 8B16[A71C]              	mov	dx,[TrnSize]		; M004
  1782                                  ;M027
  1783                                  ; These variables are also defined in the INIT segment and need to be saved
  1784                                  ;before we resize
  1785                                  ;
  1786 00000222 A1[9B1C]                	mov	ax,[OldEnv]	; Old Environment seg ;M027
  1787 00000225 8B1E[971C]              	mov	bx,[EnvSiz]	; Size of new environment ;M027
  1788 00000229 8B0E[9D1C]              	mov	cx,[UsedEnv]	; Size of old environment ;M027
  1789 0000022D 50                      	push	ax		; Save all these values ;M027
  1790 0000022E 53                      	push	bx		; M027
  1791 0000022F 51                      	push	cx		; M027
  1792                                  
  1793                                  
  1794                                  ; Bugbug: push ds, pop es here.
  1795                                  	;mov	bx,ds
  1796                                  	;mov	es,bx		; es = RESGROUP
  1797                                  	; 09/01/2023
  1798 00000230 1E                      	push	ds
  1799 00000231 07                      	pop	es
  1800                                  
  1801                                  ;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  1802                                  ; code + data for low COMMAND
  1803                                  
  1804 00000232 8B1E[B903]              	mov	bx,[ResSize]	; Total size of resident
  1805 00000236 B44A                    	mov	ah,4Ah
  1806                                  	;mov	ah,SETBLOCK
  1807 00000238 CD21                    	int	21h		; Set block to resident size
  1808                                  
  1809                                  		; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  1810                                  		; ES = segment address of block to change
  1811                                  		; BX = new size in paragraphs
  1812                                  
  1813                                  ;We check if this is for autoexec.bat (PermCom = 1). If so, we then
  1814                                  ;allocate a new batch segment, copy the old one into new batchseg and free
  1815                                  ;the old batchseg. Remember that the old batchseg was allocated on top of the
  1816                                  ;transient and we will leave a big hole if TSRs are loaded by autoexec.bat
  1817                                  ;
  1818                                  ; Bugbug: also describe why we alloc & copy batch seg BEFORE environment.
  1819                                  	
  1820 0000023A 803E[A501]01            	cmp	byte [PermCom],1 ; permanent command.com?
  1821 0000023F 7530                    	jne	short adjust_env ; no, do not free batchseg
  1822                                  
  1823 00000241 833E[4C01]00            	cmp	word [Batch],0	 ; was there a valid batchseg?
  1824 00000246 7429                    	je	short adjust_env ; no, dont juggle
  1825                                  
  1826                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16 ; batchseg size
  1827                                  	; 21/01/2023
  1828 00000248 BB0400                  	mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  1829                                  	;mov	bx,4	; 09/01/2023
  1830                                  			; (MSDOS 5.0 COMMAND COM RESGROUP:0350h)
  1831 0000024B B448                    	mov	ah,48h
  1832                                  	;mov	ah,ALLOC
  1833 0000024D CD21                    	int	21h
  1834                                  
  1835                                  		; DOS - 2+ - ALLOCATE MEMORY
  1836                                  		; BX = number of 16-byte paragraphs desired
  1837                                  
  1838                                  ; Bugbug: I just had a thought. If DOS or SHARE or somebody leaves
  1839                                  ; a hole, the batch segment COULD already be in the ideal place. We
  1840                                  ; could be making it worse! We're second-guessing where memory
  1841                                  ; allocations go, which might not be such a great idea. Is there
  1842                                  ; a strategy, short of doing something even worse like diddling
  1843                                  ; arena headers, where we can minimize the possibility of fragmentation
  1844                                  ; under all cases? Hmm..
  1845                                  	
  1846 0000024F 7220                    	jc	short adjust_env ; no memory, use old batchseg
  1847                                  
  1848 00000251 8EC0                    	mov	es,ax		 ; es = New batch segment
  1849 00000253 31FF                    	xor	di,di
  1850 00000255 31F6                    	xor	si,si
  1851                                  
  1852 00000257 1E                      	push	ds
  1853 00000258 8E1E[4C01]              	mov	ds,[Batch]	 ; ds = Old Batch Segment
  1854                                  	;assume	ds:nothing
  1855                                  	;mov	cx,SIZE BatchSegment
  1856                                  	; 23/01/2023
  1857                                  	;mov	cx,BATCHSEGMENT.SIZE
  1858                                  	;;mov	cx,33	; 09/01/2023
  1859                                  	;		; (MSDOS 5.0 COMMAND COM RESGROUP:0364h)
  1860                                  	;
  1861                                  	;add	cx,16		 ; for the filename
  1862                                  	; 20/04/2023
  1863 0000025C B93100                  	mov	cx,BATCHSEGMENT.SIZE+16 
  1864                                  
  1865                                  	; Bugbug: 16? Shouldn't this be a common equate or something?
  1866                                  	; It's sure be bad if we copied more bytes than the batch segment
  1867                                  	; holds!
  1868                                  	
  1869 0000025F FC                      	cld
  1870 00000260 F3A4                    	rep	movsb
  1871 00000262 1F                      	pop	ds
  1872                                  	;assume	ds:RESGROUP
  1873                                  
  1874 00000263 8CC1                    	mov	cx,es		; save new batch segment 
  1875 00000265 8E06[4C01]              	mov	es,[Batch]
  1876 00000269 B449                    	mov	ah,49h
  1877                                  	;mov	ah,DEALLOC
  1878 0000026B CD21                    	int	21h		; free the old batch segment
  1879                                  
  1880                                  	; Bugbug: should we check for error?
  1881                                  
  1882 0000026D 890E[4C01]              	mov	[Batch],cx	; store new batch segment address
  1883                                  
  1884                                  adjust_env:
  1885 00000271 59                      	pop	cx		; cx = size of old env ;M027
  1886 00000272 5B                      	pop	bx		; bx = size of new env needed ;M027
  1887 00000273 5D                      	pop	bp		; bp = old env seg ;M027
  1888                                  
  1889                                  ;Allocate the correct size for the environment
  1890                                  
  1891 00000274 B448                    	mov	ah,48h
  1892                                  	;mov	ah,ALLOC
  1893 00000276 CD21                    	int	21h		; get memory
  1894 00000278 7264                    	jc	short nomem_err	; out of memory,signal error
  1895                                  	
  1896                                  	; Bugbug: why not continue, leaving environment where it is?
  1897                                  
  1898 0000027A A3[3F03]                	mov	[EnvirSeg],ax	; Store new environment segment
  1899                                  	;;mov	[ds:2Ch],ax
  1900                                  	;mov	[2Ch],ax
  1901                                  	;mov	[PDB_Environ],ax ; Put new env seg in PSP
  1902 0000027D A32C00                  	mov	[PDB.ENVIRON],ax
  1903 00000280 8EC0                    	mov	es,ax		; es = address of allocated memory
  1904                                  	;assume	es:nothing
  1905                                  
  1906                                  ;Copy the environment to the newly allocated segment
  1907                                  
  1908 00000282 1E                      	push	ds
  1909 00000283 8EDD                    	mov	ds,bp		; ds = Old environment segment
  1910                                  	;assume	ds:nothing
  1911                                  
  1912 00000285 31F6                    	xor	si,si
  1913 00000287 89F7                    	mov	di,si		; Start transfer from 0
  1914                                  
  1915 00000289 FC                      	cld
  1916 0000028A F3A4                    	rep	movsb		; Do the copy
  1917                                  
  1918 0000028C 1F                      	pop	ds		; ds = RESGROUP
  1919                                  	;assume	ds:RESGROUP
  1920                                  
  1921                                  ; We have to free the old environment block if it was allocated by INIT
  1922                                  
  1923                                  ; Bugbug: is this only for the case when we were NOT passed an environment,
  1924                                  ; or does it also apply to passed environments?
  1925                                  
  1926                                  ;M036
  1927                                  ; Free up old env segment always because this is a copy passed by Exec and
  1928                                  ; takes up memory that is never used
  1929                                  
  1930                                  ;M044
  1931                                  ; Go back to the old strategy of not freeing the environment. Freeing it leaves
  1932                                  ; a hole behind that Ventura does not like. Basically, Ventura gives strange
  1933                                  ; errors if it gets a memory alloc that it is below its load segment. The
  1934                                  ; freed environment creates a large enough hole for some of its allocs to fit
  1935                                  ; in
  1936                                  
  1937                                  	;cmp	byte [AllocedEnv],0 ; has env been allocated by INIT?
  1938                                          ;je	short no_free	    ; no, do not free it
  1939                                  	; 21/01/2023
  1940                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0398h
  1941 0000028D 803E[7B1C]00            	cmp	byte [AllocedEnv],0 ; flag - old environment segment	
  1942 00000292 7506                    	jne	short no_free 
  1943                                  
  1944 00000294 8EC5                    	mov	es,bp
  1945 00000296 B449                    	mov	ah,49h
  1946                                  	;mov	ah,DEALLOC	
  1947 00000298 CD21                    	int	21h		    ; Free it
  1948                                  no_free:
  1949                                  
  1950                                  ; M004; Start of changes 
  1951                                  
  1952                                  ; Move the transient now. We will allocate the biggest block available
  1953                                  ; now and move the transient to the top of the block. We will then
  1954                                  ; deallocate this block. When the resident starts executing, it will
  1955                                  ; hopefully allocate this block again and find the transient intact.
  1956                                  
  1957 0000029A C606[9401]01            	mov	byte [TrnMvFlg],1   ; Indicate that transient has been moved
  1958 0000029F 06                      	push	es
  1959                                  	;;mov	si,offset ResGroup:TranStart
  1960                                  	; 09/01/2023
  1961                                  	;mov	si,2320h	; MSDOS 5.0 COMMAND.COM RESGROUP:03ABh
  1962 000002A0 BE2022                  	mov	si,TRANSTART	    ; (End of the resident portion)
  1963                                  	;mov	di,0
  1964 000002A3 31FF                    	xor	di,di ; 0
  1965                                  	;;mov	cx,offset TranGroup:TranSpaceEnd ; size to move
  1966                                  	;mov	cx,98C5h
  1967 000002A5 B9EB95                  	mov	cx,TRANSPACEEND
  1968                                  	
  1969                                  ; Find the largest block available
  1970                                  
  1971 000002A8 BBFFFF                  	mov	bx,0FFFFh
  1972 000002AB B448                    	mov	ah,48h
  1973                                  	;mov	ah,ALLOC
  1974 000002AD CD21                    	int	21h
  1975                                  
  1976                                  ; dx = size of transient saved previously 
  1977                                  
  1978 000002AF 39D3                    	cmp	bx,dx		; enough memory?
  1979 000002B1 722B                    	jb	short nomem_err	; not enough memory for transient
  1980                                  
  1981 000002B3 B448                    	mov	ah,48h
  1982                                  	;mov	ah,ALLOC
  1983 000002B5 CD21                    	int	21h		; get the largest block
  1984 000002B7 7225                    	jc	short nomem_err	; something is really screwed up
  1985                                  
  1986 000002B9 50                      	push	ax		; save memory address
  1987 000002BA 01D8                    	add	ax,bx		; ax = top of my memory block
  1988 000002BC 29D0                    	sub	ax,dx		; less size of transient
  1989 000002BE A3[9201]                	mov	[TrnSeg],ax	; save transient segment
  1990 000002C1 8EC0                    	mov	es,ax		;
  1991 000002C3 58                      	pop	ax		; restore our seg addr
  1992                                  
  1993                                  ; Everything is set for a move. We need to move in the reverse direction to
  1994                                  ; make sure we dont overwrite ourselves while copying
  1995                                  
  1996 000002C4 01CE                    	add	si,cx
  1997 000002C6 4E                      	dec	si
  1998 000002C7 01CF                    	add	di,cx
  1999 000002C9 4F                      	dec	di
  2000 000002CA FD                      	std
  2001 000002CB F3A4                    	rep	movsb
  2002 000002CD FC                      	cld
  2003                                  
  2004                                  ; Now we have to free up this block so that resident can get hold of it
  2005                                  
  2006 000002CE 8EC0                    	mov	es,ax
  2007 000002D0 B449                    	mov	ah,49h
  2008                                  	;mov	ah,DEALLOC
  2009 000002D2 CD21                    	int	21h		; release the memory block
  2010                                  
  2011                                  ; M004; End of changes
  2012                                  
  2013                                  	;mov	InitFlag,FALSE	; indicate INIT is done
  2014                                  	; 09/01/2023
  2015 000002D4 C606[1702]00            	mov	byte [InitFlag],0	
  2016                                  
  2017 000002D9 07                      	pop	es
  2018 000002DA 1F                      	pop	ds
  2019                                  	;assume	ds:nothing
  2020                                  	
  2021                                  	; Bugbug: did we need to save & restore seg reg's during EndInit?
  2022                                  	
  2023 000002DB E9A0FD                  	jmp	LodCom_Trap	; allocate transient
  2024                                  
  2025                                  nomem_err:
  2026                                  
  2027                                  ;We call the error routine which will never return. It will either exit
  2028                                  ;with an error ( if not the first COMMAND ) or just hang after an error 
  2029                                  ;message ( if first COMMAND )
  2030                                  
  2031 000002DE E90619                  	jmp	Alloc_error
  2032                                  
  2033                                  ;EndCodeInit:	; label	byte		; M004
  2034                                  
  2035                                  	; 16/04/2023
  2036                                  	EndCodeInit equ $
  2037                                  
  2038                                  ;; M004; Check if the EndInit code will fit into the Pipe buffers above.
  2039                                  ;; M004; If not, we signal an assembly error
  2040                                  ;
  2041                                  ;IF2
  2042                                  ;	IF ($ GT EndPipe)
  2043                                  ;		.err
  2044                                  ;		%out	"ENDINIT CODE TOO BIG"
  2045                                  ;	ENDIF
  2046                                  ;ENDIF
  2047                                  
  2048                                  ;; M004; Set the origin back to what it was at the end of the buffers
  2049                                  ;;
  2050                                  ;		ORG	EndPipe		; M004
  2051                                  
  2052                                  ; 09/01/2023
  2053                                  
  2054                                  ; MSDOS 5.0 COMMAND.COM - CODERES:03EDh
  2055                                  ;	times 84 db 0	; db (EndPipe-EndCodeInit) dup(0)
  2056                                  
  2057                                  ; 16/04/2023
  2058                                  	FillBytes equ EndPipe - EndCodeInit			
  2059                                  
  2060                                  ;%if EndCodeInit<EndPipe ; if (EndCodeInit < (EndInit+289))
  2061                                  ; 16/04/2023
  2062                                  %if FillBytes>0
  2063                                  	;times EndPipe - EndCodeInit db 0
  2064 000002E1 00<rep 5Ah>             	times FillBytes db 0   
  2065                                  %endif
  2066                                  
  2067                                  ; 09/01/2023 - Retrodos v4.0 (& v4.1)
  2068                                  ; MSDOS 5.0 COMMAND.COM - CODERES:0441h ; EndInit+289 
  2069                                  
  2070                                  ;InPipePtr	dw	offset DATARES:Pipe1	; 320h 
  2071                                  ;OutPipePtr	dw	offset DATARES:Pipe2	; 36Fh
  2072                                  
  2073 0000033B [1A02]                  InPipePtr:	dw	Pipe1 ; 320h for MSDOS 5.0 COMMAND.COM
  2074 0000033D [6902]                  OutPipePtr:	dw	Pipe2 ; 36Fh for MSDOS 5.0 COMMAND.COM
  2075                                  
  2076                                  Exec_Block:	; label	byte	; the data block for exec calls
  2077 0000033F 0000                    EnvirSeg:	dw	0
  2078                                  Com_Ptr:	; label	dword
  2079 00000341 8000                    		dw	80h	; point at unformatted parameters
  2080 00000343 0000                    		dw	0
  2081                                  Com_Fcb1:	; label	dword
  2082 00000345 5C00                    		dw	5Ch
  2083 00000347 0000                    		dw	0
  2084                                  Com_Fcb2:	; label	dword
  2085 00000349 6C00                    		dw	6Ch
  2086 0000034B 0000                    		dw	0
  2087                                  
  2088                                  ; variables passed to transient
  2089                                  TranVars:	; label	byte			
  2090                                  		;dw	offset DATARES:HeadFix_Trap
  2091 0000034D [9200]                  		dw	HeadFix_Trap
  2092 0000034F 0000                    MySeg:		dw	0	; put our own segment here
  2093 00000351 0000                    LTpa:		dw	0	; will store tpa segment here
  2094 00000353 2F                      RSwitChar:	db	"/"
  2095 00000354 5C                      RDirChar:	db	"\"
  2096                                  		;dw	offset DATARES:Issue_Exec_Call
  2097 00000355 [D700]                  		dw	Issue_Exec_Call
  2098 00000357 0000                    MySeg1:		dw	0
  2099                                  		;dw	offset DATARES:RemCheck_Trap
  2100 00000359 [6A00]                  		dw	RemCheck_Trap
  2101 0000035B 0000                    MySeg2:		dw	0
  2102 0000035D 0000                    ResTest: 	dw	0
  2103 0000035F 0000                    Res_Tpa:	dw	0	; original tpa (not rounded to 64k)
  2104                                  TranVarEnd:	; label	byte
  2105                                  
  2106 00000361 0000                    OldErrNo:	dw	0
  2107                                  
  2108                                  ;* NOTE: MsgBuffer and SafePathBuffer use the same memory.
  2109                                  ;  MsgBuffer is only used while a command is being executed.
  2110                                  ;  SafePathBuffer is no longer needed, since it is used for
  2111                                  ;  unsuccessful program launches.
  2112                                  
  2113                                  MsgBuffer:	; label	byte	; buffer for messages from disk
  2114                                  SafePathBuffer: ; label	byte	; resident pathname for EXEC
  2115                                  	;Bugbug: Why so big a buffer?
  2116                                  		;db	64+3+13 dup (0)	; path + 'd:\' 'file.ext' + null
  2117 00000363 00<rep 50h>             		times	64+3+13 db 0		
  2118                                  
  2119                                  LENMSGORPATHBUF	equ $ - MsgBuffer
  2120                                  
  2121 000003B3 00000000                Int2fHandler:	dd	0	; address of next int 2f handler
  2122 000003B7 0000                    ResMsgEnd:	dw	0	; holds offset of msg end (end of resident)
  2123                                  
  2124                                  ;SR;
  2125                                  ; The three vars below have been added for a pure COMMAND.COM
  2126                                  
  2127 000003B9 0000                    ResSize:	dw	0
  2128                                  
  2129                                  ;SR;
  2130                                  ; Moved the stack here from the code segment
  2131                                  ;
  2132                                  ; bugbug: Why this odd stack size? And what should stack size be?
  2133                                  	
  2134                                  		;db	(80h - 3) dup (?)
  2135 000003BB 90                      align 2
  2136 000003BC 00<rep 7Ch>             		times	124 db 0		
  2137                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:053Eh (offset RStack)
  2138                                  RStack:		; label	word
  2139 00000438 0000                    OldDS:		dw	0	; keeps old ds value when jumping to
  2140                                  				; resident code segments
  2141                                  ;LoadHiFlg	db	0	; Flag set to 1 if UMB loading enabled ; M003
  2142                                  
  2143                                  ; include highvar.inc		; Add variables for 6.0 loadhigh functionality
  2144                                  ; -------------------------------
  2145                                  
  2146                                  ; fInHigh  - Is set to 1 during HideUMBs(), and back to zero in UnHideUMBs().
  2147                                  ; fUmbTiny - Is set to 1 if the user has specified /S on the command line.
  2148                                  ; SegLoad  - Segment address for first UMB specified; set automatically.
  2149                                  ; UmbLoad  - The load UMB number; for example, this is 3 if the user has
  2150                                  ;            given a command-line like "/L:3,500;4"
  2151                                  ; UmbUsed  - An array of characters, each of which is 1 iff the UMB
  2152                                  ;            matching its index number was specified on the command-line;
  2153                                  ;            for example, after "/L:3,500;4;7", UmbUsed[3], [4] and [7]
  2154                                  ;            will be set to 1.  All others will be set to 0.
  2155                                  ; UmbSize  - An array of words, each of which is interpereted as a size
  2156                                  ;            specified by the user for a UMB (in the above example, all
  2157                                  ;            elements would be zero save UmbSize[3], which would be 500.
  2158                                  ; fm_umb   - Set to the old UMB link-state (0x80 or 0x00)
  2159                                  ; fm_strat - Set to the old memory-allocation strategy (0$00000???)
  2160                                  ; fm_argc  - Number of arguments received by ParseVar() (see ParseVar()
  2161                                  ;            for details).
  2162                                  
  2163                                  ; - MSDOS 6.0 COMMAND.COM -
  2164                                  ;; To keep track of which UMBs were specified on the DH/LH command lines, and
  2165                                  ;; to keep track of the minimum sizes given for each, there're two arrays kept
  2166                                  ;; in { IO.SYS: sysinitseg / COMMAND.COM: DATARES }... each is MAXUMB elements
  2167                                  ;; big. 16 should be around 14 too many for most users, so there's no expected
  2168                                  ;; space problem (it's just such a nice round number, eh?).
  2169                                  
  2170                                  ;MAXUMB	equ	16
  2171                                  
  2172                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2173                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0540h (DATARES:0540h)
  2174                                  
  2175 0000043A 00                      fInHigh:	db	0
  2176                                  
  2177                                  ; MSDOS 6.0 COMMAND.COM
  2178                                  ;fUmbTiny:	db	0
  2179                                  ;SegLoad:	dw	0
  2180                                  ;UmbLoad:	db	0
  2181                                  ;UmbUsed:	db	times MAXUMB db 0 ; db MAXUMB dup (?)
  2182                                  ;UmbSize:	dw	times MAXUMB dw 0 ; dw MAXUMB dup (?)
  2183                                  ;fm_umb:	db	0
  2184                                  ;fm_strat:	db	0
  2185                                  ;fm_argc:	db	0
  2186                                  
  2187                                  ; UmbLoad is set to UNSPECIFED, below, until /L:umb is read; at which point
  2188                                  ; UmbLoad is set to the UMB number given.
  2189                                  
  2190                                  ;*** MESSAGES
  2191                                  ;    and other translatable text
  2192                                  
  2193                                  ; include comrmsg.inc	; M00
  2194                                  ; ------------------------------
  2195                                  
  2196                                  ; 10/01/2023 - Retro DOS v4.0 COMMAND.COM
  2197                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0541h (DATARES:0541h)
  2198                                  
  2199 0000043B 41                      ABORT_CHAR:	db 'A'
  2200 0000043C 52                      RETRY_CHAR:	db 'R'
  2201 0000043D 49                      IGNORE_CHAR:	db 'I'
  2202 0000043E 46                      FAIL_CHAR:	db 'F'
  2203 0000043F 59                      YES_CHAR:	db 'Y'
  2204 00000440 4E                      NO_CHAR:	db 'N'
  2205 00000441 05                      REQ_ABORT:	db 5
  2206 00000442 41626F7274              		db 'Abort'
  2207 00000447 07                      REQ_RETRY:	db 7
  2208 00000448 2C205265747279          		db ', Retry'
  2209 0000044F 08                      REQ_IGNORE:	db 8
  2210 00000450 2C2049676E6F7265        		db ', Ignore'
  2211 00000458 06                      REQ_FAIL:	db 6
  2212 00000459 2C204661696C            		db ', Fail'
  2213 0000045F 01                      REQ_END:	db 1
  2214 00000460 3F                      		db '?'
  2215 00000461 08                      MREAD:		db 8
  2216 00000462 72656164696E6700        		db 'reading', 0
  2217 0000046A 08                      MWRITE:		db 8
  2218 0000046B 77726974696E6700        		db 'writing', 0
  2219 00000473 0E                      MDRIVE:		db 14
  2220 00000474 202531206472697665-     		db ' %1 drive %2',0Dh,0Ah
  2220 0000047D 2025320D0A         
  2221 00000482 0F                      MDEVICE:	db 15
  2222 00000483 202531206465766963-     		db ' %1 device %2',0Dh,0Ah
  2222 0000048C 652025320D0A       
  2223 00000492 26                      MVOLSERIAL:	db 38
  2224 00000493 506C6561736520696E-     		db 'Please insert volume %1 serial %2-%3',0Dh,0Ah
  2224 0000049C 7365727420766F6C75-
  2224 000004A5 6D6520253120736572-
  2224 000004AE 69616C2025322D2533-
  2224 000004B7 0D0A               
  2225 000004B9 25                      BADFATMSG:	db 37
  2226 000004BA 46696C6520616C6C6F-     		db 'File allocation table bad, drive %1',0Dh,0Ah
  2226 000004C3 636174696F6E207461-
  2226 000004CC 626C65206261642C20-
  2226 000004D5 64726976652025310D-
  2226 000004DE 0A                 
  2227 000004DF 15                      COMBAD:		db 21
  2228 000004E0 496E76616C69642043-     		db 'Invalid COMMAND.COM',0Dh,0Ah
  2228 000004E9 4F4D4D414E442E434F-
  2228 000004F2 4D0D0A             
  2229 000004F5 21                      PUTBACKMSG:	db 33
  2230 000004F6 496E73657274206469-     		db 'Insert disk with %1 in drive %2',0Dh,0Ah
  2230 000004FF 736B20776974682025-
  2230 00000508 3120696E2064726976-
  2230 00000511 652025320D0A       
  2231 00000517 21                      PROMPT:		db 33
  2232 00000518 507265737320616E79-     		db 'Press any key to continue . . .',0Dh,0Ah
  2232 00000521 206B657920746F2063-
  2232 0000052A 6F6E74696E7565202E-
  2232 00000533 202E202E0D0A       
  2233 00000539 1C                      ENDBATMES:	db 28
  2234 0000053A 0D0A                    		db 0Dh,0Ah
  2235 0000053C 5465726D696E617465-     		db 'Terminate batch job (Y/N)?'
  2235 00000545 206261746368206A6F-
  2235 0000054E 622028592F4E293F   
  2236 00000556 13                      EXECEMES:	db 19
  2237 00000557 43616E6E6F74206578-     		db 'Cannot execute %1',0Dh,0Ah
  2237 00000560 65637574652025310D-
  2237 00000569 0A                 
  2238 0000056A 13                      EXEBAD:		db 19
  2239 0000056B 4572726F7220696E20-     		db 'Error in EXE file',0Dh,0Ah
  2239 00000574 4558452066696C650D-
  2239 0000057D 0A                 
  2240 0000057E 22                      TOOBIG:		db 34
  2241 0000057F 50726F6772616D2074-     		db 'Program too big to fit in memory',0Dh,0Ah
  2241 00000588 6F6F2062696720746F-
  2241 00000591 2066697420696E206D-
  2241 0000059A 656D6F72790D0A     
  2242 000005A1 16                      NOHANDMES:	db 22
  2243 000005A2 0D0A                    		db 0Dh,0Ah
  2244 000005A4 4E6F20667265652066-     		db 'No free file handles'
  2244 000005AD 696C652068616E646C-
  2244 000005B6 6573               
  2245 000005B8 1A                      RBADNAM:	db 26
  2246 000005B9 42616420436F6D6D61-     		db 'Bad Command or file name',0Dh,0Ah
  2246 000005C2 6E64206F722066696C-
  2246 000005CB 65206E616D650D0A   
  2247                                  ACCDENIED:	; 14/01/2023
  2248                                  		; 10/01/2023
  2249 000005D3 0E                      ACCDEN:		db 14
  2250 000005D4 416363657373206465-     		db 'Access denied '
  2250 000005DD 6E69656420         
  2251 000005E2 19                      BMEMMES:	db 25
  2252 000005E3 0D0A4D656D6F727920-     		db 0Dh,0Ah,'Memory allocation error'
  2252 000005EC 616C6C6F636174696F-
  2252 000005F5 6E206572726F72     
  2253 000005FC 26                      HALTMES:	db 38
  2254 000005FD 0D0A                    		db 0Dh,0Ah
  2255 000005FF 43616E6E6F74206C6F-     		db 'Cannot load COMMAND, system halted',0Dh,0Ah
  2255 00000608 616420434F4D4D414E-
  2255 00000611 442C2073797374656D-
  2255 0000061A 2068616C7465640D0A 
  2256 00000623 21                      FRETMES:	db 33
  2257 00000624 0D0A                    		db 0Dh,0Ah,
  2258 00000626 43616E6E6F74207374-     		db 'Cannot start COMMAND, exiting',0Dh,0Ah
  2258 0000062F 61727420434F4D4D41-
  2258 00000638 4E442C206578697469-
  2258 00000641 6E670D0A           
  2259 00000645 2E                      PATRICIDE:	db 46
  2260 00000646 0D0A                    		db 0Dh,0Ah
  2261 00000648 546F70206C6576656C-     		db 'Top level process aborted, cannot continue'
  2261 00000651 2070726F6365737320-
  2261 0000065A 61626F727465642C20-
  2261 00000663 63616E6E6F7420636F-
  2261 0000066C 6E74696E7565       
  2262 00000672 0D0A                    		db 0Dh,0Ah
  2263 00000674 02                      NEWLINE:	db 2
  2264 00000675 0D0A                    		db 0Dh, 0Ah
  2265                                  
  2266                                  ; 10/01/2023
  2267                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:077Dh
  2268                                  
  2269 00000677 [5B0B]                  MsgPtrLists:	dw EXTMSGPTRS		; extended error messages
  2270 00000679 0100                    		dw 1
  2271 0000067B [1609]                  		dw PARSMSGPTRS		; parse	error messages
  2272 0000067D 0100                    		dw 1
  2273 0000067F [5B0B]                  		dw EXTMSGPTRS		; critical error messages
  2274 00000681 0100                    		dw 1
  2275 00000683 0000                    		dw 0			; File system error messages
  2276 00000685 0000                    		dw 0			; are not supported.
  2277 00000687 [8800]                  		dw MsgRetrv_Trap	; disk retriever routine
  2278 00000689 0000                    MySeg3:		dw 0			; segment of retriever routine
  2279                                  
  2280                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0791h
  2281                                  
  2282 0000068B 13                      CRMSG0:		db 19
  2283 0000068C 57726974652070726F-     		db 'Write protect error'
  2283 00000695 74656374206572726F-
  2283 0000069E 72                 
  2284 0000069F 0C                      CRMSG1:		db 12
  2285 000006A0 496E76616C69642075-     		db 'Invalid unit'
  2285 000006A9 6E6974             
  2286 000006AC 09                      CRMSG2:		db 9
  2287 000006AD 4E6F74207265616479      		db 'Not ready'
  2288 000006B6 16                      CRMSG3:		db 22
  2289 000006B7 496E76616C69642064-     		db 'Invalid device request'
  2289 000006C0 657669636520726571-
  2289 000006C9 75657374           
  2290 000006CD 0A                      CRMSG4:		db 10
  2291 000006CE 44617461206572726F-     		db 'Data error'
  2291 000006D7 72                 
  2292 000006D8 21                      CRMSG5:		db 33
  2293 000006D9 496E76616C69642064-     		db 'Invalid device request parameters'
  2293 000006E2 657669636520726571-
  2293 000006EB 756573742070617261-
  2293 000006F4 6D6574657273       
  2294 000006FA 0A                      CRMSG6:		db 10
  2295 000006FB 5365656B206572726F-     		db 'Seek error'
  2295 00000704 72                 
  2296 00000705 12                      CRMSG7:		db 18
  2297 00000706 496E76616C6964206D-     		db 'Invalid media type'
  2297 0000070F 656469612074797065 
  2298 00000718 10                      CRMSG8:		db 16
  2299 00000719 536563746F72206E6F-     		db 'Sector not found'
  2299 00000722 7420666F756E64     
  2300 00000729 1A                      CRMSG9:		db 26
  2301 0000072A 5072696E746572206F-     		db 'Printer out of paper error'
  2301 00000733 7574206F6620706170-
  2301 0000073C 6572206572726F72   
  2302 00000744 11                      CRMSG10:	db 17
  2303 00000745 577269746520666175-     		db 'Write fault error'
  2303 0000074E 6C74206572726F72   
  2304 00000756 10                      CRMSG11:	db 16
  2305 00000757 52656164206661756C-     		db 'Read fault error'
  2305 00000760 74206572726F72     
  2306 00000767 0F                      CRMSG12:	db 15
  2307 00000768 47656E6572616C2066-     		db 'General failure'
  2307 00000771 61696C757265       
  2308 00000777 11                      CRMSG13:	db 17
  2309 00000778 53686172696E672076-     		db 'Sharing violation'
  2309 00000781 696F6C6174696F6E   
  2310 00000789 0E                      CRMSG14:	db 14
  2311 0000078A 4C6F636B2076696F6C-     		db 'Lock violation'
  2311 00000793 6174696F6E         
  2312 00000798 13                      CRMSG15:	db 19
  2313 00000799 496E76616C69642064-     		db 'Invalid disk change'
  2313 000007A2 69736B206368616E67-
  2313 000007AB 65                 
  2314 000007AC 0F                      CRMSG16:	db 15
  2315 000007AD 46434220756E617661-     		db 'FCB unavailable'
  2315 000007B6 696C61626C65       
  2316 000007BC 19                      CRMSG17:	db 25
  2317 000007BD 53797374656D207265-     		db 'System resource exhausted'
  2317 000007C6 736F75726365206578-
  2317 000007CF 68617573746564     
  2318 000007D6 12                      CRMSG18:	db 18
  2319 000007D7 436F64652070616765-     		db 'Code page mismatch'
  2319 000007E0 206D69736D61746368 
  2320 000007E9 0C                      CRMSG19:	db 12
  2321 000007EA 4F7574206F6620696E-     		db 'Out of input'
  2321 000007F3 707574             
  2322 000007F6 17                      CRMSG20:	db 23
  2323 000007F7 496E73756666696369-     		db 'Insufficient disk space'
  2323 00000800 656E74206469736B20-
  2323 00000809 7370616365         
  2324                                  
  2325                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0914h
  2326                                  
  2327 0000080E [8B06]                  CRITMSGPTRS:	dw CRMSG0
  2328 00000810 [9F06]                  		dw CRMSG1
  2329 00000812 [AC06]                  		dw CRMSG2
  2330 00000814 [B606]                  		dw CRMSG3
  2331 00000816 [CD06]                  		dw CRMSG4
  2332 00000818 [D806]                  		dw CRMSG5
  2333 0000081A [FA06]                  		dw CRMSG6
  2334 0000081C [0507]                  		dw CRMSG7
  2335 0000081E [1807]                  		dw CRMSG8
  2336 00000820 [2907]                  		dw CRMSG9
  2337 00000822 [4407]                  		dw CRMSG10
  2338 00000824 [5607]                  		dw CRMSG11
  2339 00000826 [6707]                  		dw CRMSG12
  2340 00000828 [7707]                  		dw CRMSG13
  2341 0000082A [8907]                  		dw CRMSG14
  2342 0000082C [9807]                  		dw CRMSG15
  2343 0000082E [AC07]                  		dw CRMSG16
  2344 00000830 [BC07]                  		dw CRMSG17
  2345 00000832 [D607]                  		dw CRMSG18
  2346 00000834 [E907]                  		dw CRMSG19
  2347 00000836 [F607]                  		dw CRMSG20
  2348                                  
  2349                                  		; 14/01/2023
  2350                                  DataresEnd:	; MSDOS 5.0 COMMAND.COM - DATARES:093Eh (RESGROUP:093Eh)
  2351                                  
  2352 00000838 13                      PAERRMSG0:	db 19
  2353 00000839 546F6F206D616E7920-     		db 'Too many parameters'
  2353 00000842 706172616D65746572-
  2353 0000084B 73                 
  2354 0000084C 1A                      PAERRMSG1:	db 26
  2355 0000084D 526571756972656420-     		db 'Required parameter missing'
  2355 00000856 706172616D65746572-
  2355 0000085F 206D697373696E67   
  2356 00000867 0E                      PAERRMSG2:	db 14
  2357 00000868 496E76616C69642073-     		db 'Invalid switch'
  2357 00000871 7769746368         
  2358 00000876 0F                      PAERRMSG3:	db 15
  2359 00000877 496E76616C6964206B-     		db 'Invalid keyword'
  2359 00000880 6579776F7264       
  2360 00000886 01                      PAERRMSG4:	db 1
  2361 00000887 20                      		db 20h
  2362 00000888 24                      PAERRMSG5:	db 36
  2363 00000889 506172616D65746572-     		db 'Parameter value not in allowed range'
  2363 00000892 2076616C7565206E6F-
  2363 0000089B 7420696E20616C6C6F-
  2363 000008A4 7765642072616E6765 
  2364                                  PAERRMSG6:	; 10/01/2023
  2365 000008AD 1B                      PAERRMSG7:	db 27
  2366 000008AE 506172616D65746572-     		db 'Parameter value not allowed'
  2366 000008B7 2076616C7565206E6F-
  2366 000008C0 7420616C6C6F776564 
  2367                                  ;PAERRMSG7:	db 27
  2368                                  ;		db 'Parameter value not allowed'
  2369 000008C9 1C                      PAERRMSG8:	db 28
  2370 000008CA 506172616D65746572-     		db 'Parameter format not correct'
  2370 000008D3 20666F726D6174206E-
  2370 000008DC 6F7420636F72726563-
  2370 000008E5 74                 
  2371 000008E6 11                      PAERRMSG9:	db 17
  2372 000008E7 496E76616C69642070-     		db 'Invalid parameter'
  2372 000008F0 6172616D65746572   
  2373 000008F8 1D                      PAERRMSG10:	db 29
  2374 000008F9 496E76616C69642070-     		db 'Invalid parameter combination'
  2374 00000902 6172616D6574657220-
  2374 0000090B 636F6D62696E617469-
  2374 00000914 6F6E               
  2375                                  
  2376                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0A38h
  2377                                  
  2378 00000916 [3808]                  PARSMSGPTRS:	dw PAERRMSG0
  2379 00000918 [4C08]                  		dw PAERRMSG1
  2380 0000091A [6708]                  		dw PAERRMSG2
  2381 0000091C [7608]                  		dw PAERRMSG3
  2382 0000091E [8608]                  		dw PAERRMSG4
  2383 00000920 [8808]                  		dw PAERRMSG5
  2384 00000922 [AD08]                  		dw PAERRMSG6
  2385 00000924 [AD08]                  		dw PAERRMSG7
  2386 00000926 [C908]                  		dw PAERRMSG8
  2387 00000928 [E608]                  		dw PAERRMSG9
  2388 0000092A [F808]                  		dw PAERRMSG10
  2389                                  ; 21/04/2023
  2390                                  NUMPARSMSGS equ ($-PARSMSGPTRS)>>1 ; 14/01/2023
  2391                                  
  2392 0000092C 10                      INVLFUNCT:	db 16
  2393 0000092D 496E76616C69642066-     		db 'Invalid function'
  2393 00000936 756E6374696F6E     
  2394 0000093D 0E                      FNOTFOUND:	db 14
  2395 0000093E 46696C65206E6F7420-     		db 'File not found'
  2395 00000947 666F756E64         
  2396 0000094C 0E                      PNOTFOUND:	db 14
  2397 0000094D 50617468206E6F7420-     		db 'Path not found'
  2397 00000956 666F756E64         
  2398 0000095B 13                      TOOMANYOF:	db 19
  2399 0000095C 546F6F206D616E7920-     		db 'Too many open files'
  2399 00000965 6F70656E2066696C65-
  2399 0000096E 73                 
  2400                                  ; 14/01/2023
  2401                                  ;ACCDEN:	; 10/01/2023
  2402                                  ;ACCDENIED:	db 14
  2403                                  ;		db 'Access denied '
  2404 0000096F 0E                      INVHANDLE:	db 14
  2405 00000970 496E76616C69642068-     		db 'Invalid handle'
  2405 00000979 616E646C65         
  2406 0000097E 1F                      MEMCBDEST:	db 31
  2407 0000097F 4D656D6F727920636F-     		db 'Memory control blocks destroyed'
  2407 00000988 6E74726F6C20626C6F-
  2407 00000991 636B73206465737472-
  2407 0000099A 6F796564           
  2408 0000099E 13                      INSUFFMEM:	db 19
  2409 0000099F 496E73756666696369-     		db 'Insufficient memory'
  2409 000009A8 656E74206D656D6F72-
  2409 000009B1 79                 
  2410 000009B2 1C                      INVMEMBLA:	db 28
  2411 000009B3 496E76616C6964206D-     		db 'Invalid memory block address'
  2411 000009BC 656D6F727920626C6F-
  2411 000009C5 636B20616464726573-
  2411 000009CE 73                 
  2412 000009CF 13                      INVENVIRO:	db 19
  2413 000009D0 496E76616C69642045-     		db 'Invalid Environment'
  2413 000009D9 6E7669726F6E6D656E-
  2413 000009E2 74                 
  2414 000009E3 0E                      INVFORMAT:	db 14
  2415 000009E4 496E76616C69642066-     		db 'Invalid format'
  2415 000009ED 6F726D6174         
  2416 000009F2 1A                      INVFNPARM:	db 26
  2417 000009F3 496E76616C69642066-     		db 'Invalid function parameter'
  2417 000009FC 756E6374696F6E2070-
  2417 00000A05 6172616D65746572   
  2418 00000A0D 0C                      INVLDDATA:	db 12
  2419 00000A0E 496E76616C69642064-     		db 'Invalid data'
  2419 00000A17 617461             
  2420 00000A1A 1B                      INVDRVSPC:	db 27
  2421 00000A1B 496E76616C69642064-     		db 'Invalid drive specification'
  2421 00000A24 726976652073706563-
  2421 00000A2D 696669636174696F6E 
  2422 00000A36 23                      ATRCURDIR:	db 35
  2423 00000A37 417474656D70742074-     		db 'Attempt to remove current directory'
  2423 00000A40 6F2072656D6F766520-
  2423 00000A49 63757272656E742064-
  2423 00000A52 69726563746F7279   
  2424 00000A5A 0F                      NOTSAMDEV:	db 15
  2425 00000A5B 4E6F742073616D6520-     		db 'Not same device'
  2425 00000A64 646576696365       
  2426 00000A6A 0D                      NOMOREFIL:	db 13
  2427 00000A6B 4E6F206D6F72652066-     		db 'No more files'
  2427 00000A74 696C6573           
  2428 00000A78 0B                      FILEXISTS:	db 11
  2429 00000A79 46696C652065786973-     		db 'File exists'
  2429 00000A82 7473               
  2430 00000A84 1B                      CANTMKDIR:	db 27
  2431 00000A85 43616E6E6F74206D61-     		db 'Cannot make directory entry'
  2431 00000A8E 6B6520646972656374-
  2431 00000A97 6F727920656E747279 
  2432 00000AA0 0E                      FAILINT24:	db 14
  2433 00000AA1 4661696C206F6E2049-     		db 'Fail on INT 24'
  2433 00000AAA 4E54203234         
  2434 00000AAF 15                      TOOMANYRD:	db 21
  2435 00000AB0 546F6F206D616E7920-     		db 'Too many redirections'
  2435 00000AB9 726564697265637469-
  2435 00000AC2 6F6E73             
  2436 00000AC5 15                      DUPLREDIR:	db 21
  2437 00000AC6 4475706C6963617465-     		db 'Duplicate redirection'
  2437 00000ACF 207265646972656374-
  2437 00000AD8 696F6E             
  2438 00000ADB 10                      INVPASSWD:	db 16
  2439 00000ADC 496E76616C69642070-     		db 'Invalid password'
  2439 00000AE5 617373776F7264     
  2440 00000AEC 11                      INVLDPARM:	db 17
  2441 00000AED 496E76616C69642070-     		db 'Invalid parameter'
  2441 00000AF6 6172616D65746572   
  2442 00000AFE 12                      NETDATFAU:	db 18
  2443 00000AFF 4E6574776F726B2064-     		db 'Network data fault'
  2443 00000B08 617461206661756C74 
  2444 00000B11 21                      FNOSUPNET:	db 33
  2445 00000B12 46756E6374696F6E20-     		db 'Function not supported by network'
  2445 00000B1B 6E6F7420737570706F-
  2445 00000B24 72746564206279206E-
  2445 00000B2D 6574776F726B       
  2446 00000B33 27                      RSCNOTINS:	db 39
  2447 00000B34 526571756972656420-     		db 'Required system component not installed'
  2447 00000B3D 73797374656D20636F-
  2447 00000B46 6D706F6E656E74206E-
  2447 00000B4F 6F7420696E7374616C-
  2447 00000B58 6C6564             
  2448                                  
  2449                                  ; MSDOS 5.0 COMMAND.COM RESGROUP:0C8Ch
  2450                                  
  2451 00000B5B [2C09]                  EXTMSGPTRS:	dw INVLFUNCT
  2452 00000B5D [3D09]                  		dw FNOTFOUND
  2453 00000B5F [4C09]                  		dw PNOTFOUND
  2454 00000B61 [5B09]                  		dw TOOMANYOF
  2455 00000B63 [D305]                  		dw ACCDENIED
  2456 00000B65 [6F09]                  		dw INVHANDLE
  2457 00000B67 [7E09]                  		dw MEMCBDEST
  2458 00000B69 [9E09]                  		dw INSUFFMEM
  2459 00000B6B [B209]                  		dw INVMEMBLA
  2460 00000B6D [CF09]                  		dw INVENVIRO
  2461 00000B6F [E309]                  		dw INVFORMAT
  2462 00000B71 [F209]                  		dw INVFNPARM
  2463 00000B73 [0D0A]                  		dw INVLDDATA
  2464 00000B75 0000                    		dw 0
  2465 00000B77 [1A0A]                  		dw INVDRVSPC
  2466 00000B79 [360A]                  		dw ATRCURDIR
  2467 00000B7B [5A0A]                  		dw NOTSAMDEV
  2468 00000B7D [6A0A]                  		dw NOMOREFIL
  2469 00000B7F [8B06]                  		dw CRMSG0
  2470 00000B81 [9F06]                  		dw CRMSG1
  2471 00000B83 [AC06]                  		dw CRMSG2
  2472 00000B85 [B606]                  		dw CRMSG3
  2473 00000B87 [CD06]                  		dw CRMSG4
  2474 00000B89 [D806]                  		dw CRMSG5
  2475 00000B8B [FA06]                  		dw CRMSG6
  2476 00000B8D [0507]                  		dw CRMSG7
  2477 00000B8F [1807]                  		dw CRMSG8
  2478 00000B91 [2907]                  		dw CRMSG9
  2479 00000B93 [4407]                  		dw CRMSG10
  2480 00000B95 [5607]                  		dw CRMSG11
  2481 00000B97 [6707]                  		dw CRMSG12
  2482 00000B99 [7707]                  		dw CRMSG13
  2483 00000B9B [8907]                  		dw CRMSG14
  2484 00000B9D [9807]                  		dw CRMSG15
  2485 00000B9F [AC07]                  		dw CRMSG16
  2486 00000BA1 [BC07]                  		dw CRMSG17
  2487 00000BA3 [D607]                  		dw CRMSG18
  2488 00000BA5 [E907]                  		dw CRMSG19
  2489 00000BA7 [F607]                  		dw CRMSG20
  2490 00000BA9 0000<rep 28h>           		times 40 dw 0	; db 80 dup(0)
  2491 00000BF9 [780A]                  		dw FILEXISTS
  2492 00000BFB 0000                    		dw 0
  2493 00000BFD [840A]                  		dw CANTMKDIR
  2494 00000BFF [A00A]                  		dw FAILINT24
  2495 00000C01 [AF0A]                  		dw TOOMANYRD
  2496 00000C03 [C50A]                  		dw DUPLREDIR
  2497 00000C05 [DB0A]                  		dw INVPASSWD
  2498 00000C07 [EC0A]                  		dw INVLDPARM
  2499 00000C09 [FE0A]                  		dw NETDATFAU
  2500 00000C0B [110B]                  		dw FNOSUPNET
  2501 00000C0D [330B]                  		dw RSCNOTINS
  2502                                  ; ----------------------------------------------------------------------------
  2503                                  	; 17/04/2023
  2504                                  ExtMsgEnd:
  2505                                  
  2506                                  ; 21/04/2023
  2507                                  NUMEXTMSGS equ ($-EXTMSGPTRS)>>1 ; 14/01/2023
  2508                                  
  2509                                  ; ----------------------------------------------------------------------------
  2510                                  
  2511                                  ; 20/04/2023
  2512                                  
  2513 00000C0F 90                      align 16
  2514                                  
  2515                                  ; ----------------------------------------------------------------------------
  2516                                  
  2517                                  ; 10/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2518                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0D40h (CODERES:0000h)
  2519                                  
  2520                                  ; ----------------------------------------------------------------------------
  2521                                  ; SEGMENT - CODERES
  2522                                  ; ----------------------------------------------------------------------------
  2523                                  
  2524                                  ; 11/01/2023
  2525                                  RCODE_START:	
  2526                                  
  2527                                  ; ----------------------------------------------------------------------------
  2528                                  ;***	EXEC error handling
  2529                                  ;
  2530                                  ;	COMMAND has issued an EXEC system call and it has returned an error.
  2531                                  ;	We examine the error code and select an appropriate message.
  2532                                  ; --------------------------
  2533                                  ;	Bugbug:	optimize reg usage in following code? Careful of DX!
  2534                                  ;	Condense the error scan?
  2535                                  ;	RBADNAM is checked by transient, no need here?
  2536                                  ;	Move below Ext_Exec.
  2537                                  ; ----------------------------------------------------------------------------
  2538                                  
  2539                                  Exec_Err:
  2540                                  ;SR;
  2541                                  ; ds,es are setup when the transient jumps to Ext_Exec. So segment regs are
  2542                                  ; in order here
  2543                                  
  2544                                  ;	Bugbug:	can we use byte compares here?
  2545                                  ;	Might be able to use byte msg#s, too.
  2546                                  
  2547                                  ;	Store errors in a 3 or 4 byte table. Msg #s in another.
  2548                                  ;	Speed not high priority here.
  2549                                  
  2550                                  ;	Move this to transient.
  2551                                  
  2552                                  	; 10/01/2023
  2553                                  
  2554                                  	;mov	bx,RBADNAM	; offset DATARES:RBadNam
  2555 00000C10 BA[B805]                	mov	dx,RBADNAM
  2556 00000C13 3C02                    	cmp	al,ERROR_FILE_NOT_FOUND ; 2
  2557 00000C15 741B                    	je	short GotExecEMes		; bad command
  2558                                  	;mov	bx,TOOBIG	; offset DATARES:TooBig
  2559 00000C17 BA[7E05]                	mov	dx,TOOBIG
  2560 00000C1A 3C08                    	cmp	al,ERROR_NOT_ENOUGH_MEMORY ; 8
  2561 00000C1C 7414                    	je	short GotExecEMes		; file not found
  2562                                  	;mov	bx,EXEBAD	; offset DATARES:ExeBad
  2563 00000C1E BA[6A05]                	mov	dx,EXEBAD
  2564 00000C21 3C0B                    	cmp	al,ERROR_BAD_FORMAT ; 11 ; 0Bh
  2565 00000C23 740D                    	je	short GotExecEMes		; bad exe file
  2566                                  	;mov	bx,ACCDEN	; offset DATARES:AccDen
  2567 00000C25 BA[D305]                	mov	dx,ACCDEN
  2568 00000C28 3C05                    	cmp	al,ERROR_ACCESS_DENIED ; 5
  2569 00000C2A 7406                    	je	short GotExecEMes		; access denied
  2570                                  
  2571                                  Default_Message:
  2572                                  	;mov	bx,EXECEMES	; offset DATARES:ExecEMes
  2573 00000C2C BA[5605]                	mov	dx,EXECEMES
  2574                                  						; default message
  2575 00000C2F BE[3301]                	mov	si,ExecErrSubst ; offset DATARES:ExecErrSubst
  2576                                  						; get address of subst block
  2577                                  GotExecEMes:
  2578                                  	;mov	dx,bx				; DX = ptr to msg
  2579 00000C32 E85B06                  	call	RPrint ; invoke	RPrint
  2580 00000C35 EB09                    	jmp	short NoExec
  2581                                  
  2582                                  ; ----------------------------------------------------------------------------
  2583                                  ;***	EXEC call
  2584                                  ;
  2585                                  ;	The transient has set up everything for an EXEC system call.
  2586                                  ;	For cleanliness, we issue the EXEC here in the resident 
  2587                                  ;	so that we may be able to recover cleanly upon success.
  2588                                  ;
  2589                                  ;	CS,DS,ES,SS = DATARES seg addr
  2590                                  ; ----------------------------------------------------------------------------
  2591                                  
  2592                                  Ext_Exec:
  2593                                  ;SR;
  2594                                  ; The words put on the stack by the stub will be popped off when we finally
  2595                                  ;jump to LodCom (by LodCom).
  2596                                  
  2597                                  	; 10/01/2023
  2598                                  	;int	21h			; do the exec
  2599                                  	; 10/01/2023 - MSDOS 5.0 COMMAND.COM - RESGROUP:0D69h (CODERES:0029h)
  2600                                  Exec_Ret:
  2601 00000C37 72D7                    	jc	short Exec_Err		; exec failed
  2602                                  
  2603                                  ;	The exec has completed. Retrieve the exit code.
  2604                                  
  2605                                  Exec_Wait:
  2606 00000C39 B44D                    	mov	ah,4Dh
  2607                                  	;mov	ah,WAITPROCESS ; 4Dh	; get errorlevel
  2608 00000C3B CD21                    	int	21h			; get the return code
  2609                                  	;mov	[cs:RetCode],ax
  2610                                  	; 11/01/2023
  2611 00000C3D A3[9D01]                	mov	[RetCode],ax
  2612                                  
  2613                                  ;	See if we can reload the transient. The external command
  2614                                  ;	may have overwritten part of the transient.
  2615                                  
  2616                                  NoExec:
  2617                                  ;SR;
  2618                                  ; ds = es = ss = DATARES when we jump to LodCom
  2619                                  ;
  2620 00000C40 E97901                  	jmp	LodCom
  2621                                  
  2622                                  ; ----------------------------------------------------------------------------
  2623                                  ;***	Int 23 (ctrl-c) handler
  2624                                  ;
  2625                                  ;	This is the default system INT 23 handler. All processes
  2626                                  ;	(including COMMAND) get it by default. There are some
  2627                                  ;	games that are played: We ignore ^C during most of the
  2628                                  ;	INIT code. This is because we may perform an ALLOC and
  2629                                  ;	diddle the header! Also, if we are prompting for date/time
  2630                                  ;	in the init code, we are to treat ^C as empty responses.
  2631                                  ; ---------------------------
  2632                                  ;	Bugbug:	put init ctrl-c handling in init module.
  2633                                  ; ----------------------------------------------------------------------------
  2634                                  
  2635                                  ;SR;
  2636                                  ;The stub has pushed the previous ds and DATARES onto the stack. We get
  2637                                  ;both these values off the stack now
  2638                                  ;
  2639                                  ;ContC	proc	far
  2640                                  
  2641                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  2642                                  
  2643                                  	; 11/01/2023 - Retro DOS v5.40 COMMAND.COM
  2644                                  	; MSDOS 5.0 COMMAND.COM RESGROUP:0D75h (CODERES:0035h)
  2645                                  ContC:
  2646 00000C43 1F                      	pop	ds			; ds = DATARES
  2647                                  ;	assume	ds:DATARES
  2648                                  ;;	pop	word [OldDS]		; OldDS = old ds
  2649                                  
  2650 00000C44 F606[1702]01            	test	byte [InitFlag],INITINIT ; 1
  2651                                  	;test	byte [cs:INITFLAG],INITINIT ; 1	; in initialization?
  2652 00000C49 740D                    	jz	short NotAtInit		; no
  2653 00000C4B F606[1702]02            	test	byte [InitFlag],INITSPECIAL ; 2 
  2654                                  	;test	byte [cs:INITFLAG],INITSPECIAL ; 2 ; doing special stuff?
  2655 00000C50 7404                    	jz	short CmdIret		; no, ignore ^C
  2656 00000C52 1F                      	pop	ds			; restore before jumping; M021
  2657                                  	;jmp	RESGROUP:Init_ContC_SpecialCase ; Yes, go handle it
  2658 00000C53 E9FF0D                  	jmp	init_contc_specialcase
  2659                                  CmdIret:
  2660                                  ;SR;
  2661                                  ; Restore ds to its previous value
  2662                                  ;
  2663                                  
  2664                                  ;;	mov	ds,[OLdDS]		;
  2665 00000C56 1F                      	pop	ds
  2666 00000C57 CF                      	iret				; yes, ignore the ^C
  2667                                  
  2668                                  NotAtInit:
  2669 00000C58 F606[1702]04            	test	byte [InitFlag],INITCTRLC ; 4
  2670                                  	;test	byte [cs:INITFLAG],INITCTRLC ; 4 ; are we already in a ^C?
  2671 00000C5D 7412                    	jz	short NotInit 		; nope too.
  2672                                  
  2673                                  ;*	We are interrupting ourselves in this ^C handler. We need
  2674                                  ;	to set carry and return to the user sans flags only if the
  2675                                  ;	system call was a 1-12 one. Otherwise, we ignore the ^C.
  2676                                  
  2677 00000C5F 80FC01                  	cmp	ah,1
  2678 00000C62 72F2                    	jb	short CmdIret
  2679 00000C64 80FC0C                  	cmp	ah,12
  2680 00000C67 77ED                    	ja	short CmdIret
  2681                                  
  2682 00000C69 1F                      	pop	ds			;restore ds to old value
  2683 00000C6A 83C406                  	add	sp,6			; remove int frame
  2684 00000C6D F9                      	stc
  2685                                  
  2686                                  ;;	mov	ds,[OldDS]		;restore ds to its old value
  2687 00000C6E CA0200                  	retf	2			; remove those flags...
  2688                                  
  2689                                  NotInit:
  2690                                  
  2691                                  ;*	We have now received a ^C for some process (maybe ourselves
  2692                                  ;	but not at INIT).
  2693                                  ;	
  2694                                  ;	Note that we are running on the user's stack!!! Bad news if
  2695                                  ;	any of the system calls below go and issue another INT
  2696                                  ;	24... Massive stack overflow! Another bad point is that
  2697                                  ;	SavHand will save an already saved handle, thus losing a
  2698                                  ;	possible redirection...
  2699                                  ;	
  2700                                  ;	All we need to do is set the flag to indicate nested ^C. 
  2701                                  ;	The above code will correctly flag the ^C diring the
  2702                                  ;	message output and prompting while ignoring the ^C the rest
  2703                                  ;	of the time.
  2704                                  ;	
  2705                                  ;	Clean up: flush disk. If we are in the middle of a batch
  2706                                  ;	file, we ask if he wants to terminate it. If he does, then
  2707                                  ;	we turn off all internal flags and let the DOS abort.
  2708                                  
  2709 00000C71 800E[1702]04            	or	byte [InitFlag],INITCTRLC ; 4
  2710                                  	;or	byte [cs:INITFLAG],INITCTRLC ; 4 ; nested ^c is on
  2711 00000C76 FB                      	sti
  2712                                  
  2713                                  ;	push	cs			; el yucko! change the user's ds!!
  2714                                  ;	pop	ds
  2715                                  
  2716                                  ;	assume	ds:RESGROUP
  2717                                  
  2718 00000C77 58                      	pop	ax			; discard the old ds value
  2719                                  
  2720 00000C78 A1[A601]                	mov	ax,[SingleCom]
  2721 00000C7B 09C0                    	or	ax,ax
  2722 00000C7D 7506                    	jnz	short NoReset
  2723 00000C7F 50                      	push	ax
  2724 00000C80 B40D                    	mov	ah,DISK_RESET ; 0Dh
  2725 00000C82 CD21                    	int	21h			; reset disks in case files were open
  2726 00000C84 58                      	pop	ax
  2727                                  
  2728                                  NoReset:
  2729                                  
  2730                                  ;	In the generalized version of FOR, PIPE and BATCH, we would
  2731                                  ;	walk the entire active list and free each segment. Here,
  2732                                  ;	we just free the single batch segment.
  2733                                  
  2734 00000C85 F706[4C01]FFFF          	test	word [Batch],-1 ; 0FFFFh
  2735 00000C8B 7452                    	jz	short ContCTerm
  2736 00000C8D 09C0                    	or	ax,ax
  2737 00000C8F 754E                    	jnz	short ContCTerm
  2738 00000C91 E88502                  	call	SavHand
  2739 00000C94 E89303                  	call	AskEnd			; ask if user wants to end batch
  2740                                  
  2741                                  ;	If the carry flag is clear, we do NOT free up the batch file
  2742                                  
  2743 00000C97 7340                    	jnc	short ContBatch
  2744 00000C99 8A0E[A001]              	mov	cl,[EchoFlag]		; get current echo flag
  2745 00000C9D 53                      	push	bx
  2746                                  
  2747                                  ClearBatch:
  2748 00000C9E 8E06[4C01]              	mov	es,[Batch]		; get batch segment
  2749                                  	;mov	di,20h
  2750                                  	; 06/06/2023 (BugFix)
  2751 00000CA2 BF2000                  	mov	di,BATCHSEGMENT.BatFile ; get offset of batch file name
  2752                                  	; MSDOS 5.0 & MSDOS 6.0 (ES:5)
  2753                                  	;mov	bx,es:BatForPtr		; get old FOR segment
  2754 00000CA5 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
  2755                                  	; MSDOS 3.3 ([ES:4])
  2756                                  	;mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:4] ; get old FOR segment
  2757                                  	;
  2758 00000CAA 83FB00                  	cmp	bx,0			; is a FOR in progress
  2759 00000CAD 7408                    	je	short No_Bat_For	; no - don't deallocate
  2760 00000CAF 06                      	push	es			;
  2761 00000CB0 8EC3                    	mov	es,bx			; yes - free it up...
  2762 00000CB2 B449                    	mov	ah,49h
  2763                                  	;mov	ah,DEALLOC ; 49h	;
  2764 00000CB4 CD21                    	int	21h			;
  2765 00000CB6 07                      	pop	es			; restore to batch segment
  2766                                  
  2767                                  No_Bat_For:
  2768                                  	;mov	cl,[es:1]
  2769 00000CB7 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag] ; get old echo flag
  2770                                  	;mov	bx,[es:3]
  2771 00000CBC 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast] ; get old batch segment
  2772 00000CC1 B449                    	mov	ah,49h
  2773                                  	;mov	ah,DEALLOC ; 49h	; free it up...
  2774 00000CC3 CD21                    	int	21h
  2775 00000CC5 891E[4C01]              	mov	[Batch],bx		; get ready to deallocate next batch
  2776 00000CC9 FF0E[AF01]              	dec	word [Nest]		; is there another batch file?
  2777 00000CCD 75CF                    	jnz	short ClearBatch	; keep going until no batch file
  2778                                  
  2779                                  ;	We are terminating a batch file; restore the echo status
  2780                                  
  2781                                  ;Shell_Bat_Cont: 			; continue batch for SHELL
  2782 00000CCF 5B                      	pop	bx
  2783 00000CD0 880E[A001]              	mov	[EchoFlag],cl		; reset echo status
  2784                                  	; 29/05/2018
  2785 00000CD4 C606[1802]00            	mov	byte [PipeFlag],0	; turn off pipeflag
  2786                                  
  2787                                  ContBatch:
  2788 00000CD9 E8B105                  	call	crlf			; print out crlf before returning
  2789 00000CDC E86302                  	call	RestHand
  2790                                  
  2791                                  ;	Yes, we are terminating. Turn off flags and allow the DOS to abort.
  2792                                  
  2793                                  ContCTerm:
  2794 00000CDF 31C0                    	xor	ax,ax			; indicate no read
  2795 00000CE1 89C5                    	mov	bp,ax
  2796                                  
  2797                                  ;	The following resetting of the state flags is good for the
  2798                                  ;	generalized batch processing.
  2799                                  
  2800 00000CE3 A2[AB01]                	mov	[IfFlag],al		; turn off iffing
  2801 00000CE6 A2[AC01]                	mov	[ForFlag],al		; turn off for processing
  2802 00000CE9 E81C00                  	call	ResPipeOff
  2803 00000CEC 3906[A601]              	cmp	[SingleCom],ax		; see if we need to set SingleCom
  2804 00000CF0 7406                    	jz	short NoSetSing
  2805 00000CF2 C706[A601]FFFF          	mov	word [SingleCom],-1	; cause termination on 
  2806                                  					;  pipe, batch, for
  2807                                  NoSetSing:
  2808                                  
  2809                                  ;	If we are doing an internal command, go through the reload process.
  2810                                  ;	If we are doing an external, let DOS abort the process.
  2811                                  ;	In both cases, we are now done with the ^C processing.
  2812                                  
  2813 00000CF8 8026[1702]FB            	and	byte [InitFlag],~INITCTRLC ; 0FBh
  2814 00000CFD 3806[9C01]              	cmp	[ExtCom],al
  2815 00000D01 7503                    	jnz	short DoDAb		; internal ^c
  2816 00000D03 E94501                  	jmp	LodCom1
  2817                                  DoDAb:
  2818 00000D06 F9                      	stc				; tell dos to abort
  2819                                  
  2820                                  ;SR;
  2821                                  ;We dont need to restore ds here because we are forcing DOS to do an abort
  2822                                  ;by setting carry and leaving flags on the stack
  2823                                  
  2824 00000D07 CB                      	retf				; Leave flags on stack
  2825                                  
  2826                                  ;ContC	endp
  2827                                  
  2828                                  ;SR;
  2829                                  ;ds = DATARES on entry. This routine is called from DskErr and LodCom1 and
  2830                                  ;both have ds = DATARES
  2831                                  
  2832                                  	; 11/01/2023
  2833                                  ResPipeOff:
  2834 00000D08 50                      	push	ax
  2835 00000D09 31C0                    	xor	ax,ax
  2836                                  	;xchg	al,[cs:PIPEFLAG]
  2837 00000D0B 8606[1802]              	xchg	al,[PipeFlag]
  2838 00000D0F 08C0                    	or	al,al
  2839 00000D11 7404                    	jz	short NoPipePop
  2840                                  	;shr	byte [cs:ECHOFLAG],1
  2841 00000D13 D02E[A001]              	shr	byte [EchoFlag],1
  2842                                  NoPipePop:
  2843 00000D17 58                      	pop	ax
  2844 00000D18 C3                      	retn
  2845                                  
  2846                                  ;CODERES ends
  2847                                  
  2848                                  ;=============================================================================
  2849                                  ; COMMAND2.ASM, MSDOS 6.0, 1991
  2850                                  ;=============================================================================
  2851                                  ; 21/09/2018 - Retro DOS v3.0
  2852                                  
  2853                                  ;	title	COMMAND2 - resident code for COMMAND.COM part II
  2854                                  ;	name	COMMAND2
  2855                                  
  2856                                  ;/*
  2857                                  ; *                      Microsoft Confidential
  2858                                  ; *                      Copyright (C) Microsoft Corporation 1991
  2859                                  ; *                      All Rights Reserved.
  2860                                  ; */
  2861                                  
  2862                                  ;
  2863                                  ;	Revision History
  2864                                  ;	================
  2865                                  ;
  2866                                  ; M038	SR  11/5/90	Changed stuff for Novell RPL. These guys cannot
  2867                                  ;			reserve memory by changing int 12h and then give it
  2868                                  ;			back to DOS by changing arenas in autoexec.bat.
  2869                                  ;			This makes command.com reload transient and this
  2870                                  ;			cannot be done at this stage.
  2871                                  ;
  2872                                  
  2873                                  ;CODERES segment public byte
  2874                                  
  2875                                  ;*	If we cannot allocate enough memory for the transient or there
  2876                                  ;	was some other allocation error, we display a message and
  2877                                  ;	then die.
  2878                                  
  2879                                  ;SR;
  2880                                  ; We will have to make sure that at this entry point and at FatalC, 
  2881                                  ;ds = DATARES. All jumps to these points are made from only within this file
  2882                                  ;and so we should be able to do this
  2883                                  
  2884                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  2885                                  ; MSDOS 5.0 COMMAND.COM - RESGROUP:0E4Bh (CODERES:010Bh)
  2886                                  
  2887                                  	;assume	ds:DATARES
  2888                                  BadMemErr:
  2889 00000D19 BA[E205]                	mov	dx,BMEMMES			; DX = ptr to msg
  2890                                  FatalC:
  2891                                  	; 12/01/2023
  2892                                  ;;	push	cs
  2893                                  ;;	pop	ds
  2894                                  ;;	assume	ds:ResGroup
  2895                                  ;	invoke	RPrint
  2896                                  
  2897                                  	; 12/01/2023
  2898                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2899 00000D1C E87105                  	call	RPrint
  2900                                  
  2901                                  	; MSDOS 3.3
  2902                                  	;call	RDISPMSG
  2903                                  
  2904                                  ;	If this is NOT a permanent (top-level) COMMAND, then we exit;
  2905                                  ;	we can't do anything else!
  2906                                  
  2907 00000D1F 803E[A501]00            	cmp	byte [PermCom],0
  2908 00000D24 7410                    	je	short FatalRet
  2909                                  
  2910                                  ;	We are a permanent command. If we are in the process of the
  2911                                  ;	magic interrupt (Singlecom) then exit too.
  2912                                  
  2913 00000D26 833E[A601]00            	cmp	word [SingleCom],0		; if PermCom and SingleCom
  2914 00000D2B 7509                    	jne	short FatalRet			; must take int_2e exit
  2915                                  
  2916                                  ;	Permanent command. We can't do ANYthing except halt.
  2917                                  
  2918 00000D2D BA[FC05]                	mov	dx,HALTMES			; DX = ptr to msg
  2919                                  	;invoke	RPrint
  2920                                  	; 12/01/2023	
  2921                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  2922 00000D30 E85D05                  	call	RPrint	
  2923                                  	; MSDOS 3.3
  2924                                  	;call	RDISPMSG
  2925 00000D33 FB                      	sti
  2926                                  Stall:
  2927 00000D34 EBFE                    	jmp	short Stall			; crash the system nicely
  2928                                  
  2929                                  FatalRet:
  2930 00000D36 BA[2306]                	mov	dx,FRETMES			; DX = ptr to msg
  2931                                  	;call	RDISPMSG
  2932                                  	; 12/01/2023	
  2933 00000D39 E85405                  	call	RPrint	
  2934                                  FatalRet2:
  2935 00000D3C 803E[A501]00            	cmp	byte [PermCom],0		; if we get here and PermCom,
  2936 00000D41 7517                    	jne	short Ret_2e			; must be int_2e
  2937                                  
  2938                                  ;	Bugbug:	this is where we'd want to unhook int 2F, *if* we
  2939                                  ;	were a non-permanent COMMAND that had hooked it! (Just in 
  2940                                  ;	case we decide to do that.)
  2941                                  
  2942 00000D43 A1[4101]                	mov	ax,[Parent]
  2943                                  	;mov	[16h],ax
  2944 00000D46 A31600                  	mov	[PDB.PARENT_PID],ax	; mov [cs:16h],ax
  2945 00000D49 A1[4301]                	mov	ax,[OldTerm]
  2946                                  	;mov	[0Ah],ax
  2947 00000D4C A30A00                  	mov	[PDB.EXIT],ax		; mov [cs:0Ah],ax
  2948 00000D4F A1[4501]                	mov	ax,[OldTerm+2]
  2949                                  	;mov	[0Ch],ax
  2950 00000D52 A30C00                  	mov	[PDB.EXIT+2],ax 	; mov [cs:0Ch],ax
  2951 00000D55 B8004C                  	mov	ax,4C00h
  2952                                  	;mov	ax,(EXIT<<8) ; 4C00h		; return to lower level
  2953 00000D58 CD21                    	int	21h
  2954                                  Ret_2e:
  2955                                  ;SR;
  2956                                  ; We will ensure that ds = DATARES for all entries to this place
  2957                                  ;
  2958                                  
  2959                                  ;;	push	cs
  2960                                  ;;	pop	ds
  2961                                  ;;	assume	ds:resgroup,es:nothing,ss:nothing
  2962                                    	
  2963                                  ;	assume	ds:DATARES
  2964                                  
  2965                                  	;PUSH	CS
  2966                                  	;POP	DS
  2967                                  
  2968 00000D5A C706[A601]0000          	mov	word [SingleCom],0	; turn off SingleCom
  2969 00000D60 8E06[5F03]              	mov	es,[Res_Tpa]
  2970                                  	;mov	ah,49h	; 12/01/2023
  2971 00000D64 B449                    	mov	ah,DEALLOC
  2972 00000D66 CD21                    	int	21h			; free up space used by transient
  2973 00000D68 8B1E[3F01]              	mov	bx,[Save_Pdb]
  2974 00000D6C B450                    	mov	ah,50h
  2975                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  2976 00000D6E CD21                    	int	21h			; current process is user
  2977 00000D70 A1[9D01]                	mov	ax,[RetCode]
  2978 00000D73 803E[9C01]00            	cmp	byte [ExtCom],0
  2979 00000D78 7502                    	jne	short GotECode
  2980 00000D7A 31C0                    	xor	ax,ax			; internals always return 0
  2981                                  GotECode:
  2982 00000D7C C606[9C01]01            	mov	byte [ExtCom],1		; force external
  2983                                  
  2984                                  ;SR; This is actually returning to the caller. However, the old code had
  2985                                  ;ds = RESGROUP so I guess we can keep ds = DATARES for us.
  2986                                  ;Yes, int 2eh can corrupt all registers so we are ok.
  2987                                  
  2988                                  	; 12/01/2023
  2989 00000D81 FF2E[3B01]              	jmp	far [Int_2e_Ret]	; "iret"
  2990                                  
  2991                                  ;***	Int_2e, magic command executer
  2992                                  
  2993                                  Int_2e:
  2994                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  2995                                  ;SR;
  2996                                  ;We are going to come here from the stub with the old ds and DATARES value
  2997                                  ;pushed on the stack in that order. Pick up this stuff off the stack
  2998                                  
  2999                                  	; 12/01/2023 - Retro DOS v4.0 COMMAND.COM
  3000                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0EB7h (CODERES:0177h)
  3001                                  
  3002 00000D85 1F                      	pop	ds			; ds = DATARES
  3003                                  	;assume	ds:DATARES
  3004 00000D86 58                      	pop	ax
  3005                                  ;	;pop	ds:OldDS 		; Save old value of ds
  3006                                  
  3007                                  	;pop	word [cs:Int_2e_Ret]
  3008                                  	;pop	word [cs:Int_2e_Ret+2]	; store return address
  3009                                  	;pop	ax			; chuck flags
  3010 00000D87 8F06[3B01]              	pop	word [Int_2e_Ret]
  3011 00000D8B 8F06[3D01]              	pop	word [Int_2e_Ret+2]
  3012                                  	
  3013 00000D8F 83C402                  	add	sp,2
  3014                                  
  3015                                  ;;	push	cs
  3016                                  ;;	pop	es
  3017                                  
  3018 00000D92 1E                      	push	ds
  3019 00000D93 07                      	pop	es			; es = DATARES
  3020                                  ;	;mov	ds,OldDS
  3021 00000D94 8ED8                    	mov	ds,ax
  3022                                  	;assume	ds:nothing		; ds = old value
  3023                                  
  3024 00000D96 BF8000                  	mov	di,80h
  3025 00000D99 B94000                  	mov	cx,64
  3026                                  ;	Bugbug:	cld
  3027 00000D9C F3A5                    	rep	movsw
  3028 00000D9E B451                    	mov	ah,51h
  3029                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3030 00000DA0 CD21                    	int	21h			; get user's header
  3031                                  	; 12/01/2023
  3032 00000DA2 26891E[3F01]            	mov	[es:Save_Pdb],bx
  3033                                  	;mov	[cs:Save_Pdb],bx
  3034 00000DA7 B450                    	mov	ah,50h
  3035                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  3036                                  
  3037                                  ;;	mov	bx,cs
  3038                                  ;SR;
  3039                                  ;Set ds = DATARES because BadMemErr expects this
  3040                                  
  3041                                  	; 12/01/2023
  3042 00000DA9 06                      	push	es
  3043 00000DAA 1F                      	pop	ds
  3044                                  	;assume	ds:DATARES
  3045                                  
  3046 00000DAB 8CDB                    	mov	bx,ds			; es = our PSP now
  3047                                  	;mov	bx,cs
  3048                                  
  3049 00000DAD CD21                    	int	21h			; current process is me
  3050                                  	;mov	word [cs:SingleCom],81h
  3051                                  	;mov	byte [cs:ExtCom],1	; make sure this case forced
  3052                                  	; 12/01/2023
  3053 00000DAF C706[A601]8100          	mov	word [SingleCom],81h
  3054 00000DB5 C606[9C01]01            	mov	byte [ExtCom],1		; make sure this case forced
  3055                                  
  3056                                  ;SR;
  3057                                  ;We can enter LodCom directly after a command shell is terminated or we
  3058                                  ;can fall thru from above. When we enter directly from the stub, the stack
  3059                                  ;has the old ds value and the data seg value on the stack, so that ds can
  3060                                  ;be properly set. To fake this, we push dummy values here.
  3061                                  
  3062                                  	; 12/01/2023
  3063 00000DBA 1E                      	push	ds			; old value of ds
  3064 00000DBB 1E                      	push	ds			; data seg value, ds = DATARES
  3065                                  LodCom: 				; termination handler
  3066 00000DBC 1F                      	pop	ds			; ds = DATARES
  3067                                  	;assume	ds:DATARES
  3068 00000DBD 83C402                  	add	sp,2
  3069                                  ;	;pop	OldDS			; store old ds
  3070                                  	;cmp	ExtCom,0
  3071 00000DC0 803E[9C01]00            	cmp	byte [ExtCom],0
  3072                                  	;cmp	byte [cs:ExtCom],0
  3073                                  	;jne	short @f	 	; internal cmd - memory allocated
  3074                                  	; 16/04/2023
  3075 00000DC5 7503                    	jne	short LodCom0 ; 24/09/2018
  3076 00000DC7 E98100                  	jmp	LodCom1
  3077                                  	;je	short LodCom1 ; 25/09/2018	
  3078                                  ;@@:
  3079                                  LodCom0: ; 24/09/2018
  3080 00000DCA BBFFFF                  	mov	bx,0FFFFh
  3081 00000DCD B448                    	mov	ah,48h	; 12/01/2023
  3082                                  	;mov	ah,ALLOC ; 48h	
  3083 00000DCF CD21                    	int	21h		; DOS - 2+ - ALLOCATE MEMORY
  3084                                  				; BX = number of 16-byte paragraphs desired
  3085 00000DD1 E80A00                  	call	SetSize
  3086 00000DD4 83C020                  	add	ax,20h
  3087 00000DD7 39C3                    	cmp	bx,ax
  3088 00000DD9 730B                    	jnb	short MemOk		; > 512 byte buffer - good enough
  3089                                  BadMemErrJ:
  3090 00000DDB E93BFF                  	jmp	BadMemErr		; not enough memory
  3091                                  
  3092                                  ;***	SetSize - get transient size in paragraphs
  3093                                  
  3094                                  SetSize:
  3095                                  	; 12/01/2023
  3096                                  	;;mov	ax,offset TRANGROUP:TranSpaceEnd + 15
  3097                                  	;mov	ax,98D4h		; MSDOS 5.0 COMMAND.COM
  3098 00000DDE B8FA95                  	mov	ax,TRANSPACEEND+15	; mov AX,4D6Bh ; MSDOS 3.3
  3099 00000DE1 B104                    	mov	cl,4
  3100 00000DE3 D3E8                    	shr	ax,cl
  3101 00000DE5 C3                      	retn
  3102                                  
  3103                                  MemOk:
  3104                                  	;assume	ds:DATARES		;we have set ds = DATARES 
  3105                                  
  3106 00000DE6 B448                    	mov	ah,48h
  3107                                  	;mov	ah,ALLOC  ; 48h
  3108 00000DE8 CD21                    	int	21h
  3109 00000DEA 72EF                    	jc	short BadMemErrJ	; memory arenas probably trashed
  3110                                  	;mov	byte [cs:ExtCom],0
  3111                                  	;mov	[cs:Res_Tpa],ax
  3112                                  	; 12/01/2023
  3113 00000DEC C606[9C01]00            	mov	byte [ExtCom],0		; flag not to alloc again
  3114 00000DF1 A3[5F03]                	mov	[Res_Tpa],ax		; save current tpa segment
  3115                                  
  3116 00000DF4 2500F0                  	and	ax,0F000h
  3117 00000DF7 050010                  	add	ax,1000h		; round up to next 64k boundary
  3118 00000DFA 7212                    	jc	short Bad_Tpa		; memory wrap if carry set
  3119                                  
  3120                                  ;	Make sure that new boundary is within allocated range
  3121                                  
  3122                                  	;mov	dx,[cs:Res_Tpa]
  3123                                  	; 12/01/2023
  3124 00000DFC 8B16[5F03]              	mov	dx,[Res_Tpa]
  3125 00000E00 01DA                    	add	dx,bx			; compute maximum address
  3126 00000E02 39C2                    	cmp	dx,ax			; is 64k address out of range?
  3127 00000E04 7608                    	jbe	short Bad_Tpa
  3128                                  
  3129                                  ;	Must have 64K of usable space.
  3130                                  
  3131 00000E06 29C2                    	sub	dx,ax			; compute the usable space
  3132 00000E08 81FA0010                	cmp	dx,1000h		; is space >= 64k ?
  3133 00000E0C 7303                    	jae	short LTpaSet
  3134                                  Bad_Tpa:
  3135                                  	;mov	ax,[cs:Res_Tpa]
  3136                                  	; 12/01/2023
  3137 00000E0E A1[5F03]                	mov	ax,[Res_Tpa]
  3138                                  LTpaSet:
  3139                                  	;mov	[cs:LTPA],ax
  3140                                  	;mov	ax,[cs:Res_Tpa]
  3141                                  	; 12/01/2023
  3142 00000E11 A3[5103]                	mov	[LTpa],ax		; usable tpa is 64k buffer aligned
  3143 00000E14 A1[5F03]                	mov	ax,[Res_Tpa]		; actual tpa is buffer allocated
  3144 00000E17 01C3                    	add	bx,ax
  3145                                  	;mov	[cs:MemSiz],bx
  3146 00000E19 891E[9801]              	mov	[MemSiz],bx
  3147 00000E1D E8BEFF                  	call	SetSize
  3148 00000E20 29C3                    	sub	bx,ax
  3149                                  
  3150                                  	; MSDOS 6.0
  3151                                  
  3152                                  ;M038; Start of changes
  3153                                  ;Changes for Novell RPL. These guys reserve memory for themselves by
  3154                                  ;reducing int 12h size and add this memory to the system at autoexec time by
  3155                                  ;running a program that changes arenas. This changes the largest block that
  3156                                  ;command.com gets and so changes the transient segment. So, command.com does
  3157                                  ;a checksum at the wrong address and thinks that the transient is destroyed
  3158                                  ;and tries to reload it. At this point, no Comspec is defined and so the
  3159                                  ;reload fails, hanging the system. To get around this we just copy the
  3160                                  ;transient from the previous address to the new address(if changed) and
  3161                                  ;then let command.com do the checksum. So, if the transient area is not
  3162                                  ;corrupted, there will not be any reload. In Novell's case, the transient
  3163                                  ;is not really corrupted and so this should work.
  3164                                  
  3165                                  	; 12/01/2023
  3166                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:0F5Ah (CODERES:021Ah)
  3167                                  
  3168 00000E22 3B1E[9201]              	cmp	bx,[TrnSeg]		; Segment still the same?
  3169 00000E26 7423                    	je	short LodCom1		; yes, dont copy
  3170                                  
  3171                                  ;Check if the new segment is above or below the current move. If the new
  3172                                  ;segment is above (i.e new block is larger than previous block), then we
  3173                                  ;have to move in the reverse direction
  3174                                  
  3175                                  	;mov	cx,98C5h
  3176 00000E28 B9EB95                  	mov	cx,TRANSPACEEND		; cx = length to move
  3177 00000E2B 7707                    	ja	short mov_down		; new seg > old seg, reverse move
  3178 00000E2D 31F6                    	xor	si,si			; normal move
  3179 00000E2F 89F7                    	mov	di,si
  3180 00000E31 FC                      	cld
  3181 00000E32 EB06                    	jmp	short copy_trans
  3182                                  mov_down:
  3183 00000E34 89CE                    	mov	si,cx			; reverse move, start from end
  3184 00000E36 4E                      	dec	si
  3185 00000E37 89F7                    	mov	di,si
  3186 00000E39 FD                      	std
  3187                                  copy_trans:
  3188 00000E3A 1E                      	push	ds
  3189 00000E3B 06                      	push	es
  3190 00000E3C 8EC3                    	mov	es,bx			; dest segment
  3191 00000E3E 8E1E[9201]              	mov	ds,[TrnSeg]		; source segment
  3192                                  	;assume	ds:nothing
  3193                                  
  3194 00000E42 F3A4                    	rep	movsb			; copy transient
  3195 00000E44 FC                      	cld
  3196 00000E45 07                      	pop	es
  3197 00000E46 1F                      	pop	ds
  3198                                  	;assume	ds:DATARES
  3199                                  
  3200                                  ;M038; End of changes
  3201                                  
  3202                                  	;mov	[cs:TrnSeg],bx		; new location of transient
  3203                                  	; 12/01/2023
  3204 00000E47 891E[9201]              	mov	[TrnSeg],bx
  3205                                  
  3206                                  LodCom1:
  3207                                  ;;	mov	ax,cs
  3208                                  ;;	mov	ss,ax
  3209                                  ;SR; At this point ds = DATARES which is where the stack is located
  3210                                  
  3211                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3212                                  	; MSDOS 5.0 (& MSDOS 6.0-6.22)
  3213 00000E4B 8CD8                    	mov	ax,ds
  3214 00000E4D 8ED0                    	mov	ss,ax
  3215                                  	;assume	ss:DATARES
  3216                                  	;;mov	sp,offset DATARES:RStack
  3217                                  	;mov	sp,53Eh
  3218 00000E4F BC[3804]                	mov	sp,RStack
  3219                                  
  3220                                  ;;	mov	ds,ax
  3221                                  
  3222                                  	;assume	ds:DATARES
  3223                                  	
  3224                                  	; MSDOS 3.3
  3225                                  	;mov	ax,cs
  3226                                  	;mov	ss,ax
  3227                                  	;mov	sp,RSTACK
  3228                                  	;mov	ds,ax
  3229                                  
  3230 00000E52 E87B00                  	call	HeadFix			; close files, restore stdin, stdout
  3231 00000E55 31ED                    	xor	bp,bp			; flag command ok
  3232 00000E57 B8FFFF                  	mov	ax,-1
  3233 00000E5A 8706[A801]              	xchg	ax,[VerVal]
  3234 00000E5E 83F8FF                  	cmp	ax,-1
  3235 00000E61 7404                    	je	short NoSetVer
  3236 00000E63 B42E                    	mov	ah,2Eh
  3237                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh ; AL has correct value
  3238 00000E65 CD21                    	int	21h 		; DOS - SET VERIFY FLAG
  3239                                  				; DL = 00h, AL = 01h VERIFY on / 00h VERIFY off
  3240                                  NoSetVer:
  3241 00000E67 833E[A601]FF            	cmp	word [SingleCom],-1
  3242 00000E6C 7503                    	jne	short NoSng
  3243 00000E6E E9CBFE                  	jmp	FatalRet2		; we have finished the single command
  3244                                  NoSng:
  3245 00000E71 E87201                  	call	ChkSum			; check the transient
  3246                                  	;cmp	dx,[Sum]
  3247                                  	;je	short HavCom		; transient ok
  3248                                  	; 12/01/2023
  3249 00000E74 7412                    	jz	short HavCom
  3250                                  Bogus_Com:
  3251 00000E76 C606[4B01]01            	mov	byte [Loading],1	; flag DskErr routine
  3252 00000E7B E81E01                  	call	LoadCom
  3253                                  ChkSame:
  3254 00000E7E E86501                  	call	ChkSum
  3255                                  	;cmp	dx,[Sum]
  3256                                  	;je	short HavCom		; same command
  3257                                  	; 12/01/2023
  3258 00000E81 7405                    	jz	short HavCom
  3259                                  Also_Bogus:
  3260 00000E83 E85801                  	call	WrongCom
  3261 00000E86 EBF6                    	jmp	short ChkSame
  3262                                  
  3263                                  	; 12/01/2023
  3264                                  ;HavCom:
  3265                                  ;	; 25/09/2018
  3266                                  ;	mov     ax,(CHAR_OPER*256) ; 3700h
  3267                                  ;	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  3268                                  ;			; Return: AL = FFh unsupported subfunction
  3269                                  ;			; DL = current switch character
  3270                                  ;	mov     [RSWITCHAR],dl
  3271                                  ;	cmp     dl,'/'
  3272                                  ;	jnz     short USESLASH
  3273                                  ;	;mov	cl,'\'
  3274                                  ;	;mov	[RDIRCHAR],cl
  3275                                  ;	mov	byte [RDIRCHAR],'\'
  3276                                  ;USESLASH:
  3277                                  
  3278                                  HavCom:
  3279                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3280 00000E88 C606[4B01]00            	mov	byte [Loading],0		; flag to DskErr
  3281                                  	;;mov	si,offset DATARES:TranVars
  3282                                  	;mov	si,453h		; MSDOS 5.0 COMMAND.COM
  3283 00000E8D BE[4D03]                	mov	si,TranVars
  3284                                  	;;mov	di,offset TRANGROUP:HeadCall
  3285                                  	;mov	di,8D75h	; MSDOS 5.0 COMMAND.COM
  3286 00000E90 BF[9A8A]                	mov	di,HEADCALL
  3287 00000E93 8E06[9201]              	mov	es,[TrnSeg]
  3288 00000E97 FC                      	cld
  3289                                  	;mov	cx,467h		; MSDOS 5.0 COMMAND.COM	
  3290 00000E98 B9[6103]                	mov	cx,TranVarEnd
  3291 00000E9B 29F1                    	sub	cx,si
  3292 00000E9D F3A4                    	rep	movsb			; transfer info to transient
  3293 00000E9F A1[9801]                	mov	ax,[MemSiz]
  3294 00000EA2 A30200                  	mov	[PDB.BLOCK_LEN],ax ; mov [ds:2],ax ; adjust my own header
  3295                                  
  3296                                  ;***	TJmp - jump-off to transient
  3297                                  ;
  3298                                  ;	Public label so debugger can find this spot.
  3299                                  
  3300                                  TJmp:	; 12/01/2023
  3301 00000EA5 FF2E[9001]              	jmp	far [Trans]		; jmp dword ptr Trans
  3302                                  
  3303                                  ;***	TRemCheck - far version of RemCheck for transient
  3304                                  
  3305                                  TRemCheck:
  3306                                  	; 12/01/2023
  3307 00000EA9 1F                      	pop	ds			; ds = DATARES
  3308 00000EAA 83C402                  	add	sp,2			; discard old value of ds
  3309                                  
  3310 00000EAD E80100                  	call	RemCheck
  3311 00000EB0 CB                      	retf
  3312                                  
  3313                                  ;***	RemCheck
  3314                                  ;
  3315                                  ;	ENTRY	AL = drive (0=default, 1=A, ...)
  3316                                  ;
  3317                                  ;	EXIT	ZR set if removeable media
  3318                                  ;		ZR clear if fixed media
  3319                                  ;
  3320                                  ;	USED	none
  3321                                  
  3322                                  	; 12/01/2023
  3323                                  RemCheck:
  3324 00000EB1 50                      	push	ax
  3325 00000EB2 53                      	push	bx
  3326 00000EB3 89C3                    	mov	bx,ax
  3327 00000EB5 B80844                  	mov	ax,4408h
  3328                                  	;mov	ax,(IOCTL<<8)+8 ; 4408h
  3329 00000EB8 CD21                    	int	21h		; DOS - 2+ - IOCTL -
  3330 00000EBA 7304                    	jnc	short rcCont		
  3331                                  
  3332                                  ;	If an error occurred, assume the media is non-removable.
  3333                                  ;	AX contains the non-zero error code from the int 21, so
  3334                                  ;	'or ax,ax; sets non-zero. This behavior makes network drives
  3335                                  ;	appear to be non-removable.				
  3336                                  					
  3337 00000EBC 09C0                    	or	ax,ax			
  3338 00000EBE EB05                    	jmp	short ResRegs
  3339                                  rcCont:
  3340 00000EC0 83E001                  	and	ax,1
  3341 00000EC3 F7D0                    	not	ax
  3342                                  ResRegs:
  3343 00000EC5 5B                      	pop	bx
  3344 00000EC6 58                      	pop	ax
  3345 00000EC7 C3                      	retn
  3346                                  
  3347                                  ;***	THeadFix
  3348                                  ;
  3349                                  ;	Far version of HeadFix, called from transient.
  3350                                  
  3351                                  THeadFix:
  3352                                  	; 12/01/2023
  3353 00000EC8 1F                      	pop	ds			; ds = DATARES
  3354 00000EC9 83C402                  	add	sp,2			; discard old ds value on stack
  3355                                  
  3356 00000ECC E80100                  	call	HeadFix
  3357 00000ECF CB                      	retf
  3358                                  
  3359                                  ;***	HeadFix
  3360                                  
  3361                                  	; 12/01/2023
  3362                                  HeadFix:
  3363 00000ED0 E83101                  	call	SetVect			; set vectors to our values
  3364                                  
  3365                                  ;	Clean up header
  3366                                  
  3367                                  ;	Bugbug:	optimize:
  3368                                  ;	mov	word ptr ds:Pdb_Jfn_Table,cx  instead of separate bytes
  3369                                  
  3370 00000ED3 31DB                    	xor	bx,bx			; BX = handle = 0
  3371 00000ED5 8B0E[A201]              	mov	cx,[Io_Save]		; CX = original stdin, stdout
  3372                                  	;mov	dx,[18h] 
  3373 00000ED9 8B161800                	mov	dx,[PDB.JFN_TABLE]	; DX = current stdin, stdout
  3374 00000EDD 38D1                    	cmp	cl,dl
  3375 00000EDF 7408                    	je	short Chk1		; stdin matches
  3376 00000EE1 B43E                    	mov	ah,3Eh
  3377                                  	;mov	ah,CLOSE  ; 3Eh
  3378 00000EE3 CD21                    	int	21h			; close stdin
  3379                                  	;mov	[18h],cl
  3380 00000EE5 880E1800                	mov	[PDB.JFN_TABLE],cl	; restore stdin
  3381                                  Chk1:
  3382 00000EE9 43                      	inc	bx			; BX = handle = 1
  3383 00000EEA 38F5                    	cmp	ch,dh			
  3384 00000EEC 7408                    	je	short ChkOtherHand	; stdout matches
  3385 00000EEE B43E                    	mov	ah,3Eh
  3386                                  	;mov	ah,CLOSE
  3387 00000EF0 CD21                    	int	21h			; close stdout
  3388                                  	;mov	[19h],ch
  3389 00000EF2 882E1900                	mov	[PDB.JFN_TABLE+1],ch	; restore stdout
  3390                                  ChkOtherHand:
  3391 00000EF6 83C304                  	add	bx,4			; skip handles 2,3,4
  3392 00000EF9 B90F00                  	mov	cx,FILPERPROC-5	; 15	; CX = # handles to close
  3393                                  					; (handles 0-4 already done)
  3394                                  CloseLoop:
  3395 00000EFC B43E                    	mov	ah,3Eh
  3396                                  	;mov	ah,CLOSE ; 3Eh
  3397 00000EFE CD21                    	int	21h			; close each handle
  3398 00000F00 43                      	inc	bx			; BX = next handle
  3399 00000F01 E2F9                    	loop	CloseLoop
  3400                                  
  3401                                  	; MSDOS 6.0
  3402                                  ;	Bugbug:	since this is for transient code, move it there
  3403                                  	
  3404                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3405                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:103Dh)
  3406                                  
  3407                                  ;	M012: remove this CS -> DS. Must've been missed during
  3408                                  ;	purification.
  3409                                  ;;	push	ds			; save data segment
  3410                                  ;;	push	cs			; get local segment into DS
  3411                                  ;;	pop	ds			;
  3412 00000F03 803E[C501]FF            	cmp	byte [Append_Flag],-1	; do we need to reset APPEND?
  3413 00000F08 750E                    	jne	short Append_Fix_End	; no - just exit
  3414 00000F0A B807B7                  	mov	ax,0B707h
  3415                                  	;mov	ax,AppendSetState	; set the state of Append
  3416 00000F0D 8B1E[C301]              	mov	bx,[Append_State] 	; back to the original state
  3417 00000F11 CD2F                    	int	2Fh			;
  3418 00000F13 C606[C501]00            	mov	byte [Append_Flag],0	; set append flag to invalid
  3419                                  Append_Fix_End: 			;
  3420                                  ;;	pop	ds			; get data segment back
  3421 00000F18 C3                      	retn
  3422                                  
  3423                                  	; MSDOS 3.3
  3424                                  	;retn
  3425                                  
  3426                                  ;***	SavHand - save current program's stdin/out & set to our stderr
  3427                                  ;
  3428                                  ;	ENTRY	nothing
  3429                                  ;
  3430                                  ;	EXIT	nothing
  3431                                  ;
  3432                                  ;	USED	flags
  3433                                  ;
  3434                                  ;	EFFECTS
  3435                                  ;	  Handle01 = current program's stdin,stdout JFN entries
  3436                                  ;	  current program's stdin,stdout set to our stderr
  3437                                  ;
  3438                                  
  3439                                  ;SR;
  3440                                  ; Changed ds = DATARES. We need it to access our JFN_Table
  3441                                  ; Called from ContC ( ds = DATARES ) and DskErr ( ds = DATARES ).
  3442                                  
  3443                                  SavHand:
  3444                                  	;assume	ds:DATARES,es:NOTHING,ss:NOTHING
  3445                                  
  3446                                  	; 12/01/2023
  3447                                  	;push	ds ; MSDOS 3.3
  3448                                  
  3449 00000F19 53                      	push	bx			;preserve registers
  3450 00000F1A 50                      	push	ax
  3451                                  	; 12/01/2023
  3452 00000F1B 06                      	push	es
  3453 00000F1C 1E                      	push	ds			; save DATARES value
  3454                                  
  3455 00000F1D B451                    	mov	ah,51h
  3456                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3457 00000F1F CD21                    	int	21h			; BX = user's header seg addr
  3458 00000F21 8EDB                    	mov	ds,bx			; DS = user's header seg addr
  3459                                  	;lds	bx,[34h]	
  3460 00000F23 C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to JFN table
  3461 00000F27 8B07                    	mov	ax,[bx]			; AX = stdin,stdout JFN's
  3462                                  	; 12/01/2023
  3463 00000F29 07                      	pop	es			; es = DATARES
  3464 00000F2A 06                      	push	es			; save it back on stack
  3465 00000F2B 26A3[4901]              	mov	[es:Handle01],ax	; save user's stdin, stdout
  3466                                  	;mov	[cs:HANDLE01],ax
  3467                                  
  3468                                  ;SR;
  3469                                  ; Use es to address Handle01 & our JFN_Table
  3470                                  
  3471                                  	; 12/01/2023
  3472                                  	;mov	al,[es:1Ah]
  3473 00000F2F 26A01A00                	mov	al,[es:PDB.JFN_TABLE+2] ; AL = COMMAND stderr
  3474                                  	;mov	al,[cs:PDB.JFN_TABLE+2] ; mov al,[cs:1Ah]
  3475 00000F33 88C4                    	mov	ah,al			; AH = COMMAND stderr
  3476 00000F35 8907                    	mov	[bx],ax			; set user's stdin/out to our stderr
  3477                                  	; 12/01/2023
  3478 00000F37 1F                      	pop	ds			; restore registers
  3479 00000F38 07                      	pop	es
  3480 00000F39 58                      	pop	ax
  3481 00000F3A 5B                      	pop	bx
  3482                                  	;pop	ds ; MSDOS 3.3
  3483 00000F3B C3                      	retn
  3484                                  
  3485                                  	;assume	ds:DATARES
  3486                                  GetComDsk2:
  3487 00000F3C E81F00                  	call	GetComDsk
  3488 00000F3F E909FF                  	jmp	LodCom1			; memory already allocated
  3489                                  
  3490                                  RestHand:
  3491 00000F42 1E                      	push	ds
  3492 00000F43 53                      	push	bx			; restore stdin, stdout to user
  3493 00000F44 50                      	push	ax
  3494                                  	; 12/01/2023
  3495 00000F45 B451                    	mov	ah,51h
  3496                                  	;mov	ah,GET_CURRENT_PDB ; 51h
  3497 00000F47 CD21                    	int	21h			; point to user's header
  3498 00000F49 A1[4901]                	mov	ax,[Handle01]
  3499 00000F4C 8EDB                    	mov	ds,bx
  3500                                  	;assume ds:NOTHING
  3501                                  	;lds	bx,[34h] 
  3502 00000F4E C51E3400                	lds	bx,[PDB.JFN_Pointer]	; DS:BX = ptr to jfn table
  3503 00000F52 8907                    	mov	[bx],ax			; stuff his old 0 and 1
  3504 00000F54 58                      	pop	ax
  3505 00000F55 5B                      	pop	bx
  3506 00000F56 1F                      	pop	ds
  3507 00000F57 C3                      	retn
  3508                                  
  3509                                  	;assume ds:DATARES,ss:DATARES
  3510                                  Hopeless:
  3511 00000F58 BA[DF04]                	mov	dx,COMBAD
  3512 00000F5B E9BEFD                  	jmp	FatalC
  3513                                  
  3514                                  GetComDsk:
  3515 00000F5E A0[9701]                	mov	al,[ComDrv]
  3516 00000F61 E84DFF                  	call	RemCheck
  3517 00000F64 75F2                    	jnz	short Hopeless		; non-removable media
  3518                                  GetComDsk3:
  3519 00000F66 81FA[DF04]              	cmp	dx,COMBAD		; cmp dx,offset DATARES:ComBad
  3520 00000F6A 7503                    	jne	short GetComDsk4
  3521                                  	;;mov	dx,offset DATARES:ComBad ; DX = ptr to msg
  3522                                  	; 12/01/2023
  3523                                  	;mov	dx,COMBAD ; (MSDOS 5.0 COMMAND.COM - RESGROUP:10A6h)
  3524                                  	;invoke	RPrint			; say COMMAND is invalid
  3525 00000F6C E82103                  	call	RPrint
  3526                                  	;call	RDISPMSG
  3527                                  
  3528                                  GetComDsk4:
  3529                                  
  3530                                  ;	Bugbug:	there's always a drive here? No need to check?
  3531                                  
  3532 00000F6F 803E[3201]00            	cmp	byte [PutBackDrv],0	; is there a drive in the comspec?
  3533 00000F74 7509                    	jne	short Users_Drive	; yes - use it
  3534 00000F76 B419                    	mov	ah,19h
  3535                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h ; use default drive
  3536 00000F78 CD21                    	int	21h
  3537 00000F7A 0441                    	add	al,"A"                  ; convert to ascii
  3538 00000F7C A2[3201]                	mov	[PutBackDrv],al		; put in message to print out
  3539                                  
  3540                                  Users_Drive:
  3541                                  	; 12/01/2023
  3542                                  	; MSDOS 6.0
  3543 00000F7F BA[F504]                	mov	dx,PUTBACKMSG		; prompt for diskette
  3544                                  	;mov	si,offset DATARES:PutBackSubst
  3545                                  	;invoke	RPrint
  3546 00000F82 BE[2C01]                	mov	si,PutBackSubst		; containing COMMAND
  3547 00000F85 E80803                  	call	RPrint
  3548                                  	;mov	dx,offset DATARES:Prompt
  3549                                  	;invoke	RPrint
  3550 00000F88 BA[1705]                	mov	dx,PROMPT		; "Press any key"
  3551 00000F8B E80203                  	call	RPrint
  3552                                  
  3553                                  	; MSDOS 3.3
  3554                                  	;mov	dx,PUTBACKMSG		; prompt for diskette
  3555                                  	;call	RDISPMSG
  3556                                  	;mov	dx,[PUTBACKSUBSTPTR]
  3557                                  	;mov	si,[COMSPEC_END]
  3558                                  	;mov	byte [si+1],'$'
  3559                                  	;call	RDISPMSG
  3560                                  	;mov	byte [si+1],0
  3561                                  	;mov	dx,PROMPT
  3562                                  	;call	RDISPMSG
  3563                                  
  3564                                  	;call	GetRawFlushedByte
  3565                                  	;retn
  3566                                  	; 12/01/2023
  3567                                  	;jmp	short GetRawFlushedByte
  3568                                  
  3569                                  ;***	GetRawFlushedByte - flush world and get raw input
  3570                                  
  3571                                  GetRawFlushedByte:
  3572                                  	; 12/01/2023
  3573 00000F8E B8070C                  	mov	ax,0C07h
  3574                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) | RAW_CON_INPUT ; 0C07h
  3575 00000F91 CD21                    	int	21h			; get char without testing or echo
  3576 00000F93 B8000C                  	mov	ax,0C00h
  3577                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + 0 ; 0C00h
  3578 00000F96 CD21                    	int	21h
  3579                                  
  3580                                  ;	Bugbug:	get rid of this return and the following retz.
  3581                                  
  3582                                  LoadCom_retn:
  3583 00000F98 C3                      	retn
  3584                                  
  3585                                  	; 21/04/2023
  3586                                  TryDoOpen:
  3587 00000F99 E8C2FF                  	call	GetComDsk
  3588                                  	;jmp	short LoadCom
  3589                                  
  3590                                  ;***	LoadCom - load in transient
  3591                                  
  3592                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3593                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:10DAh - CODERES:039Ah)
  3594                                  
  3595                                  LoadCom:
  3596                                  	;assume	ds:DATARES
  3597                                  	
  3598 00000F9C 45                      	inc	bp				; flag command read
  3599                                  
  3600 00000F9D BA[4E01]                	mov	dx,ComSpec
  3601 00000FA0 B8003D                  	mov	ax,3D00h
  3602                                  	;mov	ax,OPEN<<8	; 3D00h
  3603 00000FA3 CD21                    	int	21h				; open command.com
  3604 00000FA5 730B                    	jnc	short ReadCom
  3605                                  	;cmp	ax,4
  3606 00000FA7 83F804                  	cmp	ax,ERROR_TOO_MANY_OPEN_FILES
  3607 00000FAA 75ED                    	jnz	short TryDoOpen
  3608 00000FAC BA[A105]                	mov	dx,NOHANDMES
  3609 00000FAF E96AFD                  	jmp	FatalC				; will never find a handle
  3610                                  
  3611                                  	; 21/04/2023
  3612                                  ;TryDoOpen:
  3613                                  	;call	GetComDsk
  3614                                  	;jmp	short LoadCom
  3615                                  
  3616                                  ReadCom:
  3617 00000FB2 89C3                    	mov	bx,ax				; BX = handle
  3618                                  	;mov	dx,offset RESGROUP:TranStart
  3619 00000FB4 BA2022                  	mov	dx,TRANSTART
  3620 00000FB7 31C9                    	xor	cx,cx				; CX:DX = seek loc
  3621 00000FB9 B80042                  	mov	ax,4200h
  3622                                  	;mov	ax,LSEEK<<8	; 4200h
  3623 00000FBC CD21                    	int	21h
  3624 00000FBE 7210                    	jc	short WrongCom1
  3625                                  	; 12/01/2023
  3626                                  	;;mov	cx,offset TRANGROUP:TranSpaceEnd - 100h
  3627                                  	;mov	cx,97C5h		 ; MSDOS 5.0 COMMAND.COM
  3628 00000FC0 B9EB94                  	mov	cx,TRANSPACEEND-100h ; 4C5Ch (for original MSDOS 3.3!)
  3629 00000FC3 1E                      	push	ds
  3630 00000FC4 8E1E[9201]              	mov	ds,[TrnSeg]
  3631                                  	;assume	ds:NOTHING
  3632 00000FC8 BA0001                  	mov	dx,100h
  3633 00000FCB B43F                    	mov	ah,3Fh
  3634                                  	;mov	ah,READ	; 3Fh	
  3635 00000FCD CD21                    	int     21h	; DOS - 2+ - READ FROM FILE WITH HANDLE
  3636                                  			; BX = file handle, CX = number of bytes to read
  3637                                  			; DS:DX -> buffer
  3638 00000FCF 1F                      	pop	ds
  3639                                  	;assume	ds:DATARES
  3640                                  WrongCom1:
  3641 00000FD0 9C                      	pushf
  3642 00000FD1 50                      	push	ax
  3643 00000FD2 B43E                    	mov	ah,3Eh
  3644                                  	;mov	ah,CLOSE ; 3Eh
  3645 00000FD4 CD21                    	int	21h			; close command.com
  3646 00000FD6 58                      	pop	ax
  3647 00000FD7 9D                      	popf
  3648 00000FD8 7204                    	jc	short WrongCom		; error on read
  3649 00000FDA 39C8                    	cmp	ax,cx
  3650                                  	;retz				; size matched
  3651 00000FDC 74BA                    	jz	short LoadCom_retn
  3652                                  WrongCom:
  3653 00000FDE BA[DF04]                	mov	dx,COMBAD
  3654 00000FE1 E87AFF                  	call	GetComDsk
  3655 00000FE4 EBB6                    	jmp	short LoadCom		; try again
  3656                                  
  3657                                  ;***	ChkSum - compute transient checksum
  3658                                  
  3659                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3660                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1129h
  3661                                  ChkSum:
  3662 00000FE6 1E                      	push	ds
  3663 00000FE7 8E1E[9201]              	mov	ds,[TrnSeg]
  3664 00000FEB BE0001                  	mov	si,100h
  3665                                  	;;mov	cx,offset TRANGROUP:TranDataEnd - 100h
  3666                                  	;mov	cx,87C2h
  3667 00000FEE B9[E784]                	mov	cx,TRANDATAEND-100h	; 3E44h (for original MSDOS 3.3!)
  3668                                  Check_Sum:
  3669 00000FF1 FC                      	cld
  3670 00000FF2 D1E9                    	shr	cx,1
  3671 00000FF4 31D2                    	xor	dx,dx
  3672                                  Chk:
  3673 00000FF6 AD                      	lodsw
  3674 00000FF7 01C2                    	add	dx,ax
  3675 00000FF9 83D200                  	adc	dx,0
  3676 00000FFC E2F8                    	loop	Chk
  3677                                  
  3678                                  	; 04/05/2023
  3679 00000FFE 1F                      	pop	ds
  3680                                  
  3681                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3682 00000FFF 3B16[9A01]              	cmp	dx,[Sum]
  3683                                  
  3684                                  	;pop	ds ; 04/05/2023
  3685 00001003 C3                      	retn
  3686                                  
  3687                                  ;***	SetVect - set interrupt vectors
  3688                                  
  3689                                  SetVect:
  3690                                  	;mov	dx,offset DATARES:LodCom_Trap 
  3691                                  	; 12/01/2023
  3692 00001004 BA[7E00]                	mov	dx,LodCom_Trap
  3693                                  	;mov	dx,LODCOM ; MSDOS 3.3
  3694 00001007 B82225                  	mov	ax,2522h
  3695                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8) | 22h  ; 2522h
  3696 0000100A 89160A00                	mov	[PDB.EXIT],dx	; mov ds:0Ah,dx
  3697 0000100E 8C1E0C00                	mov	[PDB.EXIT+2],ds ; mov ds:0Ch,ds
  3698 00001012 CD21                    	int	21h
  3699                                  	;mov	dx,offset DATARES:Ctrlc_Trap
  3700 00001014 BA[4A00]                	mov	dx,Ctrlc_Trap
  3701                                  	;mov	dx,CONTC ; MSDOS 3.3
  3702 00001017 FEC0                    	inc	al	; 23h
  3703 00001019 CD21                    	int	21h
  3704                                  	;mov	dx,offset DATARES:CritErr_Trap
  3705 0000101B BA[5500]                	mov	dx,CritErr_Trap
  3706                                  	;mov	dx,CRITERR ; MSDOS 3.3
  3707 0000101E FEC0                    	inc	al	; 24h
  3708 00001020 CD21                    	int	21h
  3709 00001022 C3                      	retn
  3710                                  
  3711                                  	; MSDOS 6.0
  3712                                  ;;SR;
  3713                                  ;We have this to take care of the extra values pushed on the stack by 
  3714                                  ;the stub before jumping to LodCom1. We set up ds here and then jump to
  3715                                  ;Lodcom1
  3716                                  
  3717                                  ;public	TrnLodCom1
  3718                                  	; 12/01/2023
  3719                                  TrnLodCom1:
  3720 00001023 1F                      	pop	ds			; ds = DATARES
  3721 00001024 83C402                  	add	sp,2
  3722                                  ;	pop	ds:OldDS
  3723 00001027 E921FE                  	jmp	LodCom1
  3724                                  
  3725                                  ; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM	
  3726                                  
  3727                                  %if 0
  3728                                  
  3729                                  ;***	EndInit - end up initialization sequence
  3730                                  ;
  3731                                  ;	Move the environment to a newly allocated segment.
  3732                                  
  3733                                  	; MSDOS 3.3
  3734                                  ENDINIT:
  3735                                  	push	ds			; save segments
  3736                                  	push	es			;
  3737                                  	push	cs			; get resident segment to DS
  3738                                  	pop	ds			;
  3739                                  	;assume	ds:RESGROUP
  3740                                  	mov	cx,[USEDENV]		; get number of bytes to move
  3741                                  	mov	es,[ENVIRSEG]		; get target environment segment
  3742                                  	;assume	es:NOTHING
  3743                                  
  3744                                  	cmp	byte [RESETENV],1	; do we need to setblock to env end?
  3745                                  	jne	short NO_RESET 		; no - we already did it
  3746                                  	mov	bx,[ENVSIZ]		; BX = size of environ in paragraphs
  3747                                  	push	es			; save environment - just to be sure
  3748                                  	mov	ah,SETBLOCK  ; 4Ah	;
  3749                                  	int	21h             ; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  3750                                  				; ES = segment address of block to change
  3751                                  				; BX = new size in paragraphs
  3752                                  	pop	es
  3753                                  
  3754                                  NO_RESET:
  3755                                  	mov	[PDB.ENVIRON],es ; mov [ds:2Ch],es ; put new environment in my header
  3756                                  	mov	ds,[OLDENV]		; source environment segment
  3757                                  	;assume	ds:NOTHING
  3758                                  	xor	si,si			; set up offsets to start of segments
  3759                                  	xor	di,di
  3760                                  	cld
  3761                                  	rep	movsb			; move it
  3762                                  	xor	ax,ax
  3763                                  	stosb				; make sure it ends with double-null
  3764                                  
  3765                                  	;mov	[cs:InitFlag],FALSE	; turn off init flag
  3766                                  	pop	es
  3767                                  	pop	ds
  3768                                  	jmp	LODCOM			; allocate transient
  3769                                  
  3770                                  	; MSDOS 6.0
  3771                                  
  3772                                  ;The init code has been changed to take care of the new way in which the
  3773                                  ;environment segment is allocated.
  3774                                  ;NB: We can use all the init variables at this point because they are all in
  3775                                  ;RESGROUP
  3776                                  ;Bugbug: The above approach will not work for ROMDOS
  3777                                  
  3778                                  ;IF 0
  3779                                  ;
  3780                                  ;EndInit:
  3781                                  ;	push	ds
  3782                                  ;	push	es			;save segments
  3783                                  ;	push	cs
  3784                                  ;	pop	ds		
  3785                                  ;	assume	ds:RESGROUP
  3786                                  ;;
  3787                                  ;; AllocedEnv flag signals whether it is a passed environment or not
  3788                                  ;;
  3789                                  ;	mov	bx,ds
  3790                                  ;	mov	es,bx			;es = RESGROUP
  3791                                  ;;
  3792                                  ;;ResSize is the actual size to be retained -- only data for HIMEM COMMAND, 
  3793                                  ;; code + data for low COMMAND
  3794                                  ;;
  3795                                  ;	mov	bx,ResSize		;Total size of resident
  3796                                  ;	mov	ah,SETBLOCK
  3797                                  ;	int	21h			;Set block to resident size
  3798                                  ;;
  3799                                  ;;Allocate the correct size for the environment
  3800                                  ;;
  3801                                  ;	mov	bx,EnvSiz		;bx = env size in paras
  3802                                  ;	mov	ah,ALLOC
  3803                                  ;	int	21h			;get memory
  3804                                  ;	jc	nomem_err		;out of memory,signal error
  3805                                  ;
  3806                                  ;	mov	EnvirSeg,ax		;Store new environment segment
  3807                                  ;	mov	ds:PDB_Environ,ax		;Put new env seg in PSP
  3808                                  ;	mov	es,ax			;es = address of allocated memory
  3809                                  ;	assume	es:nothing
  3810                                  ;
  3811                                  ;;
  3812                                  ;;Copy the environment to the newly allocated segment
  3813                                  ;;
  3814                                  ;	mov	cx,UsedEnv		;number of bytes to move
  3815                                  ;
  3816                                  ;	push	ds
  3817                                  ;	mov	ds,OldEnv		;ds = Old environment segment
  3818                                  ;	assume	ds:nothing
  3819                                  ;
  3820                                  ;	xor	si,si
  3821                                  ;	mov	di,si			;Start transfer from 0
  3822                                  ;
  3823                                  ;	cld
  3824                                  ;	rep	movsb			;Do the copy
  3825                                  ;
  3826                                  ;	xor	ax,ax			
  3827                                  ;	stosb				;Make it end with double-null
  3828                                  ;
  3829                                  ;	pop	ds			;ds = RESGROUP
  3830                                  ;	assume	ds:RESGROUP
  3831                                  ;;
  3832                                  ;;We have to free the old environment block if it was allocated by INIT
  3833                                  ;;
  3834                                  ;	cmp     AllocedEnv,0            ;has env been allocated by INIT?
  3835                                  ;	je      no_free                 ;no, do not free it
  3836                                  ;
  3837                                  ;	mov	ax,OldEnv		;Get old environment
  3838                                  ;	mov	es,ax
  3839                                  ;	mov	ah,DEALLOC	
  3840                                  ;	int	21h			;Free it
  3841                                  ;no_free:
  3842                                  ;	mov	InitFlag,FALSE		;indicate INIT is done
  3843                                  ;	
  3844                                  ;	pop	es
  3845                                  ;	pop	ds
  3846                                  ;	assume	ds:nothing
  3847                                  ;	
  3848                                  ;	jmp	LodCom			;allocate transient
  3849                                  ;
  3850                                  ;nomem_err:
  3851                                  ;;
  3852                                  ;;We call the error routine which will never return. It will either exit
  3853                                  ;;with an error ( if not the first COMMAND ) or just hang after an error 
  3854                                  ;;message ( if first COMMAND )
  3855                                  ;;
  3856                                  ;
  3857                                  ;	call	Alloc_error
  3858                                  ;ENDIF
  3859                                  ;
  3860                                  ;CODERES ends
  3861                                  
  3862                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3863                                  ;	the resident group which is the location where the transient
  3864                                  ;	segments will be loaded initial.
  3865                                  
  3866                                  ;TAIL		segment public para
  3867                                  ;
  3868                                  ;		org	0
  3869                                  ;TranStart	label	word
  3870                                  ;		public	TranStart
  3871                                  ;
  3872                                  ;TAIL		ends
  3873                                  ;
  3874                                  
  3875                                  ;	This TAIL segment is used to produce a PARA aligned label in
  3876                                  ;	the transient group which is the location where the exec
  3877                                  ;	segments will be loaded initial.
  3878                                  ;
  3879                                  ;	Bugbug:	Is TRANTAIL used anymore?
  3880                                  
  3881                                  ;TRANTAIL	segment public para
  3882                                  ;
  3883                                  ;		org	0
  3884                                  ;ExecStart   	label   word
  3885                                  ;
  3886                                  ;TRANTAIL    	ends
  3887                                  
  3888                                  %endif ; 12/01/2023
  3889                                  
  3890                                  ;=============================================================================
  3891                                  ; RUCODE.ASM, MSDOS 6.0, 1991
  3892                                  ;=============================================================================
  3893                                  ; 22/09/2018 - Retro DOS v3.0
  3894                                  
  3895                                  ;	title	Localizable code for resident COMMAND
  3896                                  
  3897                                  	;assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  3898                                  
  3899                                  ; ----------------------------------------------------------------------------
  3900                                  ;***	AskEnd - ask user to confirm batch file termination
  3901                                  ;
  3902                                  ;	Confirm with user before freeing batch ...
  3903                                  ;
  3904                                  ;	ENTRY	nothing
  3905                                  ;
  3906                                  ;	EXIT	CY = set if batch termination is confirmed
  3907                                  ;
  3908                                  ;		CY = clear if batch should continue
  3909                                  ;
  3910                                  ;	USED	AX,DX,...
  3911                                  ;
  3912                                  ;	Bugbug:	move this to transient, copy to batch segment.
  3913                                  ;	Bugbug:	or move it to command1 1st.
  3914                                  ;
  3915                                  ;	Bugbug: No_Char and Yes_Char should be constants.
  3916                                  ; ----------------------------------------------------------------------------
  3917                                  
  3918                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3919                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1169h (CODERES:0429h)
  3920                                  
  3921                                  AskEnd:
  3922                                  	;assume	ds:DATARES
  3923                                  
  3924 0000102A BA[3905]                	mov	dx,ENDBATMES			; DX = message #
  3925 0000102D E86002                  	call	RPrint
  3926                                  	;call	RDISPMSG  ; MSDOS 3.3
  3927 00001030 B8010C                  	mov	ax,0C01h
  3928                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT  ;0C01h
  3929 00001033 CD21                    	int     21h             ; DOS - CLEAR KEYBOARD BUFFER
  3930                                  				; AL must be 01h, 06h, 07h, 08h, or 0Ah.
  3931 00001035 E8F102                  	call	CharToUpper			; change to upper case
  3932 00001038 3A06[4004]              	cmp	al,[NO_CHAR]
  3933 0000103C 7407                    	je	short aeRet			; answer is no (CY is clear)
  3934 0000103E 3A06[3F04]              	cmp	al,[YES_CHAR]
  3935 00001042 75E6                    	jne	short AskEnd			; invalid response, try again
  3936 00001044 F9                      	stc					; answer is yes
  3937                                  aeRet:	
  3938 00001045 C3                      	retn
  3939                                  
  3940                                  ; ----------------------------------------------------------------------------
  3941                                  ;***	DskErr - critical error handler
  3942                                  ;
  3943                                  ;	Default critical error handler unless user intercepts int 24h.
  3944                                  ;
  3945                                  ;	ENTRY	int 24h
  3946                                  ;
  3947                                  ;	EXIT
  3948                                  ;
  3949                                  ;	USED
  3950                                  ;
  3951                                  ;	EFFECTS
  3952                                  ; ----------------------------------------------------------------------------
  3953                                  
  3954                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  3955                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1185h (CODERES:0445h)
  3956                                  
  3957                                  ;SR; 
  3958                                  ;The stub is going to push the old ds value and the resident data segment
  3959                                  ;onto the stack in that order. Get it off the stack
  3960                                  
  3961                                  ;DskErr	proc	far
  3962                                  DSKERR:
  3963                                  	;assume	ds:NOTHING,es:NOTHING,ss:NOTHING
  3964                                  	; 12/01/2023
  3965 00001046 1F                      	pop	ds			; ds = DATARES
  3966                                  	;assume ds:DATARES
  3967 00001047 8F06[3804]              	pop	word [OldDS]		; save old ds value
  3968                                  
  3969                                  ;CRITERR: ; MSDOS 3.3
  3970 0000104B FB                      	sti
  3971                                  	; 12/01/2023
  3972                                  	;push	ds ; 25/09/2018
  3973 0000104C 06                      	push	es
  3974 0000104D 56                      	push	si
  3975 0000104E 51                      	push	cx
  3976 0000104F 57                      	push	di
  3977 00001050 51                      	push	cx
  3978 00001051 50                      	push	ax
  3979                                  
  3980 00001052 1E                      	push	ds			;save our data segment
  3981                                  	;push	cs ; 25/09/2018
  3982 00001053 07                      	pop	es			;es = DATARES
  3983                                  
  3984 00001054 8EDD                    	mov	ds,bp
  3985                                  	;assume	ds:nothing
  3986                                  
  3987                                  	;mov	ax,[si].SDEVATT
  3988 00001056 8B4404                  	mov	ax,[si+SYSDEV.ATT] ; mov ax,[si+4]	
  3989 00001059 268826[2801]            	mov	[es:CDevAt],ah
  3990                                  
  3991                                  	;push	cs
  3992                                  	;pop	es
  3993                                  
  3994 0000105E BF[0601]                	mov	di,DevName
  3995 00001061 B90800                  	mov	cx,8
  3996                                  	;add	si,SDEVNAME  ; add si,10
  3997 00001064 83C60A                  	add	si,SYSDEV.NAME	; save device name (even for block device)
  3998                                  				
  3999 00001067 FC                      	cld
  4000 00001068 F3A4                    	rep	movsb
  4001 0000106A 58                      	pop	ax
  4002 0000106B 59                      	pop	cx
  4003 0000106C 5F                      	pop	di
  4004                                  
  4005                                  ;	Stack still contains DS and ES.
  4006                                  
  4007                                  ;SR;
  4008                                  ;We need ds = DATARES for SavHand
  4009                                  
  4010                                  	 ;12/01/2023
  4011 0000106D 06                      	push	es
  4012 0000106E 1F                      	pop	ds
  4013                                  	;assume	ds:DATARES
  4014                                  
  4015                                  	;invoke	SavHand		; save user's stdin/out, set to our stderr
  4016 0000106F E8A7FE                  	call	SavHand
  4017                                  
  4018                                  	; 12/01/2023
  4019                                  	; 25/09/2018
  4020                                  	;;push	cs
  4021                                  	;push	es
  4022                                  	;pop	ds		; set up local data segment
  4023                                  	;assume	ds:resgroup
  4024                                  
  4025 00001072 52                      	push	dx
  4026 00001073 E81702                  	call	crlf
  4027 00001076 5A                      	pop	dx
  4028                                  
  4029                                  ;	Bugbug:	rename Crit_Err_Info to CritErrAH?
  4030                                  
  4031 00001077 8826[9F01]              	mov	[Crit_Err_Info],ah	; save critical error flags
  4032                                  
  4033                                  ;	Compute and save ASCII drive letter (nonsense for char devices)
  4034                                  
  4035 0000107B 0441                    	add	al,'A'
  4036 0000107D A2[FF00]                	mov	[DrvLet],al
  4037                                  
  4038                                  ;	Bugbug:	These labels are awful. Change, especially 'NoHardE'.
  4039                                  
  4040 00001080 F6C480                  	test	ah,80h
  4041 00001083 740A                    	jz	short NoHardE		; it's a disk-device error
  4042 00001085 F606[2801]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4043 0000108A 7503                    	jnz	short NoHardE		; it's a character device
  4044 0000108C E9F101                  	jmp	FatErr			; it's a FAT error
  4045                                  
  4046                                  NoHardE:
  4047 0000108F BE[6104]                	mov	si,MREAD		; SI = "read" msg #
  4048 00001092 F6C401                  	test	ah,1
  4049 00001095 7403                    	jz	short SavMes		; it's a read error
  4050 00001097 BE[6A04]                	mov	si,MWRITE		; SI = "write" msg #
  4051                                  SavMes:
  4052 0000109A 893E[6103]              	mov	[OldErrNo],di		; save critical error code
  4053                                  
  4054                                  ;	Bugbug:	don't need to save/restore all here?
  4055                                  
  4056 0000109E 06                      	push	es
  4057 0000109F 1E                      	push	ds			; GetExtendedError likes to STOMP
  4058                                  	; 12/01/2023
  4059                                  	; (all registers are changed -in dos service- except bp) *
  4060                                  	;push	bp
  4061 000010A0 56                      	push	si
  4062 000010A1 52                      	push	dx
  4063 000010A2 51                      	push	cx
  4064 000010A3 53                      	push	bx
  4065 000010A4 B459                    	mov	ah,59h ; * ; 05/06/2023 (BugFix)
  4066                                  	;mov	ah,GetExtendedError ; 59h ; get extended error info
  4067 000010A6 CD21                    	int	21h
  4068 000010A8 5B                      	pop	bx
  4069 000010A9 59                      	pop	cx
  4070 000010AA 5A                      	pop	dx
  4071 000010AB 5E                      	pop	si
  4072                                  	; 12/01/2023
  4073                                  	;pop	bp
  4074 000010AC 1F                      	pop	ds
  4075 000010AD 893E[3601]              	mov	[NeedVol],di		; save possible ptr to volume label
  4076 000010B1 8C06[3801]              	mov	[NeedVol+2],es
  4077 000010B5 07                      	pop	es
  4078                                  
  4079                                  ;	Bugbug:	AX has extended error code, so no need to zero AH?
  4080                                  
  4081 000010B6 30E4                    	xor	ah,ah
  4082 000010B8 89C7                    	mov	di,ax			; DI = error code
  4083                                  
  4084                                  ; Bugbug: somewhat obsolete documentation?
  4085                                  ;
  4086                                  ; DI is now the correct error code. Classify things to see what we are
  4087                                  ; allowed to report. We convert DI into a 0-based index into a message table.
  4088                                  ; This presumes that the int 24 errors (oldstyle) and new errors (sharing and
  4089                                  ; the like) are contiguous.
  4090                                  
  4091                                  ;	Bugbug:	simplify following code by cmp'ing instead of sub'ing.
  4092                                  ;	Check use of ErrCd_24, though.
  4093                                  
  4094 000010BA 83EF13                  	sub	di,ERROR_WRITE_PROTECT ; 13h
  4095 000010BD 7303                    	jae	short HavCod
  4096                                  
  4097                                  ;	Bugbug:	wouldn't it be better to display the original error msg,
  4098                                  ;	even though it's not a critical error?
  4099                                  
  4100 000010BF BF0C00                  	mov	di,ERROR_GEN_FAILURE - ERROR_WRITE_PROTECT ; mov di,0Ch
  4101                                  
  4102                                  ; DI now has the mapped error code. Old style errors are:
  4103                                  ;   FOOBAR <read|writ>ing drive ZZ.
  4104                                  ; New style errors are:
  4105                                  ;   FOOBAR
  4106                                  ; We need to figure out which the particular error belongs to.
  4107                                  
  4108                                  HavCod:
  4109 000010C2 C606[3A01]00            	mov	byte [ErrType],0	; assume old style
  4110 000010C7 83FF10                  	cmp	di,ERROR_FCB_UNAVAILABLE - ERROR_WRITE_PROTECT  ; cmp di,10h
  4111 000010CA 7405                    	je	short SetStyle
  4112 000010CC 83FF11                  	cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4113 000010CF 7504                    	jne	short GotStyle
  4114                                  
  4115                                  SetStyle:
  4116                                  ;	Bugbug:	use INC
  4117                                  	;mov	byte [ErrType],1		; must be new type
  4118 000010D1 FE06[3A01]              	inc	byte [ErrType] ; Retro DOS v3.0 COMMAND.COM - 22/09/2018
  4119                                  
  4120                                  GotStyle:
  4121 000010D5 893E[4701]              	mov	[ErrCd_24],di
  4122                                  	; 12/01/2023
  4123                                  	; 25/09/2018
  4124                                  	; MSDOS 6.0
  4125 000010D9 83FF14                  	cmp	di,ERROR_HANDLE_DISK_FULL - ERROR_WRITE_PROTECT ; cmp di,14h
  4126                                  	; MSDOS 3.3
  4127                                  	;cmp	di,ERROR_SHARING_BUFFER_EXCEEDED - ERROR_WRITE_PROTECT ; cmp di,11h
  4128                                  
  4129                                  						; If the error message is unknown
  4130 000010DC 7642                    	jbe	short NormalError		;  redirector, continue. Otherwise,
  4131                                  
  4132                                  ; We do not know how to handle this error. Ask IFSFUNC if she knows
  4133                                  ; how to handle things
  4134                                  
  4135                                  ;input to IFSFUNC:    AL=1
  4136                                  ;		      BX=extended error number
  4137                                  ;
  4138                                  ;output from IFSFUNC: AL=error type (0 or 1)
  4139                                  ;			 0=<message> error (read/writ)ing (drive/device) xxx
  4140                                  ;			   Abort, Retry, Ignore
  4141                                  ;			 1=<message>
  4142                                  ;			   Abort, Retry, Ignore
  4143                                  ;		      ES:DI=pointer to message text
  4144                                  ;		      carry set=>no message
  4145                                  
  4146 000010DE 89C7                    	mov	di,ax			; retrieve correct extended error...
  4147 000010E0 B80005                  	mov	ax,0500h		; is the redir there?
  4148 000010E3 CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
  4149                                  			; Return: AL = 00h not installed, OK to install
  4150                                  			; 01h not installed, can't install
  4151                                  			; FFh installed
  4152 000010E5 3CFF                    	cmp	al,0FFh
  4153 000010E7 752A                    	jne	short NoHandler		; no, go to NoHandler
  4154                                  
  4155                                  	; 12/01/2023
  4156                                  	; MSDOS 6.0
  4157 000010E9 53                      	push	bx
  4158 000010EA 89FB                    	mov	bx,di			; get ErrType and ptr to error msg
  4159 000010EC B80105                  	mov	ax,0501h
  4160 000010EF CD2F                    	int	2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4161 000010F1 5B                      	pop	bx 
  4162 000010F2 721F                    	jc	short NoHandler
  4163                                  	
  4164                                  	; MSDOS 3.3
  4165                                  	;mov     ax,di
  4166                                  	;mov     ah,5
  4167                                  	;int     2Fh	; Multiplex - DOS 3+ CRITICAL ERROR HANDLER -
  4168                                  	;jc      short NOHANDLER
  4169                                  
  4170                                  ;	Bugbug:	need to record error type?
  4171                                  
  4172 000010F4 A2[3A01]                	mov	[ErrType],al
  4173                                  
  4174 000010F7 1E                      	push	ds
  4175 000010F8 06                      	push	es
  4176 000010F9 1F                      	pop	ds
  4177 000010FA 89FA                    	mov	dx,di
  4178 000010FC B9FFFF                  	mov	cx,-1			; find end of msg
  4179 000010FF 30C0                    	xor	al,al
  4180                                  
  4181 00001101 FC                      	cld
  4182 00001102 F2AE                    	repnz	scasb
  4183                                  
  4184                                  ;	Bugbug:	we can do better than this.
  4185                                  
  4186 00001104 C645FF24                	mov	byte [di-1],'$'
  4187                                  	
  4188                                  	;CALL	RDISPMSG ; MSDOS 3.3
  4189                                  	
  4190 00001108 B409                    	mov	ah,STD_CON_STRING_OUTPUT ; 9	; print the message
  4191 0000110A CD21                    	int	21h
  4192                                  
  4193 0000110C C645FF00                	mov	byte [di-1],0			; restore terminal byte
  4194                                  
  4195 00001110 1F                      	pop	ds				; clean up and continue
  4196 00001111 EB15                    	jmp	short CheckErrType
  4197                                  
  4198                                  ;*	Redir isn't available or doesn't recognize the error.
  4199                                  ;	Restore regs to unextended error.
  4200                                  
  4201                                  NoHandler:
  4202 00001113 C606[3A01]00            	mov	byte [ErrType],0
  4203                                  ;	Bugbug:	won't this break, since we add error_write_protect back in?
  4204 00001118 8B3E[6103]              	mov	di,[OldErrNo]
  4205 0000111C 893E[4701]              	mov	[ErrCd_24],di
  4206                                  
  4207                                  NormalError:
  4208                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4209                                  	; MSDOS 6.0
  4210 00001120 83C713                  	add	di,ERROR_WRITE_PROTECT
  4211 00001123 87FA                    	xchg	di,dx			; may need dx later
  4212 00001125 E88101                  	call	RPrintCrit		; print error type
  4213                                  
  4214                                  	; MSDOS 3.3
  4215                                  	;shl     di,1
  4216                                  	;mov     di,[CRMSGTBL+di]
  4217                                  	;xchg    di,dx
  4218                                  	;call    RDISPMSG
  4219                                  
  4220                                  CheckErrType:
  4221 00001128 803E[3A01]00            	cmp	byte [ErrType],0	; Check error style...
  4222 0000112D 7405                    	je	short ContOld
  4223 0000112F E85B01                  	call	crlf			; if new style then done printing
  4224 00001132 EB31                    	jmp	short Ask
  4225                                  
  4226                                  ContOld:
  4227                                  	; 12/01/2023
  4228                                  	; MSDOS 6.0
  4229 00001134 46                      	inc	si			; DS:SI = ptr to asciiz string
  4230                                  
  4231                                  ;	Bugbug:	combine some of the following two sections?
  4232                                  
  4233                                  	; 12/01/2023
  4234 00001135 F606[2801]80            	test	byte [CDevAt],DEVTYP>>8 ; 80h
  4235                                  	;test	byte [CDevAt],DEVTYP shr 8 ; 80h
  4236 0000113A 740F                    	jz	short BlkErr
  4237                                  	;;mov	dx,offset DATARES:CharDevErr	; DX = ptr to device message
  4238                                  	;mov	dx,ChardevErr
  4239 0000113C BA[8204]                	mov	dx,MDEVICE
  4240                                  	;mov	[CharDevErrRw.SubstPtr],si	; point to read/write string
  4241 0000113F 8936[0101]              	mov	[CharDevErrRw],si
  4242                                  	;mov	si,offset DATARES:CharDevErrSubst; SI = ptr to subst block
  4243 00001143 BE[0001]                	mov	si,CharDevErrSubst
  4244                                  
  4245 00001146 E84701                  	call	RPrint				; print the message
  4246 00001149 EB1A                    	jmp	short Ask			; don't ralph on command
  4247                                  
  4248                                  	; 12/01/2023
  4249                                  	; MSDOS 3.3
  4250                                  	;mov	dx,ERRMES
  4251                                  	;call	RDISPMSG
  4252                                  	;mov	dx,si
  4253                                  	;call	RDISPMSG
  4254                                  	;
  4255                                  	;test	byte [CDevAt],80h
  4256                                  	;jz	short BLKERR
  4257                                  	;mov	dx,CHARDEVERR	; " device "
  4258                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4259                                  	;int	21h		; DOS - PRINT STRING
  4260                                  	;			; DS:DX -> string terminated by "$"
  4261                                  	;jmp	short ASK
  4262                                  
  4263                                  BlkErr:
  4264                                  	; 12/01/2023
  4265                                  	; MSDOS 6.0
  4266                                  	;;mov	dx,offset DATARES:BlkDevErr	; DX = error msg #
  4267                                  	;mov	dx,BlkDevErr
  4268 0000114B BA[7304]                	mov	dx,MDRIVE
  4269                                  	;mov	[BlkDevErrRw.SubstPtr],si	; "reading","writing" ptr
  4270 0000114E 8936[FA00]              	mov	[BlkDevErrRw],si
  4271                                  	;mov	si,offset DATARES:BlkDevErrSubst ; SI = ptr to subst block
  4272 00001152 BE[F900]                	mov	si,BlkDevErrSubst
  4273 00001155 E83801                  	call	RPrint
  4274                                  
  4275                                  	; MSDOS 3.3
  4276                                  	;mov	dx,BLKDEVERR
  4277                                  	;call	RDISPMSG
  4278                                  
  4279 00001158 803E[4B01]00            	cmp	byte [Loading],0
  4280 0000115D 7406                    	jz	short Ask
  4281 0000115F E8E0FD                  	call	RestHand
  4282 00001162 E9D7FD                  	jmp	GetComDsk2		; if error loading COMMAND, re-prompt
  4283                                  Ask:
  4284 00001165 833E[4701]0F            	cmp	word [ErrCd_24],15	; error 15 has an extra message
  4285 0000116A 751E                    	jne	short Not15		; not error 15
  4286                                  
  4287                                  ;*	For error 15, tell the user which volume/serial # are needed.
  4288                                  
  4289 0000116C 51                      	push	cx
  4290                                  
  4291                                  ;	Bugbug:	does this push/pop need to be done?
  4292                                  
  4293 0000116D 1E                      	push	ds
  4294 0000116E 07                      	pop	es
  4295 0000116F C536[3601]              	lds	si,[NeedVol]
  4296                                  	;assume	ds:NOTHING
  4297 00001173 57                      	push	di
  4298 00001174 BF[1801]                	mov	di,VolName
  4299                                  	; 12/01/2023
  4300                                  	; MSDOS 6.0
  4301 00001177 B91000                  	mov	cx,16			; copy volume name & serial #
  4302                                  	; MSDOS 3.3
  4303                                  	;mov	cx,11			; copy volume name
  4304 0000117A FC                      	cld
  4305 0000117B F3A4                    	rep	movsb
  4306 0000117D 5F                      	pop	di
  4307 0000117E 06                      	push	es
  4308 0000117F 1F                      	pop	ds
  4309 00001180 59                      	pop	cx
  4310                                  	;assume	ds:DATARES
  4311                                  	; 12/01/2023
  4312                                  	; MSDOS 6.0
  4313                                  	;mov	dx,offset DATARES:NeedVolMsg	; DX = ptr to msg
  4314                                  	;mov	si,offset DATARES:NeedVolSubst	; DS:SI = ptr to subst block
  4315                                  	;mov	dx,NeedVolMsg
  4316 00001181 BA[9204]                	mov	dx,MVOLSERIAL
  4317 00001184 BE[0F01]                	mov	si,NeedVolSubst
  4318 00001187 E80601                  	call	RPrint
  4319                                  
  4320                                  	; MSDOS 3.3
  4321                                  	;mov	dx,NEEDVOLMSG
  4322                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  4323                                  	;int	21h		; DOS - PRINT STRING
  4324                                  	;			; DS:DX -> string terminated by "$"
  4325                                  Not15:
  4326                                  ;*	Print abort, retry, ignore, fail message.
  4327                                  ;	Print only options that are valid.
  4328                                  
  4329                                  ;	Bugbug:	sizzle this.
  4330                                  
  4331                                  	; 12/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4332 0000118A BA[4104]                	mov	dx,REQ_ABORT
  4333 0000118D E80001                  	call	RPrint
  4334                                  	;call	RDISPMSG
  4335 00001190 F606[9F01]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED  ; 10h
  4336 00001195 7406                    	jz	short Try_Ignore
  4337 00001197 BA[4704]                	mov	dx,REQ_RETRY
  4338 0000119A E8F300                  	call	RPrint
  4339                                  	;call	RDISPMSG
  4340                                  Try_Ignore:
  4341 0000119D F606[9F01]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h
  4342 000011A2 7406                    	jz	short Try_Fail
  4343 000011A4 BA[4F04]                	mov	dx,REQ_IGNORE
  4344 000011A7 E8E600                  	call	RPrint
  4345                                  	;call	RDISPMSG
  4346                                  Try_Fail:
  4347 000011AA F606[9F01]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED   ; 08h
  4348 000011AF 7406                    	jz	short Term_Question
  4349 000011B1 BA[5804]                	mov	dx,REQ_FAIL
  4350 000011B4 E8D900                  	call	RPrint
  4351                                  	;call	RDISPMSG
  4352                                  Term_Question:
  4353 000011B7 BA[5F04]                	mov	dx,REQ_END
  4354 000011BA E8D300                  	call	RPrint
  4355                                  	;call	RDISPMSG
  4356                                  
  4357                                  ;	If the /f switch was given, we fail all requests.
  4358                                  
  4359 000011BD F606[AA01]FF            	test	byte [fFail],-1
  4360 000011C2 741B                    	jz	short DoPrompt
  4361 000011C4 B403                    	mov	ah,3				; signal fail
  4362 000011C6 E9A800                  	jmp	EExit
  4363                                  
  4364                                  	; 16/04/2023
  4365                                  Abort_Process:
  4366 000011C9 F606[1702]01            	test	byte [InitFlag],INITINIT ; 1	; COMMAND init interrupted?
  4367 000011CE 745D                    	jz	short AbortCont			; no, handle it normally
  4368 000011D0 803E[A501]00            	cmp	byte [PermCom],0		; are we top level process?
  4369 000011D5 744B                    	jz	short JustExit			; yes, just exit
  4370                                  
  4371 000011D7 BA[4506]                	mov	dx,PATRICIDE			; no, load ptr to error msg
  4372                                  	; 12/01/2023
  4373 000011DA E8B300                  	call	RPrint				; print it
  4374                                  	;call	RDISPMSG
  4375                                  DeadInTheWater:
  4376 000011DD EBFE                    	jmp	short DeadInTheWater		; loop until the user reboots
  4377                                  
  4378                                  DoPrompt:
  4379                                  	; 12/01/2023
  4380 000011DF B8010C                  	mov	ax,0C01h
  4381                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8) + STD_CON_INPUT ; 0C01h
  4382 000011E2 CD21                    	int	21h				; get response
  4383                                  
  4384 000011E4 E8A600                  	call	crlf
  4385 000011E7 E83F01                  	call	CharToUpper			; convert to upper case
  4386 000011EA B400                    	mov	ah,0				; return code for ignore
  4387 000011EC F606[9F01]20            	test	byte [Crit_Err_Info],IGNORE_ALLOWED ; 20h ; is ignore allowed?
  4388 000011F1 7406                    	jz	short User_Retry
  4389 000011F3 3A06[3D04]              	cmp	al,[IGNORE_CHAR]		; ignore?
  4390                                  	;jz	short EExitJ
  4391                                  	; 16/04/2023
  4392 000011F7 7478                    	jz	short EExit
  4393                                  
  4394                                  ;	Bugbug:	optimize following code.
  4395                                  
  4396                                  User_Retry:
  4397 000011F9 FEC4                    	inc	ah				; return code for retry
  4398 000011FB F606[9F01]10            	test	byte [Crit_Err_Info],RETRY_ALLOWED ; 10h ; is retry allowed?
  4399 00001200 7406                    	jz	short User_Abort
  4400 00001202 3A06[3C04]              	cmp	al,[RETRY_CHAR]			; retry?
  4401                                  	;jz	short EExitJ
  4402                                  	; 16/04/2023
  4403 00001206 7469                    	jz	short EExit
  4404                                  User_Abort:
  4405 00001208 FEC4                    	inc	ah				; return code for abort
  4406                                  						;  (abort always allowed)
  4407 0000120A 3A06[3B04]              	cmp	al,[ABORT_CHAR]			; abort?
  4408 0000120E 74B9                    	jz	short Abort_Process		; exit user program
  4409 00001210 FEC4                    	inc	ah				; return code for fail
  4410 00001212 F606[9F01]08            	test	byte [Crit_Err_Info],FAIL_ALLOWED ; 08h ; is fail allowed?
  4411 00001217 7406                    	jz	short AskJ
  4412 00001219 3A06[3E04]              	cmp	al,[FAIL_CHAR]			; fail?
  4413                                  	;jz	short EExitJ
  4414                                  	; 16/04/2023
  4415 0000121D 7452                    	jz	short EExit
  4416                                  AskJ:
  4417 0000121F E943FF                  	jmp	Ask
  4418                                  
  4419                                  	; 12/01/2023
  4420                                  ;EExitJ:
  4421                                  	;jmp	short EExit
  4422                                  
  4423                                  JustExit:
  4424                                  	;assume	ds:DATARES
  4425                                  	; 12/01/2023
  4426 00001222 A1[4101]                	mov	ax,[Parent]			; load real parent pid
  4427                                  	;mov	[16h],ax
  4428 00001225 A31600                  	mov	[PDB.PARENT_PID],ax		; put it back where it belongs
  4429 00001228 B8FF4C                  	mov	ax,4CFFh
  4430                                  	;mov	ax,(EXIT<<8) | 255 ; 4CFFh
  4431 0000122B CD21                    	int     21h             ; DOS - 2+ - QUIT WITH EXIT CODE (EXIT)
  4432                                  				; AL = exit code
  4433                                  AbortCont:
  4434 0000122D F606[9501]FF            	test	byte [In_Batch],-1		; Are we accessing a batch file?
  4435 00001232 7405                    	jz	short Not_Batch_Abort
  4436 00001234 C606[9601]01            	mov	byte [Batch_Abort],1		; set flag for abort
  4437                                  
  4438                                  Not_Batch_Abort:
  4439 00001239 8A16[1802]              	mov	dl,[PipeFlag]
  4440 0000123D E8C8FA                  	call	ResPipeOff
  4441 00001240 08D2                    	or	dl,dl
  4442 00001242 740D                    	je	short CheckForA
  4443 00001244 833E[A601]00            	cmp	word [SingleCom],0
  4444 00001249 7406                    	je	short CheckForA
  4445 0000124B C706[A601]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4446                                  
  4447                                  CheckForA:
  4448 00001251 833E[4701]00            	cmp	word [ErrCd_24],0		; write protect?
  4449 00001256 7407                    	je	short abortfor
  4450 00001258 833E[4701]02            	cmp	word [ErrCd_24],2		; drive not ready?
  4451 0000125D 7512                    	jne	short EExit			; don't abort the FOR
  4452                                  
  4453                                  abortfor:
  4454 0000125F C606[AC01]00            	mov	byte [ForFlag],0		; abort a FOR in progress
  4455 00001264 833E[A601]00            	cmp	word [SingleCom],0
  4456 00001269 7406                    	je	short EExit
  4457 0000126B C706[A601]FFFF          	mov	word [SingleCom],-1		; make sure SingleCom exits
  4458                                  
  4459                                  EExit:
  4460 00001271 88E0                    	mov	al,ah
  4461 00001273 89FA                    	mov	dx,di
  4462                                  RestHd:
  4463 00001275 E8CAFC                  	call    RestHand
  4464 00001278 59                      	pop	cx
  4465 00001279 5E                      	pop	si				; restore registers
  4466 0000127A 07                      	pop	es
  4467                                  
  4468                                  	; 12/01/2023	
  4469                                  	; MSDOS 6.0
  4470                                  ;;	pop	ds
  4471                                  ;SR;
  4472                                  ;ds has to be got from the variable we saved it in
  4473                                  
  4474 0000127B 8E1E[3804]               	mov	ds,[OldDS]			; restore old value of ds
  4475                                  
  4476                                  ;	pop	ds
  4477                                  ;	assume	ds:nothing
  4478                                  
  4479                                  	; MSDOS 3.3
  4480                                  	;pop	ds
  4481                                  
  4482 0000127F CF                      	iret
  4483                                  
  4484                                  FatErr:
  4485                                  	; 12/01/2023
  4486                                  	; MSDOS 6.0
  4487                                  	;mov	dx,offset DATARES:BadFatMsg
  4488                                  	;mov	si,offset DATARES:BadFatSubst
  4489 00001280 BA[B904]                	mov	dx,BADFATMSG
  4490 00001283 BE[2901]                	mov	si,BadFatSubst
  4491 00001286 E80700                  	call	RPrint
  4492                                  
  4493                                  	; MSDOS 3.3
  4494                                  	;mov	dx,BADFATMSG
  4495                                  	;call	RDISPMSG
  4496                                  	;mov	dx,BLKDEVERR
  4497                                  	;call	RDISPMSG
  4498                                  
  4499 00001289 B002                    	mov	al,2				; abort
  4500 0000128B EBE8                    	jmp	short RestHd
  4501                                  
  4502                                  ;DskErr	endp
  4503                                  
  4504                                  	; MSDOS 6.0
  4505                                  ; ----------------------------------------------------------------------------
  4506                                  ;***	RPrint - print message
  4507                                  ;***	Crlf - display cr/lf
  4508                                  ;
  4509                                  ;	ENTRY	DS:DX = ptr to count byte, followed by message text
  4510                                  ;		DS:SI = ptr to 1st substitution block for this msg, if any
  4511                                  ;		variable fields related to substitution blocks are set
  4512                                  ;
  4513                                  ;	EXIT	nothing
  4514                                  ;
  4515                                  ;	USED	flags
  4516                                  ;
  4517                                  ;	EFFECTS
  4518                                  ;	  Message is displayed on stdout.
  4519                                  ;
  4520                                  ;	NOTE
  4521                                  ;	  Number of substitutions (%1, %2,...) in message text must not
  4522                                  ;	  be greater than number of substition blocks present.
  4523                                  ; ----------------------------------------------------------------------------
  4524                                  
  4525                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4526                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:13D1h (CODERES:0691h)
  4527                                  
  4528                                  crlf: 
  4529                                  	;mov	dx,offset DATARES:Newlin ; cheap newline
  4530                                  	; 14/01/2023
  4531 0000128D BA[7406]                	mov	dx,NEWLINE
  4532                                  
  4533                                  ;RPrint	proc
  4534                                  ;
  4535                                  ;	assume	ds:DATARES,ss:DATARES
  4536                                  ;
  4537                                  	; 14/01/2023
  4538                                  RPrint:
  4539                                  
  4540                                  ;	Bugbug:	do we need to save all reg's?
  4541                                  
  4542 00001290 56                      	push	si			; preserve registers
  4543 00001291 50                      	push	ax
  4544 00001292 53                      	push	bx
  4545 00001293 51                      	push	cx
  4546 00001294 52                      	push	dx
  4547                                  
  4548 00001295 89F3                    	mov	bx,si			; DS:BX = ptr to subst block
  4549 00001297 89D6                    	mov	si,dx			; DS:SI = ptr to count byte
  4550 00001299 AC                      	lodsb				; AL = message length
  4551                                  					; DS:SI = ptr to message text
  4552 0000129A 31C9                    	xor	cx,cx
  4553 0000129C 88C1                    	mov	cl,al			; CX = message length
  4554 0000129E E303                    	jcxz	rpRet
  4555                                  
  4556 000012A0 E81900                  	call	RDispMsg
  4557                                  
  4558 000012A3 5A                      rpRet:	pop	dx
  4559 000012A4 59                      	pop	cx
  4560 000012A5 5B                      	pop	bx
  4561 000012A6 58                      	pop	ax
  4562 000012A7 5E                      	pop	si
  4563 000012A8 C3                      	retn
  4564                                  
  4565                                  ;RPrint	endp
  4566                                  
  4567                                  	; 14/01/2023
  4568                                  ;	; MSDOS 3.3
  4569                                  ;CRLF:
  4570                                  ;	mov     dx,NEWLIN
  4571                                  ;
  4572                                  ;RDISPMSG: ; Display message/text
  4573                                  ;	; DS:DX = ($ terminated) Message/Text address 
  4574                                  ;	push    ax
  4575                                  ;	mov     ah,STD_CON_STRING_OUTPUT ; 9
  4576                                  ;	clc
  4577                                  ;	int     21h             ; DOS - PRINT STRING
  4578                                  ;				; DS:DX -> string terminated by "$"
  4579                                  ;	pop     ax
  4580                                  ;	retn
  4581                                  
  4582                                  
  4583                                  	; MSDOS 6.0
  4584                                  ; ----------------------------------------------------------------------------
  4585                                  ;***	RPrintCrit - print critical error message
  4586                                  ;
  4587                                  ;	ENTRY	DX = extended error # (19-39)
  4588                                  ;
  4589                                  ;	EXIT	nothing
  4590                                  ;
  4591                                  ;	USED	flags
  4592                                  ;
  4593                                  ;	EFFECTS
  4594                                  ;	  Message is displayed on stdout
  4595                                  ; ----------------------------------------------------------------------------
  4596                                  
  4597                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4598                                  
  4599                                  ;RPrintCrit	proc
  4600                                  ;	assume	ds:DATARES,ss:DATARES
  4601                                  
  4602                                  	; 14/01/2023
  4603                                  RPrintCrit:
  4604 000012A9 52                      	push	dx			; preserve DX
  4605 000012AA 87DA                    	xchg	bx,dx			; BX = extended error #
  4606                                  					; DX = saved BX
  4607 000012AC 83EB13                  	sub	bx,19			; BX = critical error index, from 0
  4608 000012AF D1E3                    	shl	bx,1			; BX = offset in word table
  4609 000012B1 8B9F[0E08]              	mov	bx,[bx+CRITMSGPTRS]	; BX = ptr to error msg
  4610 000012B5 87DA                    	xchg	bx,dx			; DX = ptr to error msg
  4611                                  					; BX = restored
  4612 000012B7 E8D6FF                  	call	RPrint			; print the message
  4613 000012BA 5A                      	pop	dx			; restore DX
  4614 000012BB C3                      	retn
  4615                                  
  4616                                  ;RPrintCrit	endp
  4617                                  
  4618                                  ; ----------------------------------------------------------------------------
  4619                                  ;***	RDispMsg - display message
  4620                                  ;
  4621                                  ;	Display message, with substitutions, for RPrint.
  4622                                  ;
  4623                                  ;	ENTRY	DS:SI = ptr to message text
  4624                                  ;		CX = message length
  4625                                  ;		DS:BX = ptr to substitution block, if any
  4626                                  ;
  4627                                  ;	EXIT	nothing
  4628                                  ;
  4629                                  ;	USED	AX,CX,DX,SI
  4630                                  ; ----------------------------------------------------------------------------
  4631                                  
  4632                                  ;RDispMsg	proc
  4633                                  ;	assume	ds:DATARES,ss:DATARES
  4634                                  
  4635                                  RDispMsg:
  4636                                  	; 14/01/2023
  4637                                  rdNextChar:
  4638 000012BC AC                      	lodsb				; AL = next char
  4639 000012BD 3C25                    	cmp	al,'%'
  4640 000012BF 7511                    	jne	short rdOutChar		; not a substitution
  4641 000012C1 8A14                    	mov	dl,[si]			; DL = possible '1' - '9'
  4642 000012C3 80EA31                  	sub	dl,'1'			; DL = 0 - 8 = '1' - '9'
  4643 000012C6 80FA09                  	cmp	dl,9
  4644 000012C9 7307                    	jae	short rdOutChar		; not a substitution
  4645                                  
  4646                                  ;*	A substitution code %1 - %9 has been encountered.
  4647                                  ;	DL = 0-8, indicating %1-%9
  4648                                  ;	DS:BX = ptr to substitution block
  4649                                  
  4650 000012CB E80D00                  	call	SubstMsg		; display the substitution
  4651 000012CE 46                      	inc	si			; SI = ptr past %n
  4652 000012CF 49                      	dec	cx			; count extra character in %n
  4653 000012D0 EB06                    	jmp	short rdCharDone
  4654                                  
  4655                                  ;*	Normal character output.
  4656                                  
  4657                                  rdOutChar:
  4658 000012D2 88C2                    	mov	dl,al			; DL = char
  4659 000012D4 B402                    	mov	ah,2			; AH = DOS Character Output code
  4660 000012D6 CD21                    	int	21h			; call DOS
  4661                                  rdCharDone:
  4662 000012D8 E2E2                    	loop	rdNextChar
  4663 000012DA C3                      	retn
  4664                                  
  4665                                  ;RDispMsg	endp
  4666                                  
  4667                                  ; ----------------------------------------------------------------------------
  4668                                  ;***	SubstMsg - display message substitution
  4669                                  ;
  4670                                  ;	Display a substitution string within a message.
  4671                                  ;	Substitution can be a char, an ASCIIZ string, or
  4672                                  ;	a word to be displayed as hex digits.
  4673                                  ;
  4674                                  ;	ENTRY	DL = substitution index 0-8 (for codes %1-%9)
  4675                                  ;		DS:BX = ptr to substitution block
  4676                                  ;
  4677                                  ;	EXIT	nothing
  4678                                  ;
  4679                                  ;	USED	AX,DX
  4680                                  ; ----------------------------------------------------------------------------
  4681                                  
  4682                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4683                                  
  4684                                  ;SubstMsg	proc
  4685                                  ;	assume	ds:DATARES,ss:DATARES
  4686                                  	
  4687                                  	; 14/01/2023
  4688                                  SubstMsg:
  4689 000012DB 53                      	push	bx			; preserve BX
  4690 000012DC 51                      	push	cx			; preserve CX
  4691                                  
  4692                                  	;mov	al,size SUBST		; AL = size of substitution block
  4693 000012DD B003                    	mov	al,3
  4694 000012DF F6E2                    	mul	dl			; AX = offset of desired subst block
  4695 000012E1 01C3                    	add	bx,ax			; DS:BX = ptr to desired subst block
  4696                                  
  4697                                  	;mov	al,[bx].SubstType	; AX = substitution type flag
  4698 000012E3 8A07                    	mov	al,[bx]
  4699                                  	;mov	bx,[bx].SubstPtr	; BX = ptr to char, str, or hex value
  4700 000012E5 8B5F01                  	mov	bx,[bx+1]
  4701                                  
  4702                                  ;	AL = 1, 2, or 3 for char, string, or hex type
  4703                                  
  4704 000012E8 FEC8                    	dec	al
  4705 000012EA 7428                    	jz	short smChar
  4706 000012EC FEC8                    	dec	al
  4707 000012EE 742C                    	jz	short smStr
  4708                                  
  4709                                  ;*	Hex number substitution.
  4710                                  
  4711                                  	;mov	ax,ds:[bx]		; AX = word value
  4712 000012F0 8B07                    	mov	ax,[bx]
  4713 000012F2 B90400                  	mov	cx,4			; CX = # digits to display
  4714                                  smDigit:
  4715 000012F5 D1C0                    	rol	ax,1
  4716 000012F7 D1C0                    	rol	ax,1
  4717 000012F9 D1C0                    	rol	ax,1
  4718 000012FB D1C0                    	rol	ax,1			; AL<3:0> = next digit
  4719                                  
  4720 000012FD 50                      	push	ax			; save other digits
  4721 000012FE 240F                    	and	al,0Fh			; AL = binary digit
  4722 00001300 0430                    	add	al,'0'			; AL = ascii digit if 0-9
  4723 00001302 3C39                    	cmp	al,'9'
  4724 00001304 7602                    	jbe	short smDigit09		; it's 0-9
  4725                                  	;add	al,7
  4726 00001306 0407                    	add	al,('A' - '0') - 10	; AL = ascii digit A-F
  4727                                  smDigit09:
  4728 00001308 88C2                    	mov	dl,al			; DL = ascii digit
  4729 0000130A B402                    	mov	ah,2
  4730 0000130C CD21                    	int	21h			; output the ascii digit
  4731 0000130E 58                      	pop	ax			; restore all digits
  4732                                  
  4733 0000130F E2E4                    	loop	smDigit
  4734                                  	;jmp	short smRet
  4735                                  	; 14/01/2023
  4736                                  smRet:	
  4737 00001311 59                      	pop	cx
  4738 00001312 5B                      	pop	bx
  4739 00001313 C3                      	retn
  4740                                  
  4741                                  ;*	Char substitution.
  4742                                  
  4743                                  smChar:
  4744                                  	;mov	dl,ds:[bx]		; DL = char to output
  4745 00001314 8A17                    	mov	dl,[bx]
  4746 00001316 B402                    	mov	ah,2
  4747 00001318 CD21                    	int	21h
  4748 0000131A EBF5                    	jmp	short smRet
  4749                                  
  4750                                  ;*	String substitution.
  4751                                  
  4752                                  smStr:
  4753                                  	;mov	dl,ds:[bx]		; DL = next char
  4754 0000131C 8A17                    	mov	dl,[bx]
  4755 0000131E 08D2                    	or	dl,dl
  4756 00001320 74EF                    	jz	short smRet		; null char - we're done
  4757 00001322 B402                    	mov	ah,2
  4758 00001324 CD21                    	int	21h			; display char
  4759 00001326 43                      	inc	bx			; DS:BX = ptr to next char
  4760 00001327 EBF3                    	jmp	short smStr
  4761                                  
  4762                                  ;smRet:	pop	cx
  4763                                  ;	pop	bx
  4764                                  ;	retn
  4765                                  
  4766                                  ;SubstMsg	endp
  4767                                  
  4768                                  	; MSDOS 6.0
  4769                                  ; ----------------------------------------------------------------------------
  4770                                  ;***	CharToUpper - convert character to uppercase
  4771                                  ;
  4772                                  ;	ENTRY	AL = char
  4773                                  ;
  4774                                  ;	EXIT	AL = uppercase char
  4775                                  ;
  4776                                  ;	USED	AX
  4777                                  ; ----------------------------------------------------------------------------
  4778                                  
  4779                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4780                                  
  4781                                  ;CharToUpper	proc
  4782                                  ;	assume	ds:DATARES
  4783                                  CharToUpper:
  4784 00001329 50                      	push	ax		; put char on stack as arg to int 2F
  4785 0000132A B81312                  	mov	ax,1213h	; AX = DOS int 2F 'Convert Char to Uppercase'
  4786 0000132D CD2F                    	int	2Fh
  4787 0000132F 44                      	inc	sp		; throw away old char on stack
  4788 00001330 44                      	inc	sp
  4789 00001331 C3                      	retn
  4790                                  
  4791                                  ;CharToUpper	endp
  4792                                  
  4793                                  	; 14/01/2023
  4794                                  ;	; MSDOS 3.3
  4795                                  ;CHARTOUPPER:
  4796                                  ;	cmp	al,80h
  4797                                  ;	jb	short CHARTOUPPER1
  4798                                  ;	sub	al,80h
  4799                                  ;	push	ds
  4800                                  ;	push	bx
  4801                                  ;	lds	bx,[UPPERCASETBL]
  4802                                  ;	add	bx,2
  4803                                  ;	xlat
  4804                                  ;	pop	bx
  4805                                  ;	pop	ds
  4806                                  ;	jmp	short CHARTOUPPER_RETN
  4807                                  ;CHARTOUPPER1:
  4808                                  ;	cmp	al,'a'
  4809                                  ;	jb	short CHARTOUPPER_RETN
  4810                                  ;	cmp	al,'z'
  4811                                  ;	ja	short CHARTOUPPER_RETN
  4812                                  ;	sub	al,20h
  4813                                  ;CHARTOUPPER_RETN:
  4814                                  ;	retn
  4815                                  
  4816                                  ;public	EndCode
  4817                                  ;EndCode label byte
  4818                                  
  4819                                  	; MSDOS 6.0
  4820                                  ; ----------------------------------------------------------------------------
  4821                                  ;***	MsgInt2fHandler - int 2f handler for message retrieval
  4822                                  ;
  4823                                  ;	ENTRY	If we handle it -
  4824                                  ;		  AX = ((MULTDOS shl 8) or MESSAGE_2F) = 122Eh
  4825                                  ;		  DL = operation =
  4826                                  ;		     0 = get extended error messages
  4827                                  ;		     1 = set extended error messages
  4828                                  ;		     2 = get parse error messages
  4829                                  ;		     3 = set parse error messages
  4830                                  ;		     4 = get critical error messages
  4831                                  ;		     5 = set critical error messages
  4832                                  ;		     6 = get file system error messages
  4833                                  ;		     7 = set file system error messages
  4834                                  ;		     8 = get disk retriever routine
  4835                                  ;		     9 = set disk retriever routine
  4836                                  ;		  ES:DI = address for 'set' operations
  4837                                  ;
  4838                                  ;	EXIT	ES:DI = ptr to list of message ptrs, for 'get' operations
  4839                                  ;
  4840                                  ;	NOTE
  4841                                  ;	  This handler replaces the one that used to reside in DOS.
  4842                                  ;	  'Set' operations are ignored.
  4843                                  ;	  'File system error messages' are not supported.
  4844                                  ; ----------------------------------------------------------------------------
  4845                                  
  4846                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4847                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1478h (CODERES:0738h)
  4848                                  ;SR;
  4849                                  ;At the int 2fh entry point we push the old ds value and the resident data
  4850                                  ;segment address. Get them off the stack
  4851                                  
  4852                                  ;MsgInt2fHandler proc	far
  4853                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4854                                  
  4855                                  	; 14/01/2023
  4856                                  MsgInt2fHandler:
  4857 00001332 1F                      	pop	ds			; ds = DATARES
  4858                                  	;assume	ds:DATARES
  4859                                  ;	pop	word [OldDS]		; save old value of ds
  4860                                  
  4861 00001333 3D2E12                  	cmp	ax,122Eh
  4862                                  	;cmp	ax,(MULTDOS<<8)|MESSAGE_2F
  4863                                  	;;cmp	ax,(MULTDOS shl 8) or MESSAGE_2F
  4864 00001336 742A                    	je	short miOurs		; it's ours
  4865                                  
  4866                                  ;ifndef ROMDOS
  4867                                  	;cmp	ax,5500h
  4868 00001338 3D0055                  	cmp	ax,GET_COMMAND_STATE	; is it first COMMAND query?
  4869                                  ;else
  4870                                  ;	cmp	ax,GET_ROMCOMMAND_STATE	; is it first ROM COMMAND query?
  4871                                  ;endif	;ROMDOS
  4872 0000133B 741C                    	je	short fcOurs
  4873                                  
  4874                                  ;SR;
  4875                                  ;We cannot do a far jump any more because cs cannot be used. Push the cs:ip
  4876                                  ;onto the stack and do a far return to jump to the next 2fh handler. 
  4877                                  ;Our old ds is on the stack. We need to restore it but we cannot lose the
  4878                                  ;current value of ds as it points at the data segment. So we do some kinky
  4879                                  ;stack manipulations.
  4880                                  
  4881 0000133D 50                      	push	ax
  4882 0000133E 50                      	push	ax			; create 2 words on stack for retf
  4883                                  
  4884 0000133F 55                      	push	bp
  4885 00001340 50                      	push	ax
  4886                                  
  4887 00001341 89E5                    	mov	bp,sp			; bp can be used to address stack
  4888                                  
  4889                                  ;Swap the old ds value with the second dummy word on the stack. Now, we can
  4890                                  ;do a 'pop ds' at the end to restore our ds
  4891                                  
  4892 00001343 8B4608                  	mov	ax,[bp+8]		; ax = old ds value
  4893 00001346 894604                  	mov	[bp+4],ax
  4894                                  	
  4895                                  	;mov	ax,word ptr ds:Int2fHandler+2
  4896 00001349 A1[B503]                	mov	ax,[Int2fHandler+2]
  4897 0000134C 894608                  	mov	[bp+8],ax		; put segment address
  4898                                  	;mov	ax,word ptr ds:Int2fHandler
  4899 0000134F A1[B303]                	mov	ax,[Int2fHandler]
  4900 00001352 894606                  	mov	[bp+6],ax		; put offset address
  4901                                  
  4902 00001355 58                      	pop	ax
  4903 00001356 5D                      	pop	bp
  4904 00001357 1F                      	pop	ds
  4905                                  
  4906 00001358 CB                      	retf				; chain on to next handler
  4907                                  
  4908                                  ;;	jmp	Int2fHandler		; hand off to next 2f handler
  4909                                  
  4910                                  fcOurs:
  4911                                  
  4912                                  ;We have to clear ax, and return in ds:si a pointer to the stub jump table
  4913                                  
  4914 00001359 58                      	pop	ax			; discard ds currently on stack
  4915 0000135A 1E                      	push	ds			; store our data segment
  4916                                  
  4917                                  	;mov	si,offset DATARES:Int2f_Entry ; start of table
  4918 0000135B BE[0400]                	mov	si,Int2f_Entry
  4919                                  
  4920 0000135E 31C0                    	xor	ax,ax			; indicate COMMAND present
  4921 00001360 EB11                    	jmp	short miRet		; return to caller
  4922                                  
  4923                                  miOurs:
  4924 00001362 F6C201                  	test	dl,1
  4925 00001365 750C                    	jnz	short miRet		; ignore 'set' operations
  4926                                  
  4927 00001367 53                      	push	bx			; preserve BX
  4928 00001368 89D3                    	mov	bx,dx
  4929 0000136A 30FF                    	xor	bh,bh			; BX = index in word table
  4930 0000136C D1E3                    	shl	bx,1			; BX = index in dword table
  4931                                  	;les	di,MsgPtrLists[bx]	; ES:DI = ptr to msg ptr list
  4932 0000136E C4BF[7706]              	les	di,[bx+MsgPtrLists]
  4933 00001372 5B                      	pop	bx			; restore BX
  4934                                  miRet:
  4935                                  ;	mov	ds,[OldDS]		; restore ds
  4936 00001373 1F                      	pop	ds
  4937                                  	;assume	ds:nothing
  4938                                  
  4939 00001374 CF                      	iret
  4940                                  
  4941                                  ;MsgInt2fHandler endp
  4942                                  
  4943                                  	; MSDOS 6.0
  4944                                  ; ----------------------------------------------------------------------------
  4945                                  ;***	MsgRetriever - message retrieval routine for utilities
  4946                                  ;
  4947                                  ;	Address of this routine is passed to utility programs via 
  4948                                  ;	message services int 2f. We try to find the desired message
  4949                                  ;	in memory or in our disk image.
  4950                                  ;
  4951                                  ;	ENTRY	AX = message #
  4952                                  ;		DI = offset in RESGROUP of msg ptr list
  4953                                  ;		ComSpec = asciiz pathname to our disk image
  4954                                  ;
  4955                                  ;	EXIT	CY clear for success
  4956                                  ;		ES:DI = ptr to count byte, followed by message text
  4957                                  ;
  4958                                  ;		CY set for failure
  4959                                  ;		ES,DI undefined
  4960                                  ;
  4961                                  ;	USED	flags
  4962                                  ;
  4963                                  ;	NOTE
  4964                                  ;	  The message # in AX is used to compute an offset into
  4965                                  ;	  the message ptr list pointed to by DI. The lists must
  4966                                  ;	  start with message # 1 and proceed through consecutive
  4967                                  ;	  message #'s.  
  4968                                  ;
  4969                                  ;	  It is assumed that the msg ptr list is either ParsMsgPtrs or
  4970                                  ;	  ExtMsgPtrs. We use NUMPARSEMSGS and NUMEXTMSGS to check for
  4971                                  ;	  valid message #.  ;M033
  4972                                  ;
  4973                                  ;	  List positions with no corresponding message text are
  4974                                  ;	  indicated by null pointers, which this routine detects.
  4975                                  ; ----------------------------------------------------------------------------
  4976                                  
  4977                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  4978                                  
  4979                                  ;SR; This routine will be called directly by the utilities. So, we have
  4980                                  ; trap for it in the stub. The stub pushes the old value of ds and the 
  4981                                  ; DATARES value on the stack. We get them off the stack to setup ds here
  4982                                  
  4983                                  ;MsgRetriever	proc	far
  4984                                  ;	assume	cs:CODERES,ds:NOTHING,es:NOTHING,ss:NOTHING
  4985                                  
  4986                                  	; 14/01/2023
  4987                                  MsgRetriever:
  4988 00001375 1F                      	pop	ds			; ds = DATARES
  4989                                  	;assume	ds:DATARES
  4990                                  ;	pop	word [OldDS]		; save old ds
  4991                                  
  4992 00001376 50                      	push	ax			; preserve registers
  4993 00001377 53                      	push	bx
  4994 00001378 51                      	push	cx
  4995 00001379 52                      	push	dx
  4996 0000137A 56                      	push	si
  4997                                  
  4998                                  ;;	push	ds
  4999                                  ;;	push	cs
  5000                                  ;;	pop	ds			; DS = DATARES seg addr
  5001                                  ;;	assume	ds:RESGROUP
  5002                                  ;;	push	cs
  5003                                  
  5004 0000137B 1E                      	push	ds			; get es from ds
  5005 0000137C 07                      	pop	es			; ES = DATARES seg addr
  5006                                  
  5007                                  ;	Begin modification M033.
  5008                                  
  5009                                  ;	Make sure msg # is valid.
  5010                                  ;	Assume msg ptr list is either ParsMsgPtrs or ExtMsgPtrs.
  5011                                  
  5012                                  	;mov	bx,11
  5013 0000137D BB0B00                  	mov	bx,NUMPARSMSGS		; BX = # parse error msgs in list
  5014                                  	;cmp	di,offset DATARES:ParsMsgPtrs
  5015 00001380 81FF[1609]              	cmp	di,PARSMSGPTRS
  5016 00001384 7403                    	je	short chkmsgnum		; it's ParsMsgPtrs
  5017                                  	;mov	bx,90
  5018 00001386 BB5A00                  	mov	bx,NUMEXTMSGS		; BX = # extended error msgs in list
  5019                                  chkmsgnum:
  5020 00001389 39C3                    	cmp	bx,ax
  5021 0000138B 725A                    	jc	short mrRet		; msg # too high, return carry
  5022                                  
  5023                                  ;	Msg # is valid.
  5024                                  
  5025                                  ;	End modification M033.
  5026                                  
  5027 0000138D 48                      	dec	ax
  5028 0000138E D1E0                    	shl	ax,1			; AX = offset into msg ptr list
  5029 00001390 01C7                    	add	di,ax			; DI = ptr to msg ptr
  5030                                  
  5031 00001392 81FF[B703]              	cmp	di,ResMsgEnd
  5032 00001396 7247                    	jb	short mrInMem		; ptr (and message) in memory
  5033                                  
  5034                                  ;*	Retrieve message from disk (or ROM) image.
  5035                                  ;	Read once to get the ptr to the message, then again for the message.
  5036                                  
  5037                                  ;ifndef	ROMDOS
  5038                                  	; 14/01/2023
  5039                                  	;mov	si,offset DATARES:ComSpec	; DS:SI = ptr to pathname
  5040 00001398 BE[4E01]                	mov	si,ComSpec
  5041 0000139B BA0100                  	mov	dx,1 ; EXT_EXISTS_OPEN		; DX = 'open existing file'
  5042 0000139E BB0020                  	mov	bx,2000h ; INT_24_ERROR		; BX = 'fail on crit error'
  5043 000013A1 B8006C                  	mov	ax,6C00h
  5044                                  	;mov	ax,ExtOpen shl 8		; AX = 'Extended Open File'
  5045 000013A4 CD21                    	int	21h				; call DOS
  5046 000013A6 723F                    	jc	short mrRet			; return failure
  5047                                  
  5048 000013A8 89C3                    	mov	bx,ax				; BX = file handle
  5049 000013AA 89FA                    	mov	dx,di				; DX = ptr to msg ptr
  5050 000013AC 31F6                    	xor	si,si				; SI = read count
  5051                                  mrRead:
  5052 000013AE 81EA0001                	sub	dx,100h				; DX = LSW of file offset
  5053 000013B2 31C9                    	xor	cx,cx				; CX = MSW of file offset
  5054 000013B4 B80042                  	mov	ax,4200h
  5055                                  	;mov	ax,LSEEK shl 8			; AX = 'Set File Pointer'
  5056 000013B7 CD21                    	int	21h				; call DOS
  5057 000013B9 721A                    	jc	short mrCloseFile		; handle error
  5058                                  
  5059                                  	;mov	dx,offset DATARES:MsgBuffer	; DS:DX = input buffer
  5060 000013BB BA[6303]                	mov	dx,MsgBuffer
  5061 000013BE B94000                  	mov	cx,64				; CX = # bytes to read
  5062 000013C1 B43F                    	mov	ah,3Fh
  5063                                  	;mov	ah,READ				; AH = 'Read File'
  5064 000013C3 CD21                    	int	21h				; call DOS
  5065 000013C5 720E                    	jc	short mrCloseFile		; handle error
  5066                                  
  5067 000013C7 09F6                    	or	si,si				; (CY cleared)
  5068 000013C9 750A                    	jnz	short mrCloseFile		; 2nd time thru - we're done
  5069 000013CB 46                      	inc	si				; mark one read done
  5070 000013CC 8B16[6303]              	mov	dx,[MsgBuffer]			; DX = ptr to message
  5071 000013D0 09D2                    	or	dx,dx
  5072 000013D2 75DA                    	jnz	short mrRead			; go read the message
  5073 000013D4 F9                      	stc					; null ptr found- no msg
  5074                                  
  5075                                  mrCloseFile:
  5076 000013D5 9C                      	pushf				; save success/failure (CY)
  5077 000013D6 B43E                    	mov	ah,3Eh
  5078                                  	;mov	ah,CLOSE		; AH = 'Close File'
  5079 000013D8 CD21                    	int	21h			; call DOS
  5080                                  ;	Bugbug: should we avoid this popf?
  5081 000013DA 9D                      	popf				; CY = success/failure
  5082 000013DB 89D7                    	mov	di,dx			; ES:DI = ptr to msg, if successful
  5083 000013DD EB08                    	jmp	short mrRet		; we're done
  5084                                  
  5085                                  ;else	;ROMDOS
  5086                                  ;
  5087                                  ;;	DI = ptr to msg ptr
  5088                                  ;
  5089                                  ;	mov	si,di			; SI = ptr to msg ptr
  5090                                  ;	sub	si,100h			; SI = offset into image of msg ptr
  5091                                  ;	mov	cx,2			; CX = # bytes to copy from image
  5092                                  ;
  5093                                  ;;	ASSUME ES:NOTHING is still in effect.
  5094                                  ;
  5095                                  ;	push	ds
  5096                                  ;	pop	es				; ES = DATARES seg addr
  5097                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to buffer
  5098                                  ;	invoke	LoadFromROM			; copy msg ptr from ROM
  5099                                  ;	mov	si,word ptr MsgBuffer		; SI = ptr to message
  5100                                  ;	or	si,si
  5101                                  ;	jz	mrNoMsg			; null ptr- no message text
  5102                                  ;
  5103                                  ;	sub	si,100h			; SI = offset into image of msg
  5104                                  ;	mov	cx,64			; CX = # bytes to copy from image
  5105                                  ;	mov	di,offset DATARES:MsgBuffer
  5106                                  ;	invoke	LoadFromROM
  5107                                  ;	clc					; success
  5108                                  ;	mov	di,offset DATARES:MsgBuffer	; ES:DI = ptr to msg
  5109                                  ;	jmp	short mrRet
  5110                                  ;
  5111                                  ;mrNoMsg:
  5112                                  ;	stc
  5113                                  ;	jmp	short mrRet
  5114                                  ;
  5115                                  ;;;	mov	ax,COMMAND_SEG-10h	; AX = seg addr of COMMAND image
  5116                                  ;;;	mov	es,ax			; ES:DI = ptr to msg ptr in image
  5117                                  ;	assume	es:NOTHING
  5118                                  ;
  5119                                  ;endif	;ROMDOS
  5120                                  
  5121                                  ;*	Message ptr is in memory.
  5122                                  ;	If ptr is in memory, assume message is in memory (/msg).
  5123                                  
  5124                                  mrInMem:
  5125                                  	; 14/01/2023
  5126 000013DF 268B3D                  	mov	di,[es:di]		; ES:DI = ptr to msg
  5127 000013E2 09FF                    	or	di,di			; (CY cleared)
  5128 000013E4 7501                    	jnz	short mrRet		; found message
  5129 000013E6 F9                      	stc				; null ptr found - no message
  5130                                  mrRet:	
  5131 000013E7 5E                      	pop	si			; restore all registers
  5132 000013E8 5A                      	pop	dx
  5133 000013E9 59                      	pop	cx
  5134 000013EA 5B                      	pop	bx
  5135 000013EB 58                      	pop	ax
  5136                                  
  5137                                  ;	mov	ds,[OldDS]		; restore ds
  5138 000013EC 1F                      	pop	ds
  5139                                  	;assume	ds:nothing
  5140                                  
  5141 000013ED CB                      	retf	; 21/04/2023
  5142                                  
  5143                                  ;MsgRetriever endp
  5144                                  
  5145                                  ; M003; Start of changes for UMB support
  5146                                  
  5147                                  ; ----------------------------------------------------------------------------
  5148                                  ;***	Lh_OffUnlink -- Restore allocation strat and link state
  5149                                  ;
  5150                                  ;	ENTRY	al = Saved alloc strat and link state
  5151                                  ;			b0 = 1 if alloc strat to restore is HighFirst
  5152                                  ;			b1 = 1 if link state to restore is Linked
  5153                                  ;
  5154                                  ;	EXIT	None
  5155                                  ;
  5156                                  ;	USED	ax, bx, cx
  5157                                  ; ----------------------------------------------------------------------------
  5158                                  
  5159                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5160                                  
  5161                                  ;public	Lh_OffUnlink
  5162                                  Lh_OffUnlink:	; proc	far
  5163                                  	; 14/01/2023
  5164 000013EE 88C5                    	mov	ch,al
  5165 000013F0 88C1                    	mov	cl,al
  5166                                  	;;mov	ax,(ALLOCOPER shl 8) OR 0
  5167                                  	;mov	ax,(ALLOCOPER<<8)
  5168 000013F2 B80058                  	mov	ax,5800h
  5169 000013F5 CD21                    	int	21h
  5170 000013F7 89C3                    	mov	bx,ax
  5171 000013F9 D0C9                    	ror	cl,1				; b7 = HighFirst bit
  5172 000013FB 80E180                  	and	cl,80h				; mask off b6-b0
  5173 000013FE 80E37F                  	and	bl,7fh				; mask off HighFirst bit
  5174 00001401 08CB                    	or	bl,cl				; set HighFirst bit state
  5175                                  	;;mov	ax,(ALLOCOPER shl 8) OR 1
  5176                                  	;mov	ax,(ALLOCOPER<<8)|1
  5177 00001403 B80158                  	mov	ax,5801h
  5178 00001406 CD21                    	int	21h				; set alloc strat
  5179                                  
  5180 00001408 88EB                    	mov	bl,ch
  5181 0000140A D0EB                    	shr	bl,1
  5182 0000140C 30FF                    	xor	bh,bh				; bx = linkstate
  5183                                  	;mov	ax,(ALLOCOPER shl 8) OR 3
  5184                                  	;mov	ax,(ALLOCOPER<<8)|3
  5185 0000140E B80358                  	mov	ax,5803h
  5186 00001411 CD21                    	int	21h				; set linkstate
  5187                                  
  5188 00001413 CB                      	retf
  5189                                  
  5190                                  ;Lh_OffUnlink endp
  5191                                  
  5192                                  ; M003; End of changes for UMB support
  5193                                  
  5194                                  ;public	EndCode
  5195                                  ; 14/01/2023
  5196                                  ;EndCode: ; label byte
  5197                                  ; 06/06/2023
  5198                                  ; 16/04/2023
  5199                                  EndCode equ ($-StartCode)+100h
  5200                                  ; 06/06/2023
  5201                                  ;EndCode equ $-StartCode	
  5202                                  
  5203                                  ;CODERES ends
  5204                                  ;	end
  5205                                  
  5206                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5207                                  
  5208 00001414 00<rep Ch>              	times	(((EndCode+15)>>4)<<4)-EndCode db 0
  5209                                  
  5210                                  ;align 16
  5211                                  
  5212                                  ;=============================================================================
  5213                                  ; INIT.ASM, MSDOS 6.0 (COMMAND.COM), 1991
  5214                                  ;=============================================================================
  5215                                  ; 22/09/2018 - Retro DOS v3.0 ('command3.s')
  5216                                  
  5217                                  ; INIT.ASM (MSDOS 2.11 COMMAND.COM, Retro DOS v2.0, 30/04/2018)
  5218                                  
  5219                                  ;TITLE   COMMAND Initialization
  5220                                  
  5221                                  ;ENVIRONSIZ EQU  0A0H		; Must agree with values in ENVIRONMENT segment
  5222                                  ;ENVIRONSIZ2 EQU 092H
  5223                                  ;MAX_COMSPEC EQU ENVIRONSIZ2 ; = 146  ; 22/09/2018
  5224                                  
  5225                                  ; UINIT.ASM, MSDOS 6.0, 1991
  5226                                  ; 23/09/2018
  5227                                  ENVBIG	EQU 32768		;AN000; maximum environment size
  5228                                  ; 14/01/2023
  5229                                  ;ENVSML	EQU 160			;AN000; minimum environment size
  5230                                  
  5231                                  ; ----------------------------------------------------------------------------
  5232                                  
  5233                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5234                                  
  5235                                  ; (MSDOS 5.0 COMMAND.COM -initial- Environment Structure size)
  5236                                  ENVIRONSIZ equ 160
  5237                                  ENVSML	equ 256	; minimum environment size
  5238                                  ;MAX_COMSPEC equ ENVIRONSIZ - Env_ComSpec
  5239                                  MAX_COMSPEC equ 146
  5240                                  ECOMSPEC equ 14
  5241                                  
  5242                                  ; 14/01/2023
  5243                                  TAB_CHAR equ 09h
  5244                                  SPACE_CHAR equ 20h	
  5245                                  
  5246                                  ; (MSDOS 6.22 COMMAND.COM -initial- Environment Structure size)
  5247                                  ;ENVIRONSIZ equ 180	; SIZE Environment 
  5248                                  
  5249                                  ;----------------------------------------------------
  5250                                  ; MSDOS 6.0 - ENVDATA.ASM - 1991
  5251                                  ;----------------------------------------------------
  5252                                  ;Environment Struc	; Default COMMAND environment
  5253                                  ;
  5254                                  ;Env_PathString  db	"path="
  5255                                  ;Env_PathSpec	 db	"c:\msdos"
  5256                                  ;                db	0
  5257                                  ;Env_PrmptString db	"prompt="
  5258                                  ;Env_PrmptSpec   db	"$p$g"
  5259                                  ;                db	0
  5260                                  ;Env_ComString   db	"comspec="
  5261                                  ;Env_ComSpec     db	"\command.com"
  5262                                  ;		 db	134 dup (0)
  5263                                  ;
  5264                                  ;Environment ends
  5265                                  ;----------------------------------------------------
  5266                                  
  5267                                  ;-----------------------------------------------------------------------------
  5268                                  
  5269                                  ;-----------------------------------------------------------------------------
  5270                                  ; START OF INIT PORTION
  5271                                  ; This code is deallocated after initialization.
  5272                                  ;-----------------------------------------------------------------------------
  5273                                  
  5274                                  ;INIT	SEGMENT PUBLIC PARA
  5275                                  
  5276                                  ; 	EXTRN   HEADER:BYTE
  5277                                  ;	EXTRN   BADCOMLKMES:BYTE
  5278                                  
  5279                                  ;	PUBLIC  CONPROC
  5280                                  
  5281                                  ;ASSUME  CS:RESGROUP,DS:RESGROUP,ES:RESGROUP,SS:RESGROUP
  5282                                  
  5283                                          ;ORG 0
  5284                                  ;ZERO = $
  5285                                  	; 23/09/2018
  5286                                  ZERO equ $	; Offset 0E30h for original MSDOS 3.3 COMMAND.COM
  5287                                  
  5288                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5289                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1560h (CODERES:0820h)
  5290                                  ConProc:
  5291                                  	;mov	sp,offset ResGroup:RStack	; must be first instruction
  5292 00001420 BC[3804]                	mov	sp,RStack
  5293                                  
  5294                                  ; We need to set the PSP to us right at start because Carousel needs
  5295                                  ; to be lied to and it does not set PSP when it transfers control to
  5296                                  ; us after loading us as an overlay. By setting PSP, we ensure that
  5297                                  ; command.com is also not lied to.
  5298                                  
  5299                                  	; 14/01/2023
  5300                                  	; MSDOS 6.0
  5301 00001423 B450                            mov	ah,50h
  5302                                  	;mov	ah,SET_CURRENT_PDB
  5303 00001425 8CC3                            mov	bx,es
  5304 00001427 CD21                            int	21h
  5305                                  
  5306                                  	; 14/01/2023
  5307 00001429 B430                    	mov	ah,30h 
  5308                                  	;mov	ax,GET_VERSION<<8 ; 30h
  5309                                  	; 06/06/2023 - MSDOS 6.22 COMMAND.COM
  5310                                  	;mov	ax,3000h
  5311 0000142B CD21                    	int	21h
  5312                                  	;;cmp	ax,EXPECTED_VERSION ; 1E03h
  5313                                  	;cmp	ax,5
  5314 0000142D 83F805                  	cmp	ax,EXPECTED_VERSION ; 0005h
  5315 00001430 7411                    	je	short okdos			; DOS version is ok
  5316                                  
  5317 00001432 BA[421D]                	mov	dx,BADVERMSG			; DX = ptr to msg
  5318 00001435 E858FE                  	call	RPrint
  5319                                  
  5320                                  	; MSDOS 3.3
  5321                                  	;mov	ah,STD_CON_STRING_OUTPUT ; 9
  5322                                  	;int	21h             ; DOS - PRINT STRING
  5323                                  				; DS:DX -> string terminated by "$"
  5324 00001438 8CC0                    	mov	ax,es
  5325 0000143A 2639061600              	cmp	[es:PDB.PARENT_PID],ax
  5326                                  	;cmp	[es:16h],ax			; if COMMAND is own parent,
  5327                                  Here:	
  5328 0000143F 74FE                    	jz	short Here			;  loop forever
  5329                                  	
  5330 00001441 CD20                    	int	20h				; otherwise, exit
  5331                                  okdos:
  5332                                  	; 23/09/2018
  5333                                  
  5334                                  ;  Calculate and save the end of the INIT segment (which is also
  5335                                  ;  the beginning of TRANGROUP).
  5336                                  
  5337                                  	; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  5338                                  	; MSDOS 3.3
  5339                                  	;mov	ah,65h
  5340                                  	;mov	al,2
  5341                                  	;mov	dx,-1
  5342                                  	;mov	bx,-1
  5343                                  	;mov	cx,5
  5344                                  	;mov	di,UCASE_ADDR
  5345                                  	;int	21h	; AH = 65h : GET EXTENDED COUNTRY INFORMATION (DOS 3.3+)
  5346                                  	;		; AL = 02h : Get pointer to character translation table
  5347                                  	;		; BX = code page (-1 = current global code page)
  5348                                  	;		; DX = country ID (-1 = current country)
  5349                                  	;		; CX = amount of data to return
  5350                                  	;; ES:DI = pointer to output buffer
  5351                                  	;; Buffer offset :
  5352                                  	;;	00h -  byte,  country Id
  5353                                  	;;  	01h -  dword, pointer to uppercase table	
  5354                                  
  5355                                  	; 14/01/2023
  5356                                  	; MSDOS 6.0 (& MSDOS 3.3)
  5357                                    	;mov	dx,232Fh     ; MSDOS 5.0 COMMAND.COM
  5358 00001443 BA2F22                  	mov	dx,TRANSTART+15			; get end of init code
  5359                                  	; 27/09/2018
  5360                                  	;mov	dx,TRANSTART ; (paragraph aligned address)
  5361 00001446 B104                    	mov	cl,4				; change to paragraphs
  5362 00001448 D3EA                            shr	dx,cl				;
  5363 0000144A 8CC8                            mov     ax,cs                           ; get current segment
  5364 0000144C 01D0                            add     ax,dx                           ; calculate segment of end of init
  5365 0000144E A3[A51C]                        mov     [initend],ax			; save this
  5366                                  
  5367                                  	; 14/01/2023
  5368                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1591h 
  5369                                  
  5370                                  ;  Check for /? on the command line. If found, display help text and exit.
  5371                                  ;  NOTE: this routine may terminate the program, never returning.
  5372                                  
  5373 00001451 E87106                  	call	CheckHelp
  5374                                  
  5375                                  ; We have to patch the segment values for the various interrupt entry points.
  5376                                  ; This is because we need to have the default addresses of the handlers in our
  5377                                  ; stub before the relocation is done. These values will then be changed once
  5378                                  ; the resident is relocated
  5379                                  
  5380 00001454 E8AE07                  	call	patch_segs
  5381                                  
  5382                                  ;  Turn APPEND off during initialization processing
  5383                                  
  5384                                  	; 14/01/2023
  5385 00001457 B800B7                  	mov     ax,0B700h
  5386                                  	;mov	ax,APPENDINSTALL                ; see if append installed
  5387 0000145A CD2F                    	int	2Fh				;
  5388                                  	;cmp	al,0				; append installed?
  5389 0000145C 08C0                    	or	al,al
  5390 0000145E 7418                    	jz	short set_msg_addr		; no - continue
  5391                                  	
  5392 00001460 B802B7                  	mov	ax,0B702h
  5393                                  	;mov	ax,APPENDDOS			; see if append DOS version right
  5394 00001463 CD2F                    	int	2Fh				;
  5395                                  	;cmp	ax,-1				; append version correct?
  5396                                  	;jne	short set_msg_addr		; no - continue
  5397 00001465 40                      	inc	ax ; -1 -> 0
  5398 00001466 7510                    	jnz	short set_msg_addr        
  5399                                  	
  5400 00001468 B806B7                  	mov     ax,0B706h
  5401                                  	;mov	ax,APPENDGETSTATE               ; Get the state of Append
  5402 0000146B CD2F                    	int	2Fh				;
  5403 0000146D 891E[C301]                      mov     [Append_State],bx		; save append state
  5404                                         
  5405 00001471 31DB                    	xor	bx,bx                           ; clear out state
  5406 00001473 B807B7                  	mov	ax,0B707h
  5407                                  	;mov	ax,APPENDSETSTATE               ; Set the state of Append
  5408 00001476 CD2F                    	int	2Fh				; set everything off
  5409                                  
  5410                                  set_msg_addr:
  5411                                  	; 14/01/2023
  5412                                  	;;mov	di,offset resgroup:DataresEnd 	; get address of resident end
  5413                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:15BAh) 
  5414                                  	;mov	di,093Eh  ; mov di,PAERRMSG0 ; MSDOS 5.0 COMMAND.COM
  5415 00001478 BF[3808]                	mov	di,DataresEnd
  5416 0000147B 893E[B703]              	mov	[ResMsgEnd],di			; save it
  5417                                  
  5418 0000147F E89507                          call    get_XMMAddr                     ; get XMM call address
  5419                                  
  5420                                  ; Check if this is the first instance of command.com. If not, we just exit
  5421                                  ; this routine without moving any code.
  5422                                  ; After the int 2fh, ds:si points at the resident jump table in the previous
  5423                                  ; stub. We just have to copy this over
  5424                                  	
  5425                                  ;ifndef ROMDOS
  5426 00001482 B80055                  	mov	ax,5500h
  5427                                  	;mov	ax,GET_COMMAND_STATE	
  5428                                  ;else
  5429                                  ;	mov	ax,GET_ROMCOMMAND_STATE	
  5430                                  ;endif ; ROMDOS
  5431                                  
  5432 00001485 CD2F                    	int	2Fh	;  (Int 2Fh/AX=5500h - DOS 5+ - COMMAND.COM INTERFACE)
  5433                                  	;assume	ds:nothing
  5434                                  
  5435                                  	; 03/05/2023
  5436                                  	; Return:
  5437                                  	;   AX = 0000h if an instance of COMMAND.COM is already running
  5438                                  	;   DS:SI -> entry point table
  5439                                  
  5440                                  	; (si = offset Int2f_Entry)  ; (('MsgInt2fHandler:', 'fcOurs:'))
  5441                                  
  5442 00001487 09C0                    	or	ax,ax
  5443 00001489 750C                    	jnz	short first_com			; this is the first instance
  5444                                  
  5445                                  	; 14/01/2023
  5446 0000148B 268936[E620]            	mov	[es:ResJmpTable],si		; save old stub jump table
  5447 00001490 268C1E[E820]            	mov	[es:ResJmpTable+2],ds
  5448 00001495 EB06                    	jmp	short init_cntry
  5449                                  
  5450                                  first_com:
  5451 00001497 26C606[EA20]01          	mov	byte [es:FirstCom],1		; indicate first command.com
  5452                                  
  5453                                  init_cntry:
  5454                                  	; 14/01/2023
  5455 0000149D 06                      	push	es
  5456 0000149E 1F                      	pop	ds
  5457                                  	;assume	ds:RESGROUP
  5458                                  
  5459 0000149F B465                    	mov	ah,65h
  5460                                  	;mov	ah,GETEXTCNTRY			; get extended country info
  5461 000014A1 B004                    	mov	al,4				; get file ucase table
  5462 000014A3 BAFFFF                  	mov	dx,-1				;
  5463                                  	;mov	bx,-1				;
  5464 000014A6 89D3                    	mov	bx,dx
  5465 000014A8 B90500                  	mov	cx,5				; number of bytes we want
  5466                                  	;mov	di,offset resgroup:FUCase_Addr	; buffer for address
  5467 000014AB BF[B601]                	mov	di,FUCase_Addr
  5468 000014AE CD21                    	int	21h
  5469                                  		; DOS - 4.x internal - COUNTRY-DEPENDENT FILENAME CAPITALIZATION
  5470                                  		; AL = function -
  5471                                  
  5472                                  ;	Bugbug:	conditionalize dbcs_vector stuff?
  5473                                  
  5474 000014B0 1E                      	push	ds				;
  5475 000014B1 B80063                  	mov	ax,6300h
  5476                                  	;mov	ax,(ECS_CALL shl 8) or GETLEADBTBL ;
  5477 000014B4 CD21                    	int	21h				;
  5478                                  		; DOS - 3.2+ only - GET DOUBLE BYTE CHARACTER SET LEAD TABLE
  5479                                  			
  5480 000014B6 8CDB                    	mov	bx,ds				; get segment to bx
  5481 000014B8 1F                      	pop	ds				;
  5482 000014B9 8936[BF01]              	mov	[Dbcs_Vector_Addr],si		; save address of
  5483 000014BD 891E[C101]              	mov	[Dbcs_Vector_Addr+2],bx		; dbcs vector
  5484                                  
  5485                                  	;mov	ax,[16h]
  5486 000014C1 A11600                  	mov	ax,[PDB.PARENT_PID]
  5487                                  				; mov ax,ds:16h	; Init PARENT so we can exit
  5488 000014C4 A3[4101]                	mov	[Parent],ax			;  correctly.
  5489 000014C7 A10A00                  	mov	ax,[PDB.EXIT]   ; mov ax,ds:0Ah
  5490 000014CA A3[4301]                	mov	[OldTerm],ax
  5491 000014CD A10C00                  	mov	ax,[PDB.EXIT+2] ; mov ax,ds:0Ch
  5492 000014D0 A3[4501]                	mov	[OldTerm+2],ax
  5493                                  
  5494                                  	; 14/01/2023
  5495                                  	;;;mov	ax,offset ResGroup:EndCode + 15
  5496                                  	;;mov	ax,1569h	; MSDOS 5.0 COMMAND.COM
  5497                                  	;mov	ax,EndCode+15
  5498                                  	;;mov	ax,INITSTART+15 ; 24/09/2018
  5499                                  	; 14/01/2023
  5500                                  	;mov	cl,4				; ax = size of resident part of
  5501                                  	;shr	ax,cl				;  command in paragraphs. Add
  5502                                  	;mov	cx,cs				;  this to CS and you get the
  5503                                  	;add	ax,cx				;  segment of the TPA.
  5504                                  
  5505 000014D3 8CC8                    	mov	ax,cs
  5506 000014D5 055201                  	add	ax,(EndCode+15)>>4
  5507                                  	
  5508 000014D8 A3[5F03]                	mov     [Res_Tpa],ax			; Temporarily save the TPA segment
  5509 000014DB 2500F0                  	and     ax,0F000h
  5510 000014DE 050010                  	add     ax,1000h			; Round up to next 64K boundary
  5511 000014E1 7303                    	jnc     short TpaSet			; Memory wrap if carry set
  5512 000014E3 A1[5F03]                	mov     ax,[Res_Tpa]
  5513                                  TpaSet:
  5514 000014E6 A3[5103]                	mov	[LTpa],ax			; Good enough for the moment
  5515                                  	;mov	ax,[2]
  5516 000014E9 A10200                  	mov	ax,[PDB.BLOCK_LEN]		; ax = # of paras given to command
  5517                                  
  5518 000014EC 8C1E[5703]              	mov	[MySeg1],ds			; These 3 variables are used as part of
  5519 000014F0 8C1E[5B03]              	mov	[MySeg2],ds			;  3 long ptrs that the transient will
  5520 000014F4 8C1E[4F03]              	mov	[MySeg],ds			;  use to call resident routines.
  5521                                  	; 19/04/2023
  5522                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1641h
  5523 000014F8 8C1E[8906]              	mov	[MySeg3],ds			; segment of msg retriever routine 
  5524                                  
  5525 000014FC A3[9801]                	mov	[MemSiz],ax			; Needed for execing other programs
  5526                                  
  5527                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5528                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1648h
  5529                                  
  5530                                  ; First reallocate the COMMAND size to its memory image
  5531                                  	
  5532 000014FF 50                      	push	ax    
  5533                                    	;;;mov	bx,2320h  ; MSDOS 5.0 COMMAND.COM
  5534                                  	;;mov	bx,offset RESGROUP:TranStart    ;
  5535                                  	;mov	bx,TRANSTART
  5536                                  	;;add	bx,98C5h  ; MSDOS 5.0 COMMAND.COM
  5537                                          ;add	bx,offset TRANGROUP:TranSpaceEnd;
  5538                                  	;add	bx,15 ; *			; round up the size
  5539                                  
  5540                                  	; 03/05/2023
  5541                                  	;;mov	bx,TRANSTART+15 ; * ; 14/01/2023
  5542                                  	;;add	bx,TRANSPACEEND
  5543                                  	; 06/06/2023
  5544                                  	;mov	bx,TRANSTART+TRANSPACEEND+15 
  5545                                          ;mov	cl,4				;
  5546                                          ;shr	bx,cl				; size of command.com
  5547 00001500 BB810B                  	mov	bx,(TRANSTART+TRANSPACEEND+15)>>4
  5548                                  	
  5549 00001503 B44A                    	mov	ah,4Ah
  5550                                  	;mov	ah,SETBLOCK			; free all memory above pgm
  5551 00001505 CD21                            int     21h				;
  5552 00001507 58                              pop     ax				;
  5553                                  	
  5554                                  ; Compute maximum size of environment
  5555                                  
  5556                                  	;;mov	word [ENVMAX],69 ; = (160/16)+(973/16)-1 ; (11EEh-0E30h+0Fh/10h) = 3Ch
  5557                                          ;mov	word [ENVMAX],((ENVIRONSIZ+15)/16) + ((ENVMAXIMUM-ZERO+15)/16) - 1
  5558                                  	; 14/01/2023 - Retro DOS v4.0 COMMAND.COM
  5559                                  	;mov	word [EnvMax],81	; 10+72-1  ; MSDOS 5.0 COMMAND.COM
  5560                                  	;mov	word [EndMax],90	; 12+79-1  ; MSDOS 6.22 COMMAND.COM	
  5561 00001508 C706[991C]4C00          	mov	word [EnvMax],((ENVIRONSIZ+15)/16) + ((EnvMaximum-ZERO+15)/16) - 1
  5562                                  ;
  5563                                  ; Compute minimum size of environment
  5564                                  ;
  5565                                  	;;mov	word [EnvSiz],10 ; = 160/16	; MSDOS 3.3 COMMAND.COM
  5566                                  	;mov	word [EnvSiz],16 ; = 256/16	; MSDOS 5.0 COMMAND.COM
  5567 0000150E C706[971C]1000          	mov	word [EnvSiz],ENVSML/16 ; 256/16
  5568                                  
  5569                                  	;;mov	dx,offset TranGroup:Transpaceend + 15 ; dx = size of transient
  5570                                  	;mov	dx,98D4h	 ; MSDOS 5.0 COMMAND.COM
  5571                                  	; 06/06/2023
  5572                                  	;mov	dx,TRANSPACEEND+15 ; 4D5Ch+0Fh (for MSDOS 3.3 COMMAND.COM)
  5573                                  	;mov	cl,4				;  in paragraphs.
  5574                                  	;shr	dx,cl
  5575 00001514 BA5F09                  	mov	dx,(TRANSPACEEND+15)>>4
  5576 00001517 8916[A71C]                      mov     [TrnSize],dx			; save size of transient in paragraphs
  5577                                  
  5578 0000151B 29D0                    	sub	ax,dx				; max seg addr - # para's needed for transient
  5579 0000151D A3[9201]                	mov	[TrnSeg],ax			;  = seg addr to load the transient at.
  5580                                  	;mov	ax,[2Ch]
  5581 00001520 A12C00                  	mov	ax,[PDB.ENVIRON]		; ax = environment segment
  5582                                  
  5583                                  	; 14/01/2023
  5584                                          ; MSDOS 6.0
  5585                                  	;mov	[EnvirSeg],ax
  5586                                          
  5587                                  	; 21/01/2023
  5588 00001523 09C0                    	or	ax,ax				; if there is no environment segment,
  5589 00001525 7406                    	jz	short buildenv			; make one
  5590                                    
  5591                                  	; 21/01/2023
  5592                                  	; MSDOS 3.3 & MSDOS 5.0
  5593                                  	;inc	byte [CHUCKENV]
  5594 00001527 FE06[7B1C]              	inc	byte [AllocedEnv]		; Flag - old environment segment
  5595                                  	
  5596                                  	; MSDOS 3.3 & MSDOS 5.0
  5597 0000152B EB03                    	jmp	short environpassed
  5598                                  	; MSDOS 6.0
  5599                                          ;cmp	byte [FirstCom],0		; if this is the first command.com,
  5600                                  	;je	short environpassed		; do a merge job (make sure COMSPEC exists)
  5601                                  
  5602                                  	; MSDOS 6.0
  5603                                  
  5604                                  ; We allocate a buffer here just large enough to hold the 'PATH=' and
  5605                                  ; the COMSPEC. After parsing, we will allocate an environment of the right
  5606                                  ; size and free this buffer. We need this buffer because we no longer have an
  5607                                  ; ENVIRONMENT segment but need a place to store the COMSPEC which can be
  5608                                  ; given on the command line before we know the environment size. This routine
  5609                                  ; will not return in case of an allocation error. It will either exit or hang
  5610                                  ; depending on whether or not this is the first COMMAND.COM or not.
  5611                                  
  5612                                  	; 14/01/2023
  5613                                  buildenv:
  5614 0000152D E87B06                  	call	alloc_env                       ; try to allocate buffer
  5615                                  environpassed:
  5616                                  	; 14/01/2023 - MSDOS 5.0 COMMAND.COM
  5617 00001530 A3[3F03]                	mov	[EnvirSeg],ax
  5618                                  	;
  5619 00001533 8EC0                    	mov	es,ax                           ; and it load into es.
  5620                                  	;assume	es:nothing
  5621                                  
  5622                                  gottheenvir:
  5623                                  
  5624                                  ; Initialize the command drive
  5625                                  
  5626                                  ; 14/01/2023
  5627                                  %if 0
  5628                                  	; MSDOS 3.3
  5629                                  BUILDENV:
  5630                                          ;mov	ax,offset RESGROUP:PATHSTRING	; Figure environment pointer
  5631                                  	mov	ax,PATHSTRING ; "PATH="
  5632                                  	mov	cl,4
  5633                                  	shr	ax,cl
  5634                                  	mov	dx,ds
  5635                                  	add	ax,dx
  5636                                  ENVIRONPASSED:
  5637                                          mov	[ENVIRSEG],ax
  5638                                          MOV     es,ax
  5639                                  
  5640                                          ;mov	ax,CHAR_OPER<<8
  5641                                          mov	ax,CHAR_OPER*256 ; 3700h
  5642                                  	int     21h	; DOS - 2+ internal - GET SWITCHAR/AVAILDEV
  5643                                  			; Return: AL = FFh unsupported subfunction
  5644                                  			; DL = current switch character
  5645                                          mov	[RSWITCHAR],dl
  5646                                  
  5647                                          ;CMP	dl,'/'
  5648                                  	cmp	dl,[slash_chr]
  5649                                          jnz	short IUSESLASH
  5650                                  
  5651                                  	;mov	al,'\'
  5652                                   	mov	al,[bslash_chr]
  5653                                  	mov	[COMSPECT],al
  5654                                  
  5655                                  	cmp	byte [CHUCKENV],0
  5656                                  	jnz	short IUSESLASH
  5657                                  
  5658                                          ;mov	ES:[ECOMSPEC-10h],'\'
  5659                                  	; 30/04/2018
  5660                                  	;mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],'\' ; [ES:0Eh]
  5661                                  	; 23/09/2018
  5662                                  	mov	byte [ES:(ECOMSPEC-ENVIRONMENT)],al ; mov es:0Eh,al
  5663                                  gottheenvir:
  5664                                  IUSESLASH:
  5665                                  
  5666                                  ; Initialize the command drive
  5667                                  
  5668                                  %endif
  5669                                  	; 14/01/2023
  5670                                  	; MSDOS 3.3 & MSDOS 6.0
  5671 00001535 B419                    	mov	ah,19h
  5672                                  	;mov	ah,GET_DEFAULT_DRIVE	; 19h
  5673 00001537 CD21                    	int	21h
  5674 00001539 FEC0                    	inc	al
  5675 0000153B A2[9701]                	mov	[ComDrv],al
  5676                                  
  5677                                          ;mov	al,byte ptr ds:[FCB]	; al = default drive number for command
  5678 0000153E A05C00                          mov	al,[FCB]
  5679 00001541 08C0                    	or	al,al
  5680 00001543 7426                    	jz	short nocomdrv		; no drive specified
  5681                                  
  5682 00001545 B43A                    	mov	ah,':'
  5683 00001547 A2[9701]                	mov	[ComDrv],al
  5684 0000154A 0440                    	add	al,40h			; convert number to uppercase character
  5685                                  
  5686 0000154C FD                      	std
  5687                                  
  5688                                  	; MSDOS 6.0
  5689                                  	;cmp	byte [AllocedEnv],0	; if a new environment is being built,
  5690                                  	;je	short notwidenv		;  move the default comspec string in it
  5691                                  	; 14/01/2023
  5692                                  	; MSDOS 5.0 COMMAND.COM
  5693                                  	;mov	di,[ComspOffset]
  5694                                          ;cmp	byte [es:di+1],':'	; drive specifier already exist?
  5695                                          ;je	short notwidenv		; yes, must have been inherited that way
  5696                                  
  5697                                  	; MSDOS 3.3
  5698                                  	;cmp	byte [CHUCKENV],0
  5699                                  	;jne	short NOTWIDENV
  5700                                  	; 21/01/2021
  5701                                  	; MSDOS 5.0 - COMMAND.COM - RESGROUP:16A5h
  5702 0000154D 803E[7B1C]00             	cmp	byte [AllocedEnv],0
  5703 00001552 7713                    	ja	short notwidenv
  5704                                  
  5705 00001554 1E                        	push	ds			;  2 bytes to make room for a drivespec.
  5706 00001555 06                      	push	es			;  the drivespec is in ax and is copied
  5707 00001556 1F                      	pop	ds			;  on to the front of the string.
  5708                                  
  5709                                  	; MSDOS 6.0
  5710                                          ;lea	si,[di+MAX_COMSPEC-3]	
  5711                                          ;lea	di,[di+MAX_COMSPEC-1]
  5712                                  
  5713                                  	; 21/01/2023
  5714                                  	; 14/01/2023
  5715                                  	; MSDOS 5.0 COMMAND.COM
  5716                                  	; MSDOS 3.3
  5717                                  	; 23/09/2018
  5718                                  	; 30/04/2018
  5719                                  	;mov	di,159
  5720                                  	;;MOV	DI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-1-10H
  5721                                  	;mov	di,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-1 ; mov di,9Fh
  5722 00001557 BF9F00                  	mov	di,ENVIRONSIZ-1 ; 21/01/2023
  5723                                  	;mov	si,157
  5724                                  	;;MOV	SI,OFFSET ENVIRONMENT:ECOMSPEC+ENVIRONSIZ2-3-10H
  5725                                          ;mov	si,(ECOMSPEC-ENVIRONMENT)+ENVIRONSIZ2-3 ; mov si,9Dh 
  5726 0000155A BE9D00                  	mov	si,ENVIRONSIZ-3 ; 21/01/2023 	
  5727                                  	;mov	cx,144
  5728                                  	;MOV	CX,ENVIRONSIZ2-2 ; mov cx,90h
  5729 0000155D B99000                          mov	cx,MAX_COMSPEC-2 ; 144
  5730                                  
  5731 00001560 F3A4                    	rep	movsb
  5732 00001562 1F                      	pop	ds
  5733                                  
  5734                                  	; MSDOS 6.0
  5735                                  	;mov	word ptr es:[di-1],ax
  5736                                  
  5737                                  	; MSDOS 3.3
  5738                                  	;mov	[es:0Eh],ax
  5739                                  	;;;MOV	WORD PTR ES:[ECOMSPEC-10H],AX
  5740                                  	;;MOV	[es:(ECOMSPEC-ENVIRONMENT)],ax	; mov [es:0Eh],ax
  5741                                  	; 14/01/2023
  5742 00001563 26A30E00                	mov	[es:ECOMSPEC],ax ; mov [es:0Eh],ax
  5743                                  
  5744                                  	; MSDOS 3.3 & MSDOS 6.0
  5745                                  notwidenv:
  5746 00001567 FC                      	cld
  5747 00001568 A3[5D1C]                	mov	[AUTOBAT],ax ; ":\AUTOEXEC.BAT"
  5748                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5749                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C3h)
  5750                                  	;mov	[KAUTOBAT],ax
  5751                                  nocomdrv:
  5752 0000156B E896FA                  	call	SetVect        ; Set the vectors
  5753                                  
  5754                                  ; parsing starts here
  5755                                  
  5756                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5757                                  	; (MSDOS 5.0 COMMAND.COM RESGROUP:16C9h)
  5758                                  	; MSDOS 6.0
  5759 0000156E 0E                      	push	cs
  5760 0000156F 0E                      	push	cs
  5761 00001570 1F                      	pop	ds
  5762 00001571 07                      	pop	es
  5763                                  	;assume ds:ResGroup,es:ResGroup
  5764                                  
  5765                                  ; 14/01/2023
  5766                                  %if 0	
  5767                                  	; MSDOS 3.3
  5768                                  	mov	si,80h		; get command line
  5769                                  	lodsb			; get length of line
  5770                                  	mov	cl,al
  5771                                  	xor	ch,ch		; cx = length of command line
  5772                                  
  5773                                  ; insure that the command line correctly ends with a cr
  5774                                  
  5775                                  	add	si,cx		; go to end of command line	
  5776                                  	mov	byte [si], 0Dh	; insert a carriage return
  5777                                  
  5778                                  	mov	si,81h		; Start of parms
  5779                                  CHKARG:
  5780                                          jcxz	COMRETURNSJ     ; No parameters
  5781                                          dec	cx
  5782                                  	lodsb
  5783                                  CHECKSWITCHCHR:
  5784                                  	;cmp	al,' '
  5785                                  	cmp	al,[SPACE_CHR]	 ;Skip blank spaces
  5786                                  	jz	short CHKARG
  5787                                  	cmp	al,9		; Skip TAB characters
  5788                                  	jz	short CHKARG
  5789                                  	cmp	al,[RSWITCHAR]	; Switch?
  5790                                  	jz	short PARSE_CONT ; Yes, get the char after the switch
  5791                                  	jmp	CHKOTHERARGS	; No
  5792                                  
  5793                                  %endif
  5794                                  	; 14/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5795                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:16CDh - CODERES:098Dh)
  5796                                  	; MSDOS 6.0
  5797                                  
  5798 00001572 BE8000                  	mov	si,80h				; get command line
  5799 00001575 AC                      	lodsb					; get length of line
  5800 00001576 89F7                    	mov	di,si				; get line position in di
  5801 00001578 30E4                    	xor	ah,ah				; ax = length of command line
  5802                                  
  5803                                  ; insure that the command line correctly ends with a cr
  5804                                  
  5805 0000157A 01C7                    	add	di,ax				; go to end of command line
  5806 0000157C C6050D                          mov	byte [di],0Dh			; insert a carriage return
  5807 0000157F 31C9                    	xor	cx,cx				; clear cx
  5808 00001581 890E[3E1D]                      mov	[num_positionals],cx		; initialize positionals
  5809                                  
  5810                                  ; Scan the command line looking for the parameters
  5811                                  
  5812                                  Parse_command_line:
  5813                                  	;mov	di,offset ResGroup:Parse_Command; Get address of parse_command
  5814 00001585 BF[B01C]                	mov	di,PARSE_COMMAND
  5815 00001588 8B0E[3E1D]              	mov	cx,[num_positionals]		; Get number of positionals
  5816 0000158C 31D2                    	xor	dx,dx				; clear dx
  5817 0000158E 8936[401D]                      mov	[old_parse_ptr],si		; save position before calling parser
  5818                                  	;call	dword ptr Init_Parse
  5819 00001592 FF1E[A31C]              	call	far [Init_Parse]		; call parser
  5820 00001596 890E[3E1D]                      mov     [num_positionals],cx		; Save number of positionals
  5821                                  	; 29/01/2023
  5822                                  	;;cmp	ax,END_OF_LINE ; 0FFFFh ; -1 	; are we at end of line?
  5823                                          ;cmp	ax,-1
  5824                                  	;jne	short t1
  5825                                  	; 10/06/2023
  5826 0000159A 40                      	inc	ax	 ; cmp ax,-1
  5827 0000159B 7503                    	jnz	short t1 ; 0FFFFh -> 0
  5828                                  	; ax = 0
  5829 0000159D E9FB01                  	jmp     ArgsDone                        ; yes - exit
  5830                                  t1:	
  5831                                  	;;cmp	ax,RESULT_NO_ERROR ; 0		; did an error occur
  5832                                  	;;cmp	ax,0
  5833                                  	;and	ax,ax
  5834                                  	; 10/06/2023
  5835 000015A0 48                      	dec	ax  ; cmp ax,0
  5836 000015A1 7447                    	jz	short parse_cont  ; 1 -> 0	; no - continue
  5837                                  
  5838                                  ; Before issuing error message - make sure switch is not /C
  5839                                  
  5840                                  parse_line_error:
  5841                                  	; 14/01/2023
  5842                                  	;push	si				; save line position
  5843                                  	;push	ax				; save error number
  5844                                  	;cmp	ax,3
  5845 000015A3 83F803                  	cmp	ax,BadSwt_Ptr ; 3		; Was error invalid switch?
  5846                                          ;jnz	short parse_line_error_disp	; No - just issue message
  5847 000015A6 752A                    	jne	short parse_line_error_disp2
  5848 000015A8 56                      	push	si ; **				; save line position
  5849 000015A9 50                      	push	ax ; *				; save error number
  5850 000015AA 89F7                    	mov	di,si				; Get terminating pointer in DI
  5851 000015AC 8B36[401D]                      mov     si,[old_parse_ptr]		; Get starting pointer in SI
  5852                                  
  5853                                  init_chk_delim:
  5854 000015B0 39FE                    	cmp	si,di				; at end of parsed parameter?
  5855 000015B2 741C                            je	short parse_line_error_disp	; Yes - just display message
  5856 000015B4 AC                      	lodsb					;
  5857 000015B5 3C20                    	cmp	al,20h ; ' ' ; 16/04/2023
  5858                                  	;cmp	al,space_chr ; 14/01/2023
  5859                                  	;;cmp	al,[space]			; Skip blank spaces
  5860 000015B7 74F7                    	je	short init_chk_delim		;
  5861                                  	;cmp	al,9
  5862 000015B9 3C09                    	cmp	al,tab_chr ; 9			; Skip tab characters
  5863 000015BB 74F3                    	je	short init_chk_delim		;
  5864                                  
  5865 000015BD 3A06[5303]              	cmp	al,[RSwitChar]	; '/'		; Switch?
  5866 000015C1 750D                            jne	short parse_line_error_disp	; No - just issue message
  5867 000015C3 AC                      	lodsb					; Get the char after the switch
  5868                                  
  5869 000015C4 E86F04                  	call	iupconv 			; upper case it
  5870                                  
  5871                                  	;cmp	al,[scswitch]	; 'C'		; it is /C?
  5872                                          ;jne	short check_k_too ; MSDOS 6.0	;
  5873                                  	;16/04/2023
  5874 000015C7 3C43                    	cmp	al,'C' ; scswitch
  5875 000015C9 7505                    	jne	short parse_line_error_disp  ; MSDOS 5.0 COMMAND.COM
  5876 000015CB 5A                      	pop	dx ; *				; even up stack
  5877 000015CC 5A                      	pop	dx ; **				; even up stack
  5878 000015CD E99800                  	jmp	SetSSwitch			; Yes - go set COMMAND /C
  5879                                  
  5880                                  	; MSDOS 6.0
  5881                                  ;check_k_too:
  5882                                  	;cmp	al,[skswitch]	; 'K'		; it is /K?
  5883                                          ;jne	short parse_line_error_disp	;
  5884                                  	;pop	dx ; *				; even up stack
  5885                                  	;pop	dx ; **				; even up stack
  5886                                          ;jmp	SetKSwitch			; Yes - go set COMMAND /K
  5887                                  
  5888                                  parse_line_error_disp:
  5889                                  	; 14/01/2023
  5890 000015D0 58                      	pop	ax ; *				; restore error number
  5891 000015D1 5E                      	pop	si ; **				; restore line position
  5892                                  parse_line_error_disp2:
  5893 000015D2 89C2                    	mov	dx,ax				; get message number
  5894 000015D4 E80304                  	call	RPrintParse
  5895 000015D7 E8B3FC                  	call	crlf
  5896 000015DA EBA9                            jmp     short Parse_command_line        ; continue parsing
  5897                                  
  5898                                  ; 16/04/2023
  5899                                  %if 1
  5900                                  SetMSwitch:
  5901                                          ;cmp	byte [ext_msg],1
  5902 000015DC 803E[AB1C]01            	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  5903                                  	; 16/04/2023
  5904                                  	;jnz	short setMswitchok		; no - set it
  5905                                  	;;mov	ax,1
  5906                                  	;mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  5907                                  	;jmp	parse_line_error                ; go issue error message
  5908                                  	; 16/04/2023
  5909 000015E1 744F                    	je	short parse_line_error_j
  5910                                  setMswitchok:
  5911                                          ;mov	byte [ext_msg],1
  5912 000015E3 C606[AB1C]01            	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  5913                                  	; 06/06/2023
  5914 000015E8 EB9B                    	jmp	short Parse_command_line	; keep parsing
  5915                                  %endif
  5916                                  
  5917                                  parse_cont:
  5918                                  
  5919                                  ; 15/01/2023
  5920                                  %if 0
  5921                                  	; MSDOS 3.3
  5922                                  
  5923                                  ; See if a switch was entered
  5924                                  
  5925                                  	jcxz	COMRETURNSJ
  5926                                  	dec	cx
  5927                                  	lodsb
  5928                                  	or	al,20h		; Lower case
  5929                                  	cmp	al,'f'		; FAIL switch
  5930                                  	jnz     short CHECKPSWITCH
  5931                                  %endif
  5932                                  
  5933                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  5934                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:173Ch - CODERES:09FCh)
  5935                                  	; MSDOS 6.0
  5936                                  
  5937                                  ; See if a switch was entered
  5938                                  ;
  5939                                  ; Bugbug: See if Comnd1_Syn can be moved into a reg. before the compare
  5940                                  
  5941 000015EA 813E[371D][E71C]        	cmp	word [COMND1_SYN],COMMAND_F_SYN ; was /F entered?
  5942 000015F0 742A                    	je	short SetFSwitch		; yes go set fail switch
  5943 000015F2 813E[371D][DB1C]        	cmp	word [COMND1_SYN],COMMAND_P_SYN ; was /P entered?
  5944 000015F8 7431                    	Je	short SetPSwitch		; yes go set up PERMCOM
  5945 000015FA 813E[371D][F31C]        	cmp	word [COMND1_SYN],COMMAND_D_SYN ; was /D entered?
  5946 00001600 7453                    	je	short SetDSwitch		; yes go set date switch
  5947 00001602 813E[371D][181D]        	cmp	word [COMND1_SYN],COMMAND_C_SYN ; was /C entered?
  5948 00001608 745E                    	je	short SetSSwitch		; yes go set up SINGLECOM
  5949                                  	; MSDOS 6.0 only!
  5950                                  	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; was /K entered?
  5951                                          ;je	short SetKSwitch		; yes go set up SINGLECOM
  5952 0000160A 813E[371D][FF1C]        	cmp	word [COMND1_SYN],COMMAND_E_SYN ; was /E entered?
  5953 00001610 7467                    	je	short SetESwitch		; yes go set up environment
  5954 00001612 813E[371D][241D]        	cmp	word [COMND1_SYN],COMMAND_M_SYN	; was /MSG entered?
  5955                                  	;je	short SetMSwitchjmp		; yes go set up message flag
  5956                                  	; 15/01/2023
  5957 00001618 74C2                    	je	short SetMSwitch 
  5958 0000161A EB7B                    	jmp	ChkOtherArgs		; Must be something else
  5959                                  
  5960                                  	; MSDOS 6.0
  5961                                  ;SetMSwitchjmp:
  5962                                  	;jmp	SetMSwitch
  5963                                  	
  5964                                  	; MSDOS 6.0
  5965                                  SetFSwitch:
  5966 0000161C 803E[AA01]FF            	cmp	byte [fFail],-1		; has fail switch been set?
  5967                                  	; 16/04/2023
  5968                                  	;jne	short failok		; no - set it
  5969                                  	;;mov	ax,1
  5970                                  	;mov	ax,MoreArgs_Ptr         ; set up too many arguments
  5971                                          ;jmp	parse_line_error        ; go issue error 
  5972                                  	; 16/04/2023
  5973 00001621 740F                    	je	short parse_line_error_j
  5974                                  
  5975                                  	; MSDOS 3.3 & MSDOS 6.0
  5976                                  failok:
  5977 00001623 C606[AA01]FF            	mov	byte [fFail],-1		; fail all INT 24s.
  5978                                  	; MSDOS 3.3
  5979                                  	;jmp	short CHKARG
  5980                                  	; MSDOS 6.0
  5981 00001628 E95AFF                  	jmp	Parse_command_line
  5982                                  
  5983                                  ;CHECKPSWITCH:
  5984                                  	;;cmp	al,'p'			; Permanent COMMAND switch
  5985                                  	;cmp	al,[letter_p]
  5986                                          ;jnz	short CHECKDSWITCH
  5987                                  
  5988                                  SetPSwitch:
  5989                                  
  5990                                  ; We have a permanent COMMAND switch /P. Flag this and stash the
  5991                                  ; termination address.
  5992                                  
  5993                                  	; MSDOS 6.0
  5994 0000162B 803E[A501]00            	cmp	byte [PermCom],0	; has /p switch been set?
  5995 00001630 7406                    	jz	short permcomok		; no - set it
  5996                                  	; 16/04/2023
  5997                                  parse_line_error_j:
  5998                                          ;mov	ax,1
  5999 00001632 B80100                  	mov	ax,MoreArgs_Ptr		; set up too many arguments
  6000 00001635 E96BFF                          jmp	parse_line_error	; go issue error 
  6001                                  
  6002                                  permcomok:
  6003                                  	; MSDOS 3.3 & MSDOS 6.0
  6004 00001638 FE06[A501]              	inc	byte [PermCom]
  6005                                  	;mov	word [OLDTERM],LODCOM
  6006 0000163C C706[4301][7E00]        	mov	word [OldTerm],LodCom_Trap
  6007                                  	;mov	[OLDTERM+2],ds
  6008 00001642 8C1E[4501]              	mov	[OldTerm+2],ds
  6009                                  
  6010                                  ; make sure that we display the date and time. if the flag was not
  6011                                  ; initialized, set it to indicate yes, do prompt.
  6012                                  
  6013                                  	; MSDOS 3.3
  6014                                  	;cmp	byte [PRDATTM],-1
  6015                                  	;jnz	short CHKARG
  6016                                  	;mov	byte [PRDATTM],0
  6017                                  	;jmp	short CHKARG
  6018                                  
  6019                                  	; MSDOS 6.0
  6020 00001646 803E[6E1C]FF            	cmp	byte [PRDATTM],-1
  6021 0000164B 7505                    	jne	short Parse_command_line_jmp
  6022 0000164D C606[6E1C]00            	mov	byte [PRDATTM],0
  6023                                  Parse_command_line_jmp:
  6024 00001652 E930FF                  	jmp     Parse_command_line	; keep parsing
  6025                                  
  6026                                  ;COMRETURNSJ:
  6027                                  ;	; MSDOS 3.3
  6028                                  ;	JMP	ARGSDONE
  6029                                  
  6030                                  ;CHECKDSWITCH:
  6031                                  	;;cmp	al,'d'
  6032                                          ;cmp	al,[letter_d]
  6033                                  	;jnz	short CHECKCSWITCH
  6034                                  
  6035                                  SetDSwitch:
  6036                                  
  6037                                  ; Flag no date/time prompting.
  6038                                  
  6039                                  	; MSDOS 6.0
  6040 00001655 803E[AD1C]00            	cmp	byte [dswitch],0	; has /D switch been set?
  6041                                  	; 16/04/2023
  6042                                  	;jz	short setdateok		; no - set it
  6043                                          ;;mov	ax,1
  6044                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6045                                          ;jmp	parse_line_error	; go issue error message
  6046                                  	; 16/04/2023
  6047 0000165A 75D6                    	jnz	short parse_line_error_j
  6048                                  setdateok:
  6049 0000165C FE06[AD1C]              	inc	byte  [dswitch]		; indicate /D entered
  6050                                  
  6051                                  	; MSDOS 3.3 & MSDOS 6.0
  6052 00001660 C606[6E1C]01                    mov	byte [PRDATTM],1	; User explicitly says no date time
  6053                                  	; MSDOS 3.3
  6054                                  	;jmp	short CHKARG
  6055                                  	; MSDOS 6.0
  6056 00001665 E91DFF                  	jmp     Parse_command_line	; continue parsing
  6057                                  
  6058                                  	; 15/01/2023
  6059                                  	; MSDOS 6.0 
  6060                                  ;SetKSwitch:
  6061                                  	;mov	byte [SemiPermCom],0
  6062                                  	;jmp	short SetSorKSwitch
  6063                                  
  6064                                  ;CHECKCSWITCH:
  6065                                  	;;cmp	al,'c'
  6066                                  	;cmp	al,[letter_c]
  6067                                          ;jnz	short CHECKESWITCH
  6068                                  
  6069                                  SetSSwitch:
  6070                                  ;SETCSWITCH:
  6071                                  
  6072                                  ; Set up pointer to command line, flag no date/time and turn off SingleCom.
  6073                                  
  6074 00001668 C606[A501]00            	mov	byte [PermCom],0	; A SingleCom must not be a PermCom
  6075                                  ;SetSorKSwitch:
  6076 0000166D 8936[A601]              	mov	[SingleCom],si		; Point to the rest of the command line
  6077 00001671 C606[6E1C]01            	mov	byte [PRDATTM],1	; no date or time either, explicit
  6078                                  ;COMRETURNSJ: ; 24/09/2018
  6079 00001676 E92201                  	jmp     ArgsDone
  6080                                  
  6081                                  ;CHECKESWITCH:
  6082                                  	;cmp	al,'e'
  6083                                  	;jnz	short CHKARG
  6084                                  
  6085                                  ; Look for environment-size setting switch
  6086                                  
  6087                                  ; The environment size is represented in decimal bytes and is
  6088                                  ; converted into paragraphs (rounded up to the next paragraph).
  6089                                  
  6090                                  SetESwitch:
  6091                                  	; MSDOS 6.0
  6092 00001679 803E[AC1C]00            	cmp	byte [eswitch],0	; has environment size switch been set?
  6093                                  	; 16/04/2023
  6094                                  	;jz	short eswitchok		; no - set it
  6095                                  	;;mov	ax,1
  6096                                  	;mov	ax,MoreArgs_Ptr		; set up too many arguments
  6097                                          ;jmp	parse_line_error	; go issue error message
  6098                                  	; 16/04/2023
  6099 0000167E 75B2                    	jnz	short parse_line_error_j
  6100                                  eswitchok:
  6101 00001680 FE06[AC1C]              	inc	byte [eswitch]		; indicate /E entered 	
  6102                                  
  6103                                  ; 15/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6104                                  %if 0
  6105                                  	; 23/09/2018 - Retro DOS v3.0
  6106                                  
  6107                                  	; MSDOS 3.3
  6108                                  	; (COMMAND.COM offset 0FC5h)
  6109                                  ESWITCHOK:
  6110                                  	jcxz    CHKARG
  6111                                  	dec     cx
  6112                                  	lodsb
  6113                                  	cmp     al,':'
  6114                                  	jnz     short CHECKSWITCHCHR
  6115                                  	xor     bx,bx
  6116                                  	mov     ax,bx
  6117                                  GETENVSIZE:
  6118                                  	jcxz    SETENVSIZE
  6119                                  	dec     cx
  6120                                  	lodsb
  6121                                  	cmp     al,'0'
  6122                                  	jb      short NOTDECIMALCHR
  6123                                  	cmp     al,'9'
  6124                                  	ja      short NOTDECIMALCHR
  6125                                  	sub     al,'0'
  6126                                  	mov     dx,bx
  6127                                  	shl     dx,1
  6128                                  	shl     dx,1   ; dx = 4*bx	
  6129                                  	add     bx,dx  ; bx = 5*bx
  6130                                  	shl     bx,1   ; bx = 10*bx	
  6131                                  	add     bx,ax
  6132                                  	jmp     short GETENVSIZE
  6133                                  
  6134                                  NOTDECIMALCHR:
  6135                                  	;cmp	al,' '
  6136                                  	cmp	al,[SPACE_CHAR]
  6137                                  	jz      short CHECKENVSIZE
  6138                                  	;cmp	al,'/'
  6139                                  	cmp     al,[RSWITCHAR]
  6140                                  	jz      short CHECKENVSIZE
  6141                                  
  6142                                  CHECKNEXTECHR:
  6143                                  	jcxz    INVENVSIZE
  6144                                  	dec     cx
  6145                                  	lodsb
  6146                                  	;cmp	al,' '
  6147                                  	cmp     al,[SPACE_CHR]
  6148                                  	jz      short ENVSIZESPC
  6149                                  	;cmp	al,'/'
  6150                                  	cmp     al,[RSWITCHAR]
  6151                                  	jnz     short CHECKNEXTECHR
  6152                                  
  6153                                  ENVSIZESPC:
  6154                                  	dec     si
  6155                                  	inc     cx
  6156                                  	jmp     short INVENVSIZE
  6157                                  	
  6158                                  	;nop
  6159                                  
  6160                                  CHECKENVSIZE: 
  6161                                  	dec     si
  6162                                  	inc     cx
  6163                                  
  6164                                  SETENVSIZE:
  6165                                  	;mov	word [ENVSIZ],2048	; Maximum environment size (32KB)
  6166                                  	mov	word [ENVSIZ],ENVBIG/16
  6167                                  	cmp     bx,32768
  6168                                  	ja      short INVENVSIZE
  6169                                  	;mov	word [ENVSIZ],10	; Minimum environment size (160 bytes)
  6170                                  	mov	word [ENVSIZ],ENVSML/16
  6171                                  	cmp     bx,160
  6172                                  	jb      short INVENVSIZE
  6173                                  	add     bx,15
  6174                                  	shr     bx,1
  6175                                  	shr     bx,1
  6176                                  	shr     bx,1
  6177                                  	shr     bx,1
  6178                                  	mov	[ENVSIZ],bx		; EnvSiz is in paragraphs
  6179                                  	jmp     short NEXTCH2
  6180                                  
  6181                                  	;nop
  6182                                  
  6183                                  INVENVSIZE:
  6184                                  	mov     dx,BADENVSIZMSG ; "Invalid environment size specified\r\n$"
  6185                                  	mov     ah,STD_CON_STRING_OUTPUT ; 9
  6186                                  	int     21h             ; DOS - PRINT STRING
  6187                                  				; DS:DX -> string terminated by "$"
  6188                                  NEXTCH2:
  6189                                  	; (MSDOS 3.3 COMMAND.COM, offset 1041h)
  6190                                  	jmp     CHKARG
  6191                                  
  6192                                  	;jmp	ARGSDONE
  6193                                  
  6194                                  %endif
  6195                                  	; 15/01/2023
  6196                                  	; MSDOS 6.0
  6197                                  	;mov	di,offset ResGroup:Comnd1_Addr	; get number returned
  6198 00001684 BF[391D]                        mov	di,COMND1_ADDR
  6199 00001687 8B1D                    	mov     bx,[di]				; into bx
  6200                                  
  6201 00001689 83C30F                  	add	bx,0Fh				; Round up to next paragraph
  6202 0000168C B104                    	mov	cl,4				; convert to pargraphs
  6203 0000168E D3EB                    	shr	bx,cl				; by right 4
  6204                                  
  6205 00001690 891E[971C]              	mov	[EnvSiz],bx			; EnvSiz is in paragraphs
  6206 00001694 E9EEFE                  	jmp	Parse_command_line		; continue parsing command line
  6207                                  
  6208                                  ; 16/04/2023
  6209                                  %if 0
  6210                                  SetMSwitch:
  6211                                          ;cmp	byte [ext_msg],1
  6212                                  	cmp	byte [ext_msg],SET_EXTENDED_MSG	; has /MSG switch been set?
  6213                                  	jnz	short setMswitchok		; no - set it
  6214                                  	;mov	ax,1
  6215                                  	mov	ax,MoreArgs_Ptr                 ; set up too many arguments
  6216                                  	jmp	parse_line_error                ; go issue error message
  6217                                  setMswitchok:
  6218                                          ;mov	byte [ext_msg],1
  6219                                  	mov	byte [ext_msg],SET_EXTENDED_MSG	; set /MSG switch
  6220                                  	jmp	Parse_command_line              ; keep parsing
  6221                                  %endif
  6222                                  
  6223                                  ;ArgsDoneJ:
  6224                                  	;jmp	ArgsDone
  6225                                  
  6226                                  	; 15/01/2023 - Retro DOS v4.0 (& V4.1) COMMAND.COM
  6227                                  	; (MSDOS 5.0 COMMAND.COM - RESGROUP:181Dh - CODERES:0ADDh)
  6228                                  	
  6229                                  ChkOtherArgs:
  6230                                  
  6231                                  ; We have a non-switch character here.
  6232                                  
  6233                                  	; MSDOS 6.0
  6234 00001697 1E                      	push	ds ; ****			;
  6235 00001698 56                      	push	si ; *** 			; save place in command line
  6236 00001699 C536[391D]              	lds	si,[COMND1_ADDR]		; get address of filespec
  6237                                  	;assume	ds:nothing			;
  6238                                  
  6239 0000169D 89F2                    	mov	dx,si				; put in dx also
  6240 0000169F B8023D                  	mov	ax,3D02h
  6241                                  	;mov	ax,(OPEN shl 8) or 2            ; Read and write
  6242 000016A2 CD21                    	int	21h
  6243 000016A4 7260                    	jc	short ChkSrchSpec		; Wasn't a file
  6244 000016A6 89C3                    	mov	bx,ax
  6245 000016A8 B80044                  	mov	ax,4400h
  6246                                  	;mov	ax,IOCTL shl 8
  6247 000016AB CD21                    	int	21h
  6248 000016AD F6C280                  	test	dl,80h
  6249 000016B0 7506                    	jnz	short IsaDevice
  6250                                  BadSetCon:
  6251 000016B2 B43E                    	mov	ah,3Eh
  6252                                  	;mov	ah,CLOSE		; Close initial handle, wasn't a device
  6253 000016B4 CD21                    	int	21h
  6254 000016B6 EB4E                    	jmp	short ChkSrchSpec
  6255                                  
  6256                                  ; 15/01/2023
  6257                                  %if 0
  6258                                  	; MSDOS 3.3
  6259                                  	; (COMMAND.COM offset 1047h)
  6260                                          dec	si
  6261                                  	inc	cx
  6262                                  	mov	dx,si
  6263                                  	push	cx ; **
  6264                                  	push	si ; *
  6265                                  CONTRLOOP:
  6266                                  	lodsb
  6267                                  	dec	cx
  6268                                  	;cmp	al,' '
  6269                                  	cmp	al,[SPACE_CHR]
  6270                                  	jz	short SETCDEV
  6271                                  	cmp	al,9
  6272                                  	jz	short SETCDEV
  6273                                  	jcxz	SETCDEVA
  6274                                  	jmp	short CONTRLOOP
  6275                                  
  6276                                  SETCDEVA:
  6277                                          inc	si
  6278                                  SETCDEV:
  6279                                  	mov	byte [SI-1],0
  6280                                          ;mov	ax,(OPEN SHL 8) OR 2  ; Read and write
  6281                                          mov	ax,(OPEN*256) | 2 ; 3D02h
  6282                                          int     21h	; DOS - 2+ - OPEN DISK FILE WITH HANDLE
  6283                                  			; DS:DX -> ASCIZ filename
  6284                                  			; AL = access mode
  6285                                  			; 2 - read & write
  6286                                          jc	short CHKSRCHSPEC	; Wasn't a file
  6287                                          mov	bx,ax
  6288                                          ;mov	ax,IOCTL shl 8
  6289                                          mov     ax,IOCTL*256 ; 4400h
  6290                                  	int     21h	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
  6291                                  			; BX = file or device handle
  6292                                          test	dl,80H
  6293                                  	jnz	short ISADEVICE
  6294                                  BADSETCON: ; MSDOS 6.0
  6295                                  	mov	ah,CLOSE ; 3Eh	; Close initial handle, wasn't a device
  6296                                          int     21h	; DOS - 2+ - CLOSE A FILE WITH HANDLE
  6297                                  			; BX = file handle
  6298                                          JMP     short CHKSRCHSPEC
  6299                                  %endif
  6300                                  	;nop
  6301                                  
  6302                                  	; 15/01/2023
  6303                                  IsaDevice:
  6304                                  	; MSDOS 3.3 & MSDOS 6.0
  6305 000016B8 30F6                    	xor	dh,dh
  6306 000016BA 80CA03                  	or	dl,3				; Make sure has CON attributes
  6307                                  	;mov	ax,(IOCTL shl 8) or 1
  6308 000016BD B80144                  	mov	ax,(IOCTL*256)|1 ; 4401h
  6309 000016C0 CD21                    	int	21h
  6310                                  	;
  6311                                  	; 15/01/2023
  6312 000016C2 72EE                    	jc	short BadSetCon	; MSDOS 6.0 (& 5.0)
  6313                                  	; 25/09/2018
  6314                                  	;pop	dx ; *
  6315                                  	;pop	dx ; **
  6316                                  	;
  6317                                  	;jc	short BADSETCON	; MSDOS 6.0	; Can't set attributes - quit
  6318                                  	
  6319 000016C4 89DA                    	mov	dx,bx				; Save new handle
  6320                                  
  6321                                  	; MSDOS 6.0
  6322 000016C6 26803E[EB20]01          	cmp	byte [es:DevFlag],1
  6323 000016CC 742A                    	jz	short DevErr
  6324                                  
  6325                                  	; MSDOS 3.3
  6326                                          ;pop	bx ; *				; Throw away saved SI
  6327                                          ;pop	bx ; **				; Throw away saved CX
  6328                                  
  6329                                  	; MSDOS 3.3 & MSDOS 6.0
  6330 000016CE 51                      	push	cx ; **
  6331 000016CF B90300                  	mov	cx,3
  6332 000016D2 31DB                    	xor	bx,bx
  6333                                  
  6334                                  	; 15/01/2023
  6335                                  rcclloop:
  6336 000016D4 B43E                    	mov	ah,3Eh
  6337                                  	;mov	ah,CLOSE ; 3Eh
  6338 000016D6 CD21                    	int	21h
  6339 000016D8 43                      	inc	bx
  6340 000016D9 E2F9                    	loop	rcclloop
  6341                                  
  6342 000016DB 89D3                    	mov	bx,dx				; New device handle
  6343 000016DD B445                    	mov	ah,45h
  6344                                  	;mov	ah,XDUP ; 45h
  6345 000016DF CD21                    	int	21h				; Dup to 0
  6346 000016E1 B445                    	mov	ah,45h
  6347                                  	;mov	ah,XDUP
  6348 000016E3 CD21                    	int	21h				; Dup to 1
  6349 000016E5 B445                    	mov	ah,45h
  6350                                  	;mov	ah,XDUP
  6351 000016E7 CD21                    	int	21h				; Dup to 2
  6352 000016E9 B43E                    	mov	ah,3Eh
  6353                                  	;mov	ah,CLOSE
  6354 000016EB CD21                    	int	21h				; Close initial handle
  6355                                  	
  6356 000016ED 59                      	pop	cx ; **
  6357                                  	
  6358                                  	; MSDOS 6.0
  6359 000016EE 5E                      	pop	si ; ***			; restore position of command line
  6360 000016EF 1F                      	pop	ds ; ****			;
  6361                                  
  6362                                  ; Register the fact that we already have redirected the output
  6363                                  ; and can not do it again
  6364                                  
  6365 000016F0 26FE06[EB20]            	inc	byte [es:DevFlag]		
  6366 000016F5 E98DFE                  	jmp	Parse_command_line		; continue parsing
  6367                                  
  6368                                  	; MSDOS 3.3
  6369                                  	;jcxz	ARGSDONEJ2
  6370                                  	;jmp	CHKARG
  6371                                  
  6372                                  	; MSDOS 6.0
  6373                                  DevErr:
  6374 000016F8 5E                      	pop	si ; ***
  6375 000016F9 1F                      	pop	ds ; ****
  6376 000016FA BA0100                  	mov	dx,1
  6377 000016FD E8DA02                          call	RPrintParse                     ; "Too many parameters"
  6378 00001700 E88AFB                          call	crlf
  6379 00001703 E97FFE                  	jmp	Parse_command_line
  6380                                  
  6381                                  ChkSrchSpec:				; Not a device, so must be directory spec
  6382                                  	; MSDOS 6.0
  6383 00001706 26803E[EC20]01                  cmp	byte [es:PathFlag],1		; already set COMSPEC?
  6384 0000170C 74EA                            jz	short DevErr			; yes, error
  6385                                  	
  6386 0000170E 26FE06[EC20]                    inc	byte [es:PathFlag]		; mark that we have a path
  6387                                  
  6388                                  ; We have to override the passed environment. Allocate a buffer for use now.
  6389                                  ; This buffer will later be replaced by a proper environment
  6390                                  
  6391                                  	; 15/01/2023 - Retro DOS v4.0 COMMAND.COM
  6392                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1899h
  6393 00001713 36A1[3F03]              	mov	ax,[ss:EnvirSeg]
  6394                                  	
  6395                                  	; MSDOS 6.0
  6396                                  	;call	alloc_env                       ; environment buffer
  6397                                  
  6398                                  	; 15/01/2023
  6399                                  	; MSDOS 5.0
  6400 00001717 36803E[7B1C]01          	cmp	byte [ss:AllocedEnv],1
  6401 0000171D 36C606[7B1C]00          	mov	byte [ss:AllocedEnv],0
  6402 00001723 7507                    	jne     short env_alloced
  6403 00001725 E88304                  	call	alloc_env
  6404 00001728 36A3[3F03]              	mov	[ss:EnvirSeg],ax
  6405                                  
  6406                                  env_alloced:
  6407                                  	; MSDOS 5.0 & MSDOS 6.0
  6408 0000172C 8EC0                    	mov	es,ax
  6409                                  	;assume	es:nothing
  6410 0000172E 56                      	push	si ; **				; remember location of file
  6411 0000172F 31C9                    	xor	cx,cx				; clear cx for counting
  6412                                  	
  6413                                  	; 15/01/2023
  6414                                  countloop:
  6415 00001731 AC                      	lodsb					; get a character
  6416 00001732 41                      	inc	cx				; increment counter
  6417                                          ;;cmp	al,0
  6418                                  	;cmp	al,END_OF_LINE_OUT              ; are we at end of line?
  6419                                  	;jne	short countloop			; no - keep counting
  6420 00001733 08C0                    	or	al,al	
  6421 00001735 75FA                    	jnz	short countloop
  6422                                  
  6423                                  	;;;;mov	al,[Space]
  6424                                  	;;;mov	al,[ss:Space] ; 15/01/2023 - MSDOS 5.0 COMMAND.COM
  6425                                  	;;mov	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6426                                  	; 16/04/2023
  6427                                  	;mov	al,20h ; ' ' 
  6428 00001737 4E                      	dec	si				; move back one
  6429                                          ;mov	[si],al				; put a space at end of line
  6430 00001738 C60420                  	mov	byte [si],20h ; ' ' ; space_chr
  6431                                  
  6432                                  ; We now know how long the new pathspec for command.com is. Time to
  6433                                  ; figure out how long the current COMSPEC setting is, and then to move
  6434                                  ; all the environment data up, throwing that COMSPEC setting away, and
  6435                                  ; preparing to append the new COMSPEC. ComspOffset (the offset of
  6436                                  ; where the filespec exists in the environment) is updated as well.
  6437                                  
  6438                                  	; MSDOS 6.0 COMMAND.COM
  6439                                  	;push	cx                              ;
  6440                                          ;mov	cx,ENVBIG                       ;
  6441                                          ;mov	di,ComspOffset                  ; get location of COMSPEC
  6442                                          ;mov	al,0                            ;
  6443                                          ;repne	scasb                           ; find the end of COMSPEC
  6444                                          ;mov	si,di                           ;
  6445                                  ;comp_endenv:                                   ;
  6446                                          ;scasb                                  ; end of env?
  6447                                          ;je	got_endenv                      ; yes
  6448                                          ;repne	scasb                           ;
  6449                                          ;jmp	comp_endenv                     ;
  6450                                  ;got_endenv:                                    ;
  6451                                          ;mov    cx,di                           ;
  6452                                          ;sub    cx,si                           ;
  6453                                          ;mov    di,ComspOffset                  ;
  6454                                          ;sub    di,ComspStrLen                  ;
  6455                                          ;push   ds                              ;
  6456                                          ;push   es                              ;
  6457                                          ;pop    ds                              ;
  6458                                          ;rep    movsb                           ;
  6459                                          ;dec    di                              ; copy in new COMSPEC=
  6460                                          ;push   cs                              ;
  6461                                          ;pop    ds                              ;
  6462                                          ;assume ds:ResGroup                     ;
  6463                                          ;mov    si,offset RESGROUP:ComspString  ;
  6464                                          ;mov    cx,ComspStrLen                  ;
  6465                                          ;rep    movsb                           ;
  6466                                          ;mov    ComspOffset,di                  ;
  6467                                          ;pop    ds                              ;
  6468                                          ;assume ds:nothing                      ;
  6469                                          ;pop    cx                              ;
  6470                                  	;
  6471                                          ;pop    si                              ; get new comspec location back
  6472                                  
  6473                                  	; MSDOS 3.3 COMMAND.COM
  6474                                  	;mov	byte [CHUCKENV],0		; If search specified -- no inheritance
  6475                                  	;mov	ax,PATHSTRING	; "PATH="	; Figure environment pointer
  6476                                  	;mov	cl,4
  6477                                  	;shr	ax,cl
  6478                                  	;mov	dx,ds
  6479                                  	;add	ax,dx
  6480                                  	;mov	[ENVIRSEG],ax
  6481                                  	;mov	es,ax
  6482                                  	;;mov	al,' '
  6483                                  	;mov	al,[SPACE_CHR]
  6484                                  	;mov	[si-1],al
  6485                                  	;pop	si ; **				; Remember location
  6486                                  	;pop	cx ; *				; and count
  6487                                  	;;mov	di,[ECOMLOC]
  6488                                  	;mov	di,[COMSPOFFSET]
  6489                                  
  6490                                  	; 15/01/2023
  6491                                  	; MSDOS 5.0 COMMAND.COM
  6492 0000173B 5E                      	pop	si ; **
  6493                                  	;mov	di,14
  6494 0000173C BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6495                                  
  6496                                  ComtrLoop:
  6497                                  	; MSDOS 3.3 & MSDOS 6.0
  6498 0000173F AC                      	lodsb
  6499 00001740 49                      	dec	cx
  6500                                  	;;;;cmp	al,' '
  6501                                  	;;;cmp	al,[space_chr]
  6502                                  	;;cmp	al,[ss:Space] ;  MSDOS 5.0 COMMAND.COM
  6503                                  	;cmp	al,space_chr ; Retro DOS v4.0 (& v4.1) COMMAND.COM
  6504                                  	; 16/04/2023
  6505 00001741 3C20                    	cmp	al,20h ; ' ' ; space_chr
  6506 00001743 7405                    	je	short SetComsr
  6507                                  	; MSDOS 3.3
  6508                                  	;cmp	al,9
  6509                                  	;je	short SetComsr
  6510                                  	; MSDOS 3.3 & MSDOS 6.0
  6511 00001745 AA                      	stosb
  6512 00001746 E302                    	jcxz	SetComsr
  6513 00001748 EBF5                    	jmp	short ComtrLoop
  6514                                  
  6515                                  SetComsr:
  6516                                  	; 15/01/2023
  6517                                  	; MSDOS 6.0
  6518 0000174A 51                      	push	cx ; **
  6519 0000174B 0E                      	push	cs				; Get local segment
  6520 0000174C 1F                      	pop	ds				;
  6521                                  	;assume	ds:ResGroup			;
  6522 0000174D 1E                      	push	ds ; *
  6523                                  	;mov	si,offset ResGroup:ComSpect
  6524 0000174E BE[4F1C]                	mov	si,COMSPECT
  6525 00001751 B90E00                  	mov	cx,14
  6526 00001754 268A45FF                	mov	al,[es:di-1]
  6527 00001758 3A06[5403]              	cmp	al,[RDirChar]
  6528 0000175C 7502                    	jne	short iNotRoot
  6529 0000175E 46                      	inc	si				; Don't make a double /
  6530 0000175F 49                      	dec	cx
  6531                                  	
  6532                                  	; MSDOS 3.3
  6533                                  	;push	si
  6534                                  	;push	cx
  6535                                  	;push	ds
  6536                                  	;mov	si,COMSPECT ; "/COMMAND.COM"
  6537                                  	;mov	cx,14
  6538                                  	;mov	al,[es:di-1]
  6539                                  	;call	PATHCHRCMPR
  6540                                  	;jnz	short INOTROOT			
  6541                                  	;inc	si				; Don't make a double /
  6542                                  	;dec	cx
  6543                                  
  6544                                  iNotRoot:
  6545                                  	; MSDOS 3.3 & MSDOS 6.0
  6546 00001760 F3A4                    	rep	movsb
  6547                                  
  6548                                  	;;mov	dx,[ECOMLOC]			; Now lets make sure its good!
  6549                                          ;mov	dx,[ComspOffset] ; [COMSPOFFSET]
  6550                                  	; 15/01/2023
  6551                                  	;mov	dx,14
  6552 00001762 BA0E00                  	mov	dx,ECOMSPEC ; mov dx,0Eh
  6553                                  
  6554 00001765 06                      	push	es
  6555 00001766 1F                      	pop	ds
  6556                                  	;;mov	ax,OPEN shl 8
  6557                                  	;mov	ax,OPEN*256 ; 3D00h
  6558 00001767 B8003D                  	mov	ax,3D00h ; 15/01/2023
  6559 0000176A CD21                    	int	21h				; Open COMMAND.COM
  6560 0000176C 1F                      	pop	ds ; *
  6561 0000176D 720E                    	jc	short SetComsrBad		; No COMMAND.COM here
  6562 0000176F 89C3                    	mov	bx,ax				; Handle
  6563 00001771 B43E                    	mov	ah,3Eh ; 15/01/2023
  6564                                  	;mov	ah,CLOSE ; 3Eh
  6565 00001773 CD21                    	int	21h				; Close COMMAND.COM
  6566                                  SetComsrRet:
  6567                                  	; 15/01/2023
  6568 00001775 59                      	pop	cx ; **
  6569 00001776 5E                      	pop	si ; ***
  6570                                  
  6571                                  	; MSDOS 6.0
  6572 00001777 1F                      	pop	ds ; ****			;
  6573                                  	;assume	ds:ResGroup			;
  6574                                  	;
  6575 00001778 0E                      	push	cs				; Make sure local ES is
  6576 00001779 07                      	pop	es				;  restored
  6577 0000177A E908FE                  	jmp	Parse_command_line		; continue parsing command line
  6578                                  
  6579                                  	; MSDOS 3.3
  6580                                  ;ARGSDONEJ2:
  6581                                  	;jcxz	ARGSDONE
  6582                                  	;jmp	CHKARG
  6583                                  
  6584                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6585                                  SetComsrBad:
  6586                                  	; MSDOS 3.3 & MSDOS 6.0
  6587                                  	;mov	dx,offset ResGroup:BadComlkMsg	; dx = ptr to msg
  6588 0000177D BA[D41D]                	mov	dx,BADCOMLKMES
  6589                                  
  6590                                  ;	Note: we're about to make a near call to TriageError, which
  6591                                  ;	lives in a different segment and group. Some linkers will
  6592                                  ;	generate a warning like "Possible fix-up overflow". We're
  6593                                  ;	ok, though, because we all fit in 64 KB and, at init time,
  6594                                  ;	we're still all together.
  6595                                  
  6596                                  	; 16/01/2023
  6597                                  	TRIAGEERROR equ TRANSTART+TriageError
  6598                                  	;(MSDOS 5.0 COMMAND.COM, 2320h+2D92h)
  6599                                  
  6600                                  	;call	50B2h
  6601 00001780 E8(954E)                	call	TRIAGEERROR	; TRIAGEERROR procedure is at offset 354Eh
  6602                                  				; in original MSDOS 3.3 COMMAND.COM
  6603                                  
  6604                                  			; TriageError procedure is at offset 50B2h
  6605                                  			; in original MSDOS 5.0 COMMAND.COM	
  6606 00001783 83F841                  	cmp	ax,65
  6607 00001786 7503                    	jne	short doprt
  6608                                  	;mov	dx,offset ResGroup:BadComaccMsg	; dx = ptr to msg
  6609 00001788 BA[FD1D]                	mov	dx,BADCOMACCMSG
  6610                                  doprt:
  6611 0000178B E802FB                  	call	RPrint
  6612                                  	;mov	si,offset ResGroup:ComSpect
  6613 0000178E BE[4F1C]                	mov     si,COMSPECT ; "\COMMAND.COM"
  6614                                  	;;mov	di,[ECOMLOC]
  6615                                  	;mov	di,[COMSPOFFSET] ; [ComspOffset]
  6616                                  	; 16/01/2023
  6617 00001791 BF0E00                  	mov	di,ECOMSPEC ; mov di,0Eh
  6618 00001794 B90E00                  	mov	cx,14
  6619 00001797 F3A4                    	rep	movsb				; get my default back
  6620                                  
  6621 00001799 EBDA                    	jmp	short SetComsrRet
  6622                                  
  6623                                  	; 16/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6624                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1927h (CODERES:0BE7h)
  6625                                  ArgsDone:
  6626                                  	; MSDOS 6.0
  6627 0000179B 8E06[3F03]              	mov	es,[EnvirSeg]			; get environment back
  6628                                  	;assume	es:nothing			;
  6629                                  
  6630                                  	; MSDOS 3.3 & MSDOS 6.0
  6631 0000179F 803E[A501]00                    cmp	byte [PermCom],0
  6632 000017A4 742E                            jz	short ComReturns
  6633                                  
  6634 000017A6 06                      	push	es				; Save environment pointer
  6635 000017A7 B450                    	mov	ah,50h
  6636                                  	;mov	ah,SET_CURRENT_PDB ; 50h
  6637 000017A9 8CDB                    	mov	bx,ds
  6638 000017AB 8EC3                    	mov	es,bx
  6639 000017AD CD21                    	int	21h				; current process is me
  6640 000017AF BF0A00                  	mov	di,PDB.EXIT ; mov di,0Ah	; Diddle the addresses in my header
  6641                                  	;;mov	ax,offset RESGROUP:LODCOM
  6642                                  	;mov	ax,LODCOM
  6643                                  	; 16/01/2023
  6644 000017B2 B8[7E00]                	mov	ax,LodCom_Trap
  6645 000017B5 AB                              stosw
  6646 000017B6 8CD8                            mov	ax,ds
  6647 000017B8 AB                              stosw
  6648                                  	;;mov	ax,offset RESGROUP:CONTC
  6649                                  	;mov	ax,CONTC
  6650                                  	; 16/01/2023
  6651 000017B9 B8[4A00]                	mov	ax,Ctrlc_Trap
  6652 000017BC AB                              stosw
  6653 000017BD 8CD8                            mov	ax,ds
  6654 000017BF AB                              stosw
  6655                                  	;;mov	ax,offset DATARES:CritErr_Trap  ; MSDOS 6.0
  6656                                  	;mov	ax,CRITERR
  6657                                  	; 16/01/2023
  6658 000017C0 B8[5500]                	mov	ax,CritErr_Trap
  6659 000017C3 AB                      	stosw
  6660 000017C4 8CD8                    	mov     ax,ds
  6661 000017C6 AB                      	stosw
  6662                                  	;;mov	word ptr ds:16h,ds
  6663                                  	;mov	word ptr ds:[Pdb_Parent_Pid],ds ; Parent is me forever
  6664 000017C7 8C1E1600                	mov	[PDB.PARENT_PID],ds
  6665                                          ;;mov	dx,offset RESGROUP:Int_2e
  6666                                  	;mov	dx,Int_2e
  6667                                          ; 16/01/2023
  6668 000017CB BA[3F00]                	mov	dx,Int2e_Trap
  6669 000017CE B82E25                  	mov	ax,252Eh
  6670                                  	;;mov	ax,(SET_INTERRUPT_VECTOR SHL 8) OR 2Eh
  6671                                  	;mov	ax,(SET_INTERRUPT_VECTOR*256) | 2Eh ; 252Eh
  6672 000017D1 CD21                    	int     21h	; DOS - SET INTERRUPT VECTOR
  6673                                  			; AL = interrupt number
  6674                                  			; DS:DX = new vector to be used for specified interrupt
  6675 000017D3 07                              pop	es				; Remember environment
  6676                                  	
  6677                                  ComReturns:
  6678                                          ;mov	ax,word ptr ds:Pdb_Parent_Pid
  6679 000017D4 A11600                  	mov	ax,[PDB.PARENT_PID] ; mov ax,ds:16h
  6680                                  	; 16/01/2023
  6681 000017D7 A3[4101]                	mov	[Parent],ax			; Save parent
  6682                                          ;mov	word ptr ds:Pdb_Parent_Pid,ds 	; Parent is me
  6683 000017DA 8C1E1600                        mov	[PDB.PARENT_PID],ds ; mov word ptr ds:16h,ds
  6684                                          ;mov	ax,word ptr ds:PDB_Jfn_Table
  6685 000017DE A11800                          mov	ax,[PDB.JFN_TABLE] ; mov ax,ds:18h
  6686 000017E1 A3[A201]                        mov	[Io_Save],ax		; Get the default stdin and out
  6687 000017E4 8C1E[4303]                      mov	[Com_Ptr+2],ds		; Set all these to resident
  6688 000017E8 8C1E[4703]                      mov	[Com_Fcb1+2],ds
  6689 000017EC 8C1E[4B03]              	mov	[Com_Fcb2+2],ds
  6690                                          ;mov	di,offset ResGroup:ComSpec
  6691 000017F0 BF[4E01]                        mov	di,ComSpec
  6692                                  
  6693                                  	;;mov	si,[ECOMLOC]
  6694                                  	; 16/01/2023
  6695                                  	;mov	si,[ComspOffset]
  6696 000017F3 BE0E00                  	mov	si,ECOMSPEC ; mov si,0Eh
  6697 000017F6 803E[7B1C]00            	cmp	byte [AllocedEnv],0 ; MSDOS 6.0
  6698                                          ;cmp	byte [CHUCKENV],0 ; MSDOS 3.3
  6699                                  	
  6700 000017FB 8CD8                    	mov	ax,ds				; Xchg es,ds
  6701 000017FD 06                      	push	es
  6702 000017FE 1F                      	pop	ds
  6703 000017FF 8EC0                    	mov	es,ax
  6704                                  
  6705                                  	;jne	short CopyComsp ; MSDOS 6.0
  6706                                  	; 16/01/2023	
  6707 00001801 7417                    	je	short CopyComsp ; MSDOS 5.0
  6708                                  	;je	short COPYCOMSP	; MSDOS 3.3	; All set up for copy
  6709                                  
  6710 00001803 0E                              push	cs
  6711 00001804 1F                              pop	ds
  6712                                  
  6713                                          ;mov	si,offset ResGroup:ComspString
  6714 00001805 BE[821C]                	mov	si,ComspString ; "COMSPEC=\COMMAND.COM"
  6715 00001808 06                      	push	es
  6716 00001809 57                      	push	di
  6717 0000180A E8DE01                  	call	IfindE
  6718 0000180D 89FE                    	mov	si,di
  6719 0000180F 06                      	push	es
  6720 00001810 1F                      	pop	ds
  6721 00001811 5F                      	pop	di
  6722 00001812 07                      	pop	es
  6723 00001813 7305                            jnc	short CopyComsp
  6724                                  
  6725                                  	; MSDOS 6.0
  6726                                  ComSpecNofnd:
  6727                                  	;mov	si,offset ResGroup:ComspString
  6728                                  	;add	si,ComspStrLen
  6729                                  	;push	cs
  6730                                  	;pop	ds
  6731                                  
  6732                                  	; 21/01/2023
  6733                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:19A1h
  6734                                  	;mov	si,0Eh
  6735 00001815 BE0E00                  	mov	si,ECOMSPEC
  6736 00001818 0E                      	push	cs
  6737 00001819 1F                      	pop	ds	
  6738                                  
  6739                                  	; 21/01/2023
  6740                                  ;COMSPECNOFND:
  6741                                  	; MSDOS 3.3
  6742                                          ;;mov	si,[es:ECOMLOC]
  6743                                          ;mov	si,[es:COMSPOFFSET]
  6744                                  	;;add	si,offset RESGROUP:PATHSTRING
  6745                                          ;add	si,PATHSTRING ; "PATH="
  6746                                  	;push	cs
  6747                                  	;pop	ds
  6748                                  
  6749                                  CopyComsp:
  6750                                  	; 21/01/2023
  6751                                  ;COPYCOMSP:
  6752                                  	; MSDOS 3.3 & MSDOS 6.0
  6753                                  	;;mov	es:PutBackComSpec.SubstPtr,di
  6754                                  	;mov	[es:PUTBACKSUBSTPTR],di		; Save ptr to beginning of comspec path
  6755 0000181A 26893E[2D01]            	mov	[es:PutBackComSpec],di
  6756 0000181F 807C013A                	cmp	byte [si+1],':'			; Is there a drive specifier in comspec
  6757 00001823 7506                    	jne	short CopyComspLoop		; If not, do not skip over first 2 bytes
  6758                                  	;;add	es:PutBackComSpec.SubstPtr,2
  6759                                  	;add	word [es:PUTBACKSUBSTPTR],2
  6760 00001825 268306[2D01]02          	add	word [es:PutBackComSpec],2
  6761                                  CopyComspLoop:
  6762 0000182B AC                      	lodsb
  6763 0000182C AA                      	stosb
  6764 0000182D 08C0                    	or	al,al
  6765 0000182F 75FA                    	jnz	short CopyComspLoop
  6766                                  
  6767 00001831 26893E[8E01]            	mov	[es:ComSpec_End],di		; Save ptr to end of comspec path
  6768 00001836 26FF0E[8E01]            	dec	word [es:ComSpec_End]
  6769 0000183B 268A26[9701]            	mov	ah,[es:ComDrv]
  6770 00001840 80C440                  	add	ah,'A'-1 ; 40h
  6771 00001843 268826[3201]            	mov	[es:PutBackDrv],ah		; save drive letter
  6772                                  
  6773                                  	; -------------------------------
  6774                                  
  6775                                  ; 21/01/2023 - Retro DOS v4.0 COMMAND.COM
  6776                                  %if 0
  6777                                  
  6778                                  	; MSDOS 3.3
  6779                                  	push	cs
  6780                                          pop	ds
  6781                                          ;mov	bx,offset RESGROUP:DATARESEND + 15
  6782                                  	mov	bx,DATARESEND+15
  6783                                          mov	cl,4
  6784                                          shr	bx,cl
  6785                                          MOV     AH,SETBLOCK ; 4Ah
  6786                                          int	21h			; Shrink me to the resident only
  6787                                  
  6788                                  ENVMAXIMUM:   ; offset 11EEh for MSDOS 3.3 COMMAND.COM     
  6789                                  
  6790                                  	mov	byte [TRNMVFLG], 1
  6791                                  	push	es ; *
  6792                                  	mov	si,TRANSTART
  6793                                  	mov	di,0
  6794                                  	mov	es,[TrnSeg]
  6795                                  	;mov	cx,4D5Ch
  6796                                  	mov	cx,TRANSPACEEND ; 4D5Ch for MSDOS 3.3 COMMAND.COM
  6797                                  	push	cx
  6798                                  	mov	ax,cx
  6799                                  	add	ax,si
  6800                                  	mov	cl,4
  6801                                  	shr	ax,cl
  6802                                  	inc	ax
  6803                                  	mov	cx,ds
  6804                                  	add	ax,cx
  6805                                  	cmp	ax,[TrnSeg]
  6806                                  	pop	cx
  6807                                  	jb	short MOV_DOWN
  6808                                  
  6809                                  	call	LOADCOM
  6810                                  	jmp	short ICHKSUM
  6811                                  
  6812                                  MOV_DOWN:
  6813                                  	add     si,cx
  6814                                  	dec     si
  6815                                  	add     di,cx
  6816                                  	dec     di
  6817                                  	std
  6818                                  	rep	movsb
  6819                                  	cld
  6820                                  
  6821                                  ICHKSUM:
  6822                                  	; 24/09/2018
  6823                                  ;
  6824                                  ; Compute checksum right now before we can get corrupted and save it
  6825                                  ;
  6826                                  	; MSDOS 6.0
  6827                                  	;mov	si,offset RESGROUP:TranStart
  6828                                  	;add	si,100h
  6829                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6830                                  	;
  6831                                  	;cld
  6832                                  	;shr	cx,1
  6833                                  	;xor	dx,dx
  6834                                  ;Ichksum:
  6835                                  	;lodsw
  6836                                  	;add	dx,ax
  6837                                  	;adc	dx,0
  6838                                  	;loop	Ichksum
  6839                                  	;
  6840                                          ;mov	Sum,dx			; store checksum
  6841                                  
  6842                                  	; MSDOS 3.3
  6843                                  	pop     es ; *
  6844                                  	call    CHKSUM
  6845                                  	mov     [SUM],dx
  6846                                  
  6847                                  	; MSDOS 3.3 & MSDOS 6.0
  6848                                          cmp     byte [PRDATTM],0	;
  6849                                          jnz     short NOBATCHSEG	; don't do autoexec or date time
  6850                                  ;
  6851                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6852                                  ;
  6853                                  	; BATCHSEGMENT.SIZE = 32 for MSDOS 3.3 (= 33 for MSDOS 6.0)
  6854                                  	;mov	bx,3
  6855                                  	mov	bx,(BATCHSEGMENT.SIZE+15+1+0Fh)/16 ; (32+15+1+0Fh)/16 = 3
  6856                                          mov     ah,ALLOC ; 48h		;
  6857                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6858                                  			; BX = number of 16-byte paragraphs desired
  6859                                  	jc      short NOBATCHSEG	; didn't allocate - pretend no batch
  6860                                          mov     [BATCH],ax		; save batch segment
  6861                                  
  6862                                  NOBATCHSEG:
  6863                                  
  6864                                  %endif
  6865                                  	; -------------------------------
  6866                                  
  6867                                  	; 21/01/2023 - Retrro DOS v4.0 (& v4.1) COMMAND.COM
  6868                                  	
  6869                                  	; MSDOS 6.0
  6870 00001848 E81702                  	call	setup_for_messages		; set up parse and extended error messages
  6871                                  
  6872                                  ; The routine below sets up the exact resident size of COMMAND. If this is not
  6873                                  ; the first COMMAND, then the resident code is not duplicated and the resident
  6874                                  ; size is just the data. If we are the first COMMAND, it checks if we are to
  6875                                  ; be loaded into HIMEM. If not, then the resident size includes the code and
  6876                                  ; the data otherwise it is just the data.
  6877                                   
  6878 0000184B E8AE02                  	call	Setup_res_end			; put resident size in ResSize
  6879                                  
  6880 0000184E 0E                      	push	cs
  6881 0000184F 1F                      	pop	ds
  6882                                  	;assume	ds:RESGROUP
  6883                                  
  6884                                  ;Public EnvMaximum
  6885                                  ; 14/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  6886                                  EnvMaximum:	; MSDOS 5.0 COMMAND.COM - RESGROUP:19DCh
  6887                                  
  6888                                  	; 21/01/2023
  6889                                  	; MSDOS 6.0
  6890                                  	;;mov	si,offset RESGROUP:TranStart
  6891                                  	;;mov	si,2320h	; MSDOS 5.0 COMMAND.COM
  6892                                  	;mov	si,TRANSTART
  6893                                  	;add	si,100h
  6894                                  	; 23/04/2023
  6895 00001850 BE2023                  	mov	si,TRANSTART+100h
  6896                                  
  6897                                  	;mov	cx,offset TRANGROUP:TranDataEnd - 100H
  6898                                  	;mov	cx,87C2h	; MSDOS 5.0 COMMAND.COM
  6899 00001853 B9[E784]                	mov	cx,TRANDATAEND-100h
  6900                                  
  6901 00001856 FC                      	cld
  6902 00001857 D1E9                    	shr	cx,1
  6903 00001859 31D2                    	xor	dx,dx
  6904                                  Ichksum:
  6905 0000185B AD                      	lodsw
  6906 0000185C 01C2                    	add	dx,ax
  6907 0000185E 83D200                  	adc	dx,0
  6908 00001861 E2F8                    	loop	Ichksum
  6909                                  
  6910 00001863 8916[9A01]                      mov	[Sum],dx			; store checksum
  6911                                  
  6912 00001867 803E[6E1C]00                    cmp     byte [PRDATTM],0
  6913 0000186C 750C                            jne	short NoBatchSeg		; don't do autoexec or date time
  6914                                  	
  6915                                  ; Allocate batch segment for d:/autoexec.bat + no arguments
  6916                                  
  6917                                  	;mov	bx,((SIZE BatchSegment) + 15 + 1 + 0fh)/16
  6918                                  	; 21/01/2023
  6919                                  	;mov	bx,4
  6920 0000186E BB0400                          mov	bx,((BATCHSEGMENT.SIZE)+16+0Fh)/16 ; (33+16+15)/16
  6921 00001871 B448                    	mov	ah,48h
  6922                                  	;mov	ah,ALLOC                        ;
  6923 00001873 CD21                            int	21h                             ;
  6924 00001875 7203                    	jc	short NoBatchSeg		; didn't allocate - pretend no batch
  6925 00001877 A3[4C01]                        mov	[Batch],ax			; save batch segment
  6926                                  
  6927                                  NoBatchSeg:
  6928                                  
  6929                                  ; 21/01/2023
  6930                                  %if 0
  6931                                  	; MSDOS 3.3
  6932                                  	mov     bx,0FFFFh ; 65535
  6933                                  	mov     ah,ALLOC ; 48h
  6934                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6935                                  			; BX = number of 16-byte paragraphs desired
  6936                                  	sub     bx,[TRNSIZE]
  6937                                  	sub     bx,128
  6938                                  	mov     [ENVMAX],bx
  6939                                  
  6940                                  	cmp     bx,4096
  6941                                  	jb      short ALLOCENVIRSEG
  6942                                  	mov     bx,4096-1		; max. allowed environment size
  6943                                  	mov     [ENVMAX],bx
  6944                                  
  6945                                  ALLOCENVIRSEG:
  6946                                  	mov     ah,ALLOC ; 48h
  6947                                  	int     21h	; DOS - 2+ - ALLOCATE MEMORY
  6948                                  			; BX = number of 16-byte paragraphs desired
  6949                                  	mov     bx,[ENVIRSEG]		; get old environment segment
  6950                                  	mov     [OLDENV],bx		; save it	
  6951                                  	mov     word [USEDENV],0	; initialize environment size counter
  6952                                  	mov     ds,bx
  6953                                  	mov     [ss:ENVIRSEG], ax	; save new environment segment
  6954                                  	mov     es,ax
  6955                                  	xor     si,si
  6956                                  	mov     di,si
  6957                                  	mov     bx,[ss:ENVMAX]
  6958                                  	shl     bx,1
  6959                                  	shl     bx,1
  6960                                  	shl     bx,1
  6961                                  	shl     bx,1
  6962                                  	mov     [ss:ENVMAX],bx		; convert envmax to bytes
  6963                                  	dec     bx			; dec by one to leave room for double 0
  6964                                  	xor     dx,dx			; use dx to indicate that there was
  6965                                  					; no environment size error.
  6966                                  
  6967                                  NXSTR:
  6968                                  	call    GETSTRLEN		; get the size of the current env string
  6969                                  
  6970                                  	push    ds
  6971                                  	push    cs
  6972                                  	pop     ds
  6973                                  	add     [USEDENV],cx		; add the string length to env size
  6974                                  	pop     ds
  6975                                  	cmp     cx,1			; end of environment was encountered.
  6976                                  	je      short ENVEXIT
  6977                                  	sub     bx,cx
  6978                                  	jnb     short OKCPYSTR		; can't fit in all of enviroment.
  6979                                  	inc     dx			; out of env space msg must be displayed
  6980                                  	jmp     short ENVEXIT
  6981                                  
  6982                                  	;nop
  6983                                  
  6984                                  OKCPYSTR:
  6985                                  	jmp     short NXSTR
  6986                                  
  6987                                  ENVEXIT: 
  6988                                  	push    cs
  6989                                  	pop     ds
  6990                                  	or      dx, dx			; dx will be non-zero if error
  6991                                  	jz      short ENVNOERR
  6992                                  	mov     dx,OUTENVMSG		; dx = ptr to msg
  6993                                  	call    RPRINT
  6994                                  
  6995                                  %endif
  6996                                  
  6997                                  	; 21/01/2023
  6998                                  	; MSDOS 6.0 (& MSDOS 5.0)
  6999 0000187A 8B1E[3F03]              	mov	bx,[EnvirSeg]			; get old environment segment
  7000 0000187E 891E[9B1C]              	mov	[OldEnv],bx			; save it
  7001 00001882 C706[9D1C]0000          	mov	word [UsedEnv],0		; initialize env size counter
  7002 00001888 8EDB                    	mov	ds,bx
  7003                                  	;assume	ds:nothing
  7004                                  	
  7005 0000188A 31F6                    	xor	si,si
  7006 0000188C 89F7                    	mov	di,si
  7007                                  
  7008                                  ; This is the maximum allowed size for the environment
  7009                                  
  7010                                  	; 21/01/2023
  7011                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1A1Eh
  7012                                  	;mov	bx,4096 - 1 ; 0FFFh		; max. allowed env. size
  7013                                  	;;mov	[ss:EnvMax],bx
  7014                                  	;shl	bx,1
  7015                                  	;shl	bx,1
  7016                                  	;shl	bx,1
  7017                                  	;shl	bx,1
  7018 0000188E BBF0FF                  	mov	bx,(4096-1)<<4 ; mov bx,0FFF0h
  7019 00001891 36891E[991C]            	mov	[ss:EnvMax], bx			; convert envmax to bytes
  7020 00001896 4B                      	dec	bx				; dec by one to leave room for double 0
  7021 00001897 31D2                    	xor	dx,dx				; use dx to indicate that there was
  7022                                  						; no environment size error.
  7023                                  ;public NxtStr
  7024                                  NxtStr:
  7025 00001899 E82501                  	call	GetStrLen			; get the size of the current env string
  7026                                  
  7027                                  ;Bugbug: Can use ss here to address UsedEnv
  7028                                  
  7029 0000189C 1E                      	push	ds                              ; get addressability to environment
  7030 0000189D 0E                              push	cs                              ;                       counter
  7031 0000189E 1F                              pop	ds                              ;
  7032                                  	;assume	ds:ResGroup
  7033 0000189F 010E[9D1C]                      add	[UsedEnv],cx			; add the string length to env size
  7034 000018A3 1F                      	pop	ds                              ;
  7035                                  	;assume	ds:nothing
  7036                                  	
  7037 000018A4 83F901                  	cmp	cx,1				; end of environment was encountered.
  7038 000018A7 7405                    	je	short EnvExit
  7039 000018A9 29CB                    	sub	bx,cx
  7040                                  	;jae	short OkCpyStr			; can't fit in all of enviroment.
  7041                                  	; 21/01/2023
  7042 000018AB 73EC                    	jae	short NxtStr
  7043 000018AD 42                      	inc	dx				; out of env space msg must be displayed
  7044                                  	;jmp	short EnvExit
  7045                                  
  7046                                  ;OkCpyStr:
  7047                                  	;jmp	short NxtStr
  7048                                  
  7049                                  EnvExit:
  7050 000018AE 0E                      	push	cs
  7051 000018AF 1F                      	pop	ds
  7052                                  	;assume	ds:ResGroup
  7053 000018B0 09D2                    	or	dx,dx				; dx will be non-zero if error
  7054 000018B2 7406                    	jz	short EnvNoErr
  7055                                  	;mov	dx,offset ResGroup:OutEnvMsg	; dx = ptr to msg
  7056 000018B4 BA[5A1D]                	mov	dx,OUTENVMSG
  7057 000018B7 E8D6F9                  	call 	RPrint
  7058                                  EnvNoErr:
  7059 000018BA A1[971C]                	mov	ax,[EnvSiz]			; env size previously set
  7060 000018BD B104                    	mov	cl,4
  7061 000018BF D3E0                    	shl	ax,cl				; get size in bytes
  7062 000018C1 3B06[9D1C]              	cmp	ax,[UsedEnv]			; is it a new env?
  7063 000018C5 7706                    	ja	short st_envsize		; yes, store the size
  7064 000018C7 A1[9D1C]                	mov	ax,[UsedEnv]
  7065 000018CA 83C00F                  	add	ax,15				; round up
  7066                                  st_envsize:	
  7067 000018CD D3E8                    	shr	ax,cl
  7068 000018CF A3[971C]                	mov	[EnvSiz],ax			; store env size needed(paras)
  7069                                  
  7070                                  ;if MSVER
  7071                                  	;cmp	SingleCom,0
  7072                                  	;jnz	nophead 			; don't print header if SingleCom
  7073                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7074                                  	;call	RPrint
  7075                                  ;nophead:
  7076                                  ;endif
  7077                                  
  7078                                  ; 21/01/2023
  7079                                  %if 0
  7080                                  	; MSDOS 3.3
  7081                                  ENVNOERR:
  7082                                  	mov     cx,[ENVMAX]
  7083                                  	sub     cx,bx			; current environment size in bytes
  7084                                  	add     cx,16			; add memory arena to the size
  7085                                  	shr     cx,1
  7086                                  	shr     cx,1
  7087                                  	shr     cx,1
  7088                                  	shr     cx,1			; convert current env size to paragraphs
  7089                                  	cmp     cx,[ENVSIZ]		; compare with env size previously set
  7090                                  	;jb	short SET_ENVSIZE
  7091                                  	jna	short SET_ENVSIZE  ; 24/09/2018 - Retro DOS v3.0
  7092                                  	mov     [ENVSIZ],cx		; store env size needed (paragraphs)
  7093                                  
  7094                                  SET_ENVSIZE:
  7095                                  	mov     bx,[ENVSIZ]
  7096                                  	mov     ax,es
  7097                                  	add     ax,bx			; get end segment of environemnt
  7098                                  	cmp     ax,[INITEND]		; compare with init code end segment
  7099                                  	ja      short NOPHEAD
  7100                                  					; free unused paragraghs		
  7101                                  	mov     ax,es
  7102                                  	mov     bx,[INITEND]
  7103                                  	sub     bx,ax
  7104                                  	;mov	byte [RESETENV],1  ; 24/09/2018
  7105                                  	mov	word [RESETENV],1	; environment segment reset sign
  7106                                  
  7107                                  NOPHEAD:
  7108                                  	; MSDOS 3.3
  7109                                  	mov     ah,SETBLOCK ; 4Ah
  7110                                  	int     21h	; DOS - 2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
  7111                                  			; ES = segment address of block to change
  7112                                  			; BX = new size in paragraphs
  7113                                  %endif
  7114                                  	; 21/01/2023
  7115                                  
  7116                                  	; MSDOS 3.3 & 6.0
  7117 000018D2 833E[4C01]00            	cmp     word [Batch],0		; did we set up a batch segment?
  7118 000018D7 7503                    	jnz     short DoDate		; yes - go initialize it
  7119 000018D9 E99500                  	jmp     NoDttm			; don't do autoexec or date time
  7120                                  
  7121                                  DoDate:
  7122                                  
  7123                                  ; allocate batch segment for d:/autoexec.bat + no arguments
  7124                                  
  7125 000018DC A1[4C01]                	mov	ax,[Batch]		; get batch segment
  7126 000018DF C606[A001]03            	mov	byte [EchoFlag],3	; set batch echo
  7127 000018E4 C706[AF01]0100          	mov	word [Nest],1		; set nest flag to 1 batch
  7128 000018EA 8EC0                    	mov	es,ax
  7129                                  
  7130                                  ; initialize the segment
  7131                                  
  7132 000018EC 31FF                    	xor	di,di
  7133                                  	;;mov	al,0
  7134                                  	;mov	al,BATCHTYPE ; 0
  7135                                  	; 06/06/2023
  7136 000018EE 31C0                    	xor	ax,ax
  7137 000018F0 AA                      	stosb
  7138                                  	;mov	al,1			; initialize echo for batch exit
  7139 000018F1 FEC0                    	inc	al
  7140 000018F3 AA                      	stosb
  7141                                  
  7142                                  ; Hosebag! This guy does not use the struct fields to init the BatchSegment
  7143                                  
  7144                                  	;xor	ax,ax			; initialize to zero
  7145                                  	; 06/06/2023
  7146 000018F4 FEC8                    	dec	al ; ax = 0	
  7147                                  
  7148                                  	; 21/01/2023
  7149 000018F6 AA                      	stosb	; MSDOS 6.0 		; clear out BatchEOF
  7150                                  
  7151 000018F7 AB                      	stosw				; batch segment of last job - batlast
  7152 000018F8 AB                      	stosw				; segment for FOR
  7153 000018F9 AA                      	stosb				; FOR flag
  7154 000018FA AB                      	stosw				; position in file - batseek
  7155 000018FB AB                      	stosw
  7156                                  
  7157                                  ; clean out the parameters
  7158                                  
  7159                                  	;mov	ax,-1			; initialize to no parameters
  7160                                  	; 06/06/2023
  7161 000018FC 48                      	dec	ax ; ax = -1
  7162                                  
  7163 000018FD B90A00                  	mov	cx,10
  7164 00001900 F3AB                    	rep	stosw
  7165                                  
  7166                                  ; decide whether we should grab the default drive
  7167                                  
  7168 00001902 803E[5D1C]00            	cmp	byte [AUTOBAT],0 ; ":\AUTOEXEC.BAT"
  7169 00001907 7509                    	jne	short NoAutSet
  7170 00001909 B419                    	mov	ah,19h	; 21/01/2023
  7171                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  7172 0000190B CD21                    	int	21h
  7173                                  	;;add	al,'A'
  7174                                  	;add	al,[letter_A] ; Ucasea
  7175                                  	;add	al,[ucasea] ; 21/01/2023
  7176                                  	; 21/01/2023
  7177 0000190D 0441                    	add	al,'A'
  7178 0000190F A2[5D1C]                	mov	[AUTOBAT],al
  7179                                  	; 21/01/2023
  7180                                  	;mov	[KAUTOBAT],al
  7181                                  NoAutSet:
  7182                                  
  7183                                  ; copy in the batch file name (including nul)
  7184                                  
  7185                                  	;mov	si,offset ResGroup:AutoBat
  7186 00001912 BE[5D1C]                	mov	si,AUTOBAT
  7187 00001915 B90800                  	mov	cx,8
  7188 00001918 F3A5                    	rep	movsw
  7189                                  	; 23/04/2023
  7190 0000191A A4                      	movsb	; MSDOS 6.0		; move in carriage return to terminate string
  7191                                  
  7192                                  	;mov	dx,offset ResGroup:AutoBat
  7193 0000191B BA[5D1C]                	mov     dx,AUTOBAT ; ":\AUTOEXEC.BAT"
  7194                                  
  7195                                  	;;mov	ax,OPEN shl 8
  7196 0000191E B8003D                  	mov	ax,3D00h ; 21/01/2023
  7197                                  	;mov	ax,OPEN*256 ; 3D00h  ; open for read
  7198 00001921 CD21                    	int	21h			; see if autoexec.bat exists
  7199 00001923 7208                    	jc	short noabat
  7200 00001925 89C3                    	mov	bx,ax
  7201 00001927 B43E                    	mov	ah,3Eh ; 21/01/2023
  7202                                  	;mov	ah,CLOSE  ; 3Eh
  7203 00001929 CD21                    	int	21h
  7204 0000192B EB51                    	jmp	short Drv0		; go process autoexec
  7205                                  
  7206                                  noabat:
  7207 0000192D 50                      	push	ax
  7208 0000192E E89900                  	call	Setup_Seg
  7209 00001931 A3[791C]                	mov	[triage_add+2],ax
  7210 00001934 58                      	pop	ax
  7211 00001935 FF1E[771C]              	call	far [triage_add]	; get extended error
  7212 00001939 83F841                  	cmp	ax,65			; network access denied?
  7213                                  	;jne	short OPENERR		; no - go deallocate batch
  7214                                  	; 21/01/2023
  7215                                  	;je	short AccDenErr
  7216 0000193C 7506                    	jne	short OpenErr 
  7217                                  
  7218                                  	; 21/01/2023
  7219                                  ;_ACCDENERROR:					; yes - put out message
  7220                                  ;	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7221                                  ;	mov	dx,ACCDENERR
  7222                                  ;	call	RPRINT
  7223                                  
  7224                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7225                                  
  7226                                  	; MSDOS 6.0 (& MSDOS 5.0)
  7227                                  
  7228                                  ; 21/01/2023
  7229                                  %if 0
  7230                                  
  7231                                  ; If AUTOEXEC.BAT is not found, then check for KAUTOEXE.BAT. Changed
  7232                                  ; by Ellen to check only when in Korea. The country information
  7233                                  ; returned will overlay the old parse data area, but we don't care
  7234                                  ; since we won't need the parse information or country information.
  7235                                  ; We only care about the country code returned in BX.
  7236                                  
  7237                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1AE7h
  7238                                  
  7239                                  	;mov	dx,offset ResGroup:Internat_Info ; set up internat vars
  7240                                  	mov	dx,INTERNAT_INFO
  7241                                  	mov	ax,3800h
  7242                                  	;mov	ax,INTERNATIONAL<<8
  7243                                  	;;mov	ax,INTERNATIONAL shl 8		; get country dependent info
  7244                                  	int	21h				;
  7245                                  	jc	short NoKabat 			; error - don't bother with it
  7246                                  	cmp	bx,52h
  7247                                  	;cmp	bx,KOREA_COUNTRY_CODE		; are we speaking korean?
  7248                                  	jnz	short OpenErr 			; no, don't check for kautoexe
  7249                                  
  7250                                  	;mov	di,BatFile			; 3/3/kk
  7251                                  	mov	di,20h
  7252                                  	;mov	si,offset ResGroup:KautoBat	; another trial to do	3/3/kk
  7253                                  	mov	si,KAUTOBAT
  7254                                  	mov	cx,8				; auto execution for the 3/3/kk
  7255                                  	rep	movsw				; non-english country	3/3/kk
  7256                                  	movsb					; move in carraige return to terminate string
  7257                                  	;mov	dx,offset ResGroup:KautoBat	; 3/3/kk
  7258                                  	mov	dx,KAUTOBAT
  7259                                  	mov	ax,3D00h
  7260                                  	;mov	ax,OPEN<<8
  7261                                  	;;mov	ax,OPEN shl 8			; 3/3/kk
  7262                                  	int	21h				; see if kautoexe.bat exists  3/3/kk
  7263                                  	jc	short NoKabat 			; 3/3/kk
  7264                                  	mov	bx,ax				; 3/3/kk
  7265                                  	mov	ah,3Eh
  7266                                  	;mov	ah,CLOSE			; 3/3/kk
  7267                                  	int	21h				; 3/3/kk
  7268                                  	jmp	short Drv0			; 3/3/kk
  7269                                  
  7270                                  NoKabat:					; 3/3/kk
  7271                                  	call	far [Triage_Add]		; get extended error
  7272                                  	cmp	ax,65				; network access denied?
  7273                                  	jnz	short OpenErr 			; no - go deallocate batch
  7274                                  
  7275                                  %endif
  7276                                  	; 21/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7277                                  
  7278                                  AccDenErr:					; yes - put out message
  7279                                  	;mov	dx,offset ResGroup:AccDen	; dx = ptr to msg
  7280 0000193E BA[D305]                	mov	dx,ACCDEN
  7281 00001941 E84CF9                  	call	RPrint
  7282                                  OpenErr:
  7283                                  ;OPENERR:
  7284 00001944 8E06[4C01]              	mov	es,[Batch]		; not found--turn off batch job
  7285 00001948 B449                    	mov	ah,49h
  7286                                  	;mov	ah,DEALLOC ; 49h
  7287 0000194A CD21                    	int	21h
  7288 0000194C C706[4C01]0000          	mov	word [Batch],0		; after dealloc in case of ^c
  7289 00001952 C606[A001]01            	mov	byte [EchoFlag],1
  7290 00001957 C706[AF01]0000          	mov	word [Nest],0		; indicate no batch in progress
  7291                                  
  7292                                  ;DoDttm:
  7293                                  	;mov	ax,offset TranGroup:Datinit
  7294 0000195D B8[5C2E]                	mov	ax,DATINIT
  7295 00001960 A3[6F1C]                	mov	[INITADD],ax
  7296                                  
  7297                                  	; MSDOS 6.0
  7298                                  ;;M004;;mov	ax,TrnSeg	
  7299                                  ;
  7300                                  ; M004; We cant use TrnSeg now because it is not initialized. We now that
  7301                                  ; M004; the transient starts on a para boundary at the label TranStart.
  7302                                  ; M004; We use TranStart to get the start of the transient segment.
  7303                                  
  7304                                  	; 21/01/2023
  7305                                  	;mov	ax,offset RESGROUP:TranStart	; M004
  7306                                  	;;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7307                                  	; 06/06/2023
  7308                                  	;mov	ax,TRANSTART
  7309                                  	;mov	cl,4				; M004
  7310                                  	;shr	ax,cl				; get relative seg ; M004
  7311                                  	; 06/06/2023
  7312 00001963 B82202                  	mov	ax,TRANSTART>>4	
  7313                                  
  7314 00001966 8CC9                    	mov	cx,cs
  7315 00001968 01C8                    	add	ax,cx				; ax = transient seg ; M004
  7316                                  
  7317                                  	; 21/01/2023
  7318                                  	; MSDOS 3.3
  7319                                  	; 25/09/2018
  7320                                  	;mov     ax,[TrnSeg]	; COMMAND.COM (MSDOS 3.3) - Offset 1387h
  7321                                  
  7322                                  	; MSDOS 3.3 & MSDOS 6.0
  7323 0000196A A3[711C]                	mov	[INITADD+2],ax
  7324                                  	;call	dword ptr InitAdd
  7325 0000196D FF1E[6F1C]              	call	far [INITADD]
  7326                                  
  7327                                  NoDttm:
  7328                                  	; MSDOS 6.0
  7329                                  	; 21/01/2023
  7330                                  ;Copyright:
  7331                                  	;public	Copyright
  7332                                  ;	Bugbug:	remove Copyright label.
  7333                                  
  7334                                  ;if IBMVER
  7335 00001971 833E[A601]00            	cmp	word [SingleCom],0
  7336 00001976 7506                    	jnz	short Drv0			; don't print header if SingleCom
  7337                                  	;mov	dx,offset ResGroup:CopyrightMsg	; dx = ptr to msg
  7338 00001978 BA[751D]                	mov	dx,COPYRIGHTMSG
  7339 0000197B E812F9                  	call	RPrint
  7340                                  ;endif
  7341                                  	; 21/01/2023
  7342                                  	; MSDOS 3.3
  7343                                  	;cmp	word [SingleCom],0	; don't print header if SingleCom
  7344                                  	;jnz	short DRV0
  7345                                  	;mov	dx,HEADERPTR	; dx = ptr to msg
  7346                                  	;call	RPRINT
  7347                                  ;DRV0:
  7348                                  	; MSDOS 3.3
  7349                                  	;mov	byte [INITFLAG],0
  7350                                  	;jmp	ENDINIT
  7351                                  
  7352                                  	; 21/01/2023
  7353                                  	; MSDOS 6.0
  7354                                  Drv0:						; Reset APPEND state
  7355 0000197E 1E                      	push	ds				; save data segment
  7356 0000197F 0E                      	push	cs				; Get local segment into DS
  7357 00001980 1F                      	pop	ds				;
  7358 00001981 B807B7                  	mov	ax,0B707h ; 21/01/2023
  7359                                  	;mov	ax,APPENDSETSTATE		; Set the state of Append
  7360 00001984 8B1E[C301]              	mov	bx,[Append_State] 		;  back to the original state
  7361 00001988 CD2F                    	int	2Fh				;
  7362 0000198A 1F                      	pop	ds				; get data segment back
  7363                                  
  7364                                  ;Check FirstCom set previously to see if this is the first instance of
  7365                                  ;command.com. If not, we do not move command.com. Instead, we copy over the
  7366                                  ;jump table from the previous stub to the current stub.
  7367                                  
  7368 0000198B 803E[EA20]01            	cmp	byte [FirstCom],1		; first command.com?
  7369 00001990 7429                    	jz	short move_code			; yes, move it
  7370                                  
  7371 00001992 06                      	push	es
  7372 00001993 1E                      	push	ds
  7373                                  
  7374 00001994 1E                      	push	ds
  7375 00001995 07                      	pop	es
  7376                                  	;mov	di,offset DATARES:Int2f_Entry
  7377 00001996 BF[0400]                	mov	di,Int2f_Entry	
  7378                                  
  7379 00001999 268E1E[E820]            	mov	ds,[es:ResJmpTable+2]		; get segment address
  7380 0000199E 268B36[E620]            	mov	si,[es:ResJmpTable]		; get offset address
  7381                                  
  7382                                  	;mov	cx,11
  7383                                  	;;mov 	cx,NUM_RELOC_ENTRIES 		; number of dword ptrs
  7384                                  	;shl	cx,1
  7385                                  	;shl	cx,1				; size of table in bytes
  7386                                  	; 21/01/2023
  7387 000019A3 B92C00                  	mov	cx,44				; size of table in bytes
  7388                                  
  7389 000019A6 FC                      	cld
  7390 000019A7 F3A4                    	rep	movsb				; copy the jump table
  7391                                  
  7392                                  ;Check if the resident code is in HMA. We assume that it is in HMA if its 
  7393                                  ;code segment > 0f000h. If in HMA, we set the ComInHMA flag
  7394                                  
  7395 000019A9 26817DFE00F0            	cmp	word [es:di-2],0F000h		; is resident code in HMA?
  7396 000019AF 7206                    	jb	short res_low			; no, dont set flag
  7397                                  
  7398 000019B1 26C606[3400]01          	mov	byte [es:ComInHMA],1		; indicate code in HMA
  7399                                  res_low:
  7400 000019B7 1F                      	pop	ds
  7401 000019B8 07                      	pop	es
  7402 000019B9 EB03                    	jmp	short finish_init
  7403                                  
  7404                                  ;Now, we can move the resident code to its final location, either to HIMEM
  7405                                  ;or to overlay the messages in the data segment if the user has not used the
  7406                                  ;/msg switch.
  7407                                  
  7408                                  move_code:
  7409 000019BB E88701                  	call	Move_res_code			; move the code
  7410                                  
  7411                                  finish_init:
  7412                                  	;jmp	RESGROUP:EndInit 		; finish initializing
  7413 000019BE E959E8                  	jmp	EndInit
  7414                                  
  7415                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7416                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1BA8h (CODERES:0E68h)
  7417                                  
  7418                                  GetStrLen:
  7419                                  ;	Get length of string pointed to by DS:SI. Length includes NULL.
  7420                                  ;	Length is returned in CX
  7421                                  
  7422                                  	; MSDOS 3.3 & MSDOS 6.0
  7423 000019C1 31C9                    	xor	cx,cx
  7424                                  NxtChar:
  7425 000019C3 AC                      	lodsb
  7426 000019C4 41                      	inc	cx
  7427 000019C5 08C0                    	or	al,al
  7428 000019C7 75FA                    	jnz	short NxtChar
  7429 000019C9 C3                      	retn
  7430                                  
  7431                                  	; 29/01/2023
  7432                                  Setup_Seg:
  7433                                  
  7434                                  ; If the transient has been loaded in TranSeg, then we need to use that
  7435                                  ; segment for calls to routines in the transient area. Otherwise, the current
  7436                                  ; code segment is used
  7437                                  ; Segment returned in AX.
  7438                                  
  7439                                  	; MSDOS 3.3 & MSDOS 6.0
  7440 000019CA A1[9201]                	mov	ax,[TrnSeg]
  7441 000019CD 803E[9401]01            	cmp	byte [TrnMvFlg],1	; Has transient portion been moved
  7442 000019D2 7405                    	je	short setup_end
  7443                                  
  7444                                  ;06/06/2023
  7445                                  %if 0
  7446                                  	push	bx
  7447                                  	mov	bx,cs
  7448                                  	;mov	ax,offset ResGroup:TranStart
  7449                                  	;mov	ax,2320h ; MSDOS 5.0 COMMAND.COM
  7450                                  	; 06/06/2023
  7451                                  	;mov	ax,26E0h ; MSDOS 6.22 COMMAND.COM
  7452                                  	;mov	ax,TRANSTART
  7453                                  	;shr	ax,1
  7454                                  	;shr	ax,1
  7455                                  	;shr	ax,1
  7456                                  	;shr	ax,1
  7457                                  	; 29/01/2023
  7458                                  	mov	ax,TRANSTART>>4
  7459                                  	add	ax,bx
  7460                                  	pop	bx
  7461                                  %endif
  7462                                  	; 06/06/2023
  7463 000019D4 8CC8                    	mov	ax,cs
  7464 000019D6 052202                  	add	ax,TRANSTART>>4
  7465                                  
  7466                                  setup_end:
  7467 000019D9 C3                      	retn
  7468                                  
  7469                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7470                                  ;RPRINT:
  7471                                  	; MSDOS 3.3
  7472                                  	;push    ax
  7473                                  	;call    SETUP_SEG
  7474                                  	;mov     [PRINTADD+2], ax
  7475                                  	;;call	dword ptr PRINTADD
  7476                                  	;call	far [PRINTADD]
  7477                                  	;pop     ax
  7478                                  	;retn
  7479                                  
  7480                                  	; 29/01/2023
  7481                                  	; MSDOS 6.0
  7482                                  ;***	RPrintParse - display parse error message
  7483                                  ;
  7484                                  ;	ENTRY	DX = parse error #
  7485                                  ;
  7486                                  ;	EXIT	nothing
  7487                                  ;
  7488                                  ;	USED	flags
  7489                                  ;
  7490                                  ;	EFFECTS
  7491                                  ;	  Message is displayed on stdout.
  7492                                  
  7493                                  RPrintParse:	;proc
  7494                                  	;assume	ds:ResGroup,ss:ResGroup
  7495                                  
  7496 000019DA 52                      	push	dx				; preserve DX
  7497 000019DB 87DA                    	xchg	bx,dx				; bx = parse error #
  7498                                  						; dx = saved BX
  7499 000019DD 4B                      	dec	bx				; bx = parse error index, from 0
  7500 000019DE D1E3                    	shl	bx,1				; bx = offset in word table
  7501                                  	;mov	bx,ParsMsgPtrs[bx]		; bx = ptr to error msg
  7502 000019E0 8B9F[1609]              	mov	bx,[bx+PARSMSGPTRS]
  7503 000019E4 87DA                    	xchg	bx,dx				; dx = ptr to error msg
  7504                                  						; bx = restored
  7505 000019E6 E8A7F8                  	call	RPrint				; print the message
  7506 000019E9 5A                      	pop	dx				; restore DX
  7507 000019EA C3                      	retn
  7508                                  
  7509                                  ;RPrintParse	endp
  7510                                  
  7511                                  	; 29/01/2023
  7512                                  ;PATHCHRCMPR:
  7513                                  	; MSDOS 3.3
  7514                                  	;push	dx
  7515                                  	;mov	dl,[slash_chr]
  7516                                  	;;cmp	byte [RSWITCHAR],'/'
  7517                                          ;cmp	[RSWITCHAR],dl
  7518                                  	;je	short RNOSLASHT
  7519                                  	;;cmp	al,'/'
  7520                                  	;cmp	al,dl
  7521                                  	;je	short RET41 ; zf = 1 
  7522                                  ;RNOSLASHT:
  7523                                          ;;cmp	al,'\'
  7524                                  	;cmp	al,[bslash_chr]
  7525                                  ;RET41:
  7526                                  	;pop	dx
  7527                                  	;retn
  7528                                  
  7529                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7530                                  IfindE:
  7531                                  	; MSDOS 3.3 & MSDOS 6.0
  7532 000019EB E80300                  	call	ifind				; find the name
  7533                                  	;jc	short ifind2			; carry means not found
  7534                                  	;jmp	short Iscasb1 			; scan for = sign
  7535                                  	; 29/01/2023
  7536 000019EE 733A                    	jnc	short Iscasb1
  7537                                  ifind2:
  7538 000019F0 C3                      	retn
  7539                                  
  7540                                  	; 29/01/2023
  7541                                  
  7542                                  ; on return of find1, es:di points to beginning of name
  7543                                  
  7544                                  ifind:
  7545 000019F1 FC                      	cld
  7546 000019F2 E82700                  	call	Icount0				; cx = length of name
  7547 000019F5 8E06[3F03]              	mov	es,[EnvirSeg]
  7548 000019F9 31FF                    	xor	di,di
  7549                                  ifind1:
  7550 000019FB 51                      	push	cx
  7551 000019FC 56                      	push	si
  7552 000019FD 57                      	push	di
  7553                                  ifind11:
  7554 000019FE AC                      	lodsb
  7555 000019FF E83400                  	call	iupconv
  7556 00001A02 47                      	inc	di
  7557 00001A03 263A45FF                	cmp	al,[es:di-1]
  7558 00001A07 7502                    	jnz	short ifind12
  7559 00001A09 E2F3                    	loop	ifind11
  7560                                  ifind12:
  7561 00001A0B 5F                      	pop	di
  7562 00001A0C 5E                      	pop	si
  7563 00001A0D 59                      	pop	cx
  7564 00001A0E 74E0                    	jz	short ifind2
  7565 00001A10 51                      	push	cx
  7566 00001A11 E81A00                  	call	Iscasb2 			; scan for a nul
  7567 00001A14 59                      	pop	cx
  7568                                  	;cmp	byte [es:di],0
  7569                                  	;jnz	short ifind1
  7570                                  	;stc					; indicate not found
  7571 00001A15 26803D01                	cmp	byte [es:di],1
  7572 00001A19 73E0                    	jnb	short ifind1
  7573                                  	; cf=1					; indicate not found
  7574                                  ;ifind2:
  7575 00001A1B C3                      	retn
  7576                                  
  7577                                  	; 29/01/2023
  7578                                  Icount0:
  7579 00001A1C 1E                      	push	ds
  7580 00001A1D 07                      	pop	es
  7581 00001A1E 89F7                    	mov	di,si
  7582                                  
  7583 00001A20 57                      	push	di				; count number of chars until "="
  7584 00001A21 E80600                  	call	Iscasb1
  7585                                  	; 25/09/2018
  7586                                  	;jmp	short Icountx
  7587                                  	;push	di				; count number of chars until nul
  7588                                  	;call	Iscasb2
  7589                                  ;Icountx:
  7590 00001A24 59                      	pop	cx
  7591 00001A25 29CF                    	sub	di,cx
  7592 00001A27 87F9                    	xchg	di,cx
  7593 00001A29 C3                      	retn
  7594                                  
  7595                                  Iscasb1:
  7596                                  	; 29/01/2023
  7597 00001A2A B03D                    	mov	al,"="
  7598                                  	;mov	al,[equalsign] ; [equal_sign]	; scan for an =
  7599 00001A2C EB02                    	jmp	short Iscasbx
  7600                                  Iscasb2:
  7601 00001A2E 30C0                    	xor	al,al				; scan for a nul
  7602                                  Iscasbx:
  7603 00001A30 B90001                  	mov	cx,256 ; 100h
  7604 00001A33 F2AE                    	repnz	scasb
  7605 00001A35 C3                      	retn
  7606                                  
  7607                                  	; 29/01/2023
  7608                                  ;IUPCONV:
  7609                                  	; MSDOS 3.3
  7610                                          ;;cmp	al,"a"
  7611                                  	;cmp	al,[letter_a]
  7612                                          ;jb	short IRET22
  7613                                          ;;cmp	al,"z"
  7614                                          ;cmp	al,[letter_z]
  7615                                  	;ja	short IRET22
  7616                                          ;sub	al,20h			; Lower-case changed to upper-case
  7617                                  ;IRET22:
  7618                                  	;retn
  7619                                  
  7620                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7621                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C32h
  7622                                  
  7623                                  	; MSDOS 6.0
  7624                                  ; *****************************************************************
  7625                                  ; *
  7626                                  ; * ROUTINE:	 IUPCONV    (ADDED BY EMG 4.00)
  7627                                  ; *
  7628                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
  7629                                  ; *		 the character in AL from the file upper case table
  7630                                  ; *		 in DOS if character if above ascii 128, else
  7631                                  ; *		 subtracts 20H if between "a" and "z".
  7632                                  ; *
  7633                                  ; * INPUT:	 DS	      set to resident
  7634                                  ; *		 AL	      char to be upper cased
  7635                                  ; *		 FUCASE_ADDR  set to the file upper case table
  7636                                  ; *
  7637                                  ; * OUTPUT:	 AL	      upper cased character
  7638                                  ; *
  7639                                  ; *****************************************************************
  7640                                  
  7641                                  iupconv:	;proc	near				
  7642                                  	;assume	ds:ResGroup			;
  7643                                  
  7644 00001A36 3C80                    	cmp	al,80h				; see if char is > ascii 128
  7645 00001A38 7210                    	jb	short other_fucase		; no - upper case math
  7646 00001A3A 2C80                    	sub	al,80h				; only upper 128 chars in table
  7647 00001A3C 1E                      	push	ds				;
  7648 00001A3D 53                      	push	bx				;
  7649                                  	;lds	bx,dword ptr FUCase_Addr+1	; get table address
  7650 00001A3E C51E[B701]              	lds     bx,[FUCase_Addr+1]
  7651 00001A42 83C302                  	add	bx,2				; skip over first word
  7652                                  	;xlat	ds:byte ptr [bx]		; convert to upper case
  7653 00001A45 D7                      	xlat
  7654 00001A46 5B                      	pop	bx				;
  7655 00001A47 1F                      	pop	ds				;
  7656 00001A48 EB0A                    	jmp	short iupconv_end		; we finished - exit
  7657                                  
  7658                                  other_fucase:					;
  7659                                  	;cmp	al,[lcasea] ; [letter_a]	; if between "a" and "z",
  7660 00001A4A 3C61                    	cmp	al,'a'
  7661 00001A4C 7206                    	jb	short iupconv_end		;     subtract 20h to get
  7662                                  	;cmp	al,[lcasez] ; [letter_z]	; upper case equivalent.
  7663 00001A4E 3C7A                    	cmp	al,'z'
  7664 00001A50 7702                    	ja	short iupconv_end		;
  7665 00001A52 2C20                    	sub	al,20h				; Change lower-case to upper
  7666                                  iupconv_end:					;
  7667 00001A54 C3                      	retn
  7668                                  
  7669                                  ;iupConv endp
  7670                                  
  7671                                  	; 29/01/2023
  7672                                  init_contc_specialcase:
  7673                                  	; MSDOS 3.3 & MSDOS 6.0
  7674                                  						; This routine is called if control-C
  7675 00001A55 83C406                  	add	sp,6				;  is type during the date/time prompt
  7676 00001A58 56                      	push	si				;  at initialization time.  The desired
  7677 00001A59 89D6                    	mov	si,dx				;  response is to make it look like the
  7678 00001A5B C74401000D              	mov	word [si+1],0D00h		;  user typed <CR> by "popping" the
  7679 00001A60 5E                      	pop	si				;  INT 21h stuff off the stack, putting
  7680 00001A61 CF                      	iret					;  a <CR> in the user's buffer, and
  7681                                  						;  returning directly to the user.
  7682                                  						; In this case the user is TCODE.
  7683                                  
  7684                                  ; ----------------------------------------------------------------------------
  7685                                  
  7686                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7687                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1C62h (CODERES:0F22h)
  7688                                  
  7689                                  	; MSDOS 6.0
  7690                                  ; ****************************************************************
  7691                                  ; *
  7692                                  ; * ROUTINE:	 Setup_for_messages
  7693                                  ; *
  7694                                  ; * FUNCTION:	 Sets up system for PARSE and EXTENDED ERROR
  7695                                  ; *		 messages as follows:
  7696                                  ; *
  7697                                  ; *		 IF /P and /MSG are entered
  7698                                  ; *		    keep PARSE and EXTENDED ERRORS in memory
  7699                                  ; *		 ELSE IF /P is entered
  7700                                  ; *		    use PARSE and EXTENDED ERRORS on disk
  7701                                  ; *		    remove PARSE ERRORS from memory
  7702                                  ; *		 ELSE
  7703                                  ; *		    remove PARSE ERRORS from memory
  7704                                  ; *		 ENDIF
  7705                                  ; *
  7706                                  ; * INPUT:	 PERMCOM	Set up with user input
  7707                                  ; *		 EXT_MSG	Set up with user input
  7708                                  ; *		 System set up to retain PARSE ERRORS
  7709                                  ; *
  7710                                  ; * OUTPUT:	 registers unchanged
  7711                                  ; *
  7712                                  ; ****************************************************************
  7713                                  
  7714                                  setup_for_messages: ;proc near		
  7715                                  
  7716 00001A62 53                      	push	bx
  7717 00001A63 1E                      	push	ds				; save data segment
  7718 00001A64 06                      	push	es				; save environment segment
  7719 00001A65 50                      	push	ax				;
  7720 00001A66 52                      	push	dx				;
  7721 00001A67 57                      	push	di				;
  7722 00001A68 8CC8                    	mov	ax,cs				; get local segment to ES and DS
  7723 00001A6A 8ED8                    	mov	ds,ax				;
  7724 00001A6C 8EC0                    	mov	es,ax				;
  7725                                  
  7726 00001A6E 803E[A501]00            	cmp	byte [PermCom],0		; was permcom set?
  7727 00001A73 743C                    	jz	short no_permcom		; No - don't worry about messages
  7728                                  
  7729                                  ;*	We're permanent. Install our message services int 2f handler.
  7730                                  
  7731 00001A75 06                      	push	es
  7732                                  	;mov	ax,(GET_INTERRUPT_VECTOR shl 8) or 2Fh
  7733 00001A76 B82F35                  	mov	ax,352Fh
  7734 00001A79 CD21                    	int	21h
  7735                                  			; DOS - 2+ - GET INTERRUPT VECTOR
  7736                                  			; AL = interrupt number
  7737                                  			; Return: ES:BX = value of interrupt vector
  7738 00001A7B 891E[B303]              	mov	[Int2fHandler],bx
  7739 00001A7F 8C06[B503]              	mov	[Int2fHandler+2],es
  7740 00001A83 07                      	pop	es
  7741                                  
  7742                                  ;	DS = RESGROUP seg addr
  7743                                  
  7744                                  ; M005; We will not hook int 2fh on any command.com other than the first.
  7745                                  ; M005; Carousel loads as a permanent command.com and when we exit Carousel,
  7746                                  ; M005; it just wipes our arena out. So, int 2fh is still hooked and the
  7747                                  ; M005; first int 2fh call after exit from Carousel (from the DOS terminate
  7748                                  ; M005; call) goes off into space.
  7749                                  
  7750 00001A84 803E[EA20]00            	cmp	byte [FirstCom],0		; M005
  7751 00001A89 7416                    	je	short no_msg_hook		; M005
  7752                                  ;
  7753                                  ; M005; !!!SLIMIEST CAROUSEL HACK OFF ALL!!!
  7754                                  ; M005; Carousel plays around with the interrupt vector tables. He saves it
  7755                                  ; M005; before loading a new command.com. Then, it takes hold of the current
  7756                                  ; M005; command.com's PSP and then looks at all interrupt vectors whose
  7757                                  ; M005; segment matches the command.com PSP and then updates these segments
  7758                                  ; M005; to the new command.com's PSP in his saved vector table. Whenever we
  7759                                  ; M005; we pop into his menu, he puts this saved table into the vector table.
  7760                                  ; M005; If we now quit, Carousel just wipes out command.com's arena and then
  7761                                  ; M005; issues a terminate. Unfortunately, the int 2fh vector is pointing at
  7762                                  ; M005; the command.com that was wiped out and so the next int 2fh call will
  7763                                  ; M005; bomb. To prevent Carousel from doing this clever(1**$$#) patching, we
  7764                                  ; M005; renormalize our int 2fh pointer so that its cs is not the same as the
  7765                                  ; M005; command.com PSP. Now, he does no such patching and our int 2fh vector
  7766                                  ; M005; remains nice and happy. The renormalized pointer points at a far 
  7767                                  ; M005; jump to the actual int 2fh entry point.
  7768                                  ;
  7769 00001A8B 1E                      	push	ds				; M005
  7770                                  	;mov	dx,offset DATARES:Carousel_i2f_Hook ; M005
  7771 00001A8C BA[AF00]                	mov     dx,Carousel_i2f_Hook
  7772 00001A8F 83EA10                  	sub	dx,10h				; renormalize offset; M005
  7773 00001A92 8CD8                    	mov	ax,ds				; M005
  7774 00001A94 40                      	inc	ax				; Relocated cs ; M005
  7775 00001A95 8ED8                    	mov	ds,ax				; M005
  7776                                  	;mov	ax,(SET_INTERRUPT_VECTOR shl 8) or 2Fh
  7777 00001A97 B82F25                  	mov	ax,252Fh
  7778 00001A9A CD21                    	int	21h
  7779                                  			; DOS - SET INTERRUPT VECTOR
  7780                                  			; AL = interrupt number
  7781                                  			; DS:DX = new vector to be used for specified interrupt
  7782 00001A9C 1F                      	pop	ds				; M005
  7783                                  	;mov	word ptr Carousel_i2f_Hook+3,ds	; M005
  7784 00001A9D 8C1E[B200]              	mov	[Carousel_i2f_Hook+3],ds
  7785                                  						; patch in the cs for jump
  7786                                  no_msg_hook:					; M005
  7787 00001AA1 803E[AB1C]01            	cmp	byte [ext_msg],1 ; SET_EXTENDED_MSG
  7788 00001AA6 7516                    	jne	short permcom_end		; no /msg - exit
  7789                                  
  7790                                  permcom_slash_msg:				; Keep messages in memory
  7791                                  	;mov	di,offset ResGroup:ExtMsgEnd 	; get address of resident end
  7792 00001AA8 BF[0F0C]                	mov     di,ExtMsgEnd
  7793 00001AAB 893E[B703]              	mov	[ResMsgEnd],di			; save it
  7794 00001AAF EB0D                    	jmp	short permcom_end		; exit
  7795                                  
  7796                                  no_permcom:					
  7797                                  	;cmp	byte [ext_msg],SET_EXTENDED_MSG	; was /msg specified?
  7798 00001AB1 803E[AB1C]01            	cmp	byte [ext_msg],1
  7799 00001AB6 7506                    	jne	short permcom_end		; no - no error
  7800                                  	;mov	dx,LessArgs_Ptr			; get message number for "Required parameter missing"
  7801 00001AB8 BA0200                  	mov	dx,2
  7802 00001ABB E81CFF                  	call	RPrintParse
  7803                                  
  7804                                  permcom_end:
  7805 00001ABE 5F                      	pop	di				;
  7806 00001ABF 5A                      	pop	dx				;
  7807 00001AC0 58                      	pop	ax				;
  7808 00001AC1 07                      	pop	es				; get environment back
  7809 00001AC2 1F                      	pop	ds				;
  7810 00001AC3 5B                      	pop	bx
  7811                                  
  7812 00001AC4 C3                      	retn					;
  7813                                  
  7814                                  ;setup_for_messages	endp
  7815                                  
  7816                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7817                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1CC5h
  7818                                  
  7819                                  	; MSDOS 6.0
  7820                                  
  7821                                  ;***	CheckHelp - print help text and exit if /? is on command line
  7822                                  ;
  7823                                  ;	ENTRY	command-line tail at 81h
  7824                                  ;
  7825                                  ;	EXIT	return if /? not found
  7826                                  ;		terminate if /? found
  7827                                  ;
  7828                                  ;	USED	AX,BX,CX,DX,SI,DI
  7829                                  ;
  7830                                  ;	EFFECTS	Help text displayed if /? found on command line
  7831                                  
  7832                                  CheckHelp:	; proc
  7833                                  	;assume	cs:RESGROUP,ds:RESGROUP,es:RESGROUP,ss:RESGROUP
  7834                                  
  7835 00001AC5 BE8100                  	mov	si,81h			; DS:SI = ptr to command-line tail
  7836                                  	;mov	di,offset RESGROUP:Parse_Command
  7837 00001AC8 BF[B01C]                	mov	di,PARSE_COMMAND
  7838                                  					; ES:DI = ptr to primary parse block
  7839 00001ACB 31C9                    	xor	cx,cx			; CX = # positional param's found
  7840 00001ACD 31D2                    	xor	dx,dx			; DX will be ptr to result buffer
  7841                                  chParse:
  7842                                  	;call	dword ptr Init_Parse
  7843 00001ACF FF1E[A31C]              	call	far [Init_Parse]	; call system parser
  7844                                  
  7845                                  	;;cmp	ax,END_OF_LINE
  7846                                  	;cmp	ax,-1 ; 0FFFFh	
  7847                                  	;je	short chRet		; end of command line, no /? found
  7848                                  	;;cmp	ax,RESULT_NO_ERROR
  7849                                  	;;cmp	ax,0
  7850                                  	;;je	short chWhich		; valid syntax element found
  7851                                  	;;jmp	short chParse		; go parse more
  7852                                  	;and	ax,ax ; cmp ax,0
  7853                                  	;jnz	short chParse ; jne
  7854                                  	; 10/06/2023
  7855 00001AD3 40                      	inc	ax	; cmp ax,-1
  7856 00001AD4 7413                    	jz	short chRet   ; 0FFFFh -> 0
  7857 00001AD6 48                      	dec	ax	; cmp ax,0
  7858 00001AD7 75F6                    	jnz	short chParse ; 1 -> 0
  7859                                  	; ax = 0
  7860                                  chWhich:
  7861                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_?_Syn
  7862 00001AD9 813E[371D][321D]        	cmp     word [COMND1_SYN],COMMAND_?_SYN ; "/?"
  7863 00001ADF 7409                    	je	short chHelp		; /? found - display help & exit
  7864                                  	;cmp	Comnd1_Syn,offset RESGROUP:Command_C_Syn
  7865 00001AE1 813E[371D][181D]        	cmp     word [COMND1_SYN],COMMAND_C_SYN ; "/C"
  7866                                  	;je	short chRet		; /c found - ignore rest of line
  7867                                  	; 29/01/2023
  7868 00001AE7 75E6                    	jne	short chParse
  7869                                  	; MSDOS 6.0
  7870                                          ;;cmp	Comnd1_Syn,offset RESGROUP:Command_K_Syn
  7871                                        	;cmp	word [COMND1_SYN],COMMAND_K_SYN ; "/K"
  7872                                  	;je	short chRet		; /k found - ignore rest of line
  7873                                  	;jmp	short chParse		; anything else - ignore, keep looking
  7874                                  chRet:
  7875 00001AE9 C3                      	retn
  7876                                  chHelp:
  7877                                  	;mov	si,offset RESGROUP:HelpMsgs	; SI = ptr to msg ptr list
  7878 00001AEA BE[BC20]                	mov	si,HelpMsgs
  7879                                  chHelpNext:
  7880 00001AED AD                      	lodsw					; AX = ptr to msg
  7881 00001AEE 09C0                    	or	ax,ax
  7882 00001AF0 7407                    	jz	short chHelpDone		; end of list - all done
  7883 00001AF2 89C2                    	mov	dx,ax				; DX = ptr to msg
  7884 00001AF4 E899F7                  	call	RPrint				; display msg
  7885 00001AF7 EBF4                    	jmp	short chHelpNext		; go do next msg
  7886                                  
  7887                                  chHelpDone:
  7888 00001AF9 CD20                    	int	20h				; terminate program
  7889                                  ;chRet:
  7890 00001AFB C3                      	retn
  7891                                  
  7892                                  ;CheckHelp	endp
  7893                                  
  7894                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  7895                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D03h
  7896                                  
  7897                                  	; MSDOS 6.0
  7898                                  
  7899                                  ;***** Setup_res_end -- This routine determines the resident size of COMMAND.
  7900                                  ;
  7901                                  ; It determines based on 2 factors:
  7902                                  ;	1. Is this is the first COMMAND?
  7903                                  ;	2. Is COMMAND to be loaded into HIMEM?
  7904                                  ;   The strategy works as follows:
  7905                                  ;
  7906                                  ;	if (First COMMAND)
  7907                                  ;	then if (COMMAND in HIMEM)
  7908                                  ;		ResSize = resident_data;
  7909                                  ;	     else
  7910                                  ;		ResSize = resident_data + resident_code;
  7911                                  ;	else
  7912                                  ;	   ResSize = resident_data;
  7913                                  ;
  7914                                  ; Int 2fh calls have been added to determine whether or not we are the first
  7915                                  ; COMMAND and whether DOS is in HIMEM.
  7916                                  ;
  7917                                  ;	ENTRY: ResMsgEnd = resident size of data in paras
  7918                                  ;
  7919                                  ;	EXIT:  ResSize = resident size in low memory
  7920                                  ;
  7921                                  ;	REGISTERS AFFECTED: ax,cx,dx
  7922                                  ;
  7923                                  
  7924                                  GET_HMA_ADDR	equ	4A02h
  7925                                  
  7926                                  Setup_res_end:	;proc near
  7927                                  	
  7928 00001AFC 1E                      	push	ds
  7929 00001AFD 8CC8                    	mov	ax,cs
  7930 00001AFF 8ED8                    	mov	ds,ax				;ds = RESGROUP
  7931                                  	;assume	ds:RESGROUP
  7932                                  
  7933 00001B01 8B0E[B703]              	mov	cx,[ResMsgEnd]			;set resident size = data
  7934                                  
  7935                                  ;ifndef	ROMDOS
  7936                                  
  7937                                  ;M042 -- Begin changes
  7938                                  ;If messages are to be kept behind, we need to round up the messages to
  7939                                  ;the next para boundary. This is because we have a dummy segment between the
  7940                                  ;data and the resident code segment so that the code segment starts on a
  7941                                  ;para boundary
  7942                                  
  7943                                  	;cmp	cx,offset RESGROUP:ExtMsgEnd	;messages to be resident?
  7944 00001B05 81F9[0F0C]              	cmp	cx,ExtMsgEnd
  7945 00001B09 7506                    	jne	short calc_res			;no, continue
  7946 00001B0B 83C10F                  	add	cx,15				;round up
  7947 00001B0E 83E1F0                  	and	cx,0FFF0h
  7948                                  calc_res:
  7949                                  
  7950                                  ;M042 -- End changes
  7951                                  
  7952 00001B11 31C0                    	xor	ax,ax
  7953 00001B13 803E[EA20]01                   	cmp	byte [FirstCom],1		;is it first command.com?
  7954                                  	;jne	short not_first			;no, do not keep code
  7955                                  	; 06/06/2023
  7956 00001B18 751A                    	jne	short not_first2
  7957                                  
  7958                                  ;We issue a version check call with al=01 to detect if DOS is in HMA. If so,
  7959                                  ;bit 4 of dh is set
  7960                                  
  7961 00001B1A 53                      	push	bx
  7962 00001B1B 51                      	push	cx
  7963                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ;is DOS in HIMEM? ;M013
  7964 00001B1C B80633                  	mov	ax,3306h
  7965 00001B1F CD21                    	int	21h
  7966                                  		; DOS - 5+ Get TRUE Version Number
  7967                                  		; (BL major, BH minor, DL revision, DH flags)
  7968 00001B21 59                      	pop	cx
  7969                                  
  7970                                  ;bugbug: remove version check after testing
  7971                                  
  7972 00001B22 80FB05                  	cmp	bl,5				;bl has true version ; M013
  7973 00001B25 7207                    	jb	short oldver
  7974                                  
  7975 00001B27 31C0                    	xor	ax,ax
  7976 00001B29 80E610                  	and	dh,10h				;is DOS in HMA ; M013
  7977                                  	;pop	bx
  7978                                  	;jnz	short not_first			;DOS in HIMEM, code not
  7979                                  						;	resident
  7980                                  	; 29/01/2023
  7981 00001B2C 7503                    	jnz	short not_first_pop
  7982                                  oldver:
  7983                                  	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  7984                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  7985                                  	; 06/06/2023
  7986                                  	; 29/01/2023
  7987                                  	;mov	ax,EndCode-(RCODE_START+100h) ; 23/04/2023
  7988                                  	; 03/05/2023
  7989 00001B2E B8(0409)                	mov	ax,EndCode-RCODE_START	; 06/06/2023
  7990                                  
  7991                                  not_first_pop:
  7992                                  	; 29/01/2023
  7993 00001B31 5B                      	pop	bx
  7994                                  
  7995                                  not_first:
  7996                                  
  7997                                  ;Note that ax = 0 (side effect of int 2fh), if the code is not to be retained
  7998                                  
  7999 00001B32 01C1                    	add	cx,ax
  8000                                  
  8001                                  not_first2:	; 06/06/2023
  8002                                  
  8003                                  ;endif	;not ROMDOS
  8004                                  
  8005 00001B34 83C10F                  	add	cx,15				;round up to next para
  8006 00001B37 D1E9                    	shr	cx,1
  8007 00001B39 D1E9                    	shr	cx,1
  8008 00001B3B D1E9                    	shr	cx,1
  8009 00001B3D D1E9                    	shr	cx,1				;ax = para size of res code
  8010 00001B3F 890E[B903]              	mov	[ResSize],cx			;store resident size
  8011                                  
  8012 00001B43 1F                      	pop	ds
  8013                                  	;assume	ds:nothing
  8014 00001B44 C3                      	retn
  8015                                  
  8016                                  ;ifndef	ROMDOS
  8017                                  
  8018                                  ;bugbug: remove this code (for version independent COMMAND) after testing
  8019                                  
  8020                                  	; 29/01/2023
  8021                                  ;oldver:
  8022                                  ;	pop	bx
  8023                                  ;	;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8024                                  ;	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8025                                  ;	; 29/01/2023
  8026                                  ;	mov	ax,EndCode-RCODE_START
  8027                                  ;	jmp	short not_first
  8028                                  
  8029                                  ;endif	;not ROMDOS
  8030                                  
  8031                                  ;setup_res_end	endp
  8032                                  
  8033                                  ;ifndef	ROMDOS
  8034                                  
  8035                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8036                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8037                                  
  8038                                  	; MSDOS 6.0
  8039                                  ;*** Move_res_code -- This routine moves the resident code to its final 
  8040                                  ; location. We check if DOS is in HIMEM. If so, we try to load ourselves
  8041                                  ; in HIMEM. If we fail, then we remain low and update ResSize to reflect
  8042                                  ; the correct resident size. When remaining low, we have to check if we 
  8043                                  ; need to overlay the messages part of the data segment which is determined
  8044                                  ; by the /msg switch.
  8045                                  ;
  8046                                  ;	ENTRY: ResMsgEnd = end of resident data
  8047                                  ;
  8048                                  ;	EXIT:  The resident code is either up high or in its final location
  8049                                  ;		down low.
  8050                                  ;
  8051                                  ;	REGISTERS AFFECTED: ax,bx,cx,dx,si,di
  8052                                  	
  8053                                  Move_res_code:	;proc near
  8054                                  
  8055 00001B45 1E                      	push	ds
  8056 00001B46 06                      	push	es
  8057                                  
  8058 00001B47 8CC8                    	mov	ax,cs
  8059 00001B49 8ED8                    	mov	ds,ax
  8060                                  	;assume	ds:RESGROUP
  8061                                  
  8062                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) or 06h ; M013
  8063 00001B4B B80633                  	mov	ax,3306h
  8064 00001B4E CD21                    	int	21h				;DOS in HIMEM?
  8065                                  		; DOS - 5+ Get TRUE Version Number
  8066                                  		; (BL major, BH minor, DL revision, DH flags)
  8067                                  
  8068 00001B50 80E610                  	and	dh,10h				; M013
  8069 00001B53 750E                    	jnz	short move_high			;yes, move code high
  8070                                  
  8071                                  ;Check if messages have been discarded or not
  8072                                  
  8073                                  load_low:
  8074 00001B55 1E                      	push	ds
  8075 00001B56 07                      	pop	es				;es = RESGROUP
  8076 00001B57 8B3E[B703]              	mov	di,[ResMsgEnd]			;end offset in DATARES
  8077                                  	;;mov	bx,offset RESGROUP:ExtMsgEnd	;end offset of messages
  8078                                  	;mov	bx,ExtMsgEnd
  8079                                  	; 29/01/2023
  8080 00001B5B 81FF[0F0C]              	cmp	di,ExtMsgEnd
  8081                                  	;cmp	di,bx				;are messages to be kept?
  8082 00001B5F 7431                    	je	short no_move			;yes, dont move code
  8083                                  
  8084 00001B61 EB37                    	jmp	short setup_move		;es:di points at dest.
  8085                                  
  8086                                  move_high:
  8087                                  
  8088                                  ;We have to call DOS to get the load address in HIMEM for COMMAND
  8089                                  ;We pass in bx the number of bytes we need
  8090                                  
  8091                                  	;mov	bx,offset CODERES:EndCode
  8092                                  	; 29/01/2023
  8093                                  	;;mov	bx,81Ah ; MSDOS 5.0 COMMAND.COM
  8094                                  	; 06/06/2023
  8095                                  	;mov	bx,EndCode-(RCODE_START+100h) ; 23/04/2023 ; 06/06/2023
  8096                                  	; 03/05/2023
  8097 00001B63 BB(0409)                	mov	bx,EndCode-RCODE_START ; 06/06/2023
  8098                                  
  8099                                  ;M030;
  8100                                  ; Set di=0ffffh so that we load low in case no one answers this int 2fh
  8101                                  
  8102 00001B66 BFFFFF                  	mov	di,0FFFFh			;DT - in case no-one handles
  8103                                  						;this ; M030
  8104 00001B69 B8024A                  	mov	ax,GET_HMA_ADDR ; 4A02h
  8105 00001B6C CD2F                    	int	2Fh
  8106                                  
  8107                                  ;If the offset = 0xffff, then no HMA available
  8108                                  
  8109 00001B6E 83FFFF                  	cmp	di,0FFFFh			;HMA available?
  8110 00001B71 C606[3400]01            	mov	byte [ComInHMA],1		;assume command.com in HMA
  8111 00001B76 7522                    	jne	short setup_move		;no error, es:di = memory
  8112                                  
  8113                                  	;mov	byte [ComInHMA],0		;could not load in HMA
  8114                                  	; 29/01/2023	
  8115 00001B78 FE0E[3400]              	dec	byte [ComInHMA] ; 1 -> 0
  8116                                  
  8117                                  ;Zero means that we do not have enough HIMEM. Remain low and update
  8118                                  ;ResSize to reflect this
  8119                                  
  8120 00001B7C 8B0E[B703]              	mov	cx,[ResMsgEnd]			;size of data in bytes
  8121                                  	;;mov	ax,offset CODERES:EndCode	;size of code in bytes
  8122                                  	;;mov	ax,81Ah ; MSDOS 5.0 COMMAND.COM
  8123                                  	;mov	ax,EndCode-RCODE_START
  8124                                  	;add	cx,ax
  8125                                  	; 06/06/2023
  8126                                  	; 29/01/2023
  8127                                  	;add	cx,(EndCode-(RCODE_START+100h))+15 ; 23/04/2023 ; 06/06/2023
  8128                                  	;add	cx,15				;round up to next para
  8129                                  	; 03/05/2023
  8130 00001B80 81C1(1309)              	add	cx,(EndCode-RCODE_START)+15 ; 06/06/2023
  8131 00001B84 D1E9                    	shr	cx,1
  8132 00001B86 D1E9                    	shr	cx,1
  8133 00001B88 D1E9                    	shr	cx,1
  8134 00001B8A D1E9                    	shr	cx,1				;ax = para size of res code
  8135 00001B8C 890E[B903]              	mov	[ResSize],cx			;store resident size
  8136 00001B90 EBC3                    	jmp	short load_low			;let code remain low
  8137                                  
  8138                                  no_move:
  8139                                  	; 05/05/2023
  8140                                  	;mov	cl,4
  8141 00001B92 83C70F                  	add	di,0Fh
  8142 00001B95 83E7F0                  	and	di,0FFF0h			;round it to a para offset
  8143 00001B98 EB0B                    	jmp	short patch_up
  8144                                  
  8145                                  setup_move:
  8146                                  	;mov	si,offset RESGROUP:StartCode
  8147                                  	; 03/05/2023
  8148 00001B9A BE[100C]                	mov	si,RCODE_START  ; Start addr of Resident Code (CODERES segment)
  8149                                  				; 0D40h for MSDOS 5.0 COMMAND.COM
  8150                                  	;mov	cx,offset CODERES:EndCode	;cx = bytes to move
  8151                                  	;mov	cx,81Ah ; MSDOS 5.0 COMMAND.COM
  8152                                  	; 06/06/2023
  8153                                  	;mov	cx,EndCode-(RCODE_START+100h) ; 23/04/2023
  8154                                  	; 03/05/2023
  8155 00001B9D B9(0409)                	mov	cx,EndCode-RCODE_START	; 06/06/2023
  8156                                  
  8157 00001BA0 FC                      	cld
  8158 00001BA1 57                      	push	di				;need di for patching offset
  8159 00001BA2 F3A4                    	rep	movsb
  8160 00001BA4 5F                      	pop	di
  8161                                  
  8162                                  patch_up:
  8163 00001BA5 E84200                  	call	patch_stub
  8164 00001BA8 07                      	pop	es
  8165 00001BA9 1F                      	pop	ds
  8166                                  	;assume	ds:nothing
  8167 00001BAA C3                      	retn
  8168                                  
  8169                                  ;Move_res_code endp
  8170                                  
  8171                                  ;else	;ROMDOS
  8172                                  ;
  8173                                  ;;***	Move_res_code - ROMDOS version - locate ROM resident
  8174                                  ;
  8175                                  ;Move_res_code	proc
  8176                                  ;
  8177                                  ;	push	es
  8178                                  ;
  8179                                  ;	invoke	FindROMRes		; ES:DI = ptr to ROM resident code
  8180                                  ;	call	patch_stub
  8181                                  ;
  8182                                  ;	pop	es
  8183                                  ;	ret
  8184                                  ;
  8185                                  ;Move_res_code	endp
  8186                                  ;
  8187                                  ;	assume	ds:NOTHING		; to match ending assume above
  8188                                  ;
  8189                                  ;endif	;ROMDOS
  8190                                  
  8191                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8192                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1D52h
  8193                                  
  8194                                  	; MSDOS 6.0
  8195                                  ;*** Alloc_env -- This routine allocates the temporary environment for the
  8196                                  ; Init code to initialize the COMSPEC. This is not a complete environment. 
  8197                                  ; Later on, at EndInit time, a proper sized environment is allocated and
  8198                                  ; the contents of this temporary environment are copied to it. This routine
  8199                                  ; will not be called in case a valid environment is passed to command.com
  8200                                  ;
  8201                                  ;       ENTRY:  FirstCom and initial EnvirSeg set
  8202                                  ;
  8203                                  ;       EXIT:   ax = EnvirSeg = segment of newly allocated environment segment
  8204                                  ;
  8205                                  ;       REGISTERS AFFECTED: ax,bx,cx,dx
  8206                                  
  8207                                  alloc_env:	;proc near
  8208                                  	;assume ds:nothing
  8209                                  	
  8210 00001BAB 1E                              push    ds
  8211 00001BAC 06                      	push	es
  8212 00001BAD 56                      	push	si
  8213 00001BAE 57                      	push	di
  8214                                  
  8215                                  ; 29/01/2023 - MSDOS 6.0 COMMAND.COM
  8216                                  %if 0
  8217                                          push    ss
  8218                                          pop     ds
  8219                                  	;assume ds:RESGROUP
  8220                                  
  8221                                          mov     ax,[EnvirSeg]
  8222                                  
  8223                                          cmp	byte [AllocedEnv],0
  8224                                          je	short alloc_cont
  8225                                          jmp     alloc_done
  8226                                  
  8227                                  alloc_cont:
  8228                                          sub     di,di                           ; default start
  8229                                          ;mov	bx,SIZE Environment             ; default size needed
  8230                                  	; 29/01/2023
  8231                                  	mov	bx,ENVIRONSIZ
  8232                                  
  8233                                          cmp	byte [FirstCom],0		; first COMMAND.COM?
  8234                                          je	short alloc_seg			; no
  8235                                  
  8236                                  ;   Check EnvirSeg; if non-zero, then scan it for PATH and COMSPEC;
  8237                                  ;   Record their respective locations and do not add the default vars.
  8238                                  
  8239                                  	or      ax,ax
  8240                                  	jz	short alloc_new			; no previous environment
  8241                                  
  8242                                          mov     es,ax
  8243                                  	;assume es:nothing
  8244                                  
  8245                                  _find_path:
  8246                                          mov     al,0
  8247                                          sub     di,di
  8248                                  comp_path:
  8249                                          scasb                                   ; end of env?
  8250                                  	je	short _find_prompt		; yes
  8251                                          dec     di
  8252                                          mov     cx,PathStrLen ; mov cx,5 ; "PATH="
  8253                                          ;mov	si,offset RESGROUP:PathString
  8254                                  	mov	si,PathString	
  8255                                          repe    cmpsb
  8256                                          je	short got_path
  8257                                          mov	cx,256
  8258                                          repne   scasb                           ; find next NULL
  8259                                          jmp     short comp_path
  8260                                  
  8261                                  got_path:
  8262                                          mov	byte [PathString],0		; don't add it
  8263                                  
  8264                                  _find_prompt:
  8265                                          sub     di,di
  8266                                  comp_prompt:
  8267                                  	scasb                                   ; end of env?
  8268                                  	je	short find_comspec		; yes
  8269                                  	dec     di
  8270                                  	mov     cx,PrmptStrLen2 ; mov cx,7
  8271                                  	;mov	si,offset RESGROUP:PrmptString
  8272                                  	mov	si,PrmptString
  8273                                          repe    cmpsb
  8274                                          je	short got_prompt
  8275                                          mov     cx,256
  8276                                          repne   scasb                           ; find next NULL
  8277                                          jmp	short comp_prompt
  8278                                  
  8279                                  got_prompt:
  8280                                  	mov	byte [PrmptString],0		; don't add it
  8281                                  
  8282                                  find_comspec:
  8283                                          sub     di,di
  8284                                  comp_comspec:
  8285                                          scasb                                   ; end of env?
  8286                                          je	short got_envend		; yes
  8287                                          dec     di
  8288                                          mov	cx,ComspStrLen ; mov cx,8
  8289                                  	;mov	si,offset RESGROUP:ComspString
  8290                                  	mov	si,ComspString
  8291                                          repe    cmpsb
  8292                                          je	short got_comspec
  8293                                          mov     cx,256
  8294                                          repne   scasb                           ; find next NULL
  8295                                          jmp	short comp_comspec
  8296                                  
  8297                                  got_comspec:
  8298                                          mov     [ComspOffset],di
  8299                                  
  8300                                  find_envend:
  8301                                          sub     di,di
  8302                                          mov     cx,ENVBIG                       ; max env size
  8303                                  comp_envend:
  8304                                          dec     cx                              ;
  8305                                          scasb                                   ; end of env?
  8306                                          je	short got_envend		; yes
  8307                                          repne   scasb
  8308                                          jmp	short comp_envend
  8309                                  
  8310                                  got_envend:
  8311                                          dec     di
  8312                                          lea     bx,[di+SIZE Environment]        ; add room for the basics
  8313                                  
  8314                                  ;   We want to fall through to alloc_new and set up default
  8315                                  ;   path and prompt ONLY IF this is the first process;  in all other
  8316                                  ;   cases, we assume it is a bad idea to try editing the user's environment
  8317                                  
  8318                                          push    ds
  8319                                          ;mov	ds,ds:[PDB_Parent_Pid]
  8320                                          mov	ds,[PDB.PARENT_PID]
  8321                                  	;cmp	ds:[PDB_Parent_Pid],0           ; is parent's parent pid field 0?
  8322                                  	cmp	word [PDB.PARENT_PID],0
  8323                                  	pop     ds
  8324                                          jne	short alloc_seg			; no, we're not the first process
  8325                                                                                  ; so don't muck with the env.
  8326                                  alloc_new:
  8327                                  	inc	byte [AllocedEnv]		; note we have virgin env.
  8328                                  
  8329                                  alloc_seg:
  8330                                  
  8331                                  ; Allocate default environment size
  8332                                  
  8333                                          mov     cx,bx                           ; save byte-granular size in CX
  8334                                          add     bx,15
  8335                                          shr     bx,1
  8336                                          shr     bx,1
  8337                                          shr     bx,1
  8338                                          shr     bx,1                            ; BX = # paras
  8339                                  	mov	ah,ALLOC
  8340                                  	int	21h
  8341                                          jnc	short init_ok
  8342                                          jmp     init_nomem                      ; insufficient memory, error
  8343                                  
  8344                                  ; If a previous environment existed (ie, DI != 0), then copy it into
  8345                                  ; the new buffer
  8346                                  
  8347                                  init_ok:
  8348                                  	mov	es,ax
  8349                                  	;assume	es:nothing                      ; es = temp env segment
  8350                                  
  8351                                  	or      di,di
  8352                                          jz	short copy_path
  8353                                  
  8354                                          push    cx
  8355                                          push    ds
  8356                                          mov     ds,[EnvirSeg]
  8357                                          ;assume ds:nothing
  8358                                          sub     si,si
  8359                                          mov     cx,di
  8360                                          sub     di,di
  8361                                          rep     movsb
  8362                                          pop     ds
  8363                                          ;assume ds:RESGROUP
  8364                                          pop     cx
  8365                                          sub     cx,di
  8366                                  
  8367                                  copy_path:
  8368                                  
  8369                                  ; First clear out (the rest of) the buffer
  8370                                  
  8371                                          push    di
  8372                                          sub     ax,ax
  8373                                          rep     stosb
  8374                                          pop     di
  8375                                  
  8376                                  ; Initialize the path string (PATH=) first
  8377                                  
  8378                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8379                                  	mov	si,PathString
  8380                                          cmp     byte [si],al			; add it?
  8381                                          je	short init_prompt		; no
  8382                                  	;mov	cx,PathStrLen+1                 ;
  8383                                  	mov	cx,6 ; db "PATH=",0
  8384                                          rep     movsb                           ;
  8385                                          cmp     [AllocedEnv],al			; virgin env?
  8386                                          je	short init_prompt		; no
  8387                                  
  8388                                  ; Establish a more reasonable default for the PATH
  8389                                  
  8390                                  	;mov	ah,GET_DEFAULT_DRIVE
  8391                                  	mov	ah,19h
  8392                                  	int	21h
  8393                                          add     al,'A'                          ; convert to letter
  8394                                          mov     [DefPathString],al              ;
  8395                                          mov     [DefPath2String],al             ; now our default paths are complete
  8396                                  
  8397                                          mov     dl,0                            ; get dir for default drive
  8398                                          push    ds                              ;
  8399                                          push    es                              ;
  8400                                          pop     ds                              ;
  8401                                          mov     byte [di],'\'			;
  8402                                          lea     si,[di+1]                       ; set DS:SI -> available space
  8403                                  	;mov	ah,Current_Dir                  ;
  8404                                          mov	ah,47h
  8405                                  	int     21h                             ;
  8406                                          pop     ds                              ;
  8407                                  
  8408                                  	;mov	cx,DefPathStrLen+1              ;
  8409                                  	mov	cx,9 ; db "C:\MSDOS",0
  8410                                  	;mov	dx,offset RESGROUP:DefPathString
  8411                                  	mov	dx,DefPathString 
  8412                                  	mov	si,dx                           ;
  8413                                          ;mov	ah,CHDir                        ;
  8414                                          mov	ah,3Bh
  8415                                  	int     21h                             ;
  8416                                          jnc	short init_setpath		; DefPathString exists!
  8417                                  
  8418                                  	;mov	cx,DefPath2StrLen+1		;
  8419                                          mov	cx,7 ; db "C:\DOS",0
  8420                                  	;mov	dx,offset RESGROUP:DefPath2String
  8421                                  	mov	dx,DefPath2String
  8422                                          mov     si,dx                           ;
  8423                                          ;mov	ah,CHDir                        ;
  8424                                          mov	ah,3Bh
  8425                                          int     21h                             ;
  8426                                          jc	short init_prompt		; DefPath2String doesn't exist
  8427                                  
  8428                                  init_setpath:
  8429                                          mov     dx,di                           ; success
  8430                                          push    ds                              ; so restore prev dir
  8431                                          push    es                              ;
  8432                                          pop     ds                              ; DS:DX -> prev dir
  8433                                          ;mov	ah,CHDir                        ;
  8434                                          mov	ah,3Bh
  8435                                          int     21h                             ;
  8436                                          pop     ds                              ;
  8437                                  
  8438                                          dec     di                              ; then copy in DefPathString
  8439                                          rep     movsb                           ; DS:SI -> "C:\\DOS\0"
  8440                                  
  8441                                  ; Initialize the default prompt
  8442                                  
  8443                                  init_prompt:
  8444                                          push    di                              ;
  8445                                          sub     ax,ax                           ;
  8446                                          mov     cx,64                           ; insure any data read in
  8447                                          rep     stosb                           ; from Current_Dir is zapped
  8448                                          pop     di                              ;
  8449                                  
  8450                                  	cmp	[AllocedEnv],al			; virgin env?
  8451                                          je	short init_comspec		; no
  8452                                          ;mov	si,offset RESGROUP:PrmptString  ; DS:SI -> "PROMPT=$P$G\0"
  8453                                          mov	si,PrmptString
  8454                                  	cmp     [si],al				; add it?
  8455                                          je      short init_comspec		; no
  8456                                  	;mov	cx,PrmptStrLen+1                ;
  8457                                          mov	cl,12  ; db "PROMPT=$P$G",0
  8458                                  	rep     movsb                           ;
  8459                                  
  8460                                  ; Initialize the Comspec string
  8461                                  
  8462                                  init_comspec:
  8463                                          cmp	[ComspOffset],ax		; add it?
  8464                                          jne	short init_done			; no
  8465                                          lea     ax,[di+ComspStrLen]             ;
  8466                                          mov	[ComspOffset],ax		;
  8467                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8468                                          mov	si,ComspString
  8469                                  	;mov	cx,ComspStrLen2+1               ;
  8470                                          mov	cx,21 ; db "COMSPEC=\COMMAND.COM",0
  8471                                  	rep     movsb                           ;
  8472                                  
  8473                                  init_done:
  8474                                          mov     ax,es                           ; return env seg in ax
  8475                                          mov     [EnvirSeg],ax			; save env seg
  8476                                          inc	byte [AllocedEnv]		; remember that *we* alloced it
  8477                                  %endif
  8478                                  
  8479                                  ; 29/01/2023 - MSDOS 5.0 COMMAND.COM (RESGROUP:1DC4h)
  8480                                  %if 1
  8481                                  	;mov	bx,10
  8482 00001BAF BB0A00                  	mov	bx,ENVIRONSIZ>>4 ; 160/16
  8483 00001BB2 B448                    	mov	ah,48h
  8484 00001BB4 CD21                    	int	21h    	; DOS - 2+ - ALLOCATE MEMORY
  8485                                  			; BX = number of 16-byte paragraphs desired
  8486 00001BB6 722C                    	jc	short init_nomem
  8487                                  
  8488                                  init_ok:
  8489 00001BB8 8EC0                    	mov	es,ax
  8490                                  	;assume	es:nothing                      ; es = temp env segment
  8491                                  
  8492 00001BBA 31FF                    	xor	di,di
  8493 00001BBC 89F8                    	mov	ax,di
  8494                                  	;mov	cx,160	
  8495 00001BBE B9A000                          mov     cx,ENVIRONSIZ
  8496 00001BC1 F3AA                            rep	stosb
  8497                                  
  8498                                  init_pathstr:
  8499                                  
  8500                                  ; Initialize the path string (PATH=) first
  8501                                  
  8502 00001BC3 16                      	push	ss
  8503 00001BC4 1F                      	pop	ds
  8504                                  
  8505                                          ;mov	si,offset RESGROUP:PathString   ; DS:SI -> "PATH=\0"
  8506 00001BC5 BE[7C1C]                	mov	si,PathString
  8507 00001BC8 BF0000                  	mov	di,0
  8508                                  init_cp_pathstr:
  8509 00001BCB AC                      	lodsb
  8510 00001BCC AA                      	stosb
  8511 00001BCD 08C0                    	or	al,al
  8512 00001BCF 75FA                    	jnz	short init_cp_pathstr
  8513                                  
  8514                                  ; Initialize the Comspec string
  8515                                  
  8516                                  init_comspec:
  8517                                          ;mov	si,offset RESGROUP:ComspString  ; DS:SI -> "COMSPEC=\\COMMAND.COM\0"
  8518 00001BD1 BE[821C]                        mov	si,ComspString
  8519                                  	; 05/05/2023
  8520 00001BD4 BF0600                  	mov	di,6
  8521                                  init_cp_compstr:
  8522 00001BD7 AC                      	lodsb
  8523 00001BD8 AA                      	stosb
  8524 00001BD9 08C0                    	or	al,al
  8525 00001BDB 75FA                    	jnz	short init_cp_compstr
  8526                                  
  8527                                  init_done:
  8528 00001BDD 8CC0                            mov     ax,es                           ; return env seg in ax
  8529                                          ;mov	[EnvirSeg],ax			; save env seg
  8530                                          ;inc	byte [AllocedEnv]		; remember that *we* alloced it
  8531                                  %endif	
  8532                                  
  8533                                  	; 29/01/2023
  8534                                  alloc_done:
  8535 00001BDF 5F                      	pop	di
  8536 00001BE0 5E                      	pop	si
  8537 00001BE1 07                      	pop	es
  8538 00001BE2 1F                              pop     ds
  8539                                  	;assume	ds:nothing
  8540 00001BE3 C3                      	retn
  8541                                  
  8542                                  	; 29/01/2023
  8543                                  init_nomem:
  8544                                  
  8545                                  ;We call the error routine from here. This routine never returns. It either
  8546                                  ;terminates COMMAND with error( if it is not the first invocation ) or hangs
  8547                                  ;the system ( if it is the first COMMAND.COM ).
  8548                                  
  8549 00001BE4 E80000                  	call	Alloc_error
  8550                                  
  8551                                  ;Alloc_env	endp
  8552                                  
  8553                                  ;*** Alloc_error: This routine just jumps to the actual label where we 
  8554                                  ; check if this is a permanent or secondary command.com and take the 
  8555                                  ; appropriate action.
  8556                                  ;
  8557                                  ;	ENTRY:	ds = RESGROUP = DATARES
  8558                                  ;
  8559                                  ;	EXIT:	None - does not return
  8560                                  ;
  8561                                  ;	REGISTERS AFFECTED: Does not matter
  8562                                  ;
  8563                                  
  8564                                  ;public Alloc_error
  8565                                  Alloc_error:	;proc	near
  8566                                  
  8567                                  	;jmp	RESGROUP:BadMemErr
  8568                                  	; 29/01/2023
  8569 00001BE7 E92FF1                  	jmp	BadMemErr	
  8570                                  	
  8571                                  ;Alloc_error	endp
  8572                                  
  8573                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8574                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1DFFh
  8575                                  
  8576                                  	; MSDOS 6.0
  8577                                  ;*** Patch_stub -- This routine patches in the segment and offset values in
  8578                                  ; the stub table of the various entry points in the resident code segment.
  8579                                  ; Some of them are interrupt entry points and some of them are entries from
  8580                                  ; the transient to the resident code segment.
  8581                                  ;
  8582                                  ;	ENTRY:	ds = RESGROUP
  8583                                  ;		es:di = segment:offset of final location of resident code
  8584                                  ;
  8585                                  ;	EXIT:	All segments and offsets patched into the stub table
  8586                                  ;
  8587                                  ;	REGISTERS AFFECTED: ax, bx, cx, dx, si, di
  8588                                  
  8589                                  patch_stub:	;proc near
  8590                                  	;assume	ds:RESGROUP
  8591                                  	
  8592 00001BEA 06                      	push	es
  8593                                  
  8594 00001BEB 8CC3                    	mov	bx,es			;bx = resident code segment
  8595 00001BED 89FA                    	mov	dx,di
  8596                                  	;mov	di,offset DATARES:Int2f_Entry
  8597 00001BEF BF[0400]                	mov	di,Int2f_Entry
  8598                                  	;mov	si,offset RESGROUP:Reloc_Table
  8599 00001BF2 BE[D020]                	mov	si,Reloc_Table
  8600 00001BF5 1E                      	push	ds
  8601 00001BF6 07                      	pop	es			;es = RESGROUP = DATARES
  8602                                  
  8603                                  ;bx:dx = segment:offset of resident code segment
  8604                                  ;es:di = entry point table in stub
  8605                                  ;ds:si = offset table in INIT segment -- offsets of code entry points now
  8606                                  
  8607                                  	;mov	cx,NUM_RELOC_ENTRIES	;number of entry points
  8608 00001BF7 B90B00                  	mov	cx,11 ; MSDOS 5.0 COMMAND.COM
  8609                                  patchlp:
  8610 00001BFA AD                      	lodsw				;get current offset
  8611 00001BFB 01D0                    	add	ax,dx			;offset it by code seg location 
  8612 00001BFD AB                      	stosw				;store offset
  8613 00001BFE 89D8                    	mov	ax,bx			
  8614 00001C00 AB                      	stosw				;store segment 
  8615 00001C01 E2F7                    	loop	patchlp
  8616                                  
  8617 00001C03 07                      	pop	es
  8618 00001C04 C3                      	retn
  8619                                  
  8620                                  ;Patch_stub	endp
  8621                                  
  8622                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8623                                  
  8624                                  	; MSDOS 6.0
  8625                                  ;*** Patch_segs -- This routine patches the segment values in the dword 
  8626                                  ; pointers that the stub uses to jump to the actual handler. These values 
  8627                                  ; are temporarily needed to handle these interrupts if they occur before
  8628                                  ; the resident is relocated to its final position and all the addresses of
  8629                                  ; the handlers have been updated.
  8630                                  ;
  8631                                  ;	ENTRY:	es = PSP segment = code segment
  8632                                  ;
  8633                                  ;	EXIT:	Current segment values patched into the jump table in the
  8634                                  ;		stub.
  8635                                  ;
  8636                                  ;	REGISTERS AFFECTED: ax, cx, di
  8637                                  
  8638                                  patch_segs:	;proc near
  8639                                  
  8640                                  	;mov	di,offset RESGROUP:Int2f_Entry
  8641 00001C05 BF[0400]                	mov	di,Int2f_Entry 
  8642 00001C08 B90400                  	mov	cx,4			;we have to patch 4 handlers
  8643 00001C0B 83C702                  	add	di,2
  8644 00001C0E 8CC0                    	mov	ax,es
  8645                                  pseglp:
  8646 00001C10 AB                      	stosw				;store the segment value
  8647 00001C11 83C702                  	add	di,2			;skip the next offset value
  8648 00001C14 E2FA                    	loop	pseglp
  8649                                  
  8650 00001C16 C3                      	retn
  8651                                  
  8652                                  ;Patch_segs	endp
  8653                                  
  8654                                  	; 29/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8655                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E2Ch
  8656                                  
  8657                                  	; MSDOS 6.0
  8658                                  ;*** get_XMMAddr -- This routine gets the call address for the XMM driver
  8659                                  ; by issuing the appropriate int 2fh. This is stored in a stub variable 
  8660                                  ; and is used by the stub when we have to jump to the resident in HMA
  8661                                  ;
  8662                                  ;	ENTRY:	ds = RESGROUP
  8663                                  ;
  8664                                  ;	EXIT:	XMMCallAddr = XMM driver far call address
  8665                                  ;
  8666                                  ;	REGISTERS AFFECTED:
  8667                                  ;
  8668                                  
  8669                                  get_XMMAddr:	;proc near
  8670                                  	;assume	ds:RESGROUP
  8671                                  
  8672 00001C17 06                      	push	es
  8673                                  
  8674                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_INSTALL_CHECK
  8675 00001C18 B80043                  	mov	ax,4300h
  8676 00001C1B CD2F                    	int	2Fh
  8677                                  		; - Multiplex - XMS - INSTALLATION CHECK
  8678                                  		; Return: AL = 80h XMS driver installed
  8679                                  		; AL <> 80h no driver
  8680 00001C1D 3C80                    	cmp	al,80h			; Q: installed
  8681 00001C1F 750D                    	jne	short cXMMexit		; N: set error, quit
  8682                                  ;
  8683                                  ; get the XMM control functions entry point, save it, we
  8684                                  ; need to call it later.
  8685                                  ;
  8686                                  	;mov	ax,XMM_MULTIPLEX SHL 8 + XMM_FUNCTION_ADDR
  8687 00001C21 B81043                  	mov	ax,4310h
  8688 00001C24 CD2F                    	int	2Fh
  8689                                  		; - Multiplex - XMS - GET DRIVER ADDRESS
  8690                                  		; Return: ES:BX -> driver entry point
  8691                                  
  8692 00001C26 891E[3000]              	mov	[XMMCallAddr], bx
  8693 00001C2A 8C06[3200]              	mov	[XMMCallAddr+2],es
  8694                                  cXMMexit:
  8695 00001C2E 07                      	pop	es
  8696 00001C2F C3                      	retn				; done
  8697                                  
  8698                                  ;get_XMMAddr	endp
  8699                                  
  8700                                  ;=============================================================================
  8701                                  ; UNINIT.ASM, MSDOS 6.0, 1991
  8702                                  ;=============================================================================
  8703                                  ; 24/09/2018 - Retro DOS v3.0
  8704                                  
  8705                                  ; (30/04/2018 - Retro DOS v2.0, MSDOS 2.11 COMMAND.COM)
  8706                                  
  8707                                  ; TITLE	COMMAND Initialization messages
  8708                                  
  8709                                  ;INIT	SEGMENT PUBLIC PARA
  8710                                  
  8711                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8712                                  
  8713                                  	; 25/09/2018
  8714                                  	; (15 bytes filler)
  8715 00001C30 00                      	db 0
  8716                                  	;db "25/9/2018 ETAN"
  8717                                  	; 12/06/2023
  8718 00001C31 31322F362F32303233-     	db "12/6/2023 ETAN"	
  8718 00001C3A 204554414E         
  8719 00001C3F 00                      	db 0
  8720                                  
  8721                                  ; 30/01/2023
  8722                                  %if 0
  8723                                  	; MSDOS 3.3 COMMAND.COM - offset 145Eh
  8724                                  	;dw 0
  8725                                  COPYRIGHTMSG:	; MSDOS 3.3 COMMAND.COM - offset 1460h
  8726                                  	db 0Dh,0Ah
  8727                                  	db 0Dh,0Ah
  8728                                  	db 'Microsoft(R) MS-DOS(R)  Version 3.30'
  8729                                  	db 0Dh,0Ah
  8730                                  	db '             (C)Copyright Microsoft Corp 1981-1987               '
  8731                                  	db ' ',0Dh,0Ah
  8732                                  	db '                                                   ',
  8733                                  	db 0Dh,0Ah,0
  8734                                  
  8735                                  	times 43 db 20h
  8736                                  
  8737                                  _152Fh:	db 'Specified COMMAND search directory bad',0Dh,0Ah,0
  8738                                  BADCOMLKMES:
  8739                                  	dw _152Fh
  8740                                  
  8741                                  _155Ah:	db 'Specified COMMAND search directory bad access denied',0Dh,0Ah,0
  8742                                  BADCOMACCMSG:
  8743                                  	dw _155Ah
  8744                                  
  8745                                  _1593h:	db 'Access denied',0Dh,0Ah,0
  8746                                  ACCDENERR:
  8747                                  	dw _1593h
  8748                                  
  8749                                  _15A5h:	db 'Out of environment space',0Dh,0Ah,0
  8750                                  OUTENVMSG:
  8751                                  	dw _15A5h
  8752                                  
  8753                                  BADVERMSG:
  8754                                  	db 'Incorrect DOS version',0Dh,0Ah,'$'
  8755                                  
  8756                                  BADENVSIZMSG:
  8757                                  	db 'Invalid environment size specified',0Dh,0Ah,'$'
  8758                                  
  8759                                  HEADERPTR:
  8760                                  	dw COPYRIGHTMSG
  8761                                  %endif
  8762                                  
  8763                                  ; 30/01/2023
  8764                                  ;align 16
  8765                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8766                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1E50h 
  8767                                  ICONDEV:
  8768 00001C40 2F4445562F                      db '/DEV/'
  8769 00001C45 434F4E000000000000      	db 'CON',0,0,0,0,0,0	; Room for 8 char device	
  8770                                  BADCSPFL:
  8771 00001C4E 00                      	db 0
  8772                                  COMSPECT:
  8773 00001C4F 5C434F4D4D414E442E-     	db '\COMMAND.COM',0
  8773 00001C58 434F4D00           
  8774 00001C5C 00                      	db 0
  8775                                  AUTOBAT:
  8776 00001C5D 003A5C4155544F4558-     	db 0,':\AUTOEXEC.BAT',0,0Dh
  8776 00001C66 45432E424154000D   
  8777                                  ;KAUTOBAT:
  8778                                  	;db 0,':\KAUTOEXEC.BAT',0,0Dh 
  8779                                  PRDATTM:
  8780 00001C6E FF                      	db -1 ; 0FFh		; Init not to prompt for date time
  8781                                  INITADD:
  8782 00001C6F 00000000                	dd 0
  8783                                  print_add:
  8784 00001C73 [F14D]                  	dw Printf_Init
  8785 00001C75 0000                    	dw 0
  8786                                  triage_add:
  8787 00001C77 [9C2C]                  	dw Triage_Init
  8788 00001C79 0000                    	dw 0
  8789                                  ;CHUCKENV:
  8790                                  AllocedEnv:
  8791 00001C7B 00                      	db 0
  8792                                  
  8793                                  ; 30/01/2023 - MSDOS 3.3
  8794                                  ;COMSPOFFSET:
  8795                                  ;ECOMLOC:
  8796                                  ;	;dw 0Eh
  8797                                  ;	;dw offset ENVIRONMENT:ECOMSPEC-10h
  8798                                  ;	dw ECOMSPEC-ENVIRONMENT ; 30/04/2018	
  8799                                  ;COMSPSTRING:
  8800                                  ;	db 'COMSPEC='
  8801                                  
  8802                                  ; 30/01/2023 - MSDOS 5.0 & MSDOS 6.0
  8803                                  PathString:
  8804 00001C7C 504154483D00            	db 'PATH=',0
  8805                                  PathStrLen equ $-PathString-1
  8806                                  ; MSDOS 6.0
  8807                                  ;DefPathString:
  8808                                  ;	db 'C:\MSDOS',0
  8809                                  ;DefPathStrLen equ  $-DefPathString-1
  8810                                  ;DefPath2String:
  8811                                  ;	db 'C:\DOS',0
  8812                                  ;DefPath2StrLen equ $-DefPath2String-1
  8813                                  ;
  8814                                  ;PrmptString:
  8815                                  ;	db 'PROMPT=$P$G',0
  8816                                  ;PrmptStrLen equ $-PrmptString-1
  8817                                  ;PrmptStrLen2 equ 7		; length of PROMPT=
  8818                                  ;ComspOffset:
  8819                                  ;	dw 0
  8820                                  ComspString:
  8821 00001C82 434F4D535045433D5C-     	db 'COMSPEC=\COMMAND.COM',0
  8821 00001C8B 434F4D4D414E442E43-
  8821 00001C94 4F4D00             
  8822                                  ComspStrLen equ 8		; length of COMSPEC=
  8823                                  ComspStrLen2 equ $-ComspString-1
  8824                                  				; length of full COMSPEC
  8825                                  	; 29/01/2023
  8826                                  ;equal_sign:
  8827                                  ;equalsign:
  8828                                  ;	db '='
  8829                                  ;letter_a:
  8830                                  ;lcasea:
  8831                                  ;	db 'a'
  8832                                  ;letter_z:
  8833                                  ;lcasez:
  8834                                  ;	db 'z'
  8835                                  	; 30/01/2023
  8836                                  ;;slash_chr:
  8837                                  ;;	db '/'
  8838                                  ;;bslash_chr:
  8839                                  ;;	db '\'
  8840                                  ;space_chr:
  8841                                  ;;space:
  8842                                  ;	db 20h
  8843                                  ;;letter_p:
  8844                                  ;;	db 'p'
  8845                                  ;;letter_d:
  8846                                  ;;	db 'd'
  8847                                  ;;letter_c:
  8848                                  ;;	db 'c'
  8849                                  	; 16/04/2023
  8850                                  ; MSDOS 5.0 & MSDOS 6.0
  8851                                  ;scswitch:
  8852                                  ;	db 'C'		; Single command
  8853                                  ;;skswitch:
  8854                                  ;	db 'K' ; MSDOS 6.0
  8855                                  ;;letter_A:
  8856                                  ;ucasea: ; 21/01/2023 
  8857                                  ;	db 'A'
  8858                                  
  8859                                  	; 30/01/2023
  8860                                  EnvSiz:
  8861 00001C97 0000                    	dw 0		; size user wants to allocate
  8862                                  EnvMax:
  8863 00001C99 0000                    	dw 0		; maximum size allowed
  8864                                  OldEnv:
  8865 00001C9B 0000                    	dw 0		; envirseg at initialization
  8866                                  UsedEnv:
  8867 00001C9D 0000                    	dw 0		; amount of envirseg used
  8868                                  	; MSDOS 5.0 & MSDOS 6.0
  8869                                  PARS_MSG_OFF:
  8870 00001C9F 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE OFFSET
  8871                                  PARS_MSG_SEG:
  8872 00001CA1 0000                    	dw 0		; SAVED PARSE ERROR MESSAGE SEGMENT
  8873                                  
  8874                                  ;Do not separate the following two words. Used to call transient PARSE routine
  8875                                  
  8876                                  Init_Parse:
  8877                                  	;dw 4FFBh	; MSDOS 5.0 COMMAND.COM (TRANGROUP:APPEND_PARSE)
  8878                                  init_p:
  8879 00001CA3 [ED4D]                  	dw append_parse
  8880                                  initend:
  8881 00001CA5 0000                    	dw 0		; segment address of end of init
  8882                                  TrnSize:
  8883 00001CA7 0000                    	dw 0		; size of transient in paragraphs
  8884                                  resetenv:
  8885 00001CA9 0000                    	dw 0		; set if we need to setblck env at endinit
  8886                                  
  8887                                  ext_msg:
  8888 00001CAB 00                      	db 0		; set if /MSG switch entered
  8889                                  eswitch:
  8890 00001CAC 00                      	db 0		; set if /e was entered
  8891                                  dswitch:
  8892 00001CAD 00                      	db 0		; set if /d was entered
  8893                                  parsemes_ptr:
  8894 00001CAE 0000                    	dw 0		; word to store parse error number
  8895                                  
  8896                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  8897                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:1ED6h 
  8898                                  
  8899                                  	; MSDOS 6.0 (UINIT.ASM, 1991)
  8900                                  ;  The following parse control block is used for COMMAND. This block is
  8901                                  ;  used for parsing during initialization. The syntax for COMMAND is:
  8902                                  ;  COMMAND [/?] [d:][path][/P][/F][/D][/E:xxxxx][/MSG][/C executable]
  8903                                  ;
  8904                                  ;  Anything on the command line after the /C switch will be passed to the
  8905                                  ;  executable command, so if /C is used, it must be specified last. The
  8906                                  ;  /MSG switch can only be specified if the /P switch is specified.
  8907                                  ;
  8908                                  ;  The /? switch causes help text to be displayed. Any other options
  8909                                  ;  on the command line are ignored. Command.com will not load if /?
  8910                                  ;  is specified.
  8911                                  
  8912                                  INTERNAT_INFO:		; used for country info after parsing is completed
  8913                                  PARSE_COMMAND:
  8914 00001CB0 [B31C]                  	dw COMMAND_PARMS
  8915 00001CB2 00                      	db 0			; no extra delimiter
  8916                                  COMMAND_PARMS:
  8917 00001CB3 0002                    	db 0,2			; 1 positional parm
  8918 00001CB5 [C91C]                  	dw COMMAND_FILE
  8919 00001CB7 [C91C]                  	dw COMMAND_FILE
  8920                                          ; MSDOS 5.0
  8921 00001CB9 07                      	db 7			; 7 switches
  8922                                  	; MSDOS 6.0
  8923                                  	;db 8 			; 8 switches
  8924 00001CBA [D21C]                  	dw COMMAND_SWITCH1
  8925 00001CBC [DE1C]                  	dw COMMAND_SWITCH2
  8926 00001CBE [EA1C]                  	dw COMMAND_SWITCH3
  8927 00001CC0 [F61C]                  	dw COMMAND_SWITCH4
  8928 00001CC2 [0F1D]                  	dw COMMAND_SWITCH5
  8929 00001CC4 [1B1D]                  	dw COMMAND_SWITCH6
  8930 00001CC6 [291D]                  	dw COMMAND_SWITCH7
  8931                                  	;dw COMMAND_SWITCH8 ; MSDOS 6.0
  8932 00001CC8 00                      	db 0			; no keywords
  8933                                  
  8934                                  COMMAND_FILE:
  8935 00001CC9 0102                    	dw 0201h		; filespec - optional
  8936 00001CCB 0100                    	dw 1			; capitalize - file table
  8937 00001CCD [351D]                  	dw COMND1_OUTPUT	; result buffer
  8938 00001CCF [3D1D]                  	dw NO_VAL 		;
  8939 00001CD1 00                      	db 0			; no keywords
  8940                                  
  8941                                  COMMAND_SWITCH1:
  8942 00001CD2 0000                    	dw 0			; no match flags
  8943 00001CD4 0200                    	dw 2			; capitalize by char table
  8944 00001CD6 [351D]                  	dw COMND1_OUTPUT	; result buffer
  8945 00001CD8 [3D1D]                  	dw NO_VAL 		;
  8946 00001CDA 01                      	db 1			; 1 keyword
  8947                                  COMMAND_P_SYN:
  8948 00001CDB 2F5000                  	db '/P',0		; /P switch
  8949                                  
  8950                                  COMMAND_SWITCH2:
  8951 00001CDE 0000                    	dw 0			; no match flags
  8952 00001CE0 0200                    	dw 2			; capitalize by char table
  8953 00001CE2 [351D]                  	dw COMND1_OUTPUT	; result buffer
  8954 00001CE4 [3D1D]                  	dw NO_VAL 		;
  8955 00001CE6 01                      	db 1			; 1 keyword
  8956                                  COMMAND_F_SYN:
  8957 00001CE7 2F4600                  	db '/F',0		; /F switch
  8958                                  
  8959                                  COMMAND_SWITCH3:
  8960 00001CEA 0000                    	dw 0			; no match flags
  8961 00001CEC 0200                    	dw 2			; capitalize by char table
  8962 00001CEE [351D]                  	dw COMND1_OUTPUT	; result buffer
  8963 00001CF0 [3D1D]                  	dw NO_VAL 		;
  8964 00001CF2 01                      	db 1			; 1 keyword
  8965                                  COMMAND_D_SYN:
  8966 00001CF3 2F4400                  	db '/D',0		; /D switch
  8967                                  
  8968                                  COMMAND_SWITCH4:
  8969 00001CF6 0080                    	dw 8000h		; numeric value - required
  8970 00001CF8 0000                    	dw 0			; no function flags
  8971 00001CFA [351D]                  	dw COMND1_OUTPUT	; result buffer
  8972 00001CFC [021D]                  	dw COMMAND_E_VAL	; pointer to value list
  8973 00001CFE 01                      	db 1			; 1 keyword
  8974                                  COMMAND_E_SYN:
  8975 00001CFF 2F4500                  	db '/E',0		; /E switch
  8976                                  
  8977                                  COMMAND_E_VAL:
  8978 00001D02 01                      	db 1			;
  8979 00001D03 01                      	db 1			; 1 range
  8980 00001D04 01                      	db 1			; returned if result
  8981                                  	;dd ENVSML,ENVBIG	; minimum & maximum value
  8982                                  	; MSDOS 5.0 COMMAND.COM
  8983                                  	; (RESGROUP:1F2Bh)
  8984 00001D05 A0000000                	dd 160	 ; ENVSML
  8985 00001D09 00800000                	dd 32768 ; ENVBIG
  8986 00001D0D 00                      	db 0			; no numeric values
  8987 00001D0E 00                      	db 0			; no string values
  8988                                  
  8989                                  COMMAND_SWITCH5:
  8990 00001D0F 0000                    	dw 0			; no match flags
  8991 00001D11 0200                    	dw 2			; capitalize by char table
  8992 00001D13 [351D]                  	dw COMND1_OUTPUT	; result buffer
  8993 00001D15 [3D1D]                  	dw NO_VAL 		;
  8994 00001D17 01                      	db 1			; 1 keyword
  8995                                  COMMAND_C_SYN:
  8996 00001D18 2F4300                  	db '/C',0		; /C switch
  8997                                  
  8998                                  COMMAND_SWITCH6:
  8999 00001D1B 0000                    	dw 0			; no match flags
  9000 00001D1D 0200                    	dw 2			; capitalize by char table
  9001 00001D1F [351D]                  	dw COMND1_OUTPUT	; result buffer
  9002 00001D21 [3D1D]                  	dw NO_VAL 		;
  9003 00001D23 01                      	db 1			; 1 keyword
  9004                                  COMMAND_M_SYN:
  9005 00001D24 2F4D534700              	db '/MSG',0		; /MSG switch
  9006                                  
  9007                                  COMMAND_SWITCH7:
  9008 00001D29 0000                    	dw 0			; no match flags
  9009 00001D2B 0200                    	dw 2			; capitalize by char table
  9010 00001D2D [351D]                  	dw COMND1_OUTPUT	; result buffer
  9011 00001D2F [3D1D]                  	dw NO_VAL 		;
  9012 00001D31 01                      	db 1			; 1 keyword
  9013                                  COMMAND_?_SYN:
  9014 00001D32 2F3F00                  	db '/?',0 		; /? switch
  9015                                  
  9016                                  	; MSDOS 6.0
  9017                                  ;COMMAND_SWITCH8:
  9018                                  ;	dw 0			; no match flags
  9019                                  ;	dw 2			; capitalize by char table
  9020                                  ;	dw COMND1_OUTPUT	; result buffer
  9021                                  ;	dw NO_VAL 		;
  9022                                  ;	db 1			; 1 keyword
  9023                                  ;COMMAND_K_SYN:
  9024                                  ;	db '/K',0		; /K switch
  9025                                  
  9026                                  COMND1_OUTPUT:
  9027                                  COMND1_TYPE:
  9028 00001D35 00                      	db 0			; type
  9029                                  COMND1_CODE:
  9030 00001D36 00                      	db 0			; return value
  9031                                  COMND1_SYN:
  9032 00001D37 0000                    	dw 0			; synonym pointer
  9033                                  COMND1_ADDR:
  9034 00001D39 00000000                	dd 0			; numeric value / address
  9035                                  					; of string value
  9036                                  NO_VAL:
  9037 00001D3D 00                      	db 0			; no values
  9038                                  num_positionals:
  9039 00001D3E 0000                    	dw 0			; counter for positionals
  9040                                  old_parse_ptr:
  9041 00001D40 0000                    	dw 0			; SI position before calling parser
  9042                                  
  9043                                  	; 30/01/2023
  9044                                  ;***	INITIALIZATION MESSAGES
  9045                                  ;	-------------------------
  9046                                  ;	include	comimsg.inc	;M00
  9047                                  ;-----------------------------------------------------------------------------	
  9048                                  
  9049                                  BADVERMSG:
  9050 00001D42 17                      	db 23
  9051 00001D43 496E636F7272656374-     	db 'Incorrect DOS version',0Dh,0Ah
  9051 00001D4C 20444F532076657273-
  9051 00001D55 696F6E0D0A         
  9052                                  OUTENVMSG:
  9053 00001D5A 1A                      	db 26
  9054 00001D5B 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
  9054 00001D64 7669726F6E6D656E74-
  9054 00001D6D 2073706163650D0A   
  9055                                  COPYRIGHTMSG:
  9056 00001D75 5E                      	db 94
  9057 00001D76 0D0A                    	db 0Dh,0Ah
  9058 00001D78 0D0A                    	db 0Dh,0Ah
  9059 00001D7A 4D6963726F736F6674-     	db 'Microsoft(R) MS-DOS(R) Version 5.00',0Dh,0Ah
  9059 00001D83 285229204D532D444F-
  9059 00001D8C 532852292056657273-
  9059 00001D95 696F6E20352E30300D-
  9059 00001D9E 0A                 
  9060 00001D9F 202020202020202020-     	db '             (C)Copyright Microsoft Corp 1981-1991.',0Dh,0Ah
  9060 00001DA8 20202020284329436F-
  9060 00001DB1 70797269676874204D-
  9060 00001DBA 6963726F736F667420-
  9060 00001DC3 436F72702031393831-
  9060 00001DCC 2D313939312E0D0A   
  9061                                  BADCOMLKMES:
  9062 00001DD4 28                      	db 40
  9063 00001DD5 537065636966696564-     	db 'Specified COMMAND search directory bad',0Dh,0Ah
  9063 00001DDE 20434F4D4D414E4420-
  9063 00001DE7 736561726368206469-
  9063 00001DF0 726563746F72792062-
  9063 00001DF9 61640D0A           
  9064                                  BADCOMACCMSG:
  9065 00001DFD 36                      	db 54
  9066 00001DFE 537065636966696564-     	db 'Specified COMMAND search directory bad '
  9066 00001E07 20434F4D4D414E4420-
  9066 00001E10 736561726368206469-
  9066 00001E19 726563746F72792062-
  9066 00001E22 616420             
  9067 00001E25 616363657373206465-     	db 'access denied',0Dh,0Ah
  9067 00001E2E 6E6965640D0A       
  9068                                  HELPMSG1:
  9069 00001E34 3C                      	db 60
  9070 00001E35 537461727473206120-     	db 'Starts a new instance of the MS-DOS command interpreter.',0Dh,0Ah
  9070 00001E3E 6E657720696E737461-
  9070 00001E47 6E6365206F66207468-
  9070 00001E50 65204D532D444F5320-
  9070 00001E59 636F6D6D616E642069-
  9070 00001E62 6E7465727072657465-
  9070 00001E6B 722E0D0A           
  9071 00001E6F 0D0A                    	db 0Dh,0Ah
  9072                                  HELPMSG2:
  9073 00001E71 46                      	db 70
  9074 00001E72 434F4D4D414E44205B-     	db 'COMMAND [[drive:]path] [device] [/E:nnnnn] [/P] [/C string] [/MSG]'
  9074 00001E7B 5B64726976653A5D70-
  9074 00001E84 6174685D205B646576-
  9074 00001E8D 6963655D205B2F453A-
  9074 00001E96 6E6E6E6E6E5D205B2F-
  9074 00001E9F 505D205B2F43207374-
  9074 00001EA8 72696E675D205B2F4D-
  9074 00001EB1 53475D             
  9075 00001EB4 0D0A                    	db 0Dh,0Ah
  9076 00001EB6 0D0A                    	db 0Dh,0Ah
  9077                                  HELPMSG3:
  9078 00001EB8 48                              db 72
  9079 00001EB9 20205B64726976653A-     	db '  [drive:]path    Specifies the directory containing COMMAND.COM '
  9079 00001EC2 5D7061746820202020-
  9079 00001ECB 537065636966696573-
  9079 00001ED4 207468652064697265-
  9079 00001EDD 63746F727920636F6E-
  9079 00001EE6 7461696E696E672043-
  9079 00001EEF 4F4D4D414E442E434F-
  9079 00001EF8 4D20               
  9080 00001EFA 66696C652E0D0A          	db 'file.',0Dh,0Ah
  9081                                  HELPMSG4:
  9082 00001F01 4D                      	db 77
  9083 00001F02 202064657669636520-     	db '  device          Specifies the device to use for command input and '
  9083 00001F0B 202020202020202020-
  9083 00001F14 537065636966696573-
  9083 00001F1D 207468652064657669-
  9083 00001F26 636520746F20757365-
  9083 00001F2F 20666F7220636F6D6D-
  9083 00001F38 616E6420696E707574-
  9083 00001F41 20616E6420         
  9084 00001F46 6F75747075742E0D0A      	db 'output.',0Dh,0Ah
  9085                                  HELPMSG5:
  9086 00001F4F 45                      	db 69
  9087 00001F50 20202F453A6E6E6E6E-     	db '  /E:nnnnn        Sets the initial environment size to nnnnn bytes.'
  9087 00001F59 6E2020202020202020-
  9087 00001F62 536574732074686520-
  9087 00001F6B 696E697469616C2065-
  9087 00001F74 6E7669726F6E6D656E-
  9087 00001F7D 742073697A6520746F-
  9087 00001F86 206E6E6E6E6E206279-
  9087 00001F8F 7465732E           
  9088 00001F93 0D0A                    	db 0Dh,0Ah
  9089                                  HELPMSG6:
  9090 00001F95 4D                      	db 77
  9091 00001F96 20202F502020202020-     	db '  /P              Makes the new command interpreter permanent '
  9091 00001F9F 202020202020202020-
  9091 00001FA8 4D616B657320746865-
  9091 00001FB1 206E657720636F6D6D-
  9091 00001FBA 616E6420696E746572-
  9091 00001FC3 707265746572207065-
  9091 00001FCC 726D616E656E7420   
  9092 00001FD4 2863616E2774206578-     	db '(can',27h,'t exit).',0Dh,0Ah
  9092 00001FDD 6974292E0D0A       
  9093                                  HELPMSG7:
  9094 00001FE3 50                      	db 80
  9095 00001FE4 20202F432073747269-     	db '  /C string       Carries out the command specified by string, and '
  9095 00001FED 6E6720202020202020-
  9095 00001FF6 43617272696573206F-
  9095 00001FFF 75742074686520636F-
  9095 00002008 6D6D616E6420737065-
  9095 00002011 636966696564206279-
  9095 0000201A 20737472696E672C20-
  9095 00002023 616E6420           
  9096 00002027 7468656E2073746F70-     	db 'then stops.',0Dh,0Ah
  9096 00002030 732E0D0A           
  9097                                  HELPMSG8:
  9098 00002034 4E                      	db 78
  9099 00002035 20202F4D5347202020-     	db '  /MSG            Specifies that all error messages be stored in '
  9099 0000203E 202020202020202020-
  9099 00002047 537065636966696573-
  9099 00002050 207468617420616C6C-
  9099 00002059 206572726F72206D65-
  9099 00002062 737361676573206265-
  9099 0000206B 2073746F7265642069-
  9099 00002074 6E20               
  9100 00002076 6D656D6F72792E2059-     	db 'memory. You',0Dh,0Ah
  9100 0000207F 6F750D0A           
  9101                                  HELPMSG9:
  9102 00002083 38                      	db 56
  9103 00002084 202020202020202020-     	db '                  need to specify /P with this switch.',0Dh,0Ah
  9103 0000208D 202020202020202020-
  9103 00002096 6E65656420746F2073-
  9103 0000209F 706563696679202F50-
  9103 000020A8 207769746820746869-
  9103 000020B1 73207377697463682E-
  9103 000020BA 0D0A               
  9104                                  HelpMsgs:
  9105 000020BC [341E]                          dw HELPMSG1
  9106 000020BE [711E]                  	dw HELPMSG2
  9107 000020C0 [B81E]                  	dw HELPMSG3
  9108 000020C2 [011F]                  	dw HELPMSG4
  9109 000020C4 [4F1F]                  	dw HELPMSG5
  9110 000020C6 [951F]                  	dw HELPMSG6
  9111 000020C8 [E31F]                  	dw HELPMSG7
  9112 000020CA [3420]                  	dw HELPMSG8
  9113 000020CC [8320]                  	dw HELPMSG9
  9114                                  
  9115                                  	; 23/04/2023
  9116 000020CE 0000                    	dw 0
  9117                                  
  9118                                  ;-----------------------------------------------------------------------------
  9119                                  
  9120                                  ;SR;
  9121                                  ; This table of offsets is used by the init code to calculate the new offsets
  9122                                  ;for these labels after the resident code has been relocated
  9123                                  
  9124                                  ;Reloc_Table:
  9125                                  	;dw offset CODERES:MsgInt2fHandler
  9126                                  	;dw offset CODERES:Int_2e
  9127                                  	;dw offset CODERES:ContC
  9128                                  	;dw offset CODERES:DskErr
  9129                                  	;dw offset CODERES:Exec_Ret
  9130                                  	;dw offset CODERES:TRemCheck
  9131                                  	;dw offset CODERES:TrnLodCom1
  9132                                  	;dw offset CODERES:LodCom
  9133                                  	;dw offset CODERES:MsgRetriever
  9134                                  	;dw offset CODERES:THeadFix
  9135                                  	;dw offset CODERES:Lh_OffUnlink	; M003
  9136                                  
  9137                                  	; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9138                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:22F6h
  9139                                  
  9140                                  Reloc_Table:			          ; MSDOS 5.0 CODERES address
  9141 000020D0 2207                    	dw MsgInt2fHandler - RCODE_START  ; 738h
  9142 000020D2 7501                    	dw Int_2e - RCODE_START		  ; 177h	
  9143 000020D4 3300                    	dw ContC - RCODE_START		  ; 035h
  9144 000020D6 3604                    	dw DSKERR - RCODE_START		  ; 445h
  9145 000020D8 2700                    	dw Exec_Ret - RCODE_START	  ; 029h
  9146 000020DA 9902                    	dw TRemCheck - RCODE_START	  ; 2A3h
  9147 000020DC 1304                    	dw TrnLodCom1 - RCODE_START	  ; 422h
  9148 000020DE AC01                    	dw LodCom - RCODE_START		  ; 1AEh
  9149 000020E0 6507                    	dw MsgRetriever - RCODE_START	  ; 77Bh
  9150 000020E2 B802                    	dw THeadFix - RCODE_START	  ; 2C2h
  9151 000020E4 DE07                    	dw Lh_OffUnlink - RCODE_START	  ; 7F4h
  9152                                  
  9153                                  NUM_RELOC_ENTRIES equ ($-Reloc_Table)/2
  9154                                  
  9155                                  ResJmpTable:
  9156 000020E6 00000000                	dd 0			; stores prev stub jump table addr
  9157                                  FirstCom:
  9158 000020EA 00                      	db 0			; flag set if first command.com
  9159                                  DevFlag:
  9160 000020EB 00                      	db 0
  9161                                  PathFlag:
  9162 000020EC 00                      	db 0
  9163                                  
  9164                                  	; MSDOS 5.0 COMMAND.COM - RESGROUP:2313h
  9165                                  	;times 13 db 0
  9166                                  
  9167                                  ; 30/01/2023
  9168                                  coderes_end equ $
  9169                                  
  9170                                  ;INIT	ENDS
  9171                                  
  9172                                  ;	END
  9173                                  
  9174                                  ;-----------------------------------------------------------------------------
  9175                                  ; 14/10/2018 (Retro DOS v3.0 COMMAND.COM Signature)
  9176                                  ;-----------------------------------------------------------------------------
  9177                                  
  9178                                  ;db	"Retro DOS v3.0 COMMAND.COM by Erdogan Tan [2018]"
  9179                                  	; 30/01/2023
  9180 000020ED 00                      db	0
  9181 000020EE 526574726F20444F53-     db	"Retro DOS v4.0 COMMAND.COM by Erdogan Tan [2023]"		
  9181 000020F7 2076342E3020434F4D-
  9181 00002100 4D414E442E434F4D20-
  9181 00002109 6279204572646F6761-
  9181 00002112 6E2054616E205B3230-
  9181 0000211B 32335D             
  9182 0000211E 00                      db	0
  9183                                  
  9184                                  ;-----------------------------------------------------------------------------
  9185                                  ; 24/09/2018 (Retro DOS v3.0 COMMAND)
  9186                                  ;-----------------------------------------------------------------------------
  9187                                  
  9188                                  ;TAIL    SEGMENT PUBLIC PARA
  9189                                  ;        ORG     0
  9190                                  ;TRANSTART LABEL WORD
  9191                                  ;TAIL    ENDS
  9192                                  
  9193                                  ;ALIGN 16  ; 25/09/2018
  9194                                  
  9195                                  ; 30/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9196                                  
  9197                                  numbertodiv equ ($-StartCode)+100h ; 16/04/2023
  9198                                  numbertomod equ (numbertodiv % 16)
  9199                                  
  9200                                  %if numbertomod>0 & numbertomod<16
  9201 0000211F 00                      	times (16-numbertomod) db 0
  9202                                  %endif
  9203                                  
  9204                                  ; 30/01/2023
  9205                                  ;TRANSTART:
  9206                                  
  9207                                  ; 21/04/2018 (Retro DOS v2.0 COMMAND)
  9208                                  ;	times	128 db 0	
  9209                                  
  9210                                  ;-----------------------------------------------------------------------------
  9211                                  ; SEGMENT - TRANSCODE
  9212                                  ;-----------------------------------------------------------------------------
  9213                                  
  9214                                  ;TRANGROUP: ; 21/04/2018
  9215                                  
  9216                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9217                                  ;-----------------------------------------------------------------------------
  9218                                  
  9219                                  ; MSDOS 3.3 COMMAND.COM Transient Portion Addresses
  9220                                  
  9221                                  ; 21/04/2018 - Retro DOS v2.0
  9222                                  ; transcom.s (COMMAND.COM source file 2 of 2) code/data addresses 
  9223                                  ; (these values must be changed when transcom.s source code is changed
  9224                                  ; and data offsets are changed)
  9225                                  ;
  9226                                  ; 30/04/2018
  9227                                  ; 29/04/2018
  9228                                  
  9229                                  ; 24/09/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9230                                  ;COMMAND      EQU  012CH
  9231                                  ;DATINIT      EQU  2091H
  9232                                  ;HEADCALL     EQU  428FH
  9233                                  ;TRANSPACEEND EQU  4D5CH
  9234                                  ;TRANDATAEND  EQU  3F44H
  9235                                  
  9236                                  ; 29/04/2018 (original MSDOS 3.3 COMMAND.COM TrnSeg offset addresses)
  9237                                  ;TRIAGE_INIT  EQU  1F15H
  9238                                  ;PRINTF_INIT  EQU  34E0H 
  9239                                  
  9240                                  ;GETEXTERRNUM EQU  1EEEH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr	
  9241                                  
  9242                                  ;TPA	EQU  4293H
  9243                                  ;TRNLEN	EQU  04D6H
  9244                                  
  9245                                  ; 20/10/2018 - Retro DOS v3.0 COMMAND.COM transient portion addresses
  9246                                  ;COMMAND      EQU  012CH
  9247                                  ;DATINIT      EQU  206FH
  9248                                  ;HEADCALL     EQU  426FH
  9249                                  ; 09/01/2023
  9250                                  ;TRANSPACEEND EQU  4D3CH
  9251                                  ;TRANDATAEND  EQU  3F24H
  9252                                  ;TRIAGE_INIT  EQU  1EF3H
  9253                                  ;PRINTF_INIT  EQU  34BFH 
  9254                                  ;
  9255                                  ;GETEXTERRNUM EQU  1ECCH  ; TRIAGEERROR (GET_EXT_ERR_NUMBER) proc addr
  9256                                  
  9257                                  ;-----------------------------------------------------------------------------
  9258                                  ; ARENA.INC, MSDOS 6.0, 1991
  9259                                  ;-----------------------------------------------------------------------------
  9260                                  ; 13/10/2018 - Retro DOS 3.0
  9261                                  ; 17/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9262                                  
  9263                                  ;BREAK <Memory arena structure>
  9264                                  
  9265                                  ; (-*-) Same with MSDOS 2.11 & MSDOS 6.0
  9266                                  
  9267                                  ; arena item
  9268                                  
  9269                                  struc ARENA
  9270 00000000 ??                        .signature:	resb 1		; 4D for valid item, 5A for last item
  9271 00000001 ????                      .owner:	resw 1		; owner of arena item
  9272 00000003 ????                      .size:	resw 1		; size in paragraphs of item
  9273                                  endstruc
  9274                                  
  9275                                  ;-----------------------------------------------------------------------------
  9276                                  ;START OF TRANSIENT PORTION
  9277                                  ;This code is loaded at the end of memory and may be overwritten by
  9278                                  ;memory-intensive user programs.
  9279                                  ;-----------------------------------------------------------------------------
  9280                                  
  9281                                  ; 16/04/2023
  9282                                  TRANSTART EQU ($-StartCode)+100h ; 18/04/2023
  9283                                  ; 29/09/2018
  9284                                  ; 31/01/2023 
  9285                                  ;TRANSTART:		; Offset 1660h in original MSDOS 3.3 COMMAND.COM
  9286                                  			; 09/01/2023
  9287                                  			; Offset 2320h in original MSDOS 5.0 COMMAND.COM
  9288                                  
  9289                                  ; 25/09/2018
  9290                                  ; (original MSDOS 3.3 COMMAND.COM TRIAGEERROR offset address)
  9291                                  ;
  9292                                  ; 'GET_EXT_ERR_NUMBER' ('TRIAGEERROR') procedure is at offset 354Eh 
  9293                                  ; in MSDOS 3.3 COMMAND.COM (It is at offset 1EEEh in transient porsion).	 	
  9294                                  ;
  9295                                  ;TRIAGEERROR EQU TRANSTART+GETEXTERRNUM-100H
  9296                                  ;
  9297                                  ;
  9298                                  ;COMTRANS:
  9299                                  ;
  9300                                  ; 20/10/2018 - Retro DOS v3.0	
  9301                                  ;INCBIN	"TRANCOM3.BIN"
  9302                                  ;
  9303                                  ;COMLEN	EQU $-COMTRANS ; End of COMMAND load.
  9304                                  ;
  9305                                  ; 29/04/2018
  9306                                  ;BSS_SIZE EQU TRANSPACEEND-TRANDATAEND	
  9307                                  ;
  9308                                  ;TIMES BSS_SIZE db 0
  9309                                  ;
  9310                                  ;COMLEN	EQU $-COMTRANS ; 30/04/2018
  9311                                  
  9312                                  ;COMMANDCOMSIZE equ $ - 100h
  9313                                  
  9314                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9315                                  ; ============================================================================
  9316                                  ; --- ('trancom5.s', 31/01/2023 - modified from 'trancom3.s', 20/10/2018) ----
  9317                                  ; ============================================================================
  9318                                  
  9319                                  ; ----------------------------------------------------------------------------
  9320                                  ; START OF TRANSIENT PORTION
  9321                                  ; ----------------------------------------------------------------------------
  9322                                  ; SEGMENT - TRANSCODE
  9323                                  ; ----------------------------------------------------------------------------
  9324                                  
  9325                                  ; 18/04/2023
  9326                                  section .TRANGROUP  vstart=0  ; 31/01/2023 - Retro DOS v4.0 (& v4.1) 
  9327                                  
  9328                                  ; 18/04/2023
  9329                                  ;-----------------------------------------------------------------------------
  9330                                  ; TRANSCODE segment offset 0
  9331                                  TRANSIENTSTART:
  9332                                  
  9333                                  	; 31/01/2023
  9334 00000000 00<rep 100h>            	times 256 db 0		; Allow for 100H parameter area
  9335                                  
  9336                                  ;============================================================================
  9337                                  ; TCODE.ASM, MSDOS 6.0, 1991
  9338                                  ;============================================================================
  9339                                  ; 12/10/2018 - Retro DOS v3.0
  9340                                  ; 31/01/2023 - Retro DOS v4.0 (& v4.1)
  9341                                  
  9342                                  ;[ORG 100h]
  9343                                  
  9344                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0100h
  9345                                  
  9346                                  ; ---------------------------------------------------------------------------
  9347                                  		
  9348                                  		; 31/01/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9349                                  		; (TRANGROUP:0100h)
  9350                                  SETDRV:
  9351 00000100 B40E                    	mov	ah,0Eh
  9352                                  	;mov	ah,SET_DEFAULT_DRIVE ; 0Eh
  9353 00000102 CD21                    	int	21h	; DOS -	SELECT DISK
  9354                                  			; DL = new default drive number
  9355                                  			;		(0 = A, 1 = B, ..)
  9356                                  			; Return: AL = number of logical drives
  9357                                  
  9358                                  ; ---------------------------------------------------------------------------
  9359                                  
  9360                                  ; TCOMMAND is the recycle point in COMMAND. Nothing is known here.
  9361                                  ; No registers (CS:IP) no flags, nothing.
  9362                                  
  9363                                  TCOMMAND:
  9364 00000104 2E8E1E[9C8A]            	mov	ds,[cs:RESSEG]
  9365 00000109 B8FFFF                  	mov	ax,-1
  9366 0000010C 8706[A801]              	xchg	ax,[VerVal]
  9367 00000110 83F8FF                  	cmp	ax,-1
  9368 00000113 7404                    	je	short NOSETVER2
  9369 00000115 B42E                    	mov	ah,2Eh
  9370                                  	;mov	ah,SET_VERIFY_ON_WRITE ; 2Eh
  9371 00000117 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
  9372                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
  9373                                  NOSETVER2:
  9374 00000119 2EFF1E[9A8A]            	call	far [cs:HEADCALL]   ; Make sure header fixed
  9375 0000011E 31ED                    	xor	bp,bp		    ; Flag transient not read
  9376 00000120 833E[A601]FF            	cmp	word [SingleCom],-1
  9377 00000125 7505                    	jne	short COMMAND
  9378                                  _$EXITPREP:
  9379 00000127 0E                      	push	cs
  9380 00000128 1F                      	pop	ds
  9381 00000129 E91920                  	jmp	_$EXIT		; Have finished the single command
  9382                                  
  9383                                  ; ---------------------------------------------------------------------------
  9384                                  ;
  9385                                  ; Main entry point from resident portion.
  9386                                  ;
  9387                                  ;   If BP <> 0, then we have just loaded transient portion otherwise we are
  9388                                  ;   just beginning the processing of another command.
  9389                                  ;
  9390                                  ; ---------------------------------------------------------------------------
  9391                                  
  9392                                  ; We are not always sure of the state of the world at this time. We presume
  9393                                  ; worst case and initialize the relevant registers: segments and stack.
  9394                                  
  9395                                  COMMAND:
  9396 0000012C FC                      	cld
  9397 0000012D 8CC8                    	mov	ax,cs
  9398 0000012F FA                      	cli
  9399 00000130 8ED0                    	mov	ss,ax
  9400                                  	;mov	sp,offset TRANGROUP:STACK
  9401                                  				; 07/06/2023
  9402 00000132 BC[7A95]                	mov	sp,STACK	; 09854h for MSDOS 5.0 COMMAND.COM
  9403                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9404 00000135 FB                      	sti
  9405                                  		
  9406 00000136 8EC0                    	mov	es,ax
  9407                                  		
  9408                                  	; MSDOS 6.0
  9409 00000138 8ED8                    	mov	ds,ax		;AN000; set DS to transient
  9410                                  	;ASSUME	ES:TRANGROUP,DS:TRANGROUP ;AC000;
  9411                                  	;invoke	TSYSLOADMSG	;AN000; preload messages
  9412                                  	; 31/01/2023
  9413 0000013A E8A74D                  	call	TSYSLOADMSG
  9414 0000013D C606[118E]00            	mov	byte [append_exec],0 ;AN041; set internal append state off
  9415                                  
  9416                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9417                                  	;mov	ds,[ss:RESSEG]
  9418                                  	; 31/01/2023
  9419 00000142 8E1E[9C8A]              	mov	ds,[RESSEG]
  9420 00000146 36C606[7888]80          	mov	byte [ss:UCOMBUF],128 ; Init UCOMBUF	
  9421 0000014C 36C606[FB88]80          	mov	byte [ss:COMBUF],128  ; Init COMBUF (Autoexec doing DATE)
  9422                                  
  9423                                  ; If we have just loaded the transient, then we do NOT need to initialize the
  9424                                  ; command buffer. ????  DO WE NEED TO RESTORE THE USERS DIRECTORY ????
  9425                                  ; I guess not: the only circumstances in which we reload the command processor
  9426                                  ; is after a transient program execution. In this case, we let the current
  9427                                  ; directory lie where it may.
  9428                                  
  9429 00000152 09ED                    	or	bp,bp		; See if just read
  9430 00000154 7409                    	jz	short TESTRDIR	; Not read, check user directory
  9431 00000156 36C706[7988]010D        	mov	word [ss:UCOMBUF+1],0D01h ; Reset buffer
  9432 0000015D EB17                    	jmp	short NOSETBUF
  9433                                  TESTRDIR:
  9434 0000015F 803E[A401]00            	cmp	byte [RestDir],0
  9435 00000164 7410                    	jz	short NOSETBUF	; User directory OK
  9436 00000166 1E                      	push	ds
  9437                                  
  9438                                  ; We have an unusual situation to handle. The user *may* have changed his
  9439                                  ; directory as a result of an internal command that got aborted. Restoring it
  9440                                  ; twice may not help us: the problem may never go away. We just attempt it
  9441                                  ; once and give up.
  9442                                  
  9443 00000167 C606[A401]00            	mov	byte [RestDir],0 ; Flag users dirs OK
  9444                                  
  9445                                  	; Restore users directory
  9446 0000016C 0E                      	push	cs
  9447 0000016D 1F                      	pop	ds
  9448 0000016E BA[7E89]                	mov	dx,USERDIR1
  9449 00000171 B43B                    	mov	ah,3Bh
  9450                                  	;mov	ah,CHDir ; 3Bh
  9451 00000173 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
  9452                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
  9453 00000175 1F                      	pop	ds
  9454                                  NOSETBUF:
  9455 00000176 803E[1902]00            	cmp	byte [PipeFiles],0
  9456 0000017B 740A                    	jz	short NOPCLOSE	; Don't bother if they don't exist
  9457 0000017D 803E[1802]00            	cmp	byte [PipeFlag],0
  9458 00000182 7503                    	jnz	short NOPCLOSE	; Don't del if still piping
  9459 00000184 E8612B                  	call	PIPEDEL
  9460                                  NOPCLOSE:
  9461                                  	;mov	byte [0BE9h],0	; MSDOS 3.3
  9462                                  	; 31/01/2023
  9463 00000187 C606[9C01]00            	mov	byte [ExtCom],0 ; Flag internal command
  9464 0000018C 8CC8                    	mov	ax,cs		; Get segment we're in
  9465 0000018E 8ED8                    	mov	ds,ax
  9466 00000190 50                      	push	ax
  9467                                  			; 07/06/2023 (INTERNATVARS addr = STACK addr)
  9468 00000191 BA[7A95]                	mov	dx,INTERNATVARS ; 09854h for MSDOS 5.0 COMMAND.COM
  9469                                  				; 0AF24h for MSDOS 6.22 COMMAND.COM
  9470 00000194 B80038                  	mov	ax,3800h
  9471                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
  9472 00000197 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
  9473                                  			; get current-country info
  9474                                  			; DS:DX	-> buffer for returned info
  9475 00000199 58                      	pop	ax
  9476 0000019A 2B06[9E8A]              	sub	ax,[TPA]	; AX=size of TPA in paragraphs
  9477 0000019E 53                      	push	bx
  9478 0000019F BB1000                  	mov	bx,16
  9479 000001A2 F7E3                    	mul	bx		; DX:AX=size of TPA in bytes
  9480 000001A4 5B                      	pop	bx
  9481 000001A5 09D2                    	or	dx,dx		; See if over 64K
  9482 000001A7 7403                    	jz	short SAVSIZ	; OK if not
  9483 000001A9 B8FFFF                  	mov	ax,-1		; If so, limit to 65535 bytes
  9484                                  SAVSIZ:
  9485                                  
  9486                                  ; AX is the number of bytes free in the buffer between the resident and the
  9487                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
  9488                                  
  9489 000001AC 3D0002                  	cmp	ax,512
  9490 000001AF 7603                    	jbe	short GOTSIZE
  9491                                  	;and	ax,~1FFh
  9492 000001B1 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FF
  9493                                  GOTSIZE:
  9494 000001B4 A3[BD8A]                	mov	[BYTCNT],ax	; Max no. of bytes that can be buffered
  9495 000001B7 8E1E[9C8A]              	mov	ds,[RESSEG]	; All batch work must use resident seg.
  9496                                  
  9497 000001BB F606[A001]01            	test	byte [EchoFlag],1 
  9498 000001C0 741E                    	jz	short GETCOM	; Don't do the CRLF
  9499 000001C2 E8022B                  	call	SINGLETEST
  9500 000001C5 7219                    	jb	short GETCOM
  9501 000001C7 F606[1802]FF            	test	byte [PipeFlag],0FFh ; -1
  9502 000001CC 7512                    	jnz	short GETCOM
  9503                                  				; G  Don't print prompt in FOR
  9504 000001CE F606[AC01]FF            	test	byte [ForFlag],0FFh ; -1
  9505 000001D3 750B                    	jnz	short GETCOM
  9506                                  				; G  Don't print prompt if in batch
  9507 000001D5 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; -1
  9508 000001DB 7503                    	jnz	short GETCOM
  9509 000001DD E8EA23                  	call	CRLF2
  9510                                  GETCOM:
  9511 000001E0 C606[B101]00            	mov	byte [Call_Flag],0 ; G Reset call flags
  9512 000001E5 C606[B201]00            	mov	byte [Call_Batch_Flag],0
  9513 000001EA B419                    	mov	ah,19h
  9514                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
  9515 000001EC CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
  9516 000001EE 36A2[B08A]              	mov	[ss:CURDRV],al
  9517 000001F2 F606[1802]FF            	test	byte [PipeFlag],0FFh ; -1 ; Pipe has highest presedence
  9518 000001F7 7403                    	jz	short NOPIPE
  9519 000001F9 E9B72B                  	jmp	PIPEPROC	; Continue the pipeline
  9520                                  NOPIPE:
  9521 000001FC F606[A001]01            	test	byte [EchoFlag],1
  9522 00000201 7417                    	jz	short NOPDRV	; No prompt if echo off
  9523 00000203 E8C12A                  	call	SINGLETEST
  9524 00000206 7212                    	jb	short NOPDRV
  9525 00000208 F606[AC01]FF            	test	byte [ForFlag],0FFh ; G  Don't print prompt in FOR	
  9526 0000020D 750B                    	jnz	short NOPDRV
  9527 0000020F F706[4C01]FFFF          	test	word [Batch],0FFFFh ; G  Don't print prompt if in batch
  9528 00000215 750D                    	jnz	short TESTFORBAT
  9529 00000217 E8721B                  	call	PRINT_PROMPT	; Prompt the user
  9530                                  NOPDRV:
  9531 0000021A F606[AC01]FF            	test	byte [ForFlag],0FFh ; FOR has next highest precedence
  9532 0000021F 7403                    	jz	short TESTFORBAT
  9533 00000221 E9BD0B                  	jmp	FORPROC		; Continue the FOR
  9534                                  
  9535                                  TESTFORBAT:
  9536 00000224 36C606[478A]00          	mov	byte [ss:RE_INSTR],0 ; Turn redirection back off	
  9537 0000022A C606[C701]00            	mov	byte [Re_OutStr],0  ; [0C09h] for MSDOS 3.3 
  9538 0000022F C606[C601]00            	mov	byte [Re_Out_App],0 ; [0C08h] for MSDOS 3.3
  9539 00000234 C606[AB01]00            	mov	byte [IfFlag],0	; no more ifs...
  9540 00000239 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; Batch has lowest precedence
  9541 0000023F 7441                    	jz	short ISNOBAT
  9542                                  
  9543                                  	; 31/01/2023
  9544                                  
  9545                                  	; MSDOS 6.0
  9546                                  
  9547                                  ;	Bugbug:	MULT_SHELL_GET no longer used?
  9548                                  
  9549 00000241 06                      	push	es			;AN000; save ES
  9550 00000242 1E                      	push	ds			;AN000; save DS
  9551                                  	;mov	ax,mult_shell_get	;AN000; check to see if SHELL has command
  9552                                  	; 05/02/2023
  9553 00000243 B80219                  	mov	ax,1902h
  9554 00000246 8E06[4C01]              	mov	es,[Batch]		;AN000; get batch segment
  9555                                  	;mov	di,20h
  9556 0000024A BF2000                  	mov	di,BATCHSEGMENT.BatFile	;AN000; get batch file name
  9557 0000024D 0E                      	push	cs			;AN000; get local segment to DS
  9558 0000024E 1F                      	pop	ds			;AN000;
  9559                                  	;mov	dx,offset trangroup:combuf ;AN000; pass communications buffer
  9560 0000024F BA[FB88]                	mov	dx,COMBUF
  9561 00000252 CD2F                    	int	2Fh			;AN000; call the shell
  9562                                  		; - Multiplex - DOS 4.x only SHELLB.COM - COMMAND.COM INTERFACE
  9563                                  		; ES:DI -> ASCIZ full filename of current batch file, with at least the
  9564                                  		; final filename element uppercased
  9565                                  		; DS:DX -> buffer for results
  9566                                  	;cmp	al,0FFh
  9567 00000254 3CFF                    	cmp	al,shell_action 	;AN000; does shell have a commmand?
  9568 00000256 1F                      	pop	ds			;AN000; restore DS
  9569 00000257 07                      	pop	es			;AN000; restore ES
  9570 00000258 7424                    	jz	short JDOCOM1		;AN000; yes - go process command
  9571                                  
  9572                                  	; MSDOS 3.3 (& MSDOS 6.0)
  9573 0000025A 1E                      	push	ds
  9574 0000025B E81603                  	call	READBAT			; Continue BATCH
  9575 0000025E 1F                      	pop	ds
  9576 0000025F C606[B501]00            	mov	byte [NullFlag],0	;G reset no command flag
  9577 00000264 F706[4C01]FFFF          	test	word [Batch],0FFFFh
  9578 0000026A 7512                    	jnz	short JDOCOM1		;G if batch still in progress continue
  9579 0000026C 8B1E[B301]              	mov	bx,[Next_Batch]
  9580                                  	; 31/01/2023
  9581 00000270 09DB                    	or	bx,bx
  9582                                  	;cmp	bx,0			;G see if there is a new batch file
  9583 00000272 740A                    	jz	short JDOCOM1		;G no - go do command
  9584 00000274 891E[4C01]              	mov	[Batch],bx		;G get segment of next batch file
  9585 00000278 C706[B301]0000          	mov	word [Next_Batch],0	;G reset next batch
  9586                                  JDOCOM1:
  9587 0000027E 0E                      	push	cs
  9588 0000027F 1F                      	pop	ds
  9589 00000280 EB55                    	jmp	short DOCOM1
  9590                                  ISNOBAT:
  9591 00000282 833E[A601]00            	cmp	word [SingleCom],0
  9592 00000287 741C                    	jz	short REGCOM
  9593                                  	;mov	si,[SEMIPERMCOM] ;  MSDOS 6.0
  9594 00000289 BEFFFF                  	mov	si,0FFFFh 	 ;  MSDOS 3.3 & MSDOS 5.0
  9595 0000028C 8736[A601]              	xchg	si,[SingleCom]
  9596 00000290 BF[FD88]                	mov	di,COMBUF+2
  9597 00000293 31C9                    	xor	cx,cx
  9598                                  SINGLELOOP:
  9599 00000295 AC                      	lodsb
  9600 00000296 AA                      	stosb
  9601 00000297 41                      	inc	cx
  9602 00000298 3C0D                    	cmp	al,0Dh
  9603 0000029A 75F9                    	jnz	short SINGLELOOP
  9604 0000029C 49                      	dec	cx
  9605 0000029D 0E                      	push	cs
  9606 0000029E 1F                      	pop	ds
  9607 0000029F 880E[FC88]              	mov	[COMBUF+1],cl
  9608                                  
  9609                                  ; do NOT issue a trailing CRLF...
  9610                                  
  9611 000002A3 EB32                    	jmp	short DOCOM1
  9612                                  
  9613                                  	;nop
  9614                                  
  9615                                  	; 31/01/2023 - Retro DOS v4.0 COMMAND.COM
  9616                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:02A6h
  9617                                  
  9618                                  ; We have a normal command.  
  9619                                  ; Printers are a bizarre quantity. Sometimes they are a stream and
  9620                                  ; sometimes they aren't. At this point, we automatically close all spool
  9621                                  ; files and turn on truncation mode.
  9622                                  
  9623                                  REGCOM:
  9624                                  	;mov	ax,(ServerCall shl 8) + 9
  9625                                  	; 31/01/2023
  9626 000002A5 B8095D                  	mov	ax,5D09h
  9627                                  	;mov	ax,(SERVERCALL<<8)+9
  9628 000002A8 CD21                    	int	21h	; DOS -	3.1+ internal -	FLUSH REDIRECTED PRINTER OUTPUT
  9629                                  	;mov	ax,(ServerCall shl 8) + 8
  9630 000002AA B8085D                  	mov	ax,5D08h
  9631                                  	;mov	ax,(SERVERCALL<<8)+8
  9632 000002AD B201                    	mov	dl,1
  9633 000002AF CD21                    	int	21h	; DOS -	3.1+ internal -	SET REDIRECTED PRINTER MODE
  9634                                  			; DL = 00h redirected output is	combined
  9635                                  			;      01h redirected output placed in separate	jobs
  9636                                  			; start	new print job now
  9637 000002B1 0E                      	push	cs
  9638 000002B2 1F                      	pop	ds	; Need local segment to point to buffer
  9639 000002B3 BA[7888]                	mov	dx,UCOMBUF
  9640                                  
  9641                                  	; MSDOS 6.0
  9642                                  ;	Try to read interactive command line via DOSKey.
  9643                                  ;	If that fails, use DOS Buffered Keyboard Input.
  9644                                  
  9645                                  	; 31/01/2023
  9646 000002B6 B81048                  	mov	ax,4810h	; AX = DOSKey Read Line function
  9647 000002B9 CD2F                    	int	2Fh
  9648 000002BB 09C0                    	or	ax,ax
  9649 000002BD 7404                    	jz	short GOTCOM	; DOSKey gave us a command line
  9650                                  
  9651 000002BF B40A                    	mov	ah,0Ah
  9652                                  	;mov	ah,Std_Con_String_Input	; AH = DOS Buffered Keyboard Input
  9653 000002C1 CD21                    	int	21h	; DOS -	BUFFERED KEYBOARD INPUT
  9654                                  			; DS:DX	-> buffer
  9655                                  GOTCOM:
  9656 000002C3 8A0E[7888]              	mov	cl,[UCOMBUF]
  9657 000002C7 30ED                    	xor	ch,ch
  9658 000002C9 83C103                  	add	cx,3
  9659 000002CC BE[7888]                	mov	si,UCOMBUF
  9660 000002CF BF[FB88]                	mov	di,COMBUF
  9661 000002D2 F3A4                    	rep	movsb		; Transfer it to the cooked buffer
  9662                                  DOCOM:
  9663 000002D4 E8F322                  	call	CRLF2
  9664                                  DOCOM1:
  9665 000002D7 E87726                  	call	PRESCAN		; Cook the input buffer
  9666 000002DA 7406                    	jz	short NOPIPEPROC
  9667 000002DC E9532A                  	jmp	PIPEPROCSTRT	; Fire up the pipe
  9668                                  
  9669                                  NULLCOMJ:
  9670 000002DF E9FA00                  	jmp	NULLCOM
  9671                                  
  9672                                  NOPIPEPROC:
  9673 000002E2 E84B2D                  	call	PARSELINE
  9674 000002E5 730B                    	jnb	short OKPARSE	; user error? or maybe we goofed?
  9675                                  BADPARSE:
  9676 000002E7 0E                      	push	cs
  9677 000002E8 1F                      	pop	ds
  9678 000002E9 BA[547F]                	mov	dx,BADNAM_PTR	; 31/01/2023
  9679 000002EC E80C4B                  	call	std_eprintf
  9680 000002EF E912FE                  	jmp	TCOMMAND
  9681                                  
  9682                                  OKPARSE:
  9683                                  	;test	byte [ARGV0_ARG_FLAGS],2
  9684                                  	;test	byte [ARG+ARGV_ELE.argflags],2 ; wildcard
  9685                                  	; 01/02/2023
  9686 000002F2 F606[2D8E]02            	test	byte [ARG+ARGV_ELE.argflags],2
  9687 000002F7 75EE                    	jnz	short BADPARSE	; ambiguous commands not allowed
  9688                                  	;cmp	word [ARG_ARGVCNT],0  ; there WAS a command, wasn't there?
  9689 000002F9 833E[EB90]00            	cmp	word [ARG+ARG_UNIT.argvcnt],0
  9690 000002FE 74DF                    	jz	short NULLCOMJ
  9691                                  	;cmp	word [ARGV0_ARGLEN],0 ; probably an unnecessary check...
  9692 00000300 833E[308E]00            	cmp	word [ARG+ARGV_ELE.arglen],0
  9693 00000305 74D8                    	jz	short NULLCOMJ	; guarantees argv[0] at least x<NULL>
  9694                                  
  9695 00000307 BE[FD88]                	mov	si,COMBUF+2
  9696 0000030A BF[268B]                	mov	di,IDLEN
  9697                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9698                                  				; Make FCB with blank scan-off
  9699                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9700 0000030D B80129                  	mov	ax,2901h
  9701 00000310 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9702                                  			; DS:SI	-> string to parse
  9703                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9704                                  			; AL = bit mask	to control parsing
  9705                                  	;mov	bx,[ARG_ARGV]
  9706 00000312 8B1E[2B8E]              	mov	bx,[ARG+ARG_UNIT.argv] ; mov bx,[ARG]
  9707 00000316 807F013A                	cmp	byte [bx+1],':'	; was a drive specified?
  9708 0000031A 751B                    	jne	short DRVGD	; no, use default of zero...
  9709 0000031C 8A17                    	mov	dl,[bx]		; pick-up drive letter
  9710                                  	;mov	dl,[bx+ARGV_ELE.argpointer] ; mov dl,[bx+0]
  9711                                  	;and	dl,~20h
  9712 0000031E 80E2DF                  	and	dl,0DFh		; uppercase the sucker
  9713                                  	;sub	dl,[CAPITAL_A]	; convert it to a drive number, A=0
  9714                                  	; 31/01/2023
  9715 00000321 80EA41                  	sub	dl,'A'
  9716 00000324 3CFF                    	cmp	al,-1		; See what PARSE said about our drive letter.
  9717 00000326 740C                    	je	short DRVBADJ	; It was invalid.
  9718                                  	;mov	di,[ARGV0_ARGSTARTEL]
  9719 00000328 8B3E[2E8E]              	mov	di,[ARG+ARGV_ELE.argstartel]
  9720 0000032C 803D00                  	cmp	byte [di],0	; is there actually a command there?
  9721 0000032F 7506                    	jne	short DRVGD	; if not, we have:  "d:", "d:\", "d:/"
  9722 00000331 E9CCFD                  	jmp	SETDRV		; and set drive to new drive spec
  9723                                  DRVBADJ:
  9724 00000334 E91C25                  	jmp	DRVBAD
  9725                                  DRVGD:
  9726 00000337 8A05                    	mov	al,[di]
  9727 00000339 A2[BC8A]                	mov	[SPECDRV],al
  9728 0000033C B020                    	mov	al,' '
  9729 0000033E B90900                  	mov	cx,9
  9730 00000341 47                      	inc	di
  9731 00000342 F2AE                    	repne	scasb		; Count number of letters in command name
  9732 00000344 B008                    	mov	al,8
  9733 00000346 28C8                    	sub	al,cl
  9734 00000348 A2[268B]                	mov	[IDLEN],al	; IDLEN is truly the length
  9735 0000034B BF8100                  	mov	di,81h
  9736 0000034E 56                      	push	si
  9737 0000034F BE[FD88]                	mov	si,COMBUF+2	; Skip over all leading delims
  9738 00000352 E88222                  	call	scanoff
  9739                                  
  9740                                  	; 01/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
  9741                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0356h
  9742                                  
  9743                                  	; MSDOS 6.0
  9744                                  ;SR;
  9745                                  ; We are going to skip over the first char always. The logic is that the
  9746                                  ;command tail can never start from the first character. The code below is 
  9747                                  ;trying to figure out the command tail and copy it to the command line 
  9748                                  ;buffer in the PSP. However, if the first character happens to be a switch
  9749                                  ;character and the user given command line is a full 128 bytes, we try to
  9750                                  ;copy 128 bytes to the PSP while it can take only 127 chars. This extra
  9751                                  ;char overwrites the code and leads to a crash on future commands.
  9752                                  
  9753 00000355 46                      	inc	si ;  MSDOS 6.0
  9754                                  DO_SKIPCOM:
  9755 00000356 AC                      	lodsb			; move command line pointer over
  9756 00000357 E88522                  	call	DELIM		; pathname -- have to do it ourselves
  9757 0000035A 740A                    	jz	short DO_SKIPPED ; 'cause parse_file_descriptor is dumb
  9758 0000035C 3C0D                    	cmp	al,0Dh		; can't always depend on argv[0].arglen
  9759 0000035E 7406                    	jz	short DO_SKIPPED ; to be the same length as the user-
  9760 00000360 3A06[A08A]              	cmp	al,[SWITCHAR]	; specified command string
  9761 00000364 75F0                    	jnz	short DO_SKIPCOM 
  9762                                  DO_SKIPPED:
  9763 00000366 4E                      	dec	si
  9764 00000367 31C9                    	xor	cx,cx
  9765                                  COMTAIL:
  9766 00000369 AC                      	lodsb
  9767 0000036A AA                      	stosb			; Move command tail to 80h
  9768 0000036B 3C0D                    	cmp	al,0Dh
  9769 0000036D E0FA                    	loopne	COMTAIL
  9770 0000036F 4F                      	dec	di
  9771 00000370 89FD                    	mov	bp,di
  9772 00000372 F6D1                    	not	cl
  9773 00000374 880E8000                	mov	[80h],cl
  9774 00000378 5E                      	pop	si
  9775                                  ;-----
  9776                                  ; Some of these comments are sadly at odds with this brave new code.
  9777                                  ;-----
  9778                                  ; If the command has 0 parameters must check here for
  9779                                  ; any switches that might be present.
  9780                                  ; SI -> first character after the command.
  9781                                  
  9782                                  	;mov	di,arg.argv[0].argsw_word
  9783                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9784 00000379 8B3E[328E]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9785 0000037D 893E[B38A]              	mov	[COMSW],di	; ah yes, the old addressing mode problem...
  9786                                  	;mov	SI,arg.argv[1 * SIZE argv_ele].argpointer  
  9787                                  				; s = argv[1];
  9788                                  	;mov	si,[ARGV1_ARGPOINTER]
  9789 00000381 8B36[368E]              	mov	si,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argpointer]
  9790 00000385 09F6                    	or	si,si		;   if (s == NULL)
  9791 00000387 7502                    	jnz	short DOPARSE	;	s = bp; (buffer end)
  9792 00000389 89EE                    	mov	si,bp
  9793                                  DOPARSE:
  9794 0000038B BF5C00                  	mov	di,FCB ; 5Ch
  9795                                  	;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9796                                  	; 01/02/2023
  9797 0000038E B80129                  	mov	ax,2901h
  9798                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9799 00000391 CD21                    	int	21h	; DOS -	PARSE FILENAME
  9800                                  			; DS:SI	-> string to parse
  9801                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9802                                  			; AL = bit mask	to control parsing
  9803 00000393 A2[B18A]                	mov	[PARM1],al	; Save result of parse
  9804                                  	;mov	di,arg.argv[1*SIZE argv_ele].argsw_word
  9805                                  	;mov	di,[ARGV1_ARGSW_WORD]
  9806 00000396 8B3E[3D8E]              	mov	di,[ARG+ARGV_ELE.SIZE+ARGV_ELE.argsw_word]
  9807 0000039A 893E[B58A]              	mov	[ARG1S],di
  9808                                  	;mov	si,arg.argv[2*SIZE argv_ele].argpointer    
  9809                                  				; s = argv[2];
  9810                                  	;mov	si,[ARGV2_ARGPOINTER]
  9811 0000039E 8B36[418E]              	mov	si,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argpointer]
  9812 000003A2 09F6                    	or	si,si		; if (s == NULL)
  9813 000003A4 7502                    	jnz	short DOPARSE2
  9814 000003A6 89EE                    	mov	si,bp		;     s = bp; (buffer end)
  9815                                  DOPARSE2:			
  9816 000003A8 BF6C00                  	mov	di,FCB+10h ; 6Ch
  9817                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 01h
  9818 000003AB B80129                  	mov	ax,2901h
  9819                                  	;mov	ax,(Parse_File_Descriptor<<8)|01h
  9820 000003AE CD21                    	int	21h	; DOS -	PARSE FILENAME
  9821                                  			; DS:SI	-> string to parse
  9822                                  			; ES:DI	-> buffer to fill with unopened	FCB
  9823                                  			; AL = bit mask	to control parsing
  9824 000003B0 A2[B28A]                	mov	[PARM2],al	; Save result
  9825                                  	;mov	di,[ARGV2_ARGSW_WORD]
  9826                                  	;mov	di,arg.argv[2*SIZE argv_ele].argsw_word
  9827 000003B3 8B3E[488E]              	mov	di,[ARG+(2*ARGV_ELE.SIZE)+ARGV_ELE.argsw_word]
  9828 000003B7 893E[B78A]              	mov	[ARG2S],di
  9829                                  	;mov	di,[ARGV0_ARGSW_WORD]
  9830                                  	;mov	di,arg.argv[0].argsw_word
  9831 000003BB 8B3E[328E]              	mov	di,[ARG+ARGV_ELE.argsw_word]
  9832 000003BF F7D7                    	not	di		; ARGTS doesn't include the flags
  9833                                  	;and	di,[ARG_ARGSWINFO] ; from COMSW...
  9834                                  	;and	di,arg.argswinfo	
  9835 000003C1 233E[ED90]              	and	di,[ARG+ARG_UNIT.argswinfo]
  9836 000003C5 893E[B98A]              	mov	[ARGTS],di
  9837                                  
  9838 000003C9 A0[268B]                	mov	al,[IDLEN]
  9839 000003CC 8A16[BC8A]              	mov	dl,[SPECDRV]
  9840 000003D0 08D2                    	or	dl,dl		; if a drive was specified...
  9841 000003D2 7505                    	jnz	short EXTERNALJ1 ; it MUST be external, by this time
  9842 000003D4 FEC8                    	dec	al		; (I don't know why -- old code did it)
  9843 000003D6 E9CD23                  	jmp	FNDCOM		; otherwise, check internal com table
  9844                                  EXTERNALJ1:
  9845 000003D9 E9CF24                  	jmp	EXTERNAL
  9846                                  NULLCOM:
  9847 000003DC 8E1E[9C8A]              	mov	ds,[RESSEG]
  9848 000003E0 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; -1 ;G Are we in a batch file?
  9849 000003E6 7405                    	jz	short NOSETFLAG	  ;G only set flag if in batch
  9850 000003E8 C606[B501]01            	mov	byte [NullFlag],1 ;G set flag to indicate no command
  9851                                  	;mov	byte [NullFlag],nullcommand ; 1
  9852                                  NOSETFLAG:
  9853 000003ED 833E[A601]FF            	cmp	word [SingleCom],0FFFFh ; -1
  9854 000003F2 7403                    	je	short EXITJ
  9855 000003F4 E9E9FD                  	jmp	GETCOM
  9856                                  EXITJ:
  9857 000003F7 E92DFD                  	jmp	_$EXITPREP
  9858                                  
  9859                                  ;============================================================================
  9860                                  ; MSHALO.ASM, MSDOS 6.0, 1991
  9861                                  ;============================================================================
  9862                                  ; 12/10/2018 - Retro DOS v3.0
  9863                                  
  9864                                  ; 05/02/2023 - Retro DOS v5.0 (& v4.1) COMMAND.COM
  9865                                  
  9866                                  ;	SCCSID = @(#)ibmhalo.asm	1.1 85/04/10
  9867                                  ;   On 2K (800h) boundaries beginning at address C0000h and ending at EF800h
  9868                                  ;   there is a header that describes a block of rom program.  This header
  9869                                  ;   contains information needed to initialize a module and to provide PCDOS
  9870                                  ;   with a set of reserved names for execution.
  9871                                  ;
  9872                                  ;   This header has the following format:
  9873                                  ;
  9874                                  ;   rom_header	STRUC
  9875                                  ;	Signature1  DB	55h
  9876                                  ;	Signature2  DB	AAh
  9877                                  ;	rom_length  DB	?		; number of 512 byte pieces
  9878                                  ;	init_jmp    DB	3 dup (?)
  9879                                  ;	name_list   name_struc <>
  9880                                  ;   rom_header	ENDS
  9881                                  ;
  9882                                  ;   name_struc	STRUC
  9883                                  ;	name_len    DB	?
  9884                                  ;	name_text   DB	? DUP (?)
  9885                                  ;	name_jmp    DB	3 DUP (?)
  9886                                  ;   name_struc	ENDS
  9887                                  ;
  9888                                  ;   The name list is a list of names that are reserved by a particular section
  9889                                  ;   of a module.  This list of names is terminated by a null name (length
  9890                                  ;   is zero).
  9891                                  ;
  9892                                  ;   Consider now, the PCDOS action when a user enters a command:
  9893                                  ;
  9894                                  ;	COMMAND.COM has control.
  9895                                  ;	o   If location FFFFEh has FDh then
  9896                                  ;	o	Start scanning at C0000h, every 800h for a byte 55h followed
  9897                                  ;		    by AAh, stop scan if we get above or = F0000H
  9898                                  ;	o	When we've found one, compare the name entered by the user
  9899                                  ;		    with the one found in the rom.  If we have a match, then
  9900                                  ;		    set up the environment for execution and do a long jump
  9901                                  ;		    to the near jump after the found name.
  9902                                  ;	o	If no more names in the list, then continue scanning the module
  9903                                  ;		    for more 55h followed by AAh.
  9904                                  ;	o   We get to this point only if there is no matching name in the
  9905                                  ;		rom.  We now look on disk for the command.
  9906                                  ;
  9907                                  ;   This gives us the flexibility to execute any rom cartridge without having
  9908                                  ;   to 'hard-code' the name of the cartridge into PCDOS.  Rom modules that
  9909                                  ;   want to be invisible to the DOS should not have any names in their lists
  9910                                  ;   (i.e. they have a single null name).
  9911                                  ;
  9912                                  ;   Consider a new release of BASIC, say, that patches bugs in the ROM version.
  9913                                  ;   Clearly this version will be available on disk.  How does a user actually
  9914                                  ;   invoke this new BASIC??  He cannot call it BASIC on the disk because the
  9915                                  ;   EXEC loader will execute the ROM before it even looks at the disk!	Only
  9916                                  ;   solution:
  9917                                  ;
  9918                                  ;   o	Keep things consistent and force the user to have his software named
  9919                                  ;	differently from the ROM names (BASIC1, BASIC2, etc).
  9920                                  
  9921                                  struc ROM_HEADER
  9922 00000000 ??                          .signature1: resb 1
  9923 00000001 ??                          .signature2: resb 1
  9924 00000002 ??                          .rom_length: resb 1
  9925 00000003 ??????                      .init_jmp:	 resb 3
  9926 00000006 ??                          .name_list:	 resb 1
  9927                                      .size:
  9928                                  endstruc
  9929                                  
  9930                                  struc NAME_STRUC
  9931 00000000 ??                          .name_len:	resb 1
  9932 00000001 ??                          .name_text:	resb 1
  9933 00000002 ??????                      .name_jmp:	resb 3
  9934                                      .size:	
  9935                                  endstruc
  9936                                  
  9937                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 03D1h
  9938                                  
  9939                                  ; =============== S U B	R O U T	I N E =======================================
  9940                                  
  9941                                  ;ASSUME	CS:TRANGROUP,DS:NOTHING,ES:NOTHING,SS:NOTHING
  9942                                  
  9943                                  ; 05/02/2023
  9944                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:03FBh
  9945                                  
  9946                                  ; Check for IBM PC Jr rom cartrides. DS:DX is a pointer to name
  9947                                  
  9948                                  ROM_SCAN:
  9949 000003FA 06                      	push	es
  9950 000003FB 56                      	push	si
  9951 000003FC 57                      	push	di
  9952 000003FD 51                      	push	cx
  9953 000003FE 50                      	push	ax
  9954 000003FF 53                      	push	bx
  9955                                  
  9956                                  	; check for PC Jr signature in rom
  9957                                  
  9958 00000400 B800F0                  	mov	ax,0F000h
  9959 00000403 8EC0                    	mov	es,ax
  9960 00000405 26803EFEFFFD            	cmp	byte [es:0FFFEh],0FDh
  9961 0000040B 7408                    	je	short SCAN_IT
  9962                                  NO_ROM:
  9963 0000040D F8                      	clc
  9964                                  ROM_RET:
  9965 0000040E 5B                      	pop	bx
  9966 0000040F 58                      	pop	ax
  9967 00000410 59                      	pop	cx
  9968 00000411 5F                      	pop	di
  9969 00000412 5E                      	pop	si
  9970 00000413 07                      	pop	es
  9971 00000414 C3                      	retn
  9972                                  
  9973                                  	; start scanning at C000h
  9974                                  SCAN_IT:
  9975 00000415 B800C0                  	mov	ax,0C000h
  9976                                  SCAN_ONE:
  9977 00000418 8EC0                    	mov	es,ax
  9978 0000041A 31FF                    	xor	di,di
  9979                                  
  9980                                  	; check for a valid header
  9981                                  SCAN_MODULE:
  9982 0000041C 26813D55AA              	cmp	word [es:di],0AA55h
  9983 00000421 740A                    	je	short SCAN_LIST
  9984 00000423 058000                  	add	ax,80h
  9985                                  SCAN_END:
  9986 00000426 3D00F0                  	cmp	ax,0F000h
  9987 00000429 72ED                    	jb	short SCAN_ONE
  9988 0000042B EBE0                    	jmp	short NO_ROM
  9989                                  
  9990                                  	; trundle down list of names
  9991                                  SCAN_LIST:
  9992                                  	;mov	bl,[es:di+2]	; number of 512-byte jobbers
  9993 0000042D 268A5D02                	mov	bl,[es:di+ROM_HEADER.rom_length]
  9994 00000431 30FF                    	xor	bh,bh		; nothing in the high byte
  9995 00000433 D1E3                    	shl	bx,1
  9996 00000435 D1E3                    	shl	bx,1		; number of paragraphs
  9997 00000437 83C37F                  	add	bx,7Fh
  9998 0000043A 83E380                  	and	bx,0FF80h	; round to 2k	
  9999                                  	;mov	di,6
 10000                                  	; 05/05/2023
 10001 0000043D BF0600                  	mov	di,ROM_HEADER.name_list
 10002                                  	;nop
 10003                                  SCAN_NAME:
 10004 00000440 268A0D                  	mov	cl,[es:di]	; length of name
 10005 00000443 47                      	inc	di		; point to name
 10006 00000444 30ED                    	xor	ch,ch
 10007 00000446 09C9                    	or	cx,cx		; zero length name
 10008 00000448 7504                    	jnz	short SCAN_TEST	; nope... compare
 10009 0000044A 01D8                    	add	ax,bx		; yep, skip to next block
 10010 0000044C EBD8                    	jmp	short SCAN_END
 10011                                  
 10012                                  	; compare a single name
 10013                                  SCAN_TEST:
 10014 0000044E 89D6                    	mov	si,dx
 10015 00000450 46                      	inc	si
 10016 00000451 F3A6                    	repe cmpsb		 ; compare name
 10017 00000453 7407                    	jz	short SCAN_FOUND ; success!
 10018                                  SCAN_NEXT:
 10019 00000455 01CF                    	add	di,cx		; failure, next name piece
 10020 00000457 83C703                  	add	di,3
 10021 0000045A EBE4                    	jmp	short SCAN_NAME
 10022                                  
 10023                                  	; found a name. save entry location
 10024                                  SCAN_FOUND:	
 10025 0000045C 803C3F                  	cmp	byte [si],'?'
 10026 0000045F 7405                    	je	short SCAN_SAVE
 10027 00000461 803C20                  	cmp	byte [si],' '
 10028 00000464 75EF                    	jne	short SCAN_NEXT
 10029                                  SCAN_SAVE:
 10030 00000466 2E8C06[A18C]            	mov	[cs:ROM_CS],es
 10031 0000046B 2E893E[9F8C]            	mov	[cs:ROM_IP],di
 10032 00000470 F9                      	stc
 10033 00000471 EB9B                    	jmp	short ROM_RET
 10034                                  
 10035                                  ; ---------------------------------------------------------------------------
 10036                                  
 10037                                  ; execute a rom-placed body of code. allocate largest block
 10038                                  
 10039                                  ROM_EXEC:
 10040 00000473 BBFFFF                  	mov	bx,0FFFFh
 10041                                  	; 05/02/2023
 10042 00000476 B448                    	mov	ah,48h
 10043                                  	;mov	ah,ALLOC ; 48h
 10044 00000478 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10045                                  			; BX = number of 16-byte paragraphs desired
 10046 0000047A B448                    	mov	ah,48h
 10047                                  	;mov	ah,ALLOC ; 48h
 10048 0000047C CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10049                                  			; BX = number of 16-byte paragraphs desired
 10050 0000047E 53                      	push	bx
 10051 0000047F 50                      	push	ax
 10052                                  
 10053                                  	; set terminate addresses
 10054                                  
 10055 00000480 B82225                  	mov	ax,2522h
 10056                                  	;;mov	ax,(set_interrupt_vector SHL 8) + int_terminate
 10057                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+INT_TERMINATE
 10058 00000483 1E                      	push	ds
 10059 00000484 2E8E1E[9C8A]            	mov	ds,[cs:RESSEG]
 10060                                  	;mov	dx,offset RESGROUP:EXEC_WAIT
 10061                                  	;mov	dx,131h ; MSDOS 3.3
 10062                                  	; 05/02/2023
 10063                                  	;mov	dx,0D6Bh ; MSDOS 5.0
 10064 00000489 BA[390C]                	mov	dx,Exec_Wait
 10065 0000048C CD21                    	int	21h	; DOS -	SET INTERRUPT VECTOR
 10066                                  			; AL = interrupt number
 10067                                  			; DS:DX	= new vector to	be used	for specified interrupt
 10068 0000048E 8CDA                    	mov	dx,ds
 10069 00000490 8EC2                    	mov	es,dx
 10070 00000492 1F                      	pop	ds
 10071                                  		
 10072                                  	; and create program header and dup all jfn's
 10073                                  
 10074 00000493 5A                      	pop	dx
 10075 00000494 B455                    	mov	ah,55h
 10076                                  	;mov	ah,DUP_PDB ; 55h
 10077 00000496 CD21                    	int	21h	; DOS -	2+ internal - CREATE PSP
 10078                                  			; DX = segment number at which to set up PSP
 10079                                  			; SI = (DOS 3+)	value to place in memory size field at DX:[0002h]
 10080                                  		
 10081                                  	; set up dma address
 10082                                  
 10083 00000498 8EDA                    	mov	ds,dx
 10084 0000049A BA8000                  	mov	dx,80h
 10085 0000049D B41A                    	mov	ah,1Ah
 10086                                  	;mov	ah,Set_DMA ; 1Ah
 10087 0000049F CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 10088                                  			; DS:DX	-> disk	transfer buffer
 10089                                  
 10090                                  	; copy in environment info
 10091                                  
 10092 000004A1 26A1[3F03]              	mov	ax,[es:EnvirSeg]
 10093                                  	;mov	[2Ch],ax
 10094 000004A5 A32C00                  	mov	[PDB.ENVIRON],ax
 10095                                  
 10096                                  	; set up correct size of block
 10097                                  
 10098 000004A8 5B                      	pop	bx		; BX has size, DS has segment
 10099 000004A9 8CDA                    	mov	dx,ds
 10100 000004AB 01DA                    	add	dx,bx
 10101                                  	;mov	[2],dx
 10102 000004AD 89160200                	mov	[PDB.BLOCK_LEN],dx
 10103                                  
 10104                                  	; change ownership of block
 10105                                  
 10106 000004B1 8CDA                    	mov	dx,ds
 10107 000004B3 4A                      	dec	dx
 10108 000004B4 8EDA                    	mov	ds,dx
 10109 000004B6 42                      	inc	dx	
 10110                                  	;mov	[1],dx
 10111 000004B7 89160100                	mov	[ARENA.owner],dx
 10112 000004BB 8EDA                    	mov	ds,dx
 10113                                  
 10114                                  	; set up correct stack
 10115                                  
 10116 000004BD 81FB0010                	cmp	bx,1000h
 10117 000004C1 7202                    	jb	short GOT_STACK
 10118 000004C3 31DB                    	xor	bx,bx
 10119                                  GOT_STACK:
 10120 000004C5 B104                    	mov	cl,4
 10121 000004C7 D3E3                    	shl	bx,cl
 10122 000004C9 8CDA                    	mov	dx,ds
 10123 000004CB 8ED2                    	mov	ss,dx
 10124 000004CD 89DC                    	mov	sp,bx
 10125 000004CF 31C0                    	xor	ax,ax
 10126 000004D1 50                      	push	ax
 10127                                  
 10128                                  	; set up initial registers and go to the guy
 10129                                  
 10130 000004D2 F7D0                    	not	ax
 10131 000004D4 2EFF36[A18C]            	push	word [cs:ROM_CS]
 10132 000004D9 2EFF36[9F8C]            	push	word [cs:ROM_IP]
 10133 000004DE 8EC2                    	mov	es,dx
 10134 000004E0 CB                      	retf	; far return
 10135                                  
 10136                                  ;============================================================================
 10137                                  ; TBATCH.ASM, MSDOS 6.0, 1991
 10138                                  ;============================================================================
 10139                                  ; 12/10/2018 - Retro DOS v3.0
 10140                                  
 10141                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 04B9h
 10142                                  
 10143                                  ; =============== S U B	R O U T	I N E =======================================
 10144                                  
 10145                                  ;Break	<PromptBat - Open or wait for batch file>
 10146                                  
 10147                                  ; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10148                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:04E2h
 10149                                  
 10150                                  ; Open the batch file. If we cannot find the batch file. If the media is
 10151                                  ; changeable, we prompt for the change. Otherwise, we terminate the batch
 10152                                  ; file. Leave segment registers alone.
 10153                                  
 10154                                  PROMPTBAT:
 10155 000004E1 E84D08                  	call	BATOPEN
 10156 000004E4 7201                    	jc	short PROMPTBAT1
 10157 000004E6 C3                      	retn
 10158                                  PROMPTBAT1:
 10159                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10160                                  	; MSDOS 6.0 COMMAND.COM
 10161 000004E7 83FA02                  	cmp	dx,ERROR_FILE_NOT_FOUND ;AN022; Ask for diskette if file not found
 10162 000004EA 740A                    	je	short BAT_REMCHECK	;AN022;
 10163 000004EC 83FA03                  	cmp	dx,ERROR_PATH_NOT_FOUND ;AN022; Ask for diskette if path not found
 10164 000004EF 7405                    	je	short BAT_REMCHECK	;AN022; Otherwise, issue message and exit
 10165                                  	;invoke	output_batch_name	;AN022; set up batch name in bwdbuf
 10166 000004F1 E83500                  	call	output_batch_name
 10167 000004F4 EB13                    	jmp	short BATDIE		;AN022;
 10168                                  
 10169                                  	; 05/02/2023
 10170                                  	; MSDOS 3.3 COMMAND.COM
 10171                                  	;cmp	dx,ACCDENPTR
 10172                                  	;jz	short BATDIE
 10173                                  
 10174                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10175                                  BAT_REMCHECK:				;AN022; Go see if media is removable
 10176 000004F6 2EFF1E[A68A]            	call	far [cs:RCH_ADDR]	; DX has error number
 10177 000004FB 7417                    	jz	short ASKFORBAT		; Media is removable
 10178                                  
 10179                                  ; The media is not changeable. Turn everything off.
 10180                                  
 10181 000004FD E8450B                  	call	FOROFF
 10182 00000500 E8602A                  	call	PipeOff
 10183 00000503 A2[AB01]                	mov	[IfFlag],al	; No If in progress.	
 10184 00000506 BA[4E7F]                	mov	dx,BADBAT_PTR
 10185                                  BATDIE:
 10186 00000509 E8F203                  	call	BATCHOFF
 10187 0000050C 0E                      	push	cs
 10188 0000050D 1F                      	pop	ds
 10189                                  	;invoke	std_eprintf	;AC022; display message ;  MSDOS 6.0
 10190                                  	; 05/02/2023
 10191 0000050E E8EA48                  	call	std_eprintf	; MSDOS 6.0
 10192                                  	;call	STD_PRINTF	; MSDOS 3.3
 10193                                  
 10194                                  ; TCOMMAND resets the stack. This is the equivalent of a non-local goto.
 10195                                  
 10196 00000511 E9F0FB                  	jmp	TCOMMAND
 10197                                  
 10198                                  ; Ask the user to reinsert the batch file
 10199                                  
 10200                                  ASKFORBAT:
 10201 00000514 1E                      	push	ds
 10202 00000515 0E                      	push	cs
 10203 00000516 1F                      	pop	ds
 10204                                  
 10205                                  	; MSDOS 6.0
 10206                                  	;mov	dx,offset TRANGROUP:NEEDBAT_ptr  ;AN022;
 10207 00000517 BA[517F]                	mov	dx,NEEDBAT_PTR
 10208                                  	;invoke	std_eprintf	 	;Prompt for batch file on stderr
 10209                                  	; 05/02/2023
 10210 0000051A E8DE48                  	call	std_eprintf
 10211                                  	;mov	dx,offset trangroup:pausemes_ptr
 10212 0000051D BA[C37F]                	mov	dx,PAUSEMES_PTR
 10213                                  	;invoke std_eprintf		;AN000; get second part of message
 10214 00000520 E8D848                  	call	std_eprintf
 10215                                  					;AN000; print it to stderr
 10216                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10217                                  	;call	STD_EPRINTF
 10218 00000523 E82E00                  	call	GETKEYSTROKE
 10219 00000526 1F                      	pop	ds
 10220 00000527 EBB8                    	jmp	short PROMPTBAT
 10221                                  
 10222                                  
 10223                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10224                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:052Ah
 10225                                  
 10226                                  	; MSDOS 6.0
 10227                                  ;****************************************************************
 10228                                  ;*
 10229                                  ;* ROUTINE:	Output_batch_name
 10230                                  ;*
 10231                                  ;* FUNCTION:	Sets up batch name to be printed on extended error
 10232                                  ;*
 10233                                  ;* INPUT:	DX - extended error number
 10234                                  ;*
 10235                                  ;* OUTPUT:	Ready to call print routine
 10236                                  ;*
 10237                                  ;****************************************************************
 10238                                  ;
 10239                                  ;public	output_batch_name		;AN022;
 10240                                  
 10241                                  output_batch_name:	;proc near	;AN022;
 10242                                  
 10243 00000529 1E                      	push	ds			;AN022; save resident segment
 10244 0000052A 8E1E[4C01]              	mov	ds,[Batch]		;AN022; get batch file segment
 10245                                  	;assume	DS:nothing		;AN022;
 10246                                  	;;mov	SI,BatFile		;AN022; get offset of batch file
 10247                                  	; 05/02/2023
 10248                                  	;mov	si,20h
 10249                                  	; 24/04/2023
 10250 0000052E BE2000                  	mov	si,BATCHSEGMENT.BatFile
 10251                                  	;invoke	dstrlen 		;AN022; get length of string
 10252 00000531 E83327                  	call	dstrlen
 10253                                  	;mov	di,offset Trangroup:bwdbuf
 10254                                  					;AN022; target for batch name
 10255 00000534 BF[A58B]                	mov	di,BWDBUF
 10256 00000537 F3A4                    	rep	movsb			;AN022; move the name
 10257                                  
 10258 00000539 0E                      	push	cs			;AN022; get local segment
 10259 0000053A 1F                      	pop	ds			;AN022;
 10260                                  	;assume	DS:trangroup		;AN022;
 10261                                  	; 05/02/2023
 10262 0000053B 8916[317F]              	mov	[extend_buf_ptr],dx	;AN022; put message number in block
 10263                                  	;mov	byte [msg_disp_class],1
 10264 0000053F C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class
 10265                                  					;AN022; set up extended error msg class
 10266                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 10267 00000544 BA[317F]                	mov	dx,extend_buf_ptr	
 10268                                  					;AN022; get extended message pointer
 10269                                  	;mov	string_ptr_2,offset trangroup:bwdbuf 
 10270 00000547 C706[8C8C][A58B]        	mov	word [string_ptr_2],BWDBUF	
 10271                                  					;AN022; point to substitution
 10272                                  	;mov	byte [extend_buf_sub],1
 10273 0000054D C606[337F]01            	mov	byte [extend_buf_sub],one_subst
 10274                                  					;AN022; set up for one subst
 10275 00000552 1F                      	pop	ds			;AN022; restore data segment
 10276 00000553 C3                      	retn				;AN022; return
 10277                                  
 10278                                  ;output_batch_name    endp		;AN022;
 10279                                  
 10280                                  
 10281                                  ; =============== S U B	R O U T	I N E =======================================
 10282                                  
 10283                                  ;Break	<GetKeystroke - get a keystroke and flush queue>
 10284                                  
 10285                                  ; Read the next keystroke. Since there may be several characters in the queue
 10286                                  ; after the one we ask for (function keys/Kanji), we need to flush the queue
 10287                                  ; AFTER waiting.
 10288                                  
 10289                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10290                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0555h
 10291                                  
 10292                                  GETKEYSTROKE:
 10293                                  	; 05/02/2023
 10294                                  	; MSDOS 3.3
 10295                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_NO_ECHO
 10296                                  	;;mov	ax,0C08h
 10297                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT_NO_ECHO
 10298                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10299                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10300                                  	;;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10301                                  	;;mov	ax,0C00h
 10302                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)+0
 10303                                  	;int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 10304                                  	;		; AL must be 01h,06h,07h,08h,or 0Ah.
 10305                                  	;retn
 10306                                  
 10307                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10308                                  	; MSDOS 6.0
 10309 00000554 52                      	push	dx			;AN000;  3/3/KK
 10310                                  	;mov	ax,(ECS_call SHL 8) OR GetInterimMode
 10311                                  					;AN000;  3/3/KK
 10312 00000555 B80263                  	mov	ax,6302h
 10313 00000558 CD21                    	int	21h			;AN000;  3/3/KK
 10314                                  		; DOS - 3.2+ only - GET KOREAN (HONGEUL) INPUT MODE
 10315                                  	
 10316 0000055A 52                      	push	dx			;AN000;  save interim state 3/3/KK
 10317                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10318                                  					;AN000;  3/3/KK
 10319 0000055B B80163                  	mov	ax,6301h
 10320 0000055E B201                    	mov	dl,1
 10321                                  	;mov	dl,InterimMode		;AN000;  3/3/KK
 10322 00000560 CD21                    	int	21h			;AN000;  3/3/KK
 10323                                  		; DOS - 3.2+ only - SET KOREAN (HONGEUL) INPUT MODE
 10324                                  		; DL = new mode
 10325                                  		; 00h return only full characters on DOS keyboard input functions
 10326                                  		; 01h return partially-formed characters also
 10327                                  	
 10328                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) OR STD_CON_INPUT_no_echo
 10329 00000562 B8080C                  	mov	ax,0C08h
 10330 00000565 CD21                    	int	21h			; Get character with KB buffer flush
 10331                                  		; DOS - CLEAR KEYBOARD BUFFER
 10332                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10333                                  
 10334                                  	;mov	ax,(STD_CON_INPUT_FLUSH SHL 8) + 0
 10335 00000567 B8000C                  	mov	ax,0C00h
 10336 0000056A CD21                    	int	21h
 10337                                  		; DOS - CLEAR KEYBOARD BUFFER
 10338                                  		; AL must be 01h, 06h, 07h, 08h, or 0Ah.
 10339                                  
 10340                                  	;mov	ax,(ECS_call SHL 8) OR SetInterimMode
 10341                                  					;AN000;  3/3/KK
 10342 0000056C B80163                  	mov	ax,6301h
 10343 0000056F 5A                      	pop	dx			;AN000;  restore interim state 3/3/KK
 10344 00000570 CD21                    	int	21h			;AN000;  3/3/KK
 10345 00000572 5A                      	pop	dx			;AN000;  3/3/KK
 10346                                  	
 10347 00000573 C3                      	retn
 10348                                  
 10349                                  ; =============== S U B	R O U T	I N E =======================================
 10350                                  
 10351                                  ; Break	<ReadBat - read 1 line from batch file>
 10352                                  
 10353                                  ; ReadBat - read a single line from the batch file. 
 10354                                  ; Perform all substitutions as appropriate.
 10355                                  
 10356                                  	; 05/02/2023 - Retro DOS v4.0 COMMAND.COM
 10357                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0575h
 10358                                  
 10359                                  READBAT:
 10360                                  	;ASSUME	DS:ResGroup,ES:TranGroup
 10361                                  		
 10362                                  	;mov	byte [Suppress],1
 10363                                  				; initialize line suppress status
 10364 00000574 C606[A101]01            	mov	byte [Suppress],YES_ECHO 
 10365 00000579 F606[9601]FF            	test	byte [Batch_Abort],-1 ; 0FFh
 10366 0000057E 751F                    	jnz	short TRYING_TO_ABORT
 10367 00000580 C606[9501]01            	mov	byte [In_Batch],1 ; set flag to indicate batch job
 10368                                  
 10369                                  	; MSDOS 6.0
 10370                                  
 10371                                  ;M037; Start of changes
 10372                                  ; We check here if we have set the flag indicating that the batchfile is at
 10373                                  ;EOF. In this case, we do not want to continue with the normal processing.
 10374                                  ;We call GetBatByt once more so that the batch segment gets freed up, the
 10375                                  ;batch file gets closed etc. and then return as if everything is done.
 10376                                  
 10377                                  	; 05/02/2023
 10378 00000585 1E                      	push	ds
 10379 00000586 8E1E[4C01]              	mov	ds,[Batch]
 10380                                  	;cmp	byte [2],0
 10381 0000058A 803E020000              	cmp	byte [BATCHSEGMENT.BatchEOF],0
 10382                                  				; are we at EOF in batchfile
 10383 0000058F 1F                      	pop	ds
 10384 00000590 740A                    	jz	short CONTBAT	; no, continue normal processing
 10385                                  	;invoke	GetBatByt	; frees up batchseg
 10386 00000592 E8D803                  	call	GETBATBYT
 10387 00000595 26A2[FD88]              	mov	[es:COMBUF+2],al
 10388                                  				; stuff CR into command buffer
 10389                                  				; as a dummy command
 10390                                  	;;invoke CrLf2		; print a CR-LF
 10391                                  	;call	CRLF2
 10392                                  	;;return		; done batch processing
 10393                                  	;retn
 10394                                  	; 24/04/2023
 10395 00000599 E92E20                  	jmp	CRLF2
 10396                                  
 10397                                  ;M037; End of changes
 10398                                  		
 10399                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10400                                  CONTBAT:
 10401 0000059C E842FF                  	call	PROMPTBAT
 10402                                  
 10403                                  TRYING_TO_ABORT:
 10404 0000059F BF[FD88]                	mov	di,COMBUF+2
 10405                                  
 10406                                  ; Save position and try to scan for first non delimiter.
 10407                                  
 10408                                  TESTNOP:
 10409 000005A2 8CD8                    	mov	ax,ds
 10410 000005A4 8E1E[4C01]              	mov	ds,[Batch]
 10411 000005A8 FF360800                	push	word [BATCHSEGMENT.BatSeek]
 10412 000005AC FF360A00                	push	word [BATCHSEGMENT.BatSeek+2]
 10413                                  				; save current location.
 10414 000005B0 8ED8                    	mov	ds,ax
 10415 000005B2 E85006                  	call	SKIPDELIM	; skip to first non-delim
 10416                                  
 10417                                  ; If the first non-delimiter is not a : (label), we reseek back to the
 10418                                  ; beginning and read the line.
 10419                                  
 10420 000005B5 3C3A                    	cmp	al,':'		; is it a label?
 10421 000005B7 59                      	pop	cx
 10422 000005B8 5A                      	pop	dx		; restore position in bat file
 10423 000005B9 7431                    	jz	short NOPLINE	; yes, resync everything.
 10424 000005BB F706[4C01]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10425 000005C1 7438                    	jz	short RDBAT	; no, go read batch file
 10426                                  
 10427                                  	;cmp	al,'@'
 10428 000005C3 3C40                    	cmp	al,No_Echo_Char	; see if user wants to suppress line
 10429 000005C5 7507                    	jne	short SET_BAT_POS ; no - go and set batch file position
 10430                                  	;mov	byte [Suppress],0
 10431 000005C7 C606[A101]00            	mov	byte [Suppress],NO_ECHO ; yes set flag to indicate
 10432 000005CC EB2D                    	jmp	short RDBAT	; go read batch file
 10433                                  	;nop
 10434                                  SET_BAT_POS:
 10435 000005CE 1E                      	push	ds
 10436 000005CF 8E1E[4C01]              	mov	ds,[Batch]
 10437                                  	;mov	[8],dx
 10438 000005D3 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; reseek back to beginning
 10439                                  	;mov	[10],cx
 10440 000005D7 890E0A00                	mov	[BATCHSEGMENT.BatSeek+2],cx
 10441 000005DB 1F                      	pop	ds
 10442                                  	;;mov	ax,(LSEEK SHL 8) + 0
 10443                                  	; 05/02/2023
 10444 000005DC B80042                  	mov	ax,4200h
 10445                                  	;mov	ax,(LSEEK*256) ; 4200h ; ; seek back
 10446 000005DF CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 10447                                  			; AL = method: offset from beginning of	file
 10448                                  	;mov	word [cs:BATBUFPOS],0FFFFh
 10449                                  	; 24/04/2023
 10450                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:05E3h
 10451 000005E1 26C706[A395]FFFF        	mov	word [es:BATBUFPOS],-1; 0FFFFh
 10452                                  	;mov	word [cs:BATBUFPOS],-1 ; nuke batch buffer position
 10453 000005E8 31C9                    	xor	cx,cx		; Initialize line length to zero
 10454 000005EA EB0F                    	jmp	short RDBAT
 10455                                  
 10456                                  	;nop
 10457                                  
 10458                                  ; The first non-delimiter is a :. This line is not echoed and is ignored.
 10459                                  ; We eat characters until a CR is seen.
 10460                                  
 10461                                  NOPLINE:
 10462 000005EC E80501                  	call	SKIPTOEOL
 10463 000005EF E87B03                  	call	GETBATBYT	; eat trailing LF
 10464                                  	;test	word [Batch],0FFFFh
 10465 000005F2 F706[4C01]FFFF          	test	word [Batch],-1 ; are we done with the batch file?
 10466 000005F8 75A8                    	jnz	short TESTNOP	; no, go get another line
 10467                                  READBAT_RETN:				; Hit EOF			
 10468 000005FA C3                      	retn
 10469                                  
 10470                                  ; ---------------------------------------------------------------------------
 10471                                  
 10472                                  ; Read a line into the buffer pointed to by ES:DI. If any %s are seen in the
 10473                                  ; input, we are to consider two special cases:
 10474                                  ;
 10475                                  ;   %0 to %9	These represent replaceable parameters from the batch segment
 10476                                  ;   %sym%	This is a symbol from the environment
 10477                                  
 10478                                  RDBAT:
 10479 000005FB E86F03                  	call	GETBATBYT
 10480 000005FE 41                      	inc	cx		; Inc the line length
 10481                                  
 10482                                  	; 05/02/2023
 10483                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0601h
 10484 000005FF E8B61D                  	call	testkanj
 10485 00000602 740C                    	jz	short RDBAT1
 10486                                  	;cmp	cx,127
 10487 00000604 83F97F                  	cmp	cx,COMBUFLEN-1
 10488 00000607 7350                    	jnb	short TOOLONG
 10489 00000609 AA                      	stosb
 10490 0000060A E86003                  	call    GETBATBYT
 10491 0000060D 41                      	inc	cx
 10492 0000060E EB0A                    	jmp	short SAVBATBYT
 10493                                  RDBAT1:
 10494 00000610 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10495 00000614 7343                    	jnb	short TOOLONG	   ; Yes - handle it, handle it
 10496                                  
 10497                                  ; See if we have a parameter character.
 10498                                  
 10499 00000616 3C25                    	cmp	al,'%'		; Check for parameter
 10500 00000618 7449                    	je	short NEEDPARM
 10501                                  
 10502                                  ; no parameter character. Store it as usual and see if we are done.
 10503                                  
 10504                                  SAVBATBYT:
 10505 0000061A AA                      	stosb			; End of line found?
 10506 0000061B 3C0D                    	cmp	al,0Dh
 10507 0000061D 75DC                    	jne	short RDBAT	; no, go for more
 10508                                  
 10509                                  ; We have read in an entire line. 
 10510                                  ; Decide whether we should echo the command line or not.
 10511                                  
 10512                                  FOUND_EOL:
 10513 0000061F 81EF[FE88]              	sub	di,COMBUF+3
 10514 00000623 89F8                    	mov	ax,di		; remember that we've not counted the CR
 10515 00000625 26A2[FC88]              	mov	[es:COMBUF+1],al
 10516                                  				; Set length of line
 10517 00000629 E84103                  	call	GETBATBYT	; Eat linefeed
 10518 0000062C E8EE06                  	call	BATCLOSE
 10519 0000062F 803E[A101]00            	cmp	byte [Suppress],NO_ECHO ; 0
 10520 00000634 7407                    	jz	short RESET
 10521 00000636 F606[A001]01            	test	byte [EchoFlag],1  ; To echo or not to echo, that is the
 10522 0000063B 7504                    	jnz	short TRY_NEXTFLAG ; question. (Profound, huh?)
 10523                                  RESET:
 10524 0000063D 0E                      	push	cs
 10525 0000063E 1F                      	pop	ds		; Go back to local segment
 10526 0000063F 74B9                    	jz	short READBAT_RETN ; no echoing here...
 10527                                  TRY_NEXTFLAG:
 10528 00000641 803E[B501]01            	cmp	byte [NullFlag],nullcommand ; 1
 10529                                  				;G was there a command last time?
 10530 00000646 7403                    	jz	short NO_CRLF_PRINT
 10531                                  				;G no - don't print crlf
 10532 00000648 E87F1F                  	call	CRLF2		;G Print out prompt
 10533                                  NO_CRLF_PRINT:
 10534 0000064B E83E17                  	call	PRINT_PROMPT
 10535 0000064E 0E                      	push	cs		;G change data segment
 10536 0000064F 1F                      	pop	ds
 10537 00000650 BA[FD88]                	mov	dx,COMBUF+2	; get command line for echoing
 10538 00000653 E8CD1F                  	call	CRPRINT
 10539                                  	;call	CRLF2
 10540                                  	;retn
 10541                                  	; 06/02/2023
 10542 00000656 E9711F                  	jmp	CRLF2
 10543                                  
 10544                                  ; The line was too long. Eat remainder of input text up until the CR
 10545                                  
 10546                                  TOOLONG:
 10547 00000659 3C0D                    	cmp	al,0Dh		; Has the end of the line been reached?
 10548 0000065B 7403                    	jz	short LTLCONT	; Yes, continue
 10549 0000065D E89400                  	call	SKIPTOEOL	; Eat remainder of line	
 10550                                  LTLCONT:
 10551 00000660 AA                      	stosb			; Terminate the command
 10552 00000661 EBBC                    	jmp	short FOUND_EOL	; Go process the valid part of the line
 10553                                  
 10554                                  ; We have found a parameter lead-in character. Check for the 0-9 case first
 10555                                  
 10556                                  NEEDPARM:
 10557 00000663 E80703                  	call	GETBATBYT	; get next character
 10558 00000666 3C25                    	cmp	al,'%'		; Check for two consecutive %
 10559 00000668 74B0                    	je	short SAVBATBYT	; if so, replace with a single %
 10560 0000066A 3C0D                    	cmp	al,0Dh		; Check for end-of-line
 10561 0000066C 74AC                    	je	short SAVBATBYT	; yes, treat it normally
 10562                                  
 10563                                  ; We have found %<something>. If the <something> is in the range 0-9, we
 10564                                  ; retrieve the appropriate parameter from the batch segment. Otherwise we
 10565                                  ; see if the <something> has a terminating % and then look up the contents
 10566                                  ; in the environment.
 10567                                  
 10568                                  PAROK:
 10569 0000066E 2C30                    	sub	al,'0'
 10570 00000670 7239                    	jb	short NEEDENV	; look for parameter in the environment
 10571 00000672 3C09                    	cmp	al,9
 10572 00000674 7735                    	ja	short NEEDENV
 10573                                  
 10574                                  ; We have found %<number>. This is taken from the parameters in the
 10575                                  ; allocated batch area.
 10576                                  
 10577 00000676 98                      	cbw
 10578 00000677 89C3                    	mov	bx,ax		; move index into AX
 10579 00000679 D1E3                    	shl	bx,1		; convert word index into byte ptr
 10580 0000067B 06                      	push	es
 10581 0000067C 8E06[4C01]              	mov	es,[Batch]
 10582                                  
 10583                                  ; The structure of the batch area is:
 10584                                  ;
 10585                                  ;   BYTE    type of segment
 10586                                  ;   DWORD   offset for next line
 10587                                  ;   10 WORD pointers to parameters. -1 is empty parameter
 10588                                  ;   ASCIZ   file name (with . and ..)
 10589                                  ;   BYTES   CR-terminated parameters
 10590                                  ;   BYTE    0 flag to indicate end of parameters
 10591                                  ;
 10592                                  ; Get pointer to BX'th argument
 10593                                  
 10594                                  	;;mov	si,[es:bx+0Bh]
 10595                                  	; 05/02/2023
 10596                                  	;mov	si,[es:bx+0Ch] 	; MSDOS 5.0 COMMAND.COM
 10597 00000680 268B770C                	mov	si,[es:bx+BATCHSEGMENT.BatParm]
 10598 00000684 07                      	pop	es
 10599                                  
 10600                                  ; Is there a parameter here?
 10601                                  
 10602 00000685 83FEFF                  	cmp	si,-1		; Check if parameter exists
 10603 00000688 7503                    	jnz	short YES_THERE_IS ; Yes go get it
 10604 0000068A E96EFF                  	jmp	RDBAT		; Ignore if it doesn't
 10605                                  
 10606                                  ; Copy in the found parameter from batch segment
 10607                                  
 10608                                  YES_THERE_IS:
 10609 0000068D 1E                      	push	ds
 10610 0000068E 8E1E[4C01]              	mov	ds,[Batch]
 10611 00000692 49                      	dec	cx		; Don't count '%' in line length
 10612                                  COPYPARM:
 10613 00000693 AC                      	lodsb			; From resident segment
 10614 00000694 3C0D                    	cmp	al,0Dh		; Check for end of parameter
 10615 00000696 740F                    	je	short ENDPARAM
 10616 00000698 41                      	inc	cx		; Inc the line length
 10617 00000699 81F98000                	cmp	cx,COMBUFLEN ; 128 ; Is it too long?
 10618 0000069D 7303                    	jnb	short LINETOOL	; Yes - handle it, handle it
 10619 0000069F AA                      	stosb
 10620 000006A0 EBF1                    	jmp	short COPYPARM
 10621                                  
 10622                                  ; We have copied up to the limit. Stop copying and eat remainder of batch
 10623                                  ; line. We need to make sure that the tooLong code isn't fooled into
 10624                                  ; believing that we are at EOL. Clobber AL too.
 10625                                  
 10626                                  LINETOOL:
 10627 000006A2 30C0                    	xor	al,al
 10628 000006A4 1F                      	pop	ds
 10629 000006A5 EBB2                    	jmp	short TOOLONG
 10630                                  
 10631                                  ; We have copied in an entire parameter. Go back for more
 10632                                  
 10633                                  ENDPARAM:
 10634 000006A7 1F                      	pop	ds
 10635 000006A8 E950FF                  	jmp	RDBAT
 10636                                  
 10637                                  ; We have found % followed by something other than 0-9. We presume that there
 10638                                  ; will be a following % character. In between is an environment variable that
 10639                                  ; we will fetch and replace in the batch line with its value.
 10640                                  
 10641                                  NEEDENV:
 10642                                  	; MSDOS 6.0 COMMAND.COM
 10643                                  	; 05/02/2023 
 10644 000006AB 49                      	dec     cx 		;AN070; Don't count "%"
 10645                                  
 10646                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10647 000006AC 1E                      	push	ds
 10648 000006AD 57                      	push	di
 10649                                  				; temp spot for name
 10650 000006AE BF[278B]                	mov	di,ID
 10651 000006B1 0430                    	add	al,'0'		; reconvert character
 10652 000006B3 AA                      	stosb			; store it in appropriate place
 10653                                  
 10654                                  ; loop getting characters until the next % is found or until EOL
 10655                                  
 10656                                  GETENV1:
 10657 000006B4 E8B602                  	call	GETBATBYT	; get the byte
 10658 000006B7 AA                      	stosb			; store it
 10659 000006B8 3C0D                    	cmp	al,0Dh		; EOL?
 10660 000006BA 7514                    	jne	short GETENV15	; no, see if it the term char
 10661                                  
 10662                                  ; The user entered a string with a % but no trailing %. We copy the string.
 10663                                  
 10664 000006BC 26C645FF00              	mov	byte [es:di-1],0 ; nul terminate the string
 10665 000006C1 BE[278B]                	mov	si,ID 		; point to buffer
 10666 000006C4 5F                      	pop	di		; point to line buffer
 10667 000006C5 0E                      	push	cs
 10668 000006C6 1F                      	pop	ds
 10669 000006C7 E89002                  	call	STRCPY
 10670                                  	; 05/02/2023
 10671 000006CA 72D6                    	jc	short LINETOOL	;  MSDOS 6.0 COMMAND.COM
 10672                                  	; 24/04/2023
 10673                                  	;dec	di  		;  MSDOS 3.3 COMMAND.COM	
 10674 000006CC 1F                      	pop	ds
 10675 000006CD E94AFF                  	jmp	SAVBATBYT
 10676                                  GETENV15:
 10677 000006D0 3C25                    	cmp	al,'%'		; terminating %?
 10678 000006D2 75E0                    	jne	short GETENV1	; no, go suck out more characters
 10679                                  
 10680                                  ; M017 - following DEC is wrong, because we replace the % with a = here.
 10681                                  ; This was the source of bug #1.
 10682                                  ;	dec	cx		;AN070; Don't count "%"
 10683                                  
 10684 000006D4 B03D                    	mov	al,'='		; terminate  with =
 10685 000006D6 268845FF                	mov	[es:di-1],al
 10686                                  
 10687                                  ; ID now either has a =-terminated string which we are to find in the
 10688                                  ; environment or a non =-terminated string which will not be found in the
 10689                                  ; environment.
 10690                                  
 10691                                  GETENV2:
 10692 000006DA BE[278B]                	mov	si,ID
 10693 000006DD 0E                      	push	cs
 10694 000006DE 1F                      	pop	ds		; DS:SI points to name
 10695 000006DF 51                      	push	cx
 10696 000006E0 E82B1C                  	call	find_name_in_environment
 10697 000006E3 59                      	pop	cx
 10698 000006E4 06                      	push	es
 10699 000006E5 1F                      	pop	ds
 10700 000006E6 0E                      	push	cs
 10701 000006E7 07                      	pop	es
 10702 000006E8 89FE                    	mov	si,di
 10703 000006EA 5F                      	pop	di		; get back pointer to command line
 10704                                  
 10705                                  ; If the parameter was not found, there is no need to perform any replacement.
 10706                                  ; We merely pretend that we've copied the parameter.
 10707                                  
 10708 000006EB 7203                    	jc	short GETENV6
 10709                                  
 10710                                  ; ES:DI points to command line being built
 10711                                  ; DS:SI points either to nul-terminated environment object AFTER =
 10712                                  
 10713 000006ED E86A02                  	call	STRCPY		; (let RdBat handle overflow)
 10714                                  	; 24/04/2022
 10715                                  	;dec	di 		; MSDOS 3.3 COMMAND.COM
 10716                                  GETENV6:
 10717 000006F0 1F                      	pop	ds
 10718 000006F1 E907FF                  	jmp	RDBAT		; go back to batch file
 10719                                  
 10720                                  ; =============== S U B	R O U T	I N E =======================================
 10721                                  
 10722                                  ;   SkipToEOL - read from batch file until end of line
 10723                                  
 10724                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10725                                  SKIPTOEOL:
 10726 000006F4 F706[4C01]FFFF          	test	word [Batch],-1 ; 0FFFFh
 10727                                  	;jnz	short SKIPTOEOL1  	
 10728                                  	;retn			; no batch file in effect
 10729                                  	
 10730 000006FA 7407                    	jz	short SKIPTOEOL2 ; Retro DOS v3.0 COMMAND.COM
 10731                                  SKIPTOEOL1:
 10732 000006FC E86E02                  	call	GETBATBYT
 10733 000006FF 3C0D                    	cmp	al,0Dh		; eol character?
 10734 00000701 75F1                    	jnz	short SKIPTOEOL	; no, go eat another
 10735                                  SKIPTOEOL2:
 10736 00000703 C3                      	retn
 10737                                  
 10738                                  ; =============== S U B	R O U T	I N E =======================================
 10739                                  
 10740                                  ;Break	<Allocate and deallocate the transient portion>
 10741                                  
 10742                                  ; Free Transient. Modify ES,AX,flags
 10743                                  
 10744                                  	; 06/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10745                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0708h
 10746                                  FREE_TPA:
 10747 00000704 06                      	push	es
 10748 00000705 8E06[9C8A]              	mov	es,[RESSEG]
 10749 00000709 268E06[5F03]            	mov	es,[es:Res_Tpa]
 10750 0000070E B449                    	mov	ah,49h
 10751                                  	;mov	ah,DEALLOC ; 49h
 10752 00000710 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 10753                                  			; ES = segment address of area to be freed
 10754 00000712 07                      	pop	es
 10755 00000713 C3                      	retn
 10756                                  
 10757                                  ; =============== S U B	R O U T	I N E =======================================
 10758                                  
 10759                                  ; Allocate transient. Modify AX,BX,DX,flags
 10760                                  
 10761                                  	; 06/02/2023
 10762                                  ALLOC_TPA:
 10763 00000714 06                      	push	es
 10764 00000715 8E06[9C8A]              	mov	es,[RESSEG]
 10765 00000719 BBFFFF                  	mov	bx,0FFFFh 	; Re-allocate the transient	
 10766 0000071C B448                    	mov	ah,48h
 10767                                  	;mov	ah,ALLOC ; 48h
 10768 0000071E CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10769                                  			; BX = number of 16-byte paragraphs desired
 10770 00000720 53                      	push	bx	  	; Save size of block
 10771 00000721 B448                    	mov	ah,48h
 10772                                  	;mov	ah,ALLOC ; 48h
 10773 00000723 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10774                                  			; BX = number of 16-byte paragraphs desired
 10775                                  
 10776                                  ; Attempt to align TPA on 64K boundary
 10777                                  
 10778 00000725 5B                      	pop	bx		; Restore size of block
 10779 00000726 26A3[5F03]              	mov	[es:Res_Tpa],ax
 10780                                  				; Save segment to beginning of block
 10781 0000072A A3[AC8A]                	mov	[TRAN_TPA],ax
 10782                                  
 10783                                  ; Is the segment already aligned on a 64K boundary
 10784                                  
 10785 0000072D 89C2                    	mov	dx,ax		; Save segment
 10786 0000072F 25FF0F                  	and	ax,0FFFh	; Test if above boundary
 10787 00000732 7507                    	jnz	short CALC_TPA
 10788 00000734 89D0                    	mov	ax,dx
 10789 00000736 2500F0                  	and	ax,0F000h	; Test if multiple of 64K
 10790 00000739 7523                    	jnz	short NOROUND
 10791                                  CALC_TPA:
 10792 0000073B 89D0                    	mov	ax,dx
 10793 0000073D 2500F0                  	and	ax,0F000h
 10794 00000740 050010                  	add	ax,1000h	; Round up to next 64K boundary
 10795 00000743 7219                    	jc	short NOROUND	; Memory wrap if carry set
 10796                                  
 10797                                  ; Make sure that new boundary is within allocated range
 10798                                  
 10799 00000745 268B16[5F03]            	mov	dx,[es:Res_Tpa]
 10800 0000074A 01DA                    	add	dx,bx		; Compute maximum address
 10801 0000074C 39C2                    	cmp	dx,ax		; Is 64K address out of range?
 10802 0000074E 720E                    	jb	short NOROUND
 10803                                  
 10804                                  ; Make sure that we won't overwrite the transient
 10805                                  
 10806 00000750 8CCB                    	mov	bx,cs		; CS is beginning of transient
 10807 00000752 39C3                    	cmp	bx,ax
 10808 00000754 7208                    	jb	short NOROUND
 10809                                  
 10810                                  ; The area from the 64K boundary to the beginning of the transient must
 10811                                  ; be at least 64K.
 10812                                  
 10813 00000756 29C3                    	sub	bx,ax
 10814                                  	;cmp	bx,4096
 10815 00000758 81FB0010                	cmp	bx,1000h	; Size greater than 64K?	
 10816 0000075C 7304                    	jnb	short ROUNDDONE
 10817                                  NOROUND:
 10818 0000075E 26A1[5F03]              	mov	ax,[es:Res_Tpa]
 10819                                  ROUNDDONE:
 10820 00000762 26A3[5103]              	mov	[es:LTpa],ax	; Re-compute everything
 10821 00000766 A3[9E8A]                	mov	[TPA],ax
 10822 00000769 89C3                    	mov	bx,ax
 10823 0000076B 8CC8                    	mov	ax,cs
 10824 0000076D 29D8                    	sub	ax,bx
 10825 0000076F 53                      	push	bx
 10826 00000770 BB1000                  	mov	bx,16
 10827 00000773 F7E3                    	mul	bx
 10828 00000775 5B                      	pop	bx
 10829 00000776 09D2                    	or	dx,dx
 10830 00000778 7403                    	jz	short SAVSIZ2
 10831 0000077A B8FFFF                  	mov	ax,-1
 10832                                  SAVSIZ2:
 10833                                  
 10834                                  ; AX is the number of bytes free in the buffer between the resident and the
 10835                                  ; transient with a maximum of 64K-1. We round this down to a multiple of 512.
 10836                                  
 10837 0000077D 3D0002                  	cmp	ax,512
 10838 00000780 7603                    	jbe	short GOTSIZE2
 10839                                  	;and	ax,~1FFh
 10840 00000782 2500FE                  	and	ax,0FE00h	; NOT 511 = NOT 1FFh
 10841                                  GOTSIZE2:
 10842 00000785 A3[BD8A]                	mov	[BYTCNT],ax
 10843 00000788 07                      	pop	es
 10844 00000789 C3                      	retn
 10845                                  
 10846                                  ; =============== S U B	R O U T	I N E =======================================
 10847                                  
 10848                                  ;Break	<BatCom - enter a batch file>
 10849                                  
 10850                                  ; The exec search has determined that the user has requested a batch file for
 10851                                  ; execution. We parse the arguments, create the batch segment, and signal
 10852                                  ; batch processing.
 10853                                  
 10854                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 10855                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:078Eh
 10856                                  BATCOM:	
 10857                                  
 10858                                  ;ASSUME	DS:TRANGROUP, ES:NOTHING
 10859                                  
 10860                                  ; Batch parameters are read with ES set to segment of resident part
 10861                                  
 10862                                  	; MSDOS 6.0
 10863 0000078A 8E06[9C8A]              	mov	es,[RESSEG]
 10864                                  	;ASSUME	ES:RESGROUP
 10865                                  	;cmp	byte [es:Call_Batch_Flag],1
 10866 0000078E 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10867                                  					;AN043; If in CALL,
 10868 00000794 7403                    	jz	short skip_ioset	;AN043; redirection was already set up
 10869                                  	;invoke	IOSET			; Set up any redirection
 10870 00000796 E8DD23                  	call	IOSET
 10871                                  skip_ioset:				;AN043;
 10872 00000799 E868FF                  	call	FREE_TPA		; G
 10873                                  	;cmp	byte [es:Call_Batch_Flag],1
 10874 0000079C 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10875 000007A2 7403                    	jz	short GETECHO 		; G if we're in a call, don't execute
 10876                                  
 10877                                  	; 12/02/2023
 10878                                  	; MSDOS 3.3
 10879                                  	;call	IOSET
 10880                                  	;mov	es,[RESSEG]
 10881                                  	;call	FREE_TPA
 10882                                  	;;cmp	byte [es:CALL_BATCH_FLAG],1
 10883                                  	;cmp	byte [es:CALL_BATCH_FLAG],call_in_progress
 10884                                  	;jz	short GETECHO		; G if we're in a call, don't execute
 10885                                  
 10886                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10887                                  
 10888                                  ; Since BATCH has lower precedence than PIPE or FOR. If a new BATCH file is
 10889                                  ; being started it MUST be true that no FOR or PIPE is currently in progress.
 10890                                  ; Don't execute if in call
 10891                                  
 10892 000007A4 E89E08                  	call	FOROFF
 10893                                  GETECHO:
 10894 000007A7 E8B927                  	call	PipeOff
 10895 000007AA 26A0[A001]              	mov	al,[es:EchoFlag]	; preserve echo state for chaining
 10896 000007AE 2401                    	and	al,1			; Save current echo state
 10897                                  
 10898 000007B0 50                      	push	ax
 10899 000007B1 31C0                    	xor	ax,ax
 10900 000007B3 26F706[4C01]FFFF        	test	word [es:Batch],-1 	; Are we in a batch file?
 10901 000007BA 7414                    	jz	short LEAVEBAT	   	; No, nothing to save
 10902 000007BC 26A1[4C01]              	mov	ax,[es:Batch] 		; Get current batch segment
 10903                                  	;cmp	byte [es:Call_Batch_Flag],1
 10904 000007C0 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10905 000007C6 7408                    	jz	short LEAVEBAT
 10906                                  
 10907                                  ;  We are in a chained batch file, save batlast from previous batch segment
 10908                                  ;  so that if we're in a CALL, we will return to the correct batch file.
 10909                                  
 10910 000007C8 06                      	push	es
 10911 000007C9 8EC0                    	mov	es,ax		; Get current batch segment
 10912                                  	;mov	ax,[es:02h] ; MSDOS 3.3 COMMAND.COM
 10913                                  				; Get previous batch segment
 10914                                  	; 12/02/2023
 10915                                  	;mov	ax,[es:03h] ; MSDOS 6.0 (&5.0) COMMAND.COM	
 10916 000007CB 26A10300                	mov	ax,[es:BATCHSEGMENT.BatLast]
 10917 000007CF 07                      	pop	es
 10918                                  LEAVEBAT:
 10919 000007D0 50                      	push	ax		; Keep segment until new one created
 10920                                  	;cmp	byte [es:Call_Batch_Flag],1
 10921 000007D1 26803E[B201]01          	cmp	byte [es:Call_Batch_Flag],call_in_progress
 10922 000007D7 7403                    	jz	short STARTBAT
 10923 000007D9 E82201                  	call	BATCHOFF
 10924                                  
 10925                                  ; Find length of batch file
 10926                                  
 10927                                  STARTBAT:
 10928 000007DC 26C606[B201]00          	mov	byte [es:Call_Batch_Flag],0 ; Reset call flag
 10929 000007E2 BE[C489]                	mov	si,EXECPATH
 10930                                  
 10931                                  	; 12/02/2023
 10932                                  	; MSDOS 6.0
 10933 000007E5 B811B7                  	mov	ax,0B711h
 10934                                  	;mov	ax,AppendTruename
 10935                                  				;AN042; Get the real path where the batch file
 10936 000007E8 CD2F                    	int	2Fh		;AN042;    was found with APPEND
 10937 000007EA B44E                    	mov	ah,4Eh
 10938                                  	;mov	ah,Find_First	;AN042; The find_first will return it
 10939 000007EC 89F2                    	mov	dx,si		;AN042; Get the string
 10940 000007EE B91300                  	mov	cx,13h
 10941                                  	;mov	cx,search_attr	;AN042; filetypes to search for
 10942 000007F1 CD21                    	int	21h		;AN042;
 10943                                  
 10944                                  	; MSDOS 3.3 (& MSDOS 6.0)
 10945 000007F3 E87124                  	call	dstrlen
 10946                                  ;
 10947                                  ; Allocate batch area:
 10948                                  ;   BYTE    type of segment
 10949                                  ;   WORD    segment of last batch file
 10950                                  ;   WORD    segment for FOR command
 10951                                  ;   BYTE    FOR flag state on entry to batch file
 10952                                  ;   DWORD   offset for next line
 10953                                  ;   10 WORD pointers to parameters.  -1 is empty parameter
 10954                                  ;   ASCIZ   file name (with . and ..)
 10955                                  ;   BYTES   CR-terminated parameters
 10956                                  ;   BYTE    0 flag to indicate end of parameters
 10957                                  ;
 10958                                  ; We allocate the maximum size for the command line and use setblock to shrink
 10959                                  ; later when we've squeezed out the extra
 10960                                  ;
 10961 000007F6 89CB                    	mov	bx,cx		; length of file name.
 10962                                  	;add	bx,190	; MSDOS 3.3 (BATCHSEGMENT struc size = 32)
 10963                                  	; 12/02/2023
 10964                                  	;add	bx,191	; MSDOS 6.0 (BATCHSEGMENT struc size = 33) 
 10965                                  	; 25/04/2023
 10966 000007F8 81C3BF00                	add	bx,15+BATCHSEGMENT.SIZE+COMBUFLEN+15
 10967                                  					; structure + max len + round up
 10968 000007FC 51                      	push	cx
 10969 000007FD B104                    	mov	cl,4
 10970 000007FF D3EB                    	shr	bx,cl		; convert to paragraphs
 10971 00000801 53                      	push	bx		; Save size of batch segment
 10972 00000802 B448                    	mov	ah,48h
 10973                                  	;mov	ah,ALLOC ; 48h ; Allocate batch segment
 10974 00000804 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 10975                                  				; BX = number of 16-byte paragraphs desired
 10976 00000806 5B                      	pop	bx		; Get size of batch segment
 10977                                  
 10978                                  ; This should *NEVER* return an error. The transient is MUCH bigger than
 10979                                  ; the batch segment. This may not be true, however, in a multitasking system.
 10980                                  ; G This error will occur with nesting of batch files. We also need to
 10981                                  ; G make sure that we don't overlay the transient.
 10982                                  
 10983 00000807 7221                    	jc	short MEM_ERROR	;G not enough memory - exit
 10984                                  
 10985 00000809 50                      	push	ax		;G save batch segment
 10986 0000080A 01D8                    	add	ax,bx		;G get end of batch segment
 10987 0000080C 83C020                  	add	ax,20h		;G add some tpa work area
 10988 0000080F 8CCB                    	mov	bx,cs		;G get the transient segment
 10989                                  
 10990                                  	; MSDOS 6.0
 10991                                  ; M006; We cant check just for above. If the batchseg goes into a UMB, the
 10992                                  ; M006; batchseg is always above the transient. We need to change this code
 10993                                  ; M006; to only check for an overlap
 10994                                  
 10995                                  	;;mov	dx,offset TRANGROUP:TranSpaceEnd ; M006
 10996                                  	; 12/02/2023
 10997                                  	;;mov	dx,98C5h ; MSDOS 5.0 COMMAND.COM
 10998                                  	;mov	dx,TRANSPACEEND		
 10999                                  	;add	dx,15		;round up para; M006
 11000 00000811 BAFA95                  	mov	dx,TRANSPACEEND+15
 11001                                  
 11002 00000814 D3EA                    	shr	dx,cl		;para size of transient; M006
 11003 00000816 01DA                    	add	dx,bx		;dx = top of transient; M006
 11004                                  
 11005 00000818 39D8                    	cmp	ax,bx		; M006
 11006 0000081A 7211                    	jb	short ENOUGH_MEM
 11007                                  				; Batchseg below transient
 11008                                  				; enough memory ; M006
 11009 0000081C 39D0                    	cmp	ax,dx		; M006
 11010 0000081E 770D                    	ja	short ENOUGH_MEM	
 11011                                  				; Batchseg above transient
 11012                                  				; enough memory ; M006
 11013                                  
 11014                                  ; M006; Batchseg overlaps transient -- insufficient memory
 11015                                  
 11016 00000820 58                      	pop	ax		; restore ax; M006
 11017                                  
 11018                                  	; 12/02/2023
 11019                                  	; MSDOS 3.3
 11020                                  ; M006;	cmp	ax,bx		;G do we end before the transient
 11021                                  ; M006;	pop	ax		;G get batch segment back
 11022                                  ; M006;	jb	short ENOUGH_MEM ;G we have enough memory - continue
 11023                                  
 11024                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11025 00000821 06                      	push	es		;G no we're hitting the transient
 11026 00000822 8EC0                    	mov	es,ax
 11027 00000824 B80049                  	mov	ax,4900h
 11028                                  	;mov	ax,DEALLOC*256 ; 4900h ;G deallocate the batch segment
 11029 00000827 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11030                                  			; ES = segment address of area to be freed
 11031 00000829 07                      	pop	es
 11032                                  MEM_ERROR:
 11033 0000082A E9BA00                  	jmp	NO_MEMORY	;G Set up for message and exit
 11034                                  
 11035                                  ENOUGH_MEM:
 11036                                  	; 12/02/2023 - Retro DOS v4.0 COMMAND.COM
 11037                                  	; MSDOS 6.0
 11038 0000082D 58                      	pop	ax		; restore ax; M006
 11039                                  
 11040                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11041 0000082E 26A3[4C01]              	mov	[es:Batch],ax
 11042 00000832 E8DFFE                  	call	ALLOC_TPA
 11043                                  
 11044                                  ; Initialize batch segment
 11045                                  
 11046 00000835 5A                      	pop	dx		; length of name
 11047 00000836 58                      	pop	ax		;G get saved batch segment back
 11048 00000837 26FF06[AF01]            	inc	word [es:Nest]	;G increment # batch files in progress
 11049 0000083C 06                      	push	es
 11050 0000083D 268E06[4C01]            	mov	es,[es:Batch]
 11051                                  	;mov	byte [ES:0],0
 11052                                  				; signal batch file type
 11053 00000842 26C606000000            	mov	byte [es:BATCHSEGMENT.BatType],BATCHTYPE ; 0
 11054                                  	;;mov	[es:2],ax	; MSDOS 3.3
 11055                                  				;G save segment of last batch file
 11056                                  	;mov	[es:3],ax	; MSDOS 6.0
 11057 00000848 26A30300                	mov	[es:BATCHSEGMENT.BatLast],ax
 11058 0000084C 1E                      	push	ds
 11059 0000084D 8E1E[9C8A]              	mov	ds,[RESSEG]	;G set to resident data
 11060                                  
 11061 00000851 31C0                    	xor	ax,ax
 11062 00000853 8A1E[AC01]              	mov	bl,[ForFlag]	;G get the current FOR state
 11063                                  	;;mov	[es:6],bl	; MSDOS 3.3
 11064                                  				;G save it in the batch segment
 11065                                  	;mov	[es:7],bl	; MSDOS 6.0 	
 11066 00000857 26881E0700              	mov	[es:BATCHSEGMENT.BatForFlag],bl
 11067 0000085C F6C3FF                  	test	bl,-1		;G are we in a FOR?
 11068 0000085F 7408                    	jz	short FOR_NOT_ON ;G no, for segment set to 0	
 11069 00000861 A1[AD01]                	mov	ax,[ForPtr]	;G yes, get current FOR segment	
 11070 00000864 C606[AC01]00            	mov	byte [ForFlag],0 ;G reset forflag
 11071                                  FOR_NOT_ON:
 11072                                  	;;mov	[es:4],ax	; MSDOS 3.3
 11073                                  				;G save FOR segment in batch segment
 11074                                  	;mov	[es:5],ax	; MSDOS 6.0		
 11075 00000869 26A30500                	mov	[es:BATCHSEGMENT.BatForPtr],ax	
 11076 0000086D 31C0                    	xor	ax,ax
 11077 0000086F A3[AD01]                	mov	[ForPtr],ax	;G make sure for segment is not active
 11078 00000872 8A1E[A001]              	mov	bl,[EchoFlag]
 11079 00000876 1F                      	pop	ds
 11080                                  	;mov	[es:1],bl 
 11081                                  				 ;G save echo state of parent
 11082 00000877 26881E0100              	mov	[es:BATCHSEGMENT.BatEchoFlag],bl
 11083                                  ;SR;
 11084                                  ; Initialize the new BatchEOF flag we have added to 0
 11085                                  
 11086                                  	; MSDOS 6.0
 11087                                  	;mov	byte [es:2],0
 11088 0000087C 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 11089                                  
 11090                                  	;mov	[es:08h],ax  ; MSDOS 6.0
 11091 00000882 26A30800                	mov	[es:BATCHSEGMENT.BatSeek],ax ; point to beginning of file
 11092                                  	;mov	[es:0Ah],ax  ; MSDOS 6.0	
 11093 00000886 26A30A00                	mov	[es:BATCHSEGMENT.BatSeek+2],ax
 11094                                  
 11095                                  ; Initialize pointers
 11096                                  
 11097 0000088A 48                      	dec	ax		; put -1 into AX
 11098                                  	;;mov	di,0Bh  ; MSDOS 3.3
 11099                                  				; point to parm area
 11100                                  	;mov	di,0Ch	; MSDOS 6.0
 11101 0000088B BF0C00                  	mov	di,BATCHSEGMENT.BatParm
 11102 0000088E 89FB                    	mov	bx,di
 11103 00000890 B90A00                  	mov	cx,10
 11104 00000893 F3AB                    	rep stosw		; Init to no parms
 11105                                  
 11106                                  ; Move in batch file name
 11107                                  
 11108 00000895 89D1                    	mov	cx,dx
 11109 00000897 F3A4                    	rep	movsb
 11110                                  
 11111                                  ; Now copy the command line into batch segment, parsing the arguments along
 11112                                  ; the way. Segment will look like this:
 11113                                  ;
 11114                                  ;   <arg0>CR<arg1>CR...<arg9>CR<arg10>CR...<ARGn>CR 0
 11115                                  ;
 11116                                  ; or, in the case of fewer arguments:
 11117                                  ;
 11118                                  ;   <arg0>CR<arg1>CR...<arg6>CR CR CR ... CR 0
 11119                                  
 11120 00000899 BE[FD88]                	mov	si,COMBUF+2
 11121                                  	;mov	cx,10		; at most 10 arguments
 11122                                  	; 07/06/2023
 11123 0000089C B10A                    	mov	cl,10
 11124                                  EACHPARM:
 11125 0000089E E8361D                  	call	scanoff		; skip to argument
 11126                                  
 11127                                  ; AL is first non-delimiter. DS:SI points to char = AL
 11128                                  
 11129 000008A1 3C0D                    	cmp	al,0Dh		; end of road?
 11130 000008A3 741D                    	jz	short HAVPARM	; yes, no more arguments
 11131                                  
 11132                                  ; If CX = 0 then we have stored the most parm we can. Skip store
 11133                                  
 11134 000008A5 E306                    	jcxz	MOVPARM		; Only first 10 parms get pointers
 11135                                  
 11136                                  ; Go into allocated piece and stick in new argument pointer.
 11137                                  
 11138 000008A7 26893F                  	mov	[es:bx],di	; store batch pointer
 11139 000008AA 83C302                  	add	bx,2		; advance arg counter
 11140                                  
 11141                                  ; Move the parameter into batch segment
 11142                                  
 11143                                  MOVPARM:
 11144 000008AD AC                      	lodsb			; get byte
 11145 000008AE E82E1D                  	call	DELIM		; if delimiter
 11146 000008B1 7407                    	jz	short ENDPARM	; then done with parm
 11147 000008B3 AA                      	stosb			; store byte
 11148 000008B4 3C0D                    	cmp	al,0Dh		; if CR then not delimiter
 11149 000008B6 740A                    	jz	short HAVPARM	; but end of parm list, finish
 11150 000008B8 EBF3                    	jmp	short MOVPARM
 11151                                  
 11152                                  ; We have copied a parameter up until the first separator.
 11153                                  ; Terminate it with CR.
 11154                                  
 11155                                  ENDPARM:
 11156 000008BA B00D                    	mov	al,0Dh
 11157 000008BC AA                      	stosb
 11158 000008BD E3DF                    	jcxz	EACHPARM	; if no parameters, don't dec
 11159 000008BF 49                      	dec	cx		; remember that we've seen one.	
 11160 000008C0 EBDC                    	jmp	short EACHPARM
 11161                                  
 11162                                  ; We have parsed the entire line. Terminate the arg list
 11163                                  
 11164                                  HAVPARM:
 11165 000008C2 30C0                    	xor	al,al		; Nul terminate the parms
 11166 000008C4 AA                      	stosb
 11167                                  
 11168                                  ; Now we know EXACTLY how big the BATCH segment is. Round up size (from DI)
 11169                                  ; into paragraphs and setblock to the appropriate size
 11170                                  
 11171 000008C5 8D5D0F                  	lea	bx,[di+15]
 11172 000008C8 B104                    	mov	cl,4
 11173 000008CA D3EB                    	shr	bx,cl
 11174 000008CC B44A                    	mov	ah,4Ah
 11175                                  	;mov	ah,SETBLOCK ; 4Ah
 11176 000008CE CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 11177                                  			; ES = segment address of block	to change
 11178                                  			; BX = new size	in paragraphs
 11179 000008D0 07                      	pop	es
 11180 000008D1 06                      	push	es
 11181 000008D2 1F                      	pop	ds		; Simply batch FCB setup
 11182 000008D3 833E[A601]FF            	cmp	word [SingleCom],-1 ; 0FFFFh
 11183 000008D8 7506                    	jne	short NOBATSING
 11184 000008DA C706[A601]F0FF          	mov	word [SingleCom],0FFF0h ; Flag single command BATCH job
 11185                                  
 11186                                  NOBATSING:
 11187                                  
 11188                                  ; Enter the batch file with the current echo state
 11189                                  
 11190 000008E0 58                      	pop	ax		; Get original echo state
 11191 000008E1 A2[A001]                	mov	[EchoFlag],al	; restore it
 11192 000008E4 E91DF8                  	jmp	TCOMMAND
 11193                                  
 11194                                  ; The following is executed if there isn't enough memory for batch segment
 11195                                  
 11196                                  NO_MEMORY:
 11197 000008E7 5A                      	pop	dx		; even up our stack 
 11198 000008E8 58                      	pop	ax
 11199 000008E9 58                      	pop	ax
 11200 000008EA E827FE                  	call	ALLOC_TPA	; reallocate memory
 11201                                  
 11202                                  	; 12/02/2023
 11203                                  	; MSDOS 3.3
 11204                                  	;mov	dx,INSFMEMMESPTR
 11205                                  	;jmp	CERROR
 11206                                  
 11207                                  	; MSDOS 6.0
 11208                                  	;mov	byte [msg_disp_class],1
 11209 000008ED C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class
 11210                                  				;AN000; set up extended error msg class
 11211                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr
 11212 000008F2 BA[317F]                	mov	dx,extend_buf_ptr
 11213                                  	;			;AC000; get extended message pointer
 11214                                  	;mov	word [extend_buf_ptr],8
 11215 000008F5 C706[317F]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 11216                                  				;AN000; get message number in control block
 11217 000008FB E94D20                  	jmp	cerror		;g print error message and go...
 11218                                  
 11219                                  ; =============== S U B	R O U T	I N E =======================================
 11220                                  
 11221                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11222                                  BATCHOFF:
 11223 000008FE 50                      	push	ax
 11224 000008FF 06                      	push	es
 11225 00000900 1E                      	push	ds
 11226 00000901 53                      	push	bx
 11227                                  
 11228 00000902 2E8E06[9C8A]            	mov	es,[cs:RESSEG]
 11229 00000907 2E8E1E[9C8A]            	mov	ds,[cs:RESSEG]
 11230 0000090C A1[4C01]                	mov	ax,[Batch]	; Free the batch segment
 11231 0000090F 09C0                    	or	ax,ax
 11232 00000911 7442                    	jz	short NOTFREE
 11233                                  
 11234 00000913 06                      	push	es
 11235 00000914 8EC0                    	mov	es,ax
 11236 00000916 F606[A001]01            	test	byte [EchoFlag],1
 11237                                  				;G Is echo on?
 11238 0000091B 7505                    	jnz	short ECHO_LAST_LINE
 11239                                  				;G Yes - echo last line in file
 11240                                  	;mov	byte [SUPPRESS],0
 11241 0000091D C606[A101]00            	mov	byte [Suppress],NO_ECHO
 11242                                  				;G no - don't echo last line in file	
 11243                                  ECHO_LAST_LINE:
 11244                                  	;mov	bl,[es:1]
 11245 00000922 268A1E0100              	mov	bl,[es:BATCHSEGMENT.BatEchoFlag]
 11246                                  				; G get echo state
 11247 00000927 881E[A001]              	mov	[EchoFlag],bl
 11248                                  				; G  and restore it
 11249                                  	;;mov	bx,[es:4]  ; MSDOS 3.3
 11250                                  	;mov	bx,[es:5]  ; MSDOS 6.0
 11251 0000092B 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr]
 11252                                  				;G Get FOR segment
 11253 00000930 891E[AD01]              	mov	[ForPtr],bx	;G  and restore it
 11254                                  	;;mov	bl,[es:6]  ; MSDOS 3.3
 11255                                  	;mov	bl,[es:7]  ; MSDOS 6.0	
 11256 00000934 268A1E0700              	mov	bl,[es:BATCHSEGMENT.BatForFlag]
 11257                                  				;G Get FOR flag
 11258 00000939 881E[AC01]              	mov	[ForFlag],bl
 11259                                  				;G  and restore it
 11260                                  	;;mov	bx,[es:2] ; MSDOS 3.3
 11261                                  	;mov	bx,[es:3] ; MSDOS 6.0	
 11262 0000093D 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 11263                                  				;G  Get old batch segment
 11264                                  
 11265 00000942 B449                    	mov	ah,49h
 11266                                  	;mov	ah,DEALLOC ; 49h
 11267 00000944 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 11268                                  			; ES = segment address of area to be freed
 11269 00000946 07                      	pop	es
 11270 00000947 891E[B301]              	mov	[Next_Batch],bx	;G reset batch segment	
 11271 0000094B 26FF0E[AF01]            	dec	word [es:Nest]
 11272 00000950 31C0                    	xor	ax,ax
 11273 00000952 A3[4C01]                	mov	[Batch],ax	; No batch in progress
 11274                                  NOTFREE:
 11275 00000955 5B                      	pop	bx
 11276 00000956 1F                      	pop	ds
 11277 00000957 07                      	pop	es
 11278 00000958 58                      	pop	ax
 11279 00000959 C3                      	retn
 11280                                  
 11281                                  ; =============== S U B	R O U T	I N E =======================================
 11282                                  
 11283                                  	; 12/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11284                                  
 11285                                  ; StrCpy - copy string, checking count in CX against COMBUFLEN
 11286                                  ;	Entry : DS:SI ==> source string
 11287                                  ;		ES:DI ==> destination string
 11288                                  ;		CX = current length of destination string
 11289                                  ;	Exit  : string copied, CX updated, Carry set if length limit exceeded
 11290                                  
 11291                                  	; 12/02/2023	
 11292                                  	; MSDOS 3.3
 11293                                  ;STRCPY:
 11294                                  	;push	ax
 11295                                  ;CCYCLE:
 11296                                  	;lodsb
 11297                                  	;stosb
 11298                                  	;or	al,al
 11299                                  	;jnz	short CCYCLE
 11300                                  	;pop	ax
 11301                                  	;retn
 11302                                  
 11303                                  ;Procedure StrCpy,NEAR
 11304                                  
 11305                                  	; 12/02/2023
 11306                                  	; MSDOS 6.0
 11307                                  STRCPY:
 11308 0000095A 50                      	push	ax
 11309                                  ccycle:
 11310 0000095B AC                      	lodsb
 11311 0000095C 41                      	inc	cx
 11312                                  	;cmp	cx,128
 11313 0000095D 81F98000                	cmp	cx,COMBUFLEN
 11314                                  	;jb	short ccopy
 11315                                  	;stc			; set carry to signal error
 11316                                  	;jmp	short ccend
 11317                                  	; 12/02/2023
 11318 00000961 F5                      	cmc
 11319 00000962 7205                    	jc	short ccend
 11320                                  ccopy:
 11321 00000964 AA                      	stosb
 11322 00000965 08C0                    	or	al,al
 11323 00000967 75F2                    	jnz	short ccycle
 11324                                  ccend:
 11325 00000969 49                      	dec	cx		; discount extra byte
 11326 0000096A 4F                      	dec	di		; back up pointer
 11327 0000096B 58                      	pop	ax
 11328 0000096C C3                      	retn			; return carry clear
 11329                                  
 11330                                  ;EndProc StrCpy
 11331                                  
 11332                                  ;============================================================================
 11333                                  ; TBATCH2.ASM, MSDOS 6.0, 1991
 11334                                  ;============================================================================
 11335                                  ; 12/10/2018 - Retro DOS v3.0
 11336                                  
 11337                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0892h
 11338                                  
 11339                                  ; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11340                                  
 11341                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 0977h
 11342                                  
 11343                                  ; =============== S U B	R O U T	I N E =======================================
 11344                                  
 11345                                  ;Break	<GetBatByt - retrieve a byte from the batch file>
 11346                                  
 11347                                  ; Get one byte from the batch file and return it in AL. End-of-file returns
 11348                                  ; <CR> and ends batch mode. DS must be set to resident segment.
 11349                                  ; AH, DX destroyed.
 11350                                  
 11351                                  GETBATBYT:
 11352 0000096D 53                      	push	bx
 11353 0000096E 51                      	push	cx
 11354 0000096F 1E                      	push	ds
 11355 00000970 F606[9601]FF            	test	byte [Batch_Abort],-1
 11356                                  	;jnz	short BATEOF
 11357                                  	; 14/02/2023
 11358 00000975 7403                    	jz	short getbatbyt1
 11359 00000977 E9D100                  	jmp	BATEOF
 11360                                  getbatbyt1:
 11361 0000097A F706[4C01]FFFF          	test	word [Batch],-1
 11362                                  	;jz	short BATEOF
 11363                                  	; 14/02/2023
 11364 00000980 7503                    	jnz	short getbatbyt2
 11365 00000982 E9C600                  	jmp	BATEOF
 11366                                  getbatbyt2:
 11367 00000985 06                      	push	es
 11368 00000986 8E06[4C01]              	mov	es,[Batch]
 11369                                  
 11370                                  	; MSDOS 6.0
 11371                                  ;M020;
 11372                                  ;Check if we have already reached EOF (BatchEOF flag set. Then, we do not
 11373                                  ;try to read from the batchfile again.
 11374                                  
 11375                                  	;cmp	byte [es:2],0
 11376 0000098A 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11377                                  				;already reached EOF?	;M020
 11378 00000990 7403                    	jz	short not_eof	;no, read batch file	;M020
 11379 00000992 E99C00                  	jmp	At_EOF		;yes, no more reads	;M020
 11380                                  not_eof:						;M020
 11381                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11382                                  	;add	word [es:8],1	; MSDOS 6.0
 11383 00000995 268306080001            	add	word [es:BATCHSEGMENT.BatSeek],1
 11384                                  	;adc	word [es:10],0	; MSDOS 6.0
 11385 0000099B 2683160A0000            	adc	word [es:BATCHSEGMENT.BatSeek+2],0
 11386 000009A1 07                      	pop	es
 11387                                  
 11388                                  ; See if we have bytes buffered...
 11389                                  
 11390 000009A2 8CC8                    	mov	ax,cs
 11391 000009A4 8ED8                    	mov	ds,ax
 11392 000009A6 8B1E[A395]              	mov	bx,[BATBUFPOS]
 11393 000009AA 83FBFF                  	cmp	bx,-1
 11394 000009AD 7540                    	jnz	short UNBUF
 11395                                  
 11396                                  ; There are no bytes in the buffer. Let's try to fill it up.
 11397                                  
 11398 000009AF BA[A595]                	mov	dx,BATBUF
 11399 000009B2 8B0E[7984]              	mov	cx,[BATBUFLEN] ; max to read.
 11400 000009B6 8B1E[D08D]              	mov	bx,[BATHAND]
 11401                                  	; 14/02/2023
 11402 000009BA B43F                    	mov	ah,3Fh
 11403                                  	;mov	ah,READ ; 3Fh	; Get one more byte from batch file
 11404 000009BC CD21                    	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 11405                                  			; BX = file handle,CX = number	of bytes to read
 11406                                  			; DS:DX	-> buffer
 11407                                  	; MSDOS 6.0
 11408 000009BE 7321                    	jnc	short bat_read_ok	;AN022; if no error - continue
 11409                                  	;invoke	get_ext_error_number	;AN022; get the error
 11410 000009C0 E83913                  	call	get_ext_error_number
 11411 000009C3 1E                      	push	ds			;AN022; save local segment
 11412 000009C4 8E1E[9C8A]              	mov	ds,[RESSEG]		;AN022; get resident segment
 11413                                  	;assume ds:resgroup		;AN022;
 11414 000009C8 89C2                    	mov	dx,ax			;AN022; put error in DX
 11415                                  	;invoke	output_batch_name	;AN022; set up to print the error
 11416 000009CA E85CFB                  	call	output_batch_name
 11417 000009CD 1F                      	pop	ds			;AN022;
 11418                                  	;assume	ds:trangroup		;AN022;
 11419                                  	;invoke	std_eprintf		;AN022; print out the error
 11420 000009CE E82A44                  	call	std_eprintf
 11421                                  	;mov	byte ptr combuf+2,end_of_line_in
 11422 000009D1 C606[FD88]0D            	mov	byte [COMBUF+2],END_OF_LINE_IN ; 0Dh
 11423                                  	;				;AN022; terminate the batch line for parsing
 11424                                  	;mov	byte ptr combuf+3,end_of_line_out 
 11425 000009D6 C606[FE88]00            	mov	byte [COMBUF+3],END_OF_LINE_OUT ; 0
 11426                                  	;				;AN022; terminate the batch line for output
 11427                                  ;M020;
 11428                                  ;Old bug! We jump to BatEof from here without ds=RESGROUP. Probably, this
 11429                                  ;error is never hit (and it shouldn't be)
 11430                                  
 11431 000009DB 8E1E[9C8A]              	mov	ds,[RESSEG]		; ds = RESGROUP ; M020
 11432 000009DF EB6A                    	jmp	short BATEOF		;AN022; terminate the batch file
 11433                                  bat_read_ok:				;AN022;
 11434                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11435 000009E1 89C1                    	mov	cx,ax
 11436                                  	;jcxz	TURN_OFF ; MSDOS 3.3
 11437                                  	; 14/02/2023
 11438 000009E3 E320                    	jcxz	BATEOFDS ; MSDOS 6.0
 11439 000009E5 890E[C595]              	mov	[BATBUFEND],cx
 11440 000009E9 31DB                    	xor	bx,bx
 11441 000009EB 891E[A395]              	mov	[BATBUFPOS],bx
 11442                                  
 11443                                  	; Buffered bytes!
 11444                                  UNBUF:
 11445 000009EF 8A87[A595]              	mov	al,[BATBUF+bx]		; get next byte
 11446 000009F3 43                      	inc	bx
 11447 000009F4 3B1E[C595]              	cmp	bx,[BATBUFEND]		; beyond end of buffer?
 11448 000009F8 7203                    	jb	short SETBUFPOS
 11449 000009FA BBFFFF                  	mov	bx,-1
 11450                                  SETBUFPOS:
 11451 000009FD 891E[A395]              	mov	[BATBUFPOS],bx
 11452 00000A01 3C1A                    	cmp	al,1Ah			; ^Z for termination?
 11453 00000A03 7575                    	jne	short GETBYTEDONE
 11454                                  
 11455                                  ;We get here only when we hit an EOF
 11456                                  	
 11457                                  	; MSDOS 6.0
 11458                                  BATEOFDS:
 11459                                  ;SR;
 11460                                  ; HACK!!! A massive hack being put in here to get batch processing to work
 11461                                  ;properly on EOF. Previously, a CR was returned and batch processing turned
 11462                                  ;off the moment we hit an EOF. Unfortunately, if the last line had no CR-LF,
 11463                                  ;batch processing is turned off before the last line is processed and so 
 11464                                  ;this line would never be executed. 
 11465                                  ;   	To fix this, a new flag BatchEOF has been introduced. This flag is
 11466                                  ;set to 4 if there is no CR-LF before the EOF -- this is determined by looking
 11467                                  ;at the buffer contents. If there is no LF ( we assume that presence of LF
 11468                                  ;indicated a CR-LF combination), then we set BatchEOF to 4 and return a 
 11469                                  ;fake CR to the caller. This decrements BatchEOF. On the next call to this
 11470                                  ;routine, BatchEOF is decremented to 2 and a fake lF is returned. On the 
 11471                                  ;third call, BatchEOF becomes zero and batch processing is turned off,
 11472                                  ;now that the last line has been processed. If the EOF is the first char read into the buffer 
 11473                                  ;during this call, and there was a CR-LF previously, we are going to fake
 11474                                  ;another redundant CR-LF. There is no work-around I can think of.
 11475                                  ; 	I would love to restructure this entire routine and its caller to
 11476                                  ;make the flow really easy to understand but I guess this will have to wait.
 11477                                  ;
 11478 00000A05 06                      	push	es
 11479 00000A06 8E06[9C8A]              	mov	es,[RESSEG]
 11480                                  ;SR;
 11481                                  ; If we had already set the BatchEOF flag on a previous call (BatchEOF == 2
 11482                                  ;or BatchEOF == 1 now), then do not do the LF check.
 11483                                  ;
 11484 00000A0A 268E06[4C01]            	mov	es,[es:Batch]
 11485                                  	;cmp	byte [es:2],0
 11486 00000A0F 26803E020000            	cmp	byte [es:BATCHSEGMENT.BatchEOF],0
 11487 00000A15 7516                    	jnz	short crpresent
 11488                                  
 11489                                  	;inc	byte [es:2]
 11490 00000A17 26FE060200              	inc	byte [es:BATCHSEGMENT.BatchEOF]
 11491                                  					;match the dec following
 11492 00000A1C 8B1E[C595]              	mov	bx,[BATBUFEND]
 11493 00000A20 80BF[A495]0A            	cmp	byte [bx+BATBUF-1],0Ah	;was a LF present?
 11494 00000A25 7406                    	je	short crpresent		;yes, no need to fake it
 11495                                  
 11496                                  	;add	byte [es:2],3
 11497 00000A27 268006020003            	add	byte [es:BATCHSEGMENT.BatchEOF],3
 11498                                  					;BatchEOF == 4 to fake CR-LF
 11499                                  crpresent:
 11500                                  ;;	;pop	es
 11501                                  
 11502                                  	;ASSUME	DS:TranGroup
 11503                                  	; 14/02/2023
 11504 00000A2D 8E1E[9C8A]              	mov	ds,[RESSEG]
 11505                                  	;ASSUME	DS:ResGroup
 11506                                  ;SR;
 11507                                  ; The shift operation is done here to replace the decrement. This is because
 11508                                  ;we can jump to this label directly from above when bogus calls are made to
 11509                                  ;this routine even after batch processing is turned off. The shift ensures
 11510                                  ;maintains the following invariance : 4 -> 2; 2 -> 1 ; 1 -> 0; 0 -> 0. Thus,
 11511                                  ;it is used as a decrement and also as a NOP to just fall through on bogus 
 11512                                  ;calls.
 11513                                  ;	We turn batch processing off if BatchEOF == 1 or BatchEOF == 0.
 11514                                  ;BatchEOF == 1 when we fall through from BatEOFDS and BatchEOF == 0 on a 
 11515                                  ;direct jump to BATEOF. If BatchEOF == 4, we return a fake CR-LF without 
 11516                                  ;turning batch processing off.
 11517                                  
 11518                                  At_EOF:					;new label added ;M020
 11519                                  	;shr	byte [es:2],1
 11520 00000A31 26D02E0200              	shr	byte [es:BATCHSEGMENT.BatchEOF],1
 11521                                  					;decrement the flag
 11522 00000A36 7412                    	jz	short turn_off		;zero,turn batch off
 11523                                  	;cmp	byte [es:2],1
 11524 00000A38 26803E020001            	cmp	byte [es:BATCHSEGMENT.BatchEOF],1				
 11525 00000A3E 7405                    	jz	short ret_lf		;BatchEOF was 2, return LF
 11526                                  ;
 11527                                  ;BatchEOF == 4, indicates return fake CR now and fake LF next.
 11528                                  ;
 11529 00000A40 B00D                    	mov	al,0Dh			;return fake CR.
 11530 00000A42 07                      	pop	es
 11531 00000A43 EB35                    	jmp	short GETBYTEDONE
 11532                                  ret_lf:
 11533 00000A45 B00A                    	mov	al,0Ah			;return fake LF
 11534 00000A47 07                      	pop	es
 11535 00000A48 EB30                    	jmp	short GETBYTEDONE		
 11536                                  turn_off:
 11537 00000A4A 07                      	pop	es
 11538                                  ;BATEOF:
 11539                                  	; MSDOS 3.3
 11540                                  ;TURN_OFF:
 11541                                  	;mov	ds,[RESSEG]
 11542                                  
 11543                                  	; MSDOS 3.3 (& MSDOS 6.0)
 11544                                  BATEOF:
 11545 00000A4B E8B0FE                  	call	BATCHOFF
 11546 00000A4E E8CC02                  	call	BATCLOSE
 11547                                  
 11548                                  ;;;	mov	BatchEOF,0	;make sure BatchEOF = 0
 11549                                  
 11550                                  ;SR; BugBug
 11551                                  ; There is a good reason why this carriage return is being returned here. 
 11552                                  ;This was part of the old code, thanks to some brain-damaged coding. Because,
 11553                                  ;of the way the caller is structured, a fake CR has to be returned again on
 11554                                  ;EOF to ensure the termination of the caller's loop. If echo is on, this
 11555                                  ;results in an extra linefeed after the batchfile is run if the last line of
 11556                                  ;the batchfile already had a CR-LF. 
 11557                                  ;NB: Do not confuse this with the faked CR. The fake CR-LF was to mark
 11558                                  ;the end-of-line. This CR is to mark the end-of-file.
 11559                                  
 11560 00000A51 B00D                    	mov	al,0Dh			; If end-of-file, then end of line
 11561 00000A53 F606[9601]FF            	test	byte [Batch_Abort],-1
 11562 00000A58 C606[9601]00            	mov	byte [Batch_Abort],0
 11563 00000A5D 7407                    	jz	short CONT_GET_BYT
 11564 00000A5F BF[FD88]                	mov	di,COMBUF+2		; reset pointer to beginning of buffer
 11565 00000A62 31C9                    	xor	cx,cx			; zero line length
 11566 00000A64 EB14                    	jmp	short GETBYTEDONE
 11567                                  CONT_GET_BYT:
 11568 00000A66 833E[A601]F0            	cmp	word [SingleCom],0FFF0h ; See if we need to set SINGLECOM
 11569 00000A6B 750D                    	jne	short GETBYTEDONE
 11570 00000A6D 833E[AF01]00            	cmp	word [Nest],0		;G See if we have nested batch files
 11571 00000A72 7506                    	jnz	short GETBYTEDONE	;G Yes - don't exit just yet
 11572 00000A74 C706[A601]FFFF          	mov	word [SingleCom],0FFFFh	; -1 ; Cause termination
 11573                                  GETBYTEDONE:
 11574 00000A7A 1F                      	pop	ds
 11575 00000A7B 59                      	pop	cx
 11576 00000A7C 5B                      	pop	bx
 11577 00000A7D C3                      	retn
 11578                                  
 11579                                  ; ---------------------------------------------------------------------------
 11580                                  
 11581                                  ;break	<$If - conditional execution>
 11582                                  
 11583                                  	; 17/04/2023
 11584                                  ;IFERRORP:
 11585                                  ;	pop	ax
 11586                                  ;IFERROR:
 11587                                  ;	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11588                                  ;FORERROR:
 11589                                  ;	mov	dx,SYNTMES_PTR
 11590                                  ;	jmp	cerror
 11591                                  
 11592                                  ; ---------------------------------------------------------------------------
 11593                                  
 11594                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11595                                  _$IF:
 11596                                  	; MSDOS 6.0
 11597                                  ; Turn off any pipes in progress.
 11598 00000A7E 1E                      	push	ds			;AN004; save local DS
 11599 00000A7F 8E1E[9C8A]              	mov	ds,[RESSEG]		;AN004; get resident segment
 11600                                  	;assume	ds:resgroup		;AN004;
 11601 00000A83 803E[1902]00            	cmp	byte [PipeFiles],0	;AN004; Only turn off if present.
 11602 00000A88 7403                    	jz	short IFNoPipe		;AN004; no pipe - continue
 11603                                  	;invoke	PipeDel 		;AN004; turn off piping
 11604 00000A8A E85B22                  	call	PIPEDEL	
 11605                                  IFNoPipe:				;AN004;
 11606 00000A8D 1F                      	pop	ds			;AN004; get local DS back
 11607                                  	;assume	ds:trangroup		;AN004;
 11608                                  
 11609                                  	; MSDOS 3.3 (&MSDOS 6.0)
 11610 00000A8E C606[AF8A]00            	mov	byte [IFNOTFLAG],0
 11611 00000A93 C706[7794]0000          	mov	word [IF_NOT_COUNT],0
 11612 00000A99 BE8100                  	mov	si,81h
 11613                                  IFREENT:
 11614 00000A9C E8381B                  	call	scanoff
 11615 00000A9F 3C0D                    	cmp	al,0Dh
 11616 00000AA1 743C                    	je	short IFERROR
 11617 00000AA3 89F5                    	mov	bp,si
 11618 00000AA5 BF[CA82]                	mov	di,IFTAB		; Prepare to search if table	
 11619                                  	;mov	ch,0
 11620                                  	; 17/04/2023
 11621 00000AA8 30ED                    	xor	ch,ch
 11622                                  IFINDCOM:
 11623 00000AAA 89EE                    	mov	si,bp
 11624 00000AAC 8A0D                    	mov	cl,[di]
 11625 00000AAE 47                      	inc	di
 11626 00000AAF E33E                    	jcxz	IFSTRING
 11627 00000AB1 EB02                    	jmp	short FIRSTCOMP
 11628                                  IFCOMP:
 11629 00000AB3 7510                    	jnz	short IF_DIF
 11630                                  FIRSTCOMP:
 11631 00000AB5 AC                      	lodsb
 11632 00000AB6 268A25                  	mov	ah,[es:di]
 11633 00000AB9 47                      	inc	di
 11634 00000ABA 38E0                    	cmp	al,ah
 11635 00000ABC 7405                    	je	short IFLP
 11636 00000ABE 80CC20                  	or	ah,20h			; Try lower case
 11637 00000AC1 38E0                    	cmp	al,ah
 11638                                  IFLP:
 11639 00000AC3 E2EE                    	loop	IFCOMP
 11640                                  IF_DIF:
 11641 00000AC5 9F                      	lahf
 11642 00000AC6 01CF                    	add	di,cx			; Bump to next position without affecting flags
 11643 00000AC8 8B1D                    	mov	bx,[di]			; Get handler address
 11644 00000ACA 47                      	inc	di
 11645 00000ACB 47                      	inc	di
 11646 00000ACC 9E                      	sahf
 11647 00000ACD 75DB                    	jnz	short IFINDCOM
 11648 00000ACF AC                      	lodsb
 11649 00000AD0 3C0D                    	cmp	al,0Dh
 11650                                  IFERRJ:
 11651 00000AD2 740B                    	jz	short IFERROR
 11652 00000AD4 E8081B                  	call	DELIM
 11653 00000AD7 75D1                    	jnz	short IFINDCOM
 11654 00000AD9 E8FB1A                  	call	scanoff
 11655 00000ADC FFE3                    	jmp	bx
 11656                                  
 11657                                  	; 17/04/2023
 11658                                  IFERRORP:
 11659 00000ADE 58                      	pop	ax
 11660                                  IFERROR:
 11661                                  	; 14/02/2023 - Retro DOS v4.0 COMMAND.COM
 11662                                  FORERROR:
 11663 00000ADF BA[C97F]                	mov	dx,SYNTMES_PTR
 11664 00000AE2 E9661E                  	jmp	cerror
 11665                                  
 11666                                  IFNOT:
 11667 00000AE5 F616[AF8A]              	not	byte [IFNOTFLAG]
 11668 00000AE9 FF06[7794]              	inc	word [IF_NOT_COUNT]
 11669 00000AED EBAD                    	jmp	short IFREENT
 11670                                  
 11671                                  ; We are comparing two strings for equality. First, find the end of the
 11672                                  ; first string.
 11673                                  
 11674                                  IFSTRING:
 11675 00000AEF 56                      	push	si			; save away pointer for later compare
 11676 00000AF0 31C9                    	xor	cx,cx			; count of chars in first string
 11677                                  FIRST_STRING:
 11678 00000AF2 AC                      	lodsb				; get character
 11679 00000AF3 3C0D                    	cmp	al,0Dh			; end of line?
 11680 00000AF5 74E7                    	jz	short IFERRORP		; yes => error
 11681 00000AF7 E8E51A                  	call	DELIM			; is it a delimiter?
 11682 00000AFA 7403                    	jz	short EQUAL_CHECK 	; yes, go find equal sign
 11683 00000AFC 41                      	inc	cx			; remember 1 byte for the length
 11684 00000AFD EBF3                    	jmp	short FIRST_STRING 	; go back for more
 11685                                  EQUAL_CHECK:
 11686 00000AFF 3C3D                    	cmp	al,'='			; is char we have an = sign?
 11687 00000B01 7407                    	je	short EQUAL_CHECK2 	; yes, go find second one.
 11688 00000B03 3C0D                    	cmp	al,0Dh			; end of line?
 11689 00000B05 74D7                    	je	short IFERRORP		; yes, syntax error
 11690 00000B07 AC                      	lodsb				; get next char
 11691 00000B08 EBF5                    	jmp	short EQUAL_CHECK
 11692                                  
 11693                                  ; The first = has been found. The next char had better be an = too.
 11694                                  
 11695                                  EQUAL_CHECK2:
 11696 00000B0A AC                      	lodsb				; get potential = char
 11697 00000B0B 3C3D                    	cmp	al,'='			; is it good?	
 11698                                  	;jnz	short IFERRPJ		; no, error
 11699                                  	; 17/04/2023
 11700 00000B0D 75CF                    	jne	short IFERRORP
 11701                                  
 11702                                  ; Find beginning of second string.
 11703                                  
 11704 00000B0F E8C51A                  	call	scanoff
 11705 00000B12 3C0D                    	cmp	al,0Dh
 11706                                  	;jz	short IFERRPJ
 11707                                  	; 17/04/2023
 11708 00000B14 74C8                    	je	short IFERRORP
 11709 00000B16 5F                      	pop	di
 11710                                  
 11711                                  ; DS:SI points to second string
 11712                                  ; CX has number of chars in first string
 11713                                  ; ES:DI points to first string
 11714                                  
 11715 00000B17 F3A6                    	repe	cmpsb
 11716 00000B19 7414                    	jz	short MATCH		; match found!
 11717                                  
 11718                                  ; No match. Let's find out what was wrong. The character that did not match
 11719                                  ; has been advanced over. Let's back up to it.
 11720                                  
 11721 00000B1B 4E                      	dec	si
 11722                                  
 11723                                  ; If it is EOL, then syntax error
 11724                                  
 11725 00000B1C 803C0D                  	cmp	byte [si],0Dh
 11726                                  	;jz	short IFERRJ
 11727                                  	; 17/04/2023
 11728 00000B1F 74BE                    	je	short IFERROR
 11729                                  
 11730                                  ; Advance pointer over remainder of unmatched text to next delimiter
 11731                                  
 11732                                  SKIPSTRINGEND:
 11733 00000B21 AC                      	lodsb
 11734                                  NOTMATCH:
 11735 00000B22 3C0D                    	cmp	al,0Dh
 11736                                  IFERRORJ2:
 11737                                  	;jz	short IFERRJ
 11738                                  	; 17/04/2023
 11739 00000B24 74B9                    	jz	short IFERROR
 11740 00000B26 E8B61A                  	call	DELIM
 11741 00000B29 75F6                    	jnz	short SKIPSTRINGEND
 11742                                  
 11743                                  ; Signal that we did NOT have a match
 11744                                  
 11745 00000B2B B0FF                    	mov	al,-1
 11746 00000B2D EB37                    	jmp	short IFRET
 11747                                  
 11748                                  	; 17/04/2023
 11749                                  ;IFERRPJ:
 11750                                  	;jmp	IFERRORP
 11751                                  
 11752                                  ; The compare succeeded. Was the second string longer than the first?
 11753                                  ; We do this by seeing if the next char is a delimiter.
 11754                                  
 11755                                  MATCH:
 11756 00000B2F AC                      	lodsb
 11757 00000B30 E8AC1A                  	call	DELIM
 11758 00000B33 75ED                    	jnz	short NOTMATCH ; not same.
 11759 00000B35 30C0                    	xor	al,al
 11760 00000B37 EB2D                    	jmp	short IFRET
 11761                                  
 11762                                  ; ---------------------------------------------------------------------------
 11763                                  
 11764                                  IFEXISTS:
 11765                                  
 11766                                  IFEXIST_ATTR	EQU	ATTR_HIDDEN+ATTR_SYSTEM  ; 2+4 = 6
 11767                                  
 11768                                  ;MOREDELIM:
 11769 00000B39 AC                      	lodsb
 11770 00000B3A E8A21A                  	call	DELIM
 11771 00000B3D 75FA                    	jnz	short IFEXISTS
 11772                                  	;jnz	short MOREDELIM
 11773                                  
 11774 00000B3F BA[A58B]                	mov	dx,DIRBUF
 11775 00000B42 B8001A                  	mov	ax,1A00h
 11776                                  	;mov	ax,Set_DMA*256 ; 1A00h
 11777 00000B45 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 11778                                  			; DS:DX	-> disk	transfer buffer
 11779 00000B47 BB0200                  	mov	bx,2	; if(0) [|not](|1) exist[1|2] file(2|3)
 11780 00000B4A 031E[7794]              	add	bx,[IF_NOT_COUNT]
 11781                                  	;mov	ax,ARG_ARGV
 11782                                  	;mov	ax,ARG+ARG_UNIT.argv
 11783 00000B4E B8[2B8E]                	mov	ax,ARG
 11784 00000B51 E80226                  	call	argv_calc		; convert arg index to pointer
 11785 00000B54 8B17                    	mov	dx,[bx]
 11786                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 11787                                  	;mov	cx,6
 11788 00000B56 B90600                  	mov	cx,IFEXIST_ATTR ; filetypes to search for
 11789 00000B59 B8004E                  	mov	ax,4E00h
 11790                                  	;mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 11791 00000B5C CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 11792                                  			; CX = search attributes
 11793                                  			; DS:DX	-> ASCIZ filespec
 11794                                  			; (drive,path, and wildcards allowed)
 11795 00000B5E 7204                    	jc	short IF_EX_C ; carry is how to determine error
 11796 00000B60 30C0                    	xor	al,al
 11797 00000B62 EB02                    	jmp	short IFRET
 11798                                  
 11799                                  	;nop
 11800                                  IF_EX_C:
 11801 00000B64 B0FF                    	mov	al,-1			; false 'n' fall through...
 11802                                  IFRET:
 11803 00000B66 F606[AF8A]FF            	test	byte [IFNOTFLAG],-1 ; 0FFh
 11804 00000B6B 7402                    	jz	short REALTEST
 11805 00000B6D F6D0                    	not	al
 11806                                  REALTEST:
 11807 00000B6F 08C0                    	or	al,al
 11808 00000B71 7403                    	jz	short IFTRUE
 11809 00000B73 E98EF5                  	jmp	TCOMMAND
 11810                                  
 11811                                  IFTRUE:
 11812 00000B76 E85E1A                  	call	scanoff
 11813 00000B79 89F1                    	mov	cx,si
 11814 00000B7B 81E98100                	sub	cx,81h
 11815 00000B7F 280E8000                	sub	[80h],cl
 11816 00000B83 8A0E8000                	mov	cl,[80h]
 11817 00000B87 880E[FC88]              	mov	[COMBUF+1],cl
 11818 00000B8B BF[FD88]                	mov	di,COMBUF+2
 11819 00000B8E FC                      	cld
 11820 00000B8F F3A4                    	rep	movsb
 11821 00000B91 B00D                    	mov	al,0Dh
 11822 00000B93 AA                      	stosb
 11823                                  
 11824                                  ; Signal that an IF was done. 
 11825                                  ; This prevents the redirections from getting lost.
 11826                                  
 11827 00000B94 1E                      	push	ds
 11828 00000B95 8E1E[9C8A]              	mov	ds,[RESSEG]
 11829 00000B99 C606[AB01]FF            	mov	byte [IfFlag],-1
 11830 00000B9E 1F                      	pop	ds
 11831                                  
 11832                                  ; Go do the command
 11833                                  
 11834 00000B9F E935F7                  	jmp	DOCOM1
 11835                                  
 11836                                  ; ---------------------------------------------------------------------------
 11837                                  
 11838                                  IFERRORJ3:
 11839 00000BA2 EB80                    	jmp	IFERRORJ2
 11840                                  
 11841                                  IFERLEV:
 11842 00000BA4 B70A                    	mov	bh,10
 11843 00000BA6 30DB                    	xor	bl,bl
 11844                                  GETNUMLP:
 11845 00000BA8 AC                      	lodsb
 11846 00000BA9 3C0D                    	cmp	al,0Dh
 11847 00000BAB 74F5                    	je	short IFERRORJ3
 11848 00000BAD E82F1A                  	call	DELIM
 11849 00000BB0 740C                    	jz	short GOTNUM
 11850 00000BB2 2C30                    	sub	al,'0'
 11851 00000BB4 86C3                    	xchg	al,bl
 11852 00000BB6 F6E7                    	mul	bh
 11853 00000BB8 00D8                    	add	al,bl
 11854 00000BBA 86C3                    	xchg	al,bl
 11855 00000BBC EBEA                    	jmp	short GETNUMLP
 11856                                  GOTNUM:
 11857 00000BBE 1E                      	push	ds
 11858 00000BBF 8E1E[9C8A]              	mov	ds,[RESSEG]
 11859 00000BC3 8A26[9D01]              	mov	ah,[RetCode]
 11860 00000BC7 1F                      	pop	ds
 11861 00000BC8 30C0                    	xor	al,al
 11862 00000BCA 38DC                    	cmp	ah,bl
 11863 00000BCC 7398                    	jnb	short IFRET
 11864 00000BCE FEC8                    	dec	al
 11865 00000BD0 EB94                    	jmp	short IFRET
 11866                                  
 11867                                  ; ---------------------------------------------------------------------------
 11868                                  
 11869                                  ; Shift the parameters in the batch structure by 1 and set up the new argument.
 11870                                  ; This is a NOP if no batch in progress.
 11871                                  
 11872                                  _SHIFT:
 11873 00000BD2 8E1E[9C8A]              	mov	ds,[RESSEG]
 11874 00000BD6 A1[4C01]                	mov	ax,[Batch]		; get batch pointer
 11875 00000BD9 09C0                    	or	ax,ax			; in batch mode?
 11876 00000BDB 7501                    	jnz	short SHIFT1		; yes, operate in batch segment	
 11877                                  SHIFT_RETN:				; no, done.
 11878 00000BDD C3                      	retn
 11879                                  SHIFT1:
 11880 00000BDE 8EC0                    	mov	es,ax
 11881 00000BE0 8ED8                    	mov	ds,ax
 11882                                  
 11883                                  ; Now move the batch args down by 1 word
 11884                                  
 11885                                  	;;mov	di,0Bh ; MSDOS 3.3 COMMAND.COM
 11886                                  	;mov	di,0Ch ; MSDOS 5.0 COMMAND.COM
 11887 00000BE2 BF0C00                  	mov	di,BATCHSEGMENT.BatParm ; point to parm table
 11888 00000BE5 8D7502                  	lea	si,[di+2]		; make source = dest + 2
 11889 00000BE8 B90900                  	mov	cx,9			; move 9 parameters
 11890 00000BEB F3A5                    	rep	movsw			; SHIFT down
 11891                                  
 11892                                  ; If the last parameter (the one not moved) is empty (= -1) then we are done.
 11893                                  ; We have copied it into the previous position.
 11894                                  
 11895 00000BED 833DFF                  	cmp	word [di],-1	; if last one was not in use then
 11896 00000BF0 74EB                    	je	short SHIFT_RETN ; No new parm
 11897                                  
 11898                                  ; This last pointer is NOT nul. Get it and scan to find the next argument.
 11899                                  ; Assume, first, that there is no next argument.
 11900                                   
 11901 00000BF2 8B35                    	mov	si,[di]
 11902 00000BF4 C705FFFF                	mov	word [di],-1		; Assume no parm
 11903                                  
 11904                                  ; The parameters are CR separated. Scan for end of this parm.
 11905                                  
 11906                                  SKIPCRLP:
 11907 00000BF8 AC                      	lodsb
 11908 00000BF9 3C0D                    	cmp	al,0Dh
 11909 00000BFB 75FB                    	jne	short SKIPCRLP
 11910                                  
 11911                                  ; We are now pointing at next arg. If it is 0 (end of original line) then we
 11912                                  ; are finished. There are no more parms and the pointer has been previously
 11913                                  ; initialized to indicate it.
 11914                                  
 11915 00000BFD 803C00                  	cmp	byte [si],0
 11916 00000C00 74DB                    	jz	short SHIFT_RETN 	; End of parms
 11917 00000C02 8935                    	mov	[di],si			; Pointer to next parm as %9
 11918 00000C04 C3                      	retn
 11919                                  
 11920                                  ; =============== S U B	R O U T	I N E =======================================
 11921                                  
 11922                                  ; Skip delim reads bytes from the batch file until a non-delimiter is seen.
 11923                                  ; returns char in AL, carry set -> eof
 11924                                  
 11925                                  SKIPDELIM:
 11926 00000C05 F706[4C01]FFFF          	test	word [Batch],-1		; batch file empty. OOPS!
 11927 00000C0B 740A                    	jz	short SKIPERR
 11928 00000C0D E85DFD                  	call	GETBATBYT		; get a char
 11929 00000C10 E8CC19                  	call	DELIM			; check for ignoreable chars
 11930 00000C13 74F0                    	jz	short SKIPDELIM		; ignore this char.
 11931 00000C15 F8                      	clc
 11932 00000C16 C3                      	retn
 11933                                  SKIPERR:
 11934 00000C17 F9                      	stc
 11935                                  GOTO_RETN:
 11936 00000C18 C3                      	retn
 11937                                  
 11938                                  ; ---------------------------------------------------------------------------
 11939                                  
 11940                                  ;  CALL is an internal command that transfers control to a .bat, .exe, or
 11941                                  ;  .com file. This routine strips the CALL off the command line, sets
 11942                                  ;  the CALL_FLAG to indicate a call in progress, and returns control to
 11943                                  ;  DOCOM1 in TCODE to reprocess the command line and execute the file
 11944                                  ;  being CALLed.
 11945                                  
 11946                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11947                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0C27h
 11948                                  _$CALL:
 11949                                  
 11950                                  ;  strip off CALL from command line
 11951                                  
 11952                                  	;ASSUME DS:trangroup,ES:trangroup
 11953                                  
 11954 00000C19 56                      	push	si
 11955 00000C1A 57                      	push	di
 11956 00000C1B 50                      	push	ax
 11957 00000C1C 51                      	push	cx
 11958 00000C1D BE[FD88]                	mov	si,COMBUF+2
 11959 00000C20 E8B419                  	call	scanoff			;get to first non-delimeter
 11960                                  	;add	si,4
 11961 00000C23 83C604                  	add	si,length_call		;point to char past CALL
 11962 00000C26 BF[FD88]                	mov	di,COMBUF+2
 11963                                  	;mov	cx,124		
 11964 00000C29 B97C00                  	mov	cx,COMBUFLEN-length_call 
 11965                                  					;get length of buffer
 11966 00000C2C F3A4                    	rep	movsb			;move it
 11967 00000C2E 59                      	pop	cx
 11968 00000C2F 58                      	pop	ax
 11969 00000C30 5F                      	pop	di
 11970 00000C31 5E                      	pop	si
 11971                                  
 11972                                  ;  set call flag to indicate call in progress
 11973                                  
 11974 00000C32 1E                      	push	ds
 11975 00000C33 8E1E[9C8A]              	mov	ds,[RESSEG]
 11976 00000C37 C606[B101]01            	mov	byte [Call_Flag],call_in_progress ; 1
 11977 00000C3C C606[B201]01            	mov	byte [Call_Batch_Flag],call_in_progress ; 1
 11978                                  
 11979                                  ; Turn off any pipes in progress.
 11980                                  
 11981 00000C41 803E[1902]00            	cmp	byte [PipeFiles],0 	; Only turn off if present.
 11982 00000C46 7403                    	jz	short _NOPIPE
 11983 00000C48 E89D20                  	call	PIPEDEL
 11984                                  _NOPIPE:
 11985 00000C4B 1F                      	pop	ds
 11986 00000C4C C3                      	retn
 11987                                  
 11988                                  ; ---------------------------------------------------------------------------
 11989                                  
 11990                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 11991                                  _GOTO:
 11992 00000C4D 8E1E[9C8A]              	mov	ds,[RESSEG]
 11993 00000C51 F706[4C01]FFFF          	test	word [Batch],-1	; If not in batch mode, a nop
 11994 00000C57 74BF                    	jz	short GOTO_RETN
 11995 00000C59 31D2                    	xor	dx,dx
 11996 00000C5B 1E                      	push	ds
 11997 00000C5C 8E1E[4C01]              	mov	ds,[Batch]
 11998                                  	;mov	[8],dx	; MSDOS 5.0 COMMAND.COM
 11999 00000C60 89160800                	mov	[BATCHSEGMENT.BatSeek],dx ; Back to start
 12000                                  	;mov	[10],dx	; MSDOS 5.0 COMMAND.COM
 12001 00000C64 89160A00                	mov	[BATCHSEGMENT.BatSeek+2],dx ; Back to start
 12002                                  
 12003                                  	; MSDOS 6.0
 12004                                  ;M037
 12005                                  ; Clear EOF indicator because we have reseeked to the beginning of the file.
 12006                                  ;
 12007 00000C68 C606020000              	mov	byte [BATCHSEGMENT.BatchEOF],0
 12008                                  					; clear eof indicator ;M037
 12009                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12010 00000C6D 1F                      	pop	ds
 12011                                  GOTOOPEN:
 12012 00000C6E E870F8                  	call	PROMPTBAT
 12013                                  	;mov	di,5Dh
 12014 00000C71 BF5D00                  	mov	di,FCB+1		; Get the label
 12015 00000C74 B90B00                  	mov	cx,11
 12016 00000C77 B020                    	mov	al,' '
 12017 00000C79 F2AE                    	repne	scasb
 12018 00000C7B 7501                    	jnz	short NOINC
 12019 00000C7D 41                      	inc	cx
 12020                                  NOINC:
 12021 00000C7E 83E90B                  	sub	cx,11
 12022 00000C81 F7D9                    	neg	cx
 12023                                  	;mov	[cs:GOTOLEN],cx
 12024                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12025 00000C83 26890E[A58B]            	mov	[es:GOTOLEN],cx	; MSDOS 5.0 (& 6.0)
 12026                                  
 12027                                  ; At beginning of file. Skip to first non-delimiter char
 12028                                  
 12029 00000C88 E87AFF                  	call	SKIPDELIM
 12030 00000C8B 721C                    	jb	short BADGOTO
 12031 00000C8D 3C3A                    	cmp	al,':'
 12032 00000C8F 7426                    	jz	short CHKLABEL
 12033                                  LABLKLP:				; Look for the label
 12034 00000C91 E8D9FC                  	call	GETBATBYT
 12035 00000C94 3C0A                    	cmp	al,0Ah
 12036 00000C96 7509                    	jne	short LABLKTST
 12037                                  
 12038                                  ; At beginning of line. Skip to first non-delimiter char
 12039                                  
 12040 00000C98 E86AFF                  	call	SKIPDELIM
 12041 00000C9B 720C                    	jb	short BADGOTO
 12042 00000C9D 3C3A                    	cmp	al,':'
 12043 00000C9F 7416                    	je	short CHKLABEL
 12044                                  LABLKTST:
 12045 00000CA1 F706[4C01]FFFF          	test	word [Batch],0FFFFh ; -1
 12046 00000CA7 75E8                    	jnz	short LABLKLP
 12047                                  BADGOTO:
 12048 00000CA9 E87100                  	call	BATCLOSE
 12049                                  
 12050                                  	; MSDOS 6.0
 12051                                  ;SR;
 12052                                  ; At this point we are terminating without freeing up any nested batch 
 12053                                  ;segments i.e if the error occurred within a called batch file. This routine
 12054                                  ;will traverse the linked list of batch segments and free all of them.
 12055                                  ;
 12056 00000CAC E8BB00                  	call	free_batch		; free up nested batch segments
 12057                                  
 12058                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12059 00000CAF 0E                      	push	cs
 12060 00000CB0 1F                      	pop	ds
 12061 00000CB1 BA[C67F]                	mov	dx,BADLAB_PTR
 12062 00000CB4 E9941C                  	jmp	cerror
 12063                                  
 12064                                  ; Found the :.	Skip to first non-delimiter char
 12065                                  
 12066                                  CHKLABEL:
 12067 00000CB7 E84BFF                  	call	SKIPDELIM
 12068 00000CBA 72ED                    	jb	short BADGOTO
 12069 00000CBC BF5D00                  	mov	di,FCB+1 ; 5Dh
 12070                                  	;mov	cx,[cs:GOTOLEN]
 12071                                  	; 14/02/2023
 12072 00000CBF 268B0E[A58B]            	mov	cx,[es:GOTOLEN]	 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12073 00000CC4 EB05                    	jmp	short GOTBYTE
 12074                                  
 12075                                  NEXTCHRLP:
 12076 00000CC6 51                      	push	cx
 12077 00000CC7 E8A3FC                  	call	GETBATBYT
 12078 00000CCA 59                      	pop	cx
 12079                                  GOTBYTE:
 12080                                  	; 18/03/2023
 12081                                  	; 14/02/2023
 12082                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CD9h
 12083 00000CCB E8EA16                  	call	testkanj
 12084 00000CCE 7413                    	jz	short NOTKANJ1
 12085 00000CD0 263A05                  	cmp	al,[es:di]
 12086 00000CD3 75CC                    	jne	short LABLKTST
 12087 00000CD5 47                      	inc	di
 12088 00000CD6 49                      	dec	cx
 12089 00000CD7 E3C8                    	jcxz	LABLKTST
 12090 00000CD9 51                      	push	cx
 12091 00000CDA E890FC                  	call	GETBATBYT
 12092 00000CDD 59                      	pop	cx
 12093 00000CDE 263A05                  	cmp	al,[es:di]
 12094 00000CE1 EB0C                    	jmp	short KNEXTLABCHR
 12095                                  NOTKANJ1:
 12096                                  	; 14/02/2023
 12097                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0CF1h
 12098 00000CE3 0C20                    	or	al,20h
 12099 00000CE5 263A05                  	cmp	al,[es:di]
 12100                                  	;jne	short TRYUPPER
 12101                                  	;jmp	short NEXTLABCHR
 12102                                  	; 25/04/2023
 12103 00000CE8 7407                    	je	short NEXTLABCHR 
 12104                                  TRYUPPER:
 12105 00000CEA 2C20                    	sub	al,20h
 12106 00000CEC 263A05                  	cmp	al,[es:di]
 12107                                  KNEXTLABCHR:
 12108 00000CEF 75B0                    	jnz	short LABLKTST
 12109                                  NEXTLABCHR:
 12110 00000CF1 47                      	inc	di
 12111 00000CF2 E2D2                    	loop	NEXTCHRLP
 12112 00000CF4 E876FC                  	call	GETBATBYT
 12113                                  	; 14/02/2023
 12114 00000CF7 26833E[A58B]08          	cmp	word [es:GOTOLEN],8 ;  MSDOS 5.0 (& 6.0) COMMAND.COM
 12115                                  	;cmp	word [cs:GOTOLEN],8 ; Is the label at least 8 chars long?
 12116 00000CFD 7D04                    	jge	short GOTOCONT	; Yes, then the next char doesn't matter
 12117 00000CFF 3C20                    	cmp	al,' '
 12118 00000D01 779E                    	ja	short LABLKTST
 12119                                  GOTOCONT:
 12120 00000D03 3C0D                    	cmp	al,0Dh
 12121 00000D05 7407                    	je	short SKIPLFEED
 12122                                  TONEXTBATLIN:
 12123 00000D07 E863FC                  	call	GETBATBYT
 12124 00000D0A 3C0D                    	cmp	al,0Dh
 12125 00000D0C 75F9                    	jne	short TONEXTBATLIN
 12126                                  SKIPLFEED:
 12127 00000D0E E85CFC                  	call	GETBATBYT
 12128                                  
 12129                                  	; MSDOS 6.0
 12130                                  ;SR;
 12131                                  ; The BatchEOF flag is set in GetBatByt to indicate that we are faking a 
 12132                                  ;CR-LF for the last line. On a goto, this flag has to be cleared, because
 12133                                  ;BatchEOF == 1 now, after returning a CR-LF. The next call to GetBatByt
 12134                                  ;to get the EOF has not been made yet because we encountered the Goto. On
 12135                                  ;all other cases, EOF will be hit while trying to read the next line and
 12136                                  ;we are fine. I know, I know, what a massive hack from hell!! God help us!!
 12137                                  ;
 12138 00000D11 06                      	push	es
 12139 00000D12 8E06[4C01]              	mov	es,[Batch]
 12140 00000D16 26C606020000            	mov	byte [es:BATCHSEGMENT.BatchEOF],0
 12141                                  					;invalidate fake CR-LF flag
 12142 00000D1C 07                      	pop	es
 12143                                  
 12144                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12145                                  	;call	BATCLOSE
 12146                                  	;retn
 12147                                  	; 14/02/2023
 12148                                  	;jmp	short BATCLOSE
 12149                                  
 12150                                  ; =============== S U B	R O U T	I N E =======================================
 12151                                  
 12152                                  BATCLOSE:
 12153 00000D1D 2E8B1E[D08D]            	mov	bx,[cs:BATHAND]
 12154 00000D22 83FB05                  	cmp	bx,5
 12155 00000D25 7204                    	jb	short CLOSERETURN
 12156                                  	; 14/02/2023
 12157 00000D27 B43E                    	mov	ah,3Eh
 12158                                  	;mov	ah,CLOSE ; 3Eh
 12159 00000D29 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 12160                                  			; BX = file handle
 12161                                  CLOSERETURN:
 12162 00000D2B C606[9501]00            	mov	byte [In_Batch],0 ; reset flag	
 12163 00000D30 C3                      	retn
 12164                                  
 12165                                  ; =============== S U B	R O U T	I N E =======================================
 12166                                  
 12167                                  ; Open the BATCH file, If open fails, AL is drive of batch file (A=1)
 12168                                  ; Also, fills internal batch buffer. If access denied, then AX = -1
 12169                                  
 12170                                  	; 14/02/2023
 12171                                  BATOPEN:
 12172 00000D31 1E                      	push	ds
 12173 00000D32 8E1E[4C01]              	mov	ds,[Batch]
 12174                                  	;;mov	dx,1Fh	; MSDOS 3.3 COMMAND.COM
 12175                                  	;mov	dx,20h	; MSDOS 5.0 COMMAND.COM
 12176 00000D36 BA2000                  	mov	dx,BATCHSEGMENT.BatFile
 12177 00000D39 B8003D                  	mov	ax,3D00h
 12178                                  	;mov	ax,(OPEN<<8) ; 3D00h ; Open the batch file
 12179 00000D3C CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 12180                                  			; DS:DX	-> ASCIZ filename
 12181                                  			; AL = access mode
 12182                                  			; 0 - read
 12183 00000D3E 721C                    	jb	short SETERRDL
 12184                                  	;mov	dx,[8]
 12185 00000D40 8B160800                	mov	dx,[BATCHSEGMENT.BatSeek]
 12186                                  	;mov	cx,[10]
 12187 00000D44 8B0E0A00                	mov	cx,[BATCHSEGMENT.BatSeek+2]
 12188 00000D48 1F                      	pop	ds
 12189                                  	;mov	[cs:BATHAND],ax
 12190 00000D49 26A3[D08D]              	mov	[es:BATHAND],ax ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12191 00000D4D 89C3                    	mov	bx,ax
 12192 00000D4F B80042                  	mov	ax,4200h
 12193                                  	;mov	ax,(LSEEK<<8) ; 4200h ; Go to the right spot
 12194 00000D52 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 12195                                  			; AL = method: offset from beginning of	file
 12196                                  
 12197                                  	;mov	word [cs:BATBUFPOS],-1 ; 0FFFFh
 12198                                  					; nuke batch buffer position
 12199 00000D54 26C706[A395]FFFF        	mov	word [es:BATBUFPOS],-1 ; MSDOS 5.0 (& 6.0) COMMAND.COM
 12200                                  BATOPEN_RETN:
 12201 00000D5B C3                      	retn
 12202                                  
 12203                                  SETERRDL:
 12204 00000D5C 89D3                    	mov	bx,dx
 12205                                  	; MSDOS 6.0
 12206                                  	;invoke	get_ext_error_number 	;AN022; get the extended error
 12207                                  	; 14/02/2023
 12208 00000D5E E89B0F                  	call	get_ext_error_number
 12209 00000D61 89C2                    	mov	dx,ax		     	;AN022; save extended error in DX
 12210                                  
 12211                                  	; MSDOS 3.3
 12212                                  	;mov	dx,INSERTDSKPTR
 12213                                  	;call	GET_EXT_ERR_NUMBER
 12214                                  
 12215                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12216 00000D63 8A07                    	mov	al,[bx]			; Get drive spec
 12217 00000D65 2C40                    	sub	al,'@'			; A = 1
 12218 00000D67 1F                      	pop	ds
 12219 00000D68 F9                      	stc				; SUB mucked over carry
 12220 00000D69 C3                      	retn
 12221                                  
 12222                                  ; =============== S U B	R O U T	I N E =======================================
 12223                                  
 12224                                  ;Free_batch : This routine traverses the linked batch segments freeing all
 12225                                  ;the batch and FOR segments until all of them are freed. It also restores
 12226                                  ;the old state of the EchoFlag.
 12227                                  ;
 12228                                  ;	ENTRY:	ds = RESGROUP
 12229                                  ;
 12230                                  ;	EXIT: 	All batch & FOR segments freed.
 12231                                  ;		EchoFlag restored to old state before batch process.
 12232                                  ;
 12233                                  ;	REGISTERS AFFECTED: bx, cx
 12234                                  
 12235                                  	; 14/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12236                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0D7Eh
 12237                                  
 12238                                  free_batch: ;proc near
 12239                                  	;assume	ds:RESGROUP,es:nothing
 12240                                  
 12241 00000D6A 06                      	push	es
 12242 00000D6B 8B1E[B301]              	mov	bx,[Next_Batch]
 12243 00000D6F 09DB                    	or	bx,bx
 12244 00000D71 7432                    	jz	short fb_ret
 12245                                  _ClearBatch:
 12246 00000D73 8EC3                    	mov	es,bx			; get batch segment
 12247                                  	;mov	bx,es:BatForPtr		; get old FOR segment
 12248 00000D75 268B1E0500              	mov	bx,[es:BATCHSEGMENT.BatForPtr] ; [es:5]
 12249 00000D7A 83FB00                  	cmp	bx,0			; is a FOR in progress
 12250 00000D7D 7408                    	je	short no_bat_for	; no - don't deallocate
 12251 00000D7F 06                      	push	es			;
 12252 00000D80 8EC3                    	mov	es,bx			; yes - free it up...
 12253 00000D82 B449                    	mov	ah,49h
 12254                                  	;mov	ah,DEALLOC		;
 12255 00000D84 CD21                    	int	21h			;
 12256 00000D86 07                      	pop	es			; restore to batch segment
 12257                                  no_bat_for:
 12258                                  	;mov	cl,[es:1]
 12259 00000D87 268A0E0100              	mov	cl,[es:BATCHSEGMENT.BatEchoFlag]
 12260                                  					; get old echo flag
 12261                                  	;mov	bx,[es:3]
 12262 00000D8C 268B1E0300              	mov	bx,[es:BATCHSEGMENT.BatLast]
 12263                                  					; get old batch segment
 12264 00000D91 B449                    	mov	ah,49h
 12265                                  	;mov	ah,DEALLOC		; free it up...
 12266 00000D93 CD21                    	int	21h
 12267                                  	; 14/02/2023
 12268                                  	;mov	[Batch],bx		; get ready to deallocate next batch
 12269 00000D95 FF0E[AF01]              	dec	word [Nest]		; is there another batch file?
 12270 00000D99 75D8                    	jnz	short _ClearBatch	; keep going until no batch file
 12271                                  	
 12272 00000D9B 880E[A001]              	mov	[EchoFlag],cl		;restore echo status
 12273 00000D9F C706[4C01]0000          	mov	word [Batch],0		;no batch process in progress
 12274                                  fb_ret:
 12275 00000DA5 07                      	pop	es
 12276 00000DA6 C3                      	ret
 12277                                  
 12278                                  ;free_batch endp
 12279                                  
 12280                                  ;============================================================================
 12281                                  ; TFOR.ASM, MSDOS 6.0, 1991
 12282                                  ;============================================================================
 12283                                  ; 10/10/2018 - Retro DOS v3.0
 12284                                  
 12285                                  ; All batch proccessing has DS set to segment of resident portion
 12286                                  ;ASSUME DS:RESGROUP,ES:TRANGROUP
 12287                                  
 12288                                  ; MSDOS 3.3 COMMAND.COM, transient portion/segment offset 0BE9h
 12289                                  
 12290                                  ; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12291                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:0DBFh
 12292                                  
 12293                                  ; ---------------------------------------------------------------------------
 12294                                  
 12295                                  	; 15/02/2023
 12296                                  FORTERM:
 12297                                  	; MSDOS 6.0
 12298 00000DA7 0E                      	push	cs			;AN037; Get local segment into
 12299 00000DA8 1F                      	pop	ds			;AN037;  DS, ES
 12300 00000DA9 0E                      	push	cs			;AN037;
 12301 00000DAA 07                      	pop	es			;AN037;
 12302                                  
 12303                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12304 00000DAB E89702                  	call	FOROFF
 12305                                  	;mov	ds,[cs:RESSEG]
 12306 00000DAE 268E1E[9C8A]            	mov	ds,[es:RESSEG] ; 15/02/2023 - MSDOS 5.0
 12307 00000DB3 813E[A601]00FF          	cmp	word [SingleCom],0FF00h
 12308 00000DB9 750F                    	jne	short BAT_CRLF
 12309 00000DBB 833E[AF01]00            	cmp	word [Nest],0		;See if we have nested batch files
 12310 00000DC0 7508                    	jne	short BAT_CRLF		;Yes - don't exit just yet
 12311 00000DC2 C706[A601]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause a terminate
 12312 00000DC8 EB12                    	jmp	short NOFORP2
 12313                                  BAT_CRLF:
 12314 00000DCA F606[A001]01            	test	byte [EchoFlag],1 	; Is echo on?
 12315 00000DCF 740B                    	jz	short NOFORP2		; no - exit
 12316 00000DD1 F706[4C01]FFFF          	test	word [Batch],-1 ; 0FFFFh
 12317                                  					; print CRLF if in batch
 12318 00000DD7 7403                    	jz	short NOFORP2
 12319 00000DD9 E8EE17                  	call	CRLF2
 12320                                  NOFORP2:
 12321 00000DDC E925F3                  	jmp	TCOMMAND
 12322                                  
 12323                                  ; ---------------------------------------------------------------------------
 12324                                  
 12325                                  ;------
 12326                                  ;   For-loop processing. For loops are of the form:
 12327                                  ;	    for %<loop-variable> in (<list>) do <command>
 12328                                  ; where <command> may contain references of the form %<variable>, which are
 12329                                  ; later substituted with the items in <list>. The for-loop structure is
 12330                                  ; set-up by the procedure '$for'; successive calls to 'forproc' execute
 12331                                  ; <command> once for each item in <list>. All of the information needed for
 12332                                  ; loop processing is stored on a piece of memory gotten from 'alloc'. This
 12333                                  ; structure is actually fairly large, on the order of 700 bytes, and includes
 12334                                  ; a complete copy of the original command-line structure as parsed by
 12335                                  ; 'parseline', loop control variables, and a dma buffer for the
 12336                                  ; 'FindFirst/FindNext' expansion of wildcard filenames in <list>. When loop
 12337                                  ; processing has completed, this chunk of memory is returned to the system.
 12338                                  ;
 12339                                  ;   All of the previously defined variables, in 'datares', used for loop
 12340                                  ; processing may be erased. Only one, (DW) ForPtr, need be allocated.
 12341                                  ;
 12342                                  ;   The error message, 'for_alloc_mes', should be moved into the file
 12343                                  ; containing all of the other error messages.
 12344                                  ;
 12345                                  ;   Referencing the allocated for-loop structure is a little tricky.
 12346                                  ; At the moment, a byte is defined as part of a new segment, 'for_segment'.
 12347                                  ; When 'forproc' actually runs, ES and DS are set to point to the base of the
 12348                                  ; new chunk of memory.	References to this byte, 'f', thus assemble correctly
 12349                                  ; as offsets of ES or DS. 'f' would not be necessary, except that the
 12350                                  ; assembler translates an instruction such as 'mov AX, [for_minarg]' as an
 12351                                  ; immediate move of the offset of 'for_minarg' into AX. In other words, in
 12352                                  ; terms of PDP-11 mnemonics, the assembler ACTUALLY assembles
 12353                                  ;	mov  AX, #for_minarg 	; AX := 02CA (for example)
 12354                                  ; instead of
 12355                                  ;	mov  AX, for_minarg	; AX := [02CA] (contents of 02CA)
 12356                                  ; By using 'f', we pretend that we are actually referencing an allocated
 12357                                  ; structure, and the assembler coughs up the code we want. Notice that it
 12358                                  ; doesn't matter whether we put brackets around the location or not -- the
 12359                                  ; assembler is "smart" enough to know that we want an address instead of the
 12360                                  ; contents of that location.
 12361                                  ;
 12362                                  ;   Finally, there now exists the potential to easily implement nested loops.
 12363                                  ; One method would be to have a link field in each for-structure pointing to
 12364                                  ; its parent.  Variable references that couldn't be resolved in the local
 12365                                  ; frame would cause a search of prior frames. For-structures would still be
 12366                                  ; allocated and released in exactly the same fashion. The only limit on the
 12367                                  ; number of nested loops would be memory size (although at 700 bytes a pop,
 12368                                  ; memory wouldn't last THAT long). Alternately, a small structure could be
 12369                                  ; maintained in the resident data area. This structure would be an array of
 12370                                  ; control-variable names and pointers to for-structure blocks. This would
 12371                                  ; greatly speed up the resolution of non-local variable references. However,
 12372                                  ; since space in the resident is precious, we would have to compromise on a
 12373                                  ; "reasonable" level of nesting -- 10, 16, 32 levels, whatever. For-structure
 12374                                  ; allocation and de-allocation would have to be modified slightly to take this
 12375                                  ; new structure into account.
 12376                                  ;
 12377                                  ;   Oops, just one more thing. Forbuf need not be a part of the for-structure.
 12378                                  ; It could just as well be one structure allocated in 'transpace'. Actually,
 12379                                  ; it may be easier to allocate it as part of 'for_segment'.
 12380                                  ;------
 12381                                  		; include fordata.asm
 12382                                  
 12383                                  ; Data structure definitions included by tfor.asm
 12384                                  
 12385                                  struc FOR_INFO
 12386 00000000 <res 544h>                .FOR_ARGS:	  resb  ARG_UNIT.SIZE	; argv[] structure 
 12387 00000544 ??                        .FOR_COM_START: resb  1		; beginning of <command>
 12388 00000545 ????                      .FOR_EXPAND:	  resw  1		; * or ? item in <list>?
 12389 00000547 ????                      .FOR_MINARG:	  resw  1		; beginning of <list>
 12390 00000549 ????                      .FOR_MAXARG:	  resw  1		; end of <list>
 12391 0000054B <res 80h>                 .FORBUF:	  resw  64		; temporary buffer
 12392 000005CB <res 80h>                 .FORDMA:	  resw  64		; FindFirst/Next buffer
 12393 0000064B ??                        .FOR_VAR:	  resb  1		; loop control variable
 12394                                    .size:
 12395                                  endstruc
 12396                                  					; ARG_UNIT.SIZE = 1348 (544h)
 12397                                  _$FOR_EXIT:
 12398 00000DDF EBC6                    	jmp	short FORTERM		; exceeding maxarg means all done
 12399                                  
 12400                                  ; ---------------------------------------------------------------------------
 12401                                  
 12402                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM 
 12403                                  FORPROC:
 12404 00000DE1 A1[AD01]                	mov	ax,[ForPtr]
 12405 00000DE4 8ED8                    	mov	ds,ax
 12406 00000DE6 8EC0                    	mov	es,ax			; operate in for-info area
 12407                                  	;mov	dx,5CBh	; MSDOS 5.0
 12408 00000DE8 BACB05                  	mov	dx,FOR_INFO.FORDMA ; 5CBh
 12409                                  					; 1348+1+2+2+2+128 = 1483 = 5CBh
 12410 00000DEB B8001A                  	mov	ax,1A00h
 12411                                  	;mov	ax,Set_DMA*256 ; 1A00h
 12412 00000DEE CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 12413                                  			; DS:DX	-> disk	transfer buffer
 12414                                  FOR_BEGIN:
 12415                                  	;cmp	word [545h],0
 12416 00000DF0 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0 ; [545h]
 12417 00000DF5 7404                    	jz	short FOR_BEGIN1
 12418                                  					; non-zero for_expand equals FALSE
 12419                                  	;inc	word [547h]
 12420 00000DF7 FF064705                	inc	word [FOR_INFO.FOR_MINARG] ; [547h]
 12421                                  FOR_BEGIN1:
 12422 00000DFB 8B1E4705                	mov	bx,[FOR_INFO.FOR_MINARG] ; [547h]
 12423                                  					; current item in <list> to examine
 12424 00000DFF 3B1E4905                	cmp	bx,[FOR_INFO.FOR_MAXARG] ; [549h]
 12425 00000E03 7FDA                    	jg	short _$FOR_EXIT	; exceeding maxarg means all done	
 12426                                  	;mov	ax,0
 12427 00000E05 B80000                  	mov	ax,FOR_INFO.FOR_ARGS ; 0 
 12428 00000E08 E84B23                  	call	argv_calc		; compute argv[x] address
 12429                                  	;mov	cx,[bx+3]
 12430 00000E0B 8B4F03                  	mov	cx,[bx+ARGV_ELE.argstartel]
 12431 00000E0E 8B17                    	mov	dx,[bx]
 12432                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 12433                                  	;test	byte [bx+2],4		; Is there a path separator in this arg?
 12434 00000E10 F6470204                	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 12435 00000E14 7514                    	jnz	short FORSUB		; Yes, argstartel should be correct
 12436 00000E16 8B37                    	mov	si,[bx]
 12437                                  	;mov	si,[bx+ARGV_ELE.argpointer]
 12438                                  
 12439                                  	;mov	al,[cs:LPAREN]
 12440                                  	; 15/02/2023
 12441                                  	; MSDOS 6.0 (& 5.0) COMMAND.com
 12442 00000E18 B028                    	mov	al,'('	; mov al,lparen
 12443 00000E1A 3844FF                  	cmp	[si-1],	al		; If the current token is the first
 12444 00000E1D 750B                    	jne	short FORSUB		;  one in the list and originally had
 12445 00000E1F 41                      	inc	cx			;  the opening paren as its first char,
 12446                                  					;  the argstartel ptr needs to be
 12447                                  					;  advanced passed it before the prefix
 12448                                  					;  length is computed.
 12449 00000E20 B03A                    	mov	al,':'
 12450 00000E22 384401                  	cmp	[si+1],	al		; If the token begins with "(d:",
 12451 00000E25 7503                    	jne	short FORSUB		;  argstartel has to be moved over the
 12452 00000E27 83C102                  	add	cx,2			;  rest of the prefix as well.
 12453                                  FORSUB:
 12454 00000E2A 29D1                    	sub	cx,dx			; compute length of pathname prefix
 12455                                  	;cmp	word [545h],0
 12456 00000E2C 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12457                                  					; are we still expanding a name?
 12458 00000E31 7416                    	jz	short FOR_FIND_NEXT
 12459                                  					; if so, get next matching filename
 12460                                  	;test	byte [bx+2],2
 12461 00000E33 F6470202                	test	byte [bx+ARGV_ELE.argflags],2 ; wildcard
 12462 00000E37 7505                    	jnz	short FOR_FIND_FIRST
 12463                                  					; should we expand THIS (new) arg?
 12464                                  	;mov	cx,[bx+5]	
 12465                                  					; else, just copy all of it directly	
 12466 00000E39 8B4F05                  	mov	cx,[bx+ARGV_ELE.arglen]
 12467 00000E3C EB1D                    	jmp	short FOR_SMOOSH
 12468                                  
 12469                                  	;nop
 12470                                  	; 15/02/2023
 12471                                  FOR_FIND_FIRST:
 12472 00000E3E 51                      	push	cx
 12473 00000E3F 31C9                    	xor	cx,cx
 12474 00000E41 B8004E                  	mov	ax,4E00h
 12475                                  	;mov	ax,Find_First*256 ; 4E00h
 12476 00000E44 CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 12477                                  			; CX = search attributes
 12478                                  			; DS:DX	-> ASCIZ filespec
 12479                                  			; (drive,path, and wildcards allowed)
 12480 00000E46 59                      	pop	cx
 12481 00000E47 EB05                    	jmp	short FOR_RESULT
 12482                                  
 12483                                  	;nop
 12484                                  FOR_FIND_NEXT:
 12485 00000E49 B8004F                  	mov	ax,4F00h
 12486                                  	;mov	ax,Find_Next*256 ;4F00h
 12487 00000E4C CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 12488                                  			; [DTA]	= data block from
 12489                                  			; last AH = 4Eh/4Fh call
 12490                                  FOR_RESULT:
 12491 00000E4E B8FFFF                  	mov	ax,-1 ; 0FFFFh		; assume worst case
 12492 00000E51 7201                    	jc	short FOR_CHECK
 12493                                  	; 15/02/2023
 12494 00000E53 40                      	inc	ax ; ax = 0
 12495                                  	;mov	ax,0			; Find* returns 0 for SUCCESS
 12496                                  FOR_CHECK:				; record success of findfirst/next
 12497 00000E54 A34505                  	mov	[FOR_INFO.FOR_EXPAND],ax
 12498 00000E57 09C0                    	or	ax,ax			; anything out there?
 12499 00000E59 7595                    	jnz	short FOR_BEGIN		; if not, try next arg
 12500                                  FOR_SMOOSH:
 12501                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12502 00000E5B 8B37                    	mov	si,[bx] 		; copy argv[arg][0,CX] into destbuf
 12503                                  	;mov	di,54Bh	; MSDOS 5.0
 12504 00000E5D BF4B05                  	mov	di,FOR_INFO.FORBUF	; some days this will be the entire
 12505 00000E60 F3A4                    	rep	movsb			; arg, some days just the path prefix
 12506                                  					
 12507 00000E62 833E450500              	cmp	word [FOR_INFO.FOR_EXPAND],0
 12508                                  					; if we're not expanding, we can
 12509 00000E67 7509                    	jnz	short FOR_MAKE_COM 	; skip the following	
 12510                                  	; 15/02/2023
 12511                                  	;mov	si,05E9h ; MSDOS 3.3 & 5.0 & 6.0 COMMAND.COM
 12512 00000E69 BEE905                  	mov	si,FOR_INFO.FORDMA+FIND_BUF.PNAME ; 14/10/2018
 12513                                  FOR_MORE:
 12514                                  	;cmp	byte [si],0		; tack on matching filename
 12515                                  	;jz	short FOR_MAKE_COM
 12516                                  	;movsb
 12517                                  	;jnz	short FOR_MORE
 12518                                  	; 25/04/2023
 12519 00000E6C AC                      	lodsb
 12520 00000E6D AA                      	stosb
 12521 00000E6E 08C0                    	or	al,al
 12522 00000E70 75FA                    	jnz	short FOR_MORE
 12523                                  FOR_MAKE_COM:
 12524                                  	; 25/04/2023
 12525                                  	;xor	al,al			; tack a null byte onto the end
 12526                                  	;stosb				; of the substitute string
 12527 00000E72 31C9                    	xor	cx,cx			; character count for command line
 12528 00000E74 F7D1                    	not	cx			; negate it -- take advantage of loopnz
 12529 00000E76 31DB                    	xor	bx,bx			; argpointer
 12530 00000E78 BF[FD88]                	mov	di,COMBUF+2
 12531                                  	; 15/02/2023
 12532                                  	;mov	bl,[544h]  ; MSDOS 5.0
 12533 00000E7B 8A1E4405                	mov	bl,[FOR_INFO.FOR_COM_START] ; argindex
 12534                                  	;mov	dh,[64Bh]
 12535 00000E7F 8A364B06                	mov	dh,[FOR_INFO.FOR_VAR] 
 12536                                  					; %<for-var> is replaced by [forbuf]
 12537 00000E83 0E                      	push	cs			; time to form the <command> string
 12538 00000E84 07                      	pop	es
 12539                                  	;assume ES:trangroup
 12540                                  	;mov	ax,FOR_INFO.FOR_ARGS
 12541 00000E85 B80000                  	mov	ax,0			; translate offset to pointer
 12542 00000E88 E8CB22                  	call	argv_calc
 12543                                  	;mov	si,[bx+9]
 12544 00000E8B 8B7709                  	mov	si,[bx+ARGV_ELE.arg_ocomptr] 
 12545                                  					; mov ptr passed beginning space
 12546 00000E8E 46                      	inc	si
 12547                                  FOR_MAKE_LOOP:
 12548 00000E8F 8A04                    	mov	al,[si]			; the <command> arg, byte by byte
 12549 00000E91 46                      	inc	si
 12550 00000E92 3C25                    	cmp	al,'%'			; looking for %<control-variable>
 12551 00000E94 7514                    	jne	short FOR_STOSB 	; no % ... add byte to string
 12552 00000E96 3834                    	cmp	[si],dh			; got the right <variable>?
 12553 00000E98 7510                    	jnz	short FOR_STOSB		; got a %, but wrong <variable>
 12554 00000E9A 46                      	inc	si			; skip over <for-variable>
 12555                                  
 12556 00000E9B 56                      	push	si
 12557                                  	; 15/02/2023
 12558                                  	;mov	si,54Bh	; MSDOS 5.0
 12559 00000E9C BE4B05                  	mov	si,FOR_INFO.FORBUF
 12560                                  					; substitute the <item> for <variable>
 12561                                  					; to make a final <command> to execute
 12562                                  SLOOP:					
 12563 00000E9F AC                      	lodsb				; grab all those <item> bytes, and
 12564 00000EA0 AA                      	stosb				; add 'em to the <command> string,
 12565 00000EA1 08C0                    	or	al,al			; until we run into a null
 12566 00000EA3 E0FA                    	loopne	SLOOP
 12567 00000EA5 4F                      	dec	di			; adjust length and <command> pointer
 12568 00000EA6 41                      	inc	cx			; so we can overwrite the null
 12569 00000EA7 5E                      	pop	si
 12570 00000EA8 EBE5                    	jmp	short FOR_MAKE_LOOP
 12571                                  					; got back for more <command> bytes
 12572                                  FOR_STOSB:
 12573 00000EAA AA                      	stosb				; take a byte from the <command> arg
 12574 00000EAB 49                      	dec	cx			; and put it into the <command> to be
 12575                                  					; executed (and note length, too)
 12576 00000EAC 3C0D                    	cmp	al,0Dh		
 12577 00000EAE 75DF                    	jne	short FOR_MAKE_LOOP	; If not done, loop.
 12578                                  FOR_MADE_COM:
 12579 00000EB0 F6D1                    	not	cl
 12580                                  	;mov	[cs:COMBUF+1],cl
 12581                                  	;mov	ds,[cs:RESSEG]
 12582                                  	; 15/02/2023 - Retro DOS v4.0 COMMAND.COM
 12583                                  	; MSDOS 5.0 COMMAND.COM
 12584 00000EB2 26880E[FC88]            	mov	[es:COMBUF+1],cl
 12585 00000EB7 268E1E[9C8A]            	mov	ds,[es:RESSEG]				
 12586                                  	;assume DS:resgroup
 12587 00000EBC F606[A001]01            	test	byte [EchoFlag],1 	; shall we echo this <command>, dearie?
 12588 00000EC1 742F                    	jz	short NOECHO3
 12589                                  	;cmp	byte [NullFlag],nullcommand
 12590 00000EC3 803E[B501]01            	cmp	byte [NullFlag],1 	;G was there a command last time?
 12591 00000EC8 7403                    	jz	short NO_CRLF_PR  	;G no - don't print crlf	 	
 12592                                  
 12593 00000ECA E8FD16                  	call	CRLF2		  	;G Print out prompt
 12594                                  NO_CRLF_PR:
 12595 00000ECD C606[B501]00            	mov	byte [NullFlag],0 	;G reset no command flag
 12596 00000ED2 0E                      	push	cs
 12597 00000ED3 1F                      	pop	ds
 12598 00000ED4 57                      	push	di
 12599 00000ED5 E8B40E                  	call	PRINT_PROMPT	  	;G Prompt the user
 12600 00000ED8 5F                      	pop	di
 12601                                  
 12602 00000ED9 26C645FF00              	mov	byte [es:di-1],0  	; yeah, PRINT it out...	
 12603 00000EDE C706[8C8C][FD88]        	mov	word [string_ptr_2],COMBUF+2
 12604                                  	; 17/04/2023
 12605 00000EE4 BA[F880]                	mov	dx,string_buf_ptr
 12606 00000EE7 E8193F                  	call	std_printf
 12607 00000EEA 26C645FF0D              	mov	byte [es:di-1],0Dh
 12608 00000EEF E9E2F3                  	jmp	DOCOM		  	; run silent, run deep...
 12609                                  NOECHO3:
 12610 00000EF2 C606[B501]00            	mov	byte [NullFlag],0
 12611 00000EF7 0E                      	push	cs
 12612 00000EF8 1F                      	pop	ds
 12613 00000EF9 E9DBF3                  	jmp	DOCOM1
 12614                                  
 12615                                  FORNESTERRJ:				; no multi-loop processing... yet!		
 12616 00000EFC E84601                  	call	FOROFF
 12617 00000EFF E92901                  	jmp	FORNESTERR
 12618                                  
 12619                                  ; ---------------------------------------------------------------------------
 12620                                  
 12621                                  FORERRORJ:
 12622 00000F02 E9DAFB                  	jmp	FORERROR
 12623                                  
 12624                                  ; ---------------------------------------------------------------------------
 12625                                  
 12626                                  _$FOR:
 12627 00000F05 8E06[9C8A]              	mov	es,[RESSEG]
 12628 00000F09 26803E[AC01]00          	cmp	byte [es:ForFlag],0 ; is another one already running?
 12629 00000F0F 75EB                    	jnz	short FORNESTERRJ   ; if flag is set.... boom!
 12630                                  
 12631                                  ; Turn off any pipes in progress.
 12632                                  
 12633 00000F11 26803E[1902]00          	cmp	byte [es:PipeFiles],0 ; Only turn off if present.
 12634 00000F17 7403                    	jz	short NO_PIPE
 12635 00000F19 E8CC1D                  	call	PIPEDEL
 12636                                  NO_PIPE:
 12637 00000F1C 31D2                    	xor	dx,dx			; counter (0 <= DX < argvcnt)
 12638 00000F1E E8F400                  	call	NEXTARG			; move to next argv[n]
 12639 00000F21 72DF                    	jc	short FORERRORJ		; no more args -- bad forloop
 12640 00000F23 3C25                    	cmp	al,'%'			; next arg MUST start with '%'...
 12641 00000F25 75DB                    	jne	short FORERRORJ
 12642 00000F27 89C5                    	mov	bp,ax			; save forloop variable
 12643 00000F29 AC                      	lodsb
 12644 00000F2A 08C0                    	or	al,al			; and MUST end immediately...
 12645 00000F2C 75D4                    	jnz	short FORERRORJ
 12646 00000F2E E8E400                  	call	NEXTARG			; let's make sure the next arg is 'in'
 12647 00000F31 72CF                    	jb	short FORERRORJ
 12648                                  	;and	ax,0DFDFh
 12649 00000F33 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12650                                  	; 15/02/2023
 12651                                  	;cmp	ax,4E49h  	; MSDOS 5.0	
 12652                                  	;cmp	ax,[IN_WORD] 	; MSDOS 3.3
 12653                                  	;cmp	ax,in_word	; MSDOS 5.0
 12654 00000F36 3D494E                  	cmp	ax,'IN'
 12655 00000F39 75C7                    	jnz	short FORERRORJ
 12656 00000F3B AC                      	lodsb
 12657                                  
 12658                                  	; 15/02/2023
 12659                                  	; MSDOS 3.3
 12660                                  	;or	al,al			; it, too, must end right away
 12661                                  	;jz	short CHECKLPAREN
 12662                                  	;cmp	al,[LPAREN]
 12663                                  	;jnz	short FORERRORJ
 12664                                  	;;add	word [bx+ARGV_ELE.argpointer],2 ; add word [bx+0],2
 12665                                  	;add	word [bx],2
 12666                                  	;;add	word [bx+9],2
 12667                                  	;add	word [bx+ARGV_ELE.arg_ocomptr],2
 12668                                  	;;sub	word [bx+5],2
 12669                                  	;sub	word [bx+ARGV_ELE.arglen],2
 12670                                  	;mov	ax,[si-1]
 12671                                  	;jmp	short LPCHECK
 12672                                  
 12673                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12674                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Bh
 12675                                  
 12676                                  	; MSDOS 6.0
 12677                                  ; Compaq bug fix -- exit from this loop on error
 12678                                  
 12679 00000F3C 08C0                    	or	al,al
 12680 00000F3E 75C2                    	jne	short FORERRORJ		; jump on error
 12681                                  
 12682                                  ;	je	short CHECKLPAREN
 12683                                  ;
 12684                                  ; Not null. Perhaps there are no spaces between this and the (:
 12685                                  ;   FOR %i in(foo bar...
 12686                                  ; Check for the Lparen here
 12687                                  ;
 12688                                  ;;	cmp	al,lparen
 12689                                  ;;	jnz	short FORERRORJ	
 12690                                  ;
 12691                                  ; The token was in(... We strip off the "in" part to simulate a separator
 12692                                  ; being there in the first place.
 12693                                  ;
 12694                                  ;;	add	word [bx+ARGV_ELE.argpointer],2 ; advance source pointer
 12695                                  ;;	add	word [bx+ARGV_ELE.arg_ocomptr],2
 12696                                  ;;						; advance original string
 12697                                  ;;	sub	word [bx+ARGV_ELE.arglen],2 	; decrement the appropriate length
 12698                                  ;
 12699                                  ; SI now points past the in(.  Simulate a nextarg call that results in the
 12700                                  ; current value.
 12701                                  ;
 12702                                  ;;	mov	ax,[si-1]		; get lparen and next char
 12703                                  ;;	jmp	short LPCHECK
 12704                                  ;
 12705                                  ; end of Compaq bug fix
 12706                                  
 12707                                  ; ---------------------------------------------------------------------------
 12708                                  
 12709                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12710                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:0F5Fh
 12711                                  
 12712                                  	; MSDOS 3.3 (& MSDOS 6.0)
 12713                                  CHECKLPAREN:
 12714 00000F40 E8D200                  	call	NEXTARG			; lparen delimits beginning of <list>
 12715 00000F43 72BD                    	jc	short FORERRORJ
 12716                                  LPCHECK:
 12717                                  	; 15/02/2023
 12718                                  	; MSDOS 5.0 (% MSDOS 6.0)	
 12719                                  	;;cmp	al,[LPAREN]
 12720                                  	;cmp	al,lparen
 12721 00000F45 3C28                    	cmp	al,'('
 12722 00000F47 75B9                    	jne	short FORERRORJ
 12723 00000F49 80FC00                  	cmp	ah,0
 12724 00000F4C 7410                    	je	short FOR_PAREN_TOKEN
 12725                                  	;;cmp	ah,[RPAREN]		; special case:  null list	
 12726                                  	;cmp	ah,rparen
 12727 00000F4E 80FC29                  	cmp	ah,')'
 12728 00000F51 7503                    	jne	short FOR_LIST_NOT_EMPTY
 12729 00000F53 E951FE                  	jmp	FORTERM
 12730                                  FOR_LIST_NOT_EMPTY:
 12731                                  	;inc	word [bx+ARGV_ELE.argpointer] ; inc word [bx+0]
 12732 00000F56 FF07                    	inc	word [bx]		; Advance ptr past "("
 12733                                  	;dec	word [bx+5]		; Adjust the rest of this argv entry	
 12734 00000F58 FF4F05                  	dec	word [bx+ARGV_ELE.arglen] ; to agree.
 12735 00000F5B 46                      	inc	si			; Inc si so check for ")" works
 12736 00000F5C EB0D                    	jmp	short FOR_LIST
 12737                                  
 12738                                  	;nop
 12739                                  FOR_PAREN_TOKEN:
 12740 00000F5E E8B400                  	call	NEXTARG			; what have we in our <list>?
 12741 00000F61 729F                    	jc	short FORERRORJ
 12742                                  	; 15/02/2023
 12743                                  	;;;cmp	ax,[RPAREN+1]	
 12744                                  	;;cmp	ax,[NULLRPAREN]		; special case:  null list
 12745                                  	;cmp	ax,nullrparen
 12746 00000F63 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12747 00000F66 7503                    	jne	short FOR_LIST
 12748 00000F68 E93CFE                  	jmp	FORTERM
 12749                                  
 12750                                  ;FORERORJJ:
 12751                                  	;jmp	FORERROR
 12752                                  
 12753                                  FOR_LIST:				; skip over rest of <list>
 12754 00000F6B 89D1                    	mov	cx,dx			; first arg of <list>
 12755                                  
 12756                                  SKIP_LIST:
 12757                                  	;add	si,[bx+5]
 12758 00000F6D 037705                  	add	si,[bx+ARGV_ELE.arglen]
 12759 00000F70 83EE03                  	sub	si,3			; si = ptr to last char of token
 12760                                  	; 15/02/2023
 12761                                  	;;mov	al,[RPAREN]
 12762                                  	;mov	al,rparen
 12763 00000F73 B029                    	mov	al,')'
 12764 00000F75 3804                    	cmp	[si],al			; Is this the last element in <list>
 12765 00000F77 7408                    	je	short FOR_END_LIST 	; Yes, exit loop.
 12766 00000F79 E89900                  	call	NEXTARG			; No, get next arg <list>
 12767                                  	;jc	short FORERORJJ		; If no more and no rparen, error.
 12768                                  	;jmp	short SKIP_LIST
 12769                                  	; 15/02/2023
 12770 00000F7C 73EF                    	jnc	short SKIP_LIST
 12771                                  
 12772                                  	; 15/02/2023
 12773                                  FORERORJJ:
 12774 00000F7E E95EFB                  	jmp	FORERROR
 12775                                  
 12776                                  FOR_END_LIST:
 12777 00000F81 89D7                    	mov	di,dx			; record position of last arg in <list>
 12778 00000F83 C60400                  	mov	byte [si],0		; Zap the rparen
 12779                                  	; 15/02/2023
 12780                                  	;;;cmp	ax,[RPAREN+1]	
 12781                                  	;;cmp	ax,[NULLRPAREN] 	; Was this token only a rparen
 12782                                  	;cmp	ax,nullparen
 12783 00000F86 83F829                  	cmp	ax,29h	; db 29h,0 ; db ')',0
 12784 00000F89 7401                    	je	short FOR_DO		; Yes, continue
 12785 00000F8B 47                      	inc	di			; No, inc position of last arg
 12786                                  FOR_DO:
 12787 00000F8C E88600                  	call	NEXTARG			; now we had BETTER find a 'do'...
 12788 00000F8F 72ED                    	jc	short FORERORJJ
 12789                                  	;and	ax,0DFDFh	
 12790 00000F91 25DFDF                  	and	ax,~2020h		; uppercase the letters
 12791                                  	; 15/02/2023
 12792                                  	;;cmp	ax,[DO_WORD]
 12793                                  	;cmp	ax,do_word ; 4F44h
 12794 00000F94 3D444F                  	cmp	ax,'DO'	 ; 4F44h	
 12795 00000F97 75E5                    	jne	short FORERORJJ
 12796 00000F99 AC                      	lodsb
 12797 00000F9A 08C0                    	or	al,al			; and it had BETTER be ONLY a 'do'...
 12798 00000F9C 75E0                    	jnz	short FORERORJJ
 12799                                  		
 12800 00000F9E E87400                  	call	NEXTARG			; on to the beginning of <command>
 12801 00000FA1 72DB                    	jc	short FORERORJJ		; null <command> not legal
 12802                                  
 12803 00000FA3 50                      	push	ax
 12804 00000FA4 53                      	push	bx
 12805 00000FA5 51                      	push	cx
 12806 00000FA6 52                      	push	dx			; preserve registers against disaster
 12807 00000FA7 57                      	push	di
 12808 00000FA8 56                      	push	si
 12809 00000FA9 55                      	push	bp
 12810 00000FAA E857F7                  	call	FREE_TPA		; need to make free memory, first
 12811 00000FAD E89500                  	call	FOROFF
 12812                                  	;mov	bx,264
 12813 00000FB0 BB0801                  	mov	bx,FOR_INFO.size-ARG_UNIT.SIZE
 12814 00000FB3 E8CD24                  	call	SAVE_ARGS		; extra bytes needed for for-info
 12815 00000FB6 9C                      	pushf
 12816 00000FB7 26A3[AD01]              	mov	[es:ForPtr],ax
 12817 00000FBB E856F7                  	call	ALLOC_TPA		; ALLOC_TPA clobbers registers...
 12818 00000FBE 9D                      	popf
 12819 00000FBF 5D                      	pop	bp
 12820 00000FC0 5E                      	pop	si
 12821 00000FC1 5F                      	pop	di
 12822 00000FC2 5A                      	pop	dx
 12823 00000FC3 59                      	pop	cx
 12824 00000FC4 5B                      	pop	bx
 12825 00000FC5 58                      	pop	ax
 12826 00000FC6 723C                    	jc	short FOR_ALLOC_ERR
 12827                                  
 12828 00000FC8 06                      	push	es			; save resgroup seg...
 12829 00000FC9 26FF36[AD01]            	push	word [es:ForPtr]
 12830 00000FCE 07                      	pop	es
 12831                                  	;assume es:for_segment	
 12832 00000FCF 49                      	dec	cx			; forproc wants min pointing before
 12833 00000FD0 4F                      	dec	di			; first arg, max right at last one
 12834                                  	; 15/02/2023
 12835                                  	;mov	[547h],cx
 12836 00000FD1 26890E4705              	mov	[es:FOR_INFO.FOR_MINARG],cx
 12837                                  	;mov	[549h],di
 12838 00000FD6 26893E4905              	mov	[es:FOR_INFO.FOR_MAXARG],di
 12839                                  	;mov	[544h],dl
 12840 00000FDB 2688164405              	mov	[es:FOR_INFO.FOR_COM_START],dl
 12841                                  	;mov	word [545h],0FFFFh ; -1
 12842 00000FE0 26C7064505FFFF          	mov	word [es:FOR_INFO.FOR_EXPAND],-1
 12843                                  					; non-zero means FALSE
 12844 00000FE7 89E8                    	mov	ax,bp
 12845                                  	;mov	[64Bh],ah
 12846 00000FE9 2688264B06              	mov	[es:FOR_INFO.FOR_VAR],ah
 12847 00000FEE 07                      	pop	es
 12848                                  	;assume es:resgroup	
 12849 00000FEF 26FE06[AC01]            	inc	byte [es:ForFlag]
 12850 00000FF4 26833E[A601]FF          	cmp	word [es:SingleCom],-1
 12851 00000FFA 7507                    	jne	short FOR_RET
 12852 00000FFC 26C706[A601]00FF        	mov	word [es:SingleCom],0FF00h
 12853                                  FOR_RET:
 12854 00001003 C3                      	retn
 12855                                  
 12856                                  FOR_ALLOC_ERR:
 12857                                  	; 15/02/2023
 12858                                  	; MSDOS 3.3
 12859                                  	;mov	dx,INSFMEMMESPTR
 12860                                  	;jmp	CERROR
 12861                                  
 12862                                  	; 15/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12863                                  	; MSDOS 6.0
 12864                                  	;mov	byte [msg_disp_class],1
 12865 00001004 C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class	
 12866                                  					;AN000; set up extended error msg class
 12867                                  	;mov	dx,offset TranGroup:Extend_Buf_ptr     
 12868 00001009 BA[317F]                	mov	dx,extend_buf_ptr
 12869                                  					;AC000; get extended message pointer
 12870                                  	;mov	word [extend_buf_ptr],8
 12871 0000100C C706[317F]0800          	mov	word [extend_buf_ptr],ERROR_NOT_ENOUGH_MEMORY
 12872                                  					;AN000; get message number in control block
 12873 00001012 E93619                  	jmp	cerror
 12874                                  
 12875                                  
 12876                                  ; =============== S U B	R O U T	I N E =======================================
 12877                                  
 12878                                  NEXTARG:
 12879 00001015 42                      	inc	dx			; next argv[n]
 12880                                  	;cmp	dx,[ARG_ARGVCNT]
 12881 00001016 3B16[EB90]              	cmp	dx,[ARG+ARG_UNIT.argvcnt]
 12882                                  					; make sure we don't run off end
 12883 0000101A 7D0D                    	jge	short NEXTARG_ERR 	;  of argv[]...	
 12884 0000101C 89D3                    	mov	bx,dx
 12885                                  	;mov	ax,ARG_ARGV
 12886                                  	;mov	ax,ARG+ARG_UNIT.argv
 12887 0000101E B8[2B8E]                	mov	ax,ARG
 12888 00001021 E83221                  	call	argv_calc		; convert array index to pointer
 12889 00001024 8B37                    	mov	si,[bx]			; load pointer to argstring
 12890                                  	;mov	si,[bx+ARGV_ELE.argpointer] ; mov si,[bx+0]
 12891 00001026 AD                      	lodsw				; and load first two chars
 12892 00001027 F8                      	clc
 12893 00001028 C3                      	retn
 12894                                  NEXTARG_ERR:
 12895 00001029 F9                      	stc
 12896 0000102A C3                      	retn
 12897                                  
 12898                                  ; ---------------------------------------------------------------------------
 12899                                  
 12900                                  FORNESTERR:
 12901 0000102B 1E                      	push	ds
 12902 0000102C 8E1E[9C8A]              	mov	ds,[RESSEG]
 12903                                  	;ASSUME DS:RESGROUP
 12904 00001030 BA[8F80]                	mov	dx,FORNESTMES_PTR
 12905 00001033 813E[A601]00FF          	cmp	word [SingleCom],0FF00h
 12906 00001039 7506                    	jne	short NOFORP3
 12907 0000103B C706[A601]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Cause termination
 12908                                  NOFORP3:
 12909 00001041 1F                      	pop	ds
 12910 00001042 E90619                  	jmp	cerror
 12911                                  
 12912                                  ; =============== S U B	R O U T	I N E =======================================
 12913                                  
 12914                                  ; General routine called to free the for segment. We also clear the forflag
 12915                                  ; too. Change no registers.
 12916                                  
 12917                                  FOROFF:
 12918 00001045 50                      	push	ax
 12919 00001046 06                      	push	es
 12920 00001047 2E8E06[9C8A]            	mov	es,[cs:RESSEG]
 12921 0000104C 26A1[AD01]              	mov	ax,[es:ForPtr]
 12922 00001050 09C0                    	or	ax,ax
 12923 00001052 7408                    	jz	short FREEDONE
 12924 00001054 06                      	push	es
 12925 00001055 8EC0                    	mov	es,ax
 12926                                  	; 15/02/2023
 12927 00001057 B449                    	mov	ah,49h
 12928                                  	;mov	ah,DEALLOC ; 49h
 12929 00001059 CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 12930                                  			; ES = segment address of area to be freed
 12931 0000105B 07                      	pop	es
 12932                                  FREEDONE:
 12933 0000105C 26C706[AD01]0000        	mov	word [es:ForPtr],0
 12934 00001063 26C606[AC01]00          	mov	byte [es:ForFlag],0
 12935 00001069 07                      	pop	es
 12936 0000106A 58                      	pop	ax
 12937 0000106B C3                      	retn
 12938                                  
 12939                                  ;============================================================================
 12940                                  ; TCMD1A.ASM, MSDOS 6.0, 1991
 12941                                  ;============================================================================
 12942                                  ; 09/10/2018 - Retro DOS v3.0
 12943                                  
 12944                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 0ECBh
 12945                                  
 12946                                  ; ---------------------------------------------------------------------------
 12947                                  
 12948                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 12949                                  
 12950                                  %if 0
 12951                                  
 12952                                  ; The DIR command displays the contents of a directory.
 12953                                  ;
 12954                                  ; ****************************************************************
 12955                                  ; *
 12956                                  ; * ROUTINE:	 CATALOG - display file(s) in directory
 12957                                  ; *
 12958                                  ; * FUNCTION:	 PARSE command line for drive, file, or path name.
 12959                                  ; *		 DIR allows two switches, /P (pause) and /W (wide).
 12960                                  ; *		 If an error occurs issue and error message and
 12961                                  ; *		 transfer control to CERROR.
 12962                                  ; *
 12963                                  ; * INPUT:	 command line at offset 81H
 12964                                  ; *
 12965                                  ; * OUTPUT:	 none
 12966                                  ; *
 12967                                  ; ****************************************************************
 12968                                  
 12969                                  CATALOG:
 12970                                  	; MSDOS 3.3
 12971                                  
 12972                                  	;mov	ax,ARG_ARGV
 12973                                  	;mov	ax,ARG+ARG_UNIT.argv
 12974                                  	mov	ax,ARG
 12975                                  	mov	dx,0FFFFh
 12976                                  	xor	cx,cx
 12977                                  	xor	si,si
 12978                                  DIR1:
 12979                                  	;cmp	cx,[ARG_ARGVCNT]
 12980                                  	cmp	cx,[ARG+ARG_UNIT.argvcnt]
 12981                                  	jnb	short DIR6 ; No more arguments
 12982                                  	mov	bx,cx
 12983                                  	call	ARGV_CALC
 12984                                  	;or	si,[bx+7]
 12985                                  	or	si,[bx+ARGV_ELE.argsw_word]
 12986                                  	test	si,7FFCh  ; test si,~8003
 12987                                  	jnz	short DIR2  ; /A,/B,/V switches (are invalid)
 12988                                  	;test	byte [bx+2],1
 12989                                  	test	byte [bx+ARGV_ELE.argflags],sw_flag  ; 1
 12990                                  	jz	short DIR3
 12991                                  	jmp	short DIR5
 12992                                  DIR2:
 12993                                  	mov	dx,BADPARMPTR
 12994                                  	jmp	CERROR
 12995                                  DIR3:
 12996                                  	or	cx,cx
 12997                                  	jnz	short DIR4	
 12998                                  	;cmp	word [bx+5],3
 12999                                  	cmp	word [bx+ARGV_ELE.arglen],3
 13000                                  	jz	short DIR5
 13001                                  	;add	word [bx+ARGV_ELE.argpointer],3 ; add word [bx+0],3
 13002                                  	add	word [bx],3
 13003                                  	;add	word [bx+9],3
 13004                                  	add	word [bx+ARGV_ELE.arg_ocomptr],3
 13005                                  	;add	word [bx+3],3
 13006                                  	add	word [bx+ARGV_ELE.argstartel],3
 13007                                  	;sub	word [bx+5],3
 13008                                  	sub	word [bx+ARGV_ELE.arglen],3
 13009                                  DIR4:
 13010                                  	cmp	dx,0FFFFh
 13011                                  	jnz	short DIR2
 13012                                  	mov	dx,bx
 13013                                  DIR5:
 13014                                  	inc	cx
 13015                                  	jmp	short DIR1
 13016                                  DIR6:
 13017                                  	mov	[COMSW],si
 13018                                  	push	dx
 13019                                  	xor	al,al
 13020                                  	cmp	dx,0FFFFh
 13021                                  	jz	short DIR7
 13022                                  	mov	bx,dx
 13023                                  	;mov	di,[bx+ARGV_ELE.argpointer]  ;mov di,[bx+0]
 13024                                  	mov	di,[bx]
 13025                                  	cmp	byte [di+1],':'
 13026                                  	jnz	short DIR7
 13027                                  	mov	al,[di]
 13028                                  	or	al,20h		; Lowercase drive name	
 13029                                  	sub	al,'a'-1 ; 60h  ; Convert to drive number (0,1..)
 13030                                  DIR7:
 13031                                  	;mov	[5CH],al
 13032                                  	mov	[FCB],al
 13033                                  	call	OKVOLARG
 13034                                  	mov	al,'?'		; *.* is default file spec.
 13035                                  	;mov	di,5Dh
 13036                                  	mov	di,FCB+1
 13037                                  	mov	cx,11
 13038                                  	rep stosb
 13039                                  
 13040                                  ; Begin by processing any switches that may have been specified.
 13041                                  ; BITS will contain any information about switches that was
 13042                                  ; found when the command line was parsed.
 13043                                  
 13044                                  	mov	ax,[COMSW]	; Get switches from command
 13045                                  	mov	[_BITS],ax	; initialize switches
 13046                                  	mov	word [COMSW],0	; initialize flags
 13047                                  	mov	byte [LINPERPAG],23 ; Set default for lines per page
 13048                                  	;test	al,1
 13049                                  	test	al,SWITCHW	; /W ?
 13050                                  	;mov	al,1
 13051                                  	mov	al,NORMPERLIN
 13052                                  	jz	short DIR8
 13053                                  	;mov	al,5
 13054                                  	mov	al,WIDEPERLIN
 13055                                  DIR8:
 13056                                  	mov	[LINLEN],al	; Set number of entries per line
 13057                                  	mov	[LINCNT],al
 13058                                  	mov	word [FILECNT],0 ; Keep track of how many files found
 13059                                  	mov	dx,DIRBUF
 13060                                  	mov	ah,Set_DMA ; 1Ah
 13061                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 13062                                  			; DS:DX	-> disk	transfer buffer
 13063                                  	;mov	dl,[5Ch]
 13064                                  	mov	dl,[FCB]
 13065                                  	call	SAVUDIR
 13066                                  	pop	bx
 13067                                  	cmp	bx,0FFFFh
 13068                                  	jz	short DIR9
 13069                                  	;mov	dx,[bx+ARGV_ELE.argpointer] ; mov dx,[bx+0]
 13070                                  	mov	dx,[bx]
 13071                                  
 13072                                  ; The user may have specified a device. Search for the path and see if the
 13073                                  ; attributes indicate a device.
 13074                                  
 13075                                  	mov	ah,Find_First ; 4Eh
 13076                                  	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 13077                                  			; CX = search attributes
 13078                                  			; DS:DX	-> ASCIZ filespec
 13079                                  			; (drive,path, and wildcards allowed)
 13080                                  	jc	short DIR10
 13081                                  			; Check device atrribute..
 13082                                  	;test	byte [DIRBUF_ATTRIB2],40h
 13083                                  	;test	byte [DIRBUF_ATTRIB2],ATTR_DEVICE
 13084                                  	; 14/10/2018
 13085                                  	;test	byte [DIRBUF+21],40h
 13086                                  	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 13087                                  	jz	short DIR10	; no, go do normal operation
 13088                                  	mov	word [COMSW],-2 ; 0FFFEh  ; Signal device
 13089                                  DIR9:
 13090                                  	jmp	short DOHEADER
 13091                                  DIR10:
 13092                                  	;mov	dx,[bx+ARGV_ELE.argpointer]
 13093                                  	mov	dx,[bx]
 13094                                  	mov	ah,CHDir ; 3Bh
 13095                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13096                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13097                                  	jnc	short DOHEADER
 13098                                  	;mov	si,[bx+3]
 13099                                  	mov	si,[bx+ARGV_ELE.argstartel]
 13100                                  	cmp	dx,si
 13101                                  	jz	short DIR_NO_DRIVE
 13102                                  	xor	cl,cl
 13103                                  	xchg	cl,[si]
 13104                                  	mov	ah,CHDir ; 3Bh
 13105                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13106                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13107                                  	xchg	cl,[si]
 13108                                  	jnc	short DIR_NO_DRIVE
 13109                                  	mov	al,[si-1]
 13110                                  	call	PATHCHRCMP
 13111                                  	jnz	short DIR11
 13112                                  	mov	al,[si-2]
 13113                                  	call	PATHCHRCMP
 13114                                  	jz	short DIR12
 13115                                  	xchg	cl,[si-1]
 13116                                  	mov	ah,CHDir ; 3Bh
 13117                                  	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 13118                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 13119                                  	xchg	cl,[si-1]
 13120                                  	jnc	short DIR_NO_DRIVE
 13121                                  DIR11:
 13122                                  	mov	ch,':'
 13123                                  	cmp	ch,[si-1]
 13124                                  	jnz	short DIR12
 13125                                  	;mov	cx,[bx+ARGV_ELE.argpointer] ; mov cx,[bx+0]
 13126                                  	mov	cx,[bx]
 13127                                  	xchg	cx,si
 13128                                  	sub	cx,si
 13129                                  	cmp	cx,2
 13130                                  	jz	short DIR_NO_DRIVE
 13131                                  DIR12:
 13132                                  	mov	dx,BADCDPTR
 13133                                  	;test	byte [bx+2],4
 13134                                  	test	byte [bx+ARGV_ELE.argflags],4 ; path_sep
 13135                                  	jnz	short DIRERROR
 13136                                  DIRNF:
 13137                                  	mov	dx,FNOTFOUNDPTR
 13138                                  DIRERROR:
 13139                                  	jmp	CERROR
 13140                                  DIR_NO_DRIVE:
 13141                                  	cmp	word [si],'..'
 13142                                  	jnz	short DOREALPARSE
 13143                                  	cmp	byte [si+2],0
 13144                                  	jnz	short DOREALPARSE
 13145                                  	inc	word [COMSW]
 13146                                  	jmp	short DOHEADER
 13147                                  DOREALPARSE:
 13148                                  	mov	di,FCB ; 5Ch	
 13149                                  	;mov	ax,290Eh
 13150                                  	mov	ax,(Parse_File_Descriptor<<8)|0Eh
 13151                                  	int	21h	; DOS -	PARSE FILENAME
 13152                                  			; DS:SI	-> string to parse
 13153                                  			; ES:DI	-> buffer to fill with unopened	FCB
 13154                                  			; AL = bit mask	to control parsing
 13155                                  	cmp	byte [si],0
 13156                                  	jz	short DOHEADER
 13157                                  	dec	word [COMSW]
 13158                                  DOHEADER:
 13159                                  		
 13160                                  ; Display the header
 13161                                  
 13162                                  	push	bx
 13163                                  	call	BUILD_DIR_STRING
 13164                                  	mov	dx,DIRBUF
 13165                                  	mov	[VOL_DIR],dx
 13166                                  	mov	dx,DIRHEADPTR
 13167                                  	call	PRINTF_CRLF
 13168                                  	pop	bx
 13169                                  	cmp	bx,0FFFFh
 13170                                  	jz	short DOSEARCH
 13171                                  
 13172                                  ; If there were chars left after parse or device, then invalid file name
 13173                                  
 13174                                  	cmp	word [COMSW],0
 13175                                  	jz	short DOSEARCH	; nothing left; good parse
 13176                                  	jl	short DIRNFFIX	; not .. => error file not found
 13177                                  	call	RESTUDIR
 13178                                  	mov	dx,BADCDPTR
 13179                                  	jmp	CERROR		; was .. => error directory not found
 13180                                  DIRNFFIX:
 13181                                  	call	RESTUDIR
 13182                                  	jmp	short DIRNF
 13183                                  
 13184                                  ; We are assured that everything is correct. Let's go and search. Use
 13185                                  ; attributes that will include finding directories. Perform the first search
 13186                                  ; and reset our directory afterward.
 13187                                  
 13188                                  DOSEARCH:
 13189                                  	;mov	byte [55h],0FFh
 13190                                  	mov	byte [FCB-7],0FFh
 13191                                  	;mov	byte [5Bh],10h
 13192                                  	mov	byte [FCB-1],10h
 13193                                  
 13194                                  ; Caution! Since we are using an extended FCB, we will *also* be returning
 13195                                  ; the directory information as an extended FCB. We must bias all fetches into
 13196                                  ; DIRBUF by 8 (Extended FCB part + drive)
 13197                                  
 13198                                  	mov	ah,Dir_Search_First ; 11h
 13199                                  	mov	dx,FCB-7 ; 55h
 13200                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 13201                                  			; DS:DX	-> FCB
 13202                                  
 13203                                  ; Restore the user's directory. We preserve, though, the return from the
 13204                                  ; previous system call for later checking.
 13205                                  
 13206                                  FOUND_FIRST_FILE:
 13207                                  	push	ax		; save return state
 13208                                  	call	RESTUDIR	; restore user's dir	
 13209                                  	pop	ax		; get return state back
 13210                                  
 13211                                  ; Main scanning loop. Entry has AL = Search first/next error code. Test for
 13212                                  ; no more.
 13213                                  
 13214                                  DIRSTART:
 13215                                  	inc	al		; 0FFh = file not found
 13216                                  	jnz	short DISPLAY	; Either an error or we are finished
 13217                                  	jmp	CHKCNT
 13218                                  DISPLAY:
 13219                                  	inc	word [FILECNT]	; Keep track of how many we find
 13220                                  	mov	si,DIRBUF+8	; SI -> information returned by sys call
 13221                                  	;call	SHONAME
 13222                                  	call	DISPLAYNAME
 13223                                  	;test	byte [_BITS],1
 13224                                  	test	byte [_BITS],SWITCHW ; W switch set?
 13225                                  	jz	short DIRTEST	; If so, no size, date, or time
 13226                                  	jmp	NEXENT
 13227                                  DIRTEST:
 13228                                  	;test	byte [DIRBUF_ATTRIB1],10h
 13229                                  	; 14/10/2018
 13230                                  	;test	byte [DIRBUF_ATTRIB1],ATTR_DIRECTORY
 13231                                  	;test	byte [DIRBUF+19],10h
 13232                                  	test	byte [DIRBUF+8+DIR_ENTRY.DIR_ATTR],ATTR_DIRECTORY
 13233                                  	jz	short FILEENT
 13234                                  	mov	dx,DMESPTR
 13235                                  	call	STD_PRINTF
 13236                                  	jmp	short NOFSIZ
 13237                                  FILEENT:
 13238                                  	;mov	dx,[DIRBUF_FSIZ_L]
 13239                                  	;mov	dx,[DIRBUF+36]
 13240                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_L]
 13241                                  	mov	[FILESIZE_L],dx
 13242                                  	;mov	dx,[DIRBUF_FSIZ_H]
 13243                                  	;mov	dx,[DIRBUF+38]
 13244                                  	mov	dx,[DIRBUF+8+DIR_ENTRY.DIR_SIZE_H]
 13245                                  	mov	[FILESIZE_H],dx
 13246                                  	mov	dx,FSIZEMESPTR
 13247                                  	call	STD_PRINTF	; Print size of file
 13248                                  NOFSIZ:
 13249                                  	;mov	ax,[DIRBUF_FDATE]  ; Get date
 13250                                  	;mov	ax,[DIRBUF+32]
 13251                                  	mov	ax,[DIRBUF+8+DIR_ENTRY.DIR_DATE]
 13252                                  	or	ax,ax
 13253                                  	jz	short NEXENT	; Skip if no date
 13254                                  	mov	di,CHARBUF
 13255                                  	push	ax
 13256                                  	mov	ax,'  '
 13257                                  	stosw
 13258                                  	pop	ax
 13259                                  	mov	bx,ax
 13260                                  	and	ax,1Fh		; Get day
 13261                                  	mov	dl,al
 13262                                  	mov	ax,bx
 13263                                  	mov	cl,5
 13264                                  	shr	ax,cl		; Align month
 13265                                  	and	al,0Fh		; Get month
 13266                                  	mov	dh,al
 13267                                  	mov	cl,bh
 13268                                  	shr	cl,1		; Align year
 13269                                  	xor	ch,ch
 13270                                  	add	cx,80		; Relative 1980
 13271                                  	cmp	cl,100
 13272                                  	jb	short MILLENIUM
 13273                                  	sub	cl,100
 13274                                  MILLENIUM:
 13275                                  	call	DATE_CXDX
 13276                                  	;mov	cx,[DIRBUF_FTIME]
 13277                                  	;mov	cx,[DIRBUF+30]
 13278                                  	mov	cx,[DIRBUF+8+DIR_ENTRY.DIR_TIME]
 13279                                  	jcxz	PRBUF		; Time field present?
 13280                                  	mov	ax,2020h
 13281                                  	stosw
 13282                                  	shr	cx,1
 13283                                  	shr	cx,1
 13284                                  	shr	cx,1
 13285                                  	shr	cl,1
 13286                                  	shr	cl,1		; Hours in CH, minutes in CL
 13287                                  	mov	bl,[TIME_24]
 13288                                  	or	bl,80h		; Tell P_TIME called from DIR
 13289                                  	call	P_TIME		; Don't care about DX, never used with DIR
 13290                                  PRBUF:
 13291                                  	xor	ax,ax
 13292                                  	stosb
 13293                                  	mov	dx,CHARBUF
 13294                                  	mov	[STRING_PTR_2],dx
 13295                                  	mov	dx,STRINGBUF2PTR
 13296                                  	call	STD_PRINTF
 13297                                  NEXENT:
 13298                                  	dec	byte [LINCNT]
 13299                                  	jnz	short SAMLIN
 13300                                  NEXLIN:
 13301                                  	mov	al,[LINLEN]
 13302                                  	mov	[LINCNT],al
 13303                                  	call	CRLF2
 13304                                  	dec	byte [LINPERPAG]
 13305                                  	jnz	short SCROLL
 13306                                  	;test	byte [_BITS],2
 13307                                  	test	byte [_BITS],SWITCHP ; P switch present?
 13308                                  	jz	short SCROLL	; If not, just continue
 13309                                  	mov	byte [LINPERPAG],23
 13310                                  	call	PAUSE
 13311                                  	jmp	short SCROLL
 13312                                  SAMLIN:
 13313                                  	mov	dx,TABPTR	; Output a tab
 13314                                  	call	STD_PRINTF
 13315                                  SCROLL:
 13316                                  	mov	ah,Dir_Search_Next ; 12h
 13317                                  	;mov	dx,55h
 13318                                  	mov	dx,FCB-7	; DX -> Unopened FCB
 13319                                  	int	21h	; DOS -	SEARCH NEXT USING FCB
 13320                                  			; DS:DX	-> FCB
 13321                                  			; Return: AL = status
 13322                                  	jmp	DIRSTART
 13323                                  CHKCNT:
 13324                                  	test	word [FILECNT],0FFFFh ; -1
 13325                                  	jnz	short TRAILER
 13326                                  	jmp	DIRNF
 13327                                  TRAILER:
 13328                                  	mov	al,[LINLEN]
 13329                                  	cmp	al,[LINCNT]
 13330                                  	jz	short MMESSAGE
 13331                                  	call	CRLF2
 13332                                  MMESSAGE:
 13333                                  	mov	dx,DIRMESPTR
 13334                                  	mov	si,[FILECNT]
 13335                                  	mov	[DIR_NUM],si
 13336                                  	call	STD_PRINTF
 13337                                  DTFREE:
 13338                                  	mov	ah,GET_DRIVE_FREESPACE ; 36h
 13339                                  	;mov	dl,[5Ch]
 13340                                  	mov	dl,[FCB]
 13341                                  	int	21h	; DOS -	2+ - GET DISK SPACE
 13342                                  			; DL = drive code (0 = default,	1 = A,2 = B,etc.)
 13343                                  	cmp	ax,-1
 13344                                  	jnz	short DTFREE1
 13345                                  DTRET:
 13346                                  	retn
 13347                                  DTFREE1:
 13348                                  	mul	cx
 13349                                  	mul	bx
 13350                                  	mov	[BYTES_FREE],ax
 13351                                  	mov	[BYTES_FREE+2],dx
 13352                                  	mov	dx,BYTEMESPTR
 13353                                  	jmp	STD_PRINTF
 13354                                  
 13355                                  ; =============== S U B	R O U T	I N E =======================================
 13356                                  
 13357                                  SHONAME:
 13358                                  DISPLAYNAME:
 13359                                  	; MSDOS 3.3
 13360                                  	mov	di,CHARBUF
 13361                                  	mov	cx,8
 13362                                  	rep	movsb
 13363                                  	mov	al,' '
 13364                                  	stosb
 13365                                  	mov	cx,3
 13366                                  	rep	movsb
 13367                                  	xor	ax,ax
 13368                                  	stosb
 13369                                  	push	dx
 13370                                  	mov	dx,CHARBUF
 13371                                  	mov	[STRING_PTR_2],dx
 13372                                  	mov	dx,STRINGBUF2PTR
 13373                                  	call	STD_PRINTF
 13374                                  	pop	dx
 13375                                  	retn
 13376                                  
 13377                                  %endif
 13378                                  
 13379                                  ;============================================================================
 13380                                  ; DIR.ASM, MSDOS 6.0, 1991
 13381                                  ;============================================================================
 13382                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13383                                  
 13384                                  	; MSDOS 6.0
 13385                                  %if 0
 13386                                  
 13387                                  ;***	DIR.ASM - DIR internal command
 13388                                  
 13389                                  comment	% =================================================================
 13390                                  
 13391                                  This module replaces TCMD1A.ASM.  The old module was titled 
 13392                                  "PART4 COMMAND Transient routines".
 13393                                  
 13394                                  From residual documentation, I surmise that TCMD.ASM originally
 13395                                  contained the internal commands DIR, PAUSE, ERASE, TYPE, VOL, and
 13396                                  VER.  The file seems to have been successively split:
 13397                                  
 13398                                    TCMD -> TCMD1,TCMD2 -> TCMD1A,TCMD1B,TCMD2A,TCMD2B
 13399                                  
 13400                                  TCMD1A.ASM contained only the DIR command.
 13401                                  
 13402                                  Usage:
 13403                                  ------
 13404                                  
 13405                                  DIR <filespec> /w /p /b /s /l /c /o<sortorder> /a<attriblist>
 13406                                  
 13407                                  DIR /?
 13408                                  
 13409                                  
 13410                                  <filespec> may include any or none of:  drive; directory path;
 13411                                             wildcarded filename.  If drive or directory path are
 13412                                  	   omitted, the current defaults are used.  If the
 13413                                  	   file name or extension is omitted, wildcards are
 13414                                  	   assumed.
 13415                                  
 13416                                  /w	Wide listing format.  Files are displayed in compressed
 13417                                  	'name.ext' format.  Subdirectory files are enclosed in
 13418                                  	brackets, '[dirname]'.
 13419                                  
 13420                                  /p	Paged, or prompted listing.  A screenful is displayed
 13421                                  	at a time.  The name of the directory being listed appears
 13422                                  	at the top of each page.
 13423                                  
 13424                                  	Bugbug:  pages nead to be uniform length..?
 13425                                  
 13426                                  /b	Bare listing format.  Turns off /w or /p.  Files are 
 13427                                  	listed in compressed 'name.ext' format, one per line,
 13428                                  	without additional information.  Good for making batch
 13429                                  	files or for piping.  When used with /s, complete
 13430                                  	pathnames are listed.
 13431                                  
 13432                                  /s	Descend subdirectory tree.  Performs command on current
 13433                                  	or specified directory, then for each subdirectory below
 13434                                  	that directory.  Directory header and footer is displayed
 13435                                  	for each directory where matching files are found, unless
 13436                                  	used with /b.  /b suppresses headers and footers.
 13437                                  
 13438                                  	Tree is explored depth first, alphabetically within the
 13439                                  	same level.
 13440                                  
 13441                                  	Bugbug:  hidden directories aren't searched.
 13442                                  
 13443                                  /l	Display file names, extensions and paths in lowercase.	;M010
 13444                                  
 13445                                  /c	Display file compression ratio, if the file is on a MagicDrv
 13446                                  	compressed volume.
 13447                                  
 13448                                  /o	Sort order.  /o alone sorts by default order (dirs-first, name,
 13449                                  	extension).  A sort order may be specified after /o.  Any of
 13450                                  	the following characters may be used: nedsgc (name, extension,
 13451                                  	date/time, size, group-dirs-first, compression ratio).	Placing
 13452                                  	a '-' before any letter causes a downward sort on that field.
 13453                                  	E.g., /oe-d means sort first by extension in alphabetical order,
 13454                                  	then within each extension sort by date and time in reverse
 13455                                  	chronological order.
 13456                                  
 13457                                  /a	Attribute selection.  Without /a, hidden and system files
 13458                                  	are suppressed from the listing.  With /a alone, all files
 13459                                  	are listed.  An attribute list may follow /a, consisting of
 13460                                  	any of the following characters:  hsdar (hidden, system,
 13461                                  	directory, archive, read-only).  A '-' before any letter
 13462                                  	means 'not' that attribute.  E.g., /ar-d means files that
 13463                                  	are marked read-only and are not directory files.  Note
 13464                                  	that hidden or system files may be included in the listing.
 13465                                  	They are suppressed without /a but are treated like any other
 13466                                  	attribute with /a.
 13467                                  
 13468                                  /?	Help listing.  Display DIR useage information.	;M008;Handled externally
 13469                                  
 13470                                  /h has been removed.					;M008
 13471                                  
 13472                                  DIRCMD	An environment variable named DIRCMD is parsed before the
 13473                                  	DIR command line.  Any command line options may be specified
 13474                                  	in DIRCMD, and become defaults.  /? will be ignored in DIRCMD.
 13475                                  	A filespec may be specified in DIRCMD and will be used unless
 13476                                  	a filespec is specified on the command line.  Any switch
 13477                                  	specified in DIRCMD may be overridden on the command line.
 13478                                  	If the original DIR default action is desired for a particular
 13479                                  	switch, the switch letter may be preceded by a '-' on the
 13480                                  	command line.  E.g.,
 13481                                  
 13482                                  	  /-w	use long listing format
 13483                                  	  /-p	don't page the listing
 13484                                  	  /-b	don't use bare format
 13485                                  	  /-s	don't descend subdirectory tree
 13486                                  	  /-o	display files in disk order
 13487                                  	  /-a	suppress hidden and system files
 13488                                  
 13489                                  Notes:
 13490                                  ------
 13491                                  
 13492                                  For sorted listings, file entries are loaded into the TPA buffer, which
 13493                                  is usually about 64K in size.  This allows sorts of up to 3000 files at
 13494                                  a time.  Each entry takes up 21 bytes in the buffer (see EntryStruc below).
 13495                                  The byte after the last entry is 0FFh.  The first byte of each entry is
 13496                                  a flag byte which is made zero when the entry is loaded, and made one
 13497                                  when the entry is used.
 13498                                  
 13499                                  Revision History
 13500                                  ================
 13501                                  M01	md	7/13/90 	Use ROM BIOS data area to obtain screen height
 13502                                  				in the absence of ANSI.SYS
 13503                                  
 13504                                  M007	sa	8/1/90		Allow /p/b combination
 13505                                  
 13506                                  M008	sa	8/1/90		Remove /h parameter.  Eliminate code used
 13507                                  				to internally handle /? message.
 13508                                  
 13509                                  M010	sa	8/5/90		Add support for /l (lowercase) option.
 13510                                  
 13511                                  M011	sa	8/5/90		Patch up bug where MS-DOS does not load the
 13512                                  				first FCB with the drive number when the drive
 13513                                  				letter in the command line is preceded by a
 13514                                  				switch.  Now dir manually loads the drive
 13515                                  				number after parsing.
 13516                                  
 13517                                  M018	md	8/12/90 	Increment the screen height by 1 when obtained
 13518                                  				from the ROM BIOS.
 13519                                  
 13520                                  M023	sa	8/31/90		Prevent DIR from failing if it encounters
 13521                                  				a subdirectory having len(pathname)>MAXPATH.
 13522                                  				Just skip over that subdirectory.
 13523                                  
 13524                                  M028	dbo	9/24/90		When country=US, sort by strict character
 13525                                  				byte value, rather than collating table.
 13526                                  				This to match MS-DOS Shell's sort order.
 13527                                  
 13528                                  ========================================================================= %
 13529                                  
 13530                                  %endif
 13531                                  
 13532                                  ; 16/02/2023
 13533                                  
 13534                                  NUM_DIR_SWS	equ	14	; # of dir switch synonyms in Dir_Sw_Ptrs list
 13535                                  
 13536                                  ;OptionRec	record	inmem:1,lcase:1,bare:1,subd:1,pagd:1,wide:1
 13537                                  ;
 13538                                  ;		on/off bit record for /l, /b, /s, /p, /w, /c options
 13539                                  ;		(order is hard-coded; see OnOffSw)
 13540                                  ;		Inmem is set when entries are loaded in memory.
 13541                                  
 13542                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13543                                  mask.wide  equ 1
 13544                                  mask.pagd  equ 2
 13545                                  mask.subd  equ 4
 13546                                  mask.bare  equ 8
 13547                                  mask.lcase equ 16
 13548                                  mask.inmem equ 32
 13549                                  ;
 13550                                  mask.dev    equ 1
 13551                                  mask.baddir equ 2	
 13552                                  
 13553                                  NUM_ATTR_LTRS	equ	6	; length of attribute letter list
 13554                                  
 13555                                  NUM_ORDER_LTRS	equ	5	; length of sort order letter list
 13556                                  
 13557                                  ;ResultBuffer	struc		; structure of parse result buffer
 13558                                  ;ValueType	db	?
 13559                                  ;ValueTag	db	?
 13560                                  ;SynPtr		dw	?
 13561                                  ;ValuePtr	dd	?
 13562                                  ;ResultBuffer	ends
 13563                                  
 13564                                  ;ErrorRec	record	baddir:1,dev:1
 13565                                  ;
 13566                                  ;		Error bits are:
 13567                                  ;		  Invalid directory format
 13568                                  ;		  File is device
 13569                                  
 13570                                  ;EntryStruc	struc			; our private directory entry structure
 13571                                  ;used		db	?		; =0 until entry used, then =1
 13572                                  ;filename	db	8 dup (?)	; filename
 13573                                  ;fileext	db	3 dup (?)	; extension
 13574                                  ;fileattr	db	?		; file attributes
 13575                                  ;filetime	dw	?		; file time
 13576                                  ;filedate	dw	?		; file date
 13577                                  ;filesize	dd	?		; file size
 13578                                  ;EntryStruc	ends
 13579                                  
 13580                                  ;shove	macro	val		; hose-bag 8086 doesn't push immediate
 13581                                  ;	mov	ax,val		; invisible, dangerous use of AX!
 13582                                  ;	push	ax
 13583                                  ;	endm
 13584                                  
 13585                                  ;	public	Catalog		; our entry point
 13586                                  ;
 13587                                  ;	break	<DIR (Catalog) principal routines>
 13588                                  ;
 13589                                  ;	assume	cs:TRANGROUP,ds:TRANGROUP,es:nothing,ss:TRANGROUP
 13590                                  ; ---------------------------------------------------------------------------
 13591                                  ;	Bugbug:	Each routine should start with it's own ASSUME.
 13592                                  
 13593                                  ;----------------------------------------------------------------------------
 13594                                  ;----------------------------------------------------------------------------
 13595                                  
 13596                                  ; 16/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 13597                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:108Dh
 13598                                  
 13599                                  ;***	Catalog - DIR command main routine
 13600                                  ;
 13601                                  ;	ENTRY	FCB #1 in PSP has drive# from cmd-line or default
 13602                                  ;		Cmd-line tail text is at 81h, terminated by 0Dh
 13603                                  ;		CS, DS, ES, SS = TRANGROUP seg addr
 13604                                  ;		Tpa = TPA buffer seg addr
 13605                                  ;		BytCnt = # bytes in TPA buffer
 13606                                  ;
 13607                                  ;	EXIT	nothing
 13608                                  ;
 13609                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 13610                                  ;
 13611                                  ;	ERROR EXITS
 13612                                  ;
 13613                                  ;	  Errors are handled by setting up error message pointers
 13614                                  ;	   for Std_EPrintf and jumping to CError. Syntax errors in
 13615                                  ;	   the environment variable, however, are handled by printing
 13616                                  ;	   an error message and continuing.
 13617                                  ;
 13618                                  ;	EFFECTS
 13619                                  ;
 13620                                  ;	  Directory listing is displayed (on standard output).
 13621                                  ;	  APPEND is disabled. HeadFix routine is expected to
 13622                                  ;	   restore APPEND state.
 13623                                  ;	  Working directory may be changed. The user's default
 13624                                  ;	   directory is saved and flagged for restoration by RestUDir
 13625                                  ;	   during COMMAND cycle.
 13626                                  ;	  Lots of variables may be changed in TRANSPACE segment.
 13627                                  ;
 13628                                  ;	NOTES
 13629                                  ;
 13630                                  ;	  ES = TRANGROUP seg addr except when used to address the
 13631                                  ;	   the TPA buffer, where directory entries are loaded from disk.
 13632                                  
 13633                                  	; 16/02/2023
 13634                                  CATALOG:
 13635 0000106C E8A500                  	call	SetDefaults
 13636 0000106F E8C900                  	call	ParseEnvironment
 13637 00001072 E8E100                  	call	ParseCmdLine
 13638 00001075 7303                    	jnc	short catalog1	; no parse error
 13639 00001077 E99700                  	jmp	catErr		; error msg is set up
 13640                                  catalog1:
 13641 0000107A E80A01                  	call	SetOptions
 13642 0000107D E8E000                  	call	SetCollatingTable
 13643                                  
 13644                                  ;	Drive # to operate on has already been placed in FCB by
 13645                                  ;	COMMAND preprocessing. OkVolArg & PathCrunch depend on that.
 13646                                  
 13647                                  	;;;test	Bits,mask bare
 13648                                  	;;test 	word [_Bits],8
 13649                                  	;test	byte [_Bits],8
 13650 00001080 F606[F78B]08            	test	byte [_Bits],mask.bare
 13651 00001085 750A                    	jnz	short catalog2	; don't display volume info for /b
 13652                                  	;invoke	OkVolArg	; find & display volume info
 13653 00001087 E8E40B                  	call	OkVolArg
 13654                                  	;sub	byte [LeftOnpage],2
 13655 0000108A 832E[C68A]02            	sub	word [LeftOnPage],2
 13656                                  				; record display lines used by volume info
 13657 0000108F EB15                    	jmp	short catCrunch
 13658                                  
 13659                                  ;	OkVolArg side effects:
 13660                                  ;	APPEND is disabled;
 13661                                  ;	DTA established at DirBuf;
 13662                                  ;	Filename fields in FCB are wildcarded.
 13663                                  
 13664                                  catalog2:
 13665                                  ;	OkVolArg wasn't executed, so we have to do these ourselves.
 13666                                  
 13667                                  	;invoke	DisAppend	; disable APPEND
 13668 00001091 E8A70B                  	call	DisAppend
 13669                                  
 13670                                  	;mov	dx,offset TRANGROUP:DirBuf
 13671 00001094 BA[A58B]                	mov	dx,DIRBUF
 13672 00001097 B41A                    	mov	ah,1Ah
 13673                                  	;mov	ah,Set_DMA
 13674 00001099 CD21                    	int	21h		; set DTA
 13675                                  
 13676 0000109B BF5C00                  	mov	di,FCB	; 5Ch	; ES:DI = ptr to FCB
 13677 0000109E 47                      	inc	di		; ES:DI = ptr to filename field of FCB
 13678 0000109F B03F                    	mov	al,'?'		; AL = wildcard character
 13679 000010A1 B90B00                  	mov	cx,11
 13680 000010A4 F3AA                    	rep	stosb		; wildcard filename field
 13681                                  
 13682                                  catCrunch:
 13683 000010A6 E83901                  	call	CrunchPath	; crunch pathname to get directory and filename
 13684 000010A9 7230                    	jc	short catRecErr	; handle recorded or extended error
 13685                                  
 13686                                  ;	User's directory has been saved, we've changed to specified directory.
 13687                                  ;	ComSw = error bits for later use
 13688                                  ;	FCB contains parsed filename
 13689                                  
 13690                                  	;cmp	byte [COMSW],0
 13691 000010AB 833E[B38A]00            	cmp	word [COMSW],0
 13692 000010B0 7529                    	jne	short catRecErr	; handle recorded error
 13693                                  
 13694 000010B2 E88701                  	call	InstallCtrlC	; install control-C handler
 13695 000010B5 E8D008                  	call	ZeroTotals	; zero grand totals
 13696 000010B8 E84304                  	call	ListDir		; list main directory
 13697 000010BB 7244                    	jc	short catExtErr
 13698                                  
 13699                                  	;;;test	Bits,mask subd
 13700                                  	;;test	word [_Bits],4
 13701                                  	;test	byte [_Bits],4
 13702 000010BD F606[F78B]04            	test	byte [_Bits],mask.subd
 13703 000010C2 7405                    	jz	short catalog3	; subdirectories option not set
 13704 000010C4 E88D01                  	call	ListSubds	; list subdirectories
 13705 000010C7 7238                    	jc	short catExtErr
 13706                                  catalog3:
 13707                                  ;	Check if any files were found.
 13708                                  
 13709                                  	;;;test	Bits,mask bare
 13710                                  	;;test	word [_Bits],8
 13711                                  	;test	byte [_Bits],8
 13712 000010C9 F606[F78B]08            	test	byte [_Bits],mask.bare
 13713 000010CE 750A                    	jnz	short catRet	; don't bother for bare format
 13714                                  
 13715 000010D0 A1[CE8A]                	mov	ax,[FileCntTotal]
 13716 000010D3 09C0                    	or	ax,ax
 13717 000010D5 7417                    	jz	short catNoFiles ; no files found
 13718                                  
 13719 000010D7 E8A702                  	call	DisplayTotals	; display trailing grand totals
 13720                                  	;jmp	short catRet	; all done
 13721                                  	; 25/04/2023
 13722                                  catRet:
 13723 000010DA C3                      	retn
 13724                                  
 13725                                  catRecErr:
 13726                                  
 13727                                  ;	ComSw may have error bit set. If not, do extended error.
 13728                                  
 13729                                  	;;;test	ComSw,mask dev
 13730                                  	;;test	word [COMSW],1
 13731                                  	;test	byte [COMSW],1
 13732 000010DB F606[B38A]01            	test	byte [COMSW],mask.dev
 13733 000010E0 750C                    	jnz	short catNoFiles 
 13734                                  				; filename is device, respond 'file not found'
 13735                                  	;;test	ComSw,mask baddir
 13736                                  	;;test	word [COMSW],2
 13737                                  	;test	byte [COMSW],2
 13738 000010E2 F606[B38A]02            	test	byte [COMSW],mask.baddir
 13739 000010E7 7418                    	jz	short catExtErr	; no ComSw error bits, must be extended error
 13740                                  	;mov	dx,offset TRANGROUP:BadCd_Ptr
 13741                                  				; invalid directory
 13742 000010E9 BA[6C80]                	mov	dx,badcd_ptr
 13743 000010EC EB23                    	jmp	short catErr
 13744                                  
 13745                                  catNoFiles:
 13746                                  
 13747                                  ;	Display header and force 'file not found' message.
 13748                                  
 13749 000010EE E81207                  	call	DisplayHeader
 13750 000010F1 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 13751 000010F4 C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 13752 000010F9 BA[317F]                	mov	dx,extend_buf_ptr
 13753 000010FC A3[317F]                	mov	[extend_buf_ptr],ax
 13754 000010FF EB10                    	jmp	short catErr
 13755                                  
 13756                                  catExtErr:
 13757                                  
 13758                                  ;	DOS has returned an error status. Get the extended error#, and
 13759                                  ;	set up an error message, changing 'No more files' error 
 13760                                  ;	to 'File not found' error.
 13761                                  
 13762 00001101 E8E80B                  	call	Set_Ext_Error_Msg
 13763 00001104 833E[317F]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 13764 00001109 7506                    	jne	short catalog4  ; catErr
 13765 0000110B C706[317F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 13766                                  catalog4:
 13767                                  
 13768                                  ;	Error exit. Error message information has been set up
 13769                                  ;	for Std_EPrintf.
 13770                                  
 13771                                  catErr:
 13772 00001111 E93718                  	jmp	cerror		; go to COMMAND error recycle point
 13773                                  
 13774                                  	; 25/04/2023
 13775                                  ;catRet:
 13776                                  	;retn
 13777                                  
 13778                                  ; ---------------------------------------------------------------------------
 13779                                  
 13780                                  ;***	SetDefaults - set default pathname, options
 13781                                  ;
 13782                                  ;	ENTRY	DS = TRANGROUP seg addr
 13783                                  ;
 13784                                  ;	EXIT	nothing
 13785                                  ;
 13786                                  ;	USED	AX,DI
 13787                                  ;
 13788                                  ;	EFFECTS
 13789                                  ;	  SrcBuf = '*',EOL - default pathname
 13790                                  ;	  PathPos = ptr to pathname
 13791                                  ;	  PathCnt = length of pathname
 13792                                  
 13793                                  	; 16/02/2023
 13794                                  SetDefaults:
 13795 00001114 BF[0B8D]                	mov	di,SrcBuf		; DI = ptr to pathname buffer
 13796 00001117 893E[FB8B]              	mov	[PathPos],di		; PathPos = ptr to pathname
 13797                                  	;mov	al,STAR
 13798 0000111B B02A                    	mov	al,'*'
 13799 0000111D AA                      	stosb
 13800                                  	;mov	al,END_OF_LINE_IN
 13801 0000111E B00D                    	mov	al,0Dh ; cr
 13802 00001120 AA                      	stosb				; SrcBuf = '*',0Dh
 13803 00001121 C706[F98B]0100          	mov	word [PathCnt],1	; PathCnt = pathname length
 13804                                  
 13805 00001127 31C0                    	xor	ax,ax			; AX = 0
 13806 00001129 A3[B38A]                	mov	[COMSW],ax		; = no error
 13807 0000112C A3[F78B]                	mov	[_Bits],ax		; = options off
 13808 0000112F A2[A88C]                	mov	[DestBuf],al		; = no sort
 13809 00001132 C606[FF8B]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM ; 6
 13810 00001137 A2[008C]                	mov	[AttrSelect],al		; exclude hidden, system files
 13811                                  peRet:	; 25/04/2023
 13812 0000113A C3                      	retn
 13813                                  
 13814                                  ; ---------------------------------------------------------------------------
 13815                                  
 13816                                  ;***	ParseEnvironment - find and parse our environment variable
 13817                                  ;
 13818                                  ;	Find our environment variable and parse it. If a parse
 13819                                  ;	error occurs, issue an error message. The parse results
 13820                                  ;	up to the error will still have effect. Always leave
 13821                                  ;	the option variables in a useable state.
 13822                                  ;
 13823                                  ;	ENTRY	DS = TRANGROUP seg addr
 13824                                  ;
 13825                                  ;	EXIT	nothing
 13826                                  ;
 13827                                  ;	USED	AX,BX,CX,DX,SI,DI
 13828                                  ;
 13829                                  ;	EFFECTS
 13830                                  ;
 13831                                  ;	  Bits may contain new option settings.
 13832                                  ;	  DestBuf may contain new series of sort codes.
 13833                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 13834                                  ;	  SrcBuf may contain a new default pathname/filespec.
 13835                                  ;	  PathPos, PathCnt updated for new pathname.
 13836                                  ;
 13837                                  ;	  If a parse error occurred, an error message will be issued.
 13838                                  
 13839                                  	; 16/02/2023
 13840                                  ParseEnvironment:
 13841 0000113B E87603                  	call	GetEnvValue		; get environment variable value
 13842 0000113E 72FA                    	jc	short peRet		; name not found in environment
 13843                                  
 13844                                  ;	SI = ptr to value of environment variable, in TRANGROUP seg
 13845                                  
 13846 00001140 E8BA04                  	call	Parse_Line		; parse environment value
 13847 00001143 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 13848                                  	;cmp	ax,END_OF_LINE
 13849 00001146 74F2                    	je	short peRet		; successful completion
 13850                                  
 13851                                  ;	Some kind of parse error occurred.
 13852                                  ;	We're set up for a Std_EPrintf call.
 13853                                  
 13854 00001148 E8B03C                  	call	std_eprintf		; display the parse error
 13855                                  	;mov	byte [Msg_Disp_Class],util_msg_class ; -1
 13856                                  					; restore default msg class
 13857 0000114B C606[2F7F]FF            	mov	byte [msg_disp_class],0FFh ; -1
 13858                                  	;mov	dx,offset TRANGROUP:ErrParsEnv_Ptr
 13859 00001150 BA[7081]                	mov	dx,errparsenv_ptr
 13860                                  	;;invoke Printf_Crlf		; "(Error occurred in environment.."
 13861                                  	;call	Printf_Crlf
 13862                                  	; 25/04/2023
 13863                                  	;retn
 13864 00001153 E99F3C                  	jmp	Printf_Crlf
 13865                                  					;M008;Internal handling of /? removed
 13866                                  ;peOk:	and	Bits,not mask help	; disallow /h in environment variable
 13867                                  	; 25/04/2023
 13868                                  ;peRet:
 13869                                  	;retn
 13870                                  
 13871                                  ; ---------------------------------------------------------------------------
 13872                                  
 13873                                  ;***	ParseCmdLine - parse and record command line parameters
 13874                                  ;
 13875                                  ;	ENTRY	PSP offset 81h is beginning of cmd line buffer
 13876                                  ;		DS, ES, CS = TRANGROUP seg addr
 13877                                  ;
 13878                                  ;	EXIT	CY = set if parse error occurred
 13879                                  ;
 13880                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 13881                                  ;		AX = system parser error code
 13882                                  ;		DX = ptr to message block
 13883                                  ;
 13884                                  ;	USED	AX,BX,CX,DX,SI,DI
 13885                                  ;
 13886                                  ;	EFFECTS
 13887                                  ;
 13888                                  ;	  Bits may contain new option settings.
 13889                                  ;	  DestBuf may contain new series of sort codes.
 13890                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 13891                                  ;	  SrcBuf may contain a new default pathname/filespec.
 13892                                  ;	  PathPos, PathCnt updated for new pathname.
 13893                                  ;
 13894                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 13895                                  ;	  Msg_Disp_Class = parse error class
 13896                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 13897                                  ;	  Message block (see DX) is set up for parse error message
 13898                                  
 13899                                  	; 16/02/2023
 13900                                  ParseCmdLine:
 13901 00001156 BE8100                  	mov	si,81h			; SI = ptr to cmd-line tail text
 13902 00001159 E8A104                  	call	Parse_Line		; parse cmd line tail
 13903 0000115C 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 13904                                  	;;cmp	ax,END_OF_LINE
 13905                                  	; 25/04/2023
 13906                                  	;je	short pcOk		; parse completed successfully
 13907                                  
 13908                                  ;	A parse error occurred. We're all set up for message output.
 13909                                  
 13910                                  	; 25/04/2023
 13911                                  	; cf = 1 (ax < 0FFFFh)
 13912                                  	;stc		   		; return failure
 13913                                  	;jmp	short pcRet
 13914                                  	; 25/04/2023
 13915                                  	;retn
 13916                                  pcOk:
 13917                                  	; 25/04/2023
 13918                                  	;cf = 0 (ax = 0FFFFh)
 13919                                  	;clc				; return success
 13920                                  pcRet:
 13921 0000115F C3                      	retn
 13922                                  
 13923                                  ; ---------------------------------------------------------------------------
 13924                                  
 13925                                  ;***	SetCollatingTable - set up character collating table for sorting
 13926                                  ;
 13927                                  ;	If country is other than USA, try to get a collating table
 13928                                  ;	for character sorting. For USA, use straight byte values.
 13929                                  ;	This is so DIR behaves like the MS-DOS Shell, which sorts
 13930                                  ;	by straight byte values in the USA for better performance.
 13931                                  ;
 13932                                  ;	ENTRY	ES = TRANGROUP seg addr
 13933                                  ;
 13934                                  ;	EXIT	nothing
 13935                                  ;
 13936                                  ;	USED	AX,BX,CX,DX,DI
 13937                                  ;
 13938                                  ;	EFFECTS
 13939                                  ;
 13940                                  ;	  If collating table is set -
 13941                                  ;	    CountryPtrId = 6.
 13942                                  ;	    CountryPtr points to collating table.
 13943                                  ;
 13944                                  ;	  Otherwise -
 13945                                  ;	    CountryPtrId = 0.
 13946                                  
 13947                                  SetCollatingTable:
 13948                                  
 13949                                  ;	Begin modification M028
 13950                                  
 13951                                  	;mov	dx,offset TRANGROUP:InternatVars
 13952                                  	;			; DS:DX = ptr to international info buffer
 13953 00001160 BA[7A95]                	mov	dx,INTERNATVARS
 13954 00001163 B80038                  	mov	ax,3800h
 13955                                  	;mov	ax,INTERNATIONAL << 8
 13956                                  	;;mov	ax,INTERNATIONAL shl 8
 13957                                  				; AX = 'Get current country info'
 13958 00001166 CD21                    	int	21h		; call DOS
 13959 00001168 7217                    	jc	short scNoTable	; error - so don't collate
 13960                                  
 13961                                  ;	BX = country code
 13962                                  
 13963 0000116A 83FB01                  	cmp	bx,1
 13964 0000116D 7412                    	je	short scNoTable	; we're in USA, don't collate
 13965                                  
 13966                                  ;	End modification M028
 13967                                  
 13968                                  ;*	Country code is other than USA. Try to get a collating table.
 13969                                  
 13970 0000116F B80665                  	mov	ax,6506h
 13971                                  	;mov	ax,(GETEXTCNTRY << 8) + SETCOLLATE
 13972                                  	;;mov	ax,(GETEXTCNTRY shl 8) + SETCOLLATE
 13973                                  				; AH = 'Get Extended Country Info'
 13974                                  				; AL = 'Get Pointer to Collating Table'
 13975 00001172 BBFFFF                  	mov	bx,-1		; BX = code page of interest = CON
 13976 00001175 B90500                  	mov	cx,5		; CX = length of info buffer
 13977 00001178 89DA                    	mov	dx,bx		; DX = country ID = default
 13978                                  	;mov	di,offset TRANGROUP:CountryPtrInfo
 13979 0000117A BF[9A95]                	mov	di,CountryPtrInfo
 13980                                  				; ES:DI = ptr to info buffer
 13981 0000117D CD21                    	int	21h		; call DOS
 13982 0000117F 7305                    	jnc	short scRet	; success
 13983                                  
 13984                                  ;*	Set CountryPtrId = 0 to signal no collating table.
 13985                                  
 13986                                  scNoTable:			;M028
 13987 00001181 C606[9A95]00            	mov	byte [CountryPtrId],0
 13988                                  scRet:
 13989 00001186 C3                      	retn
 13990                                  
 13991                                  ; ---------------------------------------------------------------------------
 13992                                  
 13993                                  ;***	SetOptions - check and set options
 13994                                  ;
 13995                                  ;	ENTRY	nothing
 13996                                  ;
 13997                                  ;	EXIT	nothing
 13998                                  ;
 13999                                  ;	USED	AX,BX,CX,DX
 14000                                  ;
 14001                                  ;	EFFECTS
 14002                                  ;
 14003                                  ;	  Bits may contain modified option settings.
 14004                                  ;	  Display_Ioctl table, including LinPerPag variable, is filled in.
 14005                                  ;	  LeftOnPage is initialized to # lines till end of page is handled.
 14006                                  ;	  PerLine is set according to /w presence.
 14007                                  
 14008                                  	; 16/02/2023
 14009                                  SetOptions:
 14010                                  
 14011                                  ;	If bare listing requested, cancel wide listings.
 14012                                  
 14013                                  	;;;test	Bits,mask bare
 14014                                  	;;test	word [_Bits],8
 14015                                  	;test	byte [_Bits],8
 14016 00001187 F606[F78B]08            	test	byte [_Bits],mask.bare
 14017 0000118C 7405                    	jz	short setopts1
 14018                                  	;;;and	Bits,not mask wide	;M007;Allow /p with /b
 14019                                  	;;and	word [_Bits],0FFFEh
 14020                                  	;;and	byte [_Bits],0FEh
 14021 0000118E 8026[F78B]FE            	and	byte [_Bits],~mask.wide ; 0FEh
 14022                                  setopts1:
 14023                                  ;	Set # lines per display page.
 14024                                  
 14025                                  ;M01  Obtain screen height from ROM BIOS data area
 14026                                  ;
 14027                                  ;M01	mov	LinPerPag,LINESPERPAGE	; default value
 14028                                  
 14029 00001193 1E                      	push	ds
 14030                                  	;mov	ax,ROMBIOS_DATA 	; Get ROM Data segment
 14031 00001194 B84000                  	mov	ax,40h
 14032 00001197 8ED8                    	mov	ds,ax			;
 14033                                  	;Assume	DS:ROMBIOS_DATA
 14034                                  
 14035                                  	;mov	al,[CRT_Rows] ; [84h]	; Get max rows
 14036 00001199 A08400                  	mov	al,[84h]
 14037 0000119C 1F                      	pop	ds			;
 14038                                  	;Assume	DS:Trangroup
 14039                                  
 14040 0000119D 08C0                    	or	al,al			; If zero specified
 14041 0000119F 7502                    	jnz	short setopts2		;
 14042                                  
 14043                                  	;mov	al,LINESPERPAGE 	; assume 24 rows
 14044 000011A1 B019                    	mov	al,25	; MSDOS 5.0 COMMAND.COM (TRANGROUP:11D1h)
 14045                                  setopts2:
 14046 000011A3 30E4                    	xor	ah,ah
 14047                                  setopts3:
 14048 000011A5 FEC0                    	inc	al			; height + 1 ;M018
 14049                                  
 14050 000011A7 A3[F28D]                	mov	[LinPerPag],ax		; set the rows now
 14051                                  
 14052                                  ; Now the console driver can change the rows if it knows better (M01 end)
 14053                                  
 14054                                  	;mov	ax,(IOCTL shl 8)+GENERIC_IOCTL_HANDLE 
 14055                                  					; IOCTL for handles
 14056 000011AA B80C44                  	mov	ax,440Ch
 14057                                  	;mov	bx,STDOUT		; handle #
 14058 000011AD BB0100                  	mov	bx,1
 14059                                  	;mov	ch,IOC_SC		; screen
 14060 000011B0 B503                    	mov	ch,3
 14061                                  	;mov	cl,get_generic		; get display info
 14062 000011B2 B17F                    	mov	cl,7Fh
 14063 000011B4 BA[E28D]                	mov	dx,Display_Ioctl	; info block
 14064 000011B7 CD21                    	int	21h			; call DOS
 14065                                  
 14066 000011B9 A1[F28D]                	mov	ax,[LinPerPag]		; AX = # lines per page
 14067 000011BC A3[C68A]                	mov	[LeftOnPage],ax		; initialize # lines left on page
 14068                                  
 14069                                  ;	Set # entries per line.
 14070                                  
 14071                                  	;mov	byte [PerLine],NORMPERLIN
 14072                                  					; # entries per line without /w
 14073 000011BF C606[C38A]01            	mov	byte [PerLine],1
 14074                                  	;;;test	Bits,mask wide
 14075                                  	;;test	word [_Bits],1
 14076                                  	;test	byte [_Bits],1
 14077 000011C4 F606[F78B]01            	test	byte [_Bits],mask.wide
 14078 000011C9 7405                    	jz	short setopts4
 14079                                  	;mov	byte [PerLine],WIDEPERLIN
 14080                                  					; # entries per line with /w
 14081 000011CB C606[C38A]05            	mov	byte [PerLine],5
 14082                                  setopts4:
 14083                                  				;M011;start;The following code checks if a drive
 14084                                  				;letter has been parsed into SrcBuf, and if
 14085                                  				;so, the correct drive number is loaded into
 14086                                  				;the first FCB, at offset 5C.
 14087                                  
 14088                                  	;cmp	TRANGROUP:[SrcBuf+1],COLON_CHAR	; is this a drive letter?
 14089 000011D0 803E[0C8D]3A            	cmp	byte [SrcBuf+1],':'
 14090 000011D5 750A                    	jne	short soRet
 14091                                  	;mov	al,TRANGROUP:[SrcBuf]		; load drive letter into al
 14092 000011D7 A0[0B8D]                	mov	al,[SrcBuf]
 14093                                  	;and	al,not 20h			; capitalize ASCII drive letter (LowerCase-32)-->UpperCase
 14094 000011DA 24DF                    	and	al,0DFh ; ~20h ; not 20h
 14095 000011DC 2C40                    	sub	al,'@'				; convert to 1-based number (1=A)
 14096 000011DE A25C00                  	mov	[FCB],al  ; [5Ch]		; store in first FCB
 14097                                  						;M011;end
 14098                                  soRet:
 14099 000011E1 C3                      	retn
 14100                                  
 14101                                  ; ---------------------------------------------------------------------------
 14102                                  
 14103                                  ;***	CrunchPath - analyze supplied or default pathname
 14104                                  ;
 14105                                  ;	ENTRY	PathPos = ptr to pathname buffer
 14106                                  ;		PathCnt = length of pathname, not incl trailing delimiter
 14107                                  ;		Pathname in buffer must end in delimiter (like CR) and
 14108                                  ;		 must have space for another char after the delimiter.
 14109                                  ;
 14110                                  ;	EXIT	CY = clear if no error
 14111                                  ;		We are changed to directory found in pathname
 14112                                  ;		Previous directory ready to be restored via RestUDir
 14113                                  ;		FCB filename fields contain filename (possibly w/ wildcards)
 14114                                  ;
 14115                                  ;		If error occurred,
 14116                                  ;		CY = set
 14117                                  ;		ComSw = error bits (see ErrorRec)
 14118                                  ;		If ComSw not set,
 14119                                  ;		Ready for DOS Get Extended Error call
 14120                                  
 14121                                  	; 16/02/2023
 14122                                  CrunchPath:
 14123 000011E2 E8E101                  	call	FileIsDevice
 14124 000011E5 7507                    	jne	short crpath1	; not a device, skip ahead
 14125                                  	;;;or	ComSw,mask dev	; signal file is device
 14126                                  	;;or	word [COMSW],1
 14127                                  	;or	byte [COMSW],1
 14128 000011E7 800E[B38A]01            	or	byte [COMSW],mask.dev
 14129 000011EC EB2F                    	jmp	short cpErr	; return error
 14130                                  crpath1:
 14131 000011EE FF36[FB8B]              	push	word [PathPos]	; save ptr to pathname
 14132 000011F2 C606[038C]FF            	mov	byte [DirFlag],-1
 14133                                  				; tell PathCrunch not to parse file into FCB
 14134 000011F7 E87914                  	call	PathCrunch	; change to directory in pathname
 14135 000011FA C606[038C]00            	mov	byte [DirFlag],0
 14136                                  				; reset our little flag
 14137 000011FF 5E                      	pop	si		; SI = ptr to pathname
 14138 00001200 7208                    	jc	short cpNoDir	; didn't find directory path
 14139 00001202 741A                    	jz	short cpRet	; found directory path w/ no filename
 14140                                  				;  - leave wildcard default in FCB and return
 14141                                  
 14142                                  ;*	We found a directory, and there was a filename attached.
 14143                                  ;	DestTail = ptr to ASCIIZ filename
 14144                                  
 14145 00001204 8B36[A58C]              	mov	si,[DestTail]	; SI = ptr to filename
 14146 00001208 EB28                    	jmp	short cpFile	; go parse the file into FCB
 14147                                  
 14148                                  ;*	PathCrunch failed to find a directory in the pathname.
 14149                                  ;
 14150                                  ;	Msg_Numb = error code
 14151                                  ;	DestIsDir = nonzero if path delimiter char's occur in pathname
 14152                                  ;	SI = ptr to pathname (now an ASCIIZ string)
 14153                                  
 14154                                  cpNoDir:
 14155 0000120A A1[0F8E]                	mov	ax,[Msg_Numb]	  ; AX = error code from PathCrunch
 14156 0000120D 09C0                    	or	ax,ax
 14157 0000120F 750C                    	jnz	short cpErr	  ; error occurred - return it
 14158 00001211 803E[A38C]00            	cmp	byte [DestIsDir],0
 14159 00001216 7407                    	je	short cpMaybe	  ; no path delimiters seen, maybe it's a file
 14160                                  crpath3:
 14161                                  	;;;or	ComSw,mask baddir ; signal invalid directory name
 14162                                  	;;or	word [COMSW],2
 14163                                  	;or	byte [COMSW],2
 14164 00001218 800E[B38A]02            	or	byte [COMSW],mask.baddir
 14165                                  	;jmp	short cpErr	  ; return error
 14166                                  	; 16/02/2023
 14167                                  cpErr:
 14168 0000121D F9                      	stc			  ; return error
 14169                                  cpRet:
 14170 0000121E C3                      	retn
 14171                                  
 14172                                  cpMaybe:
 14173                                  ;	SI = ptr to pathname
 14174                                  
 14175                                  	;cmp	byte [si+1],COLON_CHAR
 14176 0000121F 807C013A                	cmp	byte [si+1],':'
 14177 00001223 7501                    	jne	short crpath2	  ; no drive specifier, skip ahead
 14178 00001225 AD                      	lodsw			  ; SI = ptr past drive specifier "d:"
 14179                                  crpath2:
 14180 00001226 813C2E2E                	cmp	word [si],".."
 14181 0000122A 7506                    	jne	short cpFile	  ; if not "..", treat as a file
 14182 0000122C 807C0200                	cmp	byte [si+2],0
 14183                                  	;jne	short cpFile	  ; or if there's more after "..", treat as file
 14184                                  	;;;;or	ComSw,mask baddir ; signal invalid directory
 14185                                  	;;;or	word [COMSW],2
 14186                                  	;;or	byte [COMSW],2
 14187                                  	;or	byte [COMSW],mask.baddir
 14188                                  	;jmp	short cpErr	  ; return error
 14189                                  	; 16/02/2023
 14190 00001230 74E6                    	je	short crpath3
 14191                                  
 14192                                  ;	The preceding code was taken from the old DIR routine.
 14193                                  ;	It's garbage, I'm afraid. It's meant to check for ".."
 14194                                  ;	occurring when we're at the root directory. Too bad it
 14195                                  ;	doesn't handle problems with "..\..", etc.
 14196                                  
 14197                                  ;	We're ready to parse a filename into the FCB.
 14198                                  ;	SI = ptr to ASCIIZ filename
 14199                                  
 14200                                  cpFile:	
 14201 00001232 BF5C00                  	mov	di,FCB	; 5Ch	; DI = ptr to FCB
 14202 00001235 B80E29                  	mov	ax,290Eh
 14203                                  	;mov	ax,(Parse_File_Descriptor<<8)|0Eh
 14204                                  	;;mov	ax,(Parse_File_Descriptor shl 8) or 0Eh
 14205                                  				; wildcards already in FCB used as defaults
 14206 00001238 CD21                    	int	21h
 14207 0000123A F8                      	clc			; return success
 14208                                  	;jmp	short cpRet
 14209                                  	; 16/02/2023
 14210 0000123B C3                      	retn
 14211                                  
 14212                                  ;cpErr:
 14213                                  ;	stc			; return error
 14214                                  ;cpRet:
 14215                                  ;	retn
 14216                                  
 14217                                  ; ---------------------------------------------------------------------------
 14218                                  
 14219                                  ;***	InstallCtrlC - install our private control-C handler
 14220                                  ;
 14221                                  ;	Put our control-c handler in front of command.com's default
 14222                                  ;	handler, to make sure the user's default directory gets restored.
 14223                                  ;	This shouldn't be necessary, but, for now, there are situations
 14224                                  ;	where the TDATA segment is left in a modified state when a
 14225                                  ;	control-c occurs.  This means that the transient will be
 14226                                  ;	reloaded, and the user's directory cannot be restored.
 14227                                  ;
 14228                                  ;	Bugbug:  fix the wider problem?  Involves message services.  Ugly.
 14229                                  ;
 14230                                  ;	ENTRY	nothing
 14231                                  ;
 14232                                  ;	EXIT	nothing
 14233                                  ;
 14234                                  ;	USED	AX,BX,DX
 14235                                  ;
 14236                                  ;	EFFECTS
 14237                                  ;
 14238                                  ;	  CtrlCHandler address placed in int 23 vector.
 14239                                  ;
 14240                                  ;	NOTE
 14241                                  ;
 14242                                  ;	  Command.com's basic control-c handler will be restored
 14243                                  ;	  to the int 23 vector by the HeadFix routine, after DIR finishes.
 14244                                  
 14245                                  	; 16/02/2023
 14246                                  InstallCtrlC:
 14247 0000123C 06                      	push	es			; preserve ES
 14248 0000123D B82335                  	mov	ax,3523h
 14249                                  	;mov	ax,(GET_INTERRUPT_VECTOR<<8)+23h
 14250                                  	;;mov	ax,(GET_INTERRUPT_VECTOR shl 8) + 23h
 14251 00001240 CD21                    	int	21h
 14252 00001242 891E[9F95]              	mov	[OldCtrlCHandler],bx	; save old int 23 vector
 14253 00001246 8C06[A195]              	mov	[OldCtrlCHandler+2],es	 
 14254 0000124A 07                      	pop	es			; restore ES
 14255                                  
 14256 0000124B BA[9319]                	mov	dx,CtrlCHandler 	; DS:DX = ptr to CtrlCHandler
 14257 0000124E B82325                  	mov	ax,2523h
 14258                                  	;mov	ax,(SET_INTERRUPT_VECTOR<<8)+23h
 14259                                  	;;mov	ax,(SET_INTERRUPT_VECTOR shl 8) + 23h
 14260 00001251 CD21                    	int	21h
 14261 00001253 C3                      	retn
 14262                                  
 14263                                  ; ---------------------------------------------------------------------------
 14264                                  
 14265                                  ;***	ListSubds - search and list files in subdirectories
 14266                                  ;
 14267                                  ;	ENTRY	Current directory (on selected drive) is top of subdir tree
 14268                                  ;		FCB is still set up for file searches
 14269                                  ;		Bits, AttrSpecified, AttrSelect, DestBuf all still set up
 14270                                  ;
 14271                                  ;	EXIT	CY = clear if no error
 14272                                  ;		FileCnt = # files found & displayed
 14273                                  ;		FileSiz = total size of files found
 14274                                  ;
 14275                                  ;		If error,
 14276                                  ;		CY = set
 14277                                  ;		Ready for DOS Get Extended Error call
 14278                                  ;
 14279                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 14280                                  ;
 14281                                  ;	EFFECTS
 14282                                  ;
 14283                                  ;	  FileCntTotal, FileSizTotal are updated.
 14284                                  ;	  Subdirectories may be listed on standard output device.
 14285                                  ;
 14286                                  ;	NOTES
 14287                                  ;
 14288                                  ;	  ListSubds seeds the recursive entry point lsNode with a ptr
 14289                                  ;	   to a buffer where we'll stack up subdirectory filenames.
 14290                                  ;	   Each name is stored ASCIIZ.
 14291                                  
 14292                                  	; 16/02/2023
 14293                                  ListSubds:
 14294                                  	;invoke	SetRest1		; make sure user's dir gets restored
 14295 00001254 E8851A                  	call	SetRest1
 14296                                  
 14297 00001257 BB[658D]                	mov	bx,ScanBuf   		; BX = ptr to child name buffer
 14298                                  lsNode:
 14299 0000125A C60700                  	mov	byte [bx],0		; start with null child name
 14300                                  lsLoop:
 14301 0000125D E8F001                  	call	FindNextChild		; search for next subdirectory
 14302 00001260 7235                    	jc	short lsErr		; search failed - examine error
 14303                                  
 14304 00001262 89DA                    	mov	dx,bx			; DX = ptr to child's name
 14305 00001264 E84104                  	call	ChangeDir		; enter child directory
 14306                                  
 14307                                  					; M023;start
 14308 00001267 7306                    	jnc	short lstsd1		; check for error
 14309                                  	;cmp	ax,3
 14310 00001269 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND	; error due to len(pathname)>MAXPATH?
 14311 0000126C 74EF                    	je	short lsLoop		; yes, skip over this subdirectory
 14312                                  	;jmp	short lsRet		; no, other error: DIR must fail
 14313                                  	; 16/02/2023			; M023;end
 14314 0000126E C3                      	retn
 14315                                  lstsd1:	
 14316 0000126F 53                      	push	bx
 14317 00001270 E88B02                  	call	ListDir			; list the directory
 14318 00001273 5B                      	pop	bx
 14319                                  
 14320                                  ;	Note we're ignoring errors returned here.
 14321                                  
 14322 00001274 89DF                    	mov	di,bx			; DI = ptr to child's name
 14323 00001276 B90D00                  	mov	cx,13			; CX = max name length w/ null
 14324 00001279 30C0                    	xor	al,al			; AL = zero byte to look for
 14325 0000127B F2AE                    	repne	scasb			; DI = ptr to next name pos'n in buf
 14326 0000127D 53                      	push	bx			; save ptr to child's name
 14327 0000127E 89FB                    	mov	bx,di			; BX = ptr to next name pos'n in buf
 14328 00001280 E8D7FF                  	call	lsNode			; recurse from new node
 14329 00001283 5B                      	pop	bx			; BX = ptr to child's name
 14330 00001284 9C                      	pushf				; save error condition
 14331                                  	
 14332                                  	;;shove	0
 14333                                  	;mov	ax,0
 14334 00001285 29C0                    	sub	ax,ax ; 0
 14335 00001287 50                      	push	ax
 14336                                  	;shove	".."
 14337 00001288 B82E2E                  	mov	ax,'..'  ; 2E2Eh
 14338 0000128B 50                      	push	ax
 14339 0000128C 89E2                    	mov	dx,sp			; DX = ptr to "..",0 on stack
 14340 0000128E E81704                  	call	ChangeDir		; return to parent directory
 14341 00001291 58                      	pop	ax			; restore stack
 14342 00001292 58                      	pop	ax
 14343                                  
 14344 00001293 9D                      	popf				; restore error condition from child
 14345                                  	;jc	short lsRet		; return error
 14346                                  	;jmp	short lsLoop		; look for more children
 14347                                  	; 16/02/2023
 14348 00001294 73C7                    	jnc	short lsLoop
 14349 00001296 C3                      	retn
 14350                                  lsErr:
 14351 00001297 E8620A                  	call	get_ext_error_number	; AX = extended error code
 14352                                  	;cmp	ax,2
 14353 0000129A 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 14354 0000129D 7406                    	je	short lsRet		; file not found, we're ok
 14355                                  	;cmp	ax,18
 14356 0000129F 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 14357 000012A2 7401                    	je	short lsRet		; no more files, we're ok
 14358 000012A4 F9                      	stc				; return other errors
 14359                                  lsRet:	
 14360 000012A5 C3                      	retn
 14361                                  
 14362                                  ; ---------------------------------------------------------------------------
 14363                                  
 14364                                  	;break	<DIR support routines>
 14365                                  
 14366                                  ;***	SUPPORT ROUTINES
 14367                                  
 14368                                  ; ----------------------
 14369                                  
 14370                                  ;***	CheckChild - check potential subdirectory name for FindNextChild
 14371                                  ;
 14372                                  ;	ENTRY	DirBuf contains DOS Find-buffer with potential child
 14373                                  ;		BX = ptr to last child's name
 14374                                  ;		BP = ptr to temp child's name
 14375                                  ;
 14376                                  ;	EXIT	nothing
 14377                                  ;
 14378                                  ;	USED	AX,CX,SI,DI
 14379                                  ;
 14380                                  ;	EFFECTS
 14381                                  ;
 14382                                  ;	  Filename pointed to by BP may be changed.
 14383                                  ;
 14384                                  ;	NOTES
 14385                                  ;
 14386                                  ;	  Potential filename replaces temp filename if:
 14387                                  ;	   it's a subdirectory file;
 14388                                  ;	   it doesn't start with a '.';
 14389                                  ;	   it's alphanumerically greater than last child's name;
 14390                                  ;	   and it's alphanumerically less than temp name.
 14391                                  
 14392                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14393                                  	; 07/06/2023
 14394                                  CheckChild:
 14395                                  	;test	DirBuf.find_buf_attr,ATTR_DIRECTORY
 14396 000012A6 F606[BA8B]10            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DIRECTORY ; 10h
 14397 000012AB 741D                    	jz	short ccRet	; not a subdirectory file- return
 14398                                  
 14399                                  	; 16/02/2023
 14400 000012AD BE[C38B]                	mov	si,DIRBUF+FIND_BUF.PNAME
 14401 000012B0 803C2E                  	cmp	byte [si],'.'
 14402                                  	;;cmp	DirBuf.find_buf_pname,'.'
 14403                                  	;cmp	byte [DIRBUF+FIND_BUF.PNAME],'.'
 14404 000012B3 7415                    	je	short ccRet	; starts with a dot- return
 14405                                  
 14406                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14407                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14408 000012B5 89DF                    	mov	di,bx
 14409 000012B7 E80504                  	call	CmpAscz		; compare candidate to last child's name
 14410 000012BA 760E                    	jna	short ccRet	; it's not above it- return
 14411                                  
 14412                                  
 14413                                  	; 07/06/2023
 14414                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14415                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14416                                  	; si = DIRBUF+FIND_BUF.PNAME
 14417 000012BC 89EF                    	mov	di,bp
 14418 000012BE E8FE03                  	call	CmpAscz		; compare candidate to temp name
 14419 000012C1 7307                    	jnb	short ccRet	; it's not below it- return
 14420                                  
 14421                                  ;	New kid is alright. Copy to temp.
 14422                                  
 14423                                  	; 07/06/2023
 14424                                  	;;mov	si,offset TRANGROUP:DirBuf+find_buf_pname
 14425                                  	;mov	si,DIRBUF+FIND_BUF.PNAME
 14426                                  	; si = DIRBUF+FIND_BUF.PNAME
 14427 000012C3 89EF                    	mov	di,bp
 14428 000012C5 B90D00                  	mov	cx,13
 14429 000012C8 F3A4                    	rep	movsb
 14430                                  ccRet:
 14431 000012CA C3                      	retn
 14432                                  
 14433                                  ; ---------------------------------------------------------------------------
 14434                                  
 14435                                  ;***	CmpEntry - compare one directory entry to another in sort order
 14436                                  ;
 14437                                  ;	Compare one directory entry against another according to
 14438                                  ;	the sort codes in DestBuf. One or more comparisons
 14439                                  ;	may be made of file name, extension, time/date, and
 14440                                  ;	size.  Comparisons may be made for upward or downward
 14441                                  ;	sort order.
 14442                                  ;
 14443                                  ;	ENTRY	ES:BX = ptr to entry to compare
 14444                                  ;		ES:BP = ptr to entry to be compared against
 14445                                  ;		DestBuf contains sort codes (see DestBuf)
 14446                                  ;		DS = TRANGROUP seg addr
 14447                                  ;
 14448                                  ;	EXIT	BX = unchanged
 14449                                  ;		BP = unchanged
 14450                                  ;		Condition flags set for same, above, or below
 14451                                  ;		 comparing BX entry against BP entry.
 14452                                  ;		 'Same, above, below' translate to 'same, after, before'.
 14453                                  ;
 14454                                  ;	USED:	AX,CX,DX,SI,DI
 14455                                  
 14456                                  	; 16/02/2023
 14457                                  CmpEntry:
 14458 000012CB BE[A88C]                	mov	si,DestBuf	; (DS:SI) = ptr to sort codes
 14459                                  ceLoop:
 14460 000012CE 31C0                    	xor	ax,ax		; AX = 0
 14461 000012D0 8A04                    	mov	al,[si]		; AL = sort code
 14462 000012D2 08C0                    	or	al,al
 14463 000012D4 741C                    	jz	short ceDone	; sort code is zero, we're done
 14464 000012D6 46                      	inc	si		; DS:SI = ptr to next sort code
 14465 000012D7 56                      	push	si		; save ptr to next sort code
 14466 000012D8 FEC8                    	dec	al
 14467 000012DA D0E0                    	shl	al,1
 14468                                  	;sal	al,1		; AX = index into cmp call table
 14469                                  				; CY set for downward sort order
 14470 000012DC 89C6                    	mov	si,ax		; SI = index into cmp call table
 14471 000012DE 2E8B84[F312]            	mov	ax,[cs:si+FieldCmps]
 14472                                  				; AX = addr of compare routine
 14473 000012E3 7204                    	jc	short ceDn	; downwards sort - go swap entries
 14474 000012E5 FFD0                    	call	ax 		; do upwards sort
 14475 000012E7 EB06                    	jmp	short ceNs
 14476                                  ceDn:
 14477 000012E9 87DD                    	xchg	bx,bp		; swap entry ptrs for downward sort order
 14478 000012EB FFD0                    	call	ax		; do sort
 14479 000012ED 87DD                    	xchg	bx,bp		; swap ptrs back
 14480                                  ceNs:
 14481 000012EF 5E                      	pop	si		; SI = ptr to next sort code
 14482 000012F0 74DC                    	je	short ceLoop	; compare showed no difference, keep trying
 14483                                  ceDone:
 14484                                  
 14485                                  ;	Get here either from unequal compare or sort code = 0.
 14486                                  ;	In the latter case, condition codes indicate equality,
 14487                                  ;	which is correct.
 14488                                  
 14489 000012F2 C3                      	retn
 14490                                  
 14491                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14492                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:1339h)
 14493                                  
 14494                                  FieldCmps:		; call table of entry comparisons
 14495 000012F3 [FD12]                  	dw	CmpName
 14496 000012F5 [0813]                  	dw	CmpExt
 14497 000012F7 [4613]                  	dw	CmpTime
 14498 000012F9 [6213]                  	dw	CmpSize
 14499 000012FB [6713]                  	dw	CmpType
 14500                                  
 14501                                  ; ---------------------------------------------------------------------------
 14502                                  
 14503                                  ;***	CmpName - compare file name of two entries
 14504                                  ;***	CmpExt - compare extension of two entries
 14505                                  ;
 14506                                  ;	ENTRY	ES:BX = ptr to one entry
 14507                                  ;		ES:BP = ptr to another entry
 14508                                  ;
 14509                                  ;	EXIT	BX = unchanged
 14510                                  ;		BP = unchanged
 14511                                  ;		Condition flags set for same, above, or below
 14512                                  ;		comparing BX entry to BP entry.
 14513                                  ;
 14514                                  ;	USED:	AX,CX,DX,SI,DI
 14515                                  
 14516                                  	; 16/02/2023
 14517                                  CmpName:
 14518 000012FD 89DE                    	mov	si,bx		; ES:SI = ptr to BX entry
 14519 000012FF 89EF                    	mov	di,bp		; ES:DI = ptr to BP entry
 14520                                  	;;add	si,filename	; ES:SI = ptr to BX name
 14521                                  	;add	si,1
 14522                                  	; 25/04/2023
 14523 00001301 46                      	inc	si
 14524                                  	;;add	di,filename	; ES:DI = ptr to BP name
 14525                                  	;add	di,1
 14526                                  	; 25/04/2023
 14527 00001302 47                      	inc	di
 14528                                  	;mov	cx,size filename
 14529                                  				; CX = length of name
 14530 00001303 B90800                  	mov	cx,8
 14531 00001306 EB0C                    	jmp	short CmpStr
 14532                                  
 14533                                  CmpExt:
 14534                                  	; 07/06/2023
 14535                                  	;mov	si,bx		; ES:SI = ptr to BX entry
 14536                                  	;mov	di,bp		; ES:DI = ptr to BP entry
 14537                                  	;;add	si,fileext	; ES:SI = ptr to BX extension
 14538                                  	;add	si,9
 14539                                  	;;add	di,fileext	; ES:DI = ptr to BP extension
 14540                                  	;add	di,9
 14541                                  	;
 14542 00001308 BE0900                  	mov	si,9
 14543 0000130B 89F7                    	mov	di,si ; mov di,9
 14544 0000130D 01DE                    	add	si,bx
 14545 0000130F 01EF                    	add	di,bp
 14546                                  	;
 14547                                  	;mov	cx,size fileext	; CX = length of extension field
 14548 00001311 B90300                  	mov	cx,3
 14549                                  
 14550                                  ;	Bugbug:	use symbol for subfunction code.
 14551                                  
 14552                                  CmpStr:	
 14553 00001314 803E[9A95]06            	cmp	byte [CountryPtrId],6
 14554 00001319 7527                    	jne	short cnNoCollTable
 14555                                  				; no collating table available
 14556                                  
 14557                                  ;*	Compare strings using collating table.
 14558                                  ;
 14559                                  ;	ES:SI = ptr to 1st string
 14560                                  ;	ES:DI = ptr to 2nd string
 14561                                  ;	CX = length
 14562                                  
 14563 0000131B 55                      	push	bp		; preserve BP
 14564 0000131C 53                      	push	bx		; preserve BX
 14565 0000131D 1E                      	push	ds		; preserve DS
 14566 0000131E C51E[9B95]              	lds	bx,[CountryPtr]	; DS:BX = ptr to collating table
 14567                                  	;assume	ds:NOTHING
 14568 00001322 8B2F                    	mov	bp,[bx]		; BP = size of collating table
 14569 00001324 43                      	inc	bx
 14570 00001325 43                      	inc	bx		; DS:BX = ptr to collating values
 14571                                  				; DS:[BX]-2 = size of table
 14572 00001326 31C0                    	xor	ax,ax		; AX = 0 for starters
 14573                                  
 14574                                  ;	Bugbug:	Investigate removing collating table length checks.
 14575                                  
 14576                                  cnNextChar:
 14577 00001328 268A05                  	mov	al,[es:di]	; AL = AX = char from 2nd string
 14578 0000132B 47                      	inc	di		; ES:DI = ptr to next char 2nd string
 14579 0000132C 39E8                    	cmp	ax,bp		; compare to collating table length
 14580 0000132E 7301                    	jae	short cn1 	; char not in table
 14581 00001330 D7                      	xlat				
 14582                                  cn1:				; AL = AX = collating value
 14583 00001331 89C2                    	mov	dx,ax		; DX = collating value from 2nd string
 14584                                  	;lods	byte ptr es:[si]
 14585 00001333 26AC                    	es	lodsb		; AL = AX = char from 1st string
 14586                                  				; ES:SI = ptr to next char 1st string
 14587 00001335 39E8                    	cmp	ax,bp		; compare to collating table length
 14588 00001337 7301                    	jae	short cn2	; char not in table
 14589 00001339 D7                      	xlat				
 14590                                  cn2:				; AL = AX = collating value
 14591 0000133A 39D0                    	cmp	ax,dx		; compare collating values
 14592 0000133C E1EA                    	loope	cnNextChar	; until unequal or no more left
 14593                                  
 14594 0000133E 1F                      	pop	ds		; restore DS
 14595                                  	;assume	ds:TRANGROUP
 14596 0000133F 5B                      	pop	bx		; restore BX
 14597 00001340 5D                      	pop	bp		; restore BP
 14598 00001341 C3                      	retn
 14599                                  
 14600                                  ;*	If no collating table is available, simply compare raw ASCII values.
 14601                                  ;	Don't we wish we could just do this all the time?  Sigh.
 14602                                  
 14603                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14604                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:138Dh)
 14605                                  cnNoCollTable:
 14606                                  	;repe	cmps byte ptr es:[si],[di]
 14607                                  				;db 0F3h,26h,0A6h,0C3h
 14608 00001342 F3                      	repe	; 0F3h
 14609 00001343 26                      	es	; 26h
 14610 00001344 A6                      	cmpsb	; 0A6h
 14611 00001345 C3                      	retn	; 0C3h
 14612                                  
 14613                                  ; ---------------------------------------------------------------------------
 14614                                  
 14615                                  ;***	CmpTime - compare entries by date/time
 14616                                  ;
 14617                                  ;	ENTRY	ES:BX = ptr to one entry
 14618                                  ;		ES:BP = ptr to another entry
 14619                                  ;
 14620                                  ;	EXIT	BX = unchanged
 14621                                  ;		BP = unchanged
 14622                                  ;		Condition flags set for same, above, or below
 14623                                  ;		 comparing BX entry to BP entry.
 14624                                  ;
 14625                                  ;	USED:	CX,SI,DI
 14626                                  ;
 14627                                  ;	NOTE	Filetime and filedate fields in our private entry
 14628                                  ;		structure must be adjacent and in that order.
 14629                                  
 14630                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14631                                  	; 07/06/2023
 14632                                  CmpTime:
 14633 00001346 89DE                    	mov	si,bx
 14634 00001348 89EF                    	mov	di,bp
 14635                                  	;add	si,filedate + size filedate - 1
 14636 0000134A 83C610                  	add	si,16 ; 15+2-1
 14637                                  	;add	di,filedate + size filedate - 1
 14638 0000134D 83C710                  	add	di,16 ; 15+2-1
 14639                                  	; 07/06/2023
 14640 00001350 BE1000                  	mov	si,16
 14641                                  CmpST2:		; 07/06/2023
 14642 00001353 89F7                    	mov	di,si	; mov di,16
 14643 00001355 01DE                    	add	si,bx
 14644 00001357 01EF                    	add	di,bp
 14645                                  
 14646                                  	;mov	cx,size filetime + size filedate
 14647 00001359 B90400                  	mov	cx,4 ; 2+2
 14648 0000135C FD                      	std
 14649                                  	;repe	cmps byte ptr es:[si],[di]
 14650                                  				;db 0F3h,26h,0A6h, 0FCh,0C3h
 14651 0000135D F3                      	repe	; 0F3h
 14652 0000135E 26                      	es	; 26h
 14653 0000135F A6                      	cmpsb	; 0A6h
 14654                                  	
 14655 00001360 FC                      	cld	; 0FCh
 14656 00001361 C3                      	retn	; 0C3h
 14657                                  
 14658                                  ; ---------------------------------------------------------------------------
 14659                                  
 14660                                  ;***	CmpSize - compare entries by size
 14661                                  ;
 14662                                  ;	ENTRY	ES:BX = ptr to one entry
 14663                                  ;		ES:BP = ptr to another entry
 14664                                  ;
 14665                                  ;	EXIT	BX = unchanged
 14666                                  ;		BP = unchanged
 14667                                  ;		Condition flags set for same, above, or below
 14668                                  ;		 comparing BX entry to BP entry.
 14669                                  ;
 14670                                  ;	USED:	CX,SI,DI
 14671                                  
 14672                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14673                                  	; 07/06/2023
 14674                                  CmpSize:
 14675                                  	;mov	si,bx
 14676                                  	;mov	di,bp
 14677                                  	;;add	si,filesize + size filesize - 1
 14678                                  	;add	si,20  ; 17+4-1
 14679                                  	;;add	di,filesize + size filesize - 1
 14680                                  	;add	di,20  ; 17+4-1
 14681                                  	; 07/06/2023
 14682 00001362 BE1400                  	mov	si,20
 14683                                  	;;;
 14684 00001365 EBEC                    	jmp	short CmpST2 ; 07/06/2023
 14685                                  	;;;
 14686                                  ;CmpST2:
 14687                                  ;	mov	di,si	; mov di,20
 14688                                  ;	add	si,bx
 14689                                  ;	add	di,bp
 14690                                  ;
 14691                                  ;	;mov	cx,size filesize
 14692                                  ;	mov	cx,4
 14693                                  ;	std
 14694                                  ;	;repe	cmps byte ptr es:[si],[di]
 14695                                  ;				;db 0F3h,26h,0A6h
 14696                                  ;	repe	; 0F3h
 14697                                  ;	es	; 26h
 14698                                  ;	cmpsb	; 0A6h
 14699                                  ;
 14700                                  ;	cld
 14701                                  ;	retn
 14702                                  
 14703                                  ; ---------------------------------------------------------------------------
 14704                                  
 14705                                  ;***	CmpType - compare entries by file type (subdirectory or not)
 14706                                  ;
 14707                                  ;	ENTRY	ES:BX = ptr to one entry
 14708                                  ;		ES:BP = ptr to another entry
 14709                                  ;
 14710                                  ;	EXIT	BX = unchanged
 14711                                  ;		BP = unchanged
 14712                                  ;		Condition flags set for same, above, or below
 14713                                  ;		 comparing BX entry to BP entry.
 14714                                  ;
 14715                                  ;	USED:	AX
 14716                                  
 14717                                  	; 16/02/2023 - Retro DOS v4.0 COMMAND.COM
 14718                                  CmpType:
 14719                                  	;mov	al,es:[bx].fileattr
 14720 00001367 268A470C                	mov	al,[es:bx+12]
 14721                                  	;mov	ah,es:[bp].fileattr
 14722 0000136B 268A660C                	mov	ah,[es:bp+12]
 14723                                  	;and	ax,(ATTR_DIRECTORY shl 8) + ATTR_DIRECTORY
 14724                                  	;and	ax,1010h
 14725 0000136F 251010                  	and	ax,(ATTR_DIRECTORY<<8)+ATTR_DIRECTORY
 14726 00001372 38C4                    	cmp	ah,al
 14727 00001374 C3                      	retn
 14728                                  
 14729                                  ; ---------------------------------------------------------------------------
 14730                                  
 14731                                  ;***	DefaultAttr - set default attribute conditions
 14732                                  ;
 14733                                  ;	ENTRY	nothing
 14734                                  ;
 14735                                  ;	EXIT	CY clear
 14736                                  ;
 14737                                  ;	USED
 14738                                  ;
 14739                                  ;	EFFECTS
 14740                                  ;
 14741                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 14742                                  
 14743                                  	; 16/02/2023
 14744                                  DefaultAttr:
 14745                                  	;mov	byte [AttrSpecified],6
 14746 00001375 C606[FF8B]06            	mov	byte [AttrSpecified],ATTR_HIDDEN+ATTR_SYSTEM
 14747                                  					; specify H and S
 14748 0000137A C606[008C]00            	mov	byte [AttrSelect],0	; H and S must be off
 14749 0000137F F8                      	clc				; return success
 14750                                  dtRet:	; 18/02/2023
 14751 00001380 C3                      	retn
 14752                                  
 14753                                  ; ---------------------------------------------------------------------------
 14754                                  
 14755                                  ;***	DisplayTotals - display grand total stats
 14756                                  ;
 14757                                  ;	If we searched subdirectories, display the total # files found
 14758                                  ;	 and total size of files found.
 14759                                  ;	Display disk space remaining.
 14760                                  ;
 14761                                  ;	ENTRY	FileCntTotal, FileSizTotal contain correct values
 14762                                  ;		Bits contains setting of /s
 14763                                  ;		FCB contains drive #
 14764                                  ;
 14765                                  ;	EXIT	nothing
 14766                                  ;
 14767                                  ;	USES	AX,DX
 14768                                  ;		FileSiz
 14769                                  
 14770                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14771                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:13D1h
 14772                                  
 14773                                  DisplayTotals:
 14774                                  	;;;test	Bits,mask subd
 14775                                  	;;test	word [_Bits],4
 14776                                  	;test	byte [_Bits],4
 14777 00001381 F606[F78B]04            	test	byte [_Bits],mask.subd
 14778 00001386 741D                    	jz	short dtFree		; no subdirectories- do bytes free
 14779                                  
 14780 00001388 E83F12                  	call	CRLF2			; start on new line
 14781 0000138B E8C503                  	call	UseLine
 14782                                  
 14783 0000138E BA[6D81]                	mov	dx,total_ptr
 14784 00001391 E86F3A                  	call	std_printf		; "Total:",cr,lf
 14785 00001394 E8BC03                  	call	UseLine
 14786                                  
 14787 00001397 A1[CE8A]                	mov	ax,[FileCntTotal]	; AX = # files found mod 64K
 14788 0000139A BE[D28A]                	mov	si,FileSizTotal
 14789 0000139D BF[CA8A]                	mov	di,FileSiz
 14790 000013A0 A5                      	movsw
 14791 000013A1 A5                      	movsw				; move total size to size variable
 14792 000013A2 E87705                  	call	DisplayCntSiz		; display file count & size &
 14793                                  dtFree: 				;   (maybe) compression ratio
 14794 000013A5 B436                    	mov	ah,36h
 14795                                  	;mov	ah,GET_DRIVE_FREESPACE	; AH = DOS Get Free Space function
 14796 000013A7 8A165C00                	mov	dl,[FCB] ; [5Ch]	; DL = drive#
 14797 000013AB CD21                    	int	21h			; call DOS
 14798 000013AD 83F8FF                  	cmp	ax,-1			; check 'invalid drive' return code
 14799 000013B0 74CE                    	jz	short dtRet		; can't get drive space - return
 14800 000013B2 F7E1                    	mul	cx
 14801 000013B4 F7E3                    	mul	bx
 14802 000013B6 A3[938C]                	mov	[Bytes_Free],ax
 14803 000013B9 8916[958C]              	mov	[Bytes_Free+2],dx
 14804 000013BD BA[7F7F]                	mov	dx,bytmes_ptr
 14805 000013C0 E8403A                  	call	std_printf		; "nnn bytes free",cr,lf
 14806                                  	;call	UseLine
 14807                                  ;dtRet:
 14808                                  	;retn
 14809                                  	; 18/02/2023
 14810 000013C3 E98D03                  	jmp	UseLine
 14811                                  
 14812                                  ; ---------------------------------------------------------------------------
 14813                                  
 14814                                  ;***	FileIsDevice - see if file looks like a device
 14815                                  ;
 14816                                  ;	ENTRY	PathPos = ptr to pathname
 14817                                  ;		PathCnt = length of pathname w/o terminating char
 14818                                  ;		DirBuf is DOS DTA
 14819                                  ;
 14820                                  ;	EXIT	ZR = set if file looks like a device
 14821                                  ;
 14822                                  ;	USED	AX,BX,CX,DX,DI
 14823                                  ;
 14824                                  ;	EFFECTS
 14825                                  ;
 14826                                  ;	  DTA buffer holds results of Find First function
 14827                                  ;
 14828                                  ;	NOTES
 14829                                  ;
 14830                                  ;	  We try to flag devices in two ways. First, we try
 14831                                  ;	  the DOS Find First function. It returns attribute bit 6
 14832                                  ;	  set on a successful find if it identifies a device name.
 14833                                  ;	  Unfortunately, it returns 'path not found' for a device
 14834                                  ;	  name terminated with colon, such as "CON:". So, we look
 14835                                  ;	  for any colon in the pathname after the 2nd character,
 14836                                  ;	  and flag the pathname as a device if we find one.
 14837                                  
 14838                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14839                                  FileIsDevice:
 14840 000013C6 8B16[FB8B]              	mov	dx,[PathPos]	 ; DX = ptr to pathname
 14841                                  
 14842 000013CA 89D7                    	mov	di,dx
 14843 000013CC 033E[F98B]              	add	di,[PathCnt]	 ; DI = ptr to byte after pathname
 14844 000013D0 30DB                    	xor	bl,bl		 ; BL = NUL to terminate pathname with
 14845 000013D2 861D                    	xchg	bl,[di] 	 ; BL = saved pathname terminating char
 14846                                  
 14847 000013D4 31C9                    	xor	cx,cx		 ; CX = attribute mask (normal search)
 14848 000013D6 B44E                    	mov	ah,4Eh
 14849                                  	;mov	ah,Find_First	 ; AH = DOS Find First function code
 14850 000013D8 CD21                    	int	21h	 	 ; call DOS
 14851 000013DA 861D                    	xchg	bl,[di]		 ; restore pathname terminating char
 14852 000013DC 720A                    	jc	short piCol	 ; didn't find a dir entry, check for colon
 14853                                  
 14854                                  ;	Found a dir entry, see if Find First thinks it's a device.
 14855                                  
 14856                                  	;test	byte [DIRBUF+21],40h
 14857 000013DE F606[BA8B]40            	test	byte [DIRBUF+FIND_BUF.ATTR],ATTR_DEVICE
 14858 000013E3 7403                    	jz	short piCol	 ; device attribute not set, look for colon
 14859 000013E5 31C9                    	xor	cx,cx		 ; it's a device, return ZR flag
 14860                                  	;jmp	short piRet
 14861                                  	; 25/04/2023
 14862                                  piRet:
 14863 000013E7 C3                      	retn
 14864                                  
 14865                                  ;	Device attribute not returned by Find First function. But
 14866                                  ;	let's check for a colon anywhere in the pathname after the
 14867                                  ;	second byte.
 14868                                  ;
 14869                                  ;	DI = ptr to byte after pathname
 14870                                  
 14871                                  piCol:
 14872 000013E8 4F                      	dec	di		 ; DI = ptr to last char in pathname
 14873 000013E9 B03A                    	mov	al,':'
 14874                                  	;mov	al,COLON_CHAR	 ; AL = colon char to search for
 14875 000013EB 8B0E[F98B]              	mov	cx,[PathCnt]	 ; CX = # chars to scan
 14876 000013EF 49                      	dec	cx
 14877 000013F0 49                      	dec	cx		 ; ignore 1st two chars of pathname
 14878 000013F1 09C9                    	or	cx,cx
 14879 000013F3 78F2                    	js	short piRet	 ; if < 2 chars in pathname, just return
 14880 000013F5 09FF                    	or	di,di		 ; clear ZR in case CX = 0
 14881 000013F7 FD                      	std			 ; scan downward
 14882 000013F8 F2AE                    	repne	scasb
 14883 000013FA FC                      	cld			 ; restore default upward direction
 14884                                  
 14885                                  ;	After scanning, the ZR flag is set to indicate presence of a colon.
 14886                                  ;piRet:
 14887 000013FB C3                      	retn
 14888                                  
 14889                                  ;FileIsDevice endp
 14890                                  
 14891                                  ; ---------------------------------------------------------------------------
 14892                                  
 14893                                  ;***	FindFirst - find first directory entry to display
 14894                                  ;***	FindNext - find next directory entry to display
 14895                                  ;
 14896                                  ;	ENTRY	Bits<inmem> = set if entries are loaded in TPA
 14897                                  ;		AttrSpecified, AttrSelect are set
 14898                                  ;
 14899                                  ;	EXIT	CY = clear if successful
 14900                                  ;		BX = offset in TPA buffer of directory entry found
 14901                                  ;
 14902                                  ;		If unsuccessful,
 14903                                  ;		CY = set
 14904                                  ;		AX = DOS error code
 14905                                  ;		DOS Get Extended Error call will get error code
 14906                                  ;
 14907                                  ;		NOTE: if entries were loaded into TPA, AX contains
 14908                                  ;		ERROR_NO_MORE_FILES when no more entries are available,
 14909                                  ;		but DOS Get Extended Error call WON'T return the correct
 14910                                  ;		error. That's ok, because we'll see the value in AX
 14911                                  ;		and recognize it as a non-error condition.
 14912                                  ;
 14913                                  ;	USED	AX,CX,DX,SI,DI
 14914                                  ;
 14915                                  ;	EFFECTS
 14916                                  ;
 14917                                  ;	  Entries in memory may be marked as output.
 14918                                  ;	  If not sorted, entry is loaded at TPA.
 14919                                  ;
 14920                                  ;	NOTES
 14921                                  ;
 14922                                  ;	  If we don't find a qualifying file, we return after the final
 14923                                  ;	   DOS Find File call. A DOS Get Extended Error call will then
 14924                                  ;	   indicate an appropriate condition.
 14925                                  
 14926                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14927                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 14928                                  	
 14929                                  FindFirst:
 14930                                  	;mov	ax,offset TRANGROUP:GetFirst
 14931 000013FC B8[D314]                	mov	ax,GetFirst
 14932 000013FF EB03                    	jmp	short ffFindEntry
 14933                                  
 14934                                  	; 18/02/2023
 14935                                  FindNext:
 14936                                  	;mov	ax,offset TRANGROUP:GetNext
 14937 00001401 B8[E114]                	mov	ax,GetNext
 14938                                  
 14939                                  ;	AX = address of correct disk get routine to use.
 14940                                  
 14941                                  ffFindEntry:
 14942 00001404 06                      	push	es			; save TRANGROUP seg addr
 14943                                  	;;;test	Bits,mask inmem
 14944                                  	;;test	word [_Bits],20h
 14945                                  	;test	byte [_Bits],20h
 14946 00001405 F606[F78B]20            	test	byte [_Bits],mask.inmem
 14947 0000140A 7405                    	jz	short ffDisk		; entries not in memory, search disk
 14948                                  
 14949                                  ;	Entries are loaded in memory to sort out. Find the first one.
 14950                                  ;	There will always be one, or LoadEntries would've failed.
 14951                                  
 14952 0000140C E81A00                  	call	FindInMem		; find first entry in TPA
 14953 0000140F EB16                    	jmp	short ffRet		; return what TPA search returns
 14954                                  
 14955                                  ;	Get entry from disk.
 14956                                  
 14957                                  ffDisk:
 14958 00001411 FFD0                    	call	ax			; get entry from disk
 14959 00001413 720E                    	jc	short ffGetErr		; get & return error
 14960 00001415 8E06[9E8A]              	mov	es,[TPA]		; ES = seg addr of TPA
 14961 00001419 31FF                    	xor	di,di			; ES:DI = ptr to TPA
 14962 0000141B 89FB                    	mov	bx,di			; BX = offset of entry in TPA
 14963 0000141D E85701                  	call	LoadEntry		; load entry to TPA
 14964 00001420 F8                      	clc				; return success
 14965 00001421 EB04                    	jmp	short ffRet
 14966                                  
 14967                                  ffGetErr:
 14968 00001423 E8D608                  	call	 get_ext_error_number	; AX = DOS error code
 14969 00001426 F9                      	stc
 14970                                  ffRet:
 14971 00001427 07                      	pop	es			; ES = TRANGROUP seg addr again
 14972 00001428 C3                      	retn
 14973                                  
 14974                                  ; ---------------------------------------------------------------------------
 14975                                  
 14976                                  ;***	FindInMem - find next directory entry in TPA buffer
 14977                                  ;
 14978                                  ;	ENTRY	TPA is loaded (see LoadEntries)
 14979                                  ;
 14980                                  ;	EXIT	BX = offset in TPA of entry found
 14981                                  ;
 14982                                  ;		If no more files,
 14983                                  ;		CY = set
 14984                                  ;		AX = DOS 'no more files' error code
 14985                                  ;
 14986                                  ;	USED	AX,BX,CX,DX,SI,DI,BP,ES
 14987                                  ;
 14988                                  ;	EFFECTS
 14989                                  ;
 14990                                  ;	  Entry found is flagged as 'used' (see EntryStruc).
 14991                                  
 14992                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 14993                                  FindInMem:
 14994 00001429 8E06[9E8A]              	mov	es,[TPA]		; ES = TPA seg addr
 14995 0000142D 31DB                    	xor	bx,bx			; ES:BX = ptr to 1st entry in TPA
 14996 0000142F FC                      	cld				; make sure default string direction is up
 14997                                  	
 14998 00001430 E86D00                  	call	FindOneInMem		; locate an entry
 14999 00001433 720E                    	jc	short fiNoMore		; none left, set up 'no more files' error
 15000                                  
 15001                                  ;	BX = ptr to entry in TPA
 15002                                  
 15003                                  fiBest:
 15004 00001435 89DD                    	mov	bp,bx			; BP = ptr to best entry so far
 15005                                  fiNext:
 15006 00001437 E87300                  	call	FindNextInMem		; locate next entry
 15007 0000143A 720C                    	jc	short fiFound		; no more, best entry so far wins
 15008                                  
 15009                                  ;	BX = ptr to next entry
 15010                                  
 15011 0000143C E88CFE                  	call	CmpEntry		; compare it to best found so far (BP)
 15012 0000143F 73F6                    	jnb	short fiNext		; it's not better, go look at next one
 15013 00001441 EBF2                    	jmp	short fiBest		; it's better, go mark it as best so far
 15014                                  
 15015                                  fiNoMore:
 15016                                  
 15017                                  ;	No more entries available in TPA. Set up 'no more files' error.
 15018                                  
 15019                                  	;mov	ax,18
 15020 00001443 B81200                  	mov	ax,ERROR_NO_MORE_FILES	; AX = 'no more files' error code
 15021 00001446 F9                      	stc				; return error
 15022                                  	;jmp	short fiRet
 15023                                  	; 18/02/2023
 15024 00001447 C3                      	retn
 15025                                  
 15026                                  fiFound:
 15027 00001448 89EB                    	mov	bx,bp			; BX = ptr to best entry found
 15028 0000144A 26C60701                	mov	byte [es:bx],1		; mark entry 'used'
 15029 0000144E F8                      	clc				; return success
 15030                                  fiRet:
 15031 0000144F C3                      	retn
 15032                                  
 15033                                  ; ---------------------------------------------------------------------------
 15034                                  
 15035                                  ;***	FindNextChild - find next subdirectory in current directory
 15036                                  ;
 15037                                  ;	ENTRY	BX = ptr to last child found, ASCIIZ filename
 15038                                  ;		DirBuf is established DTA
 15039                                  ;
 15040                                  ;	EXIT	BX = ptr (same addr) to next child found, ASCIIZ filename
 15041                                  ;
 15042                                  ;		If failure,
 15043                                  ;		CY = set
 15044                                  ;		DOS Get Extended Error call will get error
 15045                                  ;
 15046                                  ;	USED	AX,CX,DX,SI,DI,BP
 15047                                  ;
 15048                                  ;	EFFECTS
 15049                                  ;
 15050                                  ;	  DirBuf is used for find first/next calls.
 15051                                  ;
 15052                                  ;	NOTES
 15053                                  ;
 15054                                  ;	  We keep on checking files until DOS returns an error. If
 15055                                  ;	  the error is 'no more files' and the temp filename is not
 15056                                  ;	  the initial high tag, copy the temp to the child's name spot
 15057                                  ;	  and return success. Otherwise, send the error back to caller.
 15058                                  ;
 15059                                  ;	  This routine depends on DS,ES,CS, & SS all being equal.
 15060                                  
 15061                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15062                                  FindNextChild:
 15063 00001450 83EC0C                  	sub	sp,12			; make temp filename buf on stack
 15064                                  	;shove	00FFh			; temp filename = high tag
 15065 00001453 B8FF00                  	mov	ax,0FFh
 15066 00001456 50                      	push	ax
 15067 00001457 89E5                    	mov	bp,sp			; BP = ptr to temp filename buf
 15068                                  	;shove	"*"	
 15069 00001459 B02A                    	mov	al,'*'  ; ax = 002Ah
 15070 0000145B 50                      	push	ax
 15071                                  	;;shove	".*" 
 15072                                  	;mov	ax,"*."
 15073                                  	;mov	ax,2E2Ah
 15074 0000145C B42E                    	mov	ah,'.'
 15075 0000145E 50                      	push	ax
 15076 0000145F E8FA04                  	call	GetDriveLtr		; AX = "d:"
 15077 00001462 50                      	push	ax
 15078 00001463 89E2                    	mov	dx,sp			; DX = ptr to "d:*.*",0 on stack
 15079                                  
 15080                                  ;	See that the stack is restored properly at the end of this proc.
 15081                                  
 15082                                  	;mov	cx,10h
 15083 00001465 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15084 00001468 B44E                    	mov	ah,4Eh
 15085                                  	;mov	ah,Find_First
 15086 0000146A CD21                    	int	21h			; DOS- Find First matching file
 15087 0000146C 722C                    	jc	short fcRet		; return error
 15088                                  
 15089 0000146E E835FE                  	call	CheckChild		; check child against last, temp
 15090                                  fcNext:	
 15091                                  	;mov	cx,10h
 15092 00001471 B91000                  	mov	cx,ATTR_DIRECTORY	; CX = attributes for file search
 15093 00001474 B44F                    	mov	ah,4Fh
 15094                                  	;mov	ah,Find_Next
 15095 00001476 CD21                    	int	21h			; DOS- Find Next matching file
 15096 00001478 7205                    	jc	short fcErr		; examine error
 15097                                  
 15098 0000147A E829FE                  	call	CheckChild		; check child against last, temp
 15099 0000147D EBF2                    	jmp	short fcNext		; go find another child
 15100                                  
 15101                                  fcErr:
 15102 0000147F E87A08                  	call	get_ext_error_number	; AX = extended error code
 15103                                  	;cmp	ax,18
 15104 00001482 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	; no more files?
 15105 00001485 7512                    	jne	short fcNope		; some other error- return it
 15106                                  
 15107                                  ;	We ran out of files. See if we qualified at least one.
 15108                                  
 15109 00001487 807E00FF                	cmp	byte [bp],0FFh
 15110 0000148B 740C                    	je	short fcNope		; temp filename is unused- no child
 15111                                  
 15112                                  ;	Move temp filename to child name position.
 15113                                  
 15114 0000148D 89EE                    	mov	si,bp			; SI = ptr to temp filename
 15115 0000148F 89DF                    	mov	di,bx			; DI = ptr to child name pos'n
 15116                                  fcMove:
 15117 00001491 AC                      	lodsb				; AL = next byte of filename
 15118 00001492 AA                      	stosb				; store byte
 15119 00001493 08C0                    	or	al,al
 15120 00001495 7403                    	jz	short fcRet		; byte was zero, return success (CY clear)
 15121 00001497 EBF8                    	jmp	short fcMove		; go move another byte
 15122                                  fcNope:
 15123 00001499 F9                      	stc				; return error
 15124                                  fcRet:
 15125 0000149A 9F                      	lahf
 15126 0000149B 83C414                  	add	sp,20			; restore stack
 15127 0000149E 9E                      	sahf
 15128 0000149F C3                      	retn
 15129                                  
 15130                                  ; ---------------------------------------------------------------------------
 15131                                  
 15132                                  ;***	FindOneInMem - find the first available entry in TPA
 15133                                  ;***	FindNextInMem - find the next available entry in TPA
 15134                                  ;
 15135                                  ;	ENTRY	ES = TPA seg addr
 15136                                  ;		BX = ptr to entry in TPA
 15137                                  ;
 15138                                  ;	EXIT	BX = ptr to entry found
 15139                                  ;		CY = set if no more entries available in TPA
 15140                                  ;
 15141                                  ;	USED	AL
 15142                                  
 15143                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15144                                  FindOneInMem:
 15145 000014A0 268A07                  	mov	al,[es:bx]		; examine 'used' byte of starting entry
 15146 000014A3 3C01                    	cmp	al,1
 15147 000014A5 7406                    	je	short FindNextInMem	; entry has already been used
 15148 000014A7 3CFF                    	cmp	al,0FFh
 15149 000014A9 7407                    	je	short foNoMore		; 0FFh, we're at the end of the list
 15150                                  
 15151                                  ;	BX = ptr to entry that hasn't been output yet.
 15152                                  
 15153 000014AB F8                      	clc				; return success
 15154 000014AC C3                      	retn
 15155                                  
 15156                                  FindNextInMem:
 15157 000014AD 83C315                  	add	bx,21
 15158                                  	;add	bx,size EntryStruc	; BX = ptr to next entry
 15159 000014B0 EBEE                    	jmp	short FindOneInMem	; go look at it
 15160                                  foNoMore:
 15161 000014B2 F9                      	stc				; ran out of entries, return failure
 15162 000014B3 C3                      	retn
 15163                                  
 15164                                  ; ---------------------------------------------------------------------------
 15165                                  
 15166                                  ;***	GetEnvValue - get value of our environment variable
 15167                                  ;
 15168                                  ;	ENTRY	DS, ES = TRANGROUP seg addr
 15169                                  ;
 15170                                  ;	EXIT	CY = set if environment variable not in environment
 15171                                  ;
 15172                                  ;		Otherwise:
 15173                                  ;		SI = ptr to environment variable asciiz value in TRANGROUP
 15174                                  ;
 15175                                  ;	USED	AX,BX,CX,DX,DI
 15176                                  ;		(We assume the (almost) worst, since we don't know about
 15177                                  ;		Find_Name_In_Environment.)
 15178                                  ;
 15179                                  ;	EFFECTS
 15180                                  ;
 15181                                  ;	  ScanBuf is loaded with value text
 15182                                  
 15183                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15184                                  GetEnvValue:
 15185 000014B4 06                      	push	es				; save ES
 15186                                  	;mov	si,offset TRANGROUP:DirEnvVar	; DS:SI = ptr to variable name
 15187 000014B5 BE[B581]                	mov	si,DirEnvVar
 15188                                  	;invoke	Find_Name_In_Environment
 15189 000014B8 E8530E                  	call	find_name_in_environment
 15190 000014BB 7214                    	jc	short geRet			; name not found in environment
 15191                                  
 15192                                  ;	ES:DI = ptr to value of environment variable
 15193                                  ;	We're assuming DS, CS, and SS are unchanged.
 15194                                  
 15195 000014BD 1E                      	push	ds
 15196 000014BE 06                      	push	es
 15197 000014BF 1F                      	pop	ds
 15198 000014C0 07                      	pop	es
 15199                                  
 15200                                  	;assume	ds:nothing
 15201                                  
 15202                                  ;	DS = seg addr of environment variable value (in environment segment)
 15203                                  ;	ES = TRANGROUP seg addr
 15204                                  
 15205 000014C1 89FE                    	mov	si,di				; DS:SI = ptr to value string
 15206                                  	;mov	di,offset TRANGROUP:ScanBuf	; ES:DI = ptr to dest buffer
 15207 000014C3 BF[658D]                	mov	di,ScanBuf
 15208                                  geLoop:
 15209                                  ;@@:	
 15210 000014C6 AC                      	lodsb
 15211 000014C7 08C0                    	or	al,al
 15212 000014C9 AA                      	stosb
 15213                                  	;loopnz	@B		; move the string, including trailing null
 15214 000014CA E0FA                    	loopnz	geLoop
 15215                                  
 15216 000014CC 06                      	push	es
 15217 000014CD 1F                      	pop	ds		; DS = TRANGROUP seg addr again
 15218                                  	;assume	ds:TRANGROUP
 15219                                  
 15220                                  	;mov	si,offset TRANGROUP:ScanBuf	; SI = ptr to var value
 15221 000014CE BE[658D]                	mov	si,ScanBuf
 15222                                  geRet:
 15223 000014D1 07                      	pop	es				; restore ES
 15224 000014D2 C3                      	retn
 15225                                  
 15226                                  ; ---------------------------------------------------------------------------
 15227                                  
 15228                                  ;***	GetFirst - get first directory entry from disk
 15229                                  ;
 15230                                  ;	ENTRY	DOS DTA established at DirBuf
 15231                                  ;		FCB contains drive # and filename
 15232                                  ;		Current directory (on selected drive) is the one to search
 15233                                  ;		AttrSpecified & AttrSelect masks set
 15234                                  ;
 15235                                  ;	EXIT	CY = clear if success
 15236                                  ;		DirBuf contains extended FCB for file found
 15237                                  ;
 15238                                  ;		If unsuccessful,
 15239                                  ;		CY = set
 15240                                  ;		Ready for DOS Get Extended Error call
 15241                                  ;
 15242                                  ;	USED	AX,DX
 15243                                  ;
 15244                                  ;	EFFECTS
 15245                                  ;
 15246                                  ;	  FCB-7 = 0FFh to mark extended FCB
 15247                                  ;	  FCB-1 = attribute mask to find all files
 15248                                  ;	  These fields should remain unmodified for GetNext calls.
 15249                                  ;
 15250                                  ;***	GetNext - get next directory entry from disk
 15251                                  ;
 15252                                  ;	ENTRY	As for GetFirst, plus
 15253                                  ;		FCB-7 set up as extended FCB w/ find-all attribute byte
 15254                                  ;
 15255                                  ;	EXIT	As for GetFirst
 15256                                  ;
 15257                                  ;	USED	AX,DX
 15258                                  
 15259                                  	; 18/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15260                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:144Fh
 15261                                  GetFirst:
 15262                                  	;mov	byte [55h],0FFh	; -1
 15263 000014D3 C6065500FF              	mov	byte [FCB-7],0FFh	; signal extended FCB
 15264                                  	;mov	byte [5Bh],16h
 15265 000014D8 C6065B0016              	mov	byte [FCB-1],ATTR_ALL ; 16h
 15266                                  					; find any file
 15267                                  	; 07/06/2023
 15268                                  	;mov	dx,FCB-7 ; 55h		; DX = ptr to extended FCB
 15269 000014DD B411                    	mov	ah,11h
 15270                                  	;mov	ah,Dir_Search_First	; AH = DOS Find First function code
 15271                                  	; 07/06/2023
 15272                                  	;int	21h			; call DOS
 15273                                  	;shl	al,1			; CY = set if error
 15274                                  	;jc	short gfRet		; return error
 15275                                  	;jmp	short gfFound		; go look at attr's
 15276                                  	; 07/06/2023
 15277 000014DF EB02                    	jmp	short GetFrstNxt
 15278                                  GetNext:
 15279                                  	; 07/06/2023
 15280                                  	;;mov	dx,55h
 15281                                  	;mov	dx,FCB-7		; DX = ptr to extended FCB
 15282 000014E1 B412                    	mov	ah,12h
 15283                                  	;mov	ah,Dir_Search_Next	; AH = DOS Find Next function code
 15284                                  GetFrstNxt:
 15285                                  	; 07/06/2023
 15286 000014E3 BA5500                  	mov	dx,FCB-7 ; mov dx,55h
 15287                                  	;
 15288 000014E6 CD21                    	int	21h			; call DOS
 15289 000014E8 D0E0                    	shl	al,1			; CY = set if error
 15290 000014EA 7211                    	jc	short gfRet		; return error
 15291                                  
 15292                                  ;*	Found an entry. Check attributes.
 15293                                  gfFound:
 15294                                  	;;mov	al,[DirBuf+8].dir_attr	; AL = file attributes
 15295                                  	;mov	al,[DIRBUF+19]
 15296 000014EC A0[B88B]                	mov	al,[DIRBUF+8+DIR_ENTRY.DIR_ATTR]
 15297 000014EF 8A26[FF8B]              	mov	ah,[AttrSpecified]	; AH = mask of pertinent attr's
 15298 000014F3 20E0                    	and	al,ah			; AL = pertinent attr's of file
 15299 000014F5 2226[008C]              	and	ah,[AttrSelect]		; AH = attr settings to match
 15300 000014F9 38E0                    	cmp	al,ah
 15301 000014FB 75E4                    	jne	short GetNext		; attr's don't match, look for another
 15302                                  gfRet:
 15303 000014FD C3                      	retn
 15304                                  
 15305                                  ; ---------------------------------------------------------------------------
 15306                                  
 15307                                  ;***	ListDir - search for and list files in the current directory
 15308                                  ;
 15309                                  ;	List header, files, and trailer for current directory on selected
 15310                                  ;	drive. Header & trailer are listed if at least one file is found.
 15311                                  ;	If no qualifying files are found, no display output occurs.
 15312                                  ;
 15313                                  ;	ENTRY	Current directory (on selected drive) is the one to be listed
 15314                                  ;		FCB contains selected drive # and filename spec
 15315                                  ;		Option bits, attribute masks, and sort codes set up
 15316                                  ;
 15317                                  ;	EXIT	CY = clear if no error
 15318                                  ;		FileCnt = # files found & displayed
 15319                                  ;
 15320                                  ;		If error,
 15321                                  ;		CY = set
 15322                                  ;		Ready for DOS Get Extended Error call
 15323                                  ;
 15324                                  ;	USED	AX,BX,CX,DX,SI,DI,BP
 15325                                  ;		FileSiz
 15326                                  ;
 15327                                  ;	EFFECTS
 15328                                  ;
 15329                                  ;	  FileCntTotal, FileSizTotal are updated.
 15330                                  ;	  Files found are listed. A directory header and trailer are
 15331                                  ;	   displayed only if files are found.
 15332                                  
 15333                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15334                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:155Eh
 15335                                  
 15336                                  ListDir:
 15337 000014FE 31C0                    	xor	ax,ax
 15338 00001500 A3[C88A]                	mov	[FileCnt],ax		; zero file count
 15339 00001503 A3[CA8A]                	mov	[FileSiz],ax		; zero file size accumulator
 15340 00001506 A3[CC8A]                	mov	[FileSiz+2],ax
 15341 00001509 803E[A88C]00            	cmp	byte [DestBuf],0	; check for sort code
 15342 0000150E 740A                    	je	short ld1		; no sort
 15343 00001510 E83000                  	call	LoadEntries		; load entries for sorted listing
 15344 00001513 7305                    	jnc	short ld1		; no error - continue
 15345 00001515 E8E407                  	call	get_ext_error_number	; AX = DOS error code
 15346                                  	; 19/02/2023
 15347                                  	;stc
 15348 00001518 EB12                    	jmp	short ldErr		; return error
 15349                                  ld1:
 15350 0000151A E8DFFE                  	call	FindFirst		; find first file
 15351 0000151D 720D                    	jc	short ldErr		; not found, return error
 15352                                  
 15353                                  ;	BX = offset in TPA buffer of entry found
 15354                                  
 15355 0000151F E8E102                  	call	DisplayHeader		; if at least one file, display header
 15356                                  ldNext:
 15357 00001522 E8B902                  	call	DisplayFile		; display the file entry
 15358                                  ;ldNext:
 15359 00001525 E8D9FE                  	call	FindNext		; find another file
 15360 00001528 7202                    	jc	short ldErr		; not found
 15361                                  	;call	DisplayFile		; display entry
 15362                                  	;jmp	short ldNext		; go find another one
 15363                                  	; 19/02/2023
 15364 0000152A EBF6                    	jmp	short ldNext
 15365                                  ldErr:
 15366                                  	;cmp	ax,2
 15367 0000152C 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND
 15368 0000152F 7407                    	je	short ldDone		; file not found, we're done
 15369                                  	;cmp	ax,18
 15370 00001531 83F812                  	cmp	ax,ERROR_NO_MORE_FILES
 15371 00001534 7402                    	je	short ldDone		; no more files, we're done
 15372 00001536 F9                      	stc
 15373                                  	;jmp	short ldRet
 15374                                  	; 19/02/2023
 15375 00001537 C3                      	retn
 15376                                  ldDone:
 15377 00001538 833E[C88A]00            	cmp	word [FileCnt],0
 15378                                  	;je	short ld2		; no files found, just return
 15379                                  	; 25/04/2023
 15380 0000153D 7403                    	jz	short ldRet
 15381 0000153F E8CA03                  	call	DisplayTrailer		; display trailing info
 15382                                  	; 08/06/2023
 15383                                  	; cf=0
 15384                                  ;ld2:	
 15385                                  	;clc				; return success
 15386                                  ldRet:
 15387 00001542 C3                      	retn
 15388                                  
 15389                                  ; ---------------------------------------------------------------------------
 15390                                  
 15391                                  ;***	LoadEntries - attempt to load entries from current directory
 15392                                  ;
 15393                                  ;	Load all qualifying directory entries from the current directory
 15394                                  ;	into the TPA. If an error is returned by FindFirst/FindNext calls
 15395                                  ;	other than 'no more files', return to caller with carry flag set.
 15396                                  ;	If we run out of buffer space, display a message that we haven't
 15397                                  ;	enough memory to sort this directory, but return without error.
 15398                                  ;	Other routines know whether or not entries have been loaded by
 15399                                  ;	the 'inmem' flag bit, which we set here.
 15400                                  ;
 15401                                  ;	The TPA is usually 64K - 512 bytes long. At 20 bytes per entry,
 15402                                  ;	this allows sorting over 3000 entries in a directory.
 15403                                  ;
 15404                                  ;	ENTRY	Tpa = buffer seg addr
 15405                                  ;		BytCnt = buffer length, in bytes
 15406                                  ;		Current directory (on selected drive) is the one to load
 15407                                  ;		FCB contains drive # and filespec
 15408                                  ;		Bits, AttrSpecified, AttrSelect, & DestBuf (sort codes) are set
 15409                                  ;
 15410                                  ;	EXIT	CY = set if error
 15411                                  ;		If error, DOS Get Extended Error will get error info
 15412                                  ;
 15413                                  ;	USED	AX,CX,DX,SI,DI
 15414                                  ;
 15415                                  ;	EFFECTS
 15416                                  ;
 15417                                  ;	  Inmem bit of Bits = set if load succeeded.
 15418                                  ;	  Tpa buffer contains directory entries.
 15419                                  ;	  Byte after last entry = 0FFh.
 15420                                  
 15421                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15422                                  LoadEntries:
 15423 00001543 06                      	push	es			; save TRANGROUP seg addr
 15424 00001544 8E06[9E8A]              	mov	es,[TPA]		; ES = TPA seg addr
 15425 00001548 31FF                    	xor	di,di			; ES:DI = destination ptr
 15426                                  	;;;and	Bits,not mask inmem	; signal entries not loaded
 15427                                  	;;and	word [_Bits],0FFDFh
 15428                                  	;and	byte [_Bits],0DFh	; not 20h
 15429 0000154A 8026[F78B]DF            	and	byte [_Bits],~mask.inmem ; ~20h
 15430                                  
 15431 0000154F E881FF                  	call	GetFirst		; look for first file
 15432 00001552 7221                    	jc	short leRet		; return any error
 15433 00001554 E82000                  	call	LoadEntry		; load entry into TPA
 15434                                  leNext:
 15435 00001557 E887FF                  	call	GetNext			; get another file
 15436 0000155A 720F                    	jc	short leLoaded		; assume any error is no more files
 15437 0000155C A1[BD8A]                	mov	ax,[BYTCNT]		; AX = size of TPA
 15438 0000155F 29F8                    	sub	ax,di			; AX = bytes left in TPA
 15439                                  	;cmp	ax,size EntryStruc+2	; insist on entry size + 2 bytes
 15440 00001561 83F817                  	cmp	ax,23 ; 21+2 
 15441 00001564 720E                    	jb	short leOk		; not enough memory left, give up
 15442 00001566 E80E00                  	call	LoadEntry		; load entry into TPA
 15443 00001569 EBEC                    	jmp	short leNext		; go get another file
 15444                                  
 15445                                  leLoaded:
 15446 0000156B 26C605FF                	mov	byte [es:di],0FFh	; mark end of entry list
 15447                                  	;;;or	Bits,mask inmem		; signal entries loaded in memory
 15448                                  	;;or	word [_Bits],20h
 15449                                  	;or	byte [_Bits],20h
 15450 0000156F 800E[F78B]20            	or	byte [_Bits],mask.inmem
 15451                                  	; 25/04/2023
 15452                                  	; cf = 0
 15453                                  leOk:
 15454 00001574 F8                      	clc				; return no error
 15455                                  leRet:
 15456 00001575 07                      	pop	es			; ES = TRANGROUP seg addr again
 15457 00001576 C3                      	retn
 15458                                  
 15459                                  
 15460                                  ; ---------------------------------------------------------------------------
 15461                                  
 15462                                  ;***	LoadEntry - load directory entry from DirBuf ext'd FCB
 15463                                  ;
 15464                                  ;	ENTRY	ES:DI = ptr to load point in TPA
 15465                                  ;		DirBuf contains extended FCB of entry to load
 15466                                  ;
 15467                                  ;	EXIT	ES:DI = ptr to next byte available in TPA
 15468                                  ;
 15469                                  ;	USED	AX,CX,SI
 15470                                  ;
 15471                                  ;	NOTES
 15472                                  ;
 15473                                  ;	  I could've used symbolic offsets and sizes of fields from
 15474                                  ;	   the dir_entry struc to do this, but this is time-critical,
 15475                                  ;	   so I hard-wired the structure of the DOS 4.x returned FCB,
 15476                                  ;	   as well as our private directory entry structure.
 15477                                  ;
 15478                                  ;	  We force a zero size for subdirectory files. A zero size is
 15479                                  ;	   ordinarily returned for subdirectories, but with Novell
 15480                                  ;	   Netware 286 or 386 loaded, we can't depend on it. Bug #1594.
 15481                                  
 15482                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15483                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:15DDh
 15484                                  LoadEntry:
 15485                                  	;mov	si,offset TRANGROUP:Dirbuf+8	; DS:SI = ptr to filename
 15486 00001577 BE[AD8B]                	mov	si,DIRBUF+8
 15487 0000157A 30C0                    	xor	al,al				; AL = 0
 15488 0000157C AA                      	stosb					; 'used' byte = false
 15489 0000157D B90B00                  	mov	cx,11
 15490 00001580 F3A4                    	rep	movsb				; transfer filename & extension
 15491 00001582 AC                      	lodsb					; AL = attrib byte
 15492 00001583 AA                      	stosb					; store attrib byte
 15493                                  	;add	si,10 ; 22-11-1
 15494                                  	;add	si,dir_time-dir_attr-1		; skip to time field
 15495 00001584 83C60A                  	add	si,(DIR_ENTRY.DIR_TIME-DIR_ENTRY.DIR_ATTR)-1
 15496 00001587 A5                      	movsw					; transfer time
 15497 00001588 A5                      	movsw					; transfer date
 15498 00001589 46                      	inc	si				; skip alloc unit
 15499 0000158A 46                      	inc	si
 15500                                  	;and	al,10h
 15501 0000158B 2410                    	and	al,ATTR_DIRECTORY
 15502 0000158D 7503                    	jnz	short leSetDirSize		; force zero size for subdir
 15503 0000158F A5                      	movsw
 15504 00001590 A5                      	movsw					; transfer size
 15505 00001591 C3                      	retn
 15506                                  leSetDirSize:
 15507 00001592 31C0                    	xor	ax,ax ; 0
 15508 00001594 AB                      	stosw
 15509 00001595 AB                      	stosw					; store zero size
 15510 00001596 C3                      	retn
 15511                                  
 15512                                  ; ---------------------------------------------------------------------------
 15513                                  
 15514                                  ;***	NoOrder - turn sorting off
 15515                                  ;
 15516                                  ;	ENTRY	nothing
 15517                                  ;
 15518                                  ;	EXIT	CY clear
 15519                                  ;
 15520                                  ;	USED	AX
 15521                                  ;
 15522                                  ;	EFFECTS
 15523                                  ;
 15524                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15525                                  
 15526                                  	; 19/02/2023
 15527                                  NoOrder:
 15528 00001597 C606[A88C]00            	mov	byte [DestBuf],0
 15529                                  				; no sort
 15530 0000159C F8                      	clc			; no error
 15531 0000159D C3                      	retn
 15532                                  
 15533                                  ; ---------------------------------------------------------------------------
 15534                                  
 15535                                  ;***	OnOffSw - record occurence of on/off option switch
 15536                                  ;
 15537                                  ;	ENTRY	DI = index into word list of switches
 15538                                  ;
 15539                                  ;	EXIT	CY clear
 15540                                  ;
 15541                                  ;	USED	AX,CX
 15542                                  ;
 15543                                  ;	EFFECTS
 15544                                  ;
 15545                                  ;	  Bits modified to indicate option state.
 15546                                  
 15547                                  	; 19/02/2023
 15548                                  OnOffSw:
 15549 0000159E 89F9                    	mov	cx,di		; CX = index into word list of options
 15550 000015A0 D1E9                    	shr	cx,1
 15551 000015A2 D1E9                    	shr	cx,1		; CX = bit position of option
 15552 000015A4 B80100                  	mov	ax,1		
 15553 000015A7 D3E0                    	shl	ax,cl		; AX = bit mask of option
 15554 000015A9 F7C70200                	test	di,2		; check if it is a negated option
 15555 000015AD 7405                    	jz	short oo1	; it's negated
 15556                                  	;or	Bits,ax		; turn option on
 15557 000015AF 0906[F78B]              	or	[_Bits],ax
 15558                                  	;jmp	short ooRet
 15559                                  	; 19/02/2023
 15560                                  	;cf=0
 15561 000015B3 C3                      	retn
 15562                                  oo1:	
 15563 000015B4 F7D0                    	not	ax		; AX = complemented bit mask of option
 15564                                  	;and	Bits,ax		; turn option off
 15565 000015B6 2106[F78B]              	and	[_Bits],ax
 15566                                  ooRet:
 15567                                  	; 19/02/2023
 15568                                  	;cf=0
 15569                                  	;clc			; always return success
 15570 000015BA C3                      	retn
 15571                                  
 15572                                  ; ---------------------------------------------------------------------------
 15573                                  
 15574                                  ;***	ParseAttr - parse and record /A option
 15575                                  ;
 15576                                  ;	ENTRY	BX = ptr to system parser result buffer for /A occurence
 15577                                  ;
 15578                                  ;	EXIT	CY = set if error occurs parsing attribute conditions
 15579                                  ;
 15580                                  ;		For parse error, we set up for Std_EPrintf call:
 15581                                  ;		AX = parse error code, like system parser
 15582                                  ;		DX = ptr to message block
 15583                                  ;
 15584                                  ;	USED	AX,CX,DX,DI
 15585                                  ;
 15586                                  ;	EFFECTS
 15587                                  ;
 15588                                  ;	  AttrSpecified, AttrSelect are updated with new attribute conditions.
 15589                                  ;	  If parse error occurs, attribute conditions parsed so far hold.
 15590                                  ;
 15591                                  ;	  For parse error, we set up for Std_EPrintf call:
 15592                                  ;	  Msg_Disp_Class = parse error message class
 15593                                  ;	  Message block (see DX) is set up for parse error message
 15594                                  
 15595                                  	; 19/02/2023
 15596                                  ParseAttr:
 15597 000015BB 56                      	push	si			; save SI
 15598 000015BC C606[FF8B]00            	mov	byte [AttrSpecified],0	; cancel all attribute conditions
 15599                                  
 15600                                  ;	Each /A invocation starts by assuming all files are to be listed.
 15601                                  
 15602                                  	;;mov	si,word ptr [bx].ValuePtr
 15603                                  					; SI = ptr to string after /A
 15604                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15605 000015C1 8B7704                  	mov	si,[bx+4]
 15606                                  paLoop:	
 15607 000015C4 BA0100                  	mov	dx,1			; DX = 1 (for un-negated attribute)
 15608 000015C7 AC                      	lodsb				; AL = next char in string
 15609 000015C8 08C0                    	or	al,al
 15610                                  	;jz	short paOk		; it's terminating null, we're done
 15611                                  	; 19/02/2023
 15612 000015CA 742F                    	jz	short paRet ; cf=0
 15613 000015CC 3C2D                    	cmp	al,'-'
 15614 000015CE 7502                    	jne	short pa1		; not '-', go look for letter
 15615 000015D0 4A                      	dec	dx			; DX = 0 (for negated attribute)
 15616 000015D1 AC                      	lodsb				; AL = next char
 15617                                  pa1:	
 15618                                  	;mov	di,offset TRANGROUP:AttrLtrs 
 15619                                  					; DI = ptr to attrib letter list
 15620 000015D2 BF[6D84]                	mov	di,AttrLtrs ; "RHSvDA"
 15621                                  	;mov	cx,6
 15622 000015D5 B90600                  	mov	cx,NUM_ATTR_LTRS ; 6	; CX = length of attrib letter list
 15623 000015D8 F2AE                    	repne	scasb			; look for our letter in the list
 15624 000015DA 751B                    	jne	short paErr		; not found, return error
 15625                                  
 15626 000015DC F7D1                    	not	cx
 15627                                  	;add	cx,6
 15628 000015DE 83C106                  	add	cx,NUM_ATTR_LTRS	; CX = attrib bit #, 0-5
 15629                                  
 15630                                  ;	Note that we rely on AttrLtrs to be in the attribute bit order,
 15631                                  ;	starting from bit 0.
 15632                                  
 15633                                  ;	Record this attribute bit in AttrSpecified.
 15634                                  
 15635 000015E1 B001                    	mov	al,1
 15636 000015E3 D2E0                    	shl	al,cl			; AL = mask for our bit
 15637 000015E5 0806[FF8B]              	or	[AttrSpecified],al	; set it in the 'specified' mask
 15638                                  
 15639                                  ;	Record the selected state for this attribute in AttrSelect.
 15640                                  ;	DX = 0 or 1, the selected state for this attribute.
 15641                                  
 15642 000015E9 F6D0                    	not	al			; AL = mask for all other bits
 15643 000015EB 2006[008C]              	and	[AttrSelect],al		; clear our bit
 15644 000015EF D2E2                    	shl	dl,cl			; DL = our bit state in position
 15645 000015F1 0816[008C]              	or	[AttrSelect],dl		; set selected attr state
 15646 000015F5 EBCD                    	jmp	short paLoop		; go look at next char
 15647                                  
 15648                                  ;	The attribute letter string is invalid.
 15649                                  
 15650                                  paErr:	
 15651 000015F7 E87303                  	call	SetupParamError		; set message up for Std_EPrintf
 15652 000015FA F9                      	stc		   		; return error
 15653                                  	; 19/02/2023
 15654                                  	;jmp	short paRet
 15655                                  ;paOk:
 15656                                  	;clc				; return success		
 15657                                  paRet:	
 15658 000015FB 5E                      	pop	si			; restore SI
 15659 000015FC C3                      	retn
 15660                                  
 15661                                  ; ---------------------------------------------------------------------------
 15662                                  
 15663                                  ;***	ParseLine - parse a line of text
 15664                                  ;
 15665                                  ;	Parse text until an EOL (CR or NUL) is found, or until a parse
 15666                                  ;	error occurs.
 15667                                  ;
 15668                                  ;	ENTRY	DS:SI = ptr to text
 15669                                  ;		CS, DS, ES = TRANGROUP seg addr
 15670                                  ;
 15671                                  ;	EXIT	AX = last return code from system parser
 15672                                  ;		CX = # positional parameters (pathnames) found - 0 or 1
 15673                                  ;
 15674                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15675                                  ;		DX = ptr to message block
 15676                                  ;
 15677                                  ;	USED	BX,CX,DX,SI,DI
 15678                                  ;
 15679                                  ;	EFFECTS
 15680                                  ;
 15681                                  ;	  Bits may contain new option settings.
 15682                                  ;	  DestBuf may contain new series of sort codes.
 15683                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15684                                  ;	  SrcBuf may contain a new default pathname/filespec.
 15685                                  ;	  PathPos, PathCnt updated for new pathname.
 15686                                  ;
 15687                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15688                                  ;	  Msg_Disp_Class = parse error class
 15689                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15690                                  ;	  Message block (see DX) is set up for parse error message
 15691                                  
 15692                                  	; 19/02/2023
 15693                                  Parse_Line:
 15694                                  	; 04/05/2023
 15695 000015FD BF[3A85]                	mov	di,PARSE_DIR		; ES:DI = ptr to parse block
 15696 00001600 31C9                    	xor	cx,cx			; CX = # positionals found
 15697                                  plPars:
 15698 00001602 E8AD0B                  	call	Parse_With_Msg		; call parser
 15699 00001605 83F8FF                  	cmp	ax,-1
 15700                                  	;cmp	ax,END_OF_LINE ; 0FFFFh ; -1
 15701 00001608 7411                    	je	short plRet		; EOL encountered, return
 15702 0000160A 83F800                  	cmp	ax,RESULT_NO_ERROR ; 0
 15703 0000160D 750C                    	jne	short plRet		; parse error occurred, return
 15704                                  
 15705                                  ;	Parse call succeeded. We have a filespec or a switch.
 15706                                  ;	DX = ptr to result buffer
 15707                                  
 15708 0000160F 89D3                    	mov	bx,dx			; BX = ptr to parse result buffer
 15709 00001611 803F05                  	cmp	byte [bx],RESULT_FILESPEC ; 5
 15710 00001614 7406                    	je	short plFil		; we have a filespec
 15711                                  
 15712 00001616 E85900                  	call	ParseSwitch		; else we have a switch
 15713                                  	;jc	short plRet		; error parsing switch, return
 15714                                  	;jmp	short plPars		; parse more
 15715                                  	; 19/02/2023
 15716 00001619 73E7                    	jnc	short plPars
 15717                                  plRet:
 15718 0000161B C3                      	retn	
 15719                                  plFil:	
 15720 0000161C E8B200                  	call	CopyPathname		; copy pathname into our buffer
 15721 0000161F EBE1                    	jmp	short plPars		; parse more
 15722                                  ;plRet:
 15723                                  ;	retn
 15724                                  
 15725                                  ; ---------------------------------------------------------------------------
 15726                                  
 15727                                  ;***	ParseOrder - parse and record /O option
 15728                                  ;
 15729                                  ;	ENTRY	BX = ptr to system parser result buffer for /O occurence
 15730                                  ;
 15731                                  ;	EXIT	CY = set if error occurs parsing order
 15732                                  ;
 15733                                  ;		For parse error, we set up for Std_EPrintf call:
 15734                                  ;		AX = parse error code, like system parser
 15735                                  ;		DX = ptr to message block
 15736                                  ;
 15737                                  ;	USED	AX,CX,DX,DI
 15738                                  ;
 15739                                  ;	EFFECTS
 15740                                  ;
 15741                                  ;	  DestBuf is updated with sort code bytes. See DestBuf description.
 15742                                  ;
 15743                                  ;	  For parse error, we set up for Std_EPrintf call:
 15744                                  ;	  Msg_Disp_Class = parse error message class
 15745                                  ;	  Message block (see DX) is set up for parse error message
 15746                                  
 15747                                  	; 19/02/2023
 15748                                  ParseOrder:
 15749 00001621 56                      	push	si			; save SI
 15750 00001622 53                      	push	bx			; save ptr to result buffer
 15751                                  
 15752                                  	;;mov	si,word ptr [bx].ValuePtr
 15753                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 15754 00001623 8B7704                  	mov	si,[bx+4]		; SI = ptr to order letters
 15755                                  	;mov	bx,offset TRANGROUP:DestBuf
 15756                                  	; 08/06/2023 (BugFix)
 15757 00001626 BB[A88C]                	mov	bx,DestBuf		; BX = ptr to sort code buffer
 15758 00001629 8A04                    	mov	al,[si]			; AL = 1st char of order string
 15759 0000162B 08C0                    	or	al,al
 15760 0000162D 750E                    	jnz	short poLtr		; not NUL, go parse letters
 15761                                  
 15762                                  ;	We have /O alone. Set standard sort order.
 15763                                  ;	Note hardwired dependency on character order in OrderLtrs.
 15764                                  
 15765 0000162F C60705                  	mov	byte [bx],5		; sort 1st by group (subdirs 1st)
 15766 00001632 43                      	inc	bx
 15767 00001633 C60701                  	mov	byte [bx],1		; then by name
 15768 00001636 43                      	inc	bx
 15769 00001637 C60702                  	mov	byte [bx],2		; then by extension
 15770 0000163A 43                      	inc	bx
 15771 0000163B EB2F                    	jmp	short poOk		; return success
 15772                                  
 15773                                  ;	We have /O<something>. Parse sort order letters.
 15774                                  
 15775                                  poLtr:	
 15776 0000163D 30D2                    	xor	dl,dl			; DL = 0 (upward sort)
 15777 0000163F AC                      	lodsb				; AL = next sort order letter
 15778 00001640 08C0                    	or	al,al
 15779 00001642 7428                    	jz	short poOk		; NUL found, return success
 15780                                  
 15781 00001644 3C2D                    	cmp	al,'-'
 15782 00001646 7503                    	jne	short po1		; not '-', go look for letter
 15783 00001648 B280                    	mov	dl,80h			; DL = downward sort mask
 15784 0000164A AC                      	lodsb				; AL = next char
 15785                                  po1:
 15786                                  	;mov	di,offset TRANGROUP:OrderLtrs
 15787                                  	; 08/06/2023 (BugFix)
 15788 0000164B BF[7384]                	mov	di,OrderLtrs	;"NEDSG" ; DI = ptr to list of letters
 15789 0000164E B90500                  	mov	cx,NUM_ORDER_LTRS ; 5	; CX = length of list
 15790 00001651 F2AE                    	repne	scasb			; look for our letter in the list
 15791 00001653 7510                    	jne	short poErr		; not found, return error
 15792                                  
 15793 00001655 F7D9                    	neg	cx
 15794 00001657 83C105                  	add	cx,NUM_ORDER_LTRS ; 5	; CL = sort order code, 1-6
 15795                                  
 15796 0000165A 08D1                    	or	cl,dl			; CL = sort code with up/dn bit
 15797 0000165C 880F                    	mov	[bx],cl			; store sort order code in buffer
 15798 0000165E 43                      	inc	bx			; BX = ptr to next spot in buffer
 15799                                  	;cmp	bx,offset TRANGROUP:EndDestBuf
 15800 0000165F 81FB[FF8C]              	cmp	bx,EndDestBuf
 15801                                  	;jae	short poErr		; too many letters
 15802                                  	;
 15803                                  	;jmp	short poLtr		; go look at next char
 15804                                  	; 19/02/2023
 15805 00001663 72D8                    	jb	short poLtr
 15806                                  
 15807                                  ;	The sort order string is invalid.  
 15808                                  
 15809                                  poErr:
 15810 00001665 5B                      	pop	bx			; BX = ptr to result buffer
 15811 00001666 E80403                  	call	SetupParamError		; set message up for Std_EPrintf
 15812 00001669 F9                      	stc				; return failure
 15813 0000166A EB04                    	jmp	short poRet
 15814                                  poOk:	
 15815 0000166C C60700                  	mov	byte [bx],0		; mark end of sort code list
 15816 0000166F 5B                      	pop	bx			; BX = ptr to result buffer
 15817                                  	; 19/02/2023
 15818                                  	;cf=0
 15819                                  	;clc				; return success
 15820                                  poRet:
 15821 00001670 5E                      	pop	si			; restore SI
 15822 00001671 C3                      	retn
 15823                                  
 15824                                  ; ---------------------------------------------------------------------------
 15825                                  
 15826                                  ;***	ParseSwitch - parse a switch
 15827                                  ;
 15828                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 15829                                  ;		     a switch
 15830                                  ;
 15831                                  ;	EXIT	CY = set if parse error occurred
 15832                                  ;
 15833                                  ;		If parse error occurred, we're set up for Std_EPrintf call:
 15834                                  ;		AX = parse error code, like system parser
 15835                                  ;		DX = ptr to message block
 15836                                  ;
 15837                                  ;	USED	AX,BX,DX
 15838                                  ;
 15839                                  ;	EFFECTS
 15840                                  ;
 15841                                  ;	  Bits may contain new option settings.
 15842                                  ;	  DestBuf may contain new series of sort codes.
 15843                                  ;	  AttrSpecified, AttrSelect may contain new attribute conditions.
 15844                                  ;
 15845                                  ;	  If parse error occurred, we're set up for Std_EPrintf call:
 15846                                  ;	  Msg_Disp_Class = parse error class
 15847                                  ;	  Byte after last parameter in text is zeroed to make ASCIIZ string
 15848                                  ;	  Message block (see DX) is set up for parse error message
 15849                                  
 15850                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15851                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16E2h
 15852                                  ParseSwitch:
 15853 00001672 51                      	push	cx			; save CX
 15854 00001673 57                      	push	di			; save DI
 15855                                  
 15856                                  	;;mov	ax,[bx].SynPtr		; AX = synonym ptr
 15857                                  	;mov	ax,[bx+ResultBuffer.SynPtr]
 15858 00001674 8B4702                  	mov	ax,[bx+2]
 15859                                  	;mov	di,offset TRANGROUP:Dir_Sw_Ptrs
 15860 00001677 BF[8A85]                	mov	di,Dir_Sw_Ptrs		; ES:DI = ptr to list of synonym ptrs
 15861 0000167A B90E00                  	mov	cx,NUM_DIR_SWS ; 14	; CX = # of dir switches in list
 15862 0000167D FC                      	cld				; scan direction = upward
 15863 0000167E F2AF                    	repne	scasw			; locate synonym ptr in list
 15864                                  	;sub	di,offset TRANGROUP:Dir_Sw_Ptrs + 2
 15865 00001680 81EF[8C85]              	sub	di,Dir_Sw_Ptrs+2
 15866                                  
 15867                                  ;	DI = index into word list of synonym ptrs
 15868                                  
 15869 00001684 2EFF95[8C16]            	call	word [cs:di+SwHandler]	; use same index into call table
 15870                                  
 15871 00001689 5F                      	pop	di			; restore DI
 15872 0000168A 59                      	pop	cx			; restore CX
 15873                                  
 15874 0000168B C3                      	retn
 15875                                  
 15876                                  ; ---------------------------------------------------------------------------
 15877                                  
 15878                                  ;	Order in this table must correspond to order in Dir_Sw_Ptrs list.
 15879                                  ;	Simple on/off switches must occur first in both lists, and must be
 15880                                  ;	  in order of option bits in Bits, starting with bit 0.
 15881                                  
 15882                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15883                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:16FCh
 15884                                  
 15885                                  SwHandler:
 15886 0000168C [9E15]                  	dw	OnOffSw		; /-W
 15887 0000168E [9E15]                  	dw	OnOffSw		; /W
 15888 00001690 [9E15]                  	dw	OnOffSw		; /-P
 15889 00001692 [9E15]                  	dw	OnOffSw		; /P
 15890 00001694 [9E15]                  	dw	OnOffSw		; /-S
 15891 00001696 [9E15]                  	dw	OnOffSw		; /S
 15892 00001698 [9E15]                  	dw	OnOffSw		; /-B
 15893 0000169A [9E15]                  	dw	OnOffSw		; /B
 15894 0000169C [9E15]                  	dw	OnOffSw		; /-L	;M010
 15895 0000169E [9E15]                  	dw	OnOffSw		; /L	;M010
 15896 000016A0 [9715]                  	dw	NoOrder		; /-O
 15897 000016A2 [2116]                  	dw	ParseOrder	; /O
 15898 000016A4 [7513]                  	dw	DefaultAttr	; /-A
 15899 000016A6 [BB15]                  	dw	ParseAttr	; /A
 15900                                  
 15901                                  ; ---------------------------------------------------------------------------
 15902                                  
 15903                                  	;break	<DIR utility routines>
 15904                                  
 15905                                  ;***	UTILITY ROUTINES
 15906                                  ; ---------------------- 
 15907                                  
 15908                                  ; ---------------------------------------------------------------------------
 15909                                  
 15910                                  ;***	ChangeDir - change directory on target drive
 15911                                  ;
 15912                                  ;	ENTRY	FCB contains drive #
 15913                                  ;		DS:DX = ptr to ASCIIZ string w/o drive specifier
 15914                                  ;
 15915                                  ;	EXIT	Changed current directory on drive
 15916                                  ;
 15917                                  ;		If error,
 15918                                  ;		CY = set
 15919                                  ;		DOS Get Extended Error call will get error
 15920                                  ;
 15921                                  ;	USED	AX,DX,SI,DI
 15922                                  ;
 15923                                  ;	EFFECTS
 15924                                  ;
 15925                                  ;	  DirBuf is used to build "d:string".
 15926                                  
 15927                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 15928                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1718h
 15929                                  
 15930                                  ChangeDir:
 15931                                  	;mov	di,offset TRANGROUP:DirBuf
 15932 000016A8 BF[A58B]                	mov	di,DIRBUF
 15933 000016AB E8AE02                  	call	GetDriveLtr	; AX = "d:"
 15934 000016AE AB                      	stosw			; put drive specifier in buffer
 15935 000016AF 89D6                    	mov	si,dx		; SI = ptr to argument string
 15936                                  cdLoop:
 15937 000016B1 AC                      	lodsb
 15938 000016B2 AA                      	stosb			; move byte to buffer
 15939 000016B3 08C0                    	or	al,al
 15940 000016B5 75FA                    	jne	short cdLoop	; continue until null transferred
 15941                                  
 15942                                  	;mov	dx,offset TRANGROUP:DirBuf
 15943 000016B7 BA[A58B]                	mov	dx,DIRBUF	; DX = ptr to "d:string"
 15944                                  	;mov	ah,CHDir
 15945 000016BA B43B                    	mov	ah,3Bh
 15946 000016BC CD21                    	int	21h		; change directory
 15947 000016BE C3                      	retn			; return what CHDIR returns
 15948                                  
 15949                                  ; ---------------------------------------------------------------------------
 15950                                  
 15951                                  ;***	CmpAscz - compare two ASCIIZ strings alphanumerically
 15952                                  ;
 15953                                  ;	ENTRY	DS:SI = ptr to one ASCIIZ string
 15954                                  ;		ES:DI = ptr to another ASCIIZ string
 15955                                  ;
 15956                                  ;	EXIT	flags set after REPE CMPSB
 15957                                  ;
 15958                                  ;	USED	AL,CX,SI,DI
 15959                                  ;
 15960                                  ;	NOTES
 15961                                  ;
 15962                                  ;	Maximum run of comparison is length of DS:SI string.
 15963                                  ;	This ensures that two identical strings followed by
 15964                                  ;	random characters will compare correctly.
 15965                                  
 15966                                  	; 19/02/2023
 15967                                  CmpAscz:
 15968                                  	; 07/06/2023
 15969 000016BF 56                      	push	si ; *
 15970                                  	;
 15971 000016C0 57                      	push	di
 15972                                  
 15973 000016C1 89F7                    	mov	di,si
 15974 000016C3 30C0                    	xor	al,al
 15975 000016C5 B9FFFF                  	mov	cx,0FFFFh
 15976 000016C8 F2AE                    	repne	scasb
 15977 000016CA F7D1                    	not	cx
 15978                                  
 15979 000016CC 5F                      	pop	di
 15980 000016CD F3A6                    	repe	cmpsb
 15981                                  
 15982                                  	; 07/06/2023
 15983 000016CF 5E                      	pop	si ; *
 15984                                  	;
 15985 000016D0 C3                      	retn
 15986                                  
 15987                                  ; ---------------------------------------------------------------------------
 15988                                  
 15989                                  ;***	CopyPathname - copy pathname to our buffer
 15990                                  ;
 15991                                  ;	ENTRY	BX = ptr to parse result buffer after system parser processed
 15992                                  ;		     a filespec
 15993                                  ;
 15994                                  ;	EXIT	nothing
 15995                                  ;
 15996                                  ;	USED	AX
 15997                                  ;
 15998                                  ;	EFFECTS
 15999                                  ;
 16000                                  ;	  SrcBuf may contain a new pathname/filespec.
 16001                                  ;	  PathPos, PathCnt updated for new pathname.
 16002                                  
 16003                                  	; 19/02/2023
 16004                                  CopyPathname:
 16005 000016D1 56                      	push	si
 16006                                  	;;lds	si,dword ptr [bx].ValuePtr  ; load far ptr from result buffer
 16007                                  	;lds	si,[bx+ResultBuffer.ValuePtr]
 16008 000016D2 C57704                  	lds	si,[bx+4]
 16009                                  	;invoke	Move_To_SrcBuf		    ; copy pathname to SrcBuf
 16010 000016D5 E8C815                  	call	Move_To_SrcBuf
 16011 000016D8 5E                      	pop	si
 16012 000016D9 C3                      	retn
 16013                                  
 16014                                  ; ---------------------------------------------------------------------------
 16015                                  
 16016                                  ;***	CountFile - update counters with current file
 16017                                  ;
 16018                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16019                                  ;
 16020                                  ;	EXIT	nothing
 16021                                  ;
 16022                                  ;	USED	AX,DX
 16023                                  ;
 16024                                  ;	EFFECTS
 16025                                  ;
 16026                                  ;	  FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16027                                  
 16028                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16029                                  CountFile:
 16030 000016DA 06                      	push	es			; save TRANGROUP seg addr
 16031 000016DB 8E06[9E8A]              	mov	es,[TPA]		; ES = TPA seg addr
 16032                                  
 16033 000016DF FF06[C88A]              	inc	word [FileCnt]		; # files this directory
 16034 000016E3 FF06[CE8A]              	inc	word [FileCntTotal]	; # files total
 16035 000016E7 7504                    	jnz	short cntf1
 16036 000016E9 FF06[D08A]              	inc	word [FileCntTotal+2]
 16037                                  cntf1:
 16038                                  	;mov	ax,word ptr es:[bx].filesize
 16039                                  					; AX = low word of file size
 16040                                  	;mov	dx,word ptr es:[bx].filesize+2
 16041                                  					; DX = high word of file size
 16042 000016ED 268B4711                	mov	ax,[es:bx+17] ; [es:bx+EntryStruc.filesize]
 16043 000016F1 268B5713                	mov	dx,[es:bx+19] ; [es:bx+EntryStruc.filesize+2]
 16044 000016F5 0106[CA8A]              	add	[FileSiz],ax
 16045 000016F9 1116[CC8A]              	adc	[FileSiz+2],dx		; size of this directory
 16046 000016FD 0106[D28A]              	add	[FileSizTotal],ax
 16047 00001701 1116[D48A]              	adc	[FileSizTotal+2],dx	; total size of files listed
 16048                                  
 16049 00001705 07                      	pop	es			; ES = TRANGROUP seg addr again
 16050                                  dbRet:	; 19/02/2023
 16051 00001706 C3                      	retn
 16052                                  
 16053                                  ; ---------------------------------------------------------------------------
 16054                                  
 16055                                  ;***	DisplayBare - display filename in bare format
 16056                                  ;
 16057                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16058                                  ;
 16059                                  ;	EXIT	DX = # char's displayed, including dot
 16060                                  ;
 16061                                  ;	USED	AX,CX,SI,DI
 16062                                  ;
 16063                                  ;	EFFECTS
 16064                                  ;
 16065                                  ;	  Filename is displayed in name.ext format, followed by cr/lf.
 16066                                  ;	  If /s is on, complete pathname is displayed.
 16067                                  ;
 16068                                  ;	NOTE
 16069                                  ;
 16070                                  ;	  Directory pseudofiles . and .. and suppressed in bare listing.
 16071                                  
 16072                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16073                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1775h
 16074                                  
 16075                                  DisplayBare:
 16076                                  ;	Suppress . and .. files from bare listing.
 16077                                  
 16078 00001707 8CD9                    	mov	cx,ds			; CX = saved TRANGROUP seg addr
 16079 00001709 8E1E[9E8A]              	mov	ds,[TPA]		; DS:BX = ptr to file entry
 16080                                  	;assume	ds:NOTHING
 16081                                  	;cmp	ds:[bx].filename,'.'	; check 1st char of filename
 16082 0000170D 807F012E                	cmp	byte [bx+1],'.' ; [bx+EntrStruc.filename]
 16083 00001711 8ED9                    	mov	ds,cx			; DS = TRANGROUP seg addr again
 16084                                  	;assume	ds:TRANGROUP
 16085 00001713 74F1                    	je	short dbRet		; it's . or .. - don't display
 16086                                  
 16087                                  	;;;test	Bits,mask subd
 16088                                  	;;test	word [_Bits],4
 16089                                  	;test	byte [_Bits],4
 16090 00001715 F606[F78B]04            	test	byte [_Bits],mask.subd
 16091 0000171A 7431                    	jz	short dbNameExt		; not /s - display filename only
 16092                                  
 16093                                  	;invoke	Build_Dir_String
 16094 0000171C E82607                  	call	build_dir_string
 16095                                  	;mov	di,offset TRANGROUP:BwdBuf
 16096 0000171F BF[A58B]                	mov	di,BWDBUF		; ES:DI = ptr to dir string
 16097                                     
 16098                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16099                                  	;;test	word [_Bits],10h
 16100                                  	;test	byte [_Bits],10h
 16101 00001722 F606[F78B]10            	test	byte [_Bits],mask.lcase
 16102                                  	;jz	@F			;M010;lowercase not needed
 16103 00001727 7405                    	jz	short dbare1
 16104 00001729 89FE                    	mov	si,di			;M010;DS:SI --> ASCIIZ string in BwdBuf	
 16105 0000172B E88002                  	call	LowercaseString		;M010;path string is in BwdBuf
 16106                                  dbare1:
 16107                                  ;@@:	
 16108                                  	;xor	al,al			; AL = 0
 16109                                  	; 19/02/2023
 16110 0000172E 31C0                    	xor	ax,ax
 16111 00001730 B9FFFF                  	mov	cx,0FFFFh
 16112 00001733 FC                      	cld
 16113 00001734 F2AE                    	repne	scasb			; ES:DI = ptr to byte after null
 16114 00001736 4F                      	dec	di			; ES:DI = ptr to null byte
 16115                                  
 16116 00001737 26807DFF5C              	cmp	byte [es:di-1],'\'
 16117                                  	;je	@F
 16118 0000173C 7403                    	je	short dbare2		; already terminated w/ '\'
 16119                                  
 16120                                  	;mov	ax,'\'			; AX = '\',0
 16121 0000173E B05C                    	mov	al,'\'
 16122 00001740 AB                      	stosw				; add to dir string
 16123                                  ;@@:
 16124                                  dbare2:
 16125                                  	;mov	String_Ptr_2,offset TRANGROUP:BwdBuf
 16126 00001741 C706[8C8C][A58B]        	mov	word [string_ptr_2],BWDBUF
 16127                                  	;mov	dx,offset TRANGROUP:String_Buf_Ptr
 16128 00001747 BA[F880]                	mov	dx,string_buf_ptr
 16129                                  	;invoke	Std_Printf		; display device & directory path
 16130 0000174A E8B636                  	call	std_printf
 16131                                  dbNameExt:
 16132 0000174D E82D00                  	call	DisplayDotForm		; display name.ext
 16133                                  	;invoke	CrLf2			; display cr/lf
 16134 00001750 E8770E                  	call	CRLF2
 16135                                  	; 19/02/2023
 16136                                  	;call	UseLine			;M007;Allow /p with /b
 16137                                  ;dbRet:
 16138                                  	;retn
 16139                                  
 16140                                  	; 19/02/2023
 16141                                  	;jmp	short UseLine
 16142                                  
 16143                                  ; ---------------------------------------------------------------------------
 16144                                  
 16145                                  ;***	UseLine - use a display line, start a new page if none left
 16146                                  ;
 16147                                  ;	ENTRY	nothing
 16148                                  ;
 16149                                  ;	EXIT	nothing
 16150                                  ;
 16151                                  ;	USED	flags
 16152                                  
 16153                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16154                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A04h
 16155                                  UseLine:
 16156 00001753 FF0E[C68A]              	dec	word [LeftOnPage]
 16157 00001757 833E[C68A]02            	cmp	word [LeftOnPage],2
 16158 0000175C 771E                    	ja	short ulRet
 16159                                  	; 19/02/2023
 16160                                  	;call	EndPage
 16161                                  ;ulRet:
 16162                                  	;retn
 16163                                  
 16164                                  	; 19/02/2023
 16165                                  	;jmp	short EndPage
 16166                                  
 16167                                  ; ---------------------------------------------------------------------------
 16168                                  
 16169                                  ;***	EndPage - end the current display page
 16170                                  ;
 16171                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16172                                  ;		Current directory (on selected drive) is the one being listed
 16173                                  ;		Bits contains /p setting
 16174                                  ;
 16175                                  ;	EXIT	LeftOnPage = # lines left for next page
 16176                                  ;
 16177                                  ;	USED	AX,DX
 16178                                  ;
 16179                                  ;	EFFECTS
 16180                                  ;
 16181                                  ;	  Pause is invoked to display a message and wait for a keystroke.
 16182                                  ;	  BwdBuf (same as DirBuf) used to build directory string.
 16183                                  
 16184                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16185                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19B8h
 16186                                  
 16187                                  EndPage:
 16188                                  	;;;test	Bits,mask pagd
 16189                                  	;;test	word [_Bits],2
 16190                                  	;test	byte [_Bits],2
 16191 0000175E F606[F78B]02            	test	byte [_Bits],mask.pagd
 16192 00001763 7410                    	jz	short epNew		; paged display isn't enabled
 16193                                  
 16194 00001765 53                      	push	bx			; save BX
 16195 00001766 51                      	push	cx			; save CX
 16196                                  
 16197                                  	;invoke	Pause			; "Press any key to continue..."
 16198 00001767 E85502                  	call	PAUSE
 16199                                  
 16200                                  	;invoke	Build_Dir_String
 16201 0000176A E8D806                  	call	build_dir_string
 16202                                  	;mov	dx,offset TRANGROUP:DirCont_Ptr
 16203 0000176D BA[7381]                	mov	dx,dircont_ptr
 16204                                  	;invoke	Printf_Crlf		; "(continuing <dir>)", cr/lf
 16205 00001770 E88236                  	call	Printf_Crlf
 16206                                  
 16207 00001773 59                      	pop	cx			; restore CX
 16208 00001774 5B                      	pop	bx			; restore BX
 16209                                  epNew:	
 16210 00001775 A1[F28D]                	mov	ax,[LinPerPag]		; AX = # lines per page
 16211 00001778 48                      	dec	ax			; AX = # lines till next EndPage
 16212 00001779 A3[C68A]                	mov	[LeftOnPage],ax		; LeftOnPage = countdown variable
 16213                                  ulRet:	
 16214                                  	; 19/02/2023
 16215 0000177C C3                      	retn
 16216                                  
 16217                                  ; ---------------------------------------------------------------------------
 16218                                  
 16219                                  ;***	DisplayDotForm - display filename in compressed dot format
 16220                                  ;
 16221                                  ;	Display name.ext, with no cr/lf's. Dot is displayed only
 16222                                  ;	if the filename has a nonblank extension.
 16223                                  ;
 16224                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16225                                  ;
 16226                                  ;	EXIT	DX = # char's displayed, including dot
 16227                                  ;
 16228                                  ;	USED	AX,CX,SI,DI
 16229                                  ;
 16230                                  ;	EFFECTS
 16231                                  ;
 16232                                  ;	  Filename is displayed in name.ext format.
 16233                                  ;
 16234                                  ;	NOTE
 16235                                  ;
 16236                                  ;	  We allow for bogus filenames that have blanks embedded
 16237                                  ;	  in the name or extension.
 16238                                  
 16239                                  ;	Bugbug:	might be a good performance gain if we buffered
 16240                                  ;	up the output and used DOS function 9.
 16241                                  
 16242                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16243                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:17C8h
 16244                                  
 16245                                  DisplayDotForm:
 16246 0000177D 1E                      	push	ds			; save TRANGROUP seg addr
 16247 0000177E 06                      	push	es			; save ES
 16248 0000177F 2EA1[9E8A]              	mov	ax,[cs:TPA]		; AX = TPA seg addr
 16249 00001783 8ED8                    	mov	ds,ax			; DS:BX = ptr to entry
 16250                                  	;assume	ds:nothing
 16251 00001785 8EC0                    	mov	es,ax			; ES:BX = ptr to entry
 16252                                  
 16253                                  	; 08/06/2023
 16254                                  	;mov	di,bx			; ES:DI = ptr to entry
 16255                                  	;;;add	di,filename + size filename - 1
 16256                                  	;add	di,8 ; 1+8-1		; ES:DI = ptr to last char in name field
 16257                                  	;;mov	cx,size filename	; CX = length of name field
 16258                                  	;mov	cx,8
 16259                                  	; 08/06/2023
 16260 00001787 B90800                  	mov	cx,8
 16261 0000178A 89CF                    	mov	di,cx
 16262 0000178C 01DF                    	add	di,bx	
 16263                                  	
 16264 0000178E B020                    	mov	al,' '
 16265 00001790 FD                      	std				; scan down
 16266 00001791 F3AE                    	repe	scasb			; scan for nonblank
 16267                                  
 16268                                  ;	Assume file name has at least one character.
 16269                                  
 16270 00001793 41                      	inc	cx			; CX = # chars in name
 16271 00001794 89CA                    	mov	dx,cx			; DX = # chars to be displayed
 16272                                  
 16273 00001796 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16274                                  	;;add	si,filename		; DS:SI = ptr to name
 16275                                  	;add	si,1 
 16276                                  	;		; add si,EntryStruc.filename
 16277                                  	; 25/04/2023
 16278 00001798 46                      	inc	si
 16279                                  NextNameChar:
 16280 00001799 FC                      	cld
 16281 0000179A AC                      	lodsb				; AL = next char
 16282                                  
 16283                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16284                                  	;;test	word [ss:_Bits],10h
 16285                                  	;test	byte [ss:_Bits],10h
 16286 0000179B 36F606[F78B]10          	test	byte [ss:_Bits],mask.lcase
 16287                                  	;jz	short @F		;M010;lowercase not required
 16288 000017A1 7403                    	jz	short ddf1
 16289 000017A3 E8FD01                  	call	LowerCase		;M010;filename char is in AL
 16290                                  ddf1:
 16291                                  ;@@:	
 16292                                  	;invoke	Print_Char		; display it
 16293 000017A6 E84D06                  	call	PRINT_CHAR
 16294 000017A9 E2EE                    	loop	NextNameChar
 16295                                  
 16296                                  ;	Now do extension.
 16297                                  
 16298 000017AB 89DF                    	mov	di,bx			; ES:DI = ptr to entry
 16299                                  	;add	di,fileext + size fileext - 1
 16300 000017AD 83C70B                  	add	di,11 ; 9+3-1		; ES:DI = ptr to last char in ext field
 16301                                  	;mov	cx,size fileext		; CX = length of ext field
 16302 000017B0 B90300                  	mov	cx,3
 16303 000017B3 B020                    	mov	al,' '
 16304 000017B5 FD                      	std				; scan down
 16305 000017B6 F3AE                    	repe	scasb			; scan for nonblank
 16306 000017B8 7420                    	je	short ddDone		; no nonblank chars in ext
 16307                                  
 16308 000017BA 41                      	inc	cx			; CX = # chars in ext
 16309 000017BB 01CA                    	add	dx,cx			; DX = total # chars to be displayed
 16310 000017BD 42                      	inc	dx			;      including dot
 16311                                  
 16312 000017BE B02E                    	mov	al,'.'
 16313 000017C0 E83306                  	call	PRINT_CHAR
 16314 000017C3 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16315                                  	;add	si,fileext		; DS:SI = ptr to ext
 16316 000017C5 83C609                  	add	si,9
 16317                                  
 16318                                  NextExtChar:
 16319 000017C8 FC                      	cld
 16320 000017C9 AC                      	lodsb				; AL = next char
 16321                                  
 16322                                  	;;;test	CS:Bits,mask lcase	;M010;check for lowercase option
 16323                                  	;;test	word [cs:_Bits],10h
 16324                                  	;test	byte [cs:_Bits],10h
 16325 000017CA 2EF606[F78B]10          	test	byte [cs:_Bits],mask.lcase
 16326                                  	;jz	short @F		;M010;lowercase not required
 16327 000017D0 7403                    	jz	short ddf2
 16328 000017D2 E8CE01                  	call	LowerCase		;M010;fileext char is in AL
 16329                                  ;@@:	
 16330                                  ddf2:
 16331                                  	;invoke	Print_Char		; display it
 16332 000017D5 E81E06                  	call	PRINT_CHAR
 16333 000017D8 E2EE                    	loop	NextExtChar
 16334                                  ddDone:
 16335 000017DA 07                      	pop	es			; restore ES
 16336 000017DB 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16337                                  	;assume	ds:TRANGROUP
 16338 000017DC FC                      	cld				; leave direction flag = up
 16339 000017DD C3                      	retn
 16340                                  
 16341                                  ; ---------------------------------------------------------------------------
 16342                                  
 16343                                  ;***	DisplayFile - display file entry, update counters
 16344                                  ;
 16345                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16346                                  ;		Bits contains /w, /p settings
 16347                                  ;
 16348                                  ;	EXIT	nothing
 16349                                  ;
 16350                                  ;	USED	AX,CX,DX,SI,DI,BP
 16351                                  ;
 16352                                  ;	EFFECTS
 16353                                  ;
 16354                                  ;	  Entry is displayed.  
 16355                                  ;	  If not /b,
 16356                                  ;	    Cursor is left at end of entry on screen.
 16357                                  ;	    FileCnt, FileCntTotal, FileSiz, FileSizTotal are updated.
 16358                                  ;	  If /b,
 16359                                  ;	    Cursor is left at beginning of next line.
 16360                                  ;	    Cnt's and Siz's aren't updated.
 16361                                  
 16362                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16363                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:182Eh
 16364                                  
 16365                                  DisplayFile:
 16366                                  	;;;test	Bits,mask bare
 16367                                  	;;test	word [_Bits],8
 16368                                  	;test	byte [_Bits],8
 16369 000017DE F606[F78B]08            	test	byte [_Bits],mask.bare
 16370 000017E3 7405                    	jz	short dfNorm		; not /b - do normal display
 16371                                  
 16372 000017E5 E81FFF                  	call	DisplayBare		; display file in bare format
 16373 000017E8 EB18                    	jmp	short dfRet
 16374                                  dfNorm:	
 16375 000017EA E87800                  	call	DisplayNext		; pos'n cursor for next entry
 16376                                  	;;;test	Bits,mask wide
 16377                                  	;;test	word [_Bits],1
 16378                                  	;test	byte [_Bits],1
 16379 000017ED F606[F78B]01            	test	byte [_Bits],mask.wide
 16380 000017F2 7405                    	jz	short dfFull		; full format
 16381 000017F4 E83701                  	call	DisplayWide		; wide format
 16382 000017F7 EB06                    	jmp	short dfCnt
 16383                                  dfFull:	
 16384 000017F9 E83400                  	call	DisplayName		; display filename & extension
 16385 000017FC E88D00                  	call	DisplayTheRest		; display size, date, time
 16386                                  dfCnt:
 16387 000017FF E8D8FE                  	call	CountFile		; update file counters
 16388                                  dfRet:
 16389                                  dhRet:	; 19/02/2023
 16390 00001802 C3                      	retn
 16391                                  
 16392                                  ; ---------------------------------------------------------------------------
 16393                                  
 16394                                  ;***	DisplayHeader - display directory header of working directory
 16395                                  ;
 16396                                  ;	ENTRY	Current directory (on selected drive) is the one to display
 16397                                  ;		LeftOnPage = # lines left on display page
 16398                                  ;
 16399                                  ;	EXIT	nothing
 16400                                  ;
 16401                                  ;	ERROR EXIT
 16402                                  ;
 16403                                  ;	  Build_Dir_String will exit through CError with "Invalid drive
 16404                                  ;	   specification" if there's a problem obtaining the current 
 16405                                  ;	   directory pathname.
 16406                                  ;
 16407                                  ;	USED	AX,DX,SI,DI
 16408                                  ;
 16409                                  ;	EFFECTS
 16410                                  ;
 16411                                  ;	  BwdBuf (which is really the same buffer as DirBuf, which
 16412                                  ;	   we are using for the DTA) contains the directory string.
 16413                                  ;	  LeftOnPage is adjusted.
 16414                                  
 16415                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16416                                  
 16417                                  DisplayHeader:
 16418                                  	;;;test	Bits,mask bare
 16419                                  	;;test	word [_Bits],8
 16420                                  	;test	byte [_Bits],8
 16421 00001803 F606[F78B]08            	test	byte [_Bits],mask.bare
 16422 00001808 75F8                    	jnz	short dhRet		; /b - don't display header
 16423                                  
 16424                                  	;;;test	Bits,mask subd
 16425                                  	;;test	word [_Bits],4
 16426                                  	;test	byte [_Bits],4
 16427 0000180A F606[F78B]04            	test	byte [_Bits],mask.subd
 16428 0000180F 7408                    	jz	short dhNorm		; not /s
 16429                                  
 16430                                  ;	For subdirectory listings, put a blank line before the header.
 16431                                  
 16432                                  	;invoke	Crlf2			; start with a blank line
 16433 00001811 E8B60D                  	call	CRLF2
 16434 00001814 E83CFF                  	call	UseLine
 16435 00001817 EB05                    	jmp	short dhCom
 16436                                  dhNorm:
 16437 00001819 B020                    	mov	al,' ' ; 20h
 16438                                  	;mov	al,BLANK		; if not /s, precede by a blank
 16439 0000181B E8D805                  	call	PRINT_CHAR		; print a leading blank
 16440                                  dhCom:
 16441 0000181E E82406                  	call	build_dir_string
 16442 00001821 BA[7880]                	mov	dx,dirhead_ptr
 16443 00001824 E8DC35                  	call	std_printf		; print header & cr/lf
 16444 00001827 E829FF                  	call	UseLine
 16445 0000182A E89D0D                  	call	CRLF2			; another cr/lf
 16446                                  	;call	UseLine
 16447                                  ;dhRet:
 16448                                  	;retn
 16449                                  
 16450                                  	; 19/02/2023
 16451 0000182D E923FF                  	jmp	UseLine
 16452                                  
 16453                                  ; ---------------------------------------------------------------------------
 16454                                  
 16455                                  ;***	DisplayName - display file name & extension
 16456                                  ;
 16457                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16458                                  ;
 16459                                  ;	EXIT	nothing
 16460                                  ;
 16461                                  ;	USED	AX,CX,DX,SI,DI
 16462                                  ;
 16463                                  ;	EFFECTS
 16464                                  ;
 16465                                  ;	  Filename & extension are displayed in spread format.
 16466                                  ;	  Cursor is left at end of extension.
 16467                                  
 16468                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16469                                  	; 08/06/2023
 16470                                  DisplayName:
 16471 00001830 1E                      	push	ds			; save TRANGROUP seg addr
 16472 00001831 8E1E[9E8A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16473                                  	;assume	ds:nothing
 16474 00001835 89DE                    	mov	si,bx			; DS:SI = ptr to entry
 16475                                  	;add	si,filename		; DS:SI = ptr to filename
 16476                                  	;add	si,1  ; EntryStruc.filename
 16477                                  	; 08/06/2023
 16478 00001837 46                      	inc	si
 16479 00001838 BF[D68A]                	mov	di,CHARBUF		; ES:DI = ptr to CharBuf
 16480                                  
 16481 0000183B B90800                  	mov	cx,8
 16482 0000183E FC                      	cld
 16483 0000183F F3A4                    	rep	movsb			; move filename to CharBuf
 16484 00001841 B020                    	mov	al,' '
 16485 00001843 AA                      	stosb				; add a blank
 16486                                  	;mov	cx,3
 16487                                  	; 08/06/2023
 16488 00001844 B103                    	mov	cl,3
 16489 00001846 F3A4                    	rep	movsb			; add extension
 16490 00001848 30C0                    	xor	al,al
 16491 0000184A AA                      	stosb				; add a NULL
 16492                                  
 16493 0000184B 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16494                                  	;assume	ds:TRANGROUP
 16495                                  
 16496                                  	;;;test	Bits,mask lcase		;M010;check for lowercase option
 16497                                  	;;test	word [_Bits],10h
 16498                                  	;test	byte [_Bits],10h
 16499 0000184C F606[F78B]10            	test	byte [_Bits],mask.lcase
 16500 00001851 7406                    	jz	short dn1		;M010;lowercase not required
 16501 00001853 BE[D68A]                	mov	si,CHARBUF		;M010;DS:SI --> ASCIIZ string
 16502 00001856 E85501                  	call	LowercaseString		;M010;filename.ext string is in CharBuf
 16503                                  dn1:	
 16504 00001859 C706[8C8C][D68A]        	mov	word [string_ptr_2],CHARBUF
 16505 0000185F BA[F880]                	mov	dx,string_buf_ptr
 16506                                  	;call	std_printf		; print filename & extension
 16507                                  	;retn
 16508                                  	; 19/02/2023
 16509 00001862 E99E35                  	jmp	std_printf
 16510                                  
 16511                                  ; ---------------------------------------------------------------------------
 16512                                  
 16513                                  ;***	DisplayNext - move display cursor to next entry position
 16514                                  ;
 16515                                  ;	ENTRY	LeftOnLine = # entries can still be printed on this line
 16516                                  ;		LeftOnPage = # lines can still be printed for this page
 16517                                  ;		FileCnt = # files in this dir displayed before this one
 16518                                  ;		Bits contains /w setting
 16519                                  ;
 16520                                  ;	EXIT	nothing
 16521                                  ;
 16522                                  ;	USED	AX,DX
 16523                                  ;
 16524                                  ;	EFFECTS
 16525                                  ;
 16526                                  ;	  LeftOnLine will be updated to reflect the entry about to be
 16527                                  ;	   displayed.
 16528                                  ;	  LeftOnPage may be updated.
 16529                                  
 16530                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16531                                  
 16532                                  DisplayNext:
 16533 00001865 833E[C88A]00            	cmp	word [FileCnt],0
 16534 0000186A 7415                    	je	short dn1st		; 1st file in directory
 16535 0000186C 803E[C28A]00            	cmp	byte [LeftOnLine],0
 16536 00001871 7E08                    	jng	short dnEol		; no more room on this line
 16537                                  
 16538                                  ;	We are in wide mode (LeftOnLine is always 0 otherwise) and
 16539                                  ;	we still have room for more on this line.
 16540                                  ;	Tab to next position.
 16541                                  
 16542 00001873 BA[0781]                	mov	dx,tab_ptr
 16543 00001876 E88A35                  	call	std_printf
 16544 00001879 EB0C                    	jmp	short dnDone
 16545                                  dnEol:	
 16546                                  ;	Start this entry on a new line.
 16547                                  
 16548 0000187B E84C0D                  	call	CRLF2		; start on new line
 16549 0000187E E8D2FE                  	call	UseLine
 16550                                  dn1st:
 16551 00001881 A0[C38A]                	mov	al,[PerLine]
 16552 00001884 A2[C28A]                	mov	[LeftOnLine],al	; reset # entries left on line
 16553                                  
 16554                                  dnDone:
 16555 00001887 FE0E[C28A]              	dec	byte [LeftOnLine]
 16556                                  				; reflect the entry about to be displayed
 16557 0000188B C3                      	retn
 16558                                  
 16559                                  ; ---------------------------------------------------------------------------
 16560                                  
 16561                                  ;***	DisplayTheRest - display file size/dir, date, time
 16562                                  ;
 16563                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16564                                  ;		Display cursor is at end of file extension
 16565                                  ;
 16566                                  ;	EXIT	nothing
 16567                                  ;
 16568                                  ;	USED	AX,CX,DX,SI,DI,BP
 16569                                  ;
 16570                                  ;	EFFECTS
 16571                                  ;
 16572                                  ;	  File size, date, & time are displayed.
 16573                                  
 16574                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16575                                  DisplayTheRest	:
 16576 0000188C 06                      	push	es			; save TRANGROUP seg addr
 16577 0000188D 8E06[9E8A]              	mov	es,[TPA]		; ES = TPA seg addr
 16578 00001891 89DD                    	mov	bp,bx			; BP = offset of entry in TPA
 16579                                  	;;test	es:[bp].fileattr,ATTR_DIRECTORY
 16580                                  	;test	byte [es:bp+EntryStruc.fileattr],10h
 16581 00001893 26F6460C10              	test	byte [es:bp+12],ATTR_DIRECTORY
 16582 00001898 7408                    	jz	short drNonDir		; not a directory file
 16583                                  
 16584                                  ;	For a directory file, display <DIR> instead of size.
 16585                                  
 16586 0000189A BA[0A81]                	mov	dx,dmes_ptr
 16587 0000189D E86335                  	call	std_printf
 16588 000018A0 EB16                    	jmp	short drCom		; skip to common fields
 16589                                  
 16590                                  drNonDir:
 16591                                  ;	For a non-directory file, display file size.
 16592                                  
 16593                                  	;;mov	dx,word ptr es:[bp].filesize
 16594                                  	;mov	dx,[es:bp+EntryStruc.filesize]
 16595 000018A2 268B5611                	mov	dx,[es:bp+17]
 16596 000018A6 8916[888C]              	mov	[File_Size_Low],dx
 16597                                  	;;mov	dx,word ptr es:[bp].filesize+2
 16598                                  	;mov	dx,[es:bp+EntryStruc.filesize+2]
 16599 000018AA 268B5613                	mov	dx,[es:bp+19]
 16600 000018AE 8916[8A8C]              	mov	[File_Size_High],dx
 16601 000018B2 BA[EA80]                	mov	dx,disp_file_size_ptr
 16602 000018B5 E84B35                  	call	std_printf
 16603                                  drCom:
 16604                                  ;	For all files, display date & time.
 16605                                  
 16606                                  	;;mov	ax,es:[bp].filedate	; AX = date word
 16607                                  	;mov	ax,[es:bp+EntryStruc.filedate]
 16608 000018B8 268B460F                	mov	ax,[es:bp+15]
 16609 000018BC 09C0                    	or	ax,ax			; test for null date (DOS 1.x)
 16610 000018BE 7448                    	jz	short drDone		; no date, skip date/time display
 16611 000018C0 89C3                    	mov	bx,ax			; BX = date word
 16612 000018C2 83E01F                  	and	ax,1Fh			; AX = day of month
 16613 000018C5 88C2                    	mov	dl,al			; DL = day of month
 16614 000018C7 89D8                    	mov	ax,bx			; AX = date word
 16615 000018C9 B105                    	mov	cl,5
 16616 000018CB D3E8                    	shr	ax,cl			; shift day out
 16617 000018CD 240F                    	and	al,0Fh			; AL = month
 16618 000018CF 88C6                    	mov	dh,al			; DH = month
 16619 000018D1 88F9                    	mov	cl,bh
 16620 000018D3 D0E9                    	shr	cl,1			; CL = year - 1980
 16621 000018D5 30ED                    	xor	ch,ch			; CX = year - 1980
 16622 000018D7 83C150                  	add	cx,80			; CX = 2-digit year
 16623 000018DA 80F964                  	cmp	cl,100
 16624 000018DD 7203                    	jb	short dr_1		; not year 2000 yet, skip ahead
 16625 000018DF 80E964                  	sub	cl,100			; adjust for 21st century
 16626                                  dr_1:	
 16627 000018E2 86F2                    	xchg	dh,dl			; DX = month/day
 16628 000018E4 890E[4881]              	mov	[DirDat_Yr],cx		; move year to msg block
 16629 000018E8 8916[4A81]              	mov	[DirDat_Mo_Day],dx	; move month/day to msg block
 16630                                  	;;mov	cx,es:[bp].filetime	; CX = file time
 16631                                  	;mov	cx,[es:bp+EntryStruc.filetime]
 16632 000018EC 268B4E0D                	mov	cx,[es:bp+13]
 16633 000018F0 E310                    	jcxz	drPrint			; no time field - go print
 16634 000018F2 D1E9                    	shr	cx,1
 16635 000018F4 D1E9                    	shr	cx,1
 16636 000018F6 D1E9                    	shr	cx,1			; CH = hours
 16637 000018F8 D0E9                    	shr	cl,1
 16638 000018FA D0E9                    	shr	cl,1			; CL = minutes
 16639 000018FC 86E9                    	xchg	ch,cl			; CX = hr/min
 16640 000018FE 890E[5381]              	mov	[DirTim_Hr_Min],cx	; move time to msg block
 16641                                  drPrint:
 16642 00001902 BA[4381]                	mov	dx,dirdattim_ptr
 16643 00001905 E8FB34                  	call	std_printf		; print date & time
 16644                                  drDone:
 16645 00001908 07                      	pop	es			; ES = TRANGROUP seg addr again	
 16646 00001909 89EB                    	mov	bx,bp			; BX = offset of entry in TPA again
 16647                                  dtrRet:
 16648                                  	; 19/02/2023
 16649 0000190B C3                      	retn
 16650                                  
 16651                                  ; ---------------------------------------------------------------------------
 16652                                  
 16653                                  ;***	DisplayTrailer - display trailing lines for directory listing
 16654                                  ;
 16655                                  ;	ENTRY	LeftOnPage = # lines left on display page
 16656                                  ;		FileCnt = # files listed
 16657                                  ;		FileSiz = total size of files listed
 16658                                  ;
 16659                                  ;	EXIT	nothing
 16660                                  ;
 16661                                  ;	USED
 16662                                  ;
 16663                                  ;	EFFECTS
 16664                                  ;
 16665                                  ;	  Trailing info lines are displayed
 16666                                  
 16667                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16668                                  
 16669                                  DisplayTrailer:
 16670                                  	;;;test	Bits,mask bare
 16671                                  	;;test	word [_Bits],8
 16672                                  	;test	byte [_Bits],8
 16673 0000190C F606[F78B]08            	test	byte [_Bits],mask.bare
 16674 00001911 75F8                    	jnz	short dtrRet		; /b - don't display trailer
 16675                                  
 16676 00001913 E8B40C                  	call	CRLF2			; start on new line
 16677 00001916 E83AFE                  	call	UseLine
 16678 00001919 A1[C88A]                	mov	ax,[FileCnt]		; AX = # files found
 16679                                  
 16680                                  ;	DisplayTotals uses this entry point.
 16681                                  ;
 16682                                  DisplayCntSiz:
 16683                                  ;	AX = # files
 16684                                  ;	FileSiz = dword total size of files
 16685                                  
 16686 0000191C A3[918C]                	mov	[Dir_Num],ax		; load # files
 16687 0000191F BA[717F]                	mov	dx,dirmes_ptr		; DX = ptr to message block
 16688 00001922 E8DE34                  	call	std_printf		; "nnn File(s)"
 16689                                  
 16690 00001925 BA[5F81]                	mov	dx,bytes_ptr
 16691 00001928 E8D834                  	call	std_printf		; "nnn bytes",cr,lf
 16692                                  	; 19/02/2023
 16693                                  	;call	UseLine
 16694                                  ;dtrRet:
 16695                                  	;retn
 16696                                  
 16697                                  	; 19/02/2023
 16698 0000192B E925FE                  	jmp	UseLine
 16699                                  
 16700                                  ; ---------------------------------------------------------------------------
 16701                                  
 16702                                  ;***	DisplayWide - display filename in wide format
 16703                                  ;
 16704                                  ;	ENTRY	BX = offset of entry in TPA buffer
 16705                                  ;
 16706                                  ;	EXIT	nothing
 16707                                  ;
 16708                                  ;	USED	AX,CX,DX,SI,DI
 16709                                  ;
 16710                                  ;	EFFECTS
 16711                                  ;
 16712                                  ;	  Name.ext is displayed. Cursor left at end of field (padded
 16713                                  ;	  with blanks). Subdirectory files are displayed as [name.ext].
 16714                                  
 16715                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16716                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:198Ah
 16717                                  
 16718                                  DisplayWide:
 16719 0000192E 1E                      	push	ds			; save TRANGROUP seg addr
 16720 0000192F 8E1E[9E8A]              	mov	ds,[TPA]		; DS:BX = ptr to entry
 16721                                  	;assume	ds:nothing
 16722                                  
 16723                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16724                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16725 00001933 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 16726 00001937 7405                    	jz	short dw1		; not a subdirectory file
 16727 00001939 B05B                    	mov	al,'['
 16728 0000193B E8B804                  	call	PRINT_CHAR		; prefix subdirectory
 16729                                  dw1:	
 16730 0000193E E83CFE                  	call	DisplayDotForm		; display name.ext
 16731                                  
 16732                                  ;	DX = # chars displayed in name.ext
 16733                                  
 16734                                  	;;test	ds:[bx].fileattr,ATTR_DIRECTORY
 16735                                  	;test	byte [bx+EntryStruc.fileattr],10h
 16736 00001941 F6470C10                	test	byte [bx+12],ATTR_DIRECTORY
 16737 00001945 7405                    	jz	short dw2		; not a subdirectory file
 16738 00001947 B05D                    	mov	al,']'
 16739 00001949 E8AA04                  	call	PRINT_CHAR		; postfix subdirectory
 16740                                  dw2:
 16741                                  ;	Pad field with blanks.
 16742                                  
 16743                                  	;mov	cx,size filename + size fileext + 1
 16744 0000194C B90C00                  	mov	cx,12 ; 8+3+1
 16745                                  					; CX = field size
 16746 0000194F 29D1                    	sub	cx,dx			; CX = # pad char's
 16747 00001951 E307                    	jcxz	dwDone
 16748 00001953 B020                    	mov	al,' '
 16749                                  dw3:	
 16750 00001955 E89E04                  	call	PRINT_CHAR
 16751 00001958 E2FB                    	loop	dw3
 16752                                  dwDone:	
 16753 0000195A 1F                      	pop	ds			; DS = TRANGROUP seg addr again
 16754                                  	;assume	ds:TRANGROUP
 16755 0000195B C3                      	retn
 16756                                  
 16757                                  ; ---------------------------------------------------------------------------
 16758                                  
 16759                                  ;***	GetDriveLtr - get target drive letter
 16760                                  ;
 16761                                  ;	ENTRY	FCB contains drive #
 16762                                  ;
 16763                                  ;	EXIT	AX = "d:"
 16764                                  ;
 16765                                  ;	USED	nothing
 16766                                  
 16767                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16768                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19D8h
 16769                                  GetDriveLtr:
 16770 0000195C A05C00                  	mov	al,[FCB] ; 5Ch	; AL = target drive #
 16771 0000195F 08C0                    	or	al,al
 16772 00001961 7505                    	jnz	short gdl1	; not current drive default, skip ahead
 16773 00001963 A0[B08A]                	mov	al,[CURDRV]	; AL = current drive #
 16774 00001966 FEC0                    	inc	al		; AL = 1-based drive #
 16775                                  gdl1:	
 16776 00001968 0440                    	add	al,'A'-1 ; 40h	; AL = target drive letter
 16777 0000196A B43A                    	mov	ah,':'		; AX = "d:"
 16778 0000196C C3                      	retn
 16779                                  
 16780                                  ; ---------------------------------------------------------------------------
 16781                                  
 16782                                  ;***	SetupParamError - set up for Std_EPrintf parameter parse error message
 16783                                  ;
 16784                                  ;	Do for our /O and /A string parsers what Parse_With_Msg does
 16785                                  ;	for system parser calls. Set up a message substitution block,
 16786                                  ;	etc. for invalid value strings. I copied the procedure from
 16787                                  ;	Setup_Parse_Error_Msg.
 16788                                  ;
 16789                                  ;	ENTRY	BX = ptr to system parser result buffer (contains ptr to str)
 16790                                  ;		
 16791                                  ;
 16792                                  ;	EXIT	AX = system parser error return code for bad param format
 16793                                  ;		DX = ptr to message description block for Std_EPrintf
 16794                                  ;
 16795                                  ;	USED	SI
 16796                                  ;
 16797                                  ;	EFFECTS
 16798                                  ;
 16799                                  ;	  Msg_Disp_Class = parse error message class
 16800                                  ;	  Message block (see DX) is set up for parse error message
 16801                                  
 16802                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16803                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:19E9h
 16804                                  SetupParamError:
 16805 0000196D B80900                  	mov	ax,9			; parse error #
 16806 00001970 C606[2F7F]02            	mov	byte [msg_disp_class],parse_msg_class
 16807                                  	;mov	byte [msg_disp_class],2
 16808 00001975 A3[317F]                	mov	[extend_buf_ptr],ax
 16809                                  	;mov	si,[bx+ResultBuffer.ValuePtr]
 16810 00001978 8B7704                  	mov	si,[bx+4]
 16811 0000197B 8936[8C8C]              	mov	[string_ptr_2],si
 16812 0000197F C606[337F]01            	mov	byte [extend_buf_sub],one_subst
 16813                                  	;mov	byte [extend_buf_sub],1
 16814 00001984 BA[317F]                	mov	dx,extend_buf_ptr
 16815 00001987 C3                      	retn
 16816                                  
 16817                                  ; ---------------------------------------------------------------------------
 16818                                  
 16819                                  ;***	ZeroTotals - zero grand total file count, size
 16820                                  ;
 16821                                  ;	ENTRY	nothing
 16822                                  ;
 16823                                  ;	EXIT	nothing
 16824                                  ;
 16825                                  ;	USED	AX
 16826                                  ;
 16827                                  ;	EFFECTS
 16828                                  ;
 16829                                  ;	  FileCntTotal & FileSizTotal are zeroed.
 16830                                  ;
 16831                                  ;	NOTES
 16832                                  ;
 16833                                  ;	  FileCntTotal throuth csecUsedTotal must be together!
 16834                                  	
 16835                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16836                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A13h	
 16837                                  ZeroTotals:
 16838 00001988 BF[CE8A]                	mov	di,FileCntTotal
 16839                                  
 16840                                  	;mov	cx,size FileCntTotal+size FileSizTotal
 16841 0000198B B90800                  	mov	cx,8
 16842                                  
 16843 0000198E 30C0                    	xor	al,al
 16844 00001990 F3AA                    	rep	stosb
 16845 00001992 C3                      	retn	
 16846                                  
 16847                                  ; ---------------------------------------------------------------------------
 16848                                  
 16849                                  ;***	CtrlCHandler - our own control-c handler
 16850                                  ;
 16851                                  ;	Make sure user's default directory gets restored. See notes
 16852                                  ;	at InstallCtrlCHandler.
 16853                                  ;
 16854                                  ;	ENTRY	control-c
 16855                                  ;
 16856                                  ;	EXIT	to OldCtrlCHandler
 16857                                  ;
 16858                                  ;	USED	DS,flags
 16859                                  ;
 16860                                  ;	EFFECTS
 16861                                  ;
 16862                                  ;	  Restore user's default directory.
 16863                                  ;
 16864                                  ;	NOTES
 16865                                  ;
 16866                                  ;	  This handler is only installed after calling PathCrunch,
 16867                                  ;	  which sets UserDir1, so the restoration will work.
 16868                                  ;
 16869                                  ;	  The original control-c vector will be restored, whether
 16870                                  ;	  or not this one is invoked, in the HeadFix routine.
 16871                                  
 16872                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16873                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A1Eh
 16874                                  
 16875                                  CtrlCHandler:	;proc	far
 16876                                  
 16877                                  ;SR;
 16878                                  ; Save all registers used: ds, dx, ax. I know ax is being used by the 
 16879                                  ;CtrlC handler, am not sure about ds & dx. Save them to be safe
 16880                                  ;
 16881 00001993 1E                      	push	ds
 16882 00001994 0E                      	push	cs
 16883 00001995 1F                      	pop	ds			; DS = TRANGROUP seg addr
 16884 00001996 50                      	push	ax
 16885 00001997 52                      	push	dx
 16886 00001998 E8EC0A                  	call	RestUDir		; restore user's default directory
 16887 0000199B 5A                      	pop	dx
 16888 0000199C 58                      	pop	ax
 16889 0000199D 1F                      	pop	ds
 16890 0000199E 2EFF2E[9F95]            	jmp	far [cs:OldCtrlCHandler]
 16891                                  					; go to previous int 23 handler
 16892                                  
 16893                                  ; ---------------------------------------------------------------------------
 16894                                  
 16895                                  ;M010;start
 16896                                  ;***	LowerCase - convert ASCII character in AL to lowercase
 16897                                  ;
 16898                                  ;	ENTRY	AL = character to be displayed
 16899                                  ;
 16900                                  ;	EXIT	AL is lowercase
 16901                                  ;
 16902                                  ;	USED	nothing
 16903                                  
 16904                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16905                                  LowerCase:
 16906 000019A3 3C41                    	cmp	al,'A'			; ensure AL is in range 'A'-'Z'
 16907 000019A5 7206                    	jb	short lcRet
 16908 000019A7 3C5A                    	cmp	al,'Z'
 16909 000019A9 7702                    	ja	short lcRet
 16910                                  
 16911 000019AB 0C20                    	or	al,20h			; convert to ASCII lowercase (UpperCase+32)-->LowerCase
 16912                                  lcRet:
 16913 000019AD C3                      	retn
 16914                                  
 16915                                  ; ---------------------------------------------------------------------------
 16916                                  
 16917                                  ;***	LowercaseString - convert ASCIIZ string at DS:SI to lowercase
 16918                                  ;
 16919                                  ;	ENTRY	DS:SI points to start of ASCIIZ string
 16920                                  ;		ES = DS
 16921                                  ;
 16922                                  ;	EXIT	nothing
 16923                                  ;	
 16924                                  ;	USED	AL,SI
 16925                                  
 16926                                  	; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16927                                  LowercaseString:
 16928 000019AE 57                      	push	di			; save di
 16929 000019AF 89F7                    	mov	di,si			; ES:DI --> ASCIIZ string
 16930 000019B1 FC                      	cld
 16931                                  NextChar: 
 16932 000019B2 AC                      	lodsb				; get character from string into al
 16933 000019B3 08C0                    	or	al,al			; are we at end of string?
 16934 000019B5 7406                    	jz	short EndOfString
 16935                                  
 16936 000019B7 E8E9FF                  	call	LowerCase		; convert character to lowercase
 16937 000019BA AA                      	stosb				; store character back into buffer
 16938 000019BB EBF5                    	jmp	short NextChar		; repeat until end of string
 16939                                  
 16940                                  EndOfString:
 16941 000019BD 5F                      	pop	di			; restore di
 16942 000019BE C3                      	retn
 16943                                  
 16944                                  ;M010;end
 16945                                  
 16946                                  ;============================================================================
 16947                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 16948                                  ;============================================================================
 16949                                  ; 09/10/2018 - Retro DOS v3.0
 16950                                  
 16951                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1195h
 16952                                  
 16953                                  ; 19/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16954                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1A4Ah
 16955                                  
 16956                                  ; =============== S U B	R O U T	I N E =======================================
 16957                                  
 16958                                  PAUSE:
 16959 000019BF BA[C37F]                	mov	dx,PAUSEMES_PTR ; 19/02/2023
 16960 000019C2 E83E34                  	call	std_printf
 16961 000019C5 E88CEB                  	call	GETKEYSTROKE
 16962                                  	;call	CRLF2
 16963                                  	;retn
 16964                                  	; 19/02/2023
 16965 000019C8 E9FF0B                  	jmp	CRLF2
 16966                                  
 16967                                  ; ---------------------------------------------------------------------------
 16968                                  
 16969                                  ;****************************************************************
 16970                                  ;*
 16971                                  ;* ROUTINE:	DEL/ERASE - erase file(s)
 16972                                  ;*
 16973                                  ;* FUNCTION:	PARSE command line for file or path name and /P
 16974                                  ;*		and invoke PATHCRUNCH. If an error occurs, set
 16975                                  ;*		up an error message and transfer control to CERROR.
 16976                                  ;*		Otherwise, transfer control to NOTEST2 if /P not
 16977                                  ;*		entered or SLASHP_ERASE if /P entered.
 16978                                  ;*
 16979                                  ;* INPUT:	command line at offset 81H
 16980                                  ;*
 16981                                  ;* OUTPUT:	if no error:
 16982                                  ;*		FCB at 5ch set up with filename(s) entered
 16983                                  ;*		Current directory set to entered directory
 16984                                  ;*
 16985                                  ;****************************************************************
 16986                                  
 16987                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 16988                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1A57h
 16989                                  	; 10/06/2023
 16990                                  ERASE:
 16991                                  	; MSDOS 6.0
 16992                                  
 16993                                  	;assume	ds:trangroup,es:trangroup
 16994                                  
 16995 000019CB BE8100                  	mov	si,81h		;AC000; get command line
 16996 000019CE C706[B38A]0000          	mov	word [COMSW],0 	;AN000; clear switch indicator
 16997 000019D4 BF[2F85]                	mov	di,PARSE_ERASE
 16998                                  				;AN000; Get address of PARSE_ERASE
 16999 000019D7 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17000                                  erase_scan:
 17001 000019D9 31D2                    	xor	dx,dx		;AN000;
 17002 000019DB E8D407                  	call	Parse_With_Msg	;AC018; call parser
 17003                                  
 17004                                  	;cmp	ax,-1  ; 0FFFFh
 17005                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 17006                                  	;je	short good_line	;AN000; yes - done parsing
 17007                                  	;;cmp	ax,0
 17008                                  	;;cmp	ax,RESULT_NO_ERROR ; 0
 17009                                  	;and	ax,ax		;AC000; did we have an error?
 17010                                  	;jnz	short errj2	;AC000; yes exit
 17011                                  	; 10/06/2023
 17012 000019DE 40                      	inc	ax  ; cmp ax,-1
 17013 000019DF 743C                    	jz	short good_line ; 0FFFFh -> 0
 17014 000019E1 48                      	dec	ax  ; cmp ax,0	
 17015 000019E2 7566                    	jnz	short errj2  ; 1 -> 0
 17016                                  	; ax = 0
 17017                                  
 17018 000019E4 813E[CD95][A284]        	cmp	word [PARSE1_SYN],SLASH_P_SYN ; "/P"
 17019                                  				;AN000; was /P entered?
 17020 000019EA 741C                    	je	short set_erase_prompt
 17021                                  				;AN000; yes - go set prompt
 17022                                  ;
 17023                                  ; Must be filespec since no other matches occurred. move filename to srcbuf
 17024                                  ;
 17025 000019EC 56                      	push	si		;AC000; save position in line
 17026 000019ED C536[CF95]              	lds	si,[PARSE1_ADDR]
 17027                                  				;AC000; get address of filespec
 17028                                  	;cmp	byte [si+1],colon_char
 17029 000019F1 807C013A                	cmp	byte [si+1],':'	;AC000; drive specified?
 17030 000019F5 750B                    	jne	short erase_drive_ok
 17031                                  				;AC000; no - continue
 17032                                  	;cmp	byte [si+2],END_OF_LINE_OUT	
 17033 000019F7 807C0200                	cmp	byte [si+2],0	;AC000; was only drive entered?
 17034 000019FB 7505                    	jne	short erase_drive_ok
 17035                                  				;AC000; no - continue
 17036 000019FD B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2 
 17037                                  				;AN022; get message number in control block
 17038 00001A00 EB3D                    	jmp	short extend_setup
 17039                                  				;AC000; exit
 17040                                  erase_drive_ok:
 17041 00001A02 E89B12                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17042 00001A05 5E                      	pop	si		;AC000; get position back
 17043 00001A06 EBD1                    	jmp	short erase_scan
 17044                                  				;AN000; continue parsing
 17045                                  set_erase_prompt:
 17046 00001A08 833E[B38A]00            	cmp	word [COMSW],0 	;AN018; was /P already entered?
 17047 00001A0D 7408                    	jz	short ok_to_set_erase_prompt
 17048                                  				;AN018; no go set switch
 17049                                  	;mov	ax,1
 17050 00001A0F B80100                  	mov	ax,MoreArgs_Ptr 
 17051                                  				;AN018; set up too many arguments
 17052 00001A12 E8AC07                  	call	setup_parse_error_msg
 17053                                  				;AN018; set up an error message
 17054 00001A15 EB33                    	jmp	short errj2	;AN018; exit
 17055                                  
 17056                                  ok_to_set_erase_prompt: 	;AN018;
 17057 00001A17 FF06[B38A]              	inc	word [COMSW]	;AN000; indicate /p specified
 17058 00001A1B EBBC                    	jmp	short erase_scan
 17059                                  				;AN000; continue parsing
 17060                                  good_line:			;G  We know line is good
 17061 00001A1D E8530C                  	call	PathCrunch
 17062 00001A20 730D                    	jnc	short checkdr
 17063 00001A22 A1[0F8E]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17064                                  	;cmp	ax,0		;AN022; was message flag set?
 17065 00001A25 09C0                    	or	ax,ax
 17066 00001A27 7516                    	jnz	short extend_setup
 17067                                  				;AN022; yes - print out message
 17068                                  	;cmp	byte [DestIsDir],0
 17069 00001A29 3806[A38C]              	cmp	[DestIsDir],al 	; No CHDIRs worked
 17070 00001A2D 750D                    	jnz	short badpath_err
 17071                                  				;AC022; see if they should have
 17072                                  checkdr:
 17073 00001A2F 833E[B38A]00            	cmp	word [COMSW],0 	;AN000; was /p specified
 17074 00001A34 7403                    	jz	short notest2j	;AN000; no - go to notest2
 17075 00001A36 E90D1B                  	jmp	slashp_erase	;AN000; yes - go to slashp_erase
 17076                                  notest2j:
 17077 00001A39 E9A51A                  	jmp	notest2
 17078                                  
 17079                                  badpath_err:			;AN022; "Path not found" message
 17080 00001A3C B80300                  	mov	ax,ERROR_PATH_NOT_FOUND ; 3
 17081                                  				;AN022; set up error number
 17082                                  extend_setup:			;AN022;
 17083                                  	;mov	byte [msg_disp_class],1
 17084 00001A3F C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class
 17085                                  				;AN022; set up extended error msg class
 17086 00001A44 BA[317F]                	mov	dx,extend_buf_ptr
 17087                                  				;AC022; get extended message pointer
 17088 00001A47 A3[317F]                	mov	[extend_buf_ptr],ax
 17089                                  				;AN022; get message number in control block
 17090                                  errj2:				;AC022; exit jump
 17091 00001A4A E9FE0E                  	jmp	cerror		;AN022;
 17092                                  
 17093                                  ; 20/02/2023
 17094                                  %if 0
 17095                                  	; MSDOS 3.3
 17096                                  	mov	dx,BADARGSPTR
 17097                                  	mov	si,80h
 17098                                  	lodsb
 17099                                  	or	al,al
 17100                                  	jz	short ERRJ2
 17101                                  	call	SCANOFF
 17102                                  	cmp	al,0Dh		; Return key
 17103                                  	jz	short ERRJ2	; If so no parameters specified
 17104                                  	push	dx
 17105                                  	push	si
 17106                                  	mov	dx,FNOTFOUNDPTR
 17107                                  ERASE_SCAN:
 17108                                  	lodsb
 17109                                  	call	DELIM
 17110                                  	jz	short ERASE_CHKDELIMCHR
 17111                                  	cmp	al,0Dh
 17112                                  	jz	short GOOD_LINE
 17113                                  	jmp	short ERASE_SCAN
 17114                                  ERASE_CHKDELIMCHR:
 17115                                  	cmp	al,20h
 17116                                  	jg	short ERRJ2
 17117                                  	lodsb
 17118                                  	call	DELIM
 17119                                  	jz	short ERASE_CHKDELIMCHR
 17120                                  	cmp	al,0Dh
 17121                                  	jz	short GOOD_LINE
 17122                                  	mov	dx,BADARGSPTR
 17123                                  	jmp	short ERRJ2
 17124                                  GOOD_LINE:
 17125                                  	pop	si
 17126                                  	pop	dx
 17127                                  	push	si
 17128                                  	call	PATHCRUNCH
 17129                                  	jnc	short CHECKDR
 17130                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17131                                  	jz	short CHECKDR	   ; see if they should have
 17132                                  BADCDERR:
 17133                                  	pop	si
 17134                                  	mov	dx,BADCDPTR
 17135                                  ERRJ2:
 17136                                  	jmp	CERROR
 17137                                  CHECKDR:
 17138                                  	mov	dx,FNOTFOUNDPTR
 17139                                  	pop	cx
 17140                                  	mov	al,' '
 17141                                  	;cmp	[5Dh],al
 17142                                  	cmp	[FCB+1],al
 17143                                  	jz	short ERRJ2
 17144                                  	add	cx,3
 17145                                  	cmp	si,cx
 17146                                  	jnz	short NOTEST2J
 17147                                  	mov	al,':'
 17148                                  	cmp	[si-2],al
 17149                                  	jz	short ERRJ2
 17150                                  NOTEST2J:
 17151                                  	jmp	NOTEST2
 17152                                  %endif
 17153                                  
 17154                                  ; ---------------------------------------------------------------------------
 17155                                  
 17156                                  ; ****************************************************************
 17157                                  ; *
 17158                                  ; * ROUTINE:	 CRENAME - rename file(s)
 17159                                  ; *
 17160                                  ; * FUNCTION:	 PARSE command line for one full filespec and one
 17161                                  ; *		 filename. Invoke PATHCRUNCH on the full filespec.
 17162                                  ; *		 Make sure the second filespec only contains a
 17163                                  ; *		 filename. If both openands are valid, attempt
 17164                                  ; *		 to rename the file.
 17165                                  ; *
 17166                                  ; * INPUT:	 command line at offset 81H
 17167                                  ; *
 17168                                  ; * OUTPUT:	 none
 17169                                  ; *
 17170                                  ; ****************************************************************
 17171                                  
 17172                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17173                                  CRENAME:
 17174                                  	; MSDOS 6.0
 17175                                  	;assume	ds:trangroup,es:trangroup
 17176                                  
 17177 00001A4D BE8100                  	mov	si,81h		;AC000; Point to command line
 17178 00001A50 BF[A685]                	mov	di,PARSE_RENAME
 17179                                  				;AN000; Get address of PARSE_RENAME
 17180 00001A53 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17181 00001A55 31D2                    	xor	dx,dx		;AN000;
 17182 00001A57 E85807                  	call	Parse_With_Msg	;AC018; call parser
 17183                                  	;cmp	ax,RESULT_NO_ERROR ; 0
 17184 00001A5A 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17185                                  ;	jz	short crename_no_parse_error
 17186                                  				;AC000; no - continue
 17187 00001A5C 752C                    	jnz	short crename_parse_error
 17188                                  				;AC000; Yes, fail. (need long jump)
 17189                                  ;
 17190                                  ;  Get first file name returned from parse into our buffer
 17191                                  ;
 17192                                  crename_no_parse_error:
 17193 00001A5E 56                      	push	si		;AN000; save position in line
 17194 00001A5F C536[CF95]              	lds	si,[PARSE1_ADDR]
 17195                                  				;AN000; get address of filespec
 17196 00001A63 E83A12                  	call    Move_To_SrcBuf	;AN000; move to srcbuf
 17197 00001A66 5E                      	pop	si		;AN000; restore position in line
 17198                                  
 17199 00001A67 31D2                    	xor	dx,dx		;AN000; clear dx
 17200 00001A69 E84607                  	call	Parse_With_Msg	;AC018; call parser
 17201                                  	;cmp	ax,RESULT_NO_ERROR
 17202 00001A6C 21C0                    	and	ax,ax ; 0 ?	;AN000; did we have an error?
 17203 00001A6E 751A                    	jnz	short crename_parse_error
 17204                                  				;AN000; Yes, fail.
 17205                                  ;
 17206                                  ;  Check the second file name for drive letter colon
 17207                                  ;
 17208 00001A70 56                      	push	si		;AN000; save position in line
 17209 00001A71 C536[CF95]              	lds	si,[PARSE1_ADDR]
 17210                                  				;AC000; get address of path
 17211                                  	;mov	al,':'		;AC000;
 17212                                  	;cmp	[si+1],al	;AC000; Does the 2nd parm have a drive spec?
 17213 00001A75 807C013A                	cmp	byte [si+1],':'
 17214 00001A79 7511                    	jnz	short ren_no_drive
 17215                                  				;AN000; Yes, error
 17216                                  	;mov	byte [msg_disp_class],2
 17217 00001A7B C606[2F7F]02            	mov	byte [msg_disp_class],parse_msg_class
 17218                                  				;AN000; set up parse error msg class
 17219 00001A80 BA[317F]                	mov	dx,extend_buf_ptr
 17220                                  				;AC000; get extended message pointer
 17221                                  	;mov	word [extend_buf_ptr],0Ah
 17222 00001A83 C706[317F]0A00          	mov	word [extend_buf_ptr],BadParm_Ptr
 17223                                  				;AN000; get "Invalid parameter" message number
 17224 00001A89 5E                      	pop	si		;AN000;
 17225                                  crename_parse_error:		;AC022;
 17226 00001A8A EB64                    	jmp	short errj	;AC000;
 17227                                  
 17228                                  ;  Get second file name returned from parse into the fCB. Save
 17229                                  ;  character after file name so we can later check to make sure it
 17230                                  ;  isn't a path character.
 17231                                  
 17232                                  ren_no_drive:
 17233 00001A8C BF6C00                  	mov	di,FCB+10h ; 6Ch
 17234                                  				;AC000; set up to parse second file name
 17235                                  	;mov	ax,(Parse_File_Descriptor SHL 8) OR 01H ;AC000;
 17236 00001A8F B80129                  	mov	ax,2901h
 17237 00001A92 CD21                    	int	21h		;AC000; do the function
 17238 00001A94 AC                      	lodsb			;AC000; Load char after filename
 17239 00001A95 A2[9B8C]                	mov	[One_Char_Val],al
 17240                                  				;AN000; save char after filename
 17241 00001A98 5E                      	pop	si		;AN000; get line position back
 17242                                  ;
 17243                                  ; We have source and target. See if any args beyond.
 17244                                  ;
 17245 00001A99 BF[A685]                	mov	di,PARSE_RENAME
 17246                                  				;AC000; get address of parse_rename
 17247 00001A9C E8FD06                  	call	parse_check_eol ;AC000; are we at end of line?
 17248 00001A9F 75E9                    	jnz	short crename_parse_error
 17249                                  				;AN000; no, fail.
 17250                                  
 17251 00001AA1 E8CF0B                  	call	PathCrunch
 17252 00001AA4 BA[427F]                	mov	dx,BADCPMES_PTR
 17253 00001AA7 74A1                    	jz	short errj2	; If 1st parm a dir, print error msg
 17254 00001AA9 730F                    	jnc	short notest3
 17255 00001AAB A1[0F8E]                	mov	ax,[Msg_Numb]	;AN022; get message number
 17256                                  	;cmp	ax,0		;AN022; was message flag set?
 17257 00001AAE 21C0                    	and	ax,ax ; 0 ?
 17258 00001AB0 758D                    	jnz	short extend_setup
 17259                                  				;AN022; yes - print out message
 17260                                  	;cmp	byte [DestIsDir],0
 17261 00001AB2 3806[A38C]              	cmp	[DestIsDir],al	; No CHDIRs worked
 17262 00001AB6 7402                    	jz	short notest3 	; see if they should have
 17263 00001AB8 EB82                    	Jmp	badpath_err	;AC022; set up error
 17264                                  notest3:
 17265 00001ABA A0[9B8C]                	mov	al,[One_Char_Val]
 17266                                  				;AN000; move char into AX
 17267 00001ABD BA[607F]                	mov	dx,INORNOT_PTR 
 17268                                  				; Load invalid fname error ptr
 17269 00001AC0 E8A20B                  	call	pathchrcmp	; Is the char in al a path sep?
 17270 00001AC3 742B                    	jz	short errj	; Yes, error - 2nd arg must be
 17271                                  				;  filename only.
 17272                                  	;mov	ah,FCB_Rename
 17273 00001AC5 B417                    	mov	ah,17h
 17274 00001AC7 BA5C00                  	mov	dx,FCB ; 5Ch
 17275 00001ACA CD21                    	int	21h
 17276 00001ACC 3CFF                    	cmp	al,0FFh		; Did an error occur??
 17277 00001ACE 7506                    	jne	short renameok
 17278                                  
 17279 00001AD0 E82902                  	call	get_ext_error_number
 17280                                  				;AN022; get extended error
 17281 00001AD3 50                      	push	ax		;AC022; Save results
 17282 00001AD4 B0FF                    	mov	al,0FFh		; Restore original error state
 17283                                  renameok:
 17284 00001AD6 50                      	push	ax
 17285 00001AD7 E8AD09                  	call	RestUDir
 17286 00001ADA 58                      	pop	ax
 17287 00001ADB FEC0                    	inc	al
 17288                                  	;;retnz
 17289                                  	;jz	short rn1
 17290                                  	;retn	
 17291 00001ADD 7514                    	jnz	short ret56
 17292                                  rn1:
 17293 00001ADF 58                      	pop	ax		;AC022; get the error number back
 17294 00001AE0 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2 
 17295                                  				;AN022; error file not found?
 17296 00001AE3 7408                    	jz	short use_renerr
 17297                                  				;AN022; yes - use generic error message
 17298 00001AE5 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5 
 17299                                  				;AN022; error file not found?
 17300 00001AE8 7403                    	jz	short use_renerr
 17301                                  				;AN022; yes - use generic error message
 17302 00001AEA E952FF                  	jmp	extend_setup	;AN022; need long jump - use extended error
 17303                                  
 17304                                  use_renerr:
 17305 00001AED BA[3F7F]                	mov	dx,RENERR_PTR	;AC022;
 17306                                  errj:
 17307 00001AF0 E9580E                  	jmp	cerror
 17308                                  ret56:
 17309                                  ;typefil_ret:	; 20/02/2023 ; 17/04/2023	
 17310 00001AF3 C3                      	retn
 17311                                  
 17312                                  ; 20/02/2023
 17313                                  %if 0
 17314                                  	; MSDOS 3.3
 17315                                  	mov	dx,BADARGSPTR
 17316                                  	call	SCANOFF
 17317                                  	cmp	al,0Dh
 17318                                  	jz	short ERRJ2
 17319                                  	call	PATHCRUNCH
 17320                                  	mov	dx,BADCPMESPTR
 17321                                  	jz	short ERRJ2
 17322                                  	jnb	short CRENAME_NO_PARSE_ERROR
 17323                                  	cmp	byte [DESTISDIR],0 ; No CHDIRs worked	
 17324                                  	jz	short CRENAME_NO_PARSE_ERROR ; see if they should have
 17325                                  	jmp	short BADCDERR
 17326                                  
 17327                                  ;  Get first file name returned from parse into our buffer
 17328                                  
 17329                                  CRENAME_NO_PARSE_ERROR:
 17330                                  	mov	si,[PATHPOS]
 17331                                  	call	SCANOFF
 17332                                  	cmp	al,0Dh
 17333                                  	mov	dx,BADARGSPTR
 17334                                  	jz	short ERRJ
 17335                                  	mov	al,':'
 17336                                  	mov	dx,BADPARMPTR
 17337                                  	cmp	[si+1],al
 17338                                  	jz	short ERRJ
 17339                                  
 17340                                  ;  Get second file name returned from parse into the FCB. Save
 17341                                  ;  character after file name so we can later check to make sure it
 17342                                  ;  isn't a path character.
 17343                                  
 17344                                  REN_NO_DRIVE:
 17345                                  	;mov	di,6Ch
 17346                                  	mov	di,FCB+10h
 17347                                  	mov	ax,(Parse_File_Descriptor<<8)|01h ; 2901h
 17348                                  	int	21h	; DOS -	PARSE FILENAME
 17349                                  			; DS:SI	-> string to parse
 17350                                  			; ES:DI	-> buffer to fill with unopened	FCB
 17351                                  			; AL = bit mask	to control parsing
 17352                                  	mov	al,' '
 17353                                  	;cmp	[6Dh],al
 17354                                  	cmp	[FCB+10h+1],al	; Check if parameter exists
 17355                                  	jz	short ERRJ	; Error if missing parameter
 17356                                  	lodsb
 17357                                  	mov	dx,INORNOTPTR
 17358                                  	call	PATHCHRCMP
 17359                                  	jz	short ERRJ
 17360                                  	mov	ah,FCB_RENAME ; 17h
 17361                                  	mov	dx,FCB ; 5Ch
 17362                                  	int	21h	; DOS -	RENAME FILE via	FCB
 17363                                  			; DS:DX	-> FCB
 17364                                  			; FCB contains new name	starting at byte 17h.
 17365                                  	cmp	al,0FFh		; Did an error occur??	
 17366                                  	jnz	short RENAMEOK
 17367                                  	stc
 17368                                  	mov	dx,RENERRPTR
 17369                                  	call	GET_EXT_ERR_NUMBER ; get extended error
 17370                                  	push	dx
 17371                                  	mov	al,0FFh		; Restore original error state
 17372                                  RENAMEOK:
 17373                                  	push	ax
 17374                                  	call	RESTUDIR
 17375                                  	pop	ax
 17376                                  	inc	al
 17377                                  	jz	short RENAME_ERR
 17378                                  RENAME_RETN:
 17379                                  TYPELP_RET:
 17380                                  	retn
 17381                                  RENAME_ERR:
 17382                                  	pop	dx
 17383                                  ERRJ:				; Retro DOS v3.0
 17384                                  	call	STD_EPRINTF
 17385                                  	jmp	TCOMMAND
 17386                                  
 17387                                  ; ---------------------------------------------------------------------------
 17388                                  
 17389                                  ;ERRJ:
 17390                                  ;	jmp	CERROR
 17391                                  
 17392                                  ; ---------------------------------------------------------------------------
 17393                                  
 17394                                  ;TYPELP_RET:
 17395                                  ;	retn
 17396                                  
 17397                                  %endif
 17398                                  
 17399                                  ; ---------------------------------------------------------------------------
 17400                                  
 17401                                  ;****************************************************************
 17402                                  ;*
 17403                                  ;* ROUTINE:	TYPEFIL - Display the contents of a file to the
 17404                                  ;*		standard output device
 17405                                  ;*
 17406                                  ;* SYNTAX:	TYPE filespec
 17407                                  ;*
 17408                                  ;* FUNCTION:	If a valid filespec is found, read the file until
 17409                                  ;*		1Ah and display the contents to STDOUT.
 17410                                  ;*
 17411                                  ;* INPUT:	command line at offset 81H
 17412                                  ;*
 17413                                  ;* OUTPUT:	none
 17414                                  ;*
 17415                                  ;****************************************************************
 17416                                  
 17417                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17418                                  TYPEFIL:
 17419                                  	; MSDOS 6.0	
 17420                                  	;assume	ds:trangroup,es:trangroup
 17421                                  
 17422 00001AF4 BE8100                  	mov	si,81h
 17423 00001AF7 BF[1D85]                	mov	di,PARSE_MRDIR
 17424                                  				;AN000; Get address of PARSE_MRDIR
 17425 00001AFA 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17426 00001AFC 31D2                    	xor	dx,dx		;AN000;
 17427 00001AFE E8B106                  	call	Parse_With_Msg	;AC018; call parser
 17428                                  	;cmp	ax,RESULT_NO_ERROR
 17429 00001B01 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 17430 00001B03 751E                    	jnz	short typefil_parse_error
 17431                                  				;AN000; yes - issue error message
 17432                                  
 17433 00001B05 56                      	push	si		;AC000; save position in line
 17434 00001B06 C536[CF95]              	lds	si,[PARSE1_ADDR]
 17435                                  				;AC000; get address of filespec
 17436 00001B0A E89311                  	call	Move_To_SrcBuf	;AC000; move to srcbuf
 17437 00001B0D 5E                      	pop	si		;AC000; get position back
 17438 00001B0E BF[1D85]                	mov	di,PARSE_MRDIR
 17439                                  				;AC000; get address of parse_mrdir
 17440 00001B11 E88806                  	call	parse_check_eol ;AC000; are we at end of line?
 17441                                  	;jz	short gottarg 	;AC000; yes - continue
 17442                                  	; 20/02/2023
 17443                                  ;typefil_parse_error:		;AN000; no - set up error message and exit
 17444                                  	;jmp	cerror
 17445 00001B14 750D                    	jnz	short typefil_parse_error
 17446                                  gottarg:
 17447 00001B16 E8CC0F                  	call	SETPATH
 17448 00001B19 F606[A78C]02            	test	byte [DestInfo],00000010b ; 2
 17449                                  				; Does the filespec contain wildcards
 17450 00001B1E 7406                    	jz	short nowilds 	; No, continue processing
 17451 00001B20 BA[607F]                	mov	dx,INORNOT_PTR	; Yes, report error
 17452                                  	; 20/02/2023
 17453                                  typefil_parse_error:
 17454 00001B23 E9250E                  	jmp	cerror
 17455                                  nowilds:
 17456                                  	;mov	ax,ExtOpen SHL 8 ;AC000; open the file
 17457 00001B26 B8006C                  	mov	ax,6C00h
 17458                                  	;mov	bx,read_open_mode ; 0
 17459                                  				;AN000; get open mode for TYPE
 17460 00001B29 31C9                    	xor	cx,cx		;AN000; no special files
 17461 00001B2B 89CB                    	mov	bx,cx ; 20/02/2023
 17462 00001B2D BA0101                  	mov	dx,101h
 17463                                  	;mov	dx,read_open_flag ; 101h
 17464                                  				;AN000; set up open flags
 17465 00001B30 BE[0B8D]                	mov	si,SrcBuf	;AN030; get file name
 17466 00001B33 CD21                    	int	21h
 17467 00001B35 7313                    	jnc	short typecont	; If open worked, continue. Otherwise load
 17468                                  
 17469                                  typerr: 			;AN022;
 17470 00001B37 0E                      	push	cs		;AN022; make sure we have local segment
 17471 00001B38 1F                      	pop	ds		;AN022;
 17472 00001B39 E8B001                  	call	Set_Ext_Error_Msg ;AN022;
 17473 00001B3C C706[8C8C][0B8D]        	mov	word [string_ptr_2],SrcBuf 
 17474                                  				;AC022; get address of failed string
 17475                                  	;mov	byte [extend_buf_sub],1
 17476 00001B42 C606[337F]01            	mov	byte [extend_buf_sub],one_subst
 17477                                  				;AC022; put number of subst in control block
 17478 00001B47 E9010E                  	jmp	cerror		;AC022; exit
 17479                                  
 17480                                  typecont:
 17481 00001B4A 89C3                    	mov	bx,ax		;AC000; get Handle
 17482                                  ;M043
 17483                                  ; We should do the LSEEK for filesize only if this handle belongs to a file
 17484                                  ;and not if it belongs to a device. If device, set TypeFilSiz+2 to -1 to
 17485                                  ;indicate it is a device.
 17486                                  ;
 17487                                  	;mov	ax,(IOCTL shl 8) or 0
 17488 00001B4C B80044                  	mov	ax,4400h
 17489 00001B4F CD21                    	int	21h
 17490                                  
 17491 00001B51 F6C280                  	test	dl,80h		;is it a device?
 17492 00001B54 7408                    	jz	short not_device
 17493                                  				;no, a file
 17494                                  
 17495 00001B56 C706[C995]FFFF          	mov	word [TypeFilSiz+2],-1
 17496                                  				;indicate it is a device
 17497 00001B5C EB17                    	jmp	short dotype
 17498                                  not_device:
 17499                                  ;SR;
 17500                                  ; Find the filesize by seeking to the end and then reset file pointer to
 17501                                  ;start of file
 17502                                  
 17503                                  	;mov	ax,(LSEEK shl 8) or 2
 17504 00001B5E B80242                  	mov	ax,4202h
 17505 00001B61 31D2                    	xor	dx,dx
 17506 00001B63 89D1                    	mov	cx,dx		;seek  to end of file
 17507 00001B65 CD21                    	int	21h
 17508                                  
 17509 00001B67 A3[C795]                	mov	[TypeFilSiz],ax
 17510 00001B6A 8916[C995]              	mov	[TypeFilSiz+2],dx ;store filesize
 17511                                  	;mov	ax,(LSEEK shl 8) or 0
 17512 00001B6E B80042                  	mov	ax,4200h
 17513 00001B71 31D2                    	xor	dx,dx
 17514 00001B73 CD21                    	int	21h	        ;reset file pointer to start
 17515                                  dotype:				;M043
 17516 00001B75 C606[7994]00            	mov	byte [zflag],0 	; Reset ^Z flag
 17517 00001B7A 8E1E[9E8A]              	mov	ds,[TPA]
 17518 00001B7E 31D2                    	xor	dx,dx
 17519                                  	;ASSUME	DS:NOTHING
 17520                                  typelp:
 17521 00001B80 2E803E[7994]00          	cmp	byte [cs:zflag],0
 17522                                  				;AC050; Is the ^Z flag set?
 17523                                  	;retnz			; Yes, return
 17524                                  	; 17/04/2023
 17525 00001B86 7401                    	jz	short tf1
 17526 00001B88 C3                      	retn
 17527                                  tf1:
 17528 00001B89 2E8B0E[BD8A]            	mov	cx,[cs:BYTCNT]	;AC056; No, continue
 17529                                  
 17530                                  ;Update the filesize left to read
 17531                                  
 17532 00001B8E 2E833E[C995]FF          	cmp	word [cs:TypeFilSiz+2],-1
 17533                                  				;is it a device? M043
 17534 00001B94 7431                    	je	short typ_read	;yes, just read from it; M043
 17535                                  
 17536 00001B96 2E833E[C995]00          	cmp	word [cs:TypeFilSiz+2],0
 17537                                  				;more than 64K left?
 17538 00001B9C 740D                    	jz	short lt64k	;no, do word subtraction
 17539 00001B9E 2E290E[C795]            	sub	[cs:TypeFilSiz],cx
 17540 00001BA3 2E831E[C995]00          	sbb	word [cs:TypeFilSiz+2],0
 17541                                  				;update filesize
 17542 00001BA9 EB1C                          	jmp	short typ_read	;do the read
 17543                                  lt64k:
 17544 00001BAB 2E3B0E[C795]            	cmp	cx,[cs:TypeFilSiz]
 17545                                  				;readsize <= buffer?
 17546 00001BB0 7610                    	jbe	short gtbuf	; yes, just update readsize
 17547                                  
 17548                                  ;Buffer size is larger than bytes to read
 17549                                  
 17550 00001BB2 2E8B0E[C795]            	mov	cx,[cs:TypeFilSiz]
 17551 00001BB7 E361                    	jcxz	typelp_ret
 17552 00001BB9 2EC706[C795]0000        	mov	word [cs:TypeFilSiz],0
 17553 00001BC0 EB05                    	jmp	short typ_read
 17554                                  gtbuf:
 17555 00001BC2 2E290E[C795]            	sub	[cs:TypeFilSiz],cx
 17556                                  				;update filesize remaining
 17557                                  typ_read:
 17558                                  	;mov	ah,read
 17559 00001BC7 B43F                    	mov	ah,3Fh
 17560 00001BC9 CD21                    	int	21h		
 17561 00001BCB 7303                    	jnc	short tf2	;M043
 17562 00001BCD E967FF                  	jmp	typerr		;M043
 17563                                  tf2:				;M043
 17564                                  ;M043;	jc	typerr		;AN022; Exit if error
 17565                                  
 17566 00001BD0 89C1                    	mov	cx,ax
 17567 00001BD2 E346                    	jcxz	typelp_ret	;AC000; exit if nothing read
 17568 00001BD4 1E                      	push	ds
 17569 00001BD5 07                      	pop	es		; Check to see if a ^Z was read.
 17570                                  	;assume es:nothing
 17571 00001BD6 31FF                    	xor	di,di
 17572 00001BD8 50                      	push	ax
 17573 00001BD9 B01A                    	mov	al,1Ah
 17574 00001BDB F2AE                    	repnz	scasb
 17575 00001BDD 58                      	pop	ax
 17576 00001BDE 91                      	xchg	ax,cx
 17577                                  	;cmp	ax,0
 17578 00001BDF 21C0                    	and	ax,ax
 17579 00001BE1 7506                    	jnz	short foundz	; Yes, handle it
 17580 00001BE3 807DFF1A                	cmp	byte [di-1],1Ah	; No, double check
 17581 00001BE7 750A                    	jnz	short typecont2	; No ^Z, continue
 17582                                  foundz:
 17583 00001BE9 29C1                    	sub	cx,ax		; Otherwise change cx so that only those
 17584 00001BEB 49                      	dec	cx		;  bytes up to but NOT including the ^Z
 17585 00001BEC 0E                      	push	cs		;  will be typed.
 17586 00001BED 07                      	pop	es
 17587                                  	;assume es:trangroup
 17588 00001BEE 26F616[7994]            	not	byte [es:zflag]	; Turn on ^Z flag so that the routine
 17589                                  typecont2:			;  will quit after this write.
 17590 00001BF3 53                      	push	bx
 17591 00001BF4 BB0100                  	mov	bx,1
 17592                                  	;mov	ah,Write
 17593 00001BF7 B440                    	mov	ah,40h
 17594 00001BF9 CD21                    	int	21h
 17595 00001BFB 5B                      	pop	bx
 17596 00001BFC 720C                    	jc	short Error_outputj
 17597 00001BFE 39C8                    	cmp	ax,cx
 17598 00001C00 7503                    	jnz	short tf3	;M043
 17599 00001C02 E97BFF                  	jmp	typelp		;M043
 17600                                  tf3:				;M043
 17601                                  ;M043;	jz	short typelp
 17602 00001C05 49                      	dec	cx
 17603 00001C06 39C8                    	cmp	ax,cx
 17604                                  	;;retz			; One less byte OK (^Z)
 17605                                  	;jnz	short Error_outputj
 17606                                  ;tf4:
 17607                                  	;retn
 17608 00001C08 7410                    	jz	short typelp_ret ; 20/02/2023
 17609                                  
 17610                                  Error_outputj:
 17611 00001C0A BB0100                  	mov	bx,1
 17612                                  	;mov	ax,IOCTL SHL 8
 17613 00001C0D B80044                  	mov	ax,4400h
 17614 00001C10 CD21                    	int	21h
 17615 00001C12 F6C280                  	test	dl,80h
 17616                                  	;test	dl,devid_ISDEV
 17617                                  	;;retnz			; If device, no error message
 17618                                  	;jnz	short tf4
 17619 00001C15 7503                    	jnz	short typelp_ret
 17620 00001C17 E9310A                  	jmp	error_output
 17621                                  typelp_ret:
 17622 00001C1A C3                      	retn
 17623                                  
 17624                                  ; 20/02/2023
 17625                                  %if 0
 17626                                  	; MSDOS 3.3
 17627                                  	mov	si,81h
 17628                                  	call	SCANOFF		; Skip to first non-delim
 17629                                  	cmp	al,0Dh
 17630                                  	jnz	short GOTTARG
 17631                                  	mov	dx,BADARGSPTR
 17632                                  
 17633                                  	;jmp	CERROR
 17634                                  	jmp	short ERRJ	; No args
 17635                                  GOTTARG:
 17636                                  	call	SETPATH
 17637                                  	test	byte [DESTINFO],2
 17638                                  	jz	short NOWILDS
 17639                                  	mov	dx,INORNOTPTR
 17640                                  
 17641                                  	;jmp	CERROR
 17642                                  	jmp	short ERRJ
 17643                                  NOWILDS:
 17644                                  	mov	ax,OPEN*256 ; 3D00h
 17645                                  	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 17646                                  			; DS:DX	-> ASCIZ filename
 17647                                  			; AL = access mode
 17648                                  			; 0 - read
 17649                                  	jnc	short TYPECONT
 17650                                  	mov	dx,FNOTFOUNDPTR
 17651                                  	cmp	ax,2
 17652                                  	jz	short ERRJ
 17653                                  	mov	dx,BADCPMESPTR
 17654                                  	stc
 17655                                  	call	GET_EXT_ERR_NUMBER
 17656                                  	
 17657                                  	;jmp	CERROR
 17658                                  	jmp	short ERRJ
 17659                                  TYPECONT:
 17660                                  	mov	byte [ZFLAG],0	; Reset ^Z flag
 17661                                  	mov	bx,ax		; Handle
 17662                                  	mov	ds,[TPA]
 17663                                  	xor	dx,dx
 17664                                  TYPELP:
 17665                                  	cmp	byte [cs:ZFLAG],0 ; Is the ^Z flag set?		
 17666                                  	jnz	short RENAME_RETN ; Yes, return	
 17667                                  	mov	cx,[cs:BYTCNT]	; No, continue
 17668                                  	mov	ah,READ ; 3Fh
 17669                                  	int	21h	; DOS -	2+ - READ FROM FILE WITH HANDLE
 17670                                  			; BX = file handle,CX = number	of bytes to read
 17671                                  			; DS:DX	-> buffer
 17672                                  	mov	cx,ax
 17673                                  	jcxz	TYPELP_RET	; exit if nothing read
 17674                                  				; Check to see if a ^Z was read.
 17675                                  	push	ds
 17676                                  	pop	es		
 17677                                  	xor	di,di
 17678                                  	push	ax
 17679                                  	mov	al,1Ah
 17680                                  	repne	scasb
 17681                                  	pop	ax
 17682                                  	xchg	ax,cx
 17683                                  	cmp	ax,0
 17684                                  	jnz	short FOUNDZ	; Yes, handle it
 17685                                  	cmp	byte [di-1],1Ah	; No, double check
 17686                                  	jnz	short TYPECONT2	; No ^Z, continue
 17687                                  FOUNDZ:
 17688                                  	sub	cx,ax		; Otherwise change cx so that only those
 17689                                  	dec	cx		;  bytes up to but NOT including the ^Z
 17690                                  	push	cs		;  will be typed.
 17691                                  	pop	es
 17692                                  	not	byte [cs:ZFLAG]	; Turn on ^Z flag so that the routine
 17693                                  				;  will quit after this write.
 17694                                  TYPECONT2:
 17695                                  	push	bx
 17696                                  	mov	bx,1
 17697                                  	mov	ah,WRITE ; 40h
 17698                                  	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 17699                                  			; BX = file handle, CX = number of bytes to write,
 17700                                  			; DS:DX -> buffer
 17701                                  	pop	bx
 17702                                  	jc	short ERROR_OUTPUTJ
 17703                                  	cmp	ax,cx
 17704                                  	jz	short TYPELP
 17705                                  	dec	cx
 17706                                  	cmp	ax,cx		; One less byte OK (^Z)
 17707                                  	jnz	short ERROR_OUTPUTJ
 17708                                  TYPEFIL_RETN:
 17709                                  	retn
 17710                                  ERROR_OUTPUTJ:
 17711                                  	mov	bx,1
 17712                                  	mov	ax,IOCTL*256 ; 4400h
 17713                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 17714                                  			; BX = file or device handle
 17715                                  	;test	dl,devid_ISDEV
 17716                                  	test	dl,80h
 17717                                  	jnz	short TYPEFIL_RETN ; If device, no error message
 17718                                  	jmp	ERROR_OUTPUT
 17719                                  %endif
 17720                                  
 17721                                  ; ---------------------------------------------------------------------------
 17722                                  
 17723                                  ; VOLUME command displays the volume ID on the specified drive
 17724                                  
 17725                                  	; 20/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17726                                  	; 10/06/2023
 17727                                  VOLUME:
 17728                                  	; MSDOS 6.0
 17729 00001C1B BE8100                  	mov	si,81h
 17730 00001C1E BF[0B85]                	mov	di,PARSE_VOL
 17731                                  				;AN000; Get address of PARSE_VOL
 17732 00001C21 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 17733 00001C23 31D2                    	xor	dx,dx		;AN000;
 17734 00001C25 E88A05                  	call	Parse_With_Msg	;AC018; call parser
 17735                                  
 17736                                  	;cmp	ax,-1 ; 0FFFFh
 17737                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 17738                                  	;je	short OkVolArg	;AC000; Yes, display default volume ID
 17739                                  	;;cmp	ax,RESULT_NO_ERROR
 17740                                  	;;cmp	ax,0		;AC000; did we have an error?
 17741                                  	;or	ax,ax ; 0?
 17742                                  	;jnz	short badvolarg	;AC000; Yes, fail.
 17743                                  	; 10/06/2023
 17744 00001C28 40                      	inc	ax  ; cmp ax,-1
 17745 00001C29 7443                    	jz	short OkVolArg ; 0FFFFh -> 0
 17746 00001C2B 48                      	dec	ax  ; cmp ax,0
 17747 00001C2C 750A                    	jnz	short badvolarg ; 1 -> 0
 17748                                  	; ax = 0
 17749                                  
 17750                                  ; We have parsed off the drive. See if there are any more chars left
 17751                                  
 17752 00001C2E BF[0B85]                	mov	di,PARSE_VOL
 17753                                  				;AC000; get address of parse_vol
 17754 00001C31 31D2                    	xor	dx,dx		;AC000;
 17755 00001C33 E86605                  	call	parse_check_eol ;AC000; call parser
 17756 00001C36 7436                    	jz	short OkVolArg	;AC000; yes, end of road
 17757                                  
 17758                                  ; The line was not interpretable. Report an error.
 17759                                  
 17760                                  badvolarg:
 17761 00001C38 E9100D                  	jmp	cerror
 17762                                  
 17763                                  ; 20/02/2023
 17764                                  %if 0
 17765                                  	; MSDOS 3.3
 17766                                  	mov	si,81h
 17767                                  	call	SCANOFF		; Skip to first non-delim
 17768                                  	;mov	ah,[5Ch]
 17769                                  	mov	ah,[FCB]
 17770                                  	;mov	byte [5Ch],0
 17771                                  	mov	byte [FCB],0
 17772                                  	cmp	al,0Dh		; are we at end of line?
 17773                                  	jz	short OKVOLARG	; Yes, display default volume ID
 17774                                  	;mov	[5Ch],ah
 17775                                  	mov	[FCB],ah
 17776                                  	lodsb
 17777                                  	lodsb
 17778                                  	cmp	al,':'
 17779                                  	jnz	short VOLUME_ERR
 17780                                  	call	SCANOFF
 17781                                  	cmp	al,0Dh
 17782                                  	jz	short OKVOLARG
 17783                                  VOLUME_ERR:
 17784                                  	mov	dx,BADDRVPTR
 17785                                  	jmp	CERROR
 17786                                  
 17787                                  ; ---------------------------------------------------------------------------
 17788                                  
 17789                                  OKVOLARG:
 17790                                  	call	CRLF2
 17791                                  	push	ds
 17792                                  	pop	es
 17793                                  	;mov	di,55h
 17794                                  	mov	di,FCB-7	; Set up extended FCB
 17795                                  	mov	al,-1
 17796                                  	stosb
 17797                                  	xor	ax,ax
 17798                                  	stosw
 17799                                  	stosw
 17800                                  	stosb
 17801                                  	mov	al,8		; Look for volume label
 17802                                  	stosb
 17803                                  	inc	di		; Skip drive byte
 17804                                  	mov	cx,11
 17805                                  	mov	al,'?'
 17806                                  	rep stosb
 17807                                  	mov	dx,DIRBUF
 17808                                  	mov	ah,Set_DMA ; 1Ah
 17809                                  	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 17810                                  			; DS:DX	-> disk	transfer buffer
 17811                                  	;mov	dx,55h
 17812                                  	mov	dx,FCB-7
 17813                                  	mov	ah,Dir_Search_First ; 11h
 17814                                  	int	21h	; DOS -	SEARCH FIRST USING FCB
 17815                                  			; DS:DX	-> FCB
 17816                                  	jmp	PRINTVOL
 17817                                  %endif
 17818                                  
 17819                                  ; ---------------------------------------------------------------------------
 17820                                  
 17821                                  ;***	DisAppend - disable APPEND
 17822                                  ;
 17823                                  ;	ENTRY	nothing
 17824                                  ;
 17825                                  ;	EXIT	nothing
 17826                                  ;
 17827                                  ;	USED	AX,BX
 17828                                  ;
 17829                                  ;	EFFECTS
 17830                                  ;
 17831                                  ;	  APPEND is disabled. If it was active, it will be re-enabled
 17832                                  ;	  after the command finishes, by the HeadFix routine.
 17833                                  ;
 17834                                  ;	NOTE
 17835                                  ;
 17836                                  ;	  This routine must not be called more than once during a single
 17837                                  ;	  command cycle. The second call would permanently disable APPEND.
 17838                                  
 17839                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17840                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1CDFh
 17841                                  
 17842                                  	; MSDOS 6.0
 17843                                  DisAppend:
 17844 00001C3B 1E                      	push	ds			; save DS
 17845 00001C3C 06                      	push	es			; save ES
 17846 00001C3D 57                      	push	di
 17847                                  
 17848                                  	;mov	ax,APPENDINSTALL	; AX = Append Installed Check code
 17849 00001C3E B800B7                  	mov	ax,0B700h
 17850 00001C41 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17851 00001C43 08C0                    	or	al,al
 17852 00001C45 7423                    	jz	short daRet		; APPEND not installed, return
 17853                                  
 17854                                  	;mov	ax,APPENDDOS		; AX = Get Append Version code
 17855 00001C47 B802B7                  	mov	ax,0B702h
 17856 00001C4A CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17857 00001C4C 83F8FF                  	cmp	ax,0FFFFh
 17858 00001C4F 7519                    	jne	short daRet		; it's not a local version, return
 17859                                  
 17860                                  	;mov	ax,APPENDGETSTATE	; AX = Get Function State code
 17861 00001C51 B806B7                  	mov	ax,0B706h
 17862 00001C54 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17863                                  
 17864 00001C56 8E1E[9C8A]              	mov	ds,[RESSEG]		; DS = resident seg addr
 17865                                  
 17866 00001C5A 891E[C301]              	mov	[Append_State],bx	; Append_State = saved APPEND state
 17867 00001C5E C606[C501]FF            	mov	byte [Append_Flag],-1	; Append_Flag = true, restore state
 17868                                  
 17869 00001C63 31DB                    	xor	bx,bx			; BX = APPEND state = off
 17870                                  	;mov	ax,APPENDSETSTATE	; AX = Set Append State code
 17871 00001C65 B807B7                  	mov	ax,0B707h
 17872 00001C68 CD2F                    	int	2Fh			; talk to APPEND via multiplex
 17873                                  daRet:	
 17874 00001C6A 5F                      	pop	di
 17875 00001C6B 07                      	pop	es			; restore ES
 17876 00001C6C 1F                      	pop	ds			; restore DS
 17877                                  
 17878 00001C6D C3                      	retn
 17879                                  
 17880                                  ; ---------------------------------------------------------------------------
 17881                                  
 17882                                  ; Find the Volume ID on the disk.
 17883                                  
 17884                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17885                                  
 17886                                  	; MSDOS 6.0
 17887                                  OkVolArg:
 17888 00001C6E E8CAFF                  	call	DisAppend		; disable APPEND
 17889 00001C71 E85609                  	call	CRLF2
 17890                                  	;mov	al,blank			
 17891 00001C74 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 17892 00001C76 E87D01                  	call	PRINT_CHAR		;AN051;  before volume message
 17893 00001C79 1E                      	push	ds
 17894 00001C7A 07                      	pop	es
 17895                                  
 17896                                  ; Volume IDs are only findable via extended FCBs or find_first with attributes
 17897                                  ; of volume_id ONLY.
 17898                                  
 17899 00001C7B BF5500                  	mov	di,FCB-7 ; 55h		; Point to extended FCB beginning
 17900 00001C7E B0FF                    	mov	al,-1			; Tag to indicate Extention
 17901 00001C80 AA                      	stosb
 17902 00001C81 31C0                    	xor	ax,ax			; Zero padding to volume label
 17903 00001C83 AB                      	stosw
 17904 00001C84 AB                      	stosw
 17905 00001C85 AA                      	stosb
 17906 00001C86 B008                    	mov	al,ATTR_VOLUME_ID ; 8	; Look for volume label
 17907 00001C88 AA                      	stosb
 17908 00001C89 47                      	inc	di			; Skip drive byte; it is already set
 17909 00001C8A B90B00                  	mov	cx,11			; fill in remainder of file
 17910 00001C8D B03F                    	mov	al,'?'
 17911 00001C8F F3AA                    	rep	stosb
 17912                                  
 17913                                  ; Set up transfer address (destination of search first information)
 17914                                  
 17915 00001C91 BA[A58B]                	mov	dx,DIRBUF
 17916                                  	;mov	ah,Set_DMA
 17917 00001C94 B41A                    	mov	ah,1Ah
 17918 00001C96 CD21                    	int	21h
 17919                                  
 17920                                  ; Do the search
 17921                                  
 17922 00001C98 BA5500                  	mov	dx,FCB-7 ; 55h
 17923                                  	;mov	ah,Dir_Search_First
 17924 00001C9B B411                    	mov	ah,11h
 17925 00001C9D CD21                    	int	21h
 17926                                  
 17927                                  ;********************************
 17928                                  ; Print volume ID info
 17929                                  
 17930 00001C9F 50                      	push	ax			;AC000; AX return from SEARCH_FIRST for VOL ID
 17931 00001CA0 A05C00                  	mov	al,[FCB]  ; [5Ch]	;AC000; get drive letter
 17932 00001CA3 0440                    	add	al,'@'  ; add al,40h
 17933 00001CA5 3C40                    	cmp	al,'@'
 17934 00001CA7 7505                    	jne	short drvok
 17935 00001CA9 A0[B08A]                	mov	al,[CURDRV]
 17936                                  	;add	al,capital_A
 17937 00001CAC 0441                    	add	al,'A'
 17938                                  drvok:
 17939 00001CAE A2[9D8C]                	mov	[vol_drv],al		;AC000; get drive letter into argument
 17940 00001CB1 58                      	pop	ax			;AC000; get return code back
 17941 00001CB2 08C0                    	or	al,al			;AC000; volume label found?
 17942 00001CB4 7405                    	jz	short Get_vol_name	;AC000; volume label exists - go get it
 17943 00001CB6 BA[2C80]                	mov	dx,VolMes_Ptr_2		;AC000; set up no volume message
 17944 00001CB9 EB13                    	jmp	short print_serial	;AC000; go print it
 17945                                  
 17946                                  Get_vol_name:
 17947 00001CBB BF[D68A]                	mov	di,CHARBUF
 17948 00001CBE 89FA                    	mov	dx,di
 17949 00001CC0 BE[AD8B]                	mov	si,DIRBUF+8		;AN000;  3/3/KK
 17950 00001CC3 B90B00                  	mov	cx,11			;AN000;  3/3/KK
 17951 00001CC6 F3A4                    	rep	movsb			;AN000;  3/3/KK
 17952                                  
 17953 00001CC8 30C0                    	xor	al,al			;AC000; store a zero to terminate the string
 17954 00001CCA AA                      	stosb
 17955 00001CCB BA[3A80]                	mov	dx,VolMes_Ptr		;AC000; set up message
 17956                                  
 17957                                  print_serial:
 17958                                  
 17959                                  ; Attempt to get the volume serial number from the disk. If an error
 17960                                  ; occurs, do not print volume serial number.
 17961                                  
 17962 00001CCE 52                      	push	dx			;AN000; save message offset
 17963                                  	;mov	ax,(GetSetMediaID SHL 8)
 17964 00001CCF B80069                  	mov	ax,6900h		;AC036; Get the volume serial info
 17965 00001CD2 8A1E5C00                	mov	bl,[FCB] ; [5Ch]	;AN000; get drive number from FCB
 17966 00001CD6 BA[F48D]                	mov	dx,vol_ioctl_buf	;AN000;target buffer
 17967 00001CD9 CD21                    	int	21h			;AN000; do the call
 17968                                  			; DOS - 4.0 internal - GET/SET DISK SERIAL NUMBER
 17969                                  			; AL = 00h get serial number / 01h set serial number
 17970                                  			; BL = drive (0=default, 1=A, 2=B, etc)
 17971                                  			; DS:DX -> disk info
 17972 00001CDB 5A                      	pop	dx			;AN000; get message offset back
 17973 00001CDC 720B                    	jc	short printvol_end	;AN000; if error, just go print label
 17974 00001CDE E82231                  	call	std_printf		;AC000; go print volume message
 17975                                  	;mov	al,blank				
 17976 00001CE1 B020                    	mov	al,' ' ; 20h		;AN051; Print out a blank
 17977 00001CE3 E81001                  	call	PRINT_CHAR		;AN051;  before volume message
 17978 00001CE6 BA[5380]                	mov	dx,VolSerMes_Ptr 	;AN000; get serial number message
 17979                                  printvol_end:
 17980 00001CE9 E91731                  	jmp	std_printf		;AC000; go print and exit
 17981                                  
 17982                                  ; ---------------------------------------------------------------------------
 17983                                  
 17984                                  ;****************************************************************
 17985                                  ;*
 17986                                  ;* ROUTINE:	Set_ext_error_msg
 17987                                  ;*
 17988                                  ;* FUNCTION:	Sets up extended error message for printing
 17989                                  ;*
 17990                                  ;* INPUT:	return from INT 21
 17991                                  ;*
 17992                                  ;* OUTPUT:	extended error message set up in extended error
 17993                                  ;*		buffer.
 17994                                  ;*
 17995                                  ;****************************************************************
 17996                                  	
 17997                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 17998                                  
 17999                                  	; MSDOS 6.0
 18000                                  Set_Ext_Error_Msg:			;AN000;
 18001 00001CEC E80D00                  	call	get_ext_error_number	;AC022; get the extended error
 18002 00001CEF C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class
 18003                                  	;mov	byte [msg_disp_class],1	;AN000; set up extended error msg class
 18004 00001CF4 BA[317F]                	mov	dx,extend_buf_ptr 	;AC000; get extended message pointer
 18005 00001CF7 A3[317F]                	mov	[extend_buf_ptr],ax	;AN000; get message number in control block
 18006 00001CFA F9                      	stc				;AN000; make sure carry is set
 18007 00001CFB C3                      	retn				;AN000; return
 18008                                  
 18009                                  ; ---------------------------------------------------------------------------
 18010                                  
 18011                                  ;****************************************************************
 18012                                  ;*
 18013                                  ;* ROUTINE:	Get_ext_error_number
 18014                                  ;*
 18015                                  ;* FUNCTION:	Does get extended error function call
 18016                                  ;*
 18017                                  ;* INPUT:	return from INT 21
 18018                                  ;*
 18019                                  ;* OUTPUT:	AX - extended error number
 18020                                  ;*
 18021                                  ;****************************************************************
 18022                                  
 18023                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18024                                  
 18025                                  	; MSDOS 6.0
 18026                                  get_ext_error_number:			;AN022;
 18027                                  
 18028                                  	;SaveReg <BX,CX,DX,SI,DI,BP,ES,DS>
 18029                                  					;AN022; save registers
 18030 00001CFC 53                      	push	bx
 18031 00001CFD 51                      	push	cx
 18032 00001CFE 52                      	push	dx
 18033 00001CFF 56                      	push	si
 18034 00001D00 57                      	push	di
 18035 00001D01 55                      	push	bp
 18036 00001D02 06                      	push	es
 18037 00001D03 1E                      	push	ds
 18038                                  	;mov	ah,GetExtendedError	;AN022; get extended error
 18039 00001D04 B459                    	mov	ah,59h
 18040 00001D06 31DB                    	xor	bx,bx			;AN022; clear BX
 18041 00001D08 CD21                    	int	21h			;AN022;
 18042                                  			; DOS - 3+ - GET EXTENDED ERROR CODE
 18043                                  			; BX = version code (0000h for DOS 3.x)
 18044                                  
 18045                                  	;RestoreReg  <DS,ES,BP,DI,SI,DX,CX,BX>
 18046                                  					;AN022; restore registers
 18047 00001D0A 1F                      	pop	ds
 18048 00001D0B 07                      	pop	es
 18049 00001D0C 5D                      	pop	bp
 18050 00001D0D 5F                      	pop	di
 18051 00001D0E 5E                      	pop	si
 18052 00001D0F 5A                      	pop	dx
 18053 00001D10 59                      	pop	cx
 18054 00001D11 5B                      	pop	bx
 18055                                  
 18056 00001D12 C3                      	retn				;AN022; return
 18057                                  
 18058                                  ;============================================================================
 18059                                  ; TCMD2A.ASM, MSDOS 6.0, 1991
 18060                                  ;============================================================================
 18061                                  ; 08/10/2018 - Retro DOS v3.0
 18062                                  
 18063                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1379h
 18064                                  
 18065                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 18066                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 1DB7h
 18067                                  
 18068                                  ; ---------------------------------------------------------------------------
 18069                                  
 18070                                  ; MSDOS 6.0
 18071                                  ;***	Version - display DOS version
 18072                                  ;
 18073                                  ;	SYNTAX	ver [/debug]
 18074                                  ;
 18075                                  ;		/debug - display additional DOS configuration info
 18076                                  ;
 18077                                  ;	ENTRY	command-line tail is in PSP
 18078                                  ;
 18079                                  ;	EXIT	if successful, nothing
 18080                                  ;		if parse fails,
 18081                                  ;		  parse error message is set up (for Std_EPrintf)
 18082                                  ;		    AX = system parser error code
 18083                                  ;		    DX = ptr to message block
 18084                                  ;		  we jump to CError
 18085                                  ;
 18086                                  ;	EFFECTS
 18087                                  ;	  If parse fails, a parse error message is displayed.
 18088                                  ;	  Otherwise, version message is displayed.
 18089                                  ;	  If /debug is specified, additional DOS info is displayed.
 18090                                  
 18091                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18092                                  VERSION:
 18093                                  	;assume	ds:TRANGROUP,es:TRANGROUP
 18094                                  
 18095                                  ;	Parse command line for /debug switch.
 18096                                  
 18097 00001D13 BE8100                  	mov	si,81h			; DS:SI = ptr to command tail
 18098 00001D16 BF[C385]                	mov	di,PARSE_VER		; ES:DI = ptr to parse block
 18099 00001D19 31C9                    	xor	cx,cx			; CX = # positional param's found
 18100 00001D1B E89404                  	call	Parse_With_Msg
 18101                                  
 18102 00001D1E B301                    	mov	bl,1			; BL = flag = /debug present
 18103                                  	;cmp	ax,RESULT_NO_ERROR
 18104                                  	;cmp	ax,0
 18105                                  	;je	short verPrintVer	; something parsed - must be /debug
 18106 00001D20 09C0                    	or	ax,ax
 18107 00001D22 740A                    	jz	short verPrintVer 
 18108 00001D24 FECB                    	dec	bl			; BL = flag = no /debug present
 18109                                  	;cmp	ax,END_OF_LINE ; -1
 18110 00001D26 83F8FF                  	cmp	ax,-1 ; 0FFFFh
 18111 00001D29 7403                    	je	short verPrintVer	; reached end of line - ok
 18112                                  
 18113                                  ;	The parse failed. Error message has been set up.
 18114                                  
 18115 00001D2B E91D0C                  	jmp	cerror
 18116                                  
 18117                                  verPrintVer:
 18118 00001D2E 53                      	push	bx			; save /debug flag
 18119 00001D2F E89808                  	call	CRLF2
 18120 00001D32 E83F00                  	call	PRINT_VERSION
 18121 00001D35 E89208                  	call	CRLF2
 18122 00001D38 5B                      	pop	bx   			; BL = /debug flag
 18123 00001D39 08DB                    	or	bl,bl
 18124 00001D3B 7434                    	jz	short verDone		; /debug is false - we're done
 18125                                  
 18126                                  ;*	For /debug, display DOS internal revision and DOS location
 18127                                  ;	(low memory, HMA, or ROM).
 18128                                  
 18129                                  ;	Bugbug:	use symbols for bitmasks below.
 18130                                  
 18131                                  	;mov	ax,(Set_CTRL_C_Trapping shl 8) + 6 ; M013
 18132 00001D3D B80633                  	mov	ax,3306h
 18133 00001D40 CD21                    	int	21h
 18134                                  		; DOS - 5+ Get TRUE Version Number
 18135                                  		; (BL major, BH minor, DL revision, DH flags)
 18136 00001D42 88D0                    	mov	al,dl			;revision number in dl; M013
 18137 00001D44 88F7                    	mov	bh,dh			;flags in dh now; M013
 18138                                  ;M032	and	al,7			; AL = DOS internal revision
 18139 00001D46 3C19                    	cmp	al,'Z'-'A' ; 25	 ;M032	; revision in A-to-Z range?
 18140                                  	;jbe	short @f	 ;M032	; A-to-Z revision ok
 18141 00001D48 7602                    	jbe	short ver1
 18142 00001D4A B0E9                    	mov	al,'*'-'A' ; -23 ;M032	; beyond Z, just say revision *
 18143                                  ;@@:
 18144                                  ver1:
 18145 00001D4C 0441                    	add	al,'A' ; 41h		; AL = DOS internal rev letter
 18146 00001D4E A2[9B8C]                	mov	[One_Char_Val],al
 18147 00001D51 BA[8181]                	mov	dx,dosrev_ptr
 18148 00001D54 E8AC30                  	call	std_printf		; print DOS internal revision
 18149                                  
 18150 00001D57 B104                    	mov	cl,4
 18151 00001D59 D2EF                    	shr	bh,cl			; CY = DOS in ROM
 18152 00001D5B 7209                    	jc	short verRom
 18153 00001D5D D0EF                    	shr	bh,1			; CY = DOS in HMA
 18154 00001D5F 720A                    	jc	short verHma
 18155                                  
 18156                                  ;	DOS isn't in ROM or HMA, so it must be in lower memory.
 18157                                  
 18158                                  	;mov	dx,offset TRANGROUP:DosLow_Ptr
 18159 00001D61 BA[9581]                	mov	dx,DosLow_Ptr
 18160 00001D64 EB08                    	jmp	short verPrintLoc
 18161                                  verRom: 
 18162                                  	;mov	dx,offset TRANGROUP:DosRom_Ptr
 18163 00001D66 BA[8F81]                	mov	dx,DosRom_Ptr
 18164 00001D69 EB03                    	jmp	short verPrintLoc
 18165                                  verHma: 
 18166                                  	;mov	dx,offset TRANGROUP:DosHma_Ptr
 18167 00001D6B BA[9281]                	mov	dx,DosHma_Ptr
 18168                                  verPrintLoc:
 18169 00001D6E E89230                  	call	std_printf
 18170                                  verDone:
 18171 00001D71 E95608                  	jmp	CRLF2
 18172                                  
 18173                                  ; 21/02/2023
 18174                                  ;	; MSDOS 3.3
 18175                                  ;VERSION:
 18176                                  ;	call	CRLF2
 18177                                  ;	call	PRINT_VERSION
 18178                                  ;	jmp	CRLF2
 18179                                  
 18180                                  ; =============== S U B	R O U T	I N E =======================================
 18181                                  
 18182                                  	; 21/02/2023 - Retro DOS v4.0
 18183                                  PRINT_VERSION:
 18184                                  	;mov	ah,GET_VERSION ; 30h
 18185 00001D74 B430                    	mov	ah,30h
 18186 00001D76 CD21                    	int	21h	; DOS -	GET DOS	VERSION
 18187                                  			; Return: AL = major version number (00h for DOS 1.x)
 18188 00001D78 50                      	push	ax
 18189 00001D79 30E4                    	xor	ah,ah
 18190 00001D7B A3[978C]                	mov	[Major_Ver_Num],ax
 18191 00001D7E 58                      	pop	ax
 18192 00001D7F 86E0                    	xchg	ah,al
 18193 00001D81 30E4                    	xor	ah,ah
 18194 00001D83 A3[998C]                	mov	[Minor_Ver_Num],ax
 18195 00001D86 BA[1380]                	mov	dx,VerMes_Ptr
 18196 00001D89 E97730                  	jmp	std_printf
 18197                                  
 18198                                  ; =============== S U B	R O U T	I N E =======================================
 18199                                  
 18200                                  	; 21/02/2023 - Retro DOS v4.0
 18201                                  PRINT_PROMPT:
 18202 00001D8C 1E                      	push	ds
 18203 00001D8D 0E                      	push	cs
 18204 00001D8E 1F                      	pop	ds		; Make sure DS is in TRANGROUP
 18205 00001D8F 06                      	push	es
 18206 00001D90 E87805                  	call	find_prompt	; Look for prompt string
 18207 00001D93 7206                    	jc	short PP0	; Can't find one	
 18208 00001D95 26803D00                	cmp	byte [es:di],0
 18209 00001D99 7524                    	jnz	short PP1
 18210                                  PP0:				; Use default prompt
 18211 00001D9B E86700                  	call	PRINT_DRIVE
 18212 00001D9E B03E                    	mov	al,'>'
 18213                                  	;mov	al,SYM
 18214 00001DA0 E85300                  	call	PRINT_CHAR
 18215 00001DA3 EB36                    	jmp	short PP5
 18216                                  ;PP1:
 18217                                  ;	mov	al,[es:di]	; Get a char
 18218                                  ;	inc	di
 18219                                  ;	or	al,al
 18220                                  ;	jz	short PP5	; Nul terminated
 18221                                  ;	; 21/02/2023
 18222                                  ;	cmp	al,'$' ; 24h
 18223                                  ;	;cmp	al,[DOLLAR]	; Meta character
 18224                                  ;	jz	short PP2	; Nope
 18225                                  ;	call	PRINT_CHAR
 18226                                  ;	jmp	short PP1
 18227                                  PP2:
 18228 00001DA5 268A05                  	mov	al,[es:di]
 18229 00001DA8 47                      	inc	di
 18230                                  	;mov	bx,CLSSTRING+2	; "[2J"
 18231 00001DA9 BB[9F82]                	mov	bx,PROMPT_TABLE-3
 18232 00001DAC 08C0                    	or	al,al
 18233 00001DAE 742B                    	jz	short PP5
 18234                                  PP3:
 18235 00001DB0 83C303                  	add	bx,3
 18236                                  	; 21/02/2023
 18237 00001DB3 E82C06                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 18238                                  	;call	UPCONV_MAPCALL  ; MSDOS 3.3
 18239 00001DB6 3A07                    	cmp	al,[bx]
 18240 00001DB8 7416                    	jz	short PP4
 18241 00001DBA 803F00                  	cmp	byte [bx],0
 18242 00001DBD 75F1                    	jnz	short PP3
 18243                                  	;jmp	short PP1
 18244                                  	; 21/02/2023
 18245                                  PP1:
 18246 00001DBF 268A05                  	mov	al,[es:di]	; Get a char
 18247 00001DC2 47                      	inc	di
 18248 00001DC3 08C0                    	or	al,al
 18249 00001DC5 7414                    	jz	short PP5	; Nul terminated
 18250                                  	; 21/02/2023
 18251 00001DC7 3C24                    	cmp	al,'$' ; 24h
 18252                                  	;cmp	al,[DOLLAR]	; Meta character
 18253 00001DC9 74DA                    	jz	short PP2	; Nope
 18254 00001DCB E82800                  	call	PRINT_CHAR
 18255 00001DCE EBEF                    	jmp	short PP1
 18256                                  PP4:
 18257 00001DD0 06                      	push	es
 18258 00001DD1 57                      	push	di
 18259 00001DD2 0E                      	push	cs
 18260 00001DD3 07                      	pop	es
 18261 00001DD4 FF5701                  	call	word [bx+1]
 18262 00001DD7 5F                      	pop	di
 18263 00001DD8 07                      	pop	es
 18264 00001DD9 EBE4                    	jmp	short PP1
 18265                                  PP5:
 18266 00001DDB 07                      	pop	es		; Restore segments
 18267 00001DDC 1F                      	pop	ds
 18268 00001DDD C3                      	retn
 18269                                  
 18270                                  ; ---------------------------------------------------------------------------
 18271                                  
 18272                                  PRINT_BACK:
 18273                                  	; 21/02/2023
 18274 00001DDE BA[0D81]                	mov	dx,dback_ptr
 18275 00001DE1 E91F30                  	jmp	std_printf
 18276                                  
 18277                                  ; ---------------------------------------------------------------------------
 18278                                  
 18279                                  PRINT_EQ:
 18280 00001DE4 B03D                    	mov	al,'='
 18281 00001DE6 EB0E                    	jmp	short PRINT_CHAR
 18282                                  
 18283                                  ; ---------------------------------------------------------------------------
 18284                                  
 18285                                  PRINT_ESC:
 18286 00001DE8 B01B                    	mov	al,1Bh
 18287 00001DEA EB0A                    	jmp	short PRINT_CHAR
 18288                                  
 18289                                  ; ---------------------------------------------------------------------------
 18290                                  
 18291                                  	; 21/02/2023
 18292                                  PRINT_G:
 18293                                  	;mov	al,[RABRACKET]
 18294 00001DEC B03E                    	mov	al,'>' ; 3Eh
 18295 00001DEE EB06                    	jmp	short PRINT_CHAR
 18296                                  
 18297                                  ; ---------------------------------------------------------------------------
 18298                                  
 18299                                  	; 21/02/2023
 18300                                  PRINT_L:
 18301                                  	;mov	al,[LABRACKET]
 18302 00001DF0 B03C                    	mov	al,'<' ; 3Ch
 18303 00001DF2 EB02                    	jmp	short PRINT_CHAR
 18304                                  
 18305                                  ; ---------------------------------------------------------------------------
 18306                                  
 18307                                  	; 21/02/2023
 18308                                  Print_B:
 18309                                  	;mov	al,[VBAR]
 18310 00001DF4 B07C                    	mov	al,'|' ; 7Ch
 18311                                  
 18312                                  ; =============== S U B	R O U T	I N E =======================================
 18313                                  
 18314                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18315                                  PRINT_CHAR:
 18316                                  	; MSDOS 6.0
 18317                                  
 18318                                  ;	Bugbug:	Why bother with ds,es here?
 18319                                  		
 18320 00001DF6 06                      	push	es
 18321 00001DF7 1E                      	push	ds
 18322 00001DF8 07                      	pop	es
 18323 00001DF9 57                      	push	di
 18324 00001DFA 52                      	push	dx
 18325 00001DFB 88C2                    	mov	dl,al		;AC000; Get char into al
 18326                                  	;mov	ah,STD_CON_OUTPUT
 18327                                  				;AC000; print the char to stdout
 18328 00001DFD B402                    	mov	ah,2
 18329 00001DFF CD21                    	int	21h		;AC000;
 18330 00001E01 5A                      	pop	dx
 18331 00001E02 5F                      	pop	di
 18332 00001E03 07                      	pop	es
 18333 00001E04 C3                      	retn
 18334                                  
 18335                                  ;21/02/2023
 18336                                  %if 0
 18337                                  	; MSDOS 3.3
 18338                                  	push	es
 18339                                  	push	ds
 18340                                  	pop	es
 18341                                  	push	di
 18342                                  	push	dx
 18343                                  	mov	di,ONE_CHAR_VAL	
 18344                                  	stosb
 18345                                  	mov	dx,ONECHRVALPTR
 18346                                  	call	STD_PRINTF
 18347                                  	pop	dx
 18348                                  	pop	di
 18349                                  	pop	es
 18350                                  	retn
 18351                                  %endif
 18352                                  
 18353                                  ; ---------------------------------------------------------------------------
 18354                                  
 18355                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18356                                  PRINT_DRIVE:
 18357                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 18358 00001E05 B419                    	mov	ah,19h
 18359 00001E07 CD21                    	int	21h	; DOS -	GET DEFAULT DISK NUMBER
 18360 00001E09 0441                    	add	al,'A'
 18361                                  	;add	al,[CAPITAL_A]
 18362                                  	;call	PRINT_CHAR
 18363                                  	;retn
 18364                                  	; 21/02/2023
 18365 00001E0B EBE9                    	jmp	short PRINT_CHAR
 18366                                  
 18367                                  ; ---------------------------------------------------------------------------
 18368                                  
 18369                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18370                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EB6h
 18371                                  
 18372                                  build_dir_for_prompt:
 18373 00001E0D 30D2                    	xor	dl,dl
 18374 00001E0F BE[A58B]                	mov	si,BWDBUF
 18375 00001E12 89F7                    	mov	di,si
 18376 00001E14 A0[B08A]                	mov	al,[CURDRV]
 18377 00001E17 0441                    	add	al,'A'
 18378 00001E19 B43A                    	mov	ah,':'
 18379 00001E1B AB                      	stosw
 18380 00001E1C A0[A18A]                	mov	al,[DIRCHAR]
 18381 00001E1F AA                      	stosb
 18382 00001E20 87F7                    	xchg	si,di
 18383 00001E22 893E[8C8C]              	mov	[string_ptr_2],di
 18384                                  	;mov	ah,CURRENT_DIR ; 47h
 18385 00001E26 B447                    	mov	ah,47h
 18386 00001E28 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18387                                  			; DL = drive (0=default,1=A,etc.)
 18388                                  			; DS:SI	points to 64-byte buffer area
 18389                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18390 00001E2A BA[F880]                	mov	dx,string_buf_ptr
 18391 00001E2D 7303                    	jnc	short doprint
 18392                                  	;mov	dx,BADCURDRVPTR	; MSDOS 3.3
 18393 00001E2F BA[C07F]                	mov	dx,BADCURDRV
 18394                                  doprint:
 18395                                  	;call	std_printf
 18396                                  	;retn
 18397 00001E32 E9CE2F                  	jmp	std_printf
 18398                                  
 18399                                  ; =============== S U B	R O U T	I N E =======================================
 18400                                  
 18401                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18402                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1EDFh
 18403                                  
 18404                                  build_dir_for_chdir:
 18405 00001E35 E80D00                  	call	build_dir_string
 18406 00001E38 BA[A58B]                	mov	dx,DIRBUF
 18407 00001E3B 8916[8C8C]              	mov	[string_ptr_2],dx
 18408                                  	;mov	dx,offset trangroup:string_buf_ptr ; MSDOS 6.0
 18409                                  	;mov	dx,STRINGBUF2PTR ; MSDOS 3.3
 18410 00001E3F BA[F880]                	mov	dx,string_buf_ptr
 18411                                  	;call	std_printf
 18412                                  	;retn
 18413                                  	; 21/02/2023
 18414                                  	;jmp	short doprint
 18415 00001E42 E9BE2F                  	jmp	std_printf
 18416                                  
 18417                                  
 18418                                  ; =============== S U B	R O U T	I N E =======================================
 18419                                  
 18420                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18421                                  build_dir_string:
 18422 00001E45 8A165C00                	mov	dl,[FCB] ; mov dl,[5Ch]
 18423 00001E49 88D0                    	mov	al,dl
 18424 00001E4B 0440                    	add	al,'@'	; 40h
 18425 00001E4D 3C40                    	cmp	al,'@'
 18426 00001E4F 7506                    	jne	short gotdrive
 18427 00001E51 0206[B08A]              	add	al,[CURDRV]
 18428 00001E55 FEC0                    	inc	al
 18429                                  gotdrive:
 18430 00001E57 50                      	push	ax
 18431 00001E58 BE[A88B]                	mov	si,BWDBUF+3
 18432                                  	;mov	ah,CURRENT_DIR ; 47h
 18433 00001E5B B447                    	mov	ah,47h
 18434 00001E5D CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 18435                                  			; DL = drive (0=default,1=A,etc.)
 18436                                  			; DS:SI	points to 64-byte buffer area
 18437 00001E5F 7305                    	jnc	short dpbisok
 18438 00001E61 0E                      	push	cs
 18439 00001E62 1F                      	pop	ds
 18440 00001E63 E9ED09                  	jmp	DRVBAD
 18441                                  dpbisok:
 18442 00001E66 BF[A58B]                	mov	di,BWDBUF
 18443 00001E69 89FA                    	mov	dx,di
 18444 00001E6B 58                      	pop	ax
 18445 00001E6C B43A                    	mov	ah,':'
 18446 00001E6E AB                      	stosw
 18447 00001E6F A0[A18A]                	mov	al,[DIRCHAR]
 18448 00001E72 AA                      	stosb
 18449 00001E73 C3                      	retn
 18450                                  
 18451                                  ; ---------------------------------------------------------------------------
 18452                                  
 18453                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18454                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:1F1Fh
 18455                                  PATH:
 18456                                  	; MSDOS 6.0
 18457 00001E74 30C0                    	xor	al,al			;AN049; Set up holding buffer
 18458 00001E76 BF[CA87]                	mov	di,SRCXNAME		;AN049;  for PATH while parsing
 18459 00001E79 AA                      	stosb				;AN049; Initialize PATH to null
 18460 00001E7A 4F                      	dec	di			;AN049; point to the start of buffer
 18461 00001E7B E8DE0C                  	call	PGETARG 		; Pre scan for arguments
 18462 00001E7E 7460                    	jz	short disppath		; Print the current path
 18463                                  	;cmp	al,semicolon		;AC049; NUL path argument?
 18464 00001E80 3C3B                    	cmp	al,';' ; 3Bh
 18465 00001E82 7503                    	jne	short pathslp 		;AC049;
 18466 00001E84 46                      	inc	si			;AN049; point past semicolon
 18467 00001E85 EB1B                    	jmp	short scan_white	;AC049; Yes - make sure nothing else on line
 18468                                  pathslp:					; Get the user specified path
 18469 00001E87 AC                      	lodsb				; Get a character
 18470 00001E88 3C0D                    	cmp	al,0Dh
 18471                                  	;cmp	al,END_OF_LINE_IN	;AC049; Is it end of line?
 18472 00001E8A 7434                    	je	short path_eol		;AC049; yes - end of command
 18473 00001E8C E82905                  	call	testkanj		;See if DBCS
 18474 00001E8F 7405                    	jz	short notkanj2		;No - continue
 18475 00001E91 AA                      	stosb				;AC049; Yes - store the first byte
 18476 00001E92 AC                      	lodsb				;skip second byte of DBCS
 18477                                  path_hold:				;AN049;
 18478 00001E93 AA                      	stosb				;AC049; Store a byte in the PATH buffer
 18479 00001E94 EBF1                    	jmp	short pathslp		;continue parsing
 18480                                  notkanj2:
 18481 00001E96 E84905                  	call	UPCONV			;upper case the character
 18482                                  
 18483 00001E99 3C3B                    	cmp	al,';' ; 3Bh
 18484                                  	;cmp	al,semicolon		;AC049; ';' not a delimiter on PATH
 18485 00001E9B 74F6                    	je	short path_hold		;AC049; go store it
 18486 00001E9D E83F07                  	call	DELIM			;delimiter?
 18487 00001EA0 75F1                    	jnz	short path_hold		;AC049; no - go store character
 18488                                  scan_white:				;AN049; make sure were at EOL
 18489 00001EA2 AC                      	lodsb				;AN049; get a character
 18490 00001EA3 3C0D                    	cmp	al,0Dh
 18491                                  	;cmp	al,END_OF_LINE_IN	;AN049; end of line?
 18492 00001EA5 7419                    	je	short path_eol		;AN049; yes - go set path
 18493 00001EA7 3C20                    	cmp	al,' ' ; 20h
 18494                                  	;cmp	al,blank		;AN049; whitespace?
 18495 00001EA9 74F7                    	je	short scan_white	;AN049; yes - continue scanning
 18496                                  	;cmp	al,9
 18497 00001EAB 3C09                    	cmp	al,tab_chr ; 9		;AN049; whitespace?
 18498 00001EAD 74F3                    	je	short scan_white	;AN049; yes - continue scanning
 18499                                  
 18500 00001EAF BA[317F]                	mov	dx,extend_buf_ptr 	;AN049; no - set up error message
 18501                                  	;mov	word [extend_buf_ptr],1	;AN049; get "Too many parameters" message number
 18502 00001EB2 C706[317F]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 18503                                  	;mov	byte [msg_disp_class],2		
 18504                                  					;AN049; set up parse error msg class
 18505 00001EB8 C606[2F7F]02            	mov	byte [msg_disp_class],parse_msg_class
 18506 00001EBD E98B0A                  	jmp	cerror			;AN049;
 18507                                  path_eol:				;AN049; Parsing was clean
 18508 00001EC0 30C0                    	xor	al,al			;AN049; null terminate the PATH
 18509 00001EC2 AA                      	stosb				;AN049;    buffer
 18510 00001EC3 E84004                  	call	find_path		;AN049; Find PATH in environment
 18511 00001EC6 E81404                  	call	delete_path		;AC049; Delete any offending name
 18512 00001EC9 E8CA04                  	call	scan_double_null	;AC049; Scan to end of environment
 18513 00001ECC E89A04                  	call	move_name		;AC049; move in PATH=
 18514 00001ECF BE[CA87]                	mov	si,SRCXNAME		;AN049; Set up source as PATH buffer
 18515                                  store_path:				;AN049; Store the PATH in the environment
 18516 00001ED2 AC                      	lodsb				;AN049; Get a character
 18517                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN049; null character?
 18518 00001ED3 20C0                    	and	al,al ; al=0 ?
 18519 00001ED5 7405                    	jz	short got_paths		;AN049; yes - exit
 18520 00001ED7 E82A05                  	call	store_char		;AN049; no - store character
 18521 00001EDA EBF6                    	jmp	short store_path	;AN049; continue
 18522                                  got_paths:				;AN049; we're finished
 18523 00001EDC 31C0                    	xor	ax,ax			;	null terminate the PATH in
 18524 00001EDE AB                      	stosw				;    	the environment
 18525 00001EDF C3                      	retn
 18526                                  disppath:
 18527 00001EE0 E82304                  	call	find_path		;AN049;
 18528 00001EE3 E80300                  	call	print_path
 18529                                  	;call	CRLF2
 18530                                  	;retn
 18531                                  	; 21/02/2023
 18532 00001EE6 E9E106                  	jmp	CRLF2
 18533                                  
 18534                                  ; 21/02/2023
 18535                                  %if 0
 18536                                  	; MSDOS 3.3
 18537                                  	call	FIND_PATH		; Find PATH in environment
 18538                                  	call	PGETARG			; Pre scan for arguments
 18539                                  	jz	short DISPPATH		; Print the current path
 18540                                  	call	DELETE_PATH		; Delete any offending name
 18541                                  	call	SCAN_DOUBLE_NULL	; Scan to end of environment	
 18542                                  	call	MOVE_NAME		; Move in PATH=
 18543                                  	call	PGETARG
 18544                                  	cmp	al,';'
 18545                                  	jz	short GOTPATHS
 18546                                  PATHSLP:
 18547                                  	lodsb
 18548                                  	cmp	al,0Dh			; End of line (CR) ?		
 18549                                  	jz	short GOTPATHS		; yes - exit
 18550                                  	;call	UPCONV	; MSDOS 6.0
 18551                                  	call	UPCONV_MAPCALL		; convert to uppercase
 18552                                  	cmp	al,';'			; ';' not a delimiter on PATH
 18553                                  	jz	short NOTDELIM		; go set path
 18554                                  	call	DELIM			; is it delim/null char ?
 18555                                  	jz	short GOTPATHS		; yes - exit
 18556                                  NOTDELIM:
 18557                                  	call	STORE_CHAR		; no - store character
 18558                                  	jmp	short PATHSLP
 18559                                  GOTPATHS:
 18560                                  	xor	ax,ax			; null terminate the PATH
 18561                                  	stosw				; in the environment
 18562                                  	retn
 18563                                  DISPPATH:
 18564                                  	call	PRINT_PATH
 18565                                  	call	CRLF2
 18566                                  	retn
 18567                                  %endif
 18568                                  
 18569                                  ; =============== S U B	R O U T	I N E =======================================
 18570                                  
 18571                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18572                                  print_path:
 18573 00001EE9 26803D00                	cmp	byte [es:di],0
 18574 00001EED 750A                    	jnz	short path1
 18575                                  path0:
 18576 00001EEF BA[8680]                	mov	dx,NULLPATH_PTR
 18577 00001EF2 0E                      	push	cs
 18578 00001EF3 07                      	pop	es
 18579 00001EF4 0E                      	push	cs
 18580 00001EF5 1F                      	pop	ds
 18581 00001EF6 E90A2F                  	jmp	std_printf
 18582                                  path1:
 18583 00001EF9 06                      	push	es
 18584 00001EFA 1F                      	pop	ds
 18585 00001EFB 83EF05                  	sub	di,5
 18586 00001EFE 89FE                    	mov	si,di
 18587 00001F00 E8AD04                  	call	SCASB2		; Look for null
 18588                                  	;cmp	cx,0FFh ; 255
 18589                                  	; 21/02/2023
 18590                                  	;ch = 0
 18591 00001F03 80F9FF                  	cmp	cl,255
 18592 00001F06 74E7                    	je	short path0
 18593 00001F08 0E                      	push	cs
 18594 00001F09 07                      	pop	es
 18595 00001F0A BF[088C]                	mov	di,Arg_Buf
 18596                                  	;mov	dx,100h ; 256
 18597                                  	;sub	dx,cx
 18598                                  	;xchg	dx,cx
 18599                                  	; 21/02/2023
 18600 00001F0D F6D9                    	neg	cl ; 256-cl
 18601 00001F0F F3A4                    	rep	movsb
 18602 00001F11 BA[CE80]                	mov	dx,arg_buf_ptr
 18603 00001F14 0E                      	push	cs
 18604 00001F15 1F                      	pop	ds
 18605 00001F16 E9EA2E                  	jmp	std_printf
 18606                                  
 18607                                  ; ---------------------------------------------------------------------------
 18608                                  
 18609                                  ; ****************************************************************
 18610                                  ; *
 18611                                  ; * ROUTINE:	 CLS
 18612                                  ; *
 18613                                  ; * FUNCTION:	 Clear the screen using INT 10h. If ANSI.SYS is
 18614                                  ; *		 installed, send a control string to clear the
 18615                                  ; *		 screen.
 18616                                  ; *
 18617                                  ; * INPUT:	 command line at offset 81H
 18618                                  ; *
 18619                                  ; * OUTPUT:	 none
 18620                                  ; *
 18621                                  ; ****************************************************************
 18622                                  
 18623                                  	; MSDOS 6.0
 18624                                  
 18625                                  ANSI_installed	equ 0FFh
 18626                                  
 18627                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18628                                  CLS:
 18629                                  	;;mov	ah,Mult_ANSI		;AN000; see if ANSI.SYS installed
 18630                                  	;mov	ah,1Ah
 18631                                  	;mov	al,0			;AN000;
 18632 00001F19 B8001A                  	mov	ax,1A00h
 18633 00001F1C CD2F                    	int	2Fh			;AN000;
 18634                                  		; - Multiplex - DOS 4+ ANSI.SYS internal - INSTALLATION CHECK
 18635                                  		; Return: AL = FFh if installed
 18636 00001F1E 3CFF                    	cmp	al,ANSI_installed	;AN000;
 18637 00001F20 7429                    	je	short ansicls 		;AN000; installed - go do ANSI CLS
 18638                                  
 18639                                  check_lines:
 18640                                  	;mov	ax,(IOCTL SHL 8) + generic_ioctl_handle ; 440Ch
 18641 00001F22 B80C44                  	mov	ax,440Ch		;AN000; get lines per page on display
 18642                                  	;mov	bx,stdout		;AN000; lines for stdout
 18643 00001F25 BB0100                  	mov	bx,1   ; handle
 18644                                  	;;mov	ch,ioc_sc		;AN000; type is display
 18645                                  	;mov	ch,3   ; CON device	
 18646                                  	;;mov	cl,get_generic		;AN000; get information
 18647                                  	;mov	cl,7Fh ; minor function, get display info
 18648                                  	; 25/04/2023
 18649 00001F28 B97F03                  	mov	cx,037Fh
 18650 00001F2B BA[E28D]                	mov	dx,Display_Ioctl	;AN000;
 18651 00001F2E CD21                    	int	21h			;AN000;
 18652 00001F30 720A                    	jc	short no_variable	;AN000; function had error, use default
 18653                                  		; 21/02/2023
 18654                                  		; ds:dx = parameter block
 18655                                  		; --- https://stanislavs.org/helppc/int_21-44-c.html ---
 18656                                  		; offset 00h  byte  level (0 for DOS 4.0)
 18657                                  		;   	 01h  byte  reserved
 18658                                  		;   	 02h  word  length of following data
 18659                                  		;   	 04h  word  control flags
 18660                                  		;	       bit 0 set for blink, clear for intensity
 18661                                  		;	       bits 1 to 15 reserved
 18662                                  		;   	 06h  byte  mode type (1=text, 2=graphics)
 18663                                  		;   	 07h  byte  reserved
 18664                                  		;   	 08h  word  colors; 0=monochrome, n=bits per pixel
 18665                                  		;   	 0Ah  word  pixel columns
 18666                                  		;   	 0Ch  word  pixel rows
 18667                                  		;   	 0Eh  word  character columns
 18668                                  		;   	 10h  word  character rows
 18669                                  	
 18670                                  	;mov	ax,[LinPerPag] ; [Display_Ioctl+10h]
 18671                                  	;				;AN000; get number of rows returned
 18672                                  	;mov	dh,al			;AN000; set number of rows
 18673                                  	;mov	ax,[display_width] ; [Display_Ioctl+0Eh]
 18674                                  	;				;AN000; get number of columns returned
 18675                                  	;mov	dl,al			;AN000; set number of columns
 18676                                  	; 21/02/2023
 18677 00001F32 8A16[F08D]              	mov	dl,[display_width]
 18678 00001F36 8A36[F28D]              	mov	dh,[LinPerPag]
 18679 00001F3A EB3B                    	jmp	short regcls		;AN000; go do cls
 18680                                  
 18681                                  no_variable:
 18682                                  	;;mov	bx,stdout		;AC000; set handle as stdout
 18683                                  	;mov	bx,1
 18684                                  	; bx = 1
 18685                                  	;mov	ax,IOCTL SHL 8		;AC000; do ioctl - get device info
 18686 00001F3C B80044                  	mov	ax,4400h
 18687 00001F3F CD21                    	int	21h			;AC000;
 18688 00001F41 F6C280                  	test	dl,80h
 18689                                  	;test	dl,devid_ISDEV		;AC000; is handle a device
 18690 00001F44 7405                    	jz	short ansicls 		;AC000; If a file put out ANSI
 18691 00001F46 F6C210                  	test	dl,10h
 18692                                  	;test	dl,devid_SPECIAL	;AC000;
 18693 00001F49 7505                    	jnz	short cls_normal	;AC000; If not special CON, do ANSI
 18694                                  
 18695                                  ansicls:
 18696 00001F4B E85200                  	call	ansi_cls		;AN000; clear the screen
 18697 00001F4E EB2C                    	jmp	short cls_ret		;AN000; exit
 18698                                  
 18699                                  ; Get video mode
 18700                                  
 18701                                  cls_normal:				;AC000;
 18702                                  	;mov	ah,get_video_state	;AC000; set up to get video state
 18703 00001F50 B40F                    	mov	ah,0Fh
 18704                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18705 00001F52 CD10                    	int	10h
 18706 00001F54 3C03                    	cmp	al,3
 18707                                  	;cmp	al,video_alpha		;AC000; see if in text mode
 18708 00001F56 760A                    	jbe	short DoAlpha
 18709 00001F58 3C07                    	cmp	al,7
 18710                                  	;cmp	al,video_bw		;AC000; see if black & white card
 18711 00001F5A 7406                    	je	short DoAlpha
 18712                                  
 18713                                  ; We are in graphics mode. Bogus IBM ROM does not scroll correctly. We will
 18714                                  ; be just as bogus and set the mode that we just got. This will blank the
 18715                                  ; screen too.
 18716                                  
 18717                                  	;mov	ah,set_video_mode	;AC000; set video mode call
 18718 00001F5C B400                    	mov	ah,0
 18719                                  	;int	video_io_int		;AC000; do int 10h - BIOS video IO
 18720 00001F5E CD10                    	int	10h
 18721 00001F60 EB1A                    	jmp	short cls_ret		;AC000; exit
 18722                                  
 18723                                  DoAlpha:
 18724                                  
 18725                                  ; Get video mode and number of columns to scroll
 18726                                  
 18727                                  ;M01 - INT 10 Function 0F doesn't reliably return the number of rows on some
 18728                                  ;M01   adaptors. We circumvent this by reaching directly into the BIOS data
 18729                                  ;M01   area
 18730                                  ;M01   Commented out code here is the original
 18731                                  ;M01	mov	ah,get_video_state	;AC000; set up to get current video state
 18732                                  ;M01	int	video_io_int		;AC000; do int 10h - BIOS video IO
 18733                                  ;M01	mov	dl,ah
 18734                                  ;M01	mov	dh,linesperpage 	;AC000; have 25 rows on the screen
 18735                                  
 18736                                  ;M01   Following code lifted from a fix Compaq applied to ANSI
 18737                                  
 18738 00001F62 1E                      	push	ds
 18739                                  	;mov	ax,ROMBIOS_DATA 	; GET ROM Data segment	M01
 18740 00001F63 B84000                  	mov	ax,40h
 18741 00001F66 8ED8                    	mov	ds,ax			;  *			M01
 18742                                  
 18743                                  	;mov	dx,[CRT_Cols]		; Get Columns - assume < 256 M01
 18744 00001F68 8A164A00                	mov	dl,[4Ah]
 18745                                  	;mov	dh,[CRT_Rows]		; GET MAX NUM OF ROWS	M01
 18746 00001F6C 8A368400                	mov	dh,[84h]
 18747 00001F70 1F                      	pop	ds			;			M01
 18748                                  
 18749 00001F71 08F6                    	or	dh,dh			; Q:ZERO		M01
 18750 00001F73 7502                    	jnz	short regcls		;  *JMP IF NO		M01
 18751                                  
 18752                                  	;mov	dh,LINESPERPAGE 	; SET TO 24 ROWS	M01
 18753                                  	; 25/04/2023
 18754 00001F75 B619                    	mov	dh,25
 18755                                  regcls:
 18756 00001F77 FEC6                    	inc	dh			; height+1		M018
 18757 00001F79 E80100                  	call	reg_cls 		; go clear the screen
 18758                                  cls_ret:
 18759 00001F7C C3                      	retn				; exit
 18760                                  
 18761                                  ; ---------------------------------------------------------------------------
 18762                                  
 18763                                  ; 21/02/2023
 18764                                  %if 0
 18765                                  	; MSDOS 3.3
 18766                                  CLS:
 18767                                  	mov	bx,STDOUT ; 1
 18768                                  	mov	ax,IOCTL*256 ; 4400h
 18769                                  	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 18770                                  			; BX = file or device handle
 18771                                  	test	dl,80h	; devid_ISDEV
 18772                                  	jz	short ANSICLS	; If a file put out ANSI
 18773                                  	test	dl,10h  ; devid_SPECIAL
 18774                                  	jz	short ANSICLS	; If not special CON, do ANSI
 18775                                  
 18776                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|29h ; 3529h
 18777                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18778                                  			; AL = interrupt number
 18779                                  			; Return: ES:BX	= value	of interrupt vector
 18780                                  	mov	dx,es
 18781                                  	mov	ax,(GET_INTERRUPT_VECTOR<<8)|20h ; 3520h
 18782                                  	int	21h	; DOS -	2+ - GET INTERRUPT VECTOR
 18783                                  			; AL = interrupt number
 18784                                  			; Return: ES:BX	= value	of interrupt vector
 18785                                  	mov	ax,es
 18786                                  	cmp	dx,ax	; If not default driver, do ANSI
 18787                                  	ja	short ANSICLS
 18788                                  
 18789                                  	mov	ah,0Fh
 18790                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18791                                  			; Return: AH = number of columns on screen
 18792                                  			; AL = current video mode
 18793                                  			; BH = current active display page
 18794                                  	cmp	al,3
 18795                                  	jbe	short DOALPHA
 18796                                  	cmp	al,7
 18797                                  	jz	short DOALPHA
 18798                                  	mov	ah,0
 18799                                  	int	10h	; - VIDEO - SET	VIDEO MODE
 18800                                  			; AL = mode
 18801                                  	retn
 18802                                  
 18803                                  DOALPHA:
 18804                                  	mov	ah,0Bh	; Set overscan to black
 18805                                  	xor	bx,bx
 18806                                  	int	10h	; - VIDEO - SET	COLOR PALETTE
 18807                                  			; BH = 00h, BL = border color
 18808                                  			; BH = 01h, BL = palette (0-3)
 18809                                  	mov	ah,0Fh
 18810                                  	int	10h	; - VIDEO - GET	CURRENT	VIDEO MODE
 18811                                  			; Return: AH = number of columns on screen
 18812                                  			; AL = current video mode
 18813                                  			; BH = current active display page
 18814                                  	mov	dl,ah
 18815                                  	dec	dl
 18816                                  	mov	dh,24
 18817                                  	xor	ax,ax
 18818                                  	mov	cx,ax
 18819                                  	mov	bx,700h
 18820                                  	mov	ah,6
 18821                                  	int	10h	; - VIDEO - SCROLL PAGE	UP
 18822                                  			; AL = number of lines to scroll window	
 18823                                  			;	(0 = blank whole window)
 18824                                  			; BH = attributes to be	used on	blanked	lines
 18825                                  			; CH,CL	= row,column of	upper left corner of window 
 18826                                  			;	  to scroll
 18827                                  			; DH,DL	= row,column of	lower right corner of window
 18828                                  	xor	dx,dx
 18829                                  	mov	bh,0
 18830                                  	mov	ah,2
 18831                                  	int	10h	; - VIDEO - SET	CURSOR POSITION
 18832                                  			; DH,DL	= row,column (0,0 = upper left)
 18833                                  			; BH = page number
 18834                                  	retn
 18835                                  
 18836                                  ANSICLS:
 18837                                  	mov	si,CLSSTRING
 18838                                  	lodsb
 18839                                  	mov	cl,al
 18840                                  	xor	ch,ch
 18841                                  	mov	ah,RAW_CON_IO ; 6
 18842                                  CLRLOOP:
 18843                                  	lodsb
 18844                                  	mov	dl,al
 18845                                  	int	21h	; DOS -	DIRECT CONSOLE I/O CHARACTER OUTPUT
 18846                                  			; DL = character <> FFh
 18847                                  			;  Return: ZF set = no character
 18848                                  			;   ZF clear = character recieved, AL = character
 18849                                  	loop	CLRLOOP
 18850                                  	retn
 18851                                  %endif
 18852                                  
 18853                                  ; ---------------------------------------------------------------------------
 18854                                  
 18855                                  ; MSDOS 6.0
 18856                                  
 18857                                  ; ****************************************************************
 18858                                  ; *
 18859                                  ; * ROUTINE:	 REG_CLS
 18860                                  ; *
 18861                                  ; * FUNCTION:	 Clear the screen using INT 10H.
 18862                                  ; *
 18863                                  ; * INPUT:	 DL = NUMBER OF COLUMNS
 18864                                  ; *		 DH = NUMBER OF ROWS
 18865                                  ; *
 18866                                  ; * OUTPUT:	 none
 18867                                  ; *
 18868                                  ; ****************************************************************
 18869                                  
 18870                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18871                                  reg_cls:
 18872                                  ; Set overscan to black.
 18873                                  
 18874 00001F7D FECE                    	dec	dh			; decrement rows and columns
 18875 00001F7F FECA                    	dec	dl			;  to zero base
 18876 00001F81 52                      	push	dx			; save rows,columns
 18877                                  	;mov	ah,set_color_palette	; set up to set the color to blank
 18878 00001F82 B40B                    	mov	ah,0Bh
 18879 00001F84 31DB                    	xor	bx,bx
 18880                                  	;int	video_io_int		; do int 10h - BIOS video IO
 18881 00001F86 CD10                    	int	10h
 18882 00001F88 5A                      	pop	dx			;  restore rows,colums
 18883                                  
 18884 00001F89 31C0                    	xor	ax,ax			; zero out ax
 18885 00001F8B 89C1                    	mov	cx,ax			;  and cx
 18886                                  
 18887                                  ; Scroll active page
 18888                                  
 18889                                  	;mov	ah,scroll_video_page	; set up to scroll page up
 18890 00001F8D B406                    	mov	ah,6
 18891                                  	;mov	bh,video_attribute	; attribute for blank line
 18892 00001F8F B707                    	mov	bh,7
 18893 00001F91 30DB                    	xor	bl,bl			; set BL to 0
 18894                                  	;int	video_io_int		; do int 10h - BIOS video IO
 18895 00001F93 CD10                    	int	10h
 18896                                  
 18897                                  ; Seek to cursor to 0,0
 18898                                  
 18899                                  ;M022 following two lines added
 18900                                  	;mov	ah,get_video_state	; get current video page in BH
 18901 00001F95 B40F                    	mov	ah,0Fh
 18902                                  	;int	video_io_int
 18903 00001F97 CD10                    	int	10h
 18904                                  	;mov	ah,set_cursor_position	; set up to set cursor position
 18905 00001F99 B402                    	mov	ah,2
 18906 00001F9B 31D2                    	xor	dx,dx			; row and column 0
 18907                                  ;M022	mov	bh,0
 18908                                  	;int	video_io_int		; do into 10h - BIOS video IO
 18909 00001F9D CD10                    	int	10h
 18910                                  
 18911 00001F9F C3                      	retn
 18912                                  
 18913                                  ; ---------------------------------------------------------------------------
 18914                                  
 18915                                  ; MSDOS 6.0
 18916                                  
 18917                                  ; ****************************************************************
 18918                                  ; *
 18919                                  ; * ROUTINE:	 ANSI_CLS
 18920                                  ; *
 18921                                  ; * FUNCTION:	 Clear the screen using by writing a control code
 18922                                  ; *		 to STDOUT.
 18923                                  ; *
 18924                                  ; * INPUT:	 none
 18925                                  ; *
 18926                                  ; * OUTPUT:	 none
 18927                                  ; *
 18928                                  ; ****************************************************************
 18929                                  
 18930                                  	; 21/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 18931                                  ansi_cls:			;AC000;
 18932 00001FA0 BE[9D82]                	mov	si,CLSSTRING
 18933                                  			; db 4,1Bh,'[2J'
 18934 00001FA3 AC                      	lodsb
 18935 00001FA4 88C1                    	mov	cl,al	; al = 4
 18936 00001FA6 30ED                    	xor	ch,ch
 18937                                  	;mov	ah,Raw_CON_IO
 18938 00001FA8 B406                    	mov	ah,6
 18939                                  clrloop:
 18940 00001FAA AC                      	lodsb
 18941 00001FAB 88C2                    	mov	dl,al
 18942 00001FAD CD21                    	int	21h
 18943                                  		; DOS - DIRECT CONSOLE I/O CHARACTER OUTPUT
 18944 00001FAF E2F9                    	loop	clrloop
 18945 00001FB1 C3                      	retn
 18946                                  
 18947                                  ;============================================================================
 18948                                  ; TCMD2B.ASM, MSDOS 6.0, 1991
 18949                                  ;============================================================================
 18950                                  ; 08/10/2018 - Retro DOS v3.0
 18951                                  
 18952                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 156Dh
 18953                                  
 18954                                  ; 21/02/2023 - Retro DOS v4.0 (& v4.1)
 18955                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 206Bh
 18956                                  
 18957                                  ; ---------------------------------------------------------------------------
 18958                                  
 18959                                  ; ****************************************************************
 18960                                  ; *
 18961                                  ; * ROUTINE:	 CTTY - Change console
 18962                                  ; *
 18963                                  ; * SYNTAX:	 CTTY device
 18964                                  ; *
 18965                                  ; * FUNCTION:	 If a valid console device is specified, CTTY will
 18966                                  ; *		 duplicate the device handle to STDIN, STDOUT and
 18967                                  ; *		 STDERR. This routine returns to LODCOM1.
 18968                                  ; *
 18969                                  ; * INPUT:	 command line at offset 81H
 18970                                  ; *
 18971                                  ; * OUTPUT:	 none
 18972                                  ; *
 18973                                  ; ****************************************************************
 18974                                  
 18975                                  	; 21/02/2023 - Retro DOS v4.0
 18976                                  	; 10/06/2023
 18977                                  CTTY:
 18978                                  	; MSDOS 6.0
 18979 00001FB2 1E                      	push	ds			;AN000; Get local ES
 18980 00001FB3 07                      	pop	es			;AN000;
 18981 00001FB4 BE8100                  	mov	si,81h			;AC000; Get command argument for CTTY
 18982 00001FB7 BF[B185]                	mov	di,PARSE_CTTY
 18983                                  					;AC000; Get address of PARSE_CTTY
 18984 00001FBA 31C9                    	xor	cx,cx			;AC000; clear cx,dx
 18985 00001FBC 31D2                    	xor	dx,dx			;AC000;
 18986 00001FBE E86F23                  	call	cmd_parse		;AC000; call parser
 18987                                  
 18988                                  	;cmp	ax,-1 ; 0FFFFh
 18989                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 18990                                  	;je	short ctty_error	;AN000; yes - error
 18991                                  	;;cmp	ax,RESULT_NO_ERROR ; 0	;AN000; did an error occur
 18992                                  	;and	ax,ax ; ax > 0 ?
 18993                                  	;jnz	short ctty_error	;AN000; YES -ERROR
 18994                                  	; 10/06/2023
 18995 00001FC1 40                      	inc	ax  ; cmp ax,-1
 18996 00001FC2 7434                    	jz	short ctty_error  ; 0FFFFh -> 0
 18997 00001FC4 48                      	dec	ax  ; cmp ax,0
 18998 00001FC5 7531                    	jnz	short ctty_error  ; 1 -> 0
 18999                                  	; ax = 0
 19000                                  
 19001 00001FC7 56                      	push	si			;AN000; save position in line
 19002 00001FC8 C536[CF95]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19003 00001FCC BF[0B8D]                	mov	di,SrcBuf		;AN000; get address of srcbuf
 19004                                  ctty_move_filename:			;AN000; put filespec in srcbuf
 19005 00001FCF AC                      	lodsb				;AN000; get a char from buffer
 19006 00001FD0 AA                      	stosb				;AN000; store in srcbuf
 19007                                  	;cmp	al,END_OF_LINE_OUT ; 0	;AN000; it char a terminator?
 19008 00001FD1 08C0                    	or	al,al ; al = 0 ?
 19009 00001FD3 75FA                    	jnz	short ctty_move_filename ; 26/04/2023
 19010                                  					;AN000; no - keep moving
 19011 00001FD5 5E                      	pop	si			;AN000; get line position back
 19012 00001FD6 BF[B185]                	mov	di,PARSE_CTTY		;AC000; Get address of PARSE_CTTY
 19013 00001FD9 E8C001                  	call	parse_check_eol 	;AN000; are we at end of line?
 19014                                  	;jz	short nocolon 		;AN000; yes - continue
 19015                                  	; 21/02/2023
 19016 00001FDC 751A                    	jnz	short ctty_error
 19017                                  ;ctty_error:
 19018                                  	;jmp	short isbaddev		;AC000; yes - exit
 19019                                  
 19020                                  	; 21/02/2023
 19021                                  	; MSDOS 3.3
 19022                                  	;call	SETPATH
 19023                                  	;dec	si
 19024                                  	;dec	si
 19025                                  	;cmp	byte [si],':'
 19026                                  	;jnz	short NOCOLON
 19027                                  	;mov	byte [si],0
 19028                                  nocolon:
 19029                                  	; 21/02/2023
 19030                                  	; MSDOS 6.0
 19031 00001FDE BA[0B8D]                	mov	dx,SrcBuf
 19032                                  ;NOCOLON:
 19033                                  	; MSDOS 3.3 & MSDOS 6.0
 19034                                  	;;mov	ax,(OPEN SHL 8) OR 2 ; Read and write
 19035                                  	;mov	ax,(OPEN<<8)|2 ; 3D02h
 19036 00001FE1 B8023D                  	mov	ax,3D02h ; 21/02/2023
 19037 00001FE4 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 19038                                  			; DS:DX	-> ASCIZ filename
 19039                                  			; AL = access mode
 19040                                  			; 2 - read & write
 19041 00001FE6 7210                    	jc	short isbaddev
 19042 00001FE8 89C3                    	mov	bx,ax
 19043                                  	;mov	ax,IOCTL*256 ; 4400h
 19044 00001FEA B80044                  	mov	ax,4400h
 19045 00001FED CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 19046                                  			; BX = file or device handle
 19047 00001FEF F6C280                  	test	dl,80h
 19048 00001FF2 750C                    	jnz	short devisok
 19049                                  closedev:
 19050                                  	;mov	ah,CLOSE ; 3Eh ; Close initial handle
 19051 00001FF4 B43E                    	mov	ah,3Eh
 19052 00001FF6 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19053                                  			; BX = file handle
 19054                                  ctty_error:
 19055                                  isbaddev:
 19056 00001FF8 BA[8C80]                	mov	dx,BADDEV_PTR
 19057 00001FFB E8052E                  	call	std_printf
 19058 00001FFE EB40                    	jmp	short resret
 19059                                  
 19060                                  	;nop
 19061                                  devisok:
 19062                                  	; 21/02/2023
 19063                                  	; MSDOS 6.0
 19064 00002000 52                      	push	dx		;AN007; save device info
 19065                                  	; 08/06/2023 (BugFix)
 19066 00002001 A1[1081]                	mov	ax,[acrlf_ptr]	;AN021; get message number for 0d, 0a
 19067                                  	;mov	dh,util_msg_class
 19068 00002004 B6FF                    	mov	dh,-1 ; 0FFh	;AN021; this is a utility message
 19069 00002006 53                      	push	bx		;AN021; save handle
 19070 00002007 E8E02E                  	call	TSYSGETMSG	;AN021; get the address of the message
 19071 0000200A 89F2                    	mov	dx,si		;AN021; get address into dx
 19072                                  	;mov	ax,(Write shl 8)
 19073 0000200C B80040                  	mov	ax,4000h	;AN007; write to device
 19074 0000200F B90200                  	mov	cx,2		;AN007; write two bytes
 19075 00002012 CD21                    	int	21h		;AN007;
 19076 00002014 5B                      	pop	bx		;AN021; get back handle
 19077 00002015 5A                      	pop	dx		;AN007; get back device info
 19078 00002016 72DC                    	jc	short closedev	;AN007; if error, quit
 19079                                  
 19080                                  	; MSDOS 3.3 & MSDOS 6.0
 19081 00002018 30F6                    	xor	dh,dh
 19082 0000201A 80CA03                  	or	dl,3
 19083                                  	;;mov	ax,(IOCTL SHL 8) OR 1
 19084                                  	;mov	ax,(IOCTL<<8)|1 ; 4401h
 19085 0000201D B80144                  	mov	ax,4401h
 19086 00002020 CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 19087                                  			; BX = device handle,DH = 0
 19088                                  			; DL = device information to set 
 19089                                  			;	(bits 0-7 from	function 0)
 19090 00002022 53                      	push	bx
 19091 00002023 B90300                  	mov	cx,3
 19092 00002026 31DB                    	xor	bx,bx
 19093                                  iclloop:			; Close basic handles
 19094                                  	;mov	ah,CLOSE ; 3Eh
 19095 00002028 B43E                    	mov	ah,3Eh
 19096 0000202A CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19097                                  			; BX = file handle
 19098 0000202C 43                      	inc	bx
 19099 0000202D E2F9                    	loop	iclloop
 19100 0000202F 5B                      	pop	bx		; Get handle
 19101                                  	;mov	ah,XDUP ; 45h
 19102 00002030 B445                    	mov	ah,45h
 19103 00002032 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19104                                  			; BX = file handle to duplicate
 19105                                  	;mov	ah,XDUP ; 45h
 19106 00002034 B445                    	mov	ah,45h
 19107 00002036 CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19108                                  			; BX = file handle to duplicate
 19109                                  	;mov	ah,XDUP ; 45h
 19110 00002038 B445                    	mov	ah,45h
 19111 0000203A CD21                    	int	21h	; DOS -	2+ - CREATE DUPLICATE HANDLE (DUP)
 19112                                  			; BX = file handle to duplicate
 19113                                  	;mov	ah,CLOSE ; 3Eh
 19114 0000203C B43E                    	mov	ah,3Eh
 19115 0000203E CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 19116                                  			; BX = file handle
 19117                                  resret:
 19118 00002040 8E1E[9C8A]              	mov	ds,[RESSEG]
 19119 00002044 1E                      	push	ds
 19120                                  	;mov	ax,[18h]
 19121 00002045 A11800                  	mov	ax,[PDB.JFN_TABLE] ; Get new 0 and 1
 19122 00002048 A3[A201]                	mov	[Io_Save],ax
 19123                                  	;;;mov	ax,31Eh ; MSDOS 3.3
 19124                                  	;;mov	ax,LODCOM1
 19125                                  	;;mov	ax,offset DATARES:TrnLodCom1_Trap  ; MSDOS 6.0
 19126                                  	;mov	ax,175h ; MSDOS 6.0
 19127 0000204B B8[7400]                	mov	ax,TrnLodCom1_Trap
 19128 0000204E 50                      	push	ax
 19129                                  
 19130 0000204F CB                      	retf		; Far return
 19131                                  
 19132                                  ; ---------------------------------------------------------------------------
 19133                                  
 19134                                  ;****************************************************************
 19135                                  ;*
 19136                                  ;* ROUTINE:	CHCP - Change code page internal command
 19137                                  ;*		(added DOS 3.30 07/21/86)
 19138                                  ;*
 19139                                  ;* SYNTAX:	CHCP [xxx]
 19140                                  ;*		where xxx is a valid code page
 19141                                  ;*
 19142                                  ;* FUNCTION:	If xxx is specified, CHCP will use INT 21H function
 19143                                  ;*		6402H to set the code page to xxxx. If no parameters
 19144                                  ;*		are specified, CHCP will use INT 21H function 6401H
 19145                                  ;*		to get global code page and display it to the user.
 19146                                  ;*
 19147                                  ;* INPUT:	command line at offset 81H
 19148                                  ;*
 19149                                  ;* OUTPUT:	none
 19150                                  ;*
 19151                                  ;****************************************************************
 19152                                  
 19153                                  NLSFUNC_installed equ  0FFh
 19154                                  set_global_cp	  equ  2
 19155                                  get_global_cp	  equ  1
 19156                                  
 19157                                  	; 21/02/2023 - Retro DOS v4.0
 19158                                  	; 09/06/2023
 19159                                  	; 10/06/2023
 19160                                  CHCP:
 19161                                  	; MSDOS 6.0
 19162 00002050 1E                      	push	ds		;AN000; Get local ES
 19163 00002051 07                      	pop	es		;AN000;
 19164 00002052 BE8100                  	mov	si,81h		;AC000; Get command argument for CHCP
 19165 00002055 BF[C884]                	mov	di,PARSE_CHCP
 19166                                  				;AN000; Get address of PARSE_CHCP
 19167 00002058 31C9                    	xor	cx,cx		;AC000; clear cx,dx
 19168 0000205A 31D2                    	xor	dx,dx		;AC000;
 19169 0000205C E85301                  	call    Parse_With_Msg	;AC018; call parser
 19170                                  
 19171                                  	;cmp	ax,-1
 19172                                  	;;cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 19173                                  	;;jne	short setcp	;AC000; no go get number & set code page
 19174                                  	;je	short getcp	;AC000; yes - no parm - get code page
 19175                                  ;setcp:
 19176                                  	;;cmp	ax,0
 19177                                  	;;cmp	ax,RESULT_NO_ERROR
 19178                                  	;			;AN000; did we have an error?
 19179                                  	;;jne	short cp_error	;AC018; yes - go issue message
 19180                                  	;and	ax,ax ; ax > 0 ?
 19181                                  	;jnz	short cp_error	
 19182                                  	; 10/06/2023
 19183 0000205F 40                      	inc	ax  ; cmp ax,-1	
 19184 00002060 745C                    	jz	short getcp ; 0FFFFh -> 0
 19185 00002062 48                      	dec	ax  ; cmp ax,0
 19186 00002063 7556                    	jnz	short cp_error ; 1 -> 0
 19187                                  	; ax = 0
 19188                                  
 19189                                  	;;push	cx		;AN000; save positional count
 19190                                  	;mov	bx,PARSE1_ADDR	;AN000; get number returned
 19191                                  	;;mov	cx,[bx]		;AN000;  into cx
 19192                                  	;;mov	[system_cpage],cx
 19193                                  	;			;AN000; save user input number
 19194                                  	;;pop	cx		;AC000; restore positional count
 19195                                  	;; 21/02/2023
 19196                                  	;mov	di,[bx]
 19197                                  	;mov	[system_cpage],di
 19198                                  	; 09/06/2023	
 19199 00002065 8B1E[CF95]              	mov	bx,[PARSE1_ADDR]
 19200 00002069 891E[068C]              	mov	[system_cpage],bx
 19201                                  	;
 19202 0000206D BF[C884]                	mov	di,PARSE_CHCP	;AN000; Get address of PARSE_CHCP
 19203 00002070 E82901                  	call	parse_check_eol ;AN000; are we at end of line?
 19204 00002073 7546                    	jnz	short cp_error	;AC000; no - exit
 19205                                  okset:
 19206                                  	;;mov	ah,NLSFUNC	;AN000; see if NLSFUNC installed
 19207                                  	;mov	ah,14h
 19208                                  	;mov	al,0		;AN000;
 19209 00002075 B80014                  	mov	ax,1400h
 19210 00002078 CD2F                    	int	2Fh		;AN000;
 19211                                  	;cmp	al,0FFh
 19212 0000207A 3CFF                    	cmp	al,NLSFUNC_installed
 19213                                  				;AN000;
 19214 0000207C 7405                    	je	short got_NLS 	;AN000; Yes - continue
 19215 0000207E BA[BA7F]                	mov	dx,NLSFUNC_PTR
 19216                                  				;AN000; no - set up error message
 19217 00002081 EB38                    	jmp	short cp_error	;AN000; error exit
 19218                                  
 19219                                  ; 21/02/2023
 19220                                  %if 0
 19221                                  	; MSDOS 3.3
 19222                                  	mov	si,81h
 19223                                  	call	SCANOFF
 19224                                  	cmp	al,0Dh ; CR
 19225                                  	jnz	short SETCP
 19226                                  	jmp	short GETCP
 19227                                  
 19228                                  	;nop
 19229                                  SETCP:
 19230                                  	xor	bx,bx
 19231                                  	mov	cx,bx
 19232                                  	mov	ax,bx
 19233                                  GET_CP_DIGIT:
 19234                                  	lodsb
 19235                                  	cmp	al,'0'
 19236                                  	jb	short CHRNOTNUMBER
 19237                                  	cmp	al,'9'
 19238                                  	ja	short CHRNOTNUMBER
 19239                                  	sub	al,'0'
 19240                                  	inc	cl
 19241                                  	cmp	cl,4
 19242                                  	ja	short CHCP_BADPARM
 19243                                  	mov	dx,bx
 19244                                  	shl	dx,1
 19245                                  	shl	dx,1
 19246                                  	add	bx,dx
 19247                                  	shl	bx,1
 19248                                  	add	bx,ax
 19249                                  	jmp	short GET_CP_DIGIT
 19250                                  CP_NEXTCHR:
 19251                                  	lodsb
 19252                                  CHRNOTNUMBER:
 19253                                  	cmp	al,' '		; SPACE
 19254                                  	jz	short CP_NEXTCHR
 19255                                  	cmp	al,9		; TAB
 19256                                  	jz	short CP_NEXTCHR
 19257                                  	cmp	al,0Dh		; CR
 19258                                  	jz	short SET_CP_TBL_NUM
 19259                                  CHCP_BADPARM:
 19260                                  	mov	dx,BADPARMPTR
 19261                                  	jmp	CERROR
 19262                                  ;GOT_NLS:
 19263                                  %endif
 19264                                  	; 21/02/2023
 19265                                  got_NLS:
 19266                                  	; MSDOS 6.0
 19267 00002083 8B1E[068C]              	mov	bx,[system_cpage]
 19268                                  				;AN000; get user input code page
 19269                                  ;SET_CP_TBL_NUM:
 19270                                  	;mov	[SYSTEM_CPAGE],bx ; MSDOS 3.3
 19271                                  	;
 19272                                  	; MSDOS 3.3 & MSDOS 6.0
 19273                                  	;;mov	ah,GETSETCDPG 	;get/set global code page function
 19274                                  	;mov	ah,66h
 19275                                  	;;mov	al,set_global_cp 
 19276                                  	;mov	al,2		;minor - set
 19277                                  	; 26/04/2023
 19278 00002087 B80266                  	mov	ax,6602h
 19279 0000208A CD21                    	int	21h
 19280                                  		; DOS - 3.3+ - SET GLOBAL CODE PAGE TABLE
 19281                                  		; BX = active code page
 19282                                  		; DX = system code page (active page at boot time)
 19283                                  
 19284 0000208C 733F                    	jnc	short chcp_return
 19285                                  				;no error - exit
 19286                                  
 19287 0000208E 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ; 2
 19288 00002091 7515                    	jnz	short chcp_other_error
 19289                                  
 19290                                  	;mov	ah,GETEXTENDEDERROR ; 59h
 19291 00002093 B459                    	mov	ah,59h
 19292 00002095 31DB                    	xor	bx,bx
 19293 00002097 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19294                                  			; BX = version code (0000h for DOS 3.x)
 19295                                  
 19296 00002099 83F80D                  	cmp	ax,ERROR_INVALID_DATA ; 0Dh ; invalid code page
 19297 0000209C 7505                    	jne	short no_countrysys ; 26/04/2023
 19298                                  	;mov	dx,FNOTFOUNDPTR ; MSDOS 3.3
 19299 0000209E BA[BD7F]                	mov	dx,INV_CODE_PAGE
 19300                                  	;jmp	cerror
 19301 000020A1 EB18                    	jmp	short cp_error
 19302                                  
 19303                                  	; 21/02/2023
 19304                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 19305                                  no_countrysys:
 19306                                  ;M045;	mov	byte [msg_disp_class],ext_msg_class	   
 19307                                  ;					;AN000; set up extended error msg class
 19308                                  ;M045;	mov	dx,extend_buf_ptr	;AC000; get extended message pointer
 19309                                  ;M045;	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND
 19310                                  					;AN000; get message number in control block
 19311 000020A3 BA[9E81]                	mov	dx,NoCntry_Ptr
 19312 000020A6 EB13                    	jmp	short cp_error
 19313                                  
 19314                                  chcp_other_error:		; end of p716
 19315                                  	;mov	ah,GETEXTENDEDERROR ; 59h ;error - see what it is
 19316 000020A8 B459                    	mov	ah,59h
 19317 000020AA 31DB                    	xor	bx,bx
 19318 000020AC CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 19319                                  			; BX = version code (0000h for DOS 3.x)
 19320 000020AE 83F841                  	cmp	ax,65		;was it access denied?
 19321 000020B1 7505                    	jne	short none_set	;no - assume all failed
 19322 000020B3 BA[9E7F]                	mov	dx,cp_not_all_ptr
 19323                                  				;set up message
 19324                                  	;jmp	cerror		;AC000; error exit
 19325 000020B6 EB03                    	jmp     short cp_error
 19326                                  none_set:
 19327 000020B8 BA[907F]                	mov	dx,cp_not_set_ptr
 19328                                  				;set up message
 19329                                  cp_error:
 19330 000020BB E98D08                  	jmp	cerror		;exit
 19331                                  getcp:
 19332                                  	;;mov	ah,GETSETCDPG ; 66h
 19333                                  	;mov	ah,66h		;get/set global code page function	
 19334                                  	;;mov	al,get_global_cp ; 1
 19335                                  	;mov	al,1		;minor - get
 19336                                  	; 26/04/2023
 19337 000020BE B80166                  	mov	ax,6601h
 19338 000020C1 CD21                    	int	21h	; DOS -	3.3+ - GET GLOBAL CODE PAGE TABLE
 19339 000020C3 891E[068C]              	mov	[system_cpage],bx
 19340                                  				;get active cp for output
 19341 000020C7 BA[AC7F]                	mov	dx,cp_active_ptr
 19342 000020CA E8362D                  	call	std_printf	;print it out
 19343                                  chcp_return:
 19344 000020CD C3                      	retn
 19345                                  
 19346                                  ; ---------------------------------------------------------------------------
 19347                                  
 19348                                  ; ****************************************************************
 19349                                  ; *
 19350                                  ; * ROUTINE:	 TRUENAME
 19351                                  ; *
 19352                                  ; * FUNCTION:	 Entry point for the internal TRUENAME command.
 19353                                  ; *		 Parses the command line. If a path is found, set
 19354                                  ; *		 SRCXNAME to path. If only a drive letter is found,
 19355                                  ; *		 set SRCXNAME to the drive letter. If no path
 19356                                  ; *		 is found, set the path of SRCXNAME to dot (.) for
 19357                                  ; *		 current directory. Use the NAME TRANSLATE system
 19358                                  ; *		 call to get the real name and  then display the 
 19359                                  ; *		 real name. If an error occurs issue an error
 19360                                  ; *		 message and transfer control to  CERROR.
 19361                                  ; *
 19362                                  ; * INPUT:	 command line at offset 81H
 19363                                  ; *
 19364                                  ; * OUTPUT:	 none
 19365                                  ; *
 19366                                  ; ****************************************************************
 19367                                  
 19368                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19369                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2197h
 19370                                  	; 10/06/2023
 19371                                  TRUENAME:				;AN000; TRUENAME entry point
 19372 000020CE 1E                      	push	ds			;AN000; Get local ES
 19373 000020CF 07                      	pop	es			;AN000;
 19374 000020D0 BE8100                  	mov	si,81h			;AN000; Get command line
 19375 000020D3 BF[2685]                	mov	di,PARSE_CHDIR		;AN000; Get address of PARSE_CHDIR
 19376 000020D6 31C9                    	xor	cx,cx			;AN000; clear cx,dx
 19377 000020D8 31D2                    	xor	dx,dx			;AN000;
 19378 000020DA E8D500                  	call	Parse_With_Msg		;AC018; call parser
 19379                                  
 19380 000020DD BF[CA87]                	mov	di,SRCXNAME		;AN000; get address of srcxname
 19381                                  	;cmp	ax,0FFFFh
 19382                                  	;;cmp	ax,END_OF_LINE		;AN000; are we at end of line?
 19383                                  	;je	short tn_eol		;AN000; yes - go process
 19384                                  	;; 22/02/2023
 19385                                  	;;cmp	ax,0
 19386                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 19387                                  	;;jne	short tn_parse_error	;AN000; yes - go issue message
 19388                                  	;and	ax,ax ; ax = 0 ?
 19389                                  	;jnz	short tn_parse_error ; no, parse error
 19390                                  	; 10/06/2023
 19391 000020E0 40                      	inc	ax  ; 0FFFFh -> 0 ; cmp ax,0FFFFh
 19392 000020E1 7433                    	jz	short tn_eol ; ah = 0 ; *
 19393 000020E3 48                      	dec	ax  ; 1 -> 0 ; cmp ax, 0
 19394 000020E4 752D                    	jnz	short tn_parse_error
 19395                                  
 19396                                  	;cmp	byte [PARSE1_TYPE],6
 19397 000020E6 803E[CB95]06            	cmp	byte [PARSE1_TYPE],result_drive
 19398                                  					;AN000; was a drive entered?
 19399                                  	;je	short tn_drive		;AN000; yes - go process
 19400                                  	;jmp	short tn_filespec	;AN000; nothing else - must be filespec
 19401                                  	; 23/02/2023
 19402 000020EB 7512                    	jne	short tn_filespec
 19403                                  
 19404                                  ;tn_eol: 
 19405                                  ;	;mov	ah,0			;AN000; no parameters on line
 19406                                  ;	mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19407                                  ;	;mov	al,dot_chr		;AN000;   for current dir
 19408                                  ;	mov	al,'.'
 19409                                  ;	stosw				;AN000; store in srcxname
 19410                                  ;	jmp	short tn_doit		;AN000; go do command
 19411                                  
 19412                                  tn_drive:				;AN000; a drive was entered
 19413 000020ED 56                      	push	si			;AN000; save position in line
 19414 000020EE BE[CF95]                	mov	si,PARSE1_ADDR		;AN000; get address of drive
 19415 000020F1 AC                      	lodsb				;AN000; get the drive number
 19416 000020F2 0440                    	add	al,"A"-1 ; 40h		;AN000; convert it to char
 19417 000020F4 AA                      	stosb				;AN000; store it in srcxname
 19418                                  	;mov	ax,dot_colon		;AN000; get colon and . and
 19419 000020F5 B83A2E                  	mov	ax,':.' ; 2E3Ah ; ah=".", al=":"
 19420 000020F8 AB                      	stosw				;AN000;  store in srcxname
 19421                                  	;mov	al,0
 19422 000020F9 B000                    	mov	al,END_OF_LINE_OUT	;AN000; put a terminator char
 19423 000020FB AA                      	stosb				;AN000;
 19424 000020FC 5E                      	pop	si			;AN000; get line position back
 19425 000020FD EB0C                    	jmp	short tn_check_eol	;AN000; check to make sure eol
 19426                                  
 19427                                  tn_filespec:				;AN000; a filespec was entered
 19428 000020FF 56                      	push	si			;AN000; save position in line
 19429 00002100 C536[CF95]              	lds	si,[PARSE1_ADDR]	;AN000; get address of filespec
 19430                                  
 19431                                  tn_move_filename:			;AN000; put filespec in srcxname
 19432 00002104 AC                      	lodsb				;AN000; get a char from buffer
 19433 00002105 AA                      	stosb				;AN000; store in srcxname
 19434                                  	;;cmp	al,0
 19435                                  	;cmp	al,END_OF_LINE_OUT	;AN000; it char a terminator?
 19436 00002106 08C0                    	or	al,al ; al = 0 ?
 19437 00002108 75FA                    	jnz	short tn_move_filename	;AN000; no - keep moving
 19438 0000210A 5E                      	pop	si			;AN000; get line position back
 19439                                  
 19440                                  tn_check_eol:				;AN000; make sure no extra parms
 19441 0000210B BF[2685]                	mov	di,PARSE_CHDIR		;AN000; get address of parse_chdir
 19442 0000210E E88B00                  	call	parse_check_eol 	;AN000; are we at end of line?
 19443 00002111 7406                    	jz	short tn_doit 		;AN000; Yes - do the command
 19444                                  tn_parse_error: 			;AN000; A parse error occurred
 19445 00002113 E93508                  	jmp	cerror			;AN000; Go to error routine
 19446                                  
 19447                                  tn_eol: 
 19448                                  	;23/02/2023
 19449                                  	;;mov	ah,0			;AN000; no parameters on line
 19450                                  	;mov	ah,END_OF_LINE_OUT	;AN000; set buffer to .
 19451                                  	;;mov	al,dot_chr		;AN000;   for current dir
 19452                                  	;mov	al,'.'
 19453                                  	; 10/06/2023
 19454                                  	;mov	ax,002Eh
 19455                                  	; ah = 0 ; *
 19456 00002116 B02E                    	mov	al,'.'  ;dot_chr ; 2Eh
 19457                                  	;
 19458 00002118 AB                      	stosw				;AN000; store in srcxname
 19459                                  	; 23/02/2023
 19460                                  	;jmp	short tn_doit		;AN000; go do command
 19461                                  
 19462                                  tn_doit:				;AN000;
 19463 00002119 BE[CA87]                	mov	si,SRCXNAME		;AN000; set up srcxname as source
 19464 0000211C BF[FB88]                	mov	di,COMBUF		;AN000; set up combuf as target (need big target)
 19465                                  	;mov	ah,xNameTrans		;AN000; do name translate call
 19466 0000211F B460                    	mov	ah,60h
 19467 00002121 CD21                    	int	21h			;AN000;
 19468 00002123 7311                    	jnc	short tn_print_xname	;AN000; If no error - print result
 19469                                  
 19470 00002125 E8C4FB                  	call	Set_Ext_Error_Msg	;AN000; get extended message
 19471 00002128 C706[8C8C][CA87]        	mov	word [string_ptr_2],SRCXNAME
 19472                                  					;AN000; get address of failed string
 19473                                  	;mov	byte [extend_buf_sub],1
 19474 0000212E C606[337F]01            	mov	byte [extend_buf_sub],one_subst
 19475                                  					;AN000; put number of subst in control block
 19476 00002133 E91508                  	jmp	cerror			;AN000; Go to error routine
 19477                                  
 19478                                  tn_print_xname: 			;AN000;
 19479 00002136 C706[8C8C][FB88]        	mov	word [string_ptr_2],COMBUF
 19480                                  					;AN000; Set up address of combuf
 19481 0000213C BA[F880]                	mov	dx,string_buf_ptr	;AN000; Set up address of print control block
 19482 0000213F E88804                  	call	CRLF2			;AN000; print a crlf
 19483                                  	;call	Printf_Crlf		;AN000; print it out
 19484                                  	;retn				;AN000;
 19485                                  	; 23/02/2023
 19486 00002142 E9B02C                  	jmp	Printf_Crlf
 19487                                  
 19488                                  ; ---------------------------------------------------------------------------
 19489                                  
 19490                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19491                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2219h
 19492                                  _$EXIT:
 19493                                  	; MSDOS 6.0
 19494 00002145 1E                      	push	ds			;AN000; save data segment
 19495 00002146 8E1E[9C8A]              	mov	ds,[RESSEG]		;AN000; get resident data segment
 19496                                  	;assume	ds:resgroup		;AN000;
 19497                                  
 19498 0000214A 803E[A501]00            	cmp	byte [PermCom],0	;AN045; is this a permanent COMMAND?
 19499 0000214F 740A                    	jz	short free_com		;AN045; no - free everything
 19500                                  
 19501                                  ;	We're a permanent command.
 19502                                  ;	Unless this is a singlecom (int 2Eh), don't deallocate transient.
 19503                                  
 19504 00002151 833E[A601]FF            	cmp	word [SingleCom],-1	;M034
 19505 00002156 7412                    	je	short no_reset		;M034 ; exit singlecom
 19506 00002158 E9A9DF                  	jmp	TCOMMAND		;permanent command, recycle
 19507                                  
 19508                                  free_com:
 19509                                  	;mov	ax,(multdos shl 8 or message_2f)
 19510 0000215B B82E12                  	mov	ax,122Eh		;AN060; reset parse message pointers
 19511                                  	;mov	dl,SET_CRITICAL_MSG	;AN000; set up critical error message address
 19512 0000215E B205                    	mov	dl,5
 19513 00002160 8B3E[BB01]              	mov	di,[Crit_Msg_Off] 	;AN000; old offset of critical messages
 19514 00002164 8E06[BD01]              	mov	es,[Crit_Msg_Seg] 	;AN000; old segment of critical messages
 19515 00002168 CD2F                    	int	2Fh			;AN000; go set it
 19516                                  no_reset:				;AN045;
 19517 0000216A 1F                      	pop	ds			;AN000; restore local data segment
 19518                                  	;assume	ds:trangroup		;AN000;
 19519                                  ;M040
 19520                                  ; Restore user directory if the restore flag is set. RestUDir1 checks for
 19521                                  ;this, restores user dir if flag is set and resets the flag.
 19522                                  
 19523                                  	;invoke	RestUDir1		;restore user dir if needed ;M040
 19524 0000216B E80C03                  	call	RestUDir1
 19525 0000216E 8E06[9C8A]              	mov	es,[RESSEG]
 19526                                  	;assume	es:resgroup
 19527                                  
 19528 00002172 26A1[4101]              	mov	ax,[es:Parent]
 19529                                  	;mov	[es:16h],ax
 19530                                  	;mov	[es:PDB_Parent_PID],ax
 19531 00002176 26A31600                	mov	[es:PDB.PARENT_PID],ax
 19532 0000217A 26A1[4301]              	mov	ax,[es:OldTerm]
 19533                                  	;mov	[es:0Ah],ax
 19534                                  	;mov	[es:PDB_Exit],ax
 19535 0000217E 26A30A00                	mov	[es:PDB.EXIT],ax
 19536 00002182 26A1[4501]              	mov	ax,[es:OldTerm+2]
 19537                                  	;mov	[es:0Ch],ax
 19538                                  	;mov	[es:PDB_Exit+2],ax
 19539 00002186 26A30C00                	mov	[es:PDB.EXIT+2],ax
 19540                                  
 19541 0000218A 06                      	push	es
 19542 0000218B 8E06[AC8A]              	mov	es,[TRAN_TPA]
 19543                                  	;mov	ah,DEALLOC
 19544 0000218F B449                    	mov	ah,49h
 19545 00002191 CD21                    	int	21h			; Now running in "free" space
 19546 00002193 07                      	pop	es
 19547                                  
 19548                                  	;mov	ah,Exit
 19549 00002194 B44C                    	mov	ah,4Ch
 19550                                  	;mov	al,byte ptr RetCode
 19551 00002196 26A0[9D01]              	mov	al,[es:RetCode]
 19552 0000219A CD21                    	int	21h
 19553                                  
 19554                                  	;..........
 19555                                  
 19556                                  ; 23/02/2023
 19557                                  %if 0
 19558                                  _$EXIT:
 19559                                  	; MSDOS 3.3
 19560                                  	mov	es,[RESSEG]
 19561                                  	mov	ax,[es:PARENT]
 19562                                  	;mov	[es:16h],ax
 19563                                  	mov	[es:PDB.PARENT_PID],ax
 19564                                  	mov	ax,[es:OLDTERM]
 19565                                  	;mov	[es:0Ah],ax
 19566                                  	mov	[es:PDB.EXIT],ax
 19567                                  	mov	ax,[es:OLDTERM+2]
 19568                                  	;mov	[es:0Ch],ax
 19569                                  	mov	[es:PDB.EXIT+2],ax
 19570                                  	push	es
 19571                                  	mov	es,[TRAN_TPA]
 19572                                  	mov	ah,DEALLOC ; 49h
 19573                                  	int	21h	; DOS -	2+ - FREE MEMORY
 19574                                  			; ES = segment address of area to be freed
 19575                                  	pop	es
 19576                                  	mov	ah,EXIT ; 4Ch
 19577                                  	;mov	al,byte [0BEAh] ;  MSDOS 3.3 COMMAND.cOm offset 168Ah
 19578                                  	mov	al,byte [es:RETCODE]
 19579                                  	int	21h		; DOS -	2+ - QUIT WITH EXIT CODE (EXIT)
 19580                                  ;;here:
 19581                                  ;;	jmp	short here
 19582                                  %endif
 19583                                  
 19584                                  ; ---------------------------------------------------------------------------
 19585                                  
 19586                                  ; MSDOS 6.0
 19587                                  ; ****************************************************************
 19588                                  ; *
 19589                                  ; * ROUTINE:	 PARSE_CHECK_EOL
 19590                                  ; *
 19591                                  ; * FUNCTION:	 Calls parser to see if end of line occurred.
 19592                                  ; *		 If not end of line, set up to print parse
 19593                                  ; *		 error message. ASSUMES NO MORE PARAMETERS ARE
 19594                                  ; *		 EXPECTED!
 19595                                  ; *
 19596                                  ; * INPUT:	 DS:SI	  last output from parser
 19597                                  ; *		 ES:DI	  points to parse block
 19598                                  ; *		 CX	  last output from parser
 19599                                  ; *
 19600                                  ; * OUTPUT:	 AX	  parser return code
 19601                                  ; *
 19602                                  ; *		 if end of line found
 19603                                  ; *		     zero flag set
 19604                                  ; *		 else
 19605                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19606                                  ; *
 19607                                  ; ****************************************************************
 19608                                  
 19609                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19610                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2270h
 19611                                  
 19612                                  parse_check_eol:
 19613 0000219C 31D2                    	xor	dx,dx			;AN000;
 19614 0000219E 8936[048C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19615 000021A2 E88B21                  	call	cmd_parse		;AN000; call parser
 19616 000021A5 3CFF                    	cmp	al,-1 ; 0FFh
 19617                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN000; Are we at end of line?
 19618 000021A7 7408                    	je	short parse_good_eol	;AN000; yes - no problem
 19619                                  	;cmp	ax,0
 19620                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; was any error found?
 19621 000021A9 21C0                    	and	ax,ax ; ax = 0 ?
 19622 000021AB 7501                    	jnz	short ok_to_setup_pmsg	;AN018; yes - continue
 19623 000021AD 40                      	inc	ax			;AN018; set AX to 1 and turn off zero flag
 19624                                  ok_to_setup_pmsg:
 19625 000021AE E81000                  	call	setup_parse_error_msg	;AN018; go set up error message
 19626                                  parse_good_eol:
 19627                                  parse_msg_good:	; 23/02/2023
 19628 000021B1 C3                      	retn				;AN000;
 19629                                  
 19630                                  ; ---------------------------------------------------------------------------
 19631                                  
 19632                                  ; MSDOS 6.0
 19633                                  ; ****************************************************************
 19634                                  ; *
 19635                                  ; * ROUTINE:	 PARSE_WITH_MSG
 19636                                  ; *
 19637                                  ; * FUNCTION:	 Calls parser. If an error occurred, the error
 19638                                  ; *		 message is set up.
 19639                                  ; *
 19640                                  ; * INPUT:	 DS:SI	  last output from parser
 19641                                  ; *		 ES:DI	  points to parse block
 19642                                  ; *		 CX	  last output from parser
 19643                                  ; *
 19644                                  ; * OUTPUT:	 AX	  parser return code
 19645                                  ; *
 19646                                  ; *		 if no error
 19647                                  ; *		     outputs from parser
 19648                                  ; *		 else
 19649                                  ; *		     MSG_DISPLAY_CLASS set to parse error
 19650                                  ; *		     error message set up for STD_PRINTF
 19651                                  ; *
 19652                                  ; ****************************************************************
 19653                                  
 19654                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19655                                  Parse_With_Msg:
 19656 000021B2 8936[048C]              	mov	[parse_last],si 	;AN018; save start of parameter
 19657 000021B6 E87721                  	call	cmd_parse		;AN018; call parser
 19658 000021B9 3CFF                    	cmp	al,-1 ; 0FFh
 19659                                  	;cmp	al,END_OF_LINE	; 0FFh	;AN018; Are we at end of line?
 19660 000021BB 74F4                    	je	short parse_msg_good	;AN018; yes - no problem
 19661                                  	;cmp	ax,0
 19662                                  	;cmp	ax,RESULT_NO_ERROR	;AN018; did an error occur
 19663 000021BD 09C0                    	or	ax,ax ; ax = 0 ?
 19664 000021BF 74F0                    	jz	short parse_msg_good	;AN018; yes - no problem
 19665                                  	; 23/02/2023
 19666                                  	;call	setup_parse_error_msg	;AN018; go set up error message
 19667                                  ;parse_msg_good:
 19668                                  	;retn				;AN018;
 19669                                  	; 23/02/2023
 19670                                  	;jmp	short setup_parse_error_msg	
 19671                                  
 19672                                  ; ---------------------------------------------------------------------------
 19673                                  
 19674                                  ; MSDOS 6.0
 19675                                  ; ****************************************************************
 19676                                  ; *
 19677                                  ; * ROUTINE:	 SETUP_PARSE_ERROR_MSG
 19678                                  ; *
 19679                                  ; * FUNCTION:	 Calls parser.	If an error occurred, the error
 19680                                  ; *		 message is set up.
 19681                                  ; *
 19682                                  ; * INPUT:	 AX	     Parse error number
 19683                                  ; *		 SI	     Set to past last parameter
 19684                                  ; *		 Parse_last  Set to start of last parameter
 19685                                  ; *
 19686                                  ; * OUTPUT:	 MSG_DISPLAY_CLASS set to parse error
 19687                                  ; *		 error message set up for STD_PRINTF
 19688                                  ; *
 19689                                  ; ****************************************************************
 19690                                  
 19691                                  	; 23/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 19692                                  setup_parse_error_msg:
 19693 000021C1 C606[2F7F]02            	mov	byte [msg_disp_class],parse_msg_class
 19694                                  	;mov	byte [msg_disp_class],2	;AC018; Set up parse message class
 19695 000021C6 BA[317F]                	mov	dx,extend_buf_ptr	;AC018; get extended message pointer
 19696 000021C9 C60400                  	mov	byte [si],END_OF_LINE_OUT ; 0
 19697                                  					;AC018; terminate the parameter string
 19698 000021CC A3[317F]                	mov	[extend_buf_ptr],ax	;AC018; get message number in control block
 19699 000021CF 83F802                  	cmp	ax,2
 19700                                  	;cmp	ax,LessArgs_Ptr 	;AC018; if required parameter missing
 19701 000021D2 740D                    	je	short setup_parse_msg_ret
 19702                                  					;AN018;    no subst
 19703 000021D4 8B36[048C]              	mov	si,[parse_last] 	;AC018; get start of parameter
 19704 000021D8 8936[8C8C]              	mov	[string_ptr_2],si 	;AC018; get address of failed string
 19705 000021DC C606[337F]01            	mov	byte [extend_buf_sub],one_subst
 19706                                  					;AC018; put number of subst in control block
 19707                                  	;mov	byte [extend_buf_sub],1
 19708                                  setup_parse_msg_ret:
 19709 000021E1 46                      	inc	si			;AN018; make sure zero flag not set
 19710 000021E2 C3                      	retn				;AC018;
 19711                                  
 19712                                  ;============================================================================
 19713                                  ; TENV.ASM, MSDOS 6.0, 1991
 19714                                  ;============================================================================
 19715                                  ; 08/10/2018 - Retro DOS v3.0
 19716                                  
 19717                                  ; TITLE	Part6 COMMAND Transient routines.
 19718                                  
 19719                                  ;	Environment utilities and misc. routines
 19720                                  
 19721                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1690h
 19722                                  
 19723                                  ; 23/02/2023 - Retro DOS v4.0 (& v4.1)
 19724                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 22BDh
 19725                                  
 19726                                  ; ---------------------------------------------------------------------------
 19727                                  
 19728                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19729                                  ADD_PROMPT:
 19730 000021E3 E8FC00                  	call	delete_prompt	; Delete any existing prompt
 19731 000021E6 E8AD01                  	call	scan_double_null
 19732                                  
 19733                                  ADD_PROMPT2:
 19734 000021E9 56                      	push	si
 19735 000021EA E89B01                  	call	GETARG
 19736 000021ED 5E                      	pop	si
 19737 000021EE 7501                    	jnz	short ADD_PROMPT3
 19738                                  ADD_PROMPT_RETN:
 19739 000021F0 C3                      	retn
 19740                                  ADD_PROMPT3:			; Pre scan for arguments
 19741 000021F1 E87501                  	call	move_name	; Move in name
 19742 000021F4 E89101                  	call	GETARG
 19743 000021F7 56                      	push	si
 19744 000021F8 EB53                    	jmp	short ADD_NAME
 19745                                  
 19746                                  ;break	The SET command
 19747                                  
 19748                                  ; Input: DS:SI points to a CR terminated string
 19749                                  ; Output: carry flag is set if no room
 19750                                  ;	  otherwise name is added to environment
 19751                                  
 19752                                  DISP_ENVJ:
 19753 000021FA E9BC00                  	jmp	DISP_ENV
 19754                                  
 19755                                  ADD_NAME_TO_ENVIRONMENT:
 19756 000021FD E88801                  	call	GETARG
 19757 00002200 74F8                    	jz	short DISP_ENVJ
 19758                                  
 19759                                  ; check if line contains exactly one equals sign
 19760                                  
 19761 00002202 31DB                    	xor	bx,bx		; = count is 0
 19762 00002204 56                      	push	si		; Save pointer to beginning of line
 19763                                  EQLP:
 19764 00002205 AC                      	lodsb			; Get a char
 19765 00002206 3C0D                    	cmp	al,13 ; 0Dh	; IF CR we're all done
 19766 00002208 740F                    	je	short QUEQ	
 19767 0000220A 3C3D                    	cmp	al,'='		; Look for = sign	
 19768 0000220C 75F7                    	jne	short EQLP	; not there, get next char
 19769 0000220E FEC3                    	inc	bl		; Otherwise increment EQ count
 19770 00002210 803C0D                  	cmp	byte [si],13	; Look for CR following = sign
 19771 00002213 75F0                    	jne	short EQLP
 19772 00002215 FEC7                    	inc	bh		; Set BH=1 means no parameters
 19773 00002217 EBEC                    	jmp	short EQLP	; And look for more
 19774                                  QUEQ:
 19775 00002219 5E                      	pop	si		; Restore beginning of line
 19776 0000221A FECB                    	dec	bl		; Zero flag means only one EQ
 19777 0000221C 7406                    	jz	short ONEQ	; Good line
 19778 0000221E BA[C97F]                	mov	dx,SYNTMES_PTR
 19779 00002221 E92707                  	jmp	cerror
 19780                                  ONEQ:
 19781 00002224 53                      	push	bx
 19782 00002225 E8BD00                  	call	delete_name_in_environment
 19783 00002228 5B                      	pop	bx
 19784 00002229 FECF                    	dec	bh
 19785 0000222B 74C3                    	jz	short ADD_PROMPT_RETN
 19786 0000222D E86601                  	call	scan_double_null
 19787 00002230 89FB                    	mov	bx,di		; Save ptr to beginning of env var name
 19788 00002232 E83401                  	call	move_name
 19789 00002235 56                      	push	si
 19790 00002236 87DF                    	xchg	bx,di		; Switch ptrs to beginning and end of
 19791                                  				;  env var name
 19792                                  		
 19793                                  ; We want to special-case COMSPEC. This is to reduce the amount of code
 19794                                  ; necessary in the resident for re-reading the transient. Let's look for
 19795                                  ; COMSPEC=
 19796                                  
 19797 00002238 C606[7884]00            	mov	byte [comspec_flag],0 ; MSDOS 6.0 ; clear flag ; M024
 19798 0000223D BE[AD81]                	mov	si,COMSPECSTR ; "COMSPEC="
 19799 00002240 B90400                  	mov	cx,4
 19800 00002243 F3A7                    	repe	cmpsw
 19801 00002245 7504                    	jnz	short NOT_COMSPEC
 19802                                  				; Zero set => exact match
 19803 00002247 FE06[7884]              	inc	byte [comspec_flag] ; MSDOS 6.0 ; comspec is changing ; M024
 19804                                  	;mov	byte [COMSPEC_FLAG],1
 19805                                  NOT_COMSPEC:
 19806 0000224B 89DF                    	mov	di,bx		; Load ptr to end of env var name
 19807                                  ADD_NAME:
 19808 0000224D 5E                      	pop	si		; Add the value of the new env var
 19809 0000224E 56                      	push	si		;  to the environment.
 19810                                  ADD_NAME1:
 19811 0000224F AC                      	lodsb
 19812 00002250 3C0D                    	cmp	al,13 ; 0Dh
 19813 00002252 7405                    	je	short ADD_NAME_RET
 19814 00002254 E8AD01                  	call	store_char
 19815 00002257 EBF6                    	jmp	short ADD_NAME1
 19816                                  ADD_NAME_RET:
 19817 00002259 5E                      	pop	si
 19818 0000225A 803E[7884]00            	cmp	byte [comspec_flag],0
 19819                                  				; If the new env var is comspec,	
 19820                                  ADD_NAME_JZ_RET:
 19821 0000225F 748F                    	jz	short ADD_PROMPT_RETN 
 19822                                  				;  copy the value into the
 19823                                  				;  comspec var in the resident
 19824                                  
 19825                                  ; We have changed the COMSPEC variable. We need to update the resident
 19826                                  ; pieces necessary to reread in the info. First, skip all delimiters
 19827                                  
 19828 00002261 E87303                  	call	scanoff
 19829 00002264 8E06[9C8A]              	mov	es,[RESSEG]	;  comspec var in the resident
 19830                                  
 19831                                  ; Make sure that the printer knows where the beginning of the string is
 19832                                  
 19833 00002268 BF[4E01]                	mov	di,ComSpec
 19834 0000226B 89FB                    	mov	bx,di
 19835                                  
 19836                                  ; Generate drive letter for display
 19837                                  
 19838 0000226D 31C0                    	xor	ax,ax		;g assume no drive first
 19839 0000226F 26A2[9701]              	mov	[es:ComDrv],al
 19840                                  	; 23/02/2023
 19841                                  	; MSDOS 6.0 (& 5.0)
 19842 00002273 50                      	push	ax		;AN000; 3/3/KK
 19843 00002274 8A04                    	mov	al,[si]		;AN000; 3/3/KK
 19844 00002276 E83F01                  	call	testkanj	;AN000; 3/3/KK	
 19845 00002279 58                      	pop	ax		;AN000; 3/3/KK
 19846 0000227A 7518                    	jnz	short _GOTDRIVE
 19847                                  	;
 19848 0000227C 807C013A                	cmp	byte [si+1],':'	; drive specified?
 19849 00002280 7512                    	jne	short _GOTDRIVE
 19850 00002282 8A04                    	mov	al,[si]		; get his specified drive
 19851                                  	; 23/02/2023
 19852 00002284 E85B01                  	call	UPCONV
 19853                                  	;call	UPCONV_MAPCALL	; convert to uppercase
 19854 00002287 2C41                    	sub	al,'A'		; convert to 0-based
 19855 00002289 83C702                  	add	di,2
 19856 0000228C FEC0                    	inc	al		; convert to 1-based number
 19857 0000228E 26A2[9701]              	mov	[es:ComDrv],al
 19858                                  
 19859                                  ; Stick the drive letter in the prompt message. Nothing special needs to be
 19860                                  ; done here..
 19861                                  	;add	al,40h
 19862 00002292 0440                    	add	al,'A'-1
 19863                                  _GOTDRIVE:
 19864                                  	; 23/02/2023
 19865                                  	;;mov	[es:0BD9h],di	; MSDOS 3.3 COMMAND.COM offset 1734h
 19866                                  	;mov	[es:PUTBACKSUBSTPTR],di
 19867                                  	;mov	[es:0233h],di	; MSDOS 5.0 COMMAND.COM offset 236Eh
 19868 00002294 26893E[2D01]            	mov	[es:PutBackComSpec],di
 19869                                  				;g point to beginning of name after drive
 19870                                  	;;mov	[es:0A21h],al	; MSDOS 3.3 COMMAND.COM offset 1739h
 19871                                  	;mov	[es:PUTBACKDRV],al
 19872                                  	;mov	[es:0238h],al	; MSDOS 5.0 COMMAND.COM offset 2373h
 19873 00002299 26A2[3201]              	mov	[es:PutBackDrv],al
 19874                                  
 19875                                  ; Copy chars until delim      	
 19876                                  
 19877 0000229D 89DF                    	mov	di,bx
 19878                                  COPY_COMSPEC:
 19879 0000229F AC                      	lodsb
 19880 000022A0 E83C03                  	call	DELIM
 19881 000022A3 7407                    	jz	short COPYDONE
 19882 000022A5 3C0D                    	cmp	al,13 ; 0Dh
 19883 000022A7 7403                    	je	short COPYDONE
 19884 000022A9 AA                      	stosb
 19885 000022AA EBF3                    	jmp	short COPY_COMSPEC
 19886                                  COPYDONE:
 19887 000022AC 30C0                    	xor	al,al		; Null terminate the string and quit
 19888 000022AE AA                      	stosb
 19889                                  	;mov	byte [comspec_flag],0
 19890 000022AF A2[7884]                	mov	[comspec_flag],al ; 0 ; 23/02/2023
 19891 000022B2 4F                      	dec	di
 19892 000022B3 26893E[8E01]            	mov	[es:ComSpec_End],di
 19893 000022B8 C3                      	retn
 19894                                  
 19895                                  DISP_ENV:
 19896 000022B9 8E1E[9C8A]              	mov	ds,[RESSEG]
 19897 000022BD 8E1E[3F03]              	mov	ds,[EnvirSeg]
 19898                                  	; assume ds:nothing
 19899 000022C1 31F6                    	xor	si,si
 19900                                  PENVLP:
 19901 000022C3 803C00                  	cmp	byte [si],0
 19902 000022C6 7497                    	jz	short ADD_NAME_JZ_RET
 19903 000022C8 BF[088C]                	mov	di,Arg_Buf
 19904                                  PENVLP2:
 19905 000022CB AC                      	lodsb
 19906 000022CC AA                      	stosb
 19907 000022CD 08C0                    	or	al,al
 19908 000022CF 75FA                    	jnz	short PENVLP2
 19909 000022D1 BA[CE80]                	mov	dx,arg_buf_ptr
 19910 000022D4 1E                      	push	ds
 19911 000022D5 06                      	push	es
 19912 000022D6 1F                      	pop	ds
 19913                                  	; assume ds:nothing
 19914 000022D7 E81B2B                  	call	Printf_Crlf
 19915 000022DA 1F                      	pop	ds
 19916 000022DB EBE6                    	jmp	short PENVLP
 19917                                  
 19918                                  ; =============== S U B	R O U T	I N E =======================================
 19919                                  
 19920                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19921                                  delete_path:
 19922 000022DD BE[A181]                	mov	si,PATH_TEXT ; "PATH="
 19923 000022E0 EB03                    	jmp	short delete_name_in_environment
 19924                                  
 19925                                  ; =============== S U B	R O U T	I N E =======================================
 19926                                  
 19927                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19928                                  delete_prompt:
 19929 000022E2 BE[A681]                	mov	si,PROMPT_TEXT ; "PROMPT="
 19930                                  
 19931                                  ; ---------------------------------------------------------------------------
 19932                                  
 19933                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19934                                  delete_name_in_environment:
 19935                                  
 19936                                  ; Input: DS:SI points to a "=" terminated string
 19937                                  ; Output: carry flag is set if name not found
 19938                                  ;	  otherwise name is deleted
 19939                                  
 19940 000022E5 56                      	push	si
 19941 000022E6 1E                      	push	ds
 19942 000022E7 E82C00                  	call	FIND		; ES:DI points to name
 19943 000022EA 7217                    	jc	short del1
 19944 000022EC 89FE                    	mov	si,di		; Save it
 19945 000022EE E8BF00                  	call	SCASB2		; Scan for the nul
 19946 000022F1 87F7                    	xchg	si,di
 19947                                  ;SR;
 19948                                  ; If we have only one env string, then the double null is lost when the last
 19949                                  ;string is deleted and we have an invalid empty environment with only a 
 19950                                  ;single null. To avoid this, we will look for the double null case and then
 19951                                  ;move an extra null char.
 19952                                  ; Bugbug: The only possible problem is that the last pathstring 
 19953                                  ;will be followed by a triple null. Is this really a problem?
 19954                                  
 19955                                  	; MSDOS 6.0
 19956 000022F3 26803C00                	cmp	byte [es:si],0	;null char?
 19957 000022F7 7501                    	jnz	short not_dnull	;no, we are at a double null
 19958 000022F9 4E                      	dec	si		;point at the double null
 19959                                  not_dnull:
 19960                                  	; MSDOS 3.3 (& MSDOS 6.0)
 19961 000022FA E86901                  	call	GETENVSIZ
 19962 000022FD 29F1                    	sub	cx,si
 19963 000022FF 06                      	push	es
 19964 00002300 1F                      	pop	ds		; ES:DI points to name
 19965                                  				; DS:SI points to next name
 19966 00002301 F3A4                    	rep	movsb
 19967                                  del1:
 19968 00002303 1F                      	pop	ds
 19969 00002304 5E                      	pop	si
 19970                                  find_retn:
 19971 00002305 C3                      	retn
 19972                                  
 19973                                  ; =============== S U B	R O U T	I N E =======================================
 19974                                  
 19975                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19976                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:23E2h
 19977                                  find_path:
 19978 00002306 BE[A181]                	mov	si,PATH_TEXT ; "PATH="
 19979 00002309 EB03                    	jmp	short find_name_in_environment
 19980                                  
 19981                                  ; =============== S U B	R O U T	I N E =======================================
 19982                                  
 19983                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 19984                                  find_prompt:
 19985 0000230B BE[A681]                	mov	si,PROMPT_TEXT ; "PROMPT="
 19986                                  
 19987                                  ; ---------------------------------------------------------------------------
 19988                                  
 19989                                  find_name_in_environment:
 19990                                  
 19991                                  ; Input: DS:SI points to a "=" terminated string
 19992                                  ; Output: ES:DI points to the arguments in the environment
 19993                                  ;	  zero is set if name not found
 19994                                  ;	  carry flag is set if name not valid format
 19995                                  
 19996 0000230E E80500                  	call	FIND		; Find the name
 19997 00002311 72F2                    	jc	short find_retn	; Carry means not found	
 19998 00002313 E99600                  	jmp	SCASB1		; Scan for = sign
 19999                                  
 20000                                  ; ---------------------------------------------------------------------------
 20001                                  	;nop
 20002                                  
 20003                                  ; =============== S U B	R O U T	I N E =======================================
 20004                                  
 20005                                  ; On return of FIND1, ES:DI points to beginning of name
 20006                                  
 20007                                  FIND:
 20008 00002316 FC                      	cld
 20009 00002317 E84100                  	call	COUNT0		; CX = Length of name
 20010 0000231A 8E06[9C8A]              	mov	es,[RESSEG]
 20011                                  	;assume es:RESGROUP
 20012 0000231E 268E06[3F03]            	mov	es,[es:EnvirSeg]
 20013                                  	;assume es:NOTHING
 20014 00002323 31FF                    	xor	di,di
 20015                                  find1:	
 20016 00002325 51                      	push	cx
 20017 00002326 56                      	push	si
 20018 00002327 57                      	push	di
 20019                                  find11:
 20020 00002328 AC                      	lodsb
 20021                                  	; 23/02/2023 
 20022                                  	; MSDOS 6.0 (& 5.0)
 20023 00002329 E88C00                  	call	testkanj	
 20024 0000232C 740F                    	jz	short notkanj3
 20025 0000232E 4E                      	dec	si
 20026 0000232F AD                      	lodsw
 20027 00002330 47                      	inc	di
 20028 00002331 47                      	inc	di
 20029 00002332 263B45FE                	cmp	ax,[es:di-2]
 20030 00002336 7511                    	jne	short find12
 20031 00002338 49                      	dec	cx
 20032 00002339 E2ED                    	loop	find11
 20033 0000233B EB0C                    	jmp	short find12
 20034                                  notkanj3:
 20035 0000233D E8A200                  	call	UPCONV		; MSDOS 5.0 (& 6.0)
 20036                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 20037 00002340 47                      	inc	di
 20038 00002341 263A45FF                	cmp	al,[es:di-1]
 20039 00002345 7502                    	jne	short find12
 20040 00002347 E2DF                    	loop	find11
 20041                                  find12:
 20042 00002349 5F                      	pop	di
 20043 0000234A 5E                      	pop	si
 20044 0000234B 59                      	pop	cx
 20045 0000234C 74B7                    	jz	short find_retn
 20046 0000234E 51                      	push	cx
 20047 0000234F E85E00                  	call	SCASB2		; Scan for a nul
 20048 00002352 59                      	pop	cx
 20049 00002353 26803D00                	cmp	byte [es:di],0
 20050 00002357 75CC                    	jnz	short find1
 20051 00002359 F9                      	stc			; Indicate not found
 20052 0000235A C3                      	retn
 20053                                  
 20054                                  ; =============== S U B	R O U T	I N E =======================================
 20055                                  
 20056                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20057                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2437h
 20058                                  COUNT0:
 20059 0000235B 1E                      	push	ds
 20060 0000235C 07                      	pop	es
 20061                                  	;assume es:nothing
 20062 0000235D 89F7                    	mov	di,si
 20063                                  ;COUNT1:
 20064 0000235F 57                      	push	di		; Count number of chars until "="
 20065 00002360 E84900                  	call	SCASB1
 20066                                  	; 23/02/2023
 20067                                  ;	jmp	short COUNTX
 20068                                  ;COUNT2:
 20069                                  ;	push	di		; Count number of chars until nul
 20070                                  ;	call	SCASB2
 20071                                  ;COUNTX:
 20072 00002363 59                      	pop	cx
 20073 00002364 29CF                    	sub	di,cx
 20074 00002366 87F9                    	xchg	di,cx
 20075                                  move_name_retn:
 20076 00002368 C3                      	retn
 20077                                  
 20078                                  ; =============== S U B	R O U T	I N E =======================================
 20079                                  
 20080                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20081                                  move_name:
 20082 00002369 803C0D                  	cmp	byte [si],13 ; 0Dh
 20083 0000236C 74FA                    	je	short move_name_retn
 20084 0000236E AC                      	lodsb
 20085                                  	; 23/02/2023 
 20086                                  	; MSDOS 6.0 (& 5.0)
 20087 0000236F E84600                  	call	testkanj		
 20088 00002372 7409                    	jz	short notkanj1
 20089 00002374 E88D00                  	call	store_char
 20090 00002377 AC                      	lodsb
 20091 00002378 E88900                  	call	store_char
 20092 0000237B EBEC                    	jmp	short move_name
 20093                                  notkanj1: 
 20094 0000237D E86200                  	call	UPCONV
 20095                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3
 20096 00002380 E88100                  	call	store_char
 20097 00002383 3C3D                    	cmp	al,'='
 20098 00002385 75E2                    	jne	short move_name
 20099                                  getarg_retn:
 20100 00002387 C3                      	retn
 20101                                  
 20102                                  ; =============== S U B	R O U T	I N E =======================================
 20103                                  
 20104                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20105                                  GETARG:
 20106 00002388 BE8000                  	mov	si,80h
 20107 0000238B AC                      	lodsb
 20108 0000238C 08C0                    	or	al,al
 20109 0000238E 74F7                    	jz	short getarg_retn
 20110 00002390 E84402                  	call	scanoff
 20111 00002393 3C0D                    	cmp	al,13 ; 0Dh
 20112                                  sdn_retn:
 20113 00002395 C3                      	retn
 20114                                  
 20115                                  ; =============== S U B	R O U T	I N E =======================================
 20116                                  
 20117                                  ; Point ES:DI to the final NULL string. Note that in an empty environment,
 20118                                  ; there is NO double NULL, merely a string that is empty.
 20119                                  
 20120                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20121                                  scan_double_null:
 20122 00002396 8E06[9C8A]              	mov	es,[RESSEG]
 20123 0000239A 268E06[3F03]            	mov	es,[es:EnvirSeg]
 20124 0000239F 31FF                    	xor	di,di
 20125                                  
 20126                                  ; Top cycle-point. If the string here is empty, then we are done
 20127                                  
 20128                                  sdn1:
 20129 000023A1 26803D00                	cmp	byte [es:di],0	; nul string?
 20130 000023A5 74EE                    	jz	short sdn_retn	; yep, all done
 20131 000023A7 E80600                  	call	SCASB2
 20132 000023AA EBF5                    	jmp	short sdn1
 20133                                  
 20134                                  ; =============== S U B	R O U T	I N E =======================================
 20135                                  
 20136                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20137                                  SCASB1:
 20138 000023AC B03D                    	mov	al,'='		; Scan for an =
 20139 000023AE EB02                    	jmp	short SCASBX
 20140                                  
 20141                                  ; =============== S U B	R O U T	I N E =======================================
 20142                                  
 20143                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20144                                  SCASB2:
 20145 000023B0 30C0                    	xor	al,al		; Scan for a nul
 20146                                  
 20147                                  ; ---------------------------------------------------------------------------
 20148                                  
 20149                                  	; 23/02/2023
 20150                                  SCASBX:
 20151 000023B2 B90001                  	mov	cx,256
 20152 000023B5 F2AE                    	repne	scasb
 20153 000023B7 C3                      	retn
 20154                                  
 20155                                  ; =============== S U B	R O U T	I N E =======================================
 20156                                  
 20157                                  ; MSDOS 6.0
 20158                                  
 20159                                  ;Bugbug: This is Kanji stuff - put it in conditionals
 20160                                  
 20161                                  	; 23/02/2023 - Retro DOS v4.0 COMMAND.COM
 20162                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:249Ah
 20163                                  testkanj:
 20164 000023B8 1E                      	push	ds			;AN000;  3/3/KK
 20165 000023B9 56                      	push	si			;AN000;  3/3/KK
 20166 000023BA 50                      	push	ax			;AN000;  3/3/KK
 20167 000023BB 2E8E1E[9C8A]            	mov	ds,[cs:RESSEG]		;AN000;  Get resident segment
 20168 000023C0 C536[BF01]              	lds	si,[Dbcs_Vector_Addr]	;AN000;  get DBCS vector
 20169                                  ktlop:					;AN000;  3/3/KK
 20170 000023C4 833C00                  	cmp	word [si],0		;AN000;  end of Table 3/3/KK
 20171 000023C7 740E                    	je	short notlead 		;AN000;  3/3/KK
 20172 000023C9 58                      	pop	ax			;AN000;  3/3/KK
 20173 000023CA 50                      	push	ax			;AN000;  3/3/KK
 20174 000023CB 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20175 000023CD 7208                    	jb	short notlead 		;AN000;  3/3/KK
 20176 000023CF 46                      	inc	si			;AN000;  3/3/KK
 20177 000023D0 3A04                    	cmp	al,[si]			;AN000;  3/3/KK
 20178 000023D2 7607                    	jbe	short islead		;AN000;  3/3/KK
 20179 000023D4 46                      	inc	si			;AN000;  3/3/KK
 20180 000023D5 EBED                    	jmp	short ktlop		;AN000;  try another range ; 3/3/KK
 20181                                  notlead:				;AN000;  3/3/KK
 20182 000023D7 31C0                    	xor	ax,ax			;AN000;  set zero 3/3/KK
 20183 000023D9 EB03                    	jmp	short ktret		;AN000;  3/3/KK
 20184                                  islead: 				;AN000;  3/3/KK
 20185 000023DB 31C0                    	xor	ax,ax			;AN000;  reset zero 3/3/KK
 20186 000023DD 40                      	inc	ax			;AN000;  3/3/KK
 20187                                  ktret:					;AN000;  3/3/KK
 20188 000023DE 58                      	pop	ax			;AN000;  3/3/KK
 20189 000023DF 5E                      	pop	si			;AN000;  3/3/KK
 20190 000023E0 1F                      	pop	ds			;AN000;  3/3/KK
 20191 000023E1 C3                      	retn				;AN000;  3/3/KK
 20192                                  
 20193                                  ; =============== S U B	R O U T	I N E =======================================
 20194                                  
 20195                                  ; MSDOS 6.0
 20196                                  
 20197                                  ; ****************************************************************
 20198                                  ; *
 20199                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 20200                                  ; *
 20201                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 20202                                  ; *		 the character in AL from the file upper case table
 20203                                  ; *		 in DOS if character if above  ascii 128, else
 20204                                  ; *		 subtracts 20H if between "a" and "z".
 20205                                  ; *
 20206                                  ; * INPUT:	 AL	      char to be upper cased
 20207                                  ; *		 FUCASE_ADDR  set to the file upper case table
 20208                                  ; *
 20209                                  ; * OUTPUT:	 AL	      upper cased character
 20210                                  ; *
 20211                                  ; ****************************************************************
 20212                                  
 20213                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20214                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:24C4h
 20215                                  UPCONV:
 20216 000023E2 3C80                    	cmp	al,80h			;AN000;  see if char is > ascii 128
 20217 000023E4 7213                    	jb	short oth_fucase	;AN000;  no - upper case math
 20218 000023E6 2C80                    	sub	al,80h			;AN000;  only upper 128 chars in table
 20219 000023E8 1E                      	push	ds			;AN000;
 20220 000023E9 53                      	push	bx			;AN000;
 20221 000023EA 8E1E[9C8A]              	mov	ds,[RESSEG]		;AN000;  get resident data segment
 20222                                  	;lds	bx,dword ptr FUCase_Addr+1
 20223 000023EE C51E[B701]              	lds	bx,[FUCase_Addr+1]	;AN000;  get table address
 20224 000023F2 83C302                  	add	bx,2			;AN000;  skip over first word
 20225                                  	;xlat	ds:byte ptr [bx]	;AN000;  convert to upper case
 20226 000023F5 D7                      	xlat
 20227 000023F6 5B                      	pop	bx			;AN000;
 20228 000023F7 1F                      	pop	ds			;AN000;
 20229                                  	;jmp	short upconv_end	;AN000;  we finished - exit
 20230                                  	; 24/02/2023
 20231 000023F8 C3                      	retn
 20232                                  oth_fucase:				;AN000;
 20233 000023F9 3C61                    	cmp	al,'a' ; small_a	;AC000; if between "a" and "z",
 20234 000023FB 7206                    	jb	short upconv_end	;AC000;    subtract 20h to get
 20235 000023FD 3C7A                    	cmp	al,'z' ; small_z	;AC000;    upper case equivalent.
 20236 000023FF 7702                    	ja	short upconv_end	;AC000;
 20237 00002401 2C20                    	sub	al,20h			;AC000; Change lower-case to upper
 20238                                  upconv_end:				;AN000;
 20239 00002403 C3                      	retn
 20240                                  
 20241                                  ; ---------------------------------------------------------------------------
 20242                                  
 20243                                  ; MSDOS 3.3
 20244                                  
 20245                                  	; 24/02/2023
 20246                                  ;UPCONV_MAPCALL:
 20247                                  	;			; If between "a" and "z"
 20248                                  	;cmp	al,[small_a]
 20249                                  	;jb	short UPCONV_END
 20250                                  	;cmp	al,[small_z]
 20251                                  	;ja	short UPCONV_END
 20252                                  	;sub	al,20h		; Change lower-case to upper
 20253                                  ;UPCONV_END:
 20254                                  	;call	far [cs:MAP_CALL] ; (far) call to char mapping routine 
 20255                                  	;			  ; 	  for (current) country
 20256                                  	;retn
 20257                                  
 20258                                  ; =============== S U B	R O U T	I N E =======================================
 20259                                  
 20260                                  ; STORE A CHAR IN environment, GROWING IT IF NECESSARY
 20261                                  
 20262                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20263                                  	; 10/06/2023
 20264                                  store_char:
 20265 00002404 51                      	push	cx
 20266 00002405 53                      	push	bx
 20267                                  
 20268                                  	; 24/02/2023
 20269                                  	;;16/10/2018
 20270                                  	; MSDOS 6.0
 20271 00002406 06                      	push	es		;AN056;*
 20272 00002407 1E                      	push	ds		;AN056; Save local DS
 20273 00002408 8E1E[9C8A]              	mov	ds,[RESSEG]	;AN056; Get resident segment
 20274 0000240C 8E06[3F03]              	mov	es,[EnvirSeg]	;AN056; Get environment segment
 20275 00002410 1F                      	pop	ds		;AN056; Get local segment back
 20276                                  
 20277                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20278 00002411 E85200                  	call	GETENVSIZ
 20279 00002414 89CB                    	mov	bx,cx		; Save room for double nul	
 20280 00002416 83EB02                  	sub	bx,2
 20281 00002419 39DF                    	cmp	di,bx
 20282 0000241B 723F                    	jb	short store1
 20283 0000241D 50                      	push	ax
 20284 0000241E 51                      	push	cx
 20285 0000241F 53                      	push	bx		; Save Size of environment
 20286 00002420 E8E1E2                  	call	FREE_TPA
 20287 00002423 5B                      	pop	bx
 20288 00002424 83C302                  	add	bx,2		; Recover true environment size
 20289                                  
 20290 00002427 81FB0080                	cmp	bx,8000h	; Don't let environment grow > 32K	
 20291 0000242B 7203                    	jb	short envsiz_ok
 20292                                  bad_env_size:			;AN056;
 20293 0000242D F9                      	stc
 20294 0000242E EB16                    	jmp	short envnoset
 20295                                  	;nop
 20296                                  envsiz_ok:
 20297 00002430 B104                    	mov	cl,4
 20298 00002432 D3EB                    	shr	bx,cl		; Convert back to paragraphs
 20299 00002434 43                      	inc	bx
 20300                                  	; 24/02/2023
 20301                                  	; MSDOS 6.0
 20302 00002435 8CC1                    	mov	cx,es		;AN056; Get environment segment
 20303 00002437 01D9                    	add	cx,bx		;AN056; Add in size of environment
 20304 00002439 83C120                  	add	cx,20h		;AN056; Add in some TPA
 20305 0000243C 8CC8                    	mov	ax,cs		;AN056; Get the transient segment
 20306 0000243E 39C1                    	cmp	cx,ax		;AN056; Are we hitting the transient?
 20307 00002440 73EB                    	jnb	short bad_env_size
 20308                                  				;AN056; Yes - don't do it!!!
 20309                                  	; MSDOS 3.3 (& MSDOS 6.0)
 20310 00002442 B44A                    	mov	ah,4Ah
 20311                                  	;mov	ah,SETBLOCK ; 4Ah
 20312 00002444 CD21                    	int	21h	; DOS -	2+ - ADJUST MEMORY BLOCK SIZE (SETBLOCK)
 20313                                  			; ES = segment address of block	to change
 20314                                  			; BX = new size	in paragraphs
 20315                                  envnoset:
 20316 00002446 9C                      	pushf
 20317 00002447 06                      	push	es
 20318 00002448 8E06[9C8A]              	mov	es,[RESSEG]
 20319 0000244C E8C5E2                  	call	ALLOC_TPA
 20320 0000244F 07                      	pop	es
 20321 00002450 9D                      	popf
 20322 00002451 59                      	pop	cx
 20323 00002452 58                      	pop	ax
 20324                                  	; 24/02/2023
 20325                                  	;pop	es ; MSDOS 6.0	;AN056;*	
 20326 00002453 7307                    	jnc	short store1
 20327                                  	; 10/06/2023 (BugFix)
 20328 00002455 07                      	pop	es ; MSDOS 6.0	;AN056;*	
 20329 00002456 BA[487F]                	mov	dx,ENVERR_PTR
 20330 00002459 E9EF04                  	jmp	cerror
 20331                                  store1:	
 20332 0000245C AA                      	stosb
 20333 0000245D 26C7050000              	mov	word [es:di],0	; NULL IS AT END
 20334                                  	; 24/02/2023
 20335 00002462 07                      	pop	es ; MSDOS 6.0	;AN056;*
 20336 00002463 5B                      	pop	bx
 20337 00002464 59                      	pop	cx
 20338 00002465 C3                      	retn
 20339                                  
 20340                                  ; =============== S U B	R O U T	I N E =======================================
 20341                                  
 20342                                  	; 24/02/2023
 20343                                  GETENVSIZ:
 20344                                  
 20345                                  ;Get size of environment in bytes, rounded up to paragraph boundry
 20346                                  ;ES has environment segment
 20347                                  ;Size returned in CX, all other registers preserved
 20348                                  
 20349 00002466 06                      	push	es
 20350 00002467 50                      	push	ax
 20351 00002468 8CC0                    	mov	ax,es
 20352 0000246A 48                      	dec	ax		;Point at arena	
 20353 0000246B 8EC0                    	mov	es,ax
 20354                                  	;mov	ax,[es:3]
 20355 0000246D 26A10300                	mov	ax,[es:ARENA.size]
 20356 00002471 B104                    	mov	cl,4
 20357 00002473 D3E0                    	shl	ax,cl		;Convert to bytes
 20358 00002475 89C1                    	mov	cx,ax
 20359 00002477 58                      	pop	ax
 20360 00002478 07                      	pop	es
 20361                                  getenvsiz_retn:
 20362 00002479 C3                      	retn
 20363                                  
 20364                                  ; =============== S U B	R O U T	I N E =======================================
 20365                                  
 20366                                  	; 24/02/2023
 20367                                  RestUDir1:
 20368 0000247A 1E                      	push	ds
 20369 0000247B 8E1E[9C8A]              	mov	ds,[RESSEG]
 20370 0000247F 803E[A401]00            	cmp	byte [RestDir],0
 20371 00002484 1F                      	pop	ds
 20372 00002485 74F2                    	jz	short getenvsiz_retn
 20373                                  
 20374                                  ; =============== S U B	R O U T	I N E =======================================
 20375                                  
 20376                                  	; 24/02/2023
 20377                                  RestUDir:
 20378 00002487 BA[7E89]                	mov	dx,USERDIR1
 20379 0000248A B43B                    	mov	ah,3Bh
 20380                                  	;mov	ah,CHDir ; 3Bh
 20381 0000248C CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20382                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 20383 0000248E 30C0                    	xor	al,al
 20384                                  	;call	SETREST
 20385                                  	;retn
 20386                                  	; 24/02/2023
 20387 00002490 E94B08                  	jmp	SETREST	
 20388                                  
 20389                                  ;============================================================================
 20390                                  ; TENV2.ASM, MSDOS 6.0, 1991
 20391                                  ;============================================================================
 20392                                  ; 07/10/2018 - Retro DOS v3.0
 20393                                  
 20394                                  ; TITLE	Part6 COMMAND Transient routines.
 20395                                  
 20396                                  ;	Environment utilities and misc. routines
 20397                                  
 20398                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 18C2h
 20399                                  
 20400                                  ; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20401                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2577h
 20402                                  
 20403                                  ; ---------------------------------------------------------------------------
 20404                                  
 20405                                  ; ****************************************************************
 20406                                  ; *
 20407                                  ; * ROUTINE:	 $CHDIR
 20408                                  ; *
 20409                                  ; * FUNCTION:	 Entry point for CHDIR command. Parse the command
 20410                                  ; *		 line. If path is found, CHDIR to path. If a drive
 20411                                  ; *		 letter is found, get and display the current dir
 20412                                  ; *		 of the specified drive. If nothing is found, get
 20413                                  ; *		 and display the current dir of the default drive.
 20414                                  ; *
 20415                                  ; * INPUT:	 command line at offset 81H
 20416                                  ; *
 20417                                  ; * OUTPUT:	 none
 20418                                  ; *
 20419                                  ; ****************************************************************
 20420                                  
 20421                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20422                                  	; 10/06/2023
 20423                                  _$CHDIR:
 20424                                  	; MSDOS 6.0
 20425 00002493 BE8100                  	mov	si,81h
 20426 00002496 BF[2685]                	mov	di,PARSE_CHDIR
 20427                                  				;AN000; Get address of PARSE_CHDIR
 20428 00002499 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20429 0000249B 31D2                    	xor	dx,dx		;AN000;
 20430 0000249D E812FD                  	call	Parse_With_Msg	;AC018; call parser
 20431                                  	
 20432                                  	;cmp	ax,-1
 20433                                  	;;cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 20434                                  	;je	short bwdj	; No args
 20435                                  	;;cmp	ax,0
 20436                                  	;;cmp	ax,RESULT_NO_ERROR
 20437                                  	;			;AC000; did we have an error?
 20438                                  	;or	ax,ax ; ax = 0 ?
 20439                                  	;jnz	short ChDirErr	;AC018; yes - exit
 20440                                  	
 20441                                  	; 10/06/2023
 20442 000024A0 40                      	inc	ax	; cmp ax,-1
 20443 000024A1 7414                    	jz	short bwdj ; 0FFFFh -> 0
 20444 000024A3 48                      	dec	ax	; cmp ax,0
 20445 000024A4 756D                    	jnz	short ChDirErr ; 1 -> 0
 20446                                  	; ax = 0	
 20447                                  
 20448                                  	;cmp	byte [PARSE1_TYPE],6
 20449 000024A6 803E[CB95]06            	cmp	byte [PARSE1_TYPE],result_drive
 20450                                  				;AC000; was a drive entered?
 20451 000024AB 7511                    	jne	short REALCD	; no
 20452                                  
 20453                                  ; D: was found. See if there is anything more.
 20454                                  
 20455 000024AD BF[2685]                	mov	di,PARSE_CHDIR
 20456                                  				;AC000; get address of parse_chdir
 20457 000024B0 31D2                    	xor	dx,dx		;AC000;
 20458 000024B2 E8E7FC                  	call	parse_check_eol ;AC000; call parser
 20459 000024B5 755C                    	jnz	short ChDirErr	;AC000;
 20460                                  bwdj:
 20461 000024B7 E87BF9                  	call	build_dir_for_chdir
 20462                                  				; Drive only specified
 20463 000024BA E80D01                  	call	CRLF2
 20464                                  chdir_retn:
 20465 000024BD C3                      	retn
 20466                                  
 20467                                  	; 24/02/2023
 20468                                  	; MSDOS 3.3
 20469                                  	;mov	ax,[COMSW]
 20470                                  	;or	ax,[ALLSWITCH]
 20471                                  	;mov	dx,BADPARMPTR
 20472                                  	;jnz	short CHDIR_ERR
 20473                                  	;mov	si,81h
 20474                                  	;call	SCANOFF
 20475                                  	;cmp	al,0Dh		; are we at end of line?
 20476                                  	;je	short BWDJ	; No args
 20477                                  	;inc	si
 20478                                  	;lodsb
 20479                                  	;cmp	al,':'
 20480                                  	;jne	short REALCD
 20481                                  	;push	si
 20482                                  	;call	SCANOFF
 20483                                  	;pop	si
 20484                                  	;cmp	al,0Dh		; was a drive entered?
 20485                                  	;jne	short REALCD	; no
 20486                                  ;BWDJ:
 20487                                  	;call	BUILD_DIR_FOR_CHDIR ; Drive only specified
 20488                                  	;call	CRLF2
 20489                                  ;CHDIR_RETN:
 20490                                  	;retn
 20491                                  
 20492                                  	; 24/02/2023
 20493                                  	; MSDOS 6.0
 20494                                  REALCD:
 20495 000024BE 56                      	push	si		;AN000; save position in line
 20496 000024BF C536[CF95]              	lds	si,[PARSE1_ADDR]
 20497                                  				;AN000; get address of filespec
 20498 000024C3 E8DA07                  	call	Move_To_SrcBuf	;AN000; move to srcbuf
 20499 000024C6 5E                      	pop	si		;AN000; restore position in line
 20500 000024C7 BF[2685]                	mov	di,PARSE_CHDIR	;AC000; get address of parse_chdir
 20501 000024CA 31D2                    	xor	dx,dx		;AC000;
 20502 000024CC E8CDFC                  	call	parse_check_eol ;AC000; call parser
 20503 000024CF 7542                    	jnz	short ChDirErr	;AC000;
 20504                                  	
 20505 000024D1 E81106                  	call	SETPATH
 20506 000024D4 F606[A78C]02            	test	byte [DestInfo],2
 20507 000024D9 7518                    	jnz	short BadChDir
 20508                                  
 20509                                  	; 26/04/2023
 20510 000024DB B43B                    	mov	ah,3Bh
 20511                                  	;mov	ah,CHDir
 20512 000024DD CD21                    	int	21h
 20513 000024DF 73DC                    	jnc	short chdir_retn
 20514                                  	
 20515 000024E1 E818F8                  	call	get_ext_error_number
 20516                                  				;AN022; get the extended error
 20517 000024E4 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20518                                  				;AN022; see if path not found
 20519 000024E7 740A                    	je	short BadChDir	;AN022; yes - issue old message
 20520                                  ;SR;
 20521                                  ; We want to issue "Invalid Directory" message even if the path is valid
 20522                                  ;but is not a directory. The extended error returns "Access denied" which
 20523                                  ;is kind of confusing. Issue the old message if access denied error is 
 20524                                  ;returned
 20525                                  
 20526 000024E9 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20527 000024EC 7405                    	je	short BadChDir
 20528                                  	
 20529 000024EE E89E00                  	call	set_ext_error_subst ;AN022;
 20530 000024F1 EB20                    	jmp	short ChDirErr	;AN022;
 20531                                  
 20532                                  BadChDir:
 20533 000024F3 BA[6C80]                	mov	dx,badcd_ptr
 20534                                  ;ChDirErr:
 20535                                  ;	call	std_eprintf
 20536                                  ;mkdir_retn:
 20537                                  	;retn
 20538                                  	; 24/02/2023
 20539 000024F6 EB1B                    	jmp	short ChDirErr	;AN022;
 20540                                  
 20541                                  	; 24/02/2023
 20542                                  	; MSDOS 3.3
 20543                                  ;REALCD:
 20544                                  	;call	SETPATH
 20545                                  	;test	byte [DESTINFO],2
 20546                                  	;jnz	short BADCHDIR
 20547                                  	;mov	ah,CHDir ; 3Bh
 20548                                  	;int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 20549                                  	;		; DS:DX	-> ASCIZ directory name	(may include drive)
 20550                                  	;jnc	short CHDIR_RETN
 20551                                  ;BADCHDIR:
 20552                                  	;mov	dx,BADCDPTR
 20553                                  ;CHDIR_ERR:
 20554                                  	;call	STD_EPRINTF
 20555                                  ;MKDIR_RETN:
 20556                                  	;retn
 20557                                  
 20558                                  ; =============== S U B	R O U T	I N E =======================================
 20559                                  
 20560                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20561                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:25E2h
 20562                                  _$MKDIR:
 20563                                  	; MSDOS 6.0
 20564 000024F8 E86300                  	call	SETRMMK
 20565 000024FB 7216                    	jc	short MkDirErr
 20566                                  
 20567 000024FD B439                    	mov	ah,39h
 20568                                  	;mov	ah,MKDIR
 20569 000024FF CD21                    	int	21h
 20570 00002501 7313                    	jnc	short mkdir_retn
 20571                                  
 20572 00002503 E8F6F7                  	call	get_ext_error_number	
 20573                                  				;AN022; get the extended error
 20574 00002506 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20575                                  				;AN022; see if path not found
 20576 00002509 742A                    	je	short MD_other_err
 20577                                  				;AN022; yes - issue old message
 20578 0000250B 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20579                                  				;AN022; access denied?
 20580 0000250E 7407                    	je	short badmderr	;AN022; yes - see if file exists
 20581                                  	
 20582 00002510 E87C00                  	call	set_ext_error_subst
 20583                                  				;AN022;
 20584                                  	;jmp	short MkDirerr	;AC022; yes - go print it
 20585                                  	; 24/02/2023
 20586                                  ChDirErr:
 20587                                  MkDirErr:
 20588                                  RmDirErr:
 20589 00002513 E8E528                  	call	std_eprintf
 20590                                  mkdir_retn:
 20591                                  rmdir_retn:
 20592 00002516 C3                      	retn
 20593                                  	
 20594                                  badmderr:
 20595 00002517 BA[CA87]                	mov	dx,SRCXNAME	;AN006; Set Disk transfer address
 20596 0000251A B41A                    	mov	ah,1Ah
 20597                                  	;mov	ah,Set_DMA	;AN006;
 20598 0000251C CD21                    	int	21h		;AN006;
 20599                                  	
 20600 0000251E B44E                    	mov	ah,4Eh
 20601                                  	;mov	ah,Find_First	;AN006; see if file/dir exists
 20602                                  	;mov	cx,10h
 20603 00002520 B91000                  	mov	cx,ATTR_DIRECTORY
 20604                                  				;AN006;   search for directory
 20605 00002523 CD21                    	int	21h		;AN006;
 20606 00002525 720E                    	jc	short MD_other_err
 20607                                  				;AN006; doesn't exist - must be something else
 20608                                  	;;mov	dl,SRCXNAME.find_buf_attr
 20609                                  				;AN006; we found a file/dir
 20610                                  	;mov	dl,[SRCXNAME+21] 
 20611 00002527 8A16[DF87]              	mov	dl,[SRCXNAME+FIND_BUF.ATTR]
 20612 0000252B F6C210                  	test	dl,ATTR_DIRECTORY
 20613                                  				;AN006; was it a directory?
 20614 0000252E 7405                    	jz	short MD_other_err
 20615                                  				;AN006; no - must have been a file
 20616 00002530 BA[5C81]                	mov	dx,MD_EXISTS_PTR
 20617                                  				;AN006; set up already exists error
 20618 00002533 EBDE                    	jmp	short MkDirErr	;AN006; make sure we didn't have network error
 20619                                  MD_other_err:			;AN006;
 20620 00002535 BA[6F80]                	mov	dx,badmkd_ptr
 20621                                  ;MkDirErr:
 20622                                  	;call	std_eprintf
 20623                                  	;retn
 20624                                  	; 24/02/2023
 20625 00002538 EBD9                    	jmp	short MkDirErr
 20626                                  
 20627                                  	; 24/02/2023
 20628                                  	; MSDOS 3.3
 20629                                  	;call	SETRMMK
 20630                                  	;jb	short MKDIRERR
 20631                                  	;mov	ah,MKDIR ; 39h
 20632                                  	;int	21h	; DOS -	2+ - CREATE A SUBDIRECTORY (MKDIR)
 20633                                  	;		; DS:DX	-> ASCIZ pathname (may include drive)
 20634                                  	;jnc	short MKDIR_RETN
 20635                                  	;mov	dx,BADMKDPTR
 20636                                  	;call	GET_EXT_ERR_NUMBER
 20637                                  ;MKDIRERR:
 20638                                  	;call	STD_EPRINTF
 20639                                  	;retn
 20640                                  
 20641                                  ; =============== S U B	R O U T	I N E =======================================
 20642                                  
 20643                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20644                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2656h
 20645                                  _$RMDIR:
 20646 0000253A E82100                  	call	SETRMMK
 20647 0000253D 72D4                    	jb	short RmDirErr
 20648 0000253F 7518                    	jnz	short badrderr
 20649                                  
 20650 00002541 B43A                    	mov	ah,3Ah
 20651                                  	;mov	ah,RMDIR ; 3Ah
 20652 00002543 CD21                    	int	21h	; DOS -	2+ - REMOVE A DIRECTORY	ENTRY (RMDIR)
 20653                                  			; DS:DX	-> ASCIZ pathname (may include drive)
 20654 00002545 73CF                    	jnc	short rmdir_retn ; 24/02/2023
 20655                                  
 20656                                  	; 24/02/2023
 20657                                  	; MSDOS 6.0
 20658 00002547 E8B2F7                  	call	get_ext_error_number
 20659                                  				;AN022; get the extended error
 20660 0000254A 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ; 3
 20661                                  				;AN022; see if path not found
 20662 0000254D 740A                    	je	short badrderr	;AN022; yes - issue old message
 20663 0000254F 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 20664                                  				;AN022; access denied?
 20665 00002552 7405                    	je	short badrderr	;AN022; yes - issue old message
 20666                                  
 20667 00002554 E83800                  	call	set_ext_error_subst
 20668                                  				;AN022;
 20669 00002557 EBBA                    	jmp	short RmDirErr	;AC022; yes - go print it
 20670                                  
 20671                                  	; MSDOS 6.0
 20672                                  badrderr:
 20673                                  	; 24/02/2023
 20674 00002559 BA[7280]                	mov	dx,badrmd_ptr
 20675 0000255C EBB5                    	jmp	short RmDirErr
 20676                                  ;RmDirErr:
 20677                                  	;call	std_eprintf
 20678                                  ;;rmdir_retn
 20679                                  	;retn
 20680                                  
 20681                                  	; 24/02/2023
 20682                                  	; MSDOS 3.3
 20683                                  	;mov	dx,BADRMDPTR
 20684                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 20685                                  ;RMDIRERR:
 20686                                  	;call	STD_EPRINTF
 20687                                  ;RMDIR_RETN:
 20688                                  	;retn
 20689                                  
 20690                                  ; =============== S U B	R O U T	I N E =======================================
 20691                                  
 20692                                  ; 	<Common MkDir/RmDir set up code>
 20693                                  ;****************************************************************
 20694                                  ;*
 20695                                  ;* ROUTINE:	SETRMMK
 20696                                  ;*
 20697                                  ;* FUNCTION:	Parse routine for the internal MKDIR and RMDIR
 20698                                  ;*		commands. Parses the command line for a required
 20699                                  ;*		filespec.
 20700                                  ;*
 20701                                  ;* INPUT:	command line at offset 81H
 20702                                  ;*
 20703                                  ;* OUTPUT:	carry clear
 20704                                  ;*		    DS:DX points to ASCIIZ argument
 20705                                  ;*		carry set
 20706                                  ;*		    DS:DX has error message pointer
 20707                                  ;*
 20708                                  ;****************************************************************
 20709                                  
 20710                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20711                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2624h
 20712                                  SETRMMK:
 20713                                  	; MSDOS 6.0
 20714 0000255E BE8100                  	mov	si,81h
 20715 00002561 BF[1D85]                	mov	di,PARSE_MRDIR 	;AN000; Get address of PARSE_MRDIR
 20716 00002564 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 20717 00002566 31D2                    	xor	dx,dx		;AN000;
 20718                                  	;invoke	Parse_With_Msg	;AC000; call parser
 20719 00002568 E847FC                  	call	Parse_With_Msg
 20720                                  	;cmp	ax,0
 20721                                  	;cmp	ax,RESULT_NO_ERROR
 20722 0000256B 09C0                    	or	ax,ax ; 0 ?	;AC000; did we have an error?
 20723 0000256D 7519                    	jnz	short noargerr	;AC000; yes - exit
 20724                                  
 20725 0000256F BF[CA87]                	mov	di,SRCXNAME
 20726                                  				;AN000; get address of srcxname
 20727 00002572 57                      	push	di		;AN000; save address
 20728 00002573 56                      	push	si		;AN000; save position in line
 20729 00002574 C536[CF95]              	lds	si,[PARSE1_ADDR]
 20730                                  				;AN000; get address of path
 20731                                  mrdir_move_filename:		;AN000; put filespec in srcxname
 20732 00002578 AC                      	lodsb			;get a char from buffer
 20733 00002579 AA                      	stosb			;AN000; store in srcxname
 20734                                  	;cmp	al,0
 20735                                  	;cmp	al,END_OF_LINE_OUT
 20736 0000257A 20C0                    	and	al,al ; 0 ?	;AC000; it char a terminator?
 20737 0000257C 75FA                    	jnz	short mrdir_move_filename
 20738                                  				;AC000; no - keep moving
 20739 0000257E 5E                      	pop	si		;AN000; get line position back
 20740                                  
 20741                                  ; we have scanned an argument.	See if any args beyond.
 20742                                  
 20743 0000257F BF[1D85]                	mov	di,PARSE_MRDIR
 20744 00002582 E817FC                  	call	parse_check_eol ;AC000; are we at end of line?
 20745 00002585 5A                      	pop	dx		;AC000; get address of SRCXNAME
 20746                                  	;retz			;yes - return no error
 20747 00002586 7406                    	jz	short setrmmk_retn
 20748                                  noargerr:
 20749 00002588 BA[317F]                	mov	dx,extend_buf_ptr
 20750                                  				;AC000; get extended message pointer
 20751 0000258B 31C0                    	xor	ax,ax
 20752 0000258D F9                      	stc
 20753                                  setrmmk_retn:
 20754 0000258E C3                      	retn
 20755                                  
 20756                                  	; 24/02/2023
 20757                                  	; MSDOS 3.3
 20758                                  ;SETRMMK:
 20759                                  	;mov	si,81h
 20760                                  	;call	SCANOFF
 20761                                  	;cmp	al,0Dh
 20762                                  	;je	short NOARGERR
 20763                                  	;mov	dx,si
 20764                                  ;SETRMMK1:
 20765                                  	;lodsb
 20766                                  	;call	DELIM
 20767                                  	;jz	short SETRMMK3
 20768                                  	;cmp	al,0Dh
 20769                                  	;jne	short SETRMMK1
 20770                                  	;mov	byte [si-1],0
 20771                                  ;SETRMMK2:
 20772                                  	;retn
 20773                                  ;SETRMMK3:
 20774                                  	;mov	byte [si-1],0
 20775                                  	;push	si
 20776                                  	;call	SCANOFF
 20777                                  	;pop	si
 20778                                  	;cmp	al,0Dh
 20779                                  	;je	short SETRMMK2
 20780                                  ;NOARGERR:
 20781                                  	;mov	dx,BADARGSPTR
 20782                                  	;xor	ax,ax
 20783                                  	;stc
 20784                                  ;SETRMMK_RETN:
 20785                                  	;retn
 20786                                  
 20787                                  ; =============== S U B	R O U T	I N E =======================================
 20788                                  
 20789                                  ; MSDOS 6.0
 20790                                  
 20791                                  ;****************************************************************
 20792                                  ;*
 20793                                  ;* ROUTINE:	Set_ext_error_subst
 20794                                  ;*
 20795                                  ;* FUNCTION:	Sets up substitution for extended error
 20796                                  ;*
 20797                                  ;* INPUT:	AX - extended error number
 20798                                  ;*		DX - offset of string
 20799                                  ;*
 20800                                  ;* OUTPUT:	Extend_Buf_Ptr set up for STD_EPRINTF
 20801                                  ;*
 20802                                  ;****************************************************************
 20803                                  
 20804                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20805                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:267Ch
 20806                                  set_ext_error_subst:
 20807                                  	;mov	byte [msg_disp_class],1
 20808 0000258F C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class
 20809                                  					;AN022; set up extended error msg class
 20810 00002594 8916[8C8C]              	mov	[string_ptr_2],dx 	;AN022; get address of failed string
 20811                                  	;mov	byte [extend_buf_sub],1
 20812 00002598 C606[337F]01            	mov	byte [extend_buf_sub],one_subst 
 20813                                  	;AN022; put number of subst in control block
 20814 0000259D BA[317F]                	mov	dx,extend_buf_ptr 	;AN022; get extended message pointer
 20815 000025A0 A3[317F]                	mov	[extend_buf_ptr],ax	;AN022; get message number in control block
 20816                                  savudir_err_retn: ; 24/02/2023
 20817 000025A3 C3                      	retn				;AN022; return
 20818                                  
 20819                                  ; =============== S U B	R O U T	I N E =======================================
 20820                                  
 20821                                  ; <SavUDir - preserve the users current directory on a particular drive>
 20822                                  
 20823                                  ; SavUDir - move the user's current directory on a drive into UserDir1
 20824                                  ; SavUDir1 - move the user's current directory on a drive into a specified
 20825                                  ;   buffer
 20826                                  ;
 20827                                  ;   Inputs:	DL has 1-based drive number
 20828                                  ;		ES:DI has destination buffer (SavUDir1 only)
 20829                                  ;   Outputs:	Carry Clear
 20830                                  ;		    DS = TranGroup
 20831                                  ;		Carry Set
 20832                                  ;		    AX has error code
 20833                                  ;   Registers Modified: AX, SI
 20834                                  
 20835                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20836                                  SAVUDIR:
 20837 000025A4 BF[7E89]                	mov	di,USERDIR1
 20838                                  ; --------------
 20839                                  SAVUDIR1:
 20840 000025A7 88D0                    	mov	al,dl
 20841 000025A9 0440                    	add	al,'@' ; 40h
 20842 000025AB 3C40                    	cmp	al,'@' ; 40h
 20843 000025AD 7506                    	jne	short GOTUDRV
 20844 000025AF 0206[B08A]              	add	al,[CURDRV]
 20845 000025B3 FEC0                    	inc	al		; A = 1
 20846                                  GOTUDRV:
 20847 000025B5 AA                      	stosb
 20848 000025B6 8A26[A18A]              	mov	ah,[DIRCHAR]
 20849 000025BA B03A                    	mov	al,':' ; 3Ah
 20850 000025BC AB                      	stosw
 20851 000025BD 06                      	push	es
 20852 000025BE 1F                      	pop	ds
 20853 000025BF 89FE                    	mov	si,di
 20854 000025C1 B447                    	mov	ah,47h ; 24/02/2023
 20855                                  	;mov	ah,CURRENT_DIR	; 47h
 20856 000025C3 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 20857                                  			; DL = drive (0=default,1=A,etc.)
 20858                                  			; DS:SI	points to 64-byte buffer area
 20859 000025C5 72DC                    	jc	short savudir_err_retn ; 24/02/2023
 20860 000025C7 0E                      	push	cs
 20861 000025C8 1F                      	pop	ds
 20862 000025C9 C3                      	retn
 20863                                  
 20864                                  ; =============== S U B	R O U T	I N E =======================================
 20865                                  
 20866                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20867                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:26B7h
 20868                                  CRLF2:
 20869 000025CA 52                      	push	dx
 20870 000025CB BA[1081]                	mov	dx,acrlf_ptr
 20871 000025CE 1E                      	push	ds
 20872 000025CF 0E                      	push	cs
 20873 000025D0 1F                      	pop	ds
 20874 000025D1 E82F28                  	call	std_printf
 20875 000025D4 1F                      	pop	ds
 20876 000025D5 5A                      	pop	dx
 20877 000025D6 C3                      	retn
 20878                                  
 20879                                  ; =============== S U B	R O U T	I N E =======================================
 20880                                  
 20881                                  ; These routines (SCANOFF, DELIM) are called in batch processing when DS
 20882                                  ; may NOT be TRANGROUP
 20883                                  
 20884                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20885                                  scanoff:
 20886 000025D7 AC                      	lodsb
 20887 000025D8 E80400                  	call	DELIM
 20888 000025DB 74FA                    	jz	short scanoff
 20889 000025DD 4E                      	dec	si		; Point to first non-delimiter
 20890                                  scanoff_retn:
 20891 000025DE C3                      	retn
 20892                                  
 20893                                  ; =============== S U B	R O U T	I N E =======================================
 20894                                  
 20895                                  ; Input:    AL is character to classify
 20896                                  ; Output:   Z set if delimiter
 20897                                  ;	    NZ set otherwise
 20898                                  ; Registers modified: none
 20899                                  
 20900                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20901                                  DELIM:
 20902 000025DF 3C20                    	cmp	al,' '	 ;20h
 20903 000025E1 74FB                    	je	short scanoff_retn
 20904 000025E3 3C3D                    	cmp	al,'='  ; 3Dh
 20905 000025E5 74F7                    	je	short scanoff_retn
 20906 000025E7 3C2C                    	cmp	al,','	; 2Ch
 20907 000025E9 74F3                    	je	short scanoff_retn
 20908 000025EB 3C3B                    	cmp	al,';'	 ;3Bh
 20909 000025ED 74EF                    	je	short scanoff_retn
 20910 000025EF 3C09                    	cmp	al,9		; Check for TAB character
 20911 000025F1 74EB                    	je	short scanoff_retn
 20912 000025F3 3C0A                    	cmp	al,0Ah		; Check for line feed character - BAS
 20913 000025F5 C3                      	retn
 20914                                  
 20915                                  
 20916                                  ; =============== S U B	R O U T	I N E =======================================
 20917                                  
 20918                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20919                                  FCB_TO_ASCZ:			
 20920                                  	; Convert DS:SI to ASCIZ ES:DI
 20921 000025F6 B90800                  	mov	cx,8
 20922                                  MAINNAME:
 20923 000025F9 AC                      	lodsb
 20924 000025FA 3C20                    	cmp	al,' ' ; 20h
 20925 000025FC 7401                    	jz	short SKIPSPC
 20926 000025FE AA                      	stosb
 20927                                  SKIPSPC:
 20928 000025FF E2F8                    	loop	MAINNAME
 20929 00002601 AC                      	lodsb
 20930 00002602 3C20                    	cmp	al,' '
 20931 00002604 740F                    	je	short GOTNAME
 20932 00002606 88C4                    	mov	ah,al
 20933                                  	; 24/02/2023
 20934 00002608 B02E                    	mov	al,'.' ; 2Eh  ; MSDOS 5.0 (& 6.0)
 20935                                  	;mov	al,[DOT_CHR]  ; MSDOS 3.3
 20936                                  	;stosb
 20937                                  	;xchg	al,ah
 20938                                  	;stosb
 20939                                  	; 24/02/2023
 20940 0000260A AB                      	stosw
 20941 0000260B B102                    	mov	cl,2
 20942                                  EXTNAME:
 20943 0000260D AC                      	lodsb
 20944 0000260E 3C20                    	cmp	al,' '
 20945 00002610 7403                    	je	short GOTNAME
 20946 00002612 AA                      	stosb
 20947 00002613 E2F8                    	loop	EXTNAME
 20948                                  GOTNAME:
 20949 00002615 30C0                    	xor	al,al
 20950 00002617 AA                      	stosb
 20951                                  STRCOMP_RETN:
 20952 00002618 C3                      	retn
 20953                                  
 20954                                  ; =============== S U B	R O U T	I N E =======================================
 20955                                  
 20956                                  ; Compare ASCIZ DS:SI with ES:DI.
 20957                                  ; SI,DI destroyed.
 20958                                  
 20959                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 20960                                  STRCOMP:	
 20961 00002619 A6                      	cmpsb
 20962 0000261A 75FC                    	jnz	short STRCOMP_RETN ; Strings not equal
 20963 0000261C 807CFF00                	cmp	byte [si-1],0	; Hit NUL terminator?	
 20964                                  	;jz	short STRCOMP_RETN ; Yes, strings equal
 20965                                  	;jmp	short STRCOMP	; Equal so far, keep going
 20966                                  	; 24/02/2023
 20967 00002620 75F7                    	jnz	short STRCOMP
 20968 00002622 C3                      	retn
 20969                                  
 20970                                  ; =============== S U B	R O U T	I N E =======================================
 20971                                  
 20972                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 20973                                  CRPRINT:
 20974 00002623 50                      	push	ax
 20975                                  	;mov	al,13	; 0Dh
 20976 00002624 B00D                    	mov	al,0Dh
 20977 00002626 51                      	push	cx
 20978 00002627 57                      	push	di
 20979 00002628 89D7                    	mov	di,dx
 20980 0000262A B9FFFF                  	mov	cx,65535 ; 0FFFFh
 20981 0000262D 06                      	push	es
 20982 0000262E 1E                      	push	ds
 20983 0000262F 07                      	pop	es
 20984 00002630 F2AE                    	repne	scasb		; LOOK FOR TERMINATOR
 20985 00002632 C645FF00                	mov	byte [di-1],0	; nul terminate the string
 20986 00002636 07                      	pop	es
 20987 00002637 8916[8C8C]              	mov	[string_ptr_2],dx
 20988                                  	;mov	dx,STRINGBUF2PTR  ; MSDOS 3.3 (Retro DOS v3.0 COMMAND.COM)
 20989 0000263B BA[F880]                	mov	dx,string_buf_ptr ; MSDOS 5.0 (& 6.0)
 20990 0000263E E8C227                  	call	std_printf
 20991                                  	;mov	byte [di-1],13
 20992 00002641 C645FF0D                	mov	byte [di-1],0Dh	; now put the CR back
 20993 00002645 7204                    	jb	short error_output
 20994 00002647 5F                      	pop	di
 20995 00002648 59                      	pop	cx
 20996 00002649 58                      	pop	ax
 20997 0000264A C3                      	retn
 20998                                  
 20999                                  ; ---------------------------------------------------------------------------
 21000                                  
 21001                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21002                                  error_output:
 21003 0000264B 0E                      	push	cs
 21004 0000264C 1F                      	pop	ds
 21005 0000264D 8E06[9C8A]              	mov	es,[RESSEG]
 21006 00002651 BA[457F]                	mov	dx,NOSPACE_PTR
 21007 00002654 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 21008 0000265A 7406                    	jz	short go_to_error
 21009 0000265C E80409                  	call	PipeOff
 21010 0000265F BA[9280]                	mov	dx,PIPEEMES_PTR
 21011                                  go_to_error:
 21012 00002662 E9E602                  	jmp	cerror
 21013                                  
 21014                                  ; =============== S U B	R O U T	I N E =======================================
 21015                                  
 21016                                  ;---- Mod for path invocation ----
 21017                                  
 21018                                  	; 24/02/2023 - Retro DOS v4.0 (& v4.1)
 21019                                  pathchrcmp:
 21020                                  	; 18/03/2023	
 21021                                  	;push	ax
 21022                                  	;mov	ah,'/' ; 2Fh
 21023                                  	;cmp	[SWITCHAR],ah
 21024 00002665 803E[A08A]2F            	cmp	byte [SWITCHAR],'/' ; 2Fh
 21025 0000266A 7404                    	je	short noslasht
 21026 0000266C 3C2F                    	cmp	al,'/'
 21027 0000266E 7402                    	je	short pccont
 21028                                  noslasht:
 21029 00002670 3C5C                    	cmp	al,'\' ; 5Ch
 21030                                  pccont:	
 21031                                  	;pop	ax
 21032 00002672 C3                      	retn
 21033                                  
 21034                                  ; =============== S U B	R O U T	I N E =======================================
 21035                                  
 21036                                  ; PATHCRUNCH -
 21037                                  ;
 21038                                  ; ENTRY FCB (in PSP) contains drive # to crunch on
 21039                                  ;       PathPos = ptr to string with pathname in it
 21040                                  ;       PathCnt = length of string
 21041                                  ;
 21042                                  ; EXIT  PathPos = ptr after pathname (w/ NULL) in string
 21043                                  ;       PathCnt = length left in string
 21044                                  ;       DestIsDir = nonzero if pathname delimiter char's found in pathname
 21045                                  ;       DestInfo<bit1> = set if wildcard char's found in pathname
 21046                                  ;       If path crunched successfully,
 21047                                  ;         CY = clear
 21048                                  ;         Current directory is changed to directory in pathname
 21049                                  ;         UserDir1 contains previous directory for use by RestUDir
 21050                                  ;         RestDir = nonzero to flag later restoration of user's dir
 21051                                  ;         DestTail = ptr to beginning of filename
 21052                                  ;         If filename found in pathname,
 21053                                  ;           ZR = clear
 21054                                  ;           FCB filename fields contain filename
 21055                                  ;         If filename not found (pure directory path),
 21056                                  ;           ZR = set
 21057                                  ;           FCB filename fields are wildcarded with ?'s
 21058                                  ;       If pathcrunch failed (no ChDir's worked),
 21059                                  ;         CY = set
 21060                                  ;         Msg_Numb = extended error code
 21061                                  ;
 21062                                  ; NOTE  DIR asks PathCrunch to forego parsing the filename into the
 21063                                  ;       FCB by setting DirFlag. In this case, the FCB is returned
 21064                                  ;       with the filename wildcarded.
 21065                                  
 21066                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21067                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2767h
 21068                                  
 21069                                  PathCrunch:
 21070                                  	; MSDOS 6.0
 21071 00002673 C706[0F8E]0000          	mov     word [Msg_Numb],0
 21072                                  				;AN022; Set up message flag
 21073                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21074                                  	;mov	dl,[5Ch]
 21075 00002679 8A165C00                	mov	dl,[FCB]	; DL = drive # (1 = A)
 21076 0000267D E824FF                  	call	SAVUDIR		; save current directory in UserDir1
 21077                                  	; MSDOS 6.0
 21078 00002680 7233                     	jc	short pcrunch_cderrj
 21079                                  				;AN022; if error on current dir - report
 21080 00002682 E86004                  	call	SETPATH		; scan past switches, whitespace
 21081                                  
 21082                                  ;       DX = ptr to pathname, NULL-terminated
 21083                                  ;       PathPos = ptr to byte after NULL at end of pathname
 21084                                  
 21085                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21086 00002685 F606[A78C]02            	test	byte [DestInfo],2 ; test if wildcards (? or *) seen
 21087 0000268A 752C                    	jnz	short trypeel	; wildcard seen, peel filename
 21088                                  
 21089                                  	;mov	ah,CHDir ; 3Bh
 21090 0000268C B43B                    	mov	ah,3Bh
 21091 0000268E CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21092                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21093                                  	; MSDOS 6.0
 21094 00002690 7313                    	jnc	short chdir_worked	;AN022; no error - continue
 21095                                  	
 21096 00002692 E867F6                  	call	get_ext_error_number    ;AN022; get the extended error
 21097 00002695 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found
 21098 00002698 741E                    	je	short trypeel		;AC022;    keep trying
 21099 0000269A 83F805                  	cmp	ax,ERROR_ACCESS_DENIED  ;AN022; if access denied
 21100 0000269D 7419                    	je	short trypeel		;AC022;    keep trying
 21101 0000269F A3[0F8E]                	mov	[Msg_Numb],ax           ;AN022; set up message flag
 21102 000026A2 E99C00                  	jmp	peelfail                ;AN022; exit with other error
 21103                                  
 21104                                  	; MSDOS 3.3
 21105                                  	;jc	short trypeel
 21106                                  chdir_worked:
 21107                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21108 000026A5 E83406                  	call	SetRest1	; set 'Restore Directory' flag true
 21109 000026A8 B03F                    	mov	al,'?'		; if pure dir, wildcard filename in FCB
 21110 000026AA BF5D00                  	mov	di,5Dh  ; FCB+1
 21111 000026AD B90B00                  	mov	cx,11
 21112 000026B0 F3AA                    	rep	stosb
 21113 000026B2 30C0                    	xor	al,al		; return carry clear, zero set
 21114 000026B4 C3                      	retn
 21115                                  
 21116                                  pcrunch_cderrj: 		;AN022; need this for long jmp
 21117 000026B5 E98100                  	jmp	pcrunch_cderr	;AN022;
 21118                                  
 21119                                  trypeel:
 21120 000026B8 8B36[FB8B]              	mov	si,[PathPos]
 21121 000026BC 4E                      	dec	si		; SI = ptr to NULL at end of pathname
 21122 000026BD 8A44FF                  	mov	al,[si-1]	; AL = last char of pathname
 21123                                  	; 25/02/2023
 21124                                  	; MSDOS 5.0 (& 6.0)
 21125 000026C0 803E[2A8E]00            	cmp	byte [KPARSE],0
 21126 000026C5 7505                    	jnz	short delstrt	; Last char is 2nd KANJI byte, might be '\'
 21127                                  	
 21128 000026C7 E89BFF                  	call	pathchrcmp
 21129 000026CA 7475                    	jz	short peelfail	; Trailing '/'
 21130                                  delstrt:
 21131 000026CC 89F1                    	mov	cx,si		; CX = ptr to NULL at end of pathname
 21132 000026CE 89D6                    	mov	si,dx		; SI = ptr to start of pathname
 21133 000026D0 52                      	push	dx		; save ptr to pathname
 21134                                  delloop:
 21135 000026D1 39CE                    	cmp	si,cx
 21136                                  	;jz	short BADRET
 21137                                  	; 25/02/2023
 21138 000026D3 7413                    	je	short gotdele	; no char's left, we have what we have
 21139 000026D5 AC                      	lodsb			; AL = next char of pathname
 21140 000026D6 E8DFFC                  	call	testkanj
 21141 000026D9 7403                    	jz	short notkanj8	; not Kanji, move along
 21142 000026DB 46                      	inc	si
 21143 000026DC EBF3                    	jmp	short delloop	
 21144                                  
 21145                                  	; 25/02/2023
 21146                                  	; MSDOS 3.3
 21147                                  	;mov	al,[si]
 21148                                  	;call	PATHCHRCMP
 21149                                  	;jz	short TRYCD
 21150                                  	;dec	si
 21151                                  	;jmp	short delloop
 21152                                  
 21153                                  notkanj8:
 21154 000026DE E884FF                  	call	pathchrcmp
 21155 000026E1 75EE                    	jnz	short delloop	; not a path delimiter, keep looking
 21156 000026E3 89F2                    	mov	dx,si
 21157 000026E5 4A                      	dec	dx		; DX = ptr to last delimiter found	
 21158 000026E6 EBE9                    	jmp	short delloop	; go look for more
 21159                                  
 21160                                  	; 25/02/2023
 21161                                  	; MSDOS 5.0 (& 6.0)
 21162                                  gotdele:
 21163 000026E8 89D6                    	mov	si,dx		; SI = ptr to pathname or last delim
 21164 000026EA 5A                      	pop	dx		; DX = ptr to pathname
 21165 000026EB 39D6                    	cmp	si,dx
 21166 000026ED 7454                    	je	short badret	; didn't find path delim
 21167 000026EF 89F1                    	mov	cx,si		; CX = ptr to last path delimiter
 21168 000026F1 89D6                    	mov	si,dx		; SI = ptr to pathname
 21169                                  delloop2:			; Set value of KPARSE
 21170 000026F3 39CE                    	cmp	si,cx
 21171 000026F5 7412                    	je	short trycd	; roll up till SI meets CX
 21172 000026F7 C606[2A8E]00            	mov	byte [KPARSE],0
 21173 000026FC AC                      	lodsb
 21174 000026FD E8B8FC                  	call	testkanj
 21175 00002700 74F1                    	jz	short delloop2
 21176 00002702 46                      	inc	si
 21177 00002703 FE06[2A8E]              	inc	byte [KPARSE]
 21178 00002707 EBEA                    	jmp	short delloop2
 21179                                  
 21180                                  trycd:
 21181 00002709 50                      	push	ax
 21182                                  	; 25/02/2023
 21183 0000270A B02E                    	mov	al,'.'
 21184                                  	;mov	al,[DOT_CHR]	; AL = '.'
 21185                                  	; MSDOS 6.0
 21186 0000270C 384401                  	cmp	[si+1],al	; check for '.' after path delim
 21187                                  				;M019; allow continuation if '. ' or 
 21188                                  				;M019; '..' is not found.
 21189 0000270F 7509                    	jne	short trycd1	;M019; '.' not found
 21190 00002711 384402                  	cmp	[si+2],al	;M019; check for '..'
 21191 00002714 7404                    	je	short trycd1	;M019; found '..'
 21192 00002716 807C0200                	cmp	byte [si+2],0	;M019; check for '. ' (null terminated)
 21193                                  trycd1:	
 21194 0000271A 58                      	pop     ax
 21195 0000271B 7424                    	jz	short peelfail	; if . or .., pure cd should have worked
 21196                                  
 21197                                  	; 25/02/2023
 21198                                  	; MSDOS 3.3
 21199                                  	;cmp	[si+1],	al	; check for '.' after path delim
 21200                                  	;pop	ax
 21201                                  	;jz	short PEELFAIL	; if . or .., pure cd should have worked
 21202                                  
 21203                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21204 0000271D 8A44FF                  	mov	al,[si-1]
 21205 00002720 3C3A                    	cmp	al,':' 		; Special case d:\file
 21206 00002722 741F                    	je	short badret
 21207                                  	; 25/02/2023
 21208                                  	; MSDOS 6.0
 21209 00002724 803E[2A8E]00            	cmp	byte [KPARSE],0
 21210 00002729 7505                    	jnz	short notdoublesl
 21211 0000272B E837FF                  	call	pathchrcmp
 21212                                  	;jnz	short notdoublesl
 21213                                  				; Last char is 2nd KANJI byte, might be '\'
 21214                                  	; 25/02/2023
 21215 0000272E 7411                    	jz	short peelfail 
 21216                                  ;peelfail:
 21217                                  	;stc
 21218                                  	;retn
 21219                                  
 21220                                  notdoublesl:
 21221 00002730 C60400                  	mov	byte [si],0
 21222                                  	;mov	ah,CHDir ; 3Bh
 21223 00002733 B43B                    	mov	ah,3Bh
 21224 00002735 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21225                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21226 00002737 7320                    	jnc	short cdsucc
 21227                                  
 21228                                  	; 25/02/2023
 21229                                  	; MSDOS 6.0
 21230                                  pcrunch_cderr:
 21231 00002739 E8C0F5                  	call	get_ext_error_number
 21232                                  				;AN022; get the extended error
 21233 0000273C A3[0F8E]                	mov	[Msg_Numb],ax	;AN022; set up message flag
 21234 0000273F 09F6                    	or	si,si		;AN022; set up zero flag to not zero
 21235                                  peelfail: ; 25/02/2023
 21236 00002741 F9                      	stc			;AN022; set up carry flag
 21237                                  pcrunch_retn:
 21238 00002742 C3                      	retn
 21239                                  
 21240                                  badret:
 21241                                  	; MSDOS 3.3 & MSDOS 6.0
 21242 00002743 8A04                    	mov	al,[si]
 21243 00002745 E81DFF                  	call	pathchrcmp	; Special case 'DIRCHAR'file
 21244 00002748 F9                      	stc
 21245 00002749 75F7                    	jnz	short pcrunch_retn
 21246 0000274B 30DB                    	xor	bl,bl
 21247 0000274D 865C01                  	xchg	bl,[si+1]
 21248                                  	;mov	ah,CHDir ; 3Bh
 21249 00002750 B43B                    	mov	ah,3Bh
 21250 00002752 CD21                    	int	21h	; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 21251                                  			; DS:DX	-> ASCIZ directory name	(may include drive)
 21252                                  	;jc	short pcrunch_retn ; MSDOS 3.3
 21253                                  	; 25/02/2023
 21254 00002754 72E3                    	jc	short pcrunch_cderr
 21255                                  				;AN022; go to error exit 
 21256 00002756 885C01                  	mov	[si+1],bl
 21257                                  cdsucc:
 21258 00002759 E88005                  	call	SetRest1
 21259 0000275C 46                      	inc	si		; Reset zero
 21260 0000275D 8936[A58C]              	mov	[DestTail],si
 21261                                  	; 25/02/2023
 21262                                  	; MSDOS 6.0
 21263 00002761 9C                      	pushf			;AN015; save flags
 21264 00002762 803E[038C]FF            	cmp	byte [DirFlag],-1
 21265                                  				;AN015; don't do parse if in DIR
 21266 00002767 7408                    	je	short pcrunch_end
 21267                                  				;AN015;
 21268                                  	; MSDOS 3.3 & MSDOS 6.0
 21269 00002769 BF5C00                  	mov	di,FCB  ; 5Ch
 21270                                  	;mov	ax,(Parse_File_Descriptor<<8)|2 ; 2902h
 21271 0000276C B80229                  	mov	ax,2902h	
 21272 0000276F CD21                    	int	21h		; Parse with default drive
 21273                                  			; DOS -	PARSE FILENAME
 21274                                  			; DS:SI	-> string to parse
 21275                                  			; ES:DI	-> buffer to fill with unopened	FCB
 21276                                  			; AL = bit mask	to control parsing
 21277                                  	; MSDOS 3.3
 21278                                  	;retn
 21279                                  
 21280                                  pcrunch_end:
 21281 00002771 9D                      	popf			;AN015; get flags back
 21282 00002772 C3                      	retn
 21283                                  
 21284                                  ;============================================================================
 21285                                  ; TMISC1.ASM, MSDOS 6.0, 1991
 21286                                  ;============================================================================
 21287                                  ; 05/10/2018 - Retro DOS v3.0
 21288                                  
 21289                                  ;TITLE	Part7 COMMAND Transient Routines
 21290                                  
 21291                                  ;	More misc routines
 21292                                  
 21293                                  ;---------------------------
 21294                                  ; We can get rid of this switch processing code if we can take
 21295                                  ; care of the remaining two calls to switch, later in the file.
 21296                                  ; However, I have not checked whether or not any other files use
 21297                                  ; switch -- after all, it IS public!
 21298                                  ;---------------------------
 21299                                  
 21300                                  ; 28/03/2023
 21301                                  SWCOUNT  EQU  6  ; MSDOS 6.0		; Length of switch_list
 21302                                  ;SWCOUNT EQU  5  ; MSDOS 3.3	
 21303                                  
 21304                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1AC2h
 21305                                  
 21306                                  ; 25/02/2023 - Retro DOS v4.0 (& v4.1)
 21307                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2869h
 21308                                  
 21309                                  ; ---------------------------------------------------------------------------
 21310                                  
 21311                                  	; 25/02/2023
 21312                                  RETSW:
 21313 00002773 93                      	xchg	ax,bx		; Put switches in AX
 21314 00002774 C3                      	retn
 21315                                  
 21316                                  ; =============== S U B	R O U T	I N E =======================================
 21317                                  
 21318                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21319                                  SWITCH:
 21320 00002775 31DB                    	xor	bx,bx		; Initialize - no switches set
 21321                                  SWLOOP:
 21322 00002777 E85DFE                  	call	scanoff		; Skip any delimiters
 21323 0000277A 3A06[A08A]              	cmp	al,[SWITCHAR]	; Is it a switch specifier?
 21324 0000277E 75F3                    	jnz	short RETSW	; No -- we're finished
 21325 00002780 81CB0080                	or	bx,8000h
 21326                                  	;or	bx,FSWITCH	; Indicate there is a switch specified
 21327 00002784 46                      	inc	si		; Skip over the switch character
 21328 00002785 E84FFE                  	call	scanoff
 21329 00002788 3C0D                    	cmp	al,0Dh
 21330 0000278A 74E7                    	je	short RETSW	; Oops
 21331 0000278C 46                      	inc	si
 21332                                  
 21333                                  	; Convert lower case input to upper case
 21334                                  
 21335 0000278D E852FC                  	call	UPCONV
 21336                                  	;call	UPCONV_MAPCALL	; MSDOS 3.3
 21337                                  
 21338 00002790 BF[6784]                	mov	di,switch_list	; "?VBAPW" (for MSDOS 6.0)
 21339                                  				; ("VBAPW" (for MSDOS 3.3))
 21340 00002793 B90600                  	mov	cx,6  ; MSDOS 6.0
 21341                                  	;mov	cx,5  ; MSDOS 3.3
 21342                                  	;mov	cx,SWCOUNT ; 5 (for MSDOS 3.3), (6 (for MSDOS 6.0))
 21343                                  		
 21344                                  	;nop
 21345                                  		
 21346 00002796 F2AE                    	repne	scasb		; Look for matching switch
 21347 00002798 7507                    	jnz	short BADSW
 21348 0000279A B80100                  	mov	ax,1
 21349 0000279D D3E0                    	shl	ax,cl		; Set a bit for the switch
 21350 0000279F 09C3                    	or	bx,ax
 21351                                  BADSW: 				; Retro DOS v3.0 COMMAND.COM modificiation
 21352 000027A1 EBD4                    	jmp	short SWLOOP
 21353                                  ;BADSW:
 21354                                  	;jmp	short SWLOOP
 21355                                  ;DRVBAD:
 21356                                  ;	mov	dx,baddrv_ptr
 21357                                  ;	jmp	cerror
 21358                                  EXTERNALJ:
 21359 000027A3 E90501                  	jmp	EXTERNAL
 21360                                  FNDCOM:				; search the internal command table
 21361 000027A6 08C0                    	or	al,al		; Get real length of first arg
 21362 000027A8 74F9                    	jz	short EXTERNALJ	; If 0, it must begin with "\" so has
 21363                                  				;  to be external.
 21364                                  ; barryf code starts here
 21365                                  
 21366 000027AA E82703                  	call	test_append	; see if APPEND installed
 21367 000027AD 7429                    	jz	short CONTCOM	; not loaded
 21368                                  
 21369                                  APPEND_INTERNAL:
 21370 000027AF 8A0E[268B]              	mov	cl,[IDLEN]
 21371 000027B3 B500                    	mov	ch,0
 21372 000027B5 890E[FB8B]              	mov	[PathPos],cx
 21373                                  	
 21374                                  	; 25/02/2023	
 21375                                  	; MSDOS 6.0
 21376 000027B9 FE06[118E]              	inc 	byte [append_exec]
 21377                                  				;AN041; set APPEND to ON
 21378 000027BD E8B603                  	call	IOSET		; re-direct the o'l io
 21379                                  
 21380 000027C0 BE[268B]                	mov	si,IDLEN	; address command name, DS already set	
 21381 000027C3 BAFFFF                  	mov	dx,-1 ; 0FFFFh	; set invoke function
 21382                                  		
 21383                                  	; MSDOS 6.0
 21384 000027C6 BF[ED4D]                	mov	di,append_parse
 21385                                  				;AN010; Get the entry point for PARSE for APPEND
 21386                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21387 000027C9 B801AE                  	mov	ax,0AE01h
 21388 000027CC CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal
 21389                                  			; - INSTALLABLE	COMMAND	- EXECUTE
 21390                                  			; DX = FFFFh, DS:SI -> buffer
 21391                                  			; Return: buffer at DS:SI filled with a	length byte
 21392                                  			; followed by the uppercase internal command
 21393                                  			; to execute (if length not 0)
 21394                                  	; 25/02/2023
 21395                                  	; INT 2Fh
 21396                                  	; 	AX = AE01h
 21397                                  	; entry:
 21398                                  	; 	DX = magic value FFFFh
 21399                                  	; 	CH = 00h
 21400                                  	; 	CL = length of command name
 21401                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 21402                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 21403                                  	; return:
 21404                                  	;	DS:SI buffer updated
 21405                                  	;	if length byte is nonzero, the following bytes contain
 21406                                  	;	the uppercase internal command to execute and the command line
 21407                                  	; 	buffer contains the command's parameters
 21408                                  	;	(the first DS:[SI] bytes are ignored)
 21409                                  	;
 21410                                  	; Format of COMMAND.COM command line buffer:
 21411                                  	;	Offset  Size    Description
 21412                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 21413                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 21414                                  	;	N BYTEs command line text, terminated by 0Dh
 21415                                  	;
 21416                                  	; Format of command name buffer:
 21417                                  	;	Offset  Size    Description
 21418                                  	;	00h     BYTE    length of command name
 21419                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 21420                                  
 21421 000027CE 803E[268B]00            	cmp	byte [IDLEN],0 ; execute requested
 21422 000027D3 7503                    	jne	short CONTCOM
 21423 000027D5 E9A300                  	jmp	CMD_DONE
 21424                                  
 21425                                  	;nop
 21426                                  CONTCOM:			; continue with internal scan
 21427 000027D8 BF[E682]                	mov	di,COMTAB
 21428 000027DB 31C9                    	xor	cx,cx
 21429                                  FINDCOM:
 21430 000027DD BE[278B]                	mov	si,ID		; pointer to command argument
 21431 000027E0 8A0D                    	mov	cl,[di]		; load length of internal command
 21432 000027E2 47                      	inc	di		; advance past length
 21433 000027E3 E3BE                    	jcxz	EXTERNALJ 	; if it's zero, we're out of internals
 21434 000027E5 3A0E[268B]              	cmp	cl,[IDLEN]	; that of the command argument
 21435 000027E9 7506                    	jne	short ABCD	; lengths not equal ==> strings not eq
 21436 000027EB 890E[FB8B]              	mov	[PathPos],cx	; store length of command
 21437 000027EF F3A6                    	repe	cmpsb
 21438                                  ABCD:					
 21439 000027F1 9F                      	lahf			; save the good ol' flags
 21440 000027F2 01CF                    	add	di,cx		; skip over remaining internal, if any
 21441 000027F4 8A05                    	mov	al,[di]		; load drive-check indicator byte (DCIB)
 21442 000027F6 A2[AE8A]                	mov	[CHKDRV],al	; save command flag byte in chkdrv
 21443 000027F9 47                      	inc	di		; increment DI (OK, OK, I'll stop)
 21444 000027FA 8B1D                    	mov	bx,[di]		; load internal command address
 21445 000027FC 47                      	inc	di		; skip over the puppy
 21446 000027FD 47                      	inc	di
 21447                                  		
 21448                                  	; MSDOS 6.0
 21449 000027FE 8B15                    	mov	dx,[di]		; load ptr to help msg #s
 21450 00002800 47                      	inc	di
 21451 00002801 47                      	inc	di
 21452 00002802 9E                      	sahf			; remember those flags?
 21453 00002803 75D8                    	jnz	short FINDCOM	; well, if all the cmps worked...
 21454                                  
 21455                                  ; All messages get redirected.
 21456                                  
 21457 00002805 803E[118E]00            	cmp     byte [append_exec],0
 21458                                  				;AN041; APPEND just executed?
 21459 0000280A 7503                    	jnz 	short DONT_SET_IO
 21460                                  				;AN041; Yes - this junk is already set
 21461 0000280C E86703                  	call	IOSET		; re-direct the ol' i/o
 21462                                  
 21463                                  DONT_SET_IO:			;AN041;
 21464                                  
 21465                                  ; Check for /?. Certain commands, flagged fLimitHelp,
 21466                                  ; respond to /? only if it is the only command-line argument.
 21467                                  
 21468 0000280F A1[B38A]                	mov	ax,[COMSW]	; AX = switches after command
 21469 00002812 0B06[B98A]              	or	ax,[AllSwitch]	; AX = all switches
 21470                                  	;and	ax,SwitchQues	
 21471 00002816 83E020                  	and	ax,20h
 21472 00002819 7426                    	jz	short DRIVE_CHECK
 21473                                  				; /? not in command line
 21474 0000281B F606[AE8A]04            	test	byte [CHKDRV],4	
 21475                                  	;test	byte [CHKDRV],fLimitHelp
 21476 00002820 7407                    	jz	short DO_HELP	; /? allowed in combination
 21477                                  
 21478                                  ; Make sure /? is the only argument on the command line.
 21479                                  
 21480 00002822 833E[EB90]02            	cmp	word [ARG+ARG_UNIT.argvcnt],2
 21481 00002827 7518                    	jne	short DRIVE_CHECK
 21482                                  				; /? not only arg - ignore
 21483                                  
 21484                                  ; Note: this is all the check we need, even against things like /??.
 21485                                  ; Our argv parser breaks /?? into two args, /? and ?.
 21486                                  
 21487                                  DO_HELP:
 21488                                  ; DX = ptr to word list of msg #s, terminated by zero word
 21489                                  
 21490 00002829 89D6                    	mov	si,dx		; SI = ptr to list of msg #s
 21491                                      	;mov	ax,no_subst	; AL = no subst's code
 21492 0000282B B80000                  	mov	ax,0
 21493 0000282E 50                      	push	ax		; build subst block on stack
 21494                                  
 21495                                  NEXT_HELP_MSG:
 21496 0000282F AD                      	lodsw			; AX = help msg # or zero
 21497 00002830 09C0                    	or	ax,ax
 21498 00002832 7409                    	jz	short HELP_DONE
 21499 00002834 50                      	push	ax		; SS:SP = ptr to subst block
 21500                                  				; (msg # and no_subst byte)
 21501                                  ;; We assume DS = SS.
 21502                                  	
 21503 00002835 89E2                    	mov     dx,sp		; DS:DX = ptr to subst block
 21504 00002837 E8C925                  	call	std_printf	; display help message	
 21505 0000283A 58                      	pop	ax		; remove msg # from stack
 21506 0000283B EBF2                    	jmp	short NEXT_HELP_MSG
 21507                                  
 21508                                  HELP_DONE:
 21509 0000283D 58                      	pop	ax		; clean up stack
 21510 0000283E E9C3D8                  	jmp	TCOMMAND	
 21511                                  
 21512                                  	; 25/02/2023
 21513                                  	; MSDOS 3.3
 21514                                  	;sahf			; remember those flags?
 21515                                  	;jnz	short FINDCOM	; well, if all the cmps worked...
 21516                                  	;call	IOSET		; re-direct the ol' i/o
 21517                                  
 21518                                  DRIVE_CHECK:
 21519 00002841 F606[AE8A]01            	test	byte [CHKDRV],1
 21520                                  	;test	byte [CHKDRV],FCHECKDRIVE 
 21521                                  				; did we wanna check those drives?
 21522 00002846 7411                    	jz	short NOCHECK
 21523 00002848 A0[B18A]                	mov	al,[PARM1]	; parse_file_descriptor results tell
 21524 0000284B 0A06[B28A]              	or	al,[PARM2]	; us whether those drives were OK
 21525 0000284F 3CFF                    	cmp	al,-1
 21526 00002851 7506                    	jne	short NOCHECK
 21527                                  	;jmp	DRVBAD
 21528                                  	; 25/02/2023
 21529                                  DRVBAD:
 21530 00002853 BA[8D7F]                	mov	dx,baddrv_ptr
 21531 00002856 E9F200                  	jmp	cerror
 21532                                  
 21533                                  ; The user may have omitted the space between the command and its arguments.
 21534                                  ; We need to copy the remainder of the user's command line into the buffer.
 21535                                  ; Note that thisdoes not screw up the arg structure; it points into COMBUF not
 21536                                  ; into the command line at 80.
 21537                                  
 21538                                  NOCHECK:
 21539 00002859 E85B02                  	call	cmd_copy
 21540                                  SWITCHECK:
 21541                                  	;test	byte [CHKDRV],2
 21542 0000285C F606[AE8A]02            	test	byte [CHKDRV],fSwitchAllowed 
 21543                                  				; Does the command take switches
 21544 00002861 7516                    	jnz	short REALWORK	; Yes, process the command
 21545 00002863 E82F00                  	call	noswit		; No, check to see if any switches
 21546 00002866 7511                    	jnz	short REALWORK	; None, process the command
 21547                                  
 21548                                  	; MSDOS 6.0
 21549                                  	;mov	byte [msg_disp_class],2
 21550 00002868 C606[2F7F]02            	mov	byte [msg_disp_class],parse_msg_class
 21551                                  				;AN000; set up parse error msg class
 21552 0000286D BA[317F]                	mov	dx,extend_buf_ptr	
 21553                                  				;AC000; get extended message pointer
 21554                                  	;mov	word [extend_buf_ptr],3
 21555 00002870 C706[317F]0300          	mov	word [extend_buf_ptr],BadSwt_Ptr
 21556                                  				;AN000; get "Invalid switch" message number
 21557 00002876 E9D200                  	jmp	cerror		; Print error and chill out...
 21558                                  
 21559                                  	; 25/02/2023
 21560                                  	; MSDOS 3.3
 21561                                  	;mov	dx,BADPARMPTR
 21562                                  	;jmp	CERROR
 21563                                  
 21564                                  REALWORK:
 21565 00002879 FFD3                    	call	bx		; do some real work, at last
 21566                                  
 21567                                  ; See if we're in a batch CALL command. If we are, reprocess the command line,
 21568                                  ; otherwise, go get another command.
 21569                                  
 21570                                  CMD_DONE:
 21571 0000287B 0E                      	push	cs		; g  restore data segment
 21572 0000287C 1F                      	pop	ds		; g
 21573 0000287D 1E                      	push	ds
 21574 0000287E 8E1E[9C8A]              	mov	ds,[RESSEG]	; g  save data segment
 21575                                  	;cmp	byte [Call_Flag],1
 21576                                  				; G  Is a call in progress?
 21577 00002882 803E[B101]01            	cmp	byte [Call_Flag],call_in_progress
 21578 00002887 C606[B101]00            	mov	byte [Call_Flag],0
 21579                                  				; G  Either way, reset flag
 21580 0000288C 1F                      	pop	ds		; g  get data segment back
 21581 0000288D 7403                    	jz	short INCALL	; G
 21582 0000288F E972D8                  	jmp	TCOMMAND	; chill out...
 21583                                  INCALL:
 21584 00002892 E942DA                  	jmp	DOCOM1
 21585                                  
 21586                                  ; =============== S U B	R O U T	I N E =======================================
 21587                                  
 21588                                  	; 25/02/2023
 21589                                  noswit:
 21590 00002895 57                      	push	di		; Save di
 21591 00002896 BF8100                  	mov	di,81h		; di = ptr to command args
 21592 00002899 BE8000                  	mov	si,80h		; Get address of length of command args
 21593 0000289C AC                      	lodsb			; Load length
 21594 0000289D 88C1                    	mov	cl,al		; Move length to cl
 21595 0000289F 30ED                    	xor	ch,ch		; Zero ch
 21596 000028A1 2EA0[A08A]              	mov	al,[cs:SWITCHAR] ; al = switch character
 21597                                  	;cmp	al,0		; Turn off ZF
 21598                                  	; 25/02/2023
 21599 000028A5 20C0                    	and	al,al
 21600 000028A7 F2AE                    	repne	scasb		; Scan for a switch character and return
 21601 000028A9 5F                      	pop	di		;  with ZF set if one was found
 21602 000028AA C3                      	retn
 21603                                  
 21604                                  ; ---------------------------------------------------------------------------
 21605                                  
 21606                                  	; 25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21607                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:29A6h
 21608                                  
 21609                                  EXTERNAL:
 21610 000028AB E82602                  	call	test_append	; check to see if append installed
 21611 000028AE 7403                    	jz	short NOT_BARRYF
 21612                                  				; no - truly external command
 21613 000028B0 E9FCFE                  	jmp	APPEND_INTERNAL	; yes - go to Barryf code
 21614                                  
 21615                                  NOT_BARRYF:
 21616 000028B3 2EC606[AF8A]00          	mov	byte [cs:FILTYP],0
 21617 000028B9 2E8A16[BC8A]            	mov	dl,[cs:SPECDRV]
 21618 000028BE 2E8816[268B]            	mov	[cs:IDLEN],dl
 21619 000028C3 2EC606[9E8C]00          	mov	byte [cs:ROM_CALL],0
 21620 000028C9 52                      	push	dx
 21621 000028CA BA[268B]                	mov	dx,IDLEN
 21622 000028CD E82ADB                  	call	ROM_SCAN
 21623 000028D0 5A                      	pop	dx
 21624                                  	;jnc	short POSTSAVE
 21625 000028D1 7305                    	jnc	short DO_SCAN
 21626 000028D3 2EFE06[9E8C]            	inc	byte [cs:ROM_CALL]
 21627                                  	;jmp	short POSTSAVE
 21628                                  
 21629                                  	;nop
 21630                                  DO_SCAN:
 21631                                  POSTSAVE:
 21632 000028D8 BF[C489]                	mov	di,EXECPATH
 21633 000028DB C60500                  	mov	byte [di],0	; Initialize to current directory
 21634                                  	
 21635 000028DE 2E803E[9E8C]00          	cmp	byte [cs:ROM_CALL],0
 21636                                  	;jz	short RESEARCH
 21637                                  	; 25/02/2023
 21638                                  	;jmp	short NEOEXECUTE
 21639 000028E4 750F                    	jnz	short NEOEXECUTE	
 21640                                  
 21641                                  	;nop
 21642                                  RESEARCH:
 21643 000028E6 E88708                  	call	path_search	; find the mother (result in execpath)
 21644 000028E9 09C0                    	or	ax,ax		; did we find anything?
 21645                                  	;jz	short BADCOMJ45	; null means no (sob)
 21646                                  	; 25/02/2023
 21647 000028EB 7459                    	jz	short BADCOM
 21648 000028ED 83F804                  	cmp	ax,4		; 04H and 08H are .exe and .com
 21649                                  				; fuckin' sixteen-bit machine ought
 21650                                  	;jl	short BATCOMJ	; to be able to handle a SIXTEEN-BIT
 21651                                  				; DISPLACEMENT!!
 21652                                  	;;jmp	short NEOEXECUTE
 21653                                  	;jmp	short EXECUTE	
 21654                                  	; 25/02/2023
 21655 000028F0 7D03                    	jnl	short EXECUTE ; jge
 21656                                  
 21657                                  	; 02H is .bat
 21658                                  
 21659                                  	;nop
 21660                                  BATCOMJ:
 21661 000028F2 E995DE                  	jmp	BATCOM
 21662                                  
 21663                                  	; 25/02/2023
 21664                                  ;BADCOMJ45:
 21665                                  	;jmp	short BADCOM
 21666                                  
 21667                                  	;nop
 21668                                  EXECUTE:
 21669                                  NEOEXECUTE:
 21670 000028F5 E87E02                  	call	IOSET
 21671                                  
 21672                                  ; MSDOS 6.0
 21673                                  ;M051
 21674                                  ; Previously LoadHigh was jumping to the execute label above. This was wrong
 21675                                  ;because IOSET was getting invoked twice resulting in 2 sets of redirections.
 21676                                  ;After a close, this would still leave one open active resulting in sharing
 21677                                  ;errors on subsequent opens of the redirected file.
 21678                                  
 21679                                  LH_EXECUTE:			;M051	
 21680 000028F8 8E06[AC8A]              	mov	es,[TRAN_TPA]
 21681                                  	;mov	ah,DEALLOC ; 49h
 21682 000028FC B449                    	mov	ah,49h
 21683 000028FE CD21                    	int	21h	; DOS -	2+ - FREE MEMORY
 21684                                  			; ES = segment address of area to be freed
 21685                                  				; Now running in "free" space
 21686 00002900 8E06[9C8A]              	mov	es,[RESSEG]
 21687 00002904 26FE06[9C01]            	inc	byte [es:ExtCom] ; Indicate external command
 21688 00002909 26C606[A401]00          	mov	byte [es:RestDir],0 
 21689                                  				; Since USERDIR1 is in transient, insure
 21690                                  				; this flag value for re-entry to COMMAND
 21691                                  	; MSDOS 6.0
 21692 0000290F BE[C489]                	mov	si,EXECPATH	  ; offset TRANGROUP:EXECPATH	
 21693 00002912 BF[6303]                	mov	di,SafePathBuffer ; offset RESGROUP:SAFEPATHBUFFER
 21694                                  	;mov	cx,LENMSGORPATHBUF
 21695 00002915 B95000                  	mov	cx,80
 21696 00002918 FC                      	cld
 21697 00002919 F3A4                    	rep	movsb		; copy program pathname to resident
 21698                                  
 21699                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21700 0000291B BF5C00                  	mov	di,FCB ; 5Ch
 21701 0000291E 89FE                    	mov	si,di
 21702                                  	;mov	cx,82 ; 52h	; moving (100h-5Ch)/2 = 80h-2Eh
 21703 00002920 B152                    	mov	cl,82 ; 25/02/2023
 21704 00002922 F3A5                    	rep	movsw		; Transfer parameters to resident header
 21705                                  	
 21706                                  	; 25/02/2023
 21707                                  	;mov	dx,EXECPATH  ; MSDOS 3.3
 21708                                  	; MSDOS 6.0 (& 5.0)
 21709                                  	;mov	dx,offset RESGROUP:SAFEPATHBUFFER
 21710 00002924 BA[6303]                	mov	dx,SafePathBuffer
 21711 00002927 06                      	push	es
 21712 00002928 1F                      	pop	ds
 21713                                  
 21714                                  	;mov	bx,offset RESGROUP:EXEC_BLOCK
 21715 00002929 BB[3F03]                	mov	bx,Exec_Block  ; = offset EnvirSeg
 21716                                  	;mov	ax,EXEC*256 ; 4B00h
 21717 0000292C B8004B                  	mov	ax,4B00h
 21718                                  	;test	byte [ROM_CALL],-1 ; 0FFh ; MSDOS 3.3
 21719 0000292F 2EF606[9E8C]FF          	test	byte [cs:ROM_CALL],-1 ; MSDOS 6.0 (& 5.0)
 21720 00002935 7403                    	jz	short OK_EXEC
 21721 00002937 E939DB                  	jmp	ROM_EXEC
 21722                                  
 21723                                  OK_EXEC:
 21724                                  
 21725                                  ; we are now running in free space. Anything we do from here on may get
 21726                                  ; trashed. Move the stack (also in free space) to allocated space because
 21727                                  ; since EXEC restores the stack, somebody may trash what is on the stack.
 21728                                  
 21729 0000293A 8CC1                    	mov	cx,es
 21730 0000293C 8ED1                    	mov	ss,cx
 21731 0000293E BC[3804]                	mov	sp,RStack
 21732                                  	; MSDOS 3.3
 21733                                  	;jmp	far [EXEC_ADDR]	; Jmp to the EXEC in the resident
 21734                                  	; 25/02/2023
 21735                                  	; MSDOS 6.0
 21736 00002941 2EFF2E[A28A]            	jmp	far [cs:EXEC_ADDR] ; Jmp to the EXEC in the resident
 21737                                  
 21738                                  ; ---------------------------------------------------------------------------
 21739                                  
 21740                                  	;  25/02/2023 - Retro DOS v4.0 COMMAND.COM
 21741                                  BADCOM:
 21742 00002946 0E                      	push	cs
 21743 00002947 1F                      	pop	ds
 21744 00002948 BA[547F]                	mov	dx,BADNAM_PTR
 21745                                  cerror:		
 21746 0000294B E8AD24                  	call	std_eprintf
 21747 0000294E E9B3D7                  	jmp	TCOMMAND
 21748                                  
 21749                                  ; =============== S U B	R O U T	I N E =======================================
 21750                                  
 21751                                  ; Prescan converts the input buffer into a canonicalized form.
 21752                                  ; All redirections and pipes are removed.
 21753                                  
 21754                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21755                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2A51h
 21756                                  
 21757                                  PRESCAN:
 21758 00002951 31C9                    	xor	cx,cx
 21759 00002953 8E06[9C8A]              	mov	es,[RESSEG]
 21760 00002957 BE[FD88]                	mov	si,COMBUF+2
 21761 0000295A 89F7                    	mov	di,si
 21762                                  COUNTQUOTES:
 21763 0000295C AC                      	lodsb			; get a byte
 21764 0000295D 3C22                    	cmp	al,22h	; '"'	; is it a quote?
 21765 0000295F 7504                    	jne	short COUNTEND	; no, try for end of road
 21766 00002961 FEC5                    	inc	ch		; bump count
 21767 00002963 EBF7                    	jmp	short COUNTQUOTES
 21768                                  				; go get next char
 21769                                  COUNTEND:
 21770 00002965 3C0D                    	cmp	al,0Dh	; 13	; end of road?
 21771 00002967 75F3                    	jne	short COUNTQUOTES
 21772                                  				; no, go back for next char
 21773                                  	; 26/02/2023
 21774                                  	; MSDOS 5.0 (& 6.0)
 21775 00002969 51                      	push	cx		; save count
 21776 0000296A 89FE                    	mov	si,di		; restore pointer to begining
 21777                                  KanjiScan:
 21778 0000296C AC                      	lodsb			; get a byte
 21779 0000296D E848FA                  	call	testkanj	; is it a leadin byte
 21780 00002970 740F                    	jz	short KanjiQuote
 21781                                  				; no, check for quotes
 21782 00002972 88C4                    	mov	ah,al		; save leadin
 21783 00002974 AC                      	lodsb			; get trailing byte
 21784 00002975 3D2020                  	cmp	ax,2020h
 21785                                  	;cmp	ax,DB_SPACE	; is it Kanji space
 21786 00002978 75F2                    	jne	short KanjiScan	; no, go get next
 21787 0000297A C744FE2020              	mov	word [si-2],2020h
 21788                                  				; replace with spaces
 21789 0000297F EBEB                    	jmp	short KanjiScan	; go get next char
 21790                                  	
 21791                                  KanjiQuote:
 21792 00002981 3C22                    	cmp	al,22h	; '"'	; beginning of quoted string
 21793 00002983 750D                    	jne	short KanjiEnd	; no, check for end
 21794 00002985 FECD                    	dec	ch		; drop count
 21795 00002987 74E3                    	jz	short KanjiScan	; if count is zero, no quoting
 21796                                  KanjiQuoteLoop:
 21797 00002989 AC                      	lodsb			; get next byte
 21798 0000298A 3C22                    	cmp	al,22h	; '"'	; is it another quote
 21799 0000298C 75FB                    	jne	short KanjiQuoteLoop
 21800                                  				; no, get another
 21801 0000298E FECD                    	dec	ch		; yes, drop count
 21802 00002990 EBDA                    	jmp	short KanjiScan	; go get next char
 21803                                  KanjiEnd:
 21804 00002992 3C0D                    	cmp	al,13 ; 0Dh	; end of line character?
 21805 00002994 75D6                    	jne	short KanjiScan	; go back to beginning
 21806 00002996 59                      	pop	cx		; get back original count
 21807                                  	; 26/04/2023
 21808 00002997 89FE                    	mov	si,di		; restore pointer to beginning
 21809                                  	
 21810                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21811                                  PRESCANLP:
 21812 00002999 AC                      	lodsb
 21813                                  	; 26/02/2023
 21814 0000299A E81BFA                  	call	testkanj
 21815 0000299D 740C                    	jz	short NOTKANJ6
 21816                                  	; MSDOS 6.0
 21817 0000299F 8805                    	mov	[di],al
 21818 000029A1 47                      	inc	di		; fake STOSB into DS
 21819 000029A2 AC                      	lodsb			; grab second byte
 21820 000029A3 8805                    	mov	[di],al		; fake stosb into DS
 21821 000029A5 FEC1                    	inc	cl
 21822 000029A7 FEC1                    	inc	cl
 21823 000029A9 EBEE                    	jmp	short PRESCANLP
 21824                                  
 21825                                  NOTKANJ6:
 21826                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21827 000029AB 3C22                    	cmp	al,'"'	; 22h	; " character
 21828 000029AD 7510                    	jne	short TRYGREATER
 21829 000029AF FECD                    	dec	ch
 21830 000029B1 740C                    	jz	short TRYGREATER
 21831                                  QLOOP:
 21832 000029B3 8805                    	mov	[di],al
 21833 000029B5 47                      	inc	di
 21834 000029B6 FEC1                    	inc	cl
 21835 000029B8 AC                      	lodsb
 21836 000029B9 3C22                    	cmp	al,'"'		; " character
 21837 000029BB 75F6                    	jne	short QLOOP
 21838 000029BD FECD                    	dec	ch
 21839                                  TRYGREATER:
 21840 000029BF 3C3E                    	cmp	al,'>' ; 3Eh
 21841                                  	;cmp	al,rabracket	; MSDOS 6.0 (& 5.0)
 21842                                  	;;cmp	al,[RABRACKET]	; MSDOS 3.3
 21843 000029C1 7557                    	jne	short NOOUT
 21844                                  
 21845                                  ; We have found a ">" char. We need to see if there is another ">"
 21846                                  ; following it.
 21847                                  
 21848 000029C3 3804                    	cmp	[si],al
 21849 000029C5 7506                    	jne	short NOAPPND
 21850 000029C7 AC                      	lodsb
 21851 000029C8 26FE06[C601]            	inc	byte [es:Re_Out_App] ; Flag >>
 21852                                  NOAPPND:
 21853                                  ; Now we attempt to find the file name. First, scan off all whitespace
 21854                                  
 21855 000029CD E807FC                  	call	scanoff
 21856                                  
 21857                                  	; 26/02/2023
 21858                                  	; MSDOS 6.0
 21859 000029D0 3C3C                    	cmp	al,'<' ; 3Ch
 21860                                  	;cmp	al,labracket	;AN040; was there no filename?
 21861 000029D2 7404                    	je	short REOUT_ERRSET
 21862                                  				;AN040; yes - set up error
 21863                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21864 000029D4 3C0D                    	cmp	al,0Dh
 21865 000029D6 750D                    	jnz	short GOTREOFIL
 21866                                  
 21867                                  ; There was no file present. Set us up at end-of-line.
 21868                                  
 21869                                  REOUT_ERRSET:			;AN040; set up for an error
 21870 000029D8 C6050D                  	mov	byte [di],0Dh	; Clobber first ">"
 21871 000029DB 26C706[C701]0900        	mov	word [es:Re_OutStr],9
 21872                                  				; Cause an error later
 21873 000029E2 E9A900                  	jmp	PRESCANEND
 21874                                  
 21875                                  GOTREOFIL:
 21876 000029E5 57                      	push	di
 21877                                  	;mov	di,offset RESGROUP:RE_OUTSTR
 21878 000029E6 BF[C701]                	mov	di,Re_OutStr
 21879 000029E9 89FB                    	mov	bx,di
 21880 000029EB 06                      	push	es
 21881                                  
 21882                                  	; 26/02/2023
 21883                                  	; MSDOS 6.0
 21884                                  SETREOUTSTR:			; Get the output redirection name
 21885                                  				; MSKK06 07/14/89
 21886 000029EC 51                      	push	cx		; save cx
 21887 000029ED B94D00                  	mov	cx,64+13	; CX = max string length
 21888                                  SETREOUTSTR_LOOP:
 21889 000029F0 AC                      	lodsb
 21890 000029F1 3C0D                    	cmp	al,0Dh
 21891 000029F3 741A                    	je	short GOTRESTR_J
 21892 000029F5 E8E7FB                  	call	DELIM
 21893 000029F8 7415                    	jz	short GOTRESTR_J
 21894 000029FA 3A06[A08A]              	cmp	al,[SWITCHAR]
 21895 000029FE 740F                    	je	short GOTRESTR_J
 21896 00002A00 3C22                    	cmp	al,'"' ; 22h 	;AN033; Is the character a quote?
 21897 00002A02 7413                    	je	short PIPEERRSYNJ5_J
 21898                                  				;AN033; Yes - get out quick - or system crashes
 21899 00002A04 3C3C                    	cmp	al,'<' ; 3Ch
 21900                                  	;cmp	al,labracket	;AN002; Is char for input redirection
 21901 00002A06 7404                    	je	short ABRACKET_TERM
 21902                                  				;AN002; yes - end of string
 21903 00002A08 3C3E                    	cmp	al,'>' ; 3Eh
 21904                                  	;cmp	al,rabracket	;AN002; Is char for output redirection
 21905 00002A0A 7506                    	jne	short NO_ABRACKET
 21906                                  				;AN002; no - not end of string
 21907                                  ABRACKET_TERM:			;AN002; have end of string by < or >
 21908 00002A0C 4E                      	dec	si		;AN002; back up over symbol
 21909 00002A0D B020                    	mov	al,20h ; BLANK	;AN002; show delimiter as char
 21910                                  GOTRESTR_J:
 21911 00002A0F 59                      	pop	cx		; MSKK06 07/14/89
 21912 00002A10 EB58                    	jmp	short GOTRESTR	;AN002; go process it
 21913                                  NO_ABRACKET:			;AN002; NOT AT END OF STRING
 21914 00002A12 AA                      	stosb			; store it into resgroup
 21915 00002A13 E2DB                    	loop	SETREOUTSTR_LOOP
 21916                                  				; MSKK06 07/14/89
 21917 00002A15 EBF8                    	jmp	short GOTRESTR_J
 21918                                  PIPEERRSYNJ5_J:
 21919 00002A17 59                      	pop	cx		; recover CX
 21920 00002A18 EB4B                    	jmp	short PIPEERRSYNJ5
 21921                                  
 21922                                  	; 26/02/2023
 21923                                  ;	; MSDOS 3.3
 21924                                  ;SETREOUTSTR_LOOP:		; Get the output redirection name
 21925                                  ;	lodsb
 21926                                  ;	cmp	al,0Dh
 21927                                  ;	jz	short GOTRESTR
 21928                                  ;	call	DELIM
 21929                                  ;	jz	short GOTRESTR
 21930                                  ;	cmp	al,[SWITCHAR]
 21931                                  ;	je	short GOTRESTR
 21932                                  ;	cmp	al,'"'
 21933                                  ;	jne	short NO_ABRACKET
 21934                                  ;	dec	ch
 21935                                  ;NO_ABRACKET:
 21936                                  ;	stosb
 21937                                  ;	jmp	short SETREOUTSTR_LOOP
 21938                                  
 21939                                  NOOUT:
 21940                                  	; 26/02/2023
 21941                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21942 00002A1A 3C3C                    	cmp	al, '<' ; 3Ch
 21943                                  	;cmp	al,labracket	; MSDOS 6.0
 21944                                  	;;cmp	al,[LABRACKET]  ; MSDOS 3.3
 21945 00002A1C 7523                    	jne	short CHKPIPE
 21946 00002A1E 89F3                    	mov	bx,si		; Save loc of "<"
 21947 00002A20 E8B4FB                  	call	scanoff
 21948                                  	; MSDOS 6.0
 21949 00002A23 3C3E                    	cmp	al,'>' ; 3Eh
 21950                                  	;cmp	al,rabracket	;AN040; was there no filename?
 21951 00002A25 7404                    	je	short REIN_ERRSET ;AN040; yes - set up error
 21952                                  	; MSDOS 3.3 (& MSDOS 6.0)
 21953 00002A27 3C0D                    	cmp	al,0Dh
 21954 00002A29 750B                    	jne	short GOTREIFIL
 21955                                  REIN_ERRSET:			;AN040; set up for error
 21956 00002A2B C6050D                  	mov	byte [di],0Dh	; Clobber "<"
 21957 00002A2E C706[478A]0900          	mov	word [RE_INSTR],9 
 21958                                  				; Cause an error later
 21959 00002A34 EB58                    	jmp	short PRESCANEND
 21960                                  GOTREIFIL:
 21961 00002A36 57                      	push	di
 21962 00002A37 BF[478A]                	mov	di,RE_INSTR
 21963 00002A3A 89FB                    	mov	bx,di
 21964 00002A3C 06                      	push	es
 21965 00002A3D 0E                      	push	cs
 21966 00002A3E 07                      	pop	es		; store in TRANGROUP
 21967                                  	; 26/04/2023
 21968                                  	;jmp	short SETREOUTSTR_LOOP  ; MSDOS 3.3 COMMAND.COM
 21969 00002A3F EBAB                    	jmp	short SETREOUTSTR ; MSDOS 5.0 (& 6.0) COMMAND.COM
 21970                                  				; Get the input redirection name
 21971                                  CHKPIPE:
 21972 00002A41 88C4                    	mov	ah,al
 21973                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 21974 00002A43 80FC7C                  	cmp	ah,'|' ; 7Ch
 21975                                  	;cmp	ah,ALTPIPECHR ; 7Ch
 21976                                  	;je	short ISPIPE3
 21977                                  	;; MSDOS 6.0
 21978                                  	;cmp	ah,'|' ; 7Ch
 21979                                  	;;cmp	al,vbar ; 7Ch
 21980                                  	;;;cmp	ah,[VBAR]  ; MSDOS 3.3
 21981 00002A46 7539                    	jne	short CONTPRESCAN
 21982                                  ISPIPE3:
 21983                                  ; Only push the echo flag if we are entering the pipe for the first time.
 21984                                  
 21985 00002A48 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 21986 00002A4E 7505                    	jne	short NOECHOPUSH
 21987 00002A50 26D026[A001]            	shl	byte [es:EchoFlag],1 ; push echo state and turn it off
 21988                                  NOECHOPUSH:
 21989 00002A55 26FE06[1802]            	inc	byte [es:PipeFlag]
 21990 00002A5A E87AFB                  	call	scanoff
 21991 00002A5D 3C0D                    	cmp	al,0Dh
 21992 00002A5F 7404                    	je	short PIPEERRSYNJ5
 21993                                  	; 26/02/2023
 21994 00002A61 3C7C                    	cmp	al,'|' ; 7Ch
 21995                                  	;cmp	al,ALTPIPECHR ; 7Ch
 21996                                  	;je	short PIPEERRSYNJ5
 21997                                  	;; MSDOS 6.0
 21998                                  	;cmp	al,'|' ; 7Ch
 21999                                  	;;cmp	al,vbar ; 7Ch
 22000                                  	;;;cmp	al,[VBAR]  ; MSDOS 3.3	
 22001 00002A63 751C                    	jne	short CONTPRESCAN
 22002                                  
 22003                                  PIPEERRSYNJ5:
 22004 00002A65 06                      	push	es
 22005 00002A66 1F                      	pop	ds
 22006 00002A67 E99E02                  	jmp	PIPEERRSYN
 22007                                  
 22008                                  ; Trailing :s are allowed on devices. Check to be sure that there is more
 22009                                  ; than just a : in the redir string.
 22010                                  
 22011                                  GOTRESTR:
 22012 00002A6A 86E0                    	xchg	ah,al
 22013 00002A6C B03A                    	mov	al,':' ; 3Ah
 22014 00002A6E 29FB                    	sub	bx,di		; compute negative of number of chars
 22015 00002A70 83FBFF                  	cmp	bx,-1		; is there just a :?
 22016 00002A73 7407                    	je	short NOTRAILCOL ; yep, don't change
 22017 00002A75 263845FF                	cmp	[es:di-1],al	; Trailing ':' OK on devices
 22018 00002A79 7501                    	jne	short NOTRAILCOL
 22019 00002A7B 4F                      	dec	di		; Back up over trailing ':'
 22020                                  NOTRAILCOL:
 22021 00002A7C 30C0                    	xor	al,al
 22022 00002A7E AA                      	stosb			; NUL terminate the string
 22023 00002A7F 07                      	pop	es
 22024 00002A80 5F                      	pop	di		; Remember the start
 22025                                  CONTPRESCAN:
 22026 00002A81 8825                    	mov	[di],ah		; "delete" the redirection string
 22027 00002A83 47                      	inc	di
 22028 00002A84 80FC0D                  	cmp	ah,0Dh
 22029 00002A87 7405                    	je	short PRESCANEND
 22030 00002A89 FEC1                    	inc	cl
 22031 00002A8B E90BFF                  	jmp	PRESCANLP
 22032                                  PRESCANEND:
 22033 00002A8E 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 22034 00002A94 7414                    	jz	short ISNOPIPE
 22035                                  
 22036                                  	; 26/02/2023
 22037                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA0h
 22038                                  	;;mov	di,3C0h		; offset RESGROUP:PIPESTR
 22039                                  	;;			; (EndInit+160]
 22040                                  	;mov	di,offset RESGROUP:PIPESTR
 22041 00002A96 BF[BA02]                	mov	di,PipeStr	; RESGROUP:EndInit+160
 22042                                  	;;MSDOS 5.0 COMMAND.COM - TRANGROUP:2BA3h
 22043                                  	;;mov	[es:3BEh],di	; [es:EndInit+158]
 22044 00002A99 26893E[B802]            	mov	[es:PipePtr],di	; RESGROUP:EndInit+158
 22045                                  	
 22046 00002A9E BE[FD88]                	mov	si,COMBUF+2
 22047 00002AA1 E833FB                  	call	scanoff
 22048                                  PIPESETLP:			; Transfer the pipe into the resident
 22049 00002AA4 AC                      	lodsb			; pipe buffer
 22050 00002AA5 AA                      	stosb
 22051 00002AA6 3C0D                    	cmp	al,0Dh
 22052 00002AA8 75FA                    	jnz	short PIPESETLP
 22053                                  ISNOPIPE:
 22054 00002AAA 880E[FC88]              	mov	[COMBUF+1],cl
 22055 00002AAE 26803E[1802]00          	cmp	byte [es:PipeFlag],0
 22056 00002AB4 0E                      	push	cs
 22057 00002AB5 07                      	pop	es
 22058 00002AB6 C3                      	retn
 22059                                  
 22060                                  ; =============== S U B	R O U T	I N E =======================================
 22061                                  
 22062                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22063                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2BC1h
 22064                                  cmd_copy:
 22065 00002AB7 BE[FD88]                	mov	si,COMBUF+2
 22066 00002ABA E81AFB                  	call	scanoff		; advance past separators...
 22067 00002ABD 0336[FB8B]              	add	si,[PathPos]
 22068 00002AC1 BF8100                  	mov	di,81h
 22069 00002AC4 31C9                    	xor	cx,cx
 22070                                  cmdcopy:
 22071 00002AC6 AC                      	lodsb
 22072 00002AC7 AA                      	stosb
 22073 00002AC8 3C0D                    	cmp	al,0Dh
 22074 00002ACA 7403                    	je	short copy_done
 22075 00002ACC 41                      	inc	cx
 22076 00002ACD EBF7                    	jmp	short cmdcopy
 22077                                  copy_done:
 22078 00002ACF 880E8000                	mov	[80h],cl
 22079 00002AD3 C3                      	retn
 22080                                  
 22081                                  ; =============== S U B	R O U T	I N E =======================================
 22082                                  
 22083                                  	; 25/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22084                                  test_append:
 22085 00002AD4 BB[FB88]                	mov	bx,COMBUF	; barry can address
 22086 00002AD7 BE[268B]                	mov	si,IDLEN	; address command name, DS already set 	
 22087 00002ADA BAFFFF                  	mov	dx,-1
 22088 00002ADD B800AE                  	mov	ax,0AE00h
 22089 00002AE0 CD2F                    	int	2Fh	; - Multiplex -	DOS 3.3+ internal 
 22090                                  			; - INSTALLABLE	COMMAND	- INSTALL CHECK
 22091                                  			; DX = FFFFh,[BX -> command line
 22092                                  			; Return: AL = FFh if this command is a TSR extension 
 22093                                  			;		   to COMMAND.COM
 22094                                  			; AL = 00h if the command should be executed as	usual
 22095                                  	;cmp	al,0
 22096 00002AE2 08C0                    	or	al,al ; 25/02/2023
 22097 00002AE4 C3                      	retn
 22098                                  
 22099                                  	; 25/02/2023
 22100                                  	; INT 2Fh
 22101                                  	; 	AX = AE00h
 22102                                  	; entry:
 22103                                  	; 	DX = magic value FFFFh
 22104                                  	; 	CH = FFh
 22105                                  	; 	CL = length of command line tail
 22106                                  	; 	DS:BX -> command line buffer  -- (offset COMBUF)
 22107                                  	; 	DS:SI -> command name buffer  -- (offset IDLEN)
 22108                                  	; return:
 22109                                  	;	AL = FFh if this command is a TSR extension to COMMAND.COM
 22110                                  	;	AL = 00h if the command should be executed as usual
 22111                                  	;
 22112                                  	; Format of COMMAND.COM command line buffer:
 22113                                  	;	Offset  Size    Description
 22114                                  	;	00h     BYTE    max length of command line, as in INT 21/AH=0Ah
 22115                                  	;	01h     BYTE    count of bytes to follow, excluding terminating 0Dh
 22116                                  	;	N BYTEs command line text, terminated by 0Dh
 22117                                  	;
 22118                                  	; Format of command name buffer:
 22119                                  	;	Offset  Size    Description
 22120                                  	;	00h     BYTE    length of command name
 22121                                  	;	01h    N BYTEs  uppercased command name (blank-padded to 11 chars)
 22122                                  
 22123                                  ;============================================================================
 22124                                  ; TMISC2.ASM, MSDOS 6.0, 1991
 22125                                  ;============================================================================
 22126                                  ; 05/10/2018 - Retro DOS v3.0
 22127                                  
 22128                                  ;	More misc routines
 22129                                  
 22130                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1D9Bh
 22131                                  
 22132                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22133                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2BEFh
 22134                                  
 22135                                  ; =============== S U B	R O U T	I N E =======================================
 22136                                  
 22137                                  SETPATH:
 22138                                  
 22139                                  ; ENTRY PathPos = ptr to string
 22140                                  ;       PathCnt = length of string
 22141                                  ;
 22142                                  ; EXIT  PathPos = ptr to string after pathname
 22143                                  ;       PathCnt = length of rest of string
 22144                                  ;       DX = ptr to pathname in string, made ASCIIZ
 22145                                  ;       DestIsDir = 1 if pathname delimiters appeared in pathname, 0 otherwise
 22146                                  ;       DestInfo = 2 if wildcards (?, *) appeared in pathname, 0 otherwise
 22147                                  ;
 22148                                  ;       A null character is dropped at the end of the pathname. If the
 22149                                  ;       character in that spot previously was CR, it is copied into the
 22150                                  ;       following byte. So there must be at least two two character 
 22151                                  ;       positions in the buffer following the pathname.
 22152                                  
 22153                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22154                                  	; 11/06/2023
 22155                                  	; MSDOS 6.0
 22156                                  	;mov	ax,[PathCnt]	;AC000; get length of string
 22157                                  	;mov	si,[PathPos]	;AC000; get start of source buffer
 22158                                  
 22159                                  	; 26/02/2023
 22160                                  	; MSDOS 3.3
 22161                                  	;mov	si,80h
 22162                                  	;lodsb
 22163                                  	;xor	ah,ah
 22164                                  	;mov	[PATCNT],ax
 22165                                  	;mov	[PATHPOS],si
 22166                                  GETPATH:
 22167                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22168 00002AE5 C606[A78C]00            	mov	byte [DestInfo],0
 22169 00002AEA C606[A38C]00            	mov	byte [DestIsDir],0
 22170 00002AEF 8B36[FB8B]              	mov	si,[PathPos]	; SI = ptr to string
 22171 00002AF3 8B0E[F98B]              	mov	cx,[PathCnt]	; CX = string length
 22172 00002AF7 89F2                    	mov	dx,si		; DX = ptr to string
 22173 00002AF9 E34D                    	jcxz	PATHDONE	; string length is zero, we're done
 22174 00002AFB 51                      	push	cx		; save string length
 22175 00002AFC 56                      	push	si		; save ptr to string
 22176 00002AFD E875FC                  	call	SWITCH
 22177                                  
 22178                                  ;       After Switch, SI has been scanned past any switches, and
 22179                                  ;       switches that COMMAND intrinsically recognizes are recorded in AX.
 22180                                  
 22181 00002B00 A3[FD8B]                	mov	[PathSw],ax	; PathSw = switch occurrence mask
 22182 00002B03 5B                      	pop	bx		; BX = ptr to original string
 22183 00002B04 29F3                    	sub	bx,si		; BX = -(# chars scanned by Switch)
 22184 00002B06 59                      	pop	cx		; CX = string length
 22185 00002B07 01D9                    	add	cx,bx		; CX = string length from current SI
 22186 00002B09 89F2                    	mov	dx,si		; DX = ptr to current string
 22187                                  SKIPPATH:
 22188                                  	; 26/02/2023
 22189                                  	; MSDOS 6.0
 22190 00002B0B C606[2A8E]00            	mov	byte [KPARSE],0
 22191                                  SKIPPATH2:
 22192 00002B10 E336                    	jcxz	PATHDONE	; string length is zero, we're done
 22193 00002B12 49                      	dec	cx		; CX = length left after next char
 22194 00002B13 AC                      	lodsb			; AL = next char of string
 22195                                  				; SI = ptr to char after this one
 22196                                  	; 26/02/2023
 22197 00002B14 E8A1F8                  	call	testkanj
 22198 00002B17 7408                    	jz	short TESTPPSEP
 22199 00002B19 49                      	dec	cx
 22200 00002B1A 46                      	inc	si
 22201 00002B1B FE06[2A8E]              	inc	byte [KPARSE]
 22202 00002B1F EBEF                    	jmp	short SKIPPATH2
 22203                                  TESTPPSEP:
 22204 00002B21 E841FB                  	call	pathchrcmp	; compare AL to path delimiter char
 22205 00002B24 7504                    	jnz	short TESTPMETA	; it's not a path delim
 22206 00002B26 FE06[A38C]              	inc	byte [DestIsDir]
 22207                                  				; DestIsDir = 1, signalling path char
 22208                                  TESTPMETA:
 22209 00002B2A 3C3F                    	cmp	al,'?'
 22210 00002B2C 7505                    	jne	short TESTPSTAR	; char is not '?'
 22211 00002B2E 800E[A78C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22212                                  TESTPSTAR:
 22213 00002B33 3C2A                    	cmp	al,'*'
 22214                                  	;cmp	al,[STAR] ; MSDOS 3.3	
 22215 00002B35 7505                    	jne	short TESTPDELIM ; char is not '*'
 22216 00002B37 800E[A78C]02            	or	byte [DestInfo],2 ; DestInfo = 2, signalling wildcard
 22217                                  TESTPDELIM:
 22218 00002B3C E8A0FA                  	call	DELIM		; compare AL to all delimiters
 22219 00002B3F 7406                    	jz	short PATHDONEDEC ; delimiter found, back up & leave
 22220 00002B41 3A06[A08A]              	cmp	al,[SWITCHAR]
 22221 00002B45 75C4                    	jne	short SKIPPATH	; char isn't switch, go get next char
 22222                                  PATHDONEDEC:
 22223 00002B47 4E                      	dec	si		; SI = ptr to char after pathname
 22224                                  PATHDONE:
 22225 00002B48 30C0                    	xor	al,al		; AL = NULL
 22226 00002B4A 8604                    	xchg	al,[si]		; place NULL after pathname
 22227 00002B4C 46                      	inc	si		; SI = ptr to byte after NULL
 22228 00002B4D 3C0D                    	cmp	al,0Dh		; were we at end of line?
 22229 00002B4F 7502                    	jne	short NOPSTORE	; not EOL, finish up
 22230 00002B51 8804                    	mov	[si],al		; save EOL after NULL
 22231                                  NOPSTORE:
 22232 00002B53 8936[FB8B]              	mov	[PathPos],si	; PathPos = ptr to char after NULL
 22233 00002B57 890E[F98B]              	mov	[PathCnt],cx	; PathCnt = length of string left
 22234                                  SETPATH_RETN:
 22235 00002B5B C3                      	retn
 22236                                  
 22237                                  ; ---------------------------------------------------------------------------
 22238                                  
 22239                                  PGETARG:
 22240 00002B5C BE8000                  	mov	si,80h
 22241 00002B5F AC                      	lodsb
 22242 00002B60 08C0                    	or	al,al
 22243 00002B62 74F7                    	jz	short SETPATH_RETN
 22244 00002B64 E80300                  	call	PSCANOFF
 22245 00002B67 3C0D                    	cmp	al,0Dh
 22246 00002B69 C3                      	retn
 22247                                  
 22248                                  ; ---------------------------------------------------------------------------
 22249                                  
 22250                                  PSCANOFF:
 22251 00002B6A AC                      	lodsb
 22252 00002B6B E871FA                  	call	DELIM
 22253 00002B6E 7504                    	jnz	short PSCANOFFD
 22254 00002B70 3C3B                    	cmp	al,';' ; 3Bh
 22255 00002B72 75F6                    	jne	short PSCANOFF	; ';' is not a delimiter
 22256                                  PSCANOFFD:
 22257 00002B74 4E                      	dec	si		; Point to first non-delimiter
 22258 00002B75 C3                      	retn
 22259                                  
 22260                                  ; =============== S U B	R O U T	I N E =======================================
 22261                                  
 22262                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22263                                  IOSET:
 22264                                  	; ALL REGISTERS PRESERVED
 22265 00002B76 1E                      	push	ds
 22266 00002B77 52                      	push	dx
 22267 00002B78 50                      	push	ax
 22268 00002B79 53                      	push	bx
 22269 00002B7A 51                      	push	cx
 22270 00002B7B 2E8E1E[9C8A]            	mov	ds,[cs:RESSEG]
 22271 00002B80 803E[1802]00            	cmp	byte [PipeFlag],0
 22272 00002B85 750D                    	jne	short NOREDIR
 22273 00002B87 F606[AB01]FF            	test	byte [IfFlag],0FFh
 22274 00002B8C 7506                    	jnz	short NOREDIR
 22275 00002B8E E88E00                  	call	TESTDOREIN
 22276 00002B91 E80600                  	call	TESTDOREOUT
 22277                                  NOREDIR:
 22278 00002B94 59                      	pop	cx
 22279 00002B95 5B                      	pop	bx
 22280 00002B96 58                      	pop	ax
 22281 00002B97 5A                      	pop	dx
 22282 00002B98 1F                      	pop	ds
 22283 00002B99 C3                      	retn
 22284                                  
 22285                                  ; =============== S U B	R O U T	I N E =======================================
 22286                                  
 22287                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22288                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CF3h
 22289                                  TESTDOREOUT:
 22290 00002B9A 803E[C701]00            	cmp	byte [Re_OutStr],0
 22291                                  	;je	short NOREOUT  ; MSDOS 3.3
 22292                                  	; 26/02/2023
 22293 00002B9F 7502                    	jne	short REOUTEXISTS
 22294 00002BA1 EB7B                    	jmp	NOREOUT 
 22295                                  REOUTEXISTS:
 22296 00002BA3 803E[C601]00            	cmp	byte [Re_Out_App],0
 22297 00002BA8 745D                    	je	short REOUTCRT
 22298                                  
 22299 00002BAA BA[C701]                	mov	dx,Re_OutStr
 22300                                  
 22301                                  	; 26/02/2023
 22302                                  	; MSDOS 6.0
 22303                                  	;mov	ax,(OPEN SHL 8) OR 2 ;AC011; Open for read/write
 22304 00002BAD B8023D                  	mov	ax,3D02h
 22305                                  	; MSDOS 3.3
 22306                                  	;mov	ax,(OPEN<<8)|1  ; 3D01h ; Open for write
 22307                                  	
 22308                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22309 00002BB0 50                      	push	ax
 22310 00002BB1 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22311                                  			; DS:DX	-> ASCIZ filename
 22312                                  			; AL = access mode
 22313                                  			; 1 - write
 22314 00002BB3 5B                      	pop	bx
 22315 00002BB4 724B                    	jc	short OpenWriteError
 22316                                  
 22317                                  	; 26/02/2023
 22318                                  	; MSDOS 6.0
 22319 00002BB6 89C3                    	mov	bx,ax
 22320                                  	;mov	ax,IOCTL<<8		;AN035; Get attributes of handle
 22321 00002BB8 B80044                  	mov	ax,4400h
 22322 00002BBB CD21                    	int	21h			;AN035;
 22323                                  			; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 22324                                  			; BX = file or device handle
 22325 00002BBD F6C280                  	test	dl,80h
 22326                                  	;test	dl,devid_ISDEV		;AN035; Is it a device?
 22327 00002BC0 7554                    	jnz	short SET_REOUT		;AN035; Yes, don't read from it
 22328                                  	
 22329                                  	;mov	ax,(LSEEK SHL 8) OR 2
 22330 00002BC2 B80242                  	mov	ax,4202h
 22331 00002BC5 B9FFFF                  	mov	cx,-1			;AC011; MOVE TO EOF -1
 22332 00002BC8 89CA                    	mov	dx,cx			;AC011;
 22333 00002BCA CD21                    	int	21h
 22334                                  			; DOS - 2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22335                                  			; AL = method: offset from end of file
 22336 00002BCC 0E                      	push	cs			;AN011; Get transient seg to DS
 22337 00002BCD 1F                      	pop	ds			;AN011;
 22338                                  	
 22339                                  	;mov	ax,(READ SHL 8) 	;AN011; Read one byte from the
 22340 00002BCE B8003F                  	mov	ax,3F00h
 22341 00002BD1 B90100                  	mov	cx,1			;AN011;  file into one_char_val
 22342 00002BD4 BA[9B8C]                	mov	dx,One_Char_Val		;AN011;
 22343 00002BD7 CD21                    	int	21h			;AN011;
 22344                                  			; DOS - 2+ - READ FROM FILE WITH HANDLE
 22345                                  			; BX = file handle, CX = number of bytes to read
 22346                                  			; DS:DX -> buffer
 22347 00002BD9 7226                    	jc	short OpenWriteError	;AN011; If error, exit
 22348 00002BDB 39C8                    	cmp	ax,cx			;AN017; Did we read 1 byte?
 22349 00002BDD 7517                    	jnz	short reout_0_length	;AN017; No - file must be 0 length
 22350                                  	
 22351 00002BDF 803E[9B8C]1A            	cmp	byte [One_Char_Val],1Ah	;AN011; Was char an eof mark?
 22352 00002BE4 8E1E[9C8A]              	mov	ds,[RESSEG]		;AN011; Get resident segment back
 22353 00002BE8 752C                    	jne	short SET_REOUT		;AN011; No, just continue
 22354                                  	
 22355                                  	;mov	ax,(LSEEK<<8)|1		;AN011; EOF mark found
 22356 00002BEA B80142                  	mov	ax,4201h
 22357 00002BED B9FFFF                  	mov	cx,-1			;AN011; LSEEK back one byte
 22358                                  setreout_p:	; 26/02/2023
 22359 00002BF0 89CA                    	mov	dx,cx			;AN011;
 22360 00002BF2 CD21                    	int	21h			;AN011;
 22361 00002BF4 EB20                    	jmp	short SET_REOUT
 22362                                  reout_0_length: 			;AN017; We have a 0 length file
 22363                                  	; ds = cs ; 26/02/2023
 22364                                  	;mov	ds,[cs:RESSEG] ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2D50h
 22365                                  					;AN017; Get resident segment back
 22366                                  	; 26/02/2023
 22367 00002BF6 8E1E[9C8A]              	mov	ds,[RESSEG]
 22368                                  	;mov	ax,(LSEEK SHL 8)	;AN017; Move to beginning of file
 22369 00002BFA B80042                  	mov	ax,4200h
 22370 00002BFD 31C9                    	xor	cx,cx			;AN017; Offset is 0
 22371                                  	;mov	dx,cx			;AN017;
 22372                                  	;int	21h			;AN017;
 22373                                  	;jmp	short SET_REOUT 	;AN017; now finish setting up redirection
 22374                                  	; 26/02/2023
 22375 00002BFF EBEF                    	jmp	short setreout_p
 22376                                  
 22377                                  	; 26/02/2023
 22378                                  	; MSDOS 3.3
 22379                                  	;xor	dx,dx
 22380                                  	;xor	cx,cx
 22381                                  	;mov	bx,ax
 22382                                  	;mov	ax,(LSEEK<<8)|2 ; 4202h
 22383                                  	;int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 22384                                  	;		; AL = method: offset from end of file
 22385                                  	;jmp	short SET_REOUT
 22386                                  		
 22387                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22388                                  OpenWriteError:	
 22389                                  	;cmp	ax,5
 22390 00002C01 83F805                  	cmp	ax,ERROR_ACCESS_DENIED
 22391 00002C04 F9                      	stc
 22392                                  	;;je	short REDIRERR ; MSDOS 3.3
 22393                                  	; 26/02/2023
 22394                                  	;jnz	short REOUTCRT
 22395                                  	;jmp	REDIRERR
 22396 00002C05 743B                    	je	short REDIRERR
 22397                                  
 22398                                  REOUTCRT:	
 22399 00002C07 BA[C701]                	mov	dx,Re_OutStr
 22400 00002C0A 31C9                    	xor	cx,cx
 22401                                  	;mov	ah,CREAT ; 3Ch
 22402 00002C0C B43C                    	mov	ah,3Ch
 22403 00002C0E 50                      	push	ax
 22404 00002C0F CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 22405                                  			; CX = attributes for file
 22406                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 22407 00002C11 5B                      	pop	bx
 22408                                  	;jc	short REDIRERR ; MSDOS 3.3
 22409                                  	; 26/02/2023
 22410                                  	;jnc	short NOREDIRERR
 22411                                  	;jmp	REDIRERR
 22412 00002C12 722E                    	jc	short REDIRERR
 22413                                  	
 22414                                  NOREDIRERR:
 22415 00002C14 89C3                    	mov	bx,ax
 22416                                  SET_REOUT:
 22417                                  
 22418                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdout
 22419                                  ; spot. We invalidate the new JFN we got.
 22420                                  
 22421 00002C16 B0FF                    	mov	al,0FFh
 22422                                  	;xchg	al,[bx+18h]
 22423 00002C18 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22424 00002C1B A21900                  	mov	[PDB.JFN_TABLE+1],al
 22425                                  NOREOUT:
 22426                                  IOSET_RETN:	; 17/04/2023
 22427 00002C1E C3                      	retn
 22428                                  
 22429                                  ; =============== S U B	R O U T	I N E =======================================
 22430                                  
 22431                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22432                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22433                                  TESTDOREIN:
 22434 00002C1F 2E803E[478A]00          	cmp	byte [cs:RE_INSTR],0
 22435 00002C25 74F7                    	jz	short IOSET_RETN
 22436 00002C27 1E                      	push	ds
 22437 00002C28 0E                      	push	cs
 22438 00002C29 1F                      	pop	ds
 22439 00002C2A BA[478A]                	mov	dx,RE_INSTR
 22440                                  	;mov	ax,OPEN*256 ; 3D00h
 22441 00002C2D B8003D                  	mov	ax,3D00h
 22442 00002C30 89C3                    	mov	bx,ax
 22443 00002C32 CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22444                                  			; DS:DX	-> ASCIZ filename
 22445                                  			; AL = access mode
 22446                                  			; 0 - read
 22447 00002C34 1F                      	pop	ds
 22448                                  
 22449 00002C35 720B                    	jc	short REDIRERR
 22450                                  
 22451 00002C37 89C3                    	mov	bx,ax
 22452 00002C39 B0FF                    	mov	al,0FFh
 22453                                  
 22454                                  ; Mega sleaze!! We move the SFN from the new handle spot into the old stdin
 22455                                  ; spot. We invalidate the new JFN we got.
 22456                                  
 22457                                  	;xchg	al,[bx+18h]
 22458 00002C3B 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22459 00002C3E A21800                  	mov	[PDB.JFN_TABLE],al
 22460 00002C41 C3                      	retn
 22461                                  
 22462                                  ; ---------------------------------------------------------------------------
 22463                                  
 22464                                  ; We had some kind of error on the redirection. Figure out what the
 22465                                  ; appropriate message should be; BX has the system call that failed
 22466                                  
 22467                                  REDIRERR:
 22468 00002C42 0E                      	push	cs
 22469 00002C43 1F                      	pop	ds
 22470 00002C44 E82E00                  	call	TriageError  ; MSDOS 6.0
 22471                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22472                                  
 22473                                  ; At this point, we have recognized the network-generated access denied error.
 22474                                  ; The correct message is in DX
 22475                                  
 22476 00002C47 83F841                  	cmp	ax,65
 22477 00002C4A 7408                    	je	short _CERRORJ	;AC000; just issue message returned
 22478 00002C4C 80FF3D                  	cmp	bh,OPEN ; 3Dh
 22479 00002C4F 7406                    	je	short OpenError
 22480 00002C51 BA[4B7F]                	mov	dx,FULLDIR_PTR
 22481                                  _CERRORJ:
 22482 00002C54 E9F4FC                  	jmp	cerror
 22483                                  
 22484                                  OpenError:
 22485                                  ; The system call was an OPEN. Report either file not found or path not found.
 22486                                  
 22487                                  	; 26/02/2023
 22488                                  	; MSDOS 6.0
 22489                                  	;mov	byte [cs:msg_disp_class],1
 22490 00002C57 2EC606[2F7F]01          	mov	byte [cs:msg_disp_class],ext_msg_class
 22491                                  				;AN000; set up extended error msg class
 22492 00002C5D BA[317F]                	mov	dx,extend_buf_ptr
 22493                                  				;AC000; get extended message pointer
 22494 00002C60 2EA3[317F]              	mov	[cs:extend_buf_ptr],ax
 22495                                  				;AN000; get message number in control block
 22496 00002C64 E9E4FC                  	jmp	cerror
 22497                                  
 22498                                  	; 26/02/2023
 22499                                  	; MSDOS 3.3
 22500                                  	;mov	dx,FNOTFOUNDPTR
 22501                                  	;;cmp	ax,2
 22502                                  	;cmp	ax,ERROR_FILE_NOT_FOUND
 22503                                  	;je	short _CERRORJ
 22504                                  	;mov	dx,ACCDENPTR
 22505                                  	;;cmp	ax,5 ; Access denied error
 22506                                  	;cmp	ax,ERROR_ACCESS_DENIED
 22507                                  	;je	short _CERRORJ
 22508                                  	;	; ERROR_PATH_NOT_FOUND
 22509                                  	;mov	dx,PNOTFOUNDPTR
 22510                                  	;jmp	CERROR
 22511                                  
 22512                                  ; =============== S U B	R O U T	I N E =======================================
 22513                                  
 22514                                  ; Compute length of string (including NUL) in DS:SI into CX. Change no other
 22515                                  ; registers
 22516                                  
 22517                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22518                                  dstrlen:
 22519 00002C67 50                      	push	ax
 22520 00002C68 31C9                    	xor	cx,cx
 22521 00002C6A FC                      	cld
 22522                                  dloop:
 22523 00002C6B AC                      	lodsb
 22524 00002C6C 41                      	inc	cx
 22525 00002C6D 08C0                    	or	al,al
 22526 00002C6F 75FA                    	jnz	short dloop
 22527 00002C71 29CE                    	sub	si,cx
 22528 00002C73 58                      	pop	ax
 22529                                  TRIAGEERR_RETN:
 22530 00002C74 C3                      	retn
 22531                                  
 22532                                  ; =============== S U B	R O U T	I N E =======================================
 22533                                  
 22534                                  ;Break	<Extended error support>
 22535                                  
 22536                                  TriageError:  ; MSDOS 6.0
 22537                                  
 22538                                  ; TriageError will examine the return from a carry-set system call and
 22539                                  ; return the correct error if applicable.
 22540                                  ;
 22541                                  ;   Inputs:	outputs from a carry-settable system call
 22542                                  ;		No system calls may be done in the interrim
 22543                                  ;   Outputs:	If carry was set on input
 22544                                  ;		   carry set on output
 22545                                  ;		   DX contains trangroup offset to printf message
 22546                                  ;		else
 22547                                  ;		   No registers changed
 22548                                  
 22549                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1EEEh
 22550                                  
 22551                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22552                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2D92h
 22553                                  
 22554                                  GET_EXT_ERR_NUMBER:  ; MSDOS 3.3
 22555 00002C75 73FD                    	jnc	short TRIAGEERR_RETN ; no carry => do nothing...
 22556 00002C77 9C                      	pushf
 22557 00002C78 53                      	push	bx
 22558 00002C79 51                      	push	cx
 22559 00002C7A 56                      	push	si
 22560 00002C7B 57                      	push	di
 22561 00002C7C 55                      	push	bp
 22562 00002C7D 06                      	push	es
 22563 00002C7E 1E                      	push	ds
 22564 00002C7F 50                      	push	ax
 22565 00002C80 52                      	push	dx
 22566 00002C81 B459                    	mov	ah,59h
 22567                                  	;mov	ah,GETEXTENDEDERROR
 22568 00002C83 CD21                    	int	21h	; DOS -	3+ - GET EXTENDED ERROR	CODE
 22569                                  			; BX = version code (0000h for DOS 3.x)
 22570 00002C85 59                      	pop	cx
 22571 00002C86 5B                      	pop	bx		; restore original AX
 22572 00002C87 BA[577F]                	mov	dx,ACCDEN_PTR
 22573 00002C8A 83F841                  	cmp	ax,65		; network access denied?
 22574 00002C8D 7404                    	je	short NoMove	; Yes, return it.
 22575 00002C8F 89D8                    	mov	ax,bx
 22576 00002C91 89CA                    	mov	dx,cx
 22577                                  NoMove:
 22578 00002C93 1F                      	pop	ds
 22579 00002C94 07                      	pop	es
 22580 00002C95 5D                      	pop	bp
 22581 00002C96 5F                      	pop	di
 22582 00002C97 5E                      	pop	si
 22583 00002C98 59                      	pop	cx
 22584 00002C99 5B                      	pop	bx
 22585 00002C9A 9D                      	popf
 22586 00002C9B C3                      	retn
 22587                                  
 22588                                  ; =============== S U B	R O U T	I N E =======================================
 22589                                  
 22590                                  	; Far call from resident portion/segment of COMMAND.COM
 22591                                  
 22592                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F15h
 22593                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DB9h
 22594                                  
 22595                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22596                                  Triage_Init:
 22597 00002C9C E8D6FF                  	call	TriageError	 ; MSDOS 6.0
 22598                                  	;call	GET_EXT_ERR_NUMBER ; MSDOS 3.3
 22599 00002C9F CB                      	retf
 22600                                  
 22601                                  ; =============== S U B	R O U T	I N E =======================================
 22602                                  
 22603                                  ; MSDOS 6.0
 22604                                  
 22605                                  ; ****************************************************************
 22606                                  ; *
 22607                                  ; * ROUTINE:	 MOVE_TO_SRCBUF
 22608                                  ; *
 22609                                  ; * FUNCTION:	 Move ASCIIZ string from DS:SI to SRCBUF.  Change
 22610                                  ; *		 terminating 0 to 0dH.	Set PATHCNT to length of
 22611                                  ; *		 string.  Set PATHPOS to start of SRCBUF.
 22612                                  ; *
 22613                                  ; * INPUT:	 DS:SI points to ASCIIZ string
 22614                                  ; *		 ES    points to TRANGROUP
 22615                                  ; *
 22616                                  ; * OUTPUT:	 SRCBUF filled in with string terminated by 0dH
 22617                                  ; *		 PATHCNT set to length of string
 22618                                  ; *		 PATHPOS set to start of SRCBUF
 22619                                  ; *		 CX,AX	 changed
 22620                                  ; *
 22621                                  ; ****************************************************************
 22622                                  
 22623                                  	; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22624                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2CABh
 22625                                  Move_To_SrcBuf:
 22626 00002CA0 56                      	push	si			;AN000;  save si,di
 22627 00002CA1 57                      	push	di			;AN000;
 22628 00002CA2 51                      	push	cx			;AN000;
 22629 00002CA3 BF[0B8D]                	mov	di,SrcBuf		;AN000;  set ES:DI to srcbuf
 22630 00002CA6 31C9                    	xor	cx,cx			;AN000; clear cx for counint
 22631 00002CA8 89C8                    	mov	ax,cx			;AN000; clear ax
 22632 00002CAA 57                      	push	di			;AN000; save start of srcbuf
 22633 00002CAB AC                      	lodsb				;AN000; get a character from DS:SI
 22634                                  mts_get_chars:				;AN000;
 22635                                  	;cmp	al,0			;AN000; was it a null char?
 22636 00002CAC 20C0                    	and 	al,al ; al = 0 ?
 22637 00002CAE 7405                    	jz	short mts_end_string	;AN000; yes - exit
 22638 00002CB0 AA                      	stosb				;AN000; no - store it in srcbuf
 22639 00002CB1 41                      	inc	cx			;AN000; increment length count
 22640 00002CB2 AC                      	lodsb				;AN000; get a character from DS:SI
 22641 00002CB3 EBF7                    	jmp	short mts_get_chars	;AN000; go check it
 22642                                  mts_end_string: 			;AN000; we've reached the end of line
 22643                                  	;mov	al,END_OF_LINE_IN	;AN000; store 0Dh in srcbuf
 22644 00002CB5 B00D                    	mov	al,0Dh
 22645 00002CB7 AA                      	stosb				;AN000;
 22646 00002CB8 5F                      	pop	di			;AN000; restore start of srcbuf
 22647 00002CB9 0E                      	push	cs			;AN000; set DS to local segment
 22648 00002CBA 1F                      	pop	ds			;AN000;
 22649 00002CBB 890E[F98B]              	mov	[PathCnt],cx		;AN000; set patchcnt to length count
 22650 00002CBF 893E[FB8B]              	mov	[PathPos],di		;AN000; set pathpos to start of srcbuf
 22651 00002CC3 59                      	pop	cx			;AN000; restore cx,di,si
 22652 00002CC4 5F                      	pop	di			;AN000;
 22653 00002CC5 5E                      	pop	si			;AN000;
 22654 00002CC6 C3                      	retn				;AN000; exit
 22655                                  
 22656                                  ;============================================================================
 22657                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 22658                                  ;============================================================================
 22659                                  ; 03/10/2018 - Retro DOS v3.0
 22660                                  
 22661                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 1F19h
 22662                                  
 22663                                  ; 26/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 22664                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 2DE4h
 22665                                  
 22666                                  ; =============== S U B	R O U T	I N E =======================================
 22667                                  
 22668                                  	; 26/02/2023
 22669                                  SINGLETEST:
 22670 00002CC7 1E                      	push	ds
 22671 00002CC8 2E8E1E[9C8A]            	mov	ds,[cs:RESSEG]
 22672 00002CCD 833E[A601]00            	cmp	word [SingleCom],0
 22673 00002CD2 7406                    	jz	short TESTDONE
 22674 00002CD4 813E[A601]FFEF          	cmp	word [SingleCom],0EFFFh
 22675                                  TESTDONE:
 22676 00002CDA 1F                      	pop	ds
 22677 00002CDB C3                      	retn
 22678                                  
 22679                                  ; =============== S U B	R O U T	I N E =======================================
 22680                                  
 22681                                  	; 26/02/2023
 22682                                  SetRest1:
 22683 00002CDC B001                    	mov	al,1
 22684                                  
 22685                                  ; ---------------------------------------------------------------------------
 22686                                  
 22687                                  SETREST:
 22688 00002CDE 1E                      	push	ds
 22689 00002CDF 8E1E[9C8A]              	mov	ds,[RESSEG]
 22690 00002CE3 A2[A401]                	mov	[RestDir],al
 22691 00002CE6 1F                      	pop	ds
 22692 00002CE7 C3                      	retn
 22693                                  
 22694                                  ; =============== S U B	R O U T	I N E =======================================
 22695                                  
 22696                                  ; Note that we need to handle the same thing that RestDir handles: the
 22697                                  ; requirement that we try only once to restore the user's environment after
 22698                                  ; and INT 24 or the like. If the condition that causes the INT 24 does not
 22699                                  ; disappear, we just give up.
 22700                                  
 22701                                  	; 26/02/2023 - Retro DOS v4.0 COMMAND.COM
 22702                                  PIPEDEL:
 22703 00002CE8 1E                      	push	ds
 22704 00002CE9 52                      	push	dx
 22705 00002CEA 2E8E1E[9C8A]            	mov	ds,[cs:RESSEG]
 22706                                  	;mov	dx,320h	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E0Ch
 22707                                  			; Pipe1 = offset RESGROUP:EndInit
 22708 00002CEF BA[1A02]                	mov	dx,Pipe1	; Clean up in case ^C
 22709                                  	;mov	ah,Unlink ; 41h 
 22710 00002CF2 B441                    	mov	ah,41h
 22711 00002CF4 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22712                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 22713                                  			;		(no wildcards allowed)
 22714                                  
 22715                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM - TRANGROUP:2E13h
 22716                                  			; Pipe2 = offset RESGROUP:EndInit+79
 22717 00002CF6 BA[6902]                	mov	dx,Pipe2
 22718                                  	;mov	ah,Unlink ; 41h
 22719 00002CF9 B441                    	mov	ah,41h
 22720 00002CFB CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 22721                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 22722                                  			;		(no wildcards allowed)
 22723 00002CFD 5A                      	pop	dx
 22724 00002CFE E86202                  	call	PipeOff
 22725 00002D01 C606[1902]00            	mov	byte [PipeFiles],0
 22726 00002D06 1F                      	pop	ds
 22727 00002D07 C3                      	retn
 22728                                  
 22729                                  ; ---------------------------------------------------------------------------
 22730                                  
 22731                                  	; 26/02/2023
 22732                                  PIPEERRSYN:
 22733 00002D08 BA[C97F]                	mov	dx,SYNTMES_PTR
 22734 00002D0B E8DAFF                  	call	PIPEDEL
 22735 00002D0E 0E                      	push	cs
 22736 00002D0F 1F                      	pop	ds
 22737 00002D10 E938FC                  	jmp	cerror
 22738                                  
 22739                                  ; ---------------------------------------------------------------------------
 22740                                  
 22741                                  	; 26/02/2023
 22742                                  PIPERR:
 22743 00002D13 9C                      	pushf
 22744 00002D14 E85EFF                  	call    TriageError
 22745                                  	;call	GET_EXT_ERR_NUMBER  ; MSDOS 3.3
 22746 00002D17 50                      	push	ax		; Save results from TriageError
 22747 00002D18 52                      	push	dx
 22748 00002D19 BA[9280]                	mov	dx,PIPEEMES_PTR
 22749 00002D1C E8C9FF                  	call	PIPEDEL
 22750 00002D1F 0E                      	push	cs
 22751 00002D20 1F                      	pop	ds
 22752 00002D21 E8D720                  	call	std_eprintf
 22753 00002D24 5A                      	pop	dx		; Restore results from TriageError
 22754 00002D25 58                      	pop	ax
 22755 00002D26 9D                      	popf
 22756 00002D27 83F841                  	cmp	ax,65
 22757 00002D2A 7503                    	jne	short TCOMMANDJ
 22758 00002D2C E91CFC                  	jmp	cerror
 22759                                  
 22760                                  TCOMMANDJ:
 22761 00002D2F E9D2D3                  	jmp	TCOMMAND
 22762                                  
 22763                                  ; ---------------------------------------------------------------------------
 22764                                  
 22765                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22766                                  PIPEPROCSTRT:
 22767 00002D32 8E1E[9C8A]              	mov	ds,[RESSEG]
 22768 00002D36 FE06[1902]              	inc	byte [PipeFiles] ; Flag that the pipe files exist
 22769                                  
 22770                                  	; MSDOS 6.0
 22771 00002D3A 06                      	push	es
 22772 00002D3B 57                      	push	di
 22773 00002D3C 1E                      	push	ds
 22774 00002D3D 56                      	push	si
 22775                                  	
 22776 00002D3E 1E                      	push	ds
 22777 00002D3F 06                      	push	es
 22778 00002D40 1F                      	pop	ds			;ds = TRANGROUP
 22779 00002D41 BE[E185]                	mov	si,TempVarName		;ds:si = "TEMP="
 22780                                  
 22781                                  ;Some hideous code in Find_Name_In_Environment. Expects ds = TRANGROUP and
 22782                                  ;so the routine is not really general
 22783                                  
 22784 00002D44 E8C7F5                  	call	find_name_in_environment
 22785                                  					;es:di points at path
 22786 00002D47 1F                      	pop	ds			;ds = DATARES again
 22787 00002D48 721F                    	jc	short no_temp_path
 22788                                  	
 22789 00002D4A 1E                      	push	ds
 22790 00002D4B 06                      	push	es
 22791 00002D4C 1F                      	pop	ds
 22792 00002D4D 07                      	pop	es			;swap ds and es
 22793 00002D4E 89FE                    	mov	si,di			;ds:si points at path
 22794                                  	
 22795 00002D50 E8AA02                  	call	skip_white		;skip white space chars
 22796                                  
 22797                                  ;This copies the path into both buffers -- Pipe1 & Pipe2
 22798                                  
 22799 00002D53 E8B302                  	call	copy_pipe_path		;copy the pipe path
 22800                                  	
 22801                                  ;Check if the TEMP path is valid
 22802                                  
 22803 00002D56 06                      	push	es
 22804 00002D57 1F                      	pop	ds			;ds = DATARES
 22805                                  	;mov	dx,offset DATARES:Pipe1	;ds:dx = path to look for
 22806                                  	;mov	dx,320h ; MSDOS 5.0 - offset EndInit
 22807 00002D58 BA[1A02]                	mov	dx,Pipe1
 22808                                  	;mov	ax,(CHMOD shl 8) or 0
 22809 00002D5B B80043                  	mov	ax,4300h
 22810 00002D5E CD21                    	int	21h
 22811 00002D60 7207                    	jc	short no_temp_path
 22812                                  	
 22813 00002D62 F7C11000                	test	cx,10h			;is it a directory?
 22814 00002D66 7501                    	jnz	short no_temp_path	;yes, continue (carry clear)
 22815                                  	
 22816 00002D68 F9                      	stc				;no, indicate fail
 22817                                  no_temp_path:
 22818 00002D69 5E                      	pop	si
 22819 00002D6A 1F                      	pop	ds
 22820 00002D6B 5F                      	pop	di
 22821 00002D6C 07                      	pop	es
 22822 00002D6D 730B                    	jnc	short crt_temp		;path found, create tempfiles
 22823                                  
 22824                                  	; 27/02/2023
 22825                                  	; MSDOS 3.3
 22826                                  	;mov	ah,GET_DEFAULT_DRIVE ; 19h
 22827                                  	;				; Get current drive
 22828                                  	;int	21h ; DOS - GET DEFAULT DISK NUMBER
 22829                                  	;add	al,[cs:CAPITAL_A]
 22830                                  	;mov	byte [PIPE2],al		; Make pipe files in root of def drv
 22831                                  	;mov	bx,PIPE1
 22832                                  	;mov	[bx],al
 22833                                  	;xor	ah,ah			; nul terminate path names
 22834                                  	;mov	byte [PIPE1+3],ah
 22835                                  	;mov	byte [PIPE2+3],ah
 22836                                  
 22837                                  	; MSDOS 6.0
 22838                                  ;SR;
 22839                                  ; We want to create temp files in the current directory rather than in the 
 22840                                  ;root of the drive. This is because the number of files that can be present
 22841                                  ;in the root directory is fixed, whereas it is not so in subdirectories.
 22842                                  
 22843                                  	;mov	ah,'.'
 22844                                  	;mov	[Pipe1],ah	; = RESGROUP:EndInit
 22845                                  	;mov	[Pipe2],ah	; = RESGROUP:EndInit+79
 22846                                  	;xor	ah,ah
 22847                                  	;mov	[Pipe1+1],ah	; = RESGROUP:EndInit+1
 22848                                  	;mov	[Pipe2+1],ah		;create files in current dir
 22849                                  	; 27/02/2023
 22850 00002D6F B92E00                  	mov	cx,002Eh
 22851 00002D72 890E[1A02]              	mov	[Pipe1],cx
 22852 00002D76 890E[6902]              	mov	[Pipe2],cx
 22853                                  crt_temp:
 22854                                  	; MSDOS 6.0
 22855                                  	;mov	dx,offset DATARES:Pipe1	; = RESGROUP:EndInit
 22856                                  	;mov	dx,320h ; MSDOS 5.0 COMMAND.COM
 22857 00002D7A BA[1A02]                	mov	dx,Pipe1
 22858                                  	; MSDOS 3.3
 22859                                  	;mov	dx,bx
 22860                                  	
 22861                                  	; MSDOS 3.3 (& MSDOS 6.0)
 22862 00002D7D 31C9                    	xor	cx,cx
 22863                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 22864 00002D7F B45A                    	mov	ah,5Ah
 22865 00002D81 CD21                    	int	21h
 22866                                  		; DOS -	3+ - CREATE UNIQUE FILE
 22867                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 22868                                  		; receive generated filename
 22869                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 22870 00002D83 728E                    	jc	short PIPERR	; Couldn't create
 22871                                  
 22872 00002D85 89C3                    	mov	bx,ax
 22873                                  	;mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 22874 00002D87 B43E                    	mov	ah,3Eh
 22875 00002D89 CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 22876                                  			; BX = file handle
 22877                                  	;;mov	dx,PIPE2
 22878                                  	;mov	dx,36Fh ; MSDOS 5.0 COMMAND.COM
 22879 00002D8B BA[6902]                	mov	dx,Pipe2
 22880                                  	;mov	ah,CREATETEMPFILE ; 5Ah ; the CreateTemp call
 22881 00002D8E B45A                    	mov	ah,5Ah
 22882 00002D90 CD21                    	int	21h
 22883                                  		; DOS -	3+ - CREATE UNIQUE FILE
 22884                                  		; DS:DX	-> ASCIZ directory path	name ending with a '' + 13 bytes to
 22885                                  		; receive generated filename
 22886                                  		; CX = file attributes (only bits 0,1,2,5 may be set)
 22887                                  	; 17/04/2023
 22888                                  	;jc	short PIPERR
 22889                                  	; 27/02/2023
 22890 00002D92 7303                    	jnc	short pps1
 22891 00002D94 E97CFF                  	jmp	PIPERR
 22892                                  pps1:
 22893 00002D97 89C3                    	mov	bx,ax
 22894 00002D99 B43E                    	mov	ah,CLOSE ; 3Eh	; Don't proliferate handles
 22895 00002D9B CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 22896                                  				; BX = file handle
 22897                                  	;call	near ptr TESTDOREIN ; Set up a redirection if specified
 22898 00002D9D E87FFE                  	call	TESTDOREIN
 22899 00002DA0 8B36[B802]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 22900 00002DA4 833E[A601]FF            	cmp	word [SingleCom],-1
 22901 00002DA9 7506                    	jne	short NOSINGP
 22902 00002DAB C706[A601]00F0          	mov	word [SingleCom],0F000h ; Flag single command pipe
 22903                                  NOSINGP:
 22904 00002DB1 EB29                    	jmp	short FIRSTPIPE
 22905                                  
 22906                                  ; ---------------------------------------------------------------------------
 22907                                  
 22908                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 22909                                  PIPEPROC:
 22910 00002DB3 8026[A001]FE            	and	byte [EchoFlag],0FEh  ; force current echo to be off
 22911 00002DB8 8B36[B802]              	mov	si,[PipePtr]	; offset RESGROUP:EndInit+158
 22912 00002DBC AC                      	lodsb
 22913                                  	; 27/02/2023
 22914 00002DBD 3C7C                    	cmp	al,'|'		
 22915                                  	;;cmp	al,ALTPIPECHR	; Alternate pipe char? 	
 22916                                  	;je	short ISPIPE1	; Yes
 22917                                  	;cmp	al,'|'
 22918                                  	;;cmp	al,[cs:VBAR]
 22919 00002DBF 7403                    	je	short ISPIPE1
 22920 00002DC1 E98400                  	jmp	PIPEEND		; Pipe done
 22921                                  ISPIPE1:
 22922 00002DC4 8B16[3B03]              	mov	dx,[InPipePtr]	; Get the input file name
 22923                                  	;mov	ax,OPEN*256 ; 3D00h
 22924 00002DC8 B8003D                  	mov	ax,3D00h
 22925 00002DCB CD21                    	int	21h	; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 22926                                  			; DS:DX	-> ASCIZ filename
 22927                                  			; AL = access mode
 22928                                  			; 0 - read
 22929                                  PIPEERRJ:
 22930 00002DCD 7303                    	jnc	short NO_PIPEERR
 22931 00002DCF E941FF                  	jmp	PIPERR		; Lost the pipe file
 22932                                  NO_PIPEERR:
 22933 00002DD2 89C3                    	mov	bx,ax
 22934 00002DD4 B0FF                    	mov	al,0FFh
 22935                                  	;xchg	al,[bx+18h]
 22936 00002DD6 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 22937 00002DD9 A21800                  	mov	[PDB.JFN_TABLE],al	; Redirect
 22938                                  FIRSTPIPE:
 22939 00002DDC BF[FD88]                	mov	di,COMBUF+2
 22940 00002DDF 31C9                    	xor	cx,cx
 22941 00002DE1 803C0D                  	cmp	byte [si],0Dh	; '|<CR>'
 22942 00002DE4 7503                    	jne	short PIPEOK1
 22943                                  PIPEERRSYNJ:
 22944 00002DE6 E91FFF                  	jmp	PIPEERRSYN
 22945                                  PIPEOK1:
 22946                                  	;;;mov	al,[cs:VBAR]
 22947                                  	; 27/02/2023
 22948                                  	;;mov	al,vbar
 22949                                  	;mov	al,'|'
 22950                                  	;cmp	[si],al		; '||'
 22951                                  	;je	short PIPEERRSYNJ
 22952 00002DE9 803C7C                  	cmp	byte [si],'|'
 22953                                  	;cmp	byte [si],ALTPIPECHR ; '##' or '|#'?
 22954 00002DEC 74F8                    	je	short PIPEERRSYNJ
 22955                                  PIPECOMLP:
 22956 00002DEE AC                      	lodsb
 22957 00002DEF AA                      	stosb
 22958                                  	; 27/02/2023
 22959 00002DF0 E8C5F5                  	call	testkanj
 22960 00002DF3 7405                    	jz	short NOTKANJ5
 22961 00002DF5 A4                      	movsb
 22962                                  ;  Added following 2 commands to the fix pipe bug.
 22963 00002DF6 41                      	inc	cx		;AN000;  3/3/KK
 22964 00002DF7 41                      	inc	cx		;AN000;  3/3/KK
 22965 00002DF8 EBF4                    	jmp	short PIPECOMLP
 22966                                  NOTKANJ5:
 22967 00002DFA 3C0D                    	cmp	al,0Dh
 22968 00002DFC 7438                    	je	short LASTPIPE
 22969 00002DFE 41                      	inc	cx
 22970                                  	; 27/02/2023
 22971 00002DFF 3C7C                    	cmp	al,'|'
 22972                                  	;cmp	al,ALTPIPECHR
 22973                                  	;je	short ISPIPE2
 22974                                  	;;cmp	al,[cs:VBAR]
 22975                                  	;cmp	al,vbar
 22976 00002E01 75EB                    	jne	short PIPECOMLP
 22977                                  ISPIPE2:
 22978 00002E03 26C645FF0D              	mov	byte [es:di-1],0Dh
 22979 00002E08 49                      	dec	cx
 22980                                  	;mov	[cs:COMBUF+1],cl
 22981                                  	; 27/02/2023
 22982 00002E09 26880E[FC88]            	mov	[es:COMBUF+1],cl
 22983 00002E0E 4E                      	dec	si
 22984                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 22985 00002E0F 8936[B802]              	mov	[PipePtr],si		; On to next pipe element
 22986                                  			; mov [EndInit+158],si
 22987 00002E13 8B16[3D03]              	mov	dx,[OutPipePtr]
 22988 00002E17 51                      	push	cx
 22989 00002E18 31C9                    	xor	cx,cx
 22990                                  	;mov	ax,CREAT*256 ; 3C00h
 22991 00002E1A B8003C                  	mov	ax,3C00h
 22992 00002E1D CD21                    	int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 22993                                  			; CX = attributes for file
 22994                                  			; DS:DX	-> ASCIZ filename (may include drive and path)
 22995 00002E1F 59                      	pop	cx
 22996 00002E20 72AB                    	jc	short PIPEERRJ		; Lost the file
 22997 00002E22 89C3                    	mov	bx,ax
 22998 00002E24 B0FF                    	mov	al,0FFh
 22999                                  	;xchg	al,[bx+18h]
 23000 00002E26 864718                  	xchg	al,[bx+PDB.JFN_TABLE]
 23001 00002E29 A21900                  	mov	[PDB.JFN_TABLE+1],al
 23002 00002E2C 8716[3B03]              	xchg	dx,[InPipePtr]	; Swap for next element of pipe
 23003 00002E30 8916[3D03]              	mov	[OutPipePtr],dx
 23004 00002E34 EB0D                    	jmp	short PIPECOM
 23005                                  LASTPIPE:
 23006                                  	;mov	[cs:COMBUF+1],cl 
 23007                                  	; 27/02/2023
 23008 00002E36 26880E[FC88]            	mov	[es:COMBUF+1],cl
 23009 00002E3B 4E                      	dec	si
 23010                                  	;mov	[3BEh],si ; MSDOS 5.0 COMMAND.COM
 23011 00002E3C 8936[B802]              	mov	[PipePtr],si	; Point at the CR (anything not '|' will do)
 23012                                  		; mov [EndInit+158],si
 23013 00002E40 E857FD                  	call	TESTDOREOUT	; Set up the redirection if specified
 23014                                  PIPECOM:
 23015 00002E43 0E                      	push	cs
 23016 00002E44 1F                      	pop	ds
 23017 00002E45 E99AD4                  	jmp	NOPIPEPROC	; Process the pipe element
 23018                                  PIPEEND:
 23019 00002E48 E89DFE                  	call	PIPEDEL
 23020 00002E4B 813E[A601]00F0          	cmp	word [SingleCom],0F000h
 23021 00002E51 7506                    	jnz	short NOSINGP2
 23022 00002E53 C706[A601]FFFF          	mov	word [SingleCom],-1 ; 0FFFFh ; Make it return
 23023                                  NOSINGP2:
 23024 00002E59 E9A8D2                  	jmp	TCOMMAND
 23025                                  
 23026                                  ; =============== S U B	R O U T	I N E =======================================
 23027                                  
 23028                                  ; Date and time are set during initialization and use
 23029                                  ; this routines since they need to do a long return
 23030                                  
 23031                                  	; 27/02/2023 - Retro DOS v4.0 COMMAND.COM
 23032                                  DATINIT:
 23033 00002E5C 2E8C1E[9C8A]            	mov	[cs:RESSEG],ds	; SetInitFlag needs resseg initialized
 23034 00002E61 06                      	push	es
 23035 00002E62 1E                      	push	ds		; Going to use the previous stack
 23036 00002E63 8CC8                    	mov	ax,cs		; Set up the appropriate segment registers
 23037 00002E65 8EC0                    	mov	es,ax
 23038 00002E67 8ED8                    	mov	ds,ax
 23039 00002E69 E87820                  	call	TSYSLOADMSG ; MSDOS 6.0 ; AN000; preload messages
 23040 00002E6C BA[7A95]                	mov	dx,INTERNATVARS
 23041 00002E6F B80038                  	mov	ax,3800h
 23042                                  	;mov	ax,INTERNATIONAL*256 ; 3800h
 23043 00002E72 CD21                    	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23044                                  			; get current-country info
 23045                                  			; DS:DX	-> buffer for returned info
 23046                                  	; 20/10/2018
 23047 00002E74 C70681000D00            	mov	word [81h],0Dh ; Want to prompt for date during initialization
 23048 00002E7A C606[FB88]80            	mov	byte [COMBUF],128 ; Init COMBUF
 23049 00002E7F C706[FC88]010D          	mov	word [COMBUF+1],0D01h
 23050 00002E85 E80600                  	call	DATE
 23051 00002E88 E86200                  	call	CTIME
 23052 00002E8B 1F                      	pop	ds
 23053 00002E8C 07                      	pop	es
 23054 00002E8D CB                      	retf	; far return
 23055                                  
 23056                                  ; =============== S U B	R O U T	I N E =======================================
 23057                                  
 23058                                  ; MSDOS 6.0
 23059                                  
 23060                                  ; ****************************************************************
 23061                                  ; *
 23062                                  ; * ROUTINE:	 DATE - Set system date
 23063                                  ; *
 23064                                  ; * FUNCTION:	 If a date is specified, set the system date,
 23065                                  ; *		 otherwise display the current system date and
 23066                                  ; *		 prompt the user for a new date.  If an invalid
 23067                                  ; *		 date is specified, issue an error message and
 23068                                  ; *		 prompt for a new date.  If the user enters
 23069                                  ; *		 nothing when prompted for a date, terminate.
 23070                                  ; *
 23071                                  ; * INPUT:	 command line at offset 81H
 23072                                  ; *
 23073                                  ; * OUTPUT:	 none
 23074                                  ; *
 23075                                  ; ****************************************************************
 23076                                  
 23077                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23078                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:2FC4h
 23079                                  	; 11/06/2023
 23080                                  DATE:
 23081 00002E8E BE8100                  	mov	si,81h			; Accepting argument for date inline
 23082 00002E91 BF[E784]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23083 00002E94 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23084 00002E96 31D2                    	xor	dx,dx			;AN000;
 23085 00002E98 E89514                  	call	cmd_parse		;AC000; call parser
 23086                                  	
 23087                                  	; 27/02/2023
 23088                                  	;cmp	ax,-1
 23089                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23090                                  	;je	short PRMTDAT 		;AC000; yes - go ask for date
 23091                                  	;;cmp	ax,0
 23092                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23093                                  	;;jne	short DATERR		;AN000; yes - go issue message
 23094                                  	; 26/04/2023
 23095                                  	;or	ax,ax ; ax = 0 ?
 23096                                  	;jnz	short DATERR
 23097                                  	;;jmp	short COMDAT		;AC000; we have a date
 23098                                  	; 11/06/2023
 23099 00002E9B 40                      	inc	ax  ; cmp ax,-1
 23100 00002E9C 7428                    	jz	short PRMTDAT ; 0FFFFh -> 0
 23101 00002E9E 48                      	dec	ax  ; cmp ax,0
 23102 00002E9F 7541                    	jnz	short DATERR ; 1 -> 0
 23103                                  	; ax = 0
 23104                                  	
 23105                                  	; 27/02/2023
 23106                                  COMDAT:
 23107 00002EA1 8B0E[D795]              	mov	cx,[DATE_YEAR]		;AC000; get parts of date in
 23108 00002EA5 8A36[D995]              	mov	dh,[DATE_MONTH]		;AC000;  cx and dx for set
 23109 00002EA9 8A16[DA95]              	mov	dl,[DATE_DAY]		;AC000;  date function call.
 23110 00002EAD 51                      	push	cx			;AC000; save date
 23111 00002EAE 52                      	push	dx			;AC000;
 23112 00002EAF B90100                  	mov	cx,1			;AC000; set 1 positional entered
 23113 00002EB2 31D2                    	xor	dx,dx			;AN029;
 23114 00002EB4 E87914                  	call	cmd_parse		;AN029; call parser
 23115 00002EB7 3CFF                    	cmp	al,0FFh ; -1
 23116                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23117 00002EB9 5A                      	pop	dx			;AC000; retrieve date
 23118 00002EBA 59                      	pop	cx			;AC000;
 23119 00002EBB 7525                    	jnz	short DATERR		;AC000; extra stuff on line - try again
 23120                                  	; 26/04/2023
 23121                                  	;mov	ah,SET_DATE		;yes - set date
 23122 00002EBD B42B                    	mov	ah,2Bh
 23123 00002EBF CD21                    	int	21h
 23124                                  			; DOS - SET CURRENT DATE
 23125                                  			; DL = day, DH = month, CX = year
 23126                                  			; Return: AL = 00h if no error /= FFh if bad value sent to routine
 23127 00002EC1 08C0                    	or	al,al
 23128 00002EC3 751D                    	jnz	short DATERR
 23129                                  date_end:
 23130 00002EC5 C3                      	retn
 23131                                  
 23132                                  PRMTDAT:
 23133                                  	; Print "Current date is
 23134                                  
 23135 00002EC6 E82B08                  	call	GetDate 		;AN000; get date for output
 23136 00002EC9 86F2                    	xchg	dh,dl			;AN000; switch month & day
 23137 00002ECB 890E[DF7F]              	mov	[CurDat_yr],cx		;AC000; put year into message control block
 23138 00002ECF 8916[E17F]              	mov	[CurDat_mo_day],dx	;AC000; put month and day into message control block
 23139 00002ED3 BA[CF7F]                	mov	dx,CurDat_Ptr		;AC000; set up message for output
 23140 00002ED6 E82A1F                  	call	std_printf
 23141                                  
 23142                                  ;AD061; mov	word [CurDat_yr],0	;AC000; reset year, month and day
 23143                                  ;AD061; mov	word [CurDat_mo_day],0 	;AC000;  pointers in control block
 23144                                  
 23145                                  GET_NEW_DATE:				;AN000;
 23146 00002ED9 E8BC00                  	call	GETDAT			;AC000; prompt user for date
 23147                                  	
 23148                                  	; 11/06/2023
 23149                                  	;cmp	ax,0FFFFh ; -1
 23150                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23151                                  	;je	short date_end		;AC000; yes - exit
 23152                                  	; 26/04/2023
 23153                                  	;;cmp	ax,0
 23154                                  	;;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23155                                  	;;;jnz	short DATERR		;AN000; yes - go issue message
 23156                                  	;; 27/02/2023
 23157                                  	;;jz	short COMDAT
 23158                                  	; 26/04/2023
 23159                                  	;and	ax,ax ; 0 ?
 23160                                  	;jz	short COMDAT
 23161                                  
 23162                                  	; 11/06/2023
 23163 00002EDC 40                      	inc	ax  ; cmp ax,-1
 23164 00002EDD 74E6                    	jz	short date_end ; 0FFFFh -> 0
 23165 00002EDF 48                      	dec	ax  ; cmp ax,0
 23166 00002EE0 74BF                    	jz	short COMDAT ; 1 -> 0
 23167                                  	; ax > 0
 23168                                  
 23169                                  ;COMDAT:
 23170                                  ;	....
 23171                                  DATERR:
 23172 00002EE2 E8E5F6                  	call	CRLF2			;AN028; print out a blank line
 23173 00002EE5 BA[CC7F]                	mov	dx,BADDAT_PTR
 23174 00002EE8 E8181F                  	call	std_printf
 23175 00002EEB EBEC                    	jmp	short GET_NEW_DATE	;AC000; get date again
 23176                                  
 23177                                  ; =============== S U B	R O U T	I N E =======================================
 23178                                  
 23179                                  ; MSDOS 6.0
 23180                                  
 23181                                  ; TIME gets and sets the time
 23182                                  
 23183                                  ; ****************************************************************
 23184                                  ; *
 23185                                  ; * ROUTINE:	 TIME - Set system time
 23186                                  ; *
 23187                                  ; * FUNCTION:	 If a time is specified, set the system time,
 23188                                  ; *		 otherwise display the current system time and
 23189                                  ; *		 prompt the user for a new time.  If an invalid
 23190                                  ; *		 time is specified, issue an error message and
 23191                                  ; *		 prompt for a new time.  If the user enters
 23192                                  ; *		 nothing when prompted for a time, terminate.
 23193                                  ; *
 23194                                  ; * INPUT:	 command line at offset 81H
 23195                                  ; *
 23196                                  ; * OUTPUT:	 none
 23197                                  ; *
 23198                                  ; ****************************************************************
 23199                                  
 23200                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23201                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:302Dh
 23202                                  	; 11/06/2023
 23203                                  CTIME:
 23204 00002EED BE8100                  	mov	si,81h			; Accepting argument for time inline
 23205 00002EF0 BF[F984]                	mov	di,PARSE_TIME		;AN000; Get address of PARSE_time
 23206 00002EF3 31C9                    	xor	cx,cx			;AN000; clear counter for positionals
 23207 00002EF5 31D2                    	xor	dx,dx			;AN000;
 23208 00002EF7 E83614                  	call	cmd_parse		;AC000; call parser
 23209                                  	
 23210                                  	; 27/02/2023
 23211                                  	;cmp	ax,-1
 23212                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23213                                  	;je	short PRMTTIM 		;AC000; yes - prompt for time
 23214                                  	;;cmp	ax,0
 23215                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23216                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 23217                                  	;and	ax,ax ; ax = 0 ?
 23218                                  	;jnz	short TIMERR
 23219                                  	;;jmp	short COMTIM		;AC000; we have a time
 23220                                  	; 11/06/2023
 23221 00002EFA 40                      	inc	ax  ; cmp ax,-1
 23222 00002EFB 742C                    	jz	short PRMTTIM ; 0FFFFh -> 0
 23223 00002EFD 48                      	dec	ax  ; cmp ax,0
 23224 00002EFE 7548                    	jnz	short TIMERR ; 1 -> 0
 23225                                  	; ax = 0
 23226                                  	
 23227                                  	; 27/02/2023
 23228                                  COMTIM:
 23229 00002F00 8A2E[DF95]              	mov	ch,[TIME_HOUR]		;AC000; get parts of time in
 23230 00002F04 8A0E[E095]              	mov	cl,[TIME_MINUTES]	;AC000;  cx and dx for set
 23231 00002F08 8A36[E195]              	mov	dh,[TIME_SECONDS]	;AC000;  time function call
 23232 00002F0C 8A16[E295]              	mov	dl,[TIME_FRACTION]	;AC000;
 23233 00002F10 51                      	push	cx			;AC000; save time
 23234 00002F11 52                      	push	dx			;AC000;
 23235 00002F12 B90100                  	mov	cx,1			;AC000; set 1 positional parm entered
 23236 00002F15 31D2                    	xor	dx,dx			;AN029;
 23237 00002F17 E81614                  	call	cmd_parse		;AN029; call parser
 23238 00002F1A 3CFF                    	cmp	al, -1
 23239                                  	;cmp	al,END_OF_LINE		;AN029; Are we at end of line?
 23240 00002F1C 5A                      	pop	dx			;AC000; retieve time
 23241 00002F1D 59                      	pop	cx			;AC000;
 23242 00002F1E 7528                    	jnz	short TIMERR		;AC000; extra stuff on line - try again
 23243                                  SAVTIM:
 23244                                  	;mov	ah,SET_TIME
 23245 00002F20 B42D                    	mov	ah,2Dh
 23246 00002F22 CD21                    	int	21h
 23247 00002F24 08C0                    	or	al,al
 23248 00002F26 7520                    	jnz	short TIMERR		;AC000; if an error occured, try again
 23249                                  time_end:
 23250 00002F28 C3                      	retn
 23251                                  
 23252                                  PRMTTIM:
 23253                                  	;Printf "Current time is ... "
 23254                                  
 23255                                  	;mov	ah,Get_Time		;AC000; get the current time
 23256 00002F29 B42C                    	mov	ah,2Ch
 23257 00002F2B CD21                    	int	21h			;AC000;   Get time in CX:DX
 23258 00002F2D 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23259 00002F2F 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23260 00002F31 890E[0180]              	mov	[CurTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23261 00002F35 8916[0380]              	mov	[CurTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23262 00002F39 BA[FC7F]                	mov	dx,CurTim_Ptr		;AC000; set up message for output
 23263 00002F3C E8C41E                  	call	std_printf
 23264                                  
 23265                                  ;AD061; mov	word [CurTim_hr_min],0 	;AC000; reset hour, minutes, seconds, and hundredths
 23266                                  ;AD061; mov	word [CurTim_Sec_hn],0 	;AC000;  pointers in control block
 23267                                  
 23268                                  GET_NEW_TIME:
 23269 00002F3F E8AE00                  	call	GETTIM			;AC000;
 23270                                  	
 23271                                  	; 11/06/2023
 23272                                  	;cmp	ax,-1
 23273                                  	;;cmp	ax,END_OF_LINE		;AC000; are we at end of line?
 23274                                  	;je	short time_end		;AC000;
 23275                                  	;;cmp	ax,0
 23276                                  	;;cmp	ax,RESULT_NO_ERROR	;AN000; did we have an error?
 23277                                  	;;jne	short TIMERR		;AN000; yes - go issue message
 23278                                  	;or	ax,ax  ; ax = 0 ?
 23279                                  	;;jnz	short TIMERR
 23280                                  	; 27/02/2023
 23281                                  	;jz	short COMTIM
 23282                                  
 23283                                  	; 11/06/2023
 23284 00002F42 40                      	inc	ax  ; cmp ax,-1
 23285 00002F43 74E3                    	jz	short time_end ; 0FFFFh -> 0
 23286 00002F45 48                      	dec	ax  ; cmp ax,0
 23287 00002F46 74B8                    	jz	short COMTIM ; 1 -> 0
 23288                                  	; ax > 0
 23289                                  
 23290                                  ;COMTIM:
 23291                                  ;	....
 23292                                  TIMERR:
 23293 00002F48 E87FF6                  	call	CRLF2			;AN028; print out a blank line
 23294 00002F4B BA[F97F]                	mov	dx,BadTim_Ptr
 23295 00002F4E E8B21E                  	call	std_printf		; Print error message
 23296 00002F51 EBEC                    	jmp	short GET_NEW_TIME	;AC000; Try again
 23297                                  
 23298                                  ; =============== S U B	R O U T	I N E =======================================
 23299                                  
 23300                                  ; MSDOS 6.0
 23301                                  
 23302                                  ; Set the special flag in the INIT flag to the value in CX.
 23303                                  
 23304                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23305                                  SetInitFlag:
 23306 00002F53 8E1E[9C8A]              	mov	ds,[RESSEG]
 23307                                  
 23308 00002F57 8026[1702]FD            	and	byte [InitFlag],~INITSPECIAL ; 0FDh ; not initspecial
 23309                                  	;and	byte [InitFlag],0FDh
 23310 00002F5C 080E[1702]              	or	byte [InitFlag],cl
 23311 00002F60 0E                      	push	cs
 23312 00002F61 1F                      	pop	ds
 23313 00002F62 C3                      	retn
 23314                                  
 23315                                  ; =============== S U B	R O U T	I N E =======================================
 23316                                  
 23317                                  ; MSDOS 6.0
 23318                                  
 23319                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23320                                  PipeOff:
 23321 00002F63 1E                      	push	ds
 23322 00002F64 50                      	push	ax
 23323 00002F65 2E8E1E[9C8A]            	mov	ds,[cs:RESSEG]
 23324 00002F6A 30C0                    	xor	al,al
 23325 00002F6C 8606[1802]              	xchg	[PipeFlag],al
 23326 00002F70 08C0                    	or	al,al
 23327 00002F72 7404                    	jz	short PipeOffDone
 23328 00002F74 D02E[A001]              	shr	byte [EchoFlag],1
 23329                                  PipeOffDone:
 23330 00002F78 58                      	pop	ax
 23331 00002F79 1F                      	pop	ds
 23332 00002F7A C3                      	retn
 23333                                  
 23334                                  ; =============== S U B	R O U T	I N E =======================================
 23335                                  
 23336                                  ; MSDOS 6.0
 23337                                  
 23338                                  	; 27/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23339                                  PRINT_TIME:
 23340                                  	;mov	ah,Get_Time
 23341 00002F7B B42C                    	mov	ah,2Ch
 23342 00002F7D CD21                    	int	21h			; Get time in CX:DX
 23343                                  
 23344 00002F7F 06                      	push	es
 23345 00002F80 0E                      	push	cs
 23346 00002F81 07                      	pop	es
 23347 00002F82 86E9                    	xchg	ch,cl			;AN000; switch hours & minutes
 23348 00002F84 86F2                    	xchg	dh,dl			;AN000; switch seconds & hundredths
 23349 00002F86 2E890E[3A81]            	mov	[cs:PromTim_hr_min],cx	;AC000; put hours and minutes into message subst block
 23350 00002F8B 2E8916[3C81]            	mov	[cs:PromTim_Sec_hn],dx	;AC000; put seconds and hundredths into message subst block
 23351 00002F90 BA[3581]                	mov	dx,promtim_ptr		;AC000; set up message for output
 23352 00002F93 E86D1E                  	call	std_printf
 23353                                  
 23354                                  ;AD061; mov	word [cs:PromTim_hr_min],0
 23355                                  					;AC000; reset hour, minutes, seconds, and hundredths
 23356                                  ;AD061; mov	word [cs:PromTim_Sec_hn],0
 23357                                  					;AC000;  pointers in control block
 23358 00002F96 07                      	pop	es
 23359 00002F97 C3                      	retn
 23360                                  
 23361                                  ; =============== S U B	R O U T	I N E =======================================
 23362                                  
 23363                                  ; MSDOS 6.0
 23364                                  
 23365                                  ; ****************************************************************
 23366                                  ; *
 23367                                  ; * ROUTINE:	 GETDAT - Prompt user for date
 23368                                  ; *
 23369                                  ; * FUNCTION:	 Gets the date format from the COUNTRY DEPENDENT
 23370                                  ; *		 INFORMATION and issues the "Enter new date"
 23371                                  ; *		 message with the proper date format. COMBUF
 23372                                  ; *		 is reset to get a date from the command line.
 23373                                  ; *		 The PARSE_DATE blocks are then reset and the
 23374                                  ; *		 PARSE function call is issued.
 23375                                  ; *
 23376                                  ; * INPUT:	 NONE
 23377                                  ; *
 23378                                  ; * OUTPUT:	 COMBUF
 23379                                  ; *		 PARSER RETURN CODES
 23380                                  ; *
 23381                                  ; ****************************************************************
 23382                                  
 23383                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23384                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:30E2h
 23385                                  GETDAT:
 23386                                  	;mov	ax,(International SHL 8)
 23387 00002F98 B80038                  	mov	ax,3800h
 23388                                  					; Determine what format the date
 23389 00002F9B BA5C00                  	mov	dx,5Ch			;  should be entered in and
 23390 00002F9E CD21                    	int	21h			;  print a message describing it
 23391                                  			; DOS - 2+ - GET COUNTRY-DEPENDENT INFORMATION
 23392                                  			; get current-country info
 23393                                  			; DS:DX -> buffer for returned info
 23394 00002FA0 89D6                    	mov	si,dx
 23395 00002FA2 AD                      	lodsw
 23396 00002FA3 2E8B16[1381]            	mov	dx,[cs:usadat_ptr]	;AC000; get mm-dd-yy
 23397 00002FA8 48                      	dec	ax
 23398 00002FA9 780C                    	js	short printformat
 23399 00002FAB 2E8B16[1681]            	mov	dx,[cs:eurdat_ptr]	;AC000; get dd-mm-yy
 23400 00002FB0 7405                    	jz	short printformat
 23401 00002FB2 2E8B16[1981]            	mov	dx,[cs:japdat_ptr]	;AC000; get yy-mm-dd
 23402                                  printformat:
 23403 00002FB7 89D0                    	mov	ax,dx			;AN000; get message number of format
 23404                                  	;mov	dh,util_msg_class	;AN000; this is a utility message
 23405 00002FB9 B6FF                    	mov	dh,-1 ; 0FFh
 23406 00002FBB E82C1F                  	call	TSYSGETMSG		;AN000; get the address of the message
 23407 00002FBE 2E8936[F07F]            	mov	[cs:NewDat_Format],si	;AN000; put the address in subst block
 23408 00002FC3 BA[EB7F]                	mov	dx,NewDat_Ptr		;AC000; get address of message to print
 23409 00002FC6 E83A1E                  	call	std_printf
 23410                                  	;mov	word [cs:NewDat_Format],no_subst
 23411                                  					;AN000; reset subst block
 23412 00002FC9 2EC706[F07F]0000        	mov	word [cs:NewDat_Format],0
 23413                                  
 23414                                  	; 28/02/2023
 23415 00002FD0 BF[E784]                	mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23416                                  ; 28/02/2023
 23417                                  gettim_p:	
 23418                                  	;mov	ah,Std_Con_String_Input
 23419 00002FD3 B40A                    	mov	ah,0Ah
 23420 00002FD5 BA[FB88]                	mov	dx,COMBUF
 23421 00002FD8 B90200                  	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23422 00002FDB E875FF                  	call	SetInitFlag		;  prompting for date.
 23423 00002FDE CD21                    	int	21h			; Get input line
 23424 00002FE0 31C9                    	xor	cx,cx			; Reset bit in InitFlag that indicates
 23425 00002FE2 E86EFF                  	call	SetInitFlag		;  prompting for date.
 23426 00002FE5 E8E2F5                  	call	CRLF2
 23427                                  	; 28/02/2023
 23428                                  	;mov	di,PARSE_DATE		;AN000; Get address of PARSE_DATE
 23429                                  ;gettim_p: ; 28/02/2023
 23430 00002FE8 BE[FD88]                	mov	si,COMBUF+2
 23431                                  	;xor	cx,cx	 ; cx = 0	;AN000; clear counter for positionals
 23432 00002FEB 31D2                    	xor	dx,dx			;AN000;
 23433                                  	;call	cmd_parse		;AC000; call parser
 23434                                  	;retn
 23435                                  	; 28/02/2023
 23436 00002FED E94013                  	jmp	cmd_parse
 23437                                  
 23438                                  ; =============== S U B	R O U T	I N E =======================================
 23439                                  
 23440                                  ; MSDOS 6.0
 23441                                  
 23442                                  ; ****************************************************************
 23443                                  ; *
 23444                                  ; * ROUTINE:	 GETTIME - Prompt user for time
 23445                                  ; *
 23446                                  ; * FUNCTION:	 Gets the time format from the COUNTRY DEPENDENT
 23447                                  ; *		 INFORMATION and issues the "Enter new time"
 23448                                  ; *		 message. COMBUF is reset to get a time from the
 23449                                  ; *		 command line. The PARSE_TIME blocks are then
 23450                                  ; *		 reset and the PARSE function call is issued.
 23451                                  ; *
 23452                                  ; * INPUT:	 NONE
 23453                                  ; *
 23454                                  ; * OUTPUT:	 COMBUF
 23455                                  ; *		 PARSER RETURN CODES
 23456                                  ; *
 23457                                  ; ****************************************************************
 23458                                  
 23459                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23460                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:313Dh
 23461                                  GETTIM:
 23462 00002FF0 31C9                    	xor	cx,cx			; Initialize hours and minutes to zero
 23463 00002FF2 BA[0A80]                	mov	dx,NewTim_Ptr
 23464 00002FF5 E80B1E                  	call	std_printf
 23465                                  
 23466                                  	; 28/02/2023
 23467 00002FF8 BF[F984]                	mov	di,PARSE_TIME
 23468 00002FFB EBD6                    	jmp	short gettim_p
 23469                                  
 23470                                  ; 28/02/2023
 23471                                  ;	;mov	ah,Std_Con_String_Input
 23472                                  ;	mov	ah,0Ah
 23473                                  ;	mov	dx,COMBUF
 23474                                  ;	mov	cx,INITSPECIAL ; 2	; Set bit in InitFlag that indicates
 23475                                  ;	call	SetInitFlag		;  prompting for time.
 23476                                  ;	int	21h			; Get input line
 23477                                  ;	; 28/02/2023
 23478                                  ;	xor	cx,cx			; Reset bit in InitFlag that indicates
 23479                                  ;	call	SetInitFlag		;  prompting for time.
 23480                                  ;	call	CRLF2
 23481                                  ;	; 28/02/2023
 23482                                  ;	;mov	si,COMBUF+2
 23483                                  ;	; 28/02/2023
 23484                                  ;	mov	di,PARSE_TIME		;AN000; Get address of PARSE_TIME
 23485                                  ;	; 28/02/2023
 23486                                  ;	jmp	short gettim_p	
 23487                                  ;	; 28/02/2023
 23488                                  ;	;;xor	cx,cx			;AN000; clear counter for positionals
 23489                                  ;	;xor	dx,dx			;AN000;
 23490                                  ;	;call	cmd_parse		;AC000; call parser
 23491                                  ;	;retn
 23492                                  
 23493                                  
 23494                                  ; =============== S U B	R O U T	I N E =======================================
 23495                                  
 23496                                  ; MSDOS 6.0
 23497                                  
 23498                                  ;Skip_white: Skips over the whitespace chars that could be present after
 23499                                  ;the '=' sign in the environment variable before the actual path.
 23500                                  ;
 23501                                  ;	ENTRY:	ds:si = arguments of the environment variable
 23502                                  ;
 23503                                  ;	EXIT:	ds:si = start of the path
 23504                                  ;
 23505                                  ;	REGISTERS AFFECTED: ax
 23506                                  
 23507                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23508                                  skip_white:
 23509 00002FFD FC                      	cld
 23510                                  skw_lp:
 23511 00002FFE AC                      	lodsb
 23512 00002FFF 3C20                    	cmp	al,' '			;blank char?
 23513 00003001 74FB                    	jz	short skw_lp		;yes, skip it
 23514 00003003 3C09                    	cmp	al,9			;tab char?
 23515 00003005 74F7                    	jz	short skw_lp		;yes, skip it
 23516 00003007 4E                      	dec	si			;point at first non-white
 23517 00003008 C3                      	retn
 23518                                  
 23519                                  ; =============== S U B	R O U T	I N E =======================================
 23520                                  
 23521                                  ; MSDOS 6.0
 23522                                  
 23523                                  ;Copy_pipe_path: This routine copies the path from the TEMP environment
 23524                                  ;variable into the path buffers Pipe1 & Pipe2.
 23525                                  ;
 23526                                  ;	ENTRY:	ds:si = path to be copied
 23527                                  ;		es = RESGROUP
 23528                                  ;
 23529                                  ;	EXIT:	Path copied into Pipe1 and Pipe2.
 23530                                  ;
 23531                                  ;	REGISTERS AFFECTED: si, di, cx, ax
 23532                                  
 23533                                  	; 28/02/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 23534                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3174h
 23535                                  
 23536                                  copy_pipe_path:
 23537 00003009 B9FFFF                  	mov	cx,0FFFFh ; 65535
 23538 0000300C 30C0                    	xor	al,al
 23539                                  
 23540 0000300E 89F7                    	mov	di,si
 23541 00003010 06                      	push	es			;save es
 23542 00003011 1E                      	push	ds
 23543 00003012 07                      	pop	es			;es:di = path to be copied
 23544                                  	
 23545 00003013 FC                      	cld
 23546 00003014 57                      	push	di
 23547 00003015 F2AE                    	repnz	scasb			;look for the null char
 23548 00003017 5F                      	pop	di
 23549                                  
 23550 00003018 07                      	pop	es			;es = RESGROUP again
 23551                                  
 23552 00003019 F7D1                    	not	cx			;length including the null
 23553                                  
 23554                                  	;;mov	di,320h ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit)
 23555                                  	;mov	di,offset DATARES:Pipe1
 23556 0000301B BF[1A02]                	mov	di,Pipe1  ; (offset RESGROUP:EndInit)
 23557 0000301E 57                      	push	di
 23558 0000301F 51                      	push	cx			
 23559 00003020 F3A4                    	rep	movsb			;copy path into Pipe1
 23560 00003022 59                      	pop	cx
 23561 00003023 5F                      	pop	di
 23562                                  
 23563 00003024 1E                      	push	ds
 23564 00003025 06                      	push	es
 23565 00003026 1F                      	pop	ds			;ds:si = Pipe1
 23566 00003027 89FE                    	mov	si,di
 23567                                  	;;mov	di,36Fh ; MSDOS 5.0 COMMAND.COM ; (RESGROUP:EndInit+79)
 23568                                  	;mov	di,offset DATARES:Pipe2	;es:di = Pipe2
 23569 00003029 BF[6902]                	mov	di,Pipe2  ; (offset RESGROUP:EndInit+79)
 23570 0000302C F3A4                    	rep	movsb			;copy path into Pipe2
 23571 0000302E 1F                      	pop	ds
 23572 0000302F C3                      	retn
 23573                                  
 23574                                  ; 28/02/2023
 23575                                  %if 0
 23576                                  
 23577                                  ;============================================================================
 23578                                  ; TCODE4.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 23579                                  ;============================================================================
 23580                                  ; 05/10/2018 - Retro DOS v3.0
 23581                                  
 23582                                  ; DATE - Gets and sets the time
 23583                                  
 23584                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 20C0h
 23585                                  
 23586                                  ; =============== S U B	R O U T	I N E =======================================
 23587                                  
 23588                                  DATE_CXDX:
 23589                                  	mov	bx,cx
 23590                                  
 23591                                  ; =============== S U B	R O U T	I N E =======================================
 23592                                  
 23593                                  P_DATE:
 23594                                  	mov	ax,bx
 23595                                  	mov	cx,dx
 23596                                  	mov	dl,100
 23597                                  	div	dl
 23598                                  	xchg	al,ah
 23599                                  	xchg	ax,dx
 23600                                  	mov	bh,'0'-' ' ; 10h  ; Enable leading zero suppression
 23601                                  	;mov	ax,[INTERNATVARS]
 23602                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23603                                  	or	ax,ax
 23604                                  	jz	short USPDAT
 23605                                  	dec	ax
 23606                                  	jz	short EUPDAT
 23607                                  	mov	bh,0	 ; Disable leading zero suppression	
 23608                                  	call	P_YR
 23609                                  	call	P_DSEP
 23610                                  	call	P_MON
 23611                                  	call	P_DSEP
 23612                                  	call	P_DAY
 23613                                  	retn
 23614                                  
 23615                                  USPDAT:
 23616                                  	call	P_MON
 23617                                  	call	P_DSEP
 23618                                  	call	P_DAY
 23619                                  PLST:
 23620                                  	call	P_DSEP
 23621                                  	call	P_YR
 23622                                  	retn
 23623                                  
 23624                                  EUPDAT:
 23625                                  	call	P_DAY
 23626                                  	call	P_DSEP
 23627                                  	call	P_MON
 23628                                  	jmp	short PLST
 23629                                  
 23630                                  ; ---------------------------------------------------------------------------
 23631                                  
 23632                                  P_MON:
 23633                                  	mov	al,ch
 23634                                  	call	OUT2
 23635                                  	retn
 23636                                  
 23637                                  ; ---------------------------------------------------------------------------
 23638                                  
 23639                                  P_DSEP:
 23640                                  	;mov	al,[DATE_SEP] ; INTERNATVARS+11
 23641                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Date_sep]
 23642                                  	stosb
 23643                                  	retn
 23644                                  
 23645                                  ; ---------------------------------------------------------------------------
 23646                                  
 23647                                  P_DAY:
 23648                                  	mov	al,cl
 23649                                  	call	OUT2
 23650                                  	retn
 23651                                  
 23652                                  ; ---------------------------------------------------------------------------
 23653                                  
 23654                                  P_YR:
 23655                                  	mov	al,dh
 23656                                  	or	al,al
 23657                                  	jz	short TWODIGYR	; Two instead of 4 digit year
 23658                                  	call	OUT2
 23659                                  TWODIGYR:
 23660                                  	mov	al,dl
 23661                                  	call	OUT2
 23662                                  DATE_RETN:
 23663                                  	retn
 23664                                  
 23665                                  ; =============== S U B	R O U T	I N E =======================================
 23666                                  
 23667                                  DATE:				 ; Accepting argument for date inline
 23668                                  	mov	si,81h
 23669                                  	call	SCANOFF
 23670                                  	cmp	al,0Dh
 23671                                  	jz	short PRMTDAT
 23672                                  	jmp	short COMDAT
 23673                                  
 23674                                  	;nop
 23675                                  PRMTDAT:
 23676                                  	; MSDOS 3.3
 23677                                  	mov	dx,CURDATPTR
 23678                                  	call	STD_PRINTF	; Print "Current date is "	
 23679                                  	call	PRINT_DATE
 23680                                  GETDAT:	
 23681                                  	mov	dx,NEWDATPTR
 23682                                  	call	STD_PRINTF	 ; Print "Enter new date: "
 23683                                  
 23684                                  	mov	ax,INTERNATIONAL*256 ; 3800h 
 23685                                  				; Determine what format the date
 23686                                  	mov	dx,5Ch		;  should be entered in and
 23687                                  	int	21h	; DOS -	2+ - GET COUNTRY-DEPENDENT INFORMATION
 23688                                  			; get current-country info
 23689                                  			; DS:DX	-> buffer for returned info
 23690                                  	mov	si,dx		;  print a message describing it
 23691                                  	lodsw
 23692                                  	mov	dx,USADATPTR	; get mm-dd-yy
 23693                                  	dec	ax
 23694                                  	js	short PRINTFORMAT
 23695                                  	mov	dx,EURDATPTR	; get dd-mm-yy
 23696                                  	jz	short PRINTFORMAT
 23697                                  	mov	dx,JAPDATPTR	; get yy-mm-dd
 23698                                  PRINTFORMAT:
 23699                                  	call	STD_PRINTF
 23700                                  	mov	ah,Std_Con_String_Input	; 0Ah
 23701                                  	mov	dx,COMBUF
 23702                                  	mov	cx,INITSPECIAL ;2 ; Set bit in InitFlag that indicate
 23703                                  	call	SETINITFLAG	;  prompting for date.
 23704                                  	int	21h		; Get input line
 23705                                  	xor	cx,cx		; Reset bit in InitFlag that indicates
 23706                                  	call	SETINITFLAG	;  prompting for date.
 23707                                  	call	CRLF2
 23708                                  	mov	si,COMBUF+2
 23709                                  	cmp	byte [si],0Dh
 23710                                  	jz	short DATE_RETN
 23711                                  COMDAT:
 23712                                  	;mov	ax,[INTERNATVARS]
 23713                                  	mov	ax,[INTERNATVARS+INTERNAT_BLOCK.Date_tim_format]
 23714                                  	or	ax,ax
 23715                                  	jz	short USSDAT
 23716                                  	dec	ax
 23717                                  	jz	short EUSDAT
 23718                                  	call	GET_YR
 23719                                  	jc	short DATERRJ
 23720                                  	call	GET_DSEP
 23721                                  	jc	short DATERRJ
 23722                                  	call	GET_MON
 23723                                  	jc	short DATERRJ
 23724                                  	call	GET_DSEP
 23725                                  	jc	short DATERRJ
 23726                                  	call	GET_DAY
 23727                                  DAT_SET:
 23728                                  	jnc	short DATSET
 23729                                  	jmp	DATERR
 23730                                  
 23731                                  ; ---------------------------------------------------------------------------
 23732                                  
 23733                                  DATSET:
 23734                                  	lodsb
 23735                                  	cmp	al,' '
 23736                                  	jz	short DATSET
 23737                                  	cmp	al,9
 23738                                  	jz	short DATSET
 23739                                  	cmp	al,0Dh
 23740                                  	jnz	short DATERR
 23741                                  	mov	ah,SET_DATE ; 2Bh
 23742                                  	int	21h	; DOS -	SET CURRENT DATE
 23743                                  			; DL = day,DH = month,	CX = year
 23744                                  			; Return: AL = 00h if no error 
 23745                                  			; 	     = FFh if bad value sent to routine
 23746                                  	or	al,al
 23747                                  	jnz	short DATERR
 23748                                  DAT_SET_RETN:
 23749                                  	retn
 23750                                  
 23751                                  ; ---------------------------------------------------------------------------
 23752                                  
 23753                                  USSDAT:
 23754                                  	call	GET_MON
 23755                                  	jb	short DATERR
 23756                                  	call	GET_DSEP
 23757                                  DATERRJ:
 23758                                  	jc	short DATERR
 23759                                  	call	GET_DAY
 23760                                  TGET:
 23761                                  	jc	short DATERR
 23762                                  	call	GET_DSEP
 23763                                  	jc	short DATERR
 23764                                  	call	GET_YR
 23765                                  	jmp	short DAT_SET
 23766                                  
 23767                                  ; ---------------------------------------------------------------------------
 23768                                  
 23769                                  EUSDAT:
 23770                                  	call	GET_DAY
 23771                                  	jc	short DATERR
 23772                                  	call	GET_DSEP
 23773                                  	jc	short DATERR
 23774                                  	call	GET_MON
 23775                                  	jmp	short TGET
 23776                                  
 23777                                  ; =============== S U B	R O U T	I N E =======================================
 23778                                  
 23779                                  GET_MON:
 23780                                  	call	GETNUM		; Get one or two digit number
 23781                                  	jc	short DAT_SET_RETN
 23782                                  	mov	dh,ah		; Put in position
 23783                                  	retn
 23784                                  
 23785                                  
 23786                                  ; =============== S U B	R O U T	I N E =======================================
 23787                                  
 23788                                  GET_DAY:
 23789                                  		call	GETNUM
 23790                                  		mov	dl,ah		; Put in position
 23791                                  GET_DAY_RETN:
 23792                                  		retn
 23793                                  
 23794                                  ; =============== S U B	R O U T	I N E =======================================
 23795                                  
 23796                                  GET_YR:
 23797                                  	call	GETNUM
 23798                                  	jc	short GET_DAY_RETN
 23799                                  	mov	cx,1900
 23800                                  	call	GET_DSEP
 23801                                  	pushf
 23802                                  	dec	si
 23803                                  	popf
 23804                                  	jz	short BIAS
 23805                                  	cmp	byte [si],0Dh
 23806                                  	je	short BIAS
 23807                                  	cmp	byte [si],' '
 23808                                  	je	short BIAS
 23809                                  	cmp	byte [si],9
 23810                                  	je	short BIAS
 23811                                  	push	bx
 23812                                  	mov	bl,100
 23813                                  	mov	al,ah
 23814                                  	mul	bl
 23815                                  	pop	bx
 23816                                  	mov	cx,ax
 23817                                  	call	GETNUM
 23818                                  	jc	short GET_DAY_RETN
 23819                                  BIAS:
 23820                                  	mov	al,ah
 23821                                  	mov	ah,0
 23822                                  	add	cx,ax
 23823                                  BIAS_RETN:
 23824                                  	retn
 23825                                  
 23826                                  ; ---------------------------------------------------------------------------
 23827                                  
 23828                                  DATERR:
 23829                                  	mov	dx,BADDATPTR
 23830                                  	call	STD_PRINTF
 23831                                  	jmp	GETDAT
 23832                                  
 23833                                  ; =============== S U B	R O U T	I N E =======================================
 23834                                  
 23835                                  GET_DSEP:
 23836                                  	lodsb
 23837                                  	cmp	al,'/'
 23838                                  	je	short BIAS_RETN
 23839                                  	;cmp	al,'.'
 23840                                  	cmp	al,[DOT_CHR]
 23841                                  	je	short BIAS_RETN
 23842                                  	;cmp	al,'-'
 23843                                  	cmp	al,[CHAR_SUB]
 23844                                  	je	short BIAS_RETN
 23845                                  	stc
 23846                                  	retn
 23847                                  
 23848                                  ; =============== S U B	R O U T	I N E =======================================
 23849                                  
 23850                                  ; TIME gets and sets the time
 23851                                  
 23852                                  CTIME:
 23853                                  	mov	si,81h		; Accepting argument for time inline
 23854                                  	call	SCANOFF
 23855                                  	cmp	al,0Dh
 23856                                  	je	short PRMTTIM
 23857                                  	mov	bx,2E3Ah ; ":."
 23858                                  	call	INLINE
 23859                                  	jmp	COMTIM
 23860                                  
 23861                                  ; =============== S U B	R O U T	I N E =======================================
 23862                                  
 23863                                  PRINT_TIME:
 23864                                  	mov	ah,Get_Time ; 2Ch ; Get time in CX:DX
 23865                                  	int	21h	; DOS -	GET CURRENT TIME
 23866                                  			; Return: CH = hours,CL = minutes,DH = seconds
 23867                                  			; DL = hundredths of seconds
 23868                                  	push	di
 23869                                  	push	es
 23870                                  	push	cs
 23871                                  	pop	es
 23872                                  	mov	di,CHARBUF
 23873                                  	mov	bl,1	; Always 24 hour time
 23874                                  	call	P_TIME
 23875                                  	xor	ax,ax
 23876                                  	stosb
 23877                                  	mov	dx,CHARBUF
 23878                                  	mov	[STRING_PTR_2],dx
 23879                                  	mov	dx,STRINGBUF2PTR
 23880                                  	call	STD_PRINTF
 23881                                  	pop	es
 23882                                  	pop	di
 23883                                  P_TIME_RETN:
 23884                                  	retn
 23885                                  
 23886                                  ; =============== S U B	R O U T	I N E =======================================
 23887                                  
 23888                                  P_TIME:
 23889                                  	mov	al,ch	
 23890                                  	test	bl,7Fh		; Ignore high bit
 23891                                  	jnz	short T24	; 24 hr time?
 23892                                  	mov	bh,'a'		; Assume A.M.
 23893                                  	cmp	al,12		; In the afternoon?
 23894                                  	jb	short MORN
 23895                                  	mov	bh,'p'
 23896                                  	jz	short MORN
 23897                                  	sub	al,12		; Keep it to 12 hours or less
 23898                                  MORN:
 23899                                  	or	al,al		; Before 1 am?
 23900                                  	jnz	short T24
 23901                                  	mov	al,12
 23902                                  T24:
 23903                                  	push	bx
 23904                                  	mov	bh,'0'-' ' ; 10h ; Enable leading zero suppression
 23905                                  	call	OUT2
 23906                                  	call	P_TSEP
 23907                                  	mov	al,cl
 23908                                  	call	OUT2
 23909                                  	pop	bx
 23910                                  	push	bx
 23911                                  	test	bl,80h
 23912                                  	jnz	short PAP	; If from DIR, go directly to am pm
 23913                                  	mov	bh,0		; Disable leading zero suppression
 23914                                  	call	P_TSEP
 23915                                  	mov	al,dh
 23916                                  	call	OUT2
 23917                                  	;mov	al,'.'
 23918                                  	mov	al,[DECIMAL_SEP]
 23919                                  	stosb
 23920                                  	mov	al,dl
 23921                                  	call	OUT2
 23922                                  PAP:
 23923                                  	pop	bx
 23924                                  	test	bl,7Fh		; Ignore high bit
 23925                                  	jnz	short P_TIME_RETN
 23926                                  	mov	al,bh
 23927                                  	stosb
 23928                                  	retn
 23929                                  
 23930                                  ; =============== S U B	R O U T	I N E =======================================
 23931                                  
 23932                                  P_TSEP:
 23933                                  	;mov	al,[TIME_SEP]
 23934                                  	mov	al,[INTERNATVARS+INTERNAT_BLOCK.Time_sep]
 23935                                  	stosb
 23936                                  P_TSEP_RETN:
 23937                                  	retn
 23938                                  
 23939                                  ; ---------------------------------------------------------------------------
 23940                                  
 23941                                  PRMTTIM:
 23942                                  	mov	dx,CURTIMPTR
 23943                                  	call	STD_PRINTF	; Print "Current time is "
 23944                                  	call	PRINT_TIME
 23945                                  GETTIM:
 23946                                  	xor	cx,cx		; Initialize hours and minutes to zero
 23947                                  	mov	dx,NEWTIMPTR
 23948                                  	call	STD_PRINTF
 23949                                  	;mov	bx,':.'
 23950                                  	mov	bx,[TIMECHARS] 
 23951                                  	call	GETBUF
 23952                                  COMTIM:
 23953                                  	jz	short P_TSEP_RETN ; If no time present, don't change it	
 23954                                  	jc	short TIMEERR
 23955                                  	mov	cx,dx
 23956                                  	xor	dx,dx
 23957                                  	lodsb
 23958                                  	cmp	al,0Dh
 23959                                  	je	short SAVTIM
 23960                                  	cmp	al,' '
 23961                                  	je	short GOTSEC2
 23962                                  	cmp	al,9
 23963                                  	je	short GOTSEC2
 23964                                  	cmp	al,bl
 23965                                  	je	short GOTSEC
 23966                                  	cmp	al,bh
 23967                                  	jne	short TIMEERR
 23968                                  GOTSEC:
 23969                                  	call	GETNUM
 23970                                  	jc	short TIMEERR
 23971                                  	mov	dh,ah		; Position seconds
 23972                                  	lodsb
 23973                                  	cmp	al,0Dh
 23974                                  	je	short SAVTIM
 23975                                  	cmp	al,' '
 23976                                  	je	short GOTSEC2
 23977                                  	cmp	al,9
 23978                                  	je	short GOTSEC2
 23979                                  	;cmp	al,'.'
 23980                                  	cmp	al,[DECIMAL_SEP]
 23981                                  	jne	short TIMEERR
 23982                                  	call	GETNUM
 23983                                  	jc	short TIMEERR
 23984                                  	mov	dl,ah
 23985                                  GOTSEC2:
 23986                                  	lodsb
 23987                                  	cmp	al,' '
 23988                                  	je	short GOTSEC2
 23989                                  	cmp	al,9
 23990                                  	je	short GOTSEC2
 23991                                  	cmp	al,0Dh
 23992                                  	jne	short TIMEERR
 23993                                  SAVTIM:
 23994                                  	mov	ah,SET_TIME ; 2Dh
 23995                                  	int	21h	; DOS -	SET CURRENT TIME
 23996                                  			; CH = hours,CL = minutes,DH = seconds,
 23997                                  			;		DL = hundredths of seconds
 23998                                  			; Return: AL = 00h if no error 
 23999                                  			;	     = FFh if bad value sent to routine
 24000                                  	or	al,al
 24001                                  P_TSEP_JRETN:
 24002                                  	jz	short P_TSEP_RETN ; Error in time?
 24003                                  TIMEERR:
 24004                                  	mov	dx,BADTIMPTR
 24005                                  	call	STD_PRINTF	; Print "Enter new time: "
 24006                                  	jmp	short GETTIM
 24007                                  
 24008                                  ; =============== S U B	R O U T	I N E =======================================
 24009                                  
 24010                                  GETBUF:
 24011                                  	mov	ah,Std_Con_String_Input ; 0Ah
 24012                                  	mov	dx,COMBUF
 24013                                  	mov	cx,2
 24014                                  	call	SETINITFLAG
 24015                                  	int	21h		; Get input line
 24016                                  	xor	cx,cx
 24017                                  	call	SETINITFLAG
 24018                                  	call	CRLF2
 24019                                  	mov	si,COMBUF+2
 24020                                  	cmp	byte [si],0Dh	; Check if new time entered
 24021                                  	jz	short P_TSEP_JRETN
 24022                                  
 24023                                  ; =============== S U B	R O U T	I N E =======================================
 24024                                  
 24025                                  INLINE:
 24026                                  	call	GETNUM		; Get one or two digit number
 24027                                  	jnb	short INLINE1
 24028                                  	retn
 24029                                  INLINE1:
 24030                                  	mov	dh,ah		; Put in position
 24031                                  	lodsb
 24032                                  	cmp	al,bl
 24033                                  	jz	short NEXT
 24034                                  	cmp	al,bh
 24035                                  	jz	short NEXT
 24036                                  	dec	si		; Clears zero flag
 24037                                  	clc
 24038                                  	mov	dl,0
 24039                                  	retn			; Time may have only an hour specified
 24040                                  NEXT:
 24041                                  	call	GETNUM
 24042                                  	mov	dl,ah		; Put in position
 24043                                  INLINE_RETN:
 24044                                  	retn
 24045                                  
 24046                                  ;============================================================================
 24047                                  ; TCODE5.ASM, MSDOS 2.11 (& MSDOS 3.3), 1983 (& 1987)
 24048                                  ;============================================================================
 24049                                  ; 05/10/2018 - Retro DOS v3.0
 24050                                  
 24051                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2370h
 24052                                  
 24053                                  ; =============== S U B	R O U T	I N E =======================================
 24054                                  
 24055                                  GETNUM:
 24056                                  	call	INDIG
 24057                                  	jb	short INLINE_RETN
 24058                                  	mov	ah,al		; Save first digit
 24059                                  	call	INDIG		; Another digit?
 24060                                  	jb	short OKRET
 24061                                  	aad			; Convert unpacked BCD to decimal
 24062                                  	mov	ah,al
 24063                                  OKRET:
 24064                                  	or	al,1
 24065                                  GETNUM_RETN:
 24066                                  	retn
 24067                                  
 24068                                  ; =============== S U B	R O U T	I N E =======================================
 24069                                  
 24070                                  INDIG:
 24071                                  	mov	al,[si]
 24072                                  	sub	al,'0'
 24073                                  	jc	short GETNUM_RETN
 24074                                  	cmp	al,10
 24075                                  	cmc
 24076                                  	jc	short GETNUM_RETN
 24077                                  	inc	si
 24078                                  	retn
 24079                                  
 24080                                  ; =============== S U B	R O U T	I N E =======================================
 24081                                  
 24082                                  OUT2:				; Output binary number as two ASCII digits
 24083                                  	aam			; Convert binary to unpacked BCD
 24084                                  	xchg	al,ah
 24085                                  	or	ax,3030h	; Add "0" bias to both digits
 24086                                  	cmp	al,'0'		; Is MSD zero?
 24087                                  	jnz	short NOSUP
 24088                                  	sub	al,bh		; Suppress leading zero if enabled
 24089                                  NOSUP:
 24090                                  	mov	bh,0		; Disable zero suppression
 24091                                  	stosw
 24092                                  	retn
 24093                                  
 24094                                  ; ---------------------------------------------------------------------------
 24095                                  	;stosb
 24096                                  	;retn
 24097                                  
 24098                                  ;============================================================================
 24099                                  ; TPIPE.ASM, MSDOS 6.0, 1991
 24100                                  ;============================================================================
 24101                                  ; 03/10/2018 - Retro DOS v3.0
 24102                                  
 24103                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23A3h
 24104                                  
 24105                                  ; =============== S U B	R O U T	I N E =======================================
 24106                                  
 24107                                  ; Set the special flag in the INIT flag to the value in CX.
 24108                                  
 24109                                  SETINITFLAG:
 24110                                  	mov	ds,[RESSEG]
 24111                                  	;and	byte [INITFLAG],0FDh
 24112                                  	and	byte [INITFLAG],~INITSPECIAL
 24113                                  	or	byte [INITFLAG],cl
 24114                                  	push	cs
 24115                                  	pop	ds
 24116                                  	retn
 24117                                  
 24118                                  ; =============== S U B	R O U T	I N E =======================================
 24119                                  
 24120                                  PIPEOFF:
 24121                                  	push	ds
 24122                                  	push	ax
 24123                                  	mov	ds,[cs:RESSEG]
 24124                                  	xor	al,al
 24125                                  	xchg	al,byte [PIPEFLAG]
 24126                                  	or	al,al
 24127                                  	jz	short PIPEOFFDONE
 24128                                  	shr	byte [ECHOFLAG],1
 24129                                  PIPEOFFDONE:
 24130                                  	pop	ax
 24131                                  	pop	ds
 24132                                  	retn
 24133                                  
 24134                                  ; ---------------------------------------------------------------------------
 24135                                  	;db    0,0,0,0,0
 24136                                  	;times 5 db 0
 24137                                  
 24138                                  align 16
 24139                                  
 24140                                  %endif
 24141                                  
 24142                                  ;============================================================================
 24143                                  ; PARSE2.ASM, MSDOS 6.0, 1991
 24144                                  ;============================================================================
 24145                                  ; 03/10/2018 - Retro DOS v3.0
 24146                                  
 24147                                  ;----------------------------------------------------------------------------
 24148                                  ; PARSELINE takes an MSDOS command line and maps it into a UNIX-style
 24149                                  ; argv[argvcnt] array. The most important difference between this array and
 24150                                  ; the tradition UNIX format is the extra cparse information included with
 24151                                  ; each argument element.
 24152                                  ;---------------
 24153                                  ; ENTRY:
 24154                                  ;	BL	     special delimiter for cparse -- not implemented)
 24155                                  ;---------------
 24156                                  ; EXIT:
 24157                                  ;	CF	    set if error
 24158                                  ;	AL	    error code (carry set). Note AH clobbered in any event.
 24159                                  ;	argv[]	    array of cparse flags and pointers to arguments
 24160                                  ;	argvcnt     argument count
 24161                                  ;---------------
 24162                                  ; NOTE(S):
 24163                                  ;	*   BL (special delimiter) is ignored, for now (set to space).
 24164                                  ;	*   Parseflags record contains cparse flags, as follows:
 24165                                  ;		sw_flag 	--	was this arg a switch?
 24166                                  ;		wildcard	--	whether or not it contained a * or ?
 24167                                  ;		path_sep	--	maybe it was a pathname
 24168                                  ;		unused		--	for future expansion
 24169                                  ;		special_delim	--	was there an initial special delimiter?
 24170                                  ;	*   argv[] and argvcnt are undefined if CF/AL indicates an error.
 24171                                  ;	*   Relationship between input, cparse output, and comtail can be
 24172                                  ;	    found in the following chart. Despite the claim of the cparse
 24173                                  ;	    documentation that, "Token buffer always starts d: for non switch
 24174                                  ;	    tokens", such is not the case (see column two, row two).
 24175                                  ;	    Similarly, [STARTEL] is not null when the command line is one of
 24176                                  ;	    the forms, "d:", "d:\", or "d:/". In fact, *STARTEL (i.e., what
 24177                                  ;	    STARTEL addresses) will be null. This is clearly just a
 24178                                  ;	    documentation error.
 24179                                  ;	*   cparse also returns a switch code in BP for each switch it
 24180                                  ;	    recognizes on the command line.
 24181                                  ;	*   arglen for each token does NOT include the terminating null.
 24182                                  ;	*   Finally, note that interesting constructions like 'foodir/*.exe'
 24183                                  ;	    parse as three separate tokens, and the asterisk is NOT a wildcard.
 24184                                  ;	    For example, 'for %i in (foodir/*.exe) do echo %i' will first
 24185                                  ;	    echo 'foodir', then '*', then '.exe'. Using cparse for command-
 24186                                  ;	    line parsing may result in slightly different behavior than
 24187                                  ;	    previously observed with the old COMMAND.COM command-line parser.
 24188                                  ;
 24189                                  ;	    Input		    Cparse		Command Line (80H)
 24190                                  ;	\alan\foo.bat		c:\alan\foo.bat 	\alan\foo.bat
 24191                                  ;	alan\foo.bat		alan\foo.bat		alan\foo.bat
 24192                                  ;	foo.bat 		foo.bat 		foo.bat
 24193                                  ;	c:\alan\foo.bat 	c:\alan\foo.bat 	c:\alan\foo.bat
 24194                                  ;	c:alan\foo.bat		c:alan\foo.bat		c:alan\foo.bat
 24195                                  ;	c:foo.bat		c:foo.bat		c:foo.bat
 24196                                  
 24197                                  ; =============== S U B	R O U T	I N E =======================================
 24198                                  
 24199                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 23D0h
 24200                                  
 24201                                  ; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24202                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 319Bh
 24203                                  
 24204                                  PARSELINE:
 24205 00003030 50                      	push	ax			; most of these are clobbered
 24206 00003031 53                      	push	bx			; by cparse...
 24207 00003032 51                      	push	cx
 24208 00003033 52                      	push	dx
 24209 00003034 57                      	push	di
 24210 00003035 56                      	push	si
 24211 00003036 9C                      	pushf
 24212 00003037 C606[908C]00            	mov	byte [cpyflag],0  ; Turn "CPARSE called from COPY flag" off
 24213 0000303C C706[F193]FFFF          	mov	word [LASTARG],-1 ; last argument at which to accumulate
 24214 00003042 31C0                    	xor	ax,ax
 24215                                  	;mov	cx,1348
 24216 00003044 B94405                  	mov	cx,ARG_UNIT.SIZE
 24217 00003047 BF[2B8E]                	mov	di,ARG
 24218 0000304A F3AA                    	rep	stosb
 24219                                  	;mov	word [ARGBUF_PTR],ARG_ARGBUF
 24220 0000304C C706[6F93][EF90]        	mov	word [ARGBUF_PTR],ARG+ARG_UNIT.argbuf
 24221                                  	;mov	word [ARG_ARGSWINFO],0 ; switch information, and info to date
 24222 00003052 C706[ED90]0000          	mov	word [ARG+ARG_UNIT.argswinfo],0
 24223                                  	;mov	word [ARG_ARGVCNT],0 ; initialize argvcnt/argv[]
 24224 00003058 C706[EB90]0000          	mov	word [ARG+ARG_UNIT.argvcnt],0
 24225 0000305E BE[FD88]                	mov	si,COMBUF+2	; prescan leaves cooked input in combuf
 24226                                  
 24227                                  ; This next section of code (up to pcont:)  makes sure that si is set up for
 24228                                  ; parsing. It should point at COMBUF if FORFLAG is set and arg.argforcombuf
 24229                                  ; otherwise. This is done so that commands can get arg pointers into their
 24230                                  ; original command line (or an exact copy of it) in arg_ocomptr.
 24231                                  ; Arg.argforcombuf is used so that the for loop processor will always be able
 24232                                  ; to get a hold of its original command line; even after COMBUF is blasted by
 24233                                  ; the command to be repeated or the transient part of command has been
 24234                                  ; reloaded.
 24235                                  
 24236 00003061 1E                      	push	ds
 24237 00003062 8E1E[9C8A]              	mov	ds,[RESSEG]
 24238 00003066 803E[AC01]00            	cmp	byte [ForFlag],0
 24239 0000306B 1F                      	pop	ds
 24240 0000306C 7510                    	jnz	short PCONT
 24241                                  	;mov	di,ARG_ARGFORCOMBUF
 24242 0000306E BF[EF92]                	mov	di,ARG+ARG_UNIT.argforcombuf 
 24243 00003071 30ED                    	xor	ch,ch
 24244 00003073 8A0E[FC88]              	mov	cl,[COMBUF+1]
 24245 00003077 FEC1                    	inc	cl
 24246 00003079 F3A4                    	rep	movsb
 24247                                  	;mov	si,ARG_ARGFORCOMBUF
 24248 0000307B BE[EF92]                	mov	si,ARG+ARG_UNIT.argforcombuf 
 24249                                  PCONT:
 24250 0000307E BF[7193]                	mov	di,TPBUF	; destination is temporary token buffer	
 24251 00003081 B320                    	mov	bl,' '		; no special delimiter, for now
 24252                                  PARSELOOP:
 24253 00003083 8936[F393]              	mov	[COMPTR],si	; save ptr into original command buffer
 24254 00003087 31ED                    	xor	bp,bp		; switch information put here by cparse
 24255 00003089 C606[0D8E]00            	mov	byte [expand_star],0 ; don't expand *'s to ?'s
 24256 0000308E E846F5                  	call	scanoff		; skip leading blanks...
 24257 00003091 E8D710                  	call	cparse		; byte off a token (args in SI, DI, BL)
 24258 00003094 730B                    	jnb	short MORE_PRSE
 24259 00003096 09ED                    	or	bp,bp		; Check for trailing switch character
 24260 00003098 7403                    	jz	short PARSEDONE
 24261 0000309A E81700                  	call	newarg		; We hit CR but BP is non-zero. The
 24262                                  				;   typical cause of this is that a
 24263                                  				;   switch char IMMEDIATELY preceeds
 24264                                  				;   the CR. We have an argument, but it
 24265                                  				;   is sort of an error.
 24266                                  	;jmp	short PARSEDONE	; We're done (found the CR).
 24267                                  	; 01/03/2023
 24268                                  PARSEDONE:
 24269 0000309D 9D                      	popf
 24270 0000309E F8                      	clc
 24271 0000309F EB0C                    	jmp	short PARSE_EXIT
 24272                                  
 24273                                  MORE_PRSE:
 24274 000030A1 C606[908C]02            	mov	byte [cpyflag],2
 24275                                  				; tell CPARSE that 1st token is done
 24276 000030A6 E80B00                  	call	newarg		; add to argv array (CX has char count)
 24277 000030A9 73D8                    	jnb	short PARSELOOP	; was everything OK?
 24278                                  	;jmp	short PARSE_ERROR ; NO, it wasn't -- bug out (CF set)
 24279                                  	; 01/03/2023
 24280                                  ;PARSEDONE:
 24281                                  	;popf
 24282                                  	;clc
 24283                                  	;jmp	short PARSE_EXIT
 24284                                  
 24285                                  PARSE_ERROR:			; error entry (er, exit) point
 24286 000030AB 9D                      	popf
 24287 000030AC F9                      	stc
 24288                                  PARSE_EXIT:			; depend on not changing CF
 24289 000030AD 5E                      	pop	si
 24290 000030AE 5F                      	pop	di
 24291 000030AF 5A                      	pop	dx
 24292 000030B0 59                      	pop	cx
 24293 000030B1 5B                      	pop	bx
 24294 000030B2 58                      	pop	ax
 24295 000030B3 C3                      	retn
 24296                                  
 24297                                  ; =============== S U B	R O U T	I N E =======================================
 24298                                  
 24299                                  ; NEWARG adds the supplied argstring and cparse data to arg.argv[].
 24300                                  ;
 24301                                  ; ENTRY:
 24302                                  ;   BH			argflags
 24303                                  ;   CX			character count in argstring
 24304                                  ;   DI			pointer to argstring
 24305                                  ;   comptr		ptr to starting loc of current token in original command
 24306                                  ;   [STARTEL]		cparse's answer to where the last element starts
 24307                                  ; EXIT:
 24308                                  ;   argbufptr		points to next free section of argbuffer
 24309                                  ;   arg.argbuf		contains null-terminated argument strings
 24310                                  ;   arg.argvcnt 	argument count
 24311                                  ;   arg.argv[]		array of flags and pointers
 24312                                  ;   arg.arg_ocomptr	ptr to starting loc of current token in original command
 24313                                  ;   CF			set if error
 24314                                  ;   AL			carry set:  error code; otherwise, zero
 24315                                  
 24316                                  	; 01/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24317                                  newarg:
 24318 000030B4 53                      	push	bx
 24319 000030B5 51                      	push	cx
 24320 000030B6 52                      	push	dx
 24321 000030B7 57                      	push	di
 24322 000030B8 56                      	push	si
 24323 000030B9 9C                      	pushf
 24324 000030BA E86600                  	call	arg_switch		; if it's a switch, record switch info
 24325                                  					; LEAVE SWITCH ON COMMAND LINE!!
 24326                                  	;;;jc	short newarg_done 	; previous arg's switches -- and leave
 24327                                  
 24328                                  	;cmp	word [ARG_ARGVCNT],64	; check to ensure we've not
 24329 000030BD 833E[EB90]40            	cmp	word [ARG+ARG_UNIT.argvcnt],ARGMAX ; 64
 24330 000030C2 7D4F                    	jge	short to_many_args	; exceeded array limits
 24331 000030C4 88FE                    	mov	dh,bh			
 24332                                  	;mov	bx,[ARG_ARGVCNT]	; save argflags	
 24333 000030C6 8B1E[EB90]              	mov	bx,[ARG+ARG_UNIT.argvcnt] ; argv[argvcnt++] = arg data
 24334                                  	;inc	word [ARG_ARGVCNT]
 24335 000030CA FF06[EB90]              	inc	word [ARG+ARG_UNIT.argvcnt]
 24336                                  	;mov	ax,ARG_ARGV
 24337 000030CE B8[2B8E]                	mov	ax,ARG+ARG_UNIT.argv
 24338 000030D1 E88200                  	call	argv_calc		; convert offset to pointer
 24339                                  	;mov	[BX].argsw_word,0 	; no switch information, yet...
 24340                                  	;mov	word [bx+7],0
 24341 000030D4 C747070000              	mov	word [bx+ARGV_ELE.argsw_word],0
 24342                                  	;mov	[BX].arglen,CX		; argv[argvcnt].arglen = arg length
 24343                                  	;mov	[bx+5],cx
 24344 000030D9 894F05                  	mov	[bx+ARGV_ELE.arglen],cx 
 24345                                  	;mov	[BX].argflags,DH 	; argv[argvcnt].argflags = cparse flags
 24346                                  	;mov	[bx+2],dh
 24347 000030DC 887702                  	mov	[bx+ARGV_ELE.argflags],dh
 24348 000030DF 8B36[6F93]              	mov	si,[ARGBUF_PTR]
 24349                                  	;mov	[BX].argpointer,SI 	; argv[argvcnt].argpointer = [argbufptr]
 24350                                  	;mov	[bx+ARGV_ELE.argpointer],si
 24351 000030E3 8937                    	mov	[bx],si			
 24352 000030E5 0336[D28D]              	add	si,[STARTEL]		; save startel from new location
 24353 000030E9 29FE                    	sub	si,di			; form pointer into argbuf
 24354                                  	;mov	[BX].argstartel,SI ; argv[argvcnt].argstartel = new [STARTEL]
 24355                                  	;mov	[bx+3],si
 24356 000030EB 897703                  	mov	[bx+ARGV_ELE.argstartel],si
 24357 000030EE 8B36[F393]              	mov	si,[COMPTR]
 24358                                  	;mov	[BX].arg_ocomptr,si ; arg_ocomptr = ptr into original com line
 24359                                  	;mov	[bx+9],si
 24360 000030F2 897709                  	mov	[bx+ARGV_ELE.arg_ocomptr],si
 24361 000030F5 89FE                    	mov	si,di			; now save argstring in argbuffer
 24362 000030F7 8B3E[6F93]              	mov	di,[ARGBUF_PTR]		; load the argbuf pointer and make
 24363 000030FB 01CF                    	add	di,cx			; sure we're not about to run off
 24364                                  	;cmp	DI,OFFSET TRANGROUP:arg.argbuf+ARGBLEN-1
 24365                                  	;cmp	di,ARG_ARGBUF+255
 24366 000030FD 81FF[EE91]              	cmp	di,ARG+ARG_UNIT.argbuf+ARGBLEN-1
 24367 00003101 7D15                    	jge	short buf_oflow		; the end of the buffer (plus null byte)	
 24368 00003103 29CF                    	sub	di,cx
 24369 00003105 FC                      	cld
 24370 00003106 F3A4                    	rep	movsb
 24371 00003108 B000                    	mov	al,ANULL ; 0		; tack a null byte on the end
 24372 0000310A AA                      	stosb
 24373 0000310B 893E[6F93]              	mov	[ARGBUF_PTR],di		; update argbufptr after copy
 24374                                  newarg_done:
 24375 0000310F 9D                      	popf
 24376 00003110 F8                      	clc
 24377 00003111 EB0A                    	jmp	short newarg_exit
 24378                                  to_many_args:
 24379 00003113 B80100                  	mov	ax,1
 24380 00003116 EB03                    	jmp	short newarg_error
 24381                                  buf_oflow:
 24382 00003118 B80200                  	mov	ax,2
 24383                                  newarg_error:
 24384 0000311B 9D                      	popf
 24385 0000311C F9                      	stc
 24386                                  newarg_exit:
 24387 0000311D 5E                      	pop	si
 24388 0000311E 5F                      	pop	di
 24389 0000311F 5A                      	pop	dx
 24390 00003120 59                      	pop	cx
 24391 00003121 5B                      	pop	bx
 24392 00003122 C3                      	retn
 24393                                  
 24394                                  ; =============== S U B	R O U T	I N E =======================================
 24395                                  
 24396                                  ; ARG_SWITCH decides if an argument might really be a switch. In the
 24397                                  ; event that it is, and we can recognize
 24398                                  ;
 24399                                  ; ENTRY:
 24400                                  ;   As in <newarg>.
 24401                                  ; EXIT:
 24402                                  ;   CF	    --	    clear (wasn't a switch); set (was a switch)
 24403                                  ; NOTE(S):
 24404                                  ;   *	The mechanism mapping a switch into a bit-value depends entirely
 24405                                  ;	on the order of definition in the <switch_list> variable and the
 24406                                  ;	values chosen to define the bits in CMDT:COMEQU.ASM. Change either
 24407                                  ;	<switch_list> or the definitions in CMDT:COMEQU.ASM -- and rewrite
 24408                                  ;	this mechanism. This code taken from CMDT:TCODE.ASM.
 24409                                  ;   *	The <switch_list> declared below is redundant to one declared in
 24410                                  ;	TDATA.ASM, and used in TCODE.ASM.
 24411                                  ;   *	An ugly routine.
 24412                                  
 24413                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24414                                  arg_switch:
 24415 00003123 50                      	push	ax
 24416 00003124 53                      	push	bx
 24417 00003125 51                      	push	cx
 24418 00003126 57                      	push	di
 24419 00003127 9C                      	pushf
 24420 00003128 F6C701                  	test	bh,1 ; sw_flag		; is it a switch? (preserve flag word)
 24421 0000312B 741C                    	jz	short arg_no_switch0
 24422 0000312D 833E[F193]FF            	cmp	word [LASTARG],-1 	; have we encountered any REAL args yet?
 24423 00003132 741B                    	je	short arg_no_switch1 	; no, so leading switches don't matter
 24424 00003134 8B1E[F193]              	mov	bx,[LASTARG]		; yes, add switch info to last REAL arg
 24425                                  	;mov	ax,offset TRANGROUP:arg.argv
 24426                                  	;mov	ax,ARG_ARGV
 24427 00003138 B8[2B8E]                	mov	ax,ARG+ARG_UNIT.argv  ; ARG+0
 24428 0000313B E81800                  	call	argv_calc
 24429                                  	;or	[BX].argsw_word,BP
 24430                                  	;or	[bx+7],bp
 24431 0000313E 096F07                  	or	[bx+ARGV_ELE.argsw_word],bp
 24432                                  	;or	arg.argswinfo,BP
 24433                                  	;or	[ARG_ARGSWINFO],bp
 24434 00003141 092E[ED90]              	or	[ARG+ARG_UNIT.argswinfo],bp
 24435                                  arg_yes_switch:
 24436 00003145 9D                      	popf
 24437 00003146 F9                      	stc
 24438 00003147 EB08                    	jmp	short arg_switch_exit
 24439                                  
 24440                                  arg_no_switch0:
 24441                                  	;mov	ax,[ARG_ARGVCNT]
 24442 00003149 A1[EB90]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 24443 0000314C A3[F193]                	mov	[LASTARG],ax
 24444                                  arg_no_switch1:
 24445 0000314F 9D                      	popf
 24446 00003150 F8                      	clc
 24447                                  arg_switch_exit:
 24448 00003151 5F                      	pop	di
 24449 00003152 59                      	pop	cx
 24450 00003153 5B                      	pop	bx
 24451 00003154 58                      	pop	ax
 24452 00003155 C3                      	retn
 24453                                  
 24454                                  ; =============== S U B	R O U T	I N E =======================================
 24455                                  
 24456                                  ; ARGV_CALC maps an array index into a byte-offset from the base of
 24457                                  ; the supplied array.  Method used for computing the address is:
 24458                                  ;	Array Index * Array Elt Size + Base Addr = Elt Addr
 24459                                  ; ENTRY:
 24460                                  ;   AX	    --	    base of array
 24461                                  ;   BX	    --	    array index
 24462                                  ; EXIT:
 24463                                  ;   BX	    --	    byte offset
 24464                                  
 24465                                  	; 01/03/2023 - Retro DOS v4.0 COMMAND.COM
 24466                                  argv_calc:
 24467 00003156 50                      	push	ax		; Save base
 24468 00003157 88D8                    	mov	al,bl		; al = array index
 24469                                  	;mov	bl,11
 24470 00003159 B30B                    	mov	bl,ARGV_ELE.SIZE ; bl = size of an argv element
 24471 0000315B F6E3                    	mul	bl		; ax = base offset
 24472 0000315D 5B                      	pop	bx		; Get base
 24473 0000315E 01D8                    	add	ax,bx		; Add in base offset
 24474 00003160 93                      	xchg	ax,bx		; Restore ax and put byte offset in bx
 24475 00003161 C3                      	retn
 24476                                  
 24477                                  ; ---------------------------------------------------------------------------
 24478                                  	
 24479                                  	;db 0Ah dup(0)
 24480                                  	;times 10 db 0
 24481                                  
 24482 00003162 90<rep Eh>              align 16
 24483                                  
 24484                                  ;============================================================================
 24485                                  ; PATH1.ASM, MSDOS 6.0, 1991
 24486                                  ;============================================================================
 24487                                  ; 03/10/2018 - Retro DOS v3.0
 24488                                  
 24489                                  ;----------------------------------------------------------------------------
 24490                                  ;    PATH.ASM contains the routines to perform pathname incovation. Path and
 24491                                  ;    Parse share a temporary buffer and argv[] definitions. <Path_Search>,
 24492                                  ;    given a pathname, attempts to find a corresponding executable or batch
 24493                                  ;    file on disk. Directories specified in the user's search path will be
 24494                                  ;    searched for a matching file, if a match is not found in the current
 24495                                  ;    directory and if the pathname is actually only an MSDOS filename.
 24496                                  ;    <Path_Search> assumes that the parsed command name can be found in
 24497                                  ;    argv[0] -- in other words, <Parseline> should be executed prior to
 24498                                  ;    <Path_Search>. Alternatively, the command name and appropriate
 24499                                  ;    information could be placed in argv[0], or <Path_Search> could be
 24500                                  ;    (easily) modified to make no assumptions about where its input is found.
 24501                                  ;    Please find enclosed yet another important routine, <Save_Args>, which
 24502                                  ;    places the entire arg/argv[]/argbuf structure on a piece of newly
 24503                                  ;    allocated memory. This is handy for for-loop processing, and anything
 24504                                  ;    else that wants to save the whole shebang and then process other command
 24505                                  ;    lines.
 24506                                  ;
 24507                                  ; Alan L, OS/MSDOS				    August 15, 1983
 24508                                  ;
 24509                                  ; ENTRY:
 24510                                  ;   <Path_Search>:	    argv[0].
 24511                                  ;   <Save_Args>:	    bytes to allocate in addition to arg structure
 24512                                  ; EXIT:
 24513                                  ;   <Path_Search>:	    success flag, best pathname match in EXECPATH.
 24514                                  ;   <Save_Args>:	    success flag, segment address of new memory
 24515                                  ; NOTE(S):
 24516                                  ;   *	<Argv_calc> handily turns an array index into an absolute pointer.
 24517                                  ;	The computation depends on the size of an argv[] element (arg_ele).
 24518                                  ;   *	<Parseline> calls <cparse> for chunks of the command line. <Cparse>
 24519                                  ;	does not function as specified; see <Parseline> for more details.
 24520                                  ;   *	<Parseline> now knows about the flags the internals of COMMAND.COM
 24521                                  ;	need to know about. This extra information is stored in a switch_flag
 24522                                  ;	word with each command-line argument; the switches themselves will not
 24523                                  ;	appear in the resulting arg structure.
 24524                                  ;   *	With the exception of CARRY, flags are generally preserved across calls.
 24525                                  ;----------------------------------------------------------------------------
 24526                                  
 24527                                  ; =============== S U B	R O U T	I N E =======================================
 24528                                  
 24529                                  ; PATH_SEARCH tries to find the file it's given, somewhere. An initial value
 24530                                  ; of *argv[0].argstartel == 0 implies that there is no command (empty line
 24531                                  ; or 'd:' or 'd:/'). This check is done in strip; otherwise, strip formats
 24532                                  ; the filename/pathname into tpbuf. Search(tpbuf) is executed to see if we
 24533                                  ; have a match, either in the current working directory if we were handed
 24534                                  ; a filename, or in the specified directory, given a pathname. If this call
 24535                                  ; fails, and we were given a pathname, then Path_Search fails. Otherwise,
 24536                                  ; Path_Crunch is repeatedly invoked on tpbuf[STARTEL] (if there's a drive
 24537                                  ; prefix, we want to skip it) for each pathstring in userpath. Success on
 24538                                  ; either the first invocation of search or on one of the succeeding calls
 24539                                  ; sets up the appropriate information for copying the successful pathname
 24540                                  ; prefix (if any) into the result buffer, followed by the successful filename
 24541                                  ; match (from [search_best_buf]). The result is returned in in EXECPATH.
 24542                                  ;
 24543                                  ; ENTRY:
 24544                                  ;   argv[0]		--	command name and associated information
 24545                                  ; EXIT:
 24546                                  ;   AX			--	non-zero indicates type of file found
 24547                                  ;   EXECPATH		--	successful pathname (AX non-zero)
 24548                                  ; NOTE(S):
 24549                                  ;   1)	Uses the temporary buffer, tpbuf, from the parse routines.
 24550                                  ;   2)	Some files are more equal than others.	See search: for rankings.
 24551                                  ;   3)	Path_Search terminates as soon as a call to search succeeds, even
 24552                                  ;	if search returns an .exe or .bat.
 24553                                  ;   5)	Clobbers dma address.
 24554                                  
 24555                                  PBUFLEN 	EQU	128		; length of EXECPATH
 24556                                  PATH_SEP_CHAR	EQU	';'
 24557                                  
 24558                                  ;parseflags RECORD special_delim:1, unused:4, path_sep:1, wildcard:1, sw_flag:1
 24559                                  
 24560                                  	;special_delim equ 128
 24561                                  	;path_sep equ 4
 24562                                  	;wildcard equ 2
 24563                                  	;sw_flag  equ 1
 24564                                  
 24565                                  ;----------------------------------------------------------------------------
 24566                                  
 24567                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2510h
 24568                                  
 24569                                  ; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24570                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 32D1h
 24571                                  
 24572                                  path_search:
 24573 00003170 53                      	push	bx
 24574 00003171 51                      	push	cx
 24575 00003172 52                      	push	dx		; could use a "stack 'em" instruction
 24576 00003173 56                      	push	si
 24577 00003174 57                      	push	di
 24578 00003175 55                      	push	bp
 24579 00003176 9C                      	pushf
 24580                                  
 24581                                  	;test	ds:arg.argv[0].argflags, (MASK wildcard) + (MASK sw_flag)
 24582                                  	;test	byte [ARGV0_ARG_FLAGS],3
 24583 00003177 F606[2D8E]03            	test	byte [ARG+ARGV_ELE.argflags],3 ; wildcard+sw_flag
 24584 0000317C 7403                    	jz	short path_search_ok
 24585                                  path_failure_jmp:
 24586 0000317E E9C100                  	jmp	path_failure	; ambiguous commands not allowed
 24587                                  
 24588                                  path_search_ok:
 24589 00003181 E85201                  	call	STORE_PCHAR	; figure out the pathname separator
 24590 00003184 BA[F593]                	mov	dx,FBUF		; clobber old dma value with
 24591 00003187 B8001A                  	mov	ax,Set_DMA*256 ; 1A00h ; a pointer to our dma buffer
 24592 0000318A CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 24593                                  			; DS:DX	-> disk	transfer buffer
 24594 0000318C 06                      	push	es
 24595 0000318D E876F1                  	call	find_path	; get a handle (ES:DI) on user path
 24596 00003190 8C06[2094]              	mov	[pathinfo+0],es	; and squirrel it away
 24597 00003194 893E[2294]              	mov	[pathinfo+2],di	; "old" pathstring pointer
 24598 00003198 893E[2494]              	mov	[pathinfo+4],di	; "new" pathstring pointer
 24599 0000319C 07                      	pop	es
 24600                                  	
 24601 0000319D BB8000                  	mov	bx,PBUFLEN ; 128 ; copy/format argv[0] into temp buffer
 24602 000031A0 BE[C489]                	mov	si,EXECPATH
 24603 000031A3 E88002                  	call	STRIP
 24604 000031A6 72D6                    	jc	short path_failure_jmp ; if possible, of course
 24605                                  		
 24606 000031A8 89F2                    	mov	dx,si		; search (EXECPATH, error_message)
 24607 000031AA C706[7594][8D7F]        	mov	word [search_error],baddrv_ptr
 24608 000031B0 E89F01                  	call	PSEARCH		; must do at least one search
 24609 000031B3 09C0                    	or	ax,ax		; find anything?
 24610 000031B5 7469                    	jz	short path_noinit
 24611                                  				; failure ... search farther	
 24612 000031B7 89C5                    	mov	bp,ax		; success... save filetype code	
 24613 000031B9 BF[C489]                	mov	di,EXECPATH
 24614                                  	;mov	si,ds:arg.argv[0].argpointer
 24615                                  	;mov	si,[ARG_ARGV]
 24616 000031BC 8B36[2B8E]              	mov	si,[ARG+ARGV_ELE.argpointer]
 24617                                  	;mov	cx,ds:arg.argv[0].argstartel
 24618                                  	;mov	cx,[ARGV0_ARGSTARTEL]
 24619 000031C0 8B0E[2E8E]              	mov	cx,[ARG+ARGV_ELE.argstartel]
 24620 000031C4 29F1                    	sub	cx,si		; compute prefix bytes to copy
 24621                                  
 24622                                  ; We have the number of bytes in the prefix (up to the final component).
 24623                                  ; We need to form the complete pathname including leading drive and current
 24624                                  ; directory.
 24625                                  ;
 24626                                  ; Is there a drive letter present?
 24627                                  
 24628 000031C6 B43A                    	mov	ah,':'
 24629 000031C8 83F902                  	cmp	cx,2		; room for drive letter?
 24630 000031CB 7205                    	jb	short adddrive	; no, stick it in
 24631 000031CD 386401                  	cmp	[si+1],	ah	; colon present?
 24632 000031D0 7408                    	je	short movedrive	; yes, just move it
 24633                                  adddrive:
 24634 000031D2 A0[B08A]                	mov	al,[CURDRV]	; get current drive
 24635 000031D5 0441                    	add	al,'A'		; convert to uppercase letter
 24636 000031D7 AB                      	stosw			; store d:
 24637 000031D8 EB05                    	jmp	short checkpath
 24638                                  
 24639                                  movedrive:
 24640 000031DA AD                      	lodsw			; move d:
 24641 000031DB AB                      	stosw
 24642 000031DC 83E902                  	sub	cx,2		; 2 bytes less to move
 24643                                  checkpath:
 24644 000031DF 0C20                    	or	al,20h
 24645 000031E1 88C2                    	mov	dl,al		
 24646                                  	;sub	dl,60h
 24647 000031E3 80EA60                  	sub	dl,'a'-1	; convert to 1-based for current dir
 24648                                  
 24649                                  ; Stick in beginning path char
 24650                                  
 24651 000031E6 A0[2694]                	mov	al,[psep_char]
 24652 000031E9 AA                      	stosb
 24653                                  
 24654                                  ; Is there a leading /? If so, then no current dir copy is necessary.
 24655                                  ; Otherwise, get current dir for DL.
 24656                                  
 24657 000031EA 83F901                  	cmp	cx,1		; is there room for path char?
 24658 000031ED 720A                    	jb	short addpath	; no, go add path
 24659 000031EF AC                      	lodsb
 24660 000031F0 49                      	dec	cx
 24661 000031F1 3A06[2694]              	cmp	al,[psep_char]	; is there a path separator?
 24662 000031F5 741C                    	je	short movepath	; yes, go move remainder of path
 24663 000031F7 41                      	inc	cx
 24664 000031F8 4E                      	dec	si		; undo the lodsb
 24665                                  addpath:
 24666 000031F9 56                      	push	si
 24667 000031FA 89FE                    	mov	si,di		; remainder of buffer
 24668 000031FC B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24669 000031FF CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24670                                  			; DL = drive (0=default,1=A,etc.)
 24671                                  			; DS:SI	points to 64-byte buffer area
 24672                                  
 24673                                  ; The previous current dir will succeed a previous find_first already worked.
 24674                                  ;
 24675                                  ; Find end of string.
 24676                                  
 24677 00003201 89F7                    	mov	di,si
 24678 00003203 5E                      	pop	si
 24679 00003204 A0[2694]                	mov	al,[psep_char]
 24680 00003207 803D00                  	cmp	byte [di],0	; root (empty dir string)?
 24681 0000320A 7407                    	jz	short movepath	; yes, no need for path char
 24682                                  scanend:
 24683                                  	;cmp	byte [di],0	; end of string?
 24684                                  	;jz	short foundend
 24685                                  	;inc	di
 24686                                  	;jmp	short scanend
 24687                                  	; 18/03/2023 - Retro DOS v4.0 COMMAND.COM
 24688 0000320C 47                      	inc	di
 24689 0000320D 803D00                  	cmp	byte [di],0
 24690 00003210 75FA                    	jnz	short scanend
 24691                                  
 24692                                  ; Stick in a trailing path char.
 24693                                  
 24694                                  foundend:
 24695 00003212 AA                      	stosb
 24696                                  
 24697                                  ; Move remaining part of path. Skip leading path char if present.
 24698                                  
 24699                                  movepath:
 24700 00003213 3804                    	cmp	[si],al		; first char a path char?
 24701 00003215 7502                    	jne	short copypath
 24702                                  	; 26/04/2023
 24703 00003217 46                      	inc	si		; move past leading char
 24704 00003218 49                      	dec	cx		; drop from count
 24705                                  copypath:
 24706 00003219 E302                    	jcxz	_copydone	; no chars to move!	
 24707 0000321B F3A4                    	rep	movsb
 24708                                  _copydone:
 24709 0000321D E9A100                  	jmp	path_success
 24710                                  				; run off and form complete pathname
 24711                                  path_noinit:
 24712                                  	;test	ds:arg.argv[0].argflags, MASK path_sep
 24713                                  	;test	byte [ARGV0_ARG_FLAGS],4
 24714 00003220 F606[2D8E]04            	test	byte [ARG+ARGV_ELE.argflags],4 ; path_sep
 24715 00003225 751B                    	jnz	short path_failure
 24716                                  				; complete pathname specified ==> fail
 24717                                  	;mov	bh,';'
 24718 00003227 B73B                    	mov	bh,PATH_SEP_CHAR
 24719                                  				; semicolon terminates pathstring
 24720                                  	;mov	dx,ds:arg.argv[0].argstartel
 24721                                  				; this is where the last element starts
 24722                                  	;mov	dx,[ARGV0_ARGSTARTEL]
 24723 00003229 8B16[2E8E]              	mov	dx,[ARG+ARGV_ELE.argstartel]
 24724                                  	;sub	dx,ds:arg.argv[0].argpointer
 24725                                  				; form pointer into EXECPATH,
 24726                                  	;sub	dx,[ARG_ARGV]
 24727 0000322D 2B16[2B8E]              	sub	dx,[ARG+ARGV_ELE.argpointer]
 24728 00003231 81C2[C489]              	add	dx,EXECPATH	; skipping over drive spec, if any
 24729                                  path_loop:
 24730 00003235 E8AD00                  	call	path_crunch	; pcrunch (EXECPATH, pathinfo)
 24731 00003238 89C5                    	mov	bp,ax		; save filetype code
 24732 0000323A 9F                      	lahf			; save flags, just in case
 24733 0000323B 09ED                    	or	bp,bp		; did path_crunch find anything?		
 24734 0000323D 7508                    	jnz	short path_found 
 24735 0000323F 9E                      	sahf			; see? needed those flags, after all!
 24736 00003240 73F3                    	jnc	short path_loop	; is there anything left to the path?
 24737                                  path_failure:
 24738 00003242 31C0                    	xor	ax,ax
 24739 00003244 E98700                  	jmp	path_exit
 24740                                  
 24741                                  path_found:				; pathinfo[] points to winner
 24742 00003247 BF[C489]                	mov	di,EXECPATH
 24743                                  	;mov	cx,pathinfo[4] 
 24744 0000324A 8B0E[2494]              	mov	cx,[pathinfo+4]	; "new" pointer -- end of string
 24745                                  	;mov	si,pathinfo[2]
 24746 0000324E 8B36[2294]              	mov	si,[pathinfo+2]	; "old" pointer -- beginning of string
 24747                                  
 24748                                  ;	BAS Nov 20/84
 24749                                  ;   Look at the pathname and expand . and .. if they are the first element
 24750                                  ;   in the pathname (after the drive letter)
 24751                                  
 24752 00003252 06                      	push	es
 24753                                  	;push	pathinfo[0]
 24754 00003253 FF36[2094]              	push	word [pathinfo+0]
 24755 00003257 07                      	pop	es
 24756                                  ;SR;
 24757                                  ; Oops! Gets fooled if path= \;..
 24758                                  ; We should also check if a drive letter is really present
 24759                                  ;
 24760 00003258 26807C022E              	cmp	byte [es:si+2],'.'
 24761                                  				; Look for Current dir at start of path
 24762 0000325D 7534                    	jne	short path_cpy
 24763                                  
 24764                                  	; 18/03/2023
 24765                                  	; MSDOS 6.0
 24766 0000325F 26807C013A              	cmp	byte [es:si+1],':'
 24767                                  				; does path have drive letter?
 24768 00003264 752D                    	jne	short path_cpy	; no, copy the path string
 24769                                  
 24770 00003266 51                      	push	cx		; Save pointer to end of string
 24771                                  	;mov	al,[es:si]
 24772                                  	;mov	[di],al		; Copy drive letter, :, and root char
 24773                                  	;mov	al,[es:si+1]	; to EXECPATH
 24774                                  	;mov	[di+1],al
 24775                                  	; 05/05/2023
 24776 00003267 268B04                  	mov	ax,[es:si]
 24777 0000326A 8905                    	mov	[di],ax
 24778 0000326C A0[2694]                	mov	al,[psep_char]
 24779 0000326F 884502                  	mov	[di+2],al
 24780 00003272 56                      	push	si		; Save pointer to begining of string
 24781 00003273 268A14                  	mov	dl,[es:si]	; Convert device letter for cur dir
 24782 00003276 80CA20                  	or	dl,20h
 24783                                  	;sub	dl,60h
 24784 00003279 80EA60                  	sub	dl,'a'-1
 24785 0000327C 89FE                    	mov	si,di		; pointer to EXECPATH
 24786 0000327E 83C603                  	add	si,3		; Don't wipe out drive and root info
 24787 00003281 B80047                  	mov	ax,Current_Dir*256 ; 4700h
 24788 00003284 CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 24789                                  			; DL = drive (0=default,1=A,etc.)
 24790                                  			; DS:SI	points to 64-byte buffer area
 24791 00003286 E8DEF9                  	call	dstrlen		; Determine length of present info
 24792 00003289 01CE                    	add	si,cx		; Don't copy over drive and root info
 24793 0000328B 4E                      	dec	si
 24794 0000328C 89F7                    	mov	di,si		; Point to end of target string
 24795 0000328E 5E                      	pop	si		; Restore pointer to begining of string
 24796 0000328F 83C603                  	add	si,3		; Point past drive letter, :, .
 24797 00003292 59                      	pop	cx		; Restore pointer to end of string
 24798                                  path_cpy:
 24799 00003293 07                      	pop	es
 24800 00003294 29F1                    	sub	cx,si		; yields character count
 24801 00003296 1E                      	push	ds		; time to switch segments
 24802 00003297 FF36[2094]              	push	word [pathinfo+0]
 24803                                  				; string lives in this segment
 24804 0000329B 1F                      	pop	ds
 24805 0000329C FC                      	cld
 24806                                  
 24807                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24808                                  	; MSDOS 5.0 (& MSDOS 5.0)
 24809                                  	;;rep	movsb ; 3/3/KK	; copy the prefix path into EXECPATH
 24810                                  kloop:
 24811 0000329D AC                      	lodsb			;AN000;  3/3/KK
 24812 0000329E AA                      	stosb			;AN000;  3/3/KK
 24813 0000329F E816F1                  	call	testkanj	;AN000;  3/3/KK
 24814 000032A2 7410                    	jz	short _notkanj1	;AN000;  3/3/KK
 24815 000032A4 49                      	dec	cx		;AN000;  3/3/KK
 24816 000032A5 E307                    	jcxz	popdone		;AN000;  Ignore boundary error 3/3/KK
 24817 000032A7 A4                      	movsb			;AN000;  3/3/KK
 24818 000032A8 49                      	dec	cx		;AN000;  3/3/KK
 24819 000032A9 83F901                  	cmp	cx,1		;AN000;  One char (the terminator) left ? 3/3/KK
 24820 000032AC 77EF                    	ja	short kloop	;AN000;  no.  3/3/KK
 24821                                  popdone:			;AN000;  3/3/KK
 24822 000032AE 1F                      	pop	ds		;AN000;  Yes ES:DI->terminator, last char is 3/3/KK
 24823 000032AF A0[2694]                	mov	al,[psep_char]	;AN000;  KANJI 3/3/KK
 24824 000032B2 EB0C                    	jmp	short path_store
 24825                                  				;AN000;  3/3/KK
 24826                                  _notkanj1:
 24827                                  	; 26/04/2023
 24828 000032B4 E2E7                    	loop	kloop
 24829 000032B6 1F                      	pop	ds		; return to our segment
 24830 000032B7 4F                      	dec	di		; overwrite terminator
 24831 000032B8 A0[2694]                	mov	al,[psep_char]	; with a pathname separator
 24832 000032BB 3A45FF                  	cmp	al,[di-1]
 24833 000032BE 7401                    	je	short path_success
 24834                                  path_store:
 24835 000032C0 AA                      	stosb
 24836                                  path_success:
 24837 000032C1 BE[2894]                	mov	si,search_best_buf
 24838 000032C4 31C9                    	xor	cx,cx
 24839                                  path_succ_loop:
 24840 000032C6 AC                      	lodsb			; append winning filename to path
 24841 000032C7 AA                      	stosb			; (including terminating null)	
 24842 000032C8 08C0                    	or	al,al
 24843 000032CA 75FA                    	jnz	short path_succ_loop
 24844 000032CC 89E8                    	mov	ax,bp		; retrieve filetype code
 24845                                  path_exit:
 24846 000032CE 9D                      	popf
 24847 000032CF 5D                      	pop	bp
 24848 000032D0 5F                      	pop	di
 24849 000032D1 5E                      	pop	si		; chill out...
 24850 000032D2 5A                      	pop	dx
 24851 000032D3 59                      	pop	cx
 24852 000032D4 5B                      	pop	bx
 24853 000032D5 C3                      	retn
 24854                                  
 24855                                  ; =============== S U B	R O U T	I N E =======================================
 24856                                  
 24857                                  ; STORE_PCHAR determines the pathname-element separator and squirrels
 24858                                  ; it away. In other words, must we say '/bin/ls' or '\bin\ls'?
 24859                                  ;
 24860                                  ; ENTRY:
 24861                                  ; EXIT:
 24862                                  ; NOTE(S):
 24863                                  ;   *	Uses <psep_char>, defined in <path_search>.
 24864                                  
 24865                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24866                                  STORE_PCHAR:
 24867 000032D6 50                      	push	ax
 24868 000032D7 B02F                    	mov	al,'/'		; is the pathname-element separator
 24869 000032D9 E889F3                  	call	pathchrcmp	; a regular slash?
 24870 000032DC 7402                    	jz	short STORE_SLASH
 24871                                  				; if yes, remember slash
 24872 000032DE B05C                    	mov	al,'\'
 24873                                  	; 18/03/2023
 24874                                  	;mov	[psep_char],al	; otherwise, remember back-slash
 24875                                  	;pop	ax
 24876                                  	;retn
 24877                                  STORE_SLASH:
 24878 000032E0 A2[2694]                	mov	[psep_char],al
 24879 000032E3 58                      	pop	ax
 24880 000032E4 C3                      	retn
 24881                                  
 24882                                  ; =============== S U B	R O U T	I N E =======================================
 24883                                  
 24884                                  ; PATH_CRUNCH takes a prefix from a prefix string, and a suffix from
 24885                                  ; EXECPATH, and smooshes them into tpbuf. The caller may supply an
 24886                                  ; additional separator to use for breaking up the path-string. Null is the
 24887                                  ; default. Once the user-string has been formed, search is invoked to see
 24888                                  ; what's out there.
 24889                                  ;
 24890                                  ; ENTRY:
 24891                                  ;   BH			--	additional terminator character
 24892                                  ;   SI			--	pointer into pathstring to be dissected
 24893                                  ;   DX			--	pointer to stripped filename
 24894                                  ; EXIT:
 24895                                  ;   AX			--	non-zero (file type), zero (nothing found)
 24896                                  ;   SI			--	moves along pathstring from call to call
 24897                                  ;   [search_best_buf]	--	name of best file (AX non-zero)
 24898                                  ;   [tpbuf]		--	clobbered
 24899                                  ; NOTE(S):
 24900                                  ;   *	Implicit in this code is the ability to specify when to search
 24901                                  ;	the current directory (if at all) through the PATH defined by
 24902                                  ;	the user, a la UNIX (e.g., PATH=;c:\bin;c:\etc searches the
 24903                                  ;	current directory before the bin and etc directories of drive c).
 24904                                  
 24905                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24906                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3454h
 24907                                  	
 24908                                  path_crunch:
 24909 000032E5 53                      	push	bx
 24910 000032E6 51                      	push	cx
 24911 000032E7 52                      	push	dx
 24912 000032E8 57                      	push	di
 24913 000032E9 56                      	push	si
 24914                                  	;pushf	; ** ; 18/03/2023
 24915 000032EA E8E9FF                  	call	STORE_PCHAR	; figure out pathname separator
 24916 000032ED BF[7193]                	mov	di,TPBUF	; destination of concatenated string
 24917 000032F0 8B36[2494]              	mov	si,[pathinfo+4]	; "new" pointer to start with
 24918 000032F4 8936[2294]              	mov	[pathinfo+2],si	; becomes "old" pointer
 24919 000032F8 1E                      	push	ds		; save old segment pointer
 24920 000032F9 FF36[2094]              	push	word [pathinfo+0]
 24921                                  				; replace with pointer to userpath's
 24922 000032FD 1F                      	pop	ds		; segment
 24923                                  	; 26/04/2023
 24924 000032FE 30C9                    	xor	cl,cl		;AN000; clear flag for later use 3/3/KK	
 24925                                  path_cr_copy:
 24926 00003300 AC                      	lodsb			; get a pathname byte
 24927 00003301 08C0                    	or	al,al		; check for terminator(s)
 24928 00003303 7414                    	jz	short path_seg	; null terminates segment & pathstring
 24929 00003305 38F8                    	cmp	al,bh
 24930 00003307 7410                    	je	short path_seg	; BH terminates a pathstring segment
 24931                                  	;
 24932                                  	; 18/03/2023
 24933                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 24934 00003309 E8ACF0                  	call	testkanj	;AN000; 3/3/KK
 24935 0000330C 7406                    	jz	short _notkanj2	;AN000; 3/3/KK
 24936 0000330E AA                      	stosb			;AN000; 3/3/KK
 24937 0000330F A4                      	movsb			;AN000; 3/3/KK
 24938 00003310 B101                    	mov	cl,1 ; *	;AN000; CL=1 means latest stored char is DBCS 3/3/KK	
 24939 00003312 EBEC                    	jmp	short path_cr_copy
 24940                                  _notkanj2:
 24941 00003314 30C9                    	xor	cl,cl ; *	;AN000; CL=0 means latest stored char is SBCS 3/3/KK
 24942                                  	;
 24943 00003316 AA                      	stosb
 24944 00003317 EBE7                    	jmp	short path_cr_copy
 24945                                  
 24946                                  path_seg:
 24947 00003319 1F                      	pop	ds		; restore old data segment
 24948 0000331A 8936[2494]              	mov	[pathinfo+4],si	; save "new" pointer for next time
 24949 0000331E 88C3                    	mov	bl,al		; remember if we saw null or not...
 24950                                  				;;; REMOVE NEXT 3 LINES FOR CURDIR SPEC
 24951 00003320 31C0                    	xor	ax,ax		; in case nothing in pathstr...
 24952 00003322 81FF[7193]              	cmp	di,TPBUF	; was there really anything in pathstr?		
 24953 00003326 7421                    	je	short path_cr_leave
 24954                                  				; if nothing was copied, pathstr empty
 24955                                  path_cr_look:
 24956 00003328 A0[2694]                	mov	al,[psep_char]	; form complete pathname
 24957                                  	;
 24958                                  	; 18/03/2023
 24959                                  	; MSDOS 6.0
 24960 0000332B 08C9                    	or	cl,cl ; *	;AN000; 3/3/KK
 24961 0000332D 7505                    	jnz	short path_cr_store
 24962                                  				;AN000; this is a trailing byte of ECS code 3/3/KK
 24963                                  	;
 24964 0000332F 3A45FF                  	cmp	al,[di-1]	; add pathname separator for suffix
 24965 00003332 7401                    	je	short path_cr_l1
 24966                                  path_cr_store:
 24967 00003334 AA                      	stosb
 24968                                  path_cr_l1:
 24969 00003335 89D6                    	mov	si,dx
 24970                                  path_cr_l2:
 24971 00003337 AC                      	lodsb			; tack the stripped filename onto
 24972 00003338 AA                      	stosb			; the end of the path, up to and
 24973 00003339 08C0                    	or	al,al		; including the terminating null
 24974 0000333B 75FA                    	jnz	short path_cr_l2
 24975 0000333D BA[7193]                	mov	dx,TPBUF	; and look for an appropriate file...	
 24976 00003340 C706[7594][8980]        	mov	word [search_error],BADPMES_PTR
 24977                                  	;invoke search
 24978 00003346 E80900                  	call	PSEARCH		; results are in AX & search_best_buf
 24979                                  
 24980                                  	; 18/03/2023
 24981                                  ;path_cr_leave:
 24982                                  	;or	bl,bl		; did we finish off the pathstring?
 24983                                  	;jz	short path_cr_empty
 24984                                  	;			; null in BL means all gone...
 24985                                  	;popf	; **		; otherwise, plenty left
 24986                                  	;clc
 24987                                  	;jmp	short path_cr_exit
 24988                                  ;path_cr_empty:
 24989                                  	;popf	; **
 24990                                  	;stc
 24991                                  ;path_cr_exit:
 24992                                  
 24993                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 24994                                  path_cr_leave:
 24995                                  	;popf ; ** ; 18/03/2023
 24996 00003349 80FB01                  	cmp	bl,1	; if bl = 0 -> cf = 1 (path_cr_empty:)
 24997                                  	
 24998                                  path_cr_exit:
 24999 0000334C 5E                      	pop	si
 25000 0000334D 5F                      	pop	di
 25001 0000334E 5A                      	pop	dx
 25002 0000334F 59                      	pop	cx
 25003 00003350 5B                      	pop	bx
 25004 00003351 C3                      	retn
 25005                                  
 25006                                  ;============================================================================
 25007                                  ; PATH2.ASM, MSDOS 6.0, 1991
 25008                                  ;============================================================================
 25009                                  ; 02/10/2018 - Retro DOS v3.0
 25010                                  
 25011                                  ;----------------------------------------------------------------------------
 25012                                  ;   SEARCH, when given a pathname, attempts to find a file with
 25013                                  ; one of the following extensions: .com, .exe, .bat (highest to
 25014                                  ; lowest priority). Where conflicts arise, the extension with
 25015                                  ; the highest priority is favored.
 25016                                  ; ENTRY:
 25017                                  ;   DX		--	pointer to null-terminated pathname
 25018                                  ;   fbuf	--	dma buffer for findfirst/next
 25019                                  ; EXIT:
 25020                                  ;   AX		--	8)  file found with .com extension
 25021                                  ;			4)  file found with .exe extension
 25022                                  ;			2)  file found with .bat extension
 25023                                  ;			0)  no such file to be found
 25024                                  ;   (if AX is non-zero:)
 25025                                  ;   [search_best]	identical to AX
 25026                                  ;   [search_best_buf]	null-terminated filename
 25027                                  ; NOTES:
 25028                                  ;   1) Requires caller to have allocated a dma buffer and executed a setdma.
 25029                                  ;---------------
 25030                                  ; CONSTANTS:
 25031                                  ;---------------
 25032                                  SEARCH_FILE_NOT_FOUND	EQU	0
 25033                                  SEARCH_COM		EQU	8
 25034                                  SEARCH_EXE		EQU	4
 25035                                  SEARCH_BAT		EQU	2
 25036                                  FNAME_LEN		EQU	8
 25037                                  FNAME_MAX_LEN		EQU	13
 25038                                  DOT			EQU	'.'
 25039                                  WILDCHAR		EQU	'?'
 25040                                  
 25041                                  
 25042                                  ; =============== S U B	R O U T	I N E =======================================
 25043                                  
 25044                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 26D6h
 25045                                  
 25046                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25047                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:34C9h
 25048                                  	
 25049                                  PSEARCH:
 25050 00003352 51                      	push	cx
 25051 00003353 52                      	push	dx
 25052 00003354 57                      	push	di
 25053 00003355 56                      	push	si
 25054                                  	;pushf	; ** ; 18/03/2023
 25055 00003356 52                      	push	dx		; check drivespec (save pname ptr)
 25056 00003357 89D7                    	mov	di,dx		; working copy of pathname
 25057 00003359 BE[3594]                	mov	si,search_curdir_buf
 25058 0000335C 31D2                    	xor	dx,dx		; zero means current drive
 25059 0000335E 807D013A                	cmp	byte [di+1],':'	; is there a drive spec?
 25060 00003362 7508                    	jne	short SEARCH_DIR_CHECK
 25061 00003364 8A15                    	mov	dl,[di]		; get the drive byte
 25062 00003366 80E2DF                  	and	dl,0DFh ; ~20h	; uppercase the sucker
 25063 00003369 80EA40                  	sub	dl,'@' ; 40h	; and convert to drive number
 25064                                  SEARCH_DIR_CHECK:
 25065 0000336C B80047                  	mov	ax,Current_Dir*256 ; 4700h
 25066 0000336F CD21                    	int	21h	; DOS -	2+ - GET CURRENT DIRECTORY
 25067                                  			; DL = drive (0=default,1=A,etc.)
 25068                                  			; DS:SI	points to 64-byte buffer area
 25069 00003371 5A                      	pop	dx		; directory? If we can't we'll		
 25070 00003372 724C                    	jc	short SEARCH_INVALID_DRIVE
 25071                                  				; assume it's a bad drive...
 25072 00003374 B91300                  	mov	cx,search_attr	; 13h
 25073                                  				; filetypes to search for
 25074 00003377 B8004E                  	mov	ax,Find_First*256 ; 4E00h ; request first match, if any
 25075 0000337A CD21                    	int	21h	; DOS -	2+ - FIND FIRST	ASCIZ (FINDFIRST)
 25076                                  			; CX = search attributes
 25077                                  			; DS:DX	-> ASCIZ filespec
 25078                                  			; (drive,path, and wildcards allowed)
 25079 0000337C 7249                    	jc	short SEARCH_NO_FILE
 25080 0000337E C606[2794]00            	mov	byte [search_best],SEARCH_FILE_NOT_FOUND ; 0
 25081 00003383 C606[2894]00            	mov	byte [search_best_buf],ANULL
 25082                                  				; 0 ; nothing's been found, yet
 25083                                  SEARCH_LOOP:
 25084 00003388 E84300                  	call	SEARCH_FTYPE	; determine if .com, &c...
 25085 0000338B 3A06[2794]              	cmp	al,[search_best]
 25086                                  				; better than what we've found so far?
 25087 0000338F 7E13                    	jle	short SEARCH_NEXT
 25088                                  				; no, look for another	
 25089 00003391 A2[2794]                	mov	[search_best],al
 25090                                  				; found something... save its code	
 25091                                  	;mov	si,offset TRANGROUP:fbuf.find_buf_pname
 25092                                  	;mov	si,FBUF_PNAME
 25093 00003394 BE[1394]                	mov	si,FBUF+FIND_BUF.PNAME ; FBUF+30
 25094 00003397 BF[2894]                	mov	di,search_best_buf
 25095 0000339A B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25096 0000339D FC                      	cld
 25097 0000339E F3A4                    	rep	movsb		; save complete pathname representation
 25098 000033A0 3C08                    	cmp	al,SEARCH_COM	; 8
 25099                                  				; have we found the best of all?	
 25100 000033A2 740A                    	je	short SEARCH_DONE
 25101                                  SEARCH_NEXT:			; keep on looking
 25102 000033A4 B91300                  	mov	cx,search_attr ; 13h
 25103 000033A7 B8004F                  	mov	ax,Find_Next*256 ; 4F00h ; next match
 25104 000033AA CD21                    	int	21h	; DOS -	2+ - FIND NEXT ASCIZ (FINDNEXT)
 25105                                  			; [DTA]	= data block from
 25106                                  			; last AH = 4Eh/4Fh call
 25107 000033AC 73DA                    	jnc	short SEARCH_LOOP
 25108                                  SEARCH_DONE:			; it's all over with...
 25109 000033AE A0[2794]                	mov	al,[search_best]
 25110                                  				; pick best to return with
 25111                                  	; 18/03/2023
 25112                                  	; MSDOS 6.0
 25113 000033B1 803E[E18D]01            	cmp	byte [ext_entered],1
 25114                                  				;AN005; Did user request a specific ext?
 25115 000033B6 7411                    	je	short SEARCH_EXIT
 25116                                  				;AN005; no - exit
 25117 000033B8 A0[E18D]                	mov	al,[ext_entered]
 25118                                  				;AN005; yes - get the real file type back
 25119 000033BB A2[2794]                	mov	[search_best],al
 25120                                  				;AN005; save the real file type
 25121                                  	;
 25122 000033BE EB09                    	jmp	short SEARCH_EXIT
 25123                                  
 25124                                  SEARCH_INVALID_DRIVE:		; Tell the user path/drive
 25125 000033C0 8B16[7594]              	mov	dx,[search_error]
 25126                                  				; appropriate error message
 25127 000033C4 E83C1A                  	call	std_printf	; and pretend no file found
 25128                                  
 25129                                  SEARCH_NO_FILE:			; couldn't find a match
 25130                                  	;mov	ax,SEARCH_FILE_NOT_FOUND ; 0
 25131                                  	; 18/03/2023
 25132 000033C7 31C0                    	xor	ax,ax
 25133                                  SEARCH_EXIT:
 25134                                  	;popf	; ** ; 18/03/2023
 25135 000033C9 5E                      	pop	si
 25136 000033CA 5F                      	pop	di
 25137 000033CB 5A                      	pop	dx
 25138 000033CC 59                      	pop	cx
 25139 000033CD C3                      	retn
 25140                                  
 25141                                  ; =============== S U B	R O U T	I N E =======================================
 25142                                  
 25143                                  ; SEARCH_FTYPE determines the type of a file by examining its extension.
 25144                                  ;
 25145                                  ; ENTRY:
 25146                                  ;   fbuf    --	dma buffer containing filename
 25147                                  ; EXIT:
 25148                                  ;   AX	    --	file code, as given in search header
 25149                                  ; NOTE(S):
 25150                                  ;   *	Implicit assumption that NULL == search_file_not_found
 25151                                  
 25152                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25153                                  
 25154                                  SEARCH_FTYPE:
 25155 000033CE 57                      	push	di
 25156 000033CF 56                      	push	si
 25157                                  	;mov	ax,ANULL ; 0	; find the end of the filename
 25158                                  	; 18/02/2023
 25159 000033D0 31C0                    	xor	ax,ax ; ax = 0		
 25160                                  	;mov	di,offset TRANGROUP:fbuf.find_buf_pname
 25161                                  	;mov	di,FBUF_PNAME
 25162 000033D2 BF[1394]                	mov	di,FBUF+FIND_BUF.PNAME ; FBUF+1Eh
 25163 000033D5 B90D00                  	mov	cx,FNAME_MAX_LEN ; 13
 25164 000033D8 FC                      	cld
 25165 000033D9 F2AE                    	repnz	scasb		; search for the terminating null
 25166 000033DB 7535                    	jnz	short FTYPE_EXIT
 25167                                  				; weird... no null byte at end
 25168 000033DD 83EF05                  	sub	di,5		; . + E + X + T + NULL
 25169                                  
 25170                                  	; Compare .COM
 25171                                  
 25172 000033E0 BE[5B84]                	mov	si,comext ; ".COM"
 25173 000033E3 89F8                    	mov	ax,di
 25174 000033E5 A7                      	cmpsw
 25175 000033E6 7508                    	jnz	short FTYPE_EXE
 25176 000033E8 A7                      	cmpsw
 25177 000033E9 7505                    	jnz	short FTYPE_EXE
 25178                                  	;mov	ax,8
 25179 000033EB B80800                  	mov	ax,SEARCH_COM	; success!
 25180 000033EE EB22                    	jmp	short FTYPE_EXIT
 25181                                  
 25182                                  	; Compare .EXE
 25183                                  FTYPE_EXE:			; still looking... now for '.exe'
 25184 000033F0 89C7                    	mov	di,ax
 25185 000033F2 BE[5F84]                	mov	si,exeext ; ".EXE"
 25186 000033F5 A7                      	cmpsw
 25187 000033F6 7508                    	jnz	short FTYPE_BAT
 25188 000033F8 A7                      	cmpsw
 25189 000033F9 7505                    	jnz	short FTYPE_BAT
 25190                                  	;mov	ax,4
 25191 000033FB B80400                  	mov	ax,SEARCH_EXE	; success!
 25192 000033FE EB12                    	jmp	short FTYPE_EXIT
 25193                                  
 25194                                  	; Compare .BAT
 25195                                  FTYPE_BAT:			; still looking... now for '.bat'
 25196 00003400 89C7                    	mov	di,ax
 25197 00003402 BE[6384]                	mov	si,batext ; ".BAT"
 25198 00003405 A7                      	cmpsw
 25199 00003406 7508                    	jnz	short FTYPE_FAIL
 25200 00003408 A7                      	cmpsw
 25201 00003409 7505                    	jnz	short FTYPE_FAIL
 25202                                  	;mov	ax,2
 25203 0000340B B80200                  	mov	ax,SEARCH_BAT	; success!
 25204 0000340E EB02                    	jmp	short FTYPE_EXIT
 25205                                  
 25206                                  FTYPE_FAIL:			; file doesn't match what we need
 25207                                  	;mov	ax,ANULL ; 0
 25208                                  	; 18/03/2023
 25209 00003410 29C0                    	sub	ax,ax  ; ax = 0
 25210                                  FTYPE_EXIT:
 25211                                  	; 18/03/2023
 25212                                  	; MSDOS 6.0
 25213 00003412 803E[E18D]01            	cmp	byte [ext_entered],1
 25214                                  				;AN005; was an extension entered?
 25215 00003417 740A                    	jz	short FTYPE_DONE
 25216                                  				;AN005; no - exit
 25217                                  	;cmp	ax,ANULL	;AN005; was any match found
 25218 00003419 21C0                    	and	ax,ax  ; ax = 0 ?
 25219 0000341B 7406                    	jz	short FTYPE_DONE
 25220                                  				;AN005; no - exit
 25221 0000341D A2[E18D]                	mov	[ext_entered],al
 25222                                  				;AN005; save the match type found
 25223 00003420 B80800                  	mov	ax,SEARCH_COM	;AN005; send back best was found to stop search
 25224                                  FTYPE_DONE:
 25225 00003423 5E                      	pop	si
 25226 00003424 5F                      	pop	di
 25227 00003425 C3                      	retn
 25228                                  
 25229                                  ; =============== S U B	R O U T	I N E =======================================
 25230                                  
 25231                                  ; STRIP copies the source string (argv[0]) into the destination buffer,
 25232                                  ; replacing any extension with wildcards.
 25233                                  ;
 25234                                  ; ENTRY:
 25235                                  ;	BX	--	maximum length of destination buffer
 25236                                  ;	DS:SI	--	address of destination buffer
 25237                                  ;	argv[0] --	command name to be stripped
 25238                                  ; EXIT:
 25239                                  ;	CF	--	set if failure, clear if successful
 25240                                  ; NOTE(S):
 25241                                  
 25242                                  	; 18/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25243                                  
 25244                                  STRIP:
 25245 00003426 50                      	push	ax
 25246 00003427 53                      	push	bx
 25247 00003428 51                      	push	cx
 25248 00003429 52                      	push	dx
 25249 0000342A 57                      	push	di
 25250 0000342B 56                      	push	si
 25251                                  	;pushf	; ** ; 18/03/2023
 25252                                  		
 25253                                  	; 05/05/2023
 25254                                  	; MSDOS 6.0
 25255 0000342C C606[E18D]01            	mov	byte [ext_entered],1
 25256                                  				;AN005; assume no extension on file name
 25257                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25258                                  	;mov	dx,[ARG_ARGV]
 25259                                  	;mov	dx,ds:arg.argv[0].argpointer
 25260                                  				; save pointer to beginning of argstring
 25261                                  	;mov	dx,[ARGV0_ARGPOINTER]
 25262 00003431 8B16[2B8E]              	mov	dx,[ARG+ARGV_ELE.argpointer]
 25263                                  	;mov	di,ds:arg.argv[0].argstartel
 25264                                  				; beginning of last pathname element
 25265                                  	;mov	di,[ARGV0_ARGSTARTEL] ; beginning of last pathname element
 25266 00003435 8B3E[2E8E]              	mov	di,[ARG+ARGV_ELE.argstartel]
 25267 00003439 803D00                  	cmp	byte [di],0	; *STARTEL == NULL means no command
 25268 0000343C 743D                    	je	short STRIP_ERROR
 25269 0000343E 89D1                    	mov	cx,dx		; compute where end of argstring lies
 25270                                  	;add	cx,ds:arg.argv[0].arglen
 25271                                  	;add	cx,[ARGV0_ARGLEN]
 25272 00003440 030E[308E]              	add	cx,[ARG+ARGV_ELE.arglen]
 25273 00003444 29F9                    	sub	cx,di		; and then find length of last element
 25274 00003446 41                      	inc	cx		; include null as well
 25275 00003447 B02E                    	mov	al,'.'
 25276                                  	;mov	al,DOT		; let's find the filetype extension
 25277 00003449 FC                      	cld
 25278 0000344A F2AE                    	repnz	scasb		; wind up pointing to either null or dot
 25279                                  
 25280                                  	; 18/03/2023
 25281                                  	; MSDOS 6.0
 25282 0000344C E307                    	jcxz	PROCESS_EXT	;AN005; if no extension found, just continue
 25283 0000344E B000                    	mov	al,0 ; 18/03/2023
 25284                                  	;mov	byte [ext_entered],0
 25285 00003450 A2[E18D]                	mov	[ext_entered],al
 25286                                  				;AN005; we found an extension
 25287                                  	;;mov	al,ANULL	;AN005; continue scanning until the
 25288                                  	;mov	al,0
 25289 00003453 F2AE                    	repnz	scasb		;AN005; end of line is reached.
 25290                                  PROCESS_EXT:
 25291                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25292 00003455 89F9                    	mov	cx,di		; pointer to end of argstring yields
 25293 00003457 29D1                    	sub	cx,dx		; number of bytes to be copied
 25294 00003459 83EB04                  	sub	bx,4		; can argstring fit into dest. buffer?
 25295 0000345C 39D9                    	cmp	cx,bx
 25296 0000345E 7F1B                    	jg	short STRIP_ERROR
 25297                                  				; if not, we must have a bad pathname
 25298 00003460 89F7                    	mov	di,si		; destination buffer
 25299 00003462 89D6                    	mov	si,dx		; source is beginning of pathname
 25300 00003464 FC                      	cld
 25301 00003465 F3A4                    	rep	movsb		; SI=arg,DI=buffer,CX=argend-argbeg
 25302                                  
 25303                                  	; 18/03/2023
 25304                                  	; MSDOS 6.0
 25305 00003467 803E[E18D]01            	cmp	byte [ext_entered],1
 25306                                  				;AN005; if an extension was entered
 25307 0000346C 750A                    	jne	short SKIP_WILDS
 25308                                  				;AN005;    don't set up wildcard ext.
 25309                                  
 25310                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25311 0000346E 4F                      	dec	di		; overwrite null or dot
 25312 0000346F AA                      	stosb			; with a dot
 25313 00003470 B03F                    	mov	al,'?'
 25314                                  	;mov	al,WILDCHAR	; now add wildcards
 25315 00003472 AA                      	stosb
 25316 00003473 AA                      	stosb
 25317 00003474 AA                      	stosb
 25318 00003475 B000                    	mov	al,0
 25319                                  	;mov	al,ANULL	; and a terminating null	
 25320 00003477 AA                      	stosb
 25321                                  SKIP_WILDS:
 25322                                  	;popf	; ** ; 18/03/2023
 25323 00003478 F8                      	clc
 25324 00003479 EB01                    	jmp	short STRIP_EXIT ; chill out...
 25325                                  
 25326                                  STRIP_ERROR:
 25327                                  	;popf	; ** ; 18/03/2023
 25328 0000347B F9                      	stc
 25329                                  STRIP_EXIT:
 25330 0000347C 5E                      	pop	si
 25331 0000347D 5F                      	pop	di
 25332 0000347E 5A                      	pop	dx
 25333 0000347F 59                      	pop	cx
 25334 00003480 5B                      	pop	bx
 25335 00003481 58                      	pop	ax
 25336 00003482 C3                      	retn
 25337                                  
 25338                                  ; =============== S U B	R O U T	I N E =======================================
 25339                                  
 25340                                  ; SAVE_ARGS attempts to preserve the existing argv[]/argvcnt/argbuffer
 25341                                  ;
 25342                                  ; structure in newly allocated memory. The argv[] structure is found at the
 25343                                  ; beginning of this area. The caller indicates how much extra space is
 25344                                  ; needed in the resulting structure; Save_Args returns a segment number and
 25345                                  ; an offset into that area, indicating where the caller may preserve its own
 25346                                  ; data. Note that <argvcnt> can be found at <offset-2>.
 25347                                  ; ENTRY:
 25348                                  ;   BX	    --	size (in bytes) of extra area to allocate
 25349                                  ; EXIT:
 25350                                  ;   AX	    --	segment of new area.
 25351                                  ;   CF	    --	set if unable to save a copy.
 25352                                  ; NOTE(S):
 25353                                  ;   1)	The allocated area will be AT LEAST the size requested -- since
 25354                                  ;	the underlying MSDOS call, <alloc> returns an integral number of
 25355                                  ;	paragraphs.
 25356                                  ;   2)	It is an error if MSDOS can't allocate AT LEAST as much memory
 25357                                  ;	as the caller of Save_Args requests.
 25358                                  ;   3)	AX is undefined if CF indicates an error.
 25359                                  
 25360                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25361                                  
 25362                                  SAVE_ARGS:
 25363 00003483 53                      	push	bx
 25364 00003484 51                      	push	cx
 25365 00003485 52                      	push	dx
 25366 00003486 57                      	push	di
 25367 00003487 56                      	push	si
 25368 00003488 55                      	push	bp
 25369                                  	; 01/05/2023
 25370                                  	; 26/04/2023
 25371                                  	;pushf ; **
 25372                                  	;add	bx,1363		; space for arg structure, round up
 25373 00003489 81C35305                	add	bx,ARG_UNIT.SIZE+15 ; 1348+15
 25374 0000348D B104                    	mov	cl,4		; to paragraph size and convert
 25375 0000348F D3EB                    	shr	bx,cl		; size in bytes to size in paragraphs
 25376 00003491 B80048                  	mov	ax,ALLOC*256 ; 4800h
 25377 00003494 CD21                    	int	21h	; DOS -	2+ - ALLOCATE MEMORY
 25378                                  			; BX = number of 16-byte paragraphs desired
 25379 00003496 7242                    	jc	short SAVE_ERROR ; ***
 25380 00003498 89C5                    	mov	bp,ax		; save segment id
 25381 0000349A 06                      	push	es		; save TRANGROUP address
 25382 0000349B 8EC0                    	mov	es,ax		; switch to new memory segment
 25383                                  	; assume es:nothing
 25384                                  	;mov	cx,1348		; get back structure size
 25385 0000349D B94405                  	mov	cx,ARG_UNIT.SIZE
 25386 000034A0 31FF                    	xor	di,di		; destination is new memory area
 25387                                  	;mov	si,ARG_ARGV
 25388 000034A2 BE[2B8E]                	mov	si,ARG		; source is arg structure
 25389 000034A5 F3A4                    	rep	movsb		; move that sucker!
 25390                                  	;mov	cx,arg.argvcnt 	; adjust argv pointers
 25391                                  	;mov	cx,[ARG_ARGVCNT]
 25392 000034A7 8B0E[EB90]              	mov	cx,[ARG+ARG_UNIT.argvcnt]
 25393 000034AB 31C0                    	xor	ax,ax		; base address for argv_calc
 25394                                  
 25395                                  ;	Bugbug:	What did they mean by this?
 25396                                  ;	Note that the replacement line produces exactly the same code.
 25397                                  ;;	mov	SI, OFFSET TRANGROUP:arg.argbuf - OFFSET arg_unit.argbuf
 25398                                  ;	mov	SI, OFFSET TRANGROUP:arg
 25399                                  
 25400                                  	;mov	si,ARG_ARGV
 25401 000034AD BE[2B8E]                	mov	si,ARG	
 25402                                  SAVE_PTR_LOOP:
 25403 000034B0 49                      	dec	cx		; exhausted all args?
 25404 000034B1 7C24                    	jl	short SAVE_DONE
 25405 000034B3 89CB                    	mov	bx,cx		; get arg index and
 25406 000034B5 E89EFC                  	call	argv_calc	; convert to a pointer
 25407                                  	;mov	dx,ds:arg.argv[bx].argpointer
 25408                                  	;mov	dx,[ARG_ARGV+bx]
 25409 000034B8 8B97[2B8E]              	mov	dx,[ARG+ARGV_ELE.argpointer+bx]
 25410 000034BC 29F2                    	sub	dx,si		; adjust argpointer
 25411                                  	;mov	es:argv[BX].argpointer,dx
 25412                                  	;mov	[es:bx+ARGV_ELE.argpointer],dx ; mov [es:bx+0],dx
 25413 000034BE 268917                  	mov	[es:bx],dx
 25414                                  	;mov	dx,ds:arg.argv[bx].argstartel
 25415                                  	;mov	dx,[ARGV0_ARGSTARTEL+bx]
 25416 000034C1 8B97[2E8E]              	mov	dx,[ARG+ARGV_ELE.argstartel+bx]
 25417 000034C5 29F2                    	sub	dx,si		; and adjust argstartel
 25418                                  	;mov	es:argv[bx].argstartel,dx
 25419                                  	;mov	[es:bx+3],dx
 25420 000034C7 26895703                	mov	[es:bx+ARGV_ELE.argstartel],dx
 25421                                  	;mov	dx,ds:arg.argv[bx].arg_ocomptr
 25422                                  	;mov	dx,[ARGV0_OCOMPTR+bx]
 25423 000034CB 8B97[348E]              	mov	dx,[ARG+ARGV_ELE.arg_ocomptr+bx]
 25424 000034CF 29F2                    	sub	dx,si		; and adjust arg_ocomptr
 25425                                  	;mov	es:argv[bx].arg_ocomptr,dx
 25426                                  	;mov	[es:bx+9],dx
 25427 000034D1 26895709                	mov	[es:bx+ARGV_ELE.arg_ocomptr],dx
 25428 000034D5 EBD9                    	jmp	short SAVE_PTR_LOOP
 25429                                  SAVE_DONE:
 25430 000034D7 07                      	pop	es		; back we go to TRANGROUP
 25431                                  	; assume es:nothing
 25432 000034D8 89E8                    	mov	ax,bp		; restore segment id
 25433                                  	; 26/04/2023
 25434                                  	; cf = 0 ; *
 25435                                  	;jmp	short SAVE_OK
 25436                                  
 25437                                  	; 26/04/2023
 25438                                  ;SAVE_ERROR:
 25439                                  ;	; 26/04/2023
 25440                                  ;	;popf ; **
 25441                                  ;	stc
 25442                                  ;	jmp	short SAVE_EXIT
 25443                                  
 25444                                  SAVE_OK:
 25445                                  	; 26/04/2023
 25446                                  	;popf ; **
 25447                                  	; 26/04/2023
 25448                                  	; cf = 0 ; *
 25449                                  	;clc
 25450                                  SAVE_EXIT:
 25451                                  SAVE_ERROR:	; 26/04/2023 (cf=1) ; ***
 25452 000034DA 5D                      	pop	bp
 25453 000034DB 5E                      	pop	si
 25454 000034DC 5F                      	pop	di
 25455 000034DD 5A                      	pop	dx
 25456 000034DE 59                      	pop	cx
 25457 000034DF 5B                      	pop	bx
 25458                                  answ_no:	; 26/04/2023
 25459 000034E0 C3                      	retn
 25460                                  
 25461                                  ;============================================================================
 25462                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (1)
 25463                                  ;============================================================================
 25464                                  ; 02/10/2018 - Retro DOS v3.0
 25465                                  
 25466                                  ; Title	COMMAND Language midifiable Code Transient
 25467                                  
 25468                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2843h
 25469                                  
 25470                                  ; =============== S U B	R O U T	I N E =======================================
 25471                                  
 25472                                  ; ****************************************************************
 25473                                  ; *
 25474                                  ; * ROUTINE:	 NOTEST2 - execution of DEL/ERASE command
 25475                                  ; *
 25476                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25477                                  ; *		 user for Y/N if necessary. If an error occurs,
 25478                                  ; *		 set up an error message and go to CERROR.
 25479                                  ; *
 25480                                  ; * INPUT:	 FCB at 5ch set up with filename(s) entered
 25481                                  ; *		 Current directory set to entered directory
 25482                                  ; *
 25483                                  ; * OUTPUT:	 none
 25484                                  ; *
 25485                                  ; ****************************************************************
 25486                                  ;
 25487                                  ; ARE YOU SURE prompt when deleting *.*
 25488                                  
 25489                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25490                                  
 25491                                  notest2:
 25492 000034E1 B90B00                  	mov	cx,11
 25493 000034E4 BE5D00                  	mov	si,FCB+1 ; 5Dh
 25494                                  ambspec:
 25495 000034E7 AC                      	lodsb
 25496 000034E8 3C3F                    	cmp	al,'?'
 25497 000034EA 7502                    	jne	short allfil
 25498 000034EC E2F9                    	loop	ambspec
 25499                                  allfil:
 25500                                  	; 19/03/2023
 25501                                  	;cmp	cx,0
 25502 000034EE 09C9                    	or	cx,cx
 25503 000034F0 752E                    	jnz	short noprmpt
 25504                                  askagn:	
 25505 000034F2 BA[1080]                	mov	dx,SureMes_Ptr	; "Are you sure (Y/N)?"
 25506 000034F5 E80B19                  	call	std_printf
 25507 000034F8 BE8000                  	mov	si,80h
 25508 000034FB 89F2                    	mov	dx,si
 25509 000034FD C7047800                	mov	word [si],120	; zero length
 25510                                  	;mov	ax,0C0Ah
 25511 00003501 B80A0C                  	mov	ax,(STD_CON_INPUT_FLUSH<<8)|Std_Con_String_Input
 25512 00003504 CD21                    	int	21h	; DOS -	CLEAR KEYBOARD BUFFER
 25513                                  			; AL must be 01h,06h,07h,08h or 0Ah.
 25514 00003506 AD                      	lodsw
 25515 00003507 08E4                    	or	ah,ah
 25516 00003509 74E7                    	jz	short askagn
 25517 0000350B E8C9F0                  	call	scanoff
 25518                                  	; 19/03/2023
 25519                                  	; MSDOS 6.0
 25520 0000350E E80C02                  	call	char_in_xlat	; Convert to upper case
 25521                                  	;retc			; return if function not supported
 25522                                  	; 19/03/2023
 25523                                  	;jnc	short check_yn
 25524                                  ;answ_no:
 25525                                  	;retn
 25526 00003511 72CD                    	jc	short answ_no
 25527                                  
 25528                                  	; 19/03/2023
 25529                                  	; AL = 0 if it was (country depended) NO character
 25530                                  	; AL = 1 if it was (country depenced) YES character
 25531                                  
 25532                                  	; MSDOS 3.3
 25533                                  	;call	UPCONV
 25534                                  
 25535                                  	; 19/03/2023	
 25536                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25537                                  	;cmp	al,[CAPITAL_N]
 25538                                  	;jne	short CHECK_Y
 25539                                  	;retn
 25540                                  ;CHECK_Y:
 25541                                  	;cmp	al,[CAPITAL_Y]
 25542                                  	;pushf
 25543                                  	;call	CRLF2
 25544                                  	;popf
 25545                                  	;jne	short ASKAGN
 25546                                  
 25547                                  check_yn:
 25548                                  	; 19/03/2023
 25549                                  	;cmp	al,0	; NO character
 25550 00003513 08C0                    	or	al,al
 25551 00003515 74C9                    	jz	short answ_no
 25552                                  	;cmp	al,1	 ;YES character
 25553 00003517 FEC8                    	dec	al ; 1 -> 0 --> zf = 1
 25554 00003519 9C                      	pushf
 25555 0000351A E8ADF0                  	call	CRLF2
 25556 0000351D 9D                      	popf
 25557 0000351E 75D2                    	jnz	short askagn
 25558                                  noprmpt:
 25559 00003520 B413                    	mov	ah,FCB_Delete ; 13h
 25560 00003522 BA5C00                  	mov	dx,FCB ; 5Ch
 25561 00003525 CD21                    	int	21h	; DOS -	DELETE FILE via	FCB
 25562                                  			; DS:DX	-> FCB with filename field filled with
 25563                                  			; template for deletion ('?' wildcard allowed,but not '*')
 25564                                  			; Return: AL = 00h file	found,FFh file	not found
 25565 00003527 FEC0                    	inc	al
 25566 00003529 7403                    	jz	short eraerr
 25567                                  	; 26/04/2023
 25568                                  	;call	RestUDir
 25569                                  ;answ_no:
 25570                                  	;retn
 25571 0000352B E959EF                  	jmp	RestUDir ; 26/04/2023
 25572                                  
 25573                                  	; 19/03/2023
 25574                                  	; MSDOS 6.0
 25575                                  eraerr:
 25576                                  	;invoke	set_ext_error_msg
 25577                                  				;AN022; set up the extended error
 25578 0000352E E8BBE7                  	call	Set_Ext_Error_Msg
 25579 00003531 52                      	push	dx		;AN022; save message
 25580                                  	;invoke	RESTUDIR
 25581 00003532 E852EF                  	call	RestUDir
 25582 00003535 5A                      	pop	dx		;AN022; restore message
 25583                                  	
 25584 00003536 833E[317F]12            	cmp	word [extend_buf_ptr],ERROR_NO_MORE_FILES ; 18
 25585                                  				;AN022; convert no more files to
 25586 0000353B 7506                    	jne	short cerrorj2	;AN022;  file not found
 25587 0000353D C706[317F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2  
 25588                                  				;AN000; get message number in control block
 25589                                  cerrorj2:
 25590 00003543 E905F4                  	jmp	cerror
 25591                                  	
 25592                                  	; 19/03/2023
 25593                                  	; MSDOS 3.3
 25594                                  ;ERAERR:	
 25595                                  	;mov	ah,Set_DMA ; 1Ah
 25596                                  	;mov	dx,FCB ; 5Ch
 25597                                  	;int	21h		; DOS -	SET DISK TRANSFER AREA ADDRESS
 25598                                  	;			; DS:DX	-> disk	transfer buffer
 25599                                  	;mov	ah,Dir_Search_First ; 11h
 25600                                  	;int	21h		; DOS -	SEARCH FIRST USING FCB
 25601                                  	;			; DS:DX	-> FCB
 25602                                  	;push	ax
 25603                                  	;call	RESTUDIR
 25604                                  	;pop	ax
 25605                                  	;mov	dx,FNOTFOUNDPTR
 25606                                  	;inc	al
 25607                                  	;jz	short CERRORJ
 25608                                  	;mov	dx,ACCDENPTR
 25609                                  	;jmp	CERROR
 25610                                  
 25611                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25612                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:36D4h
 25613                                  
 25614                                  ; ****************************************************************
 25615                                  ; *
 25616                                  ; * ROUTINE:	 SLASHP_ERASE - execution of DEL/ERASE /P
 25617                                  ; *
 25618                                  ; * FUNCTION:	 Delete files based on user parsed input. Prompt
 25619                                  ; *		 user for Y/N where necessary. If an error occurs
 25620                                  ; *		 set up and error message and transfer control
 25621                                  ; *		 to CERROR.
 25622                                  ; *
 25623                                  ; * INPUT:	 FCB at 5Ch set up with filename(s) entered
 25624                                  ; *		 Current directory set to entered directory
 25625                                  ; *
 25626                                  ; * OUTPUT:	 none
 25627                                  ; *
 25628                                  ; ****************************************************************
 25629                                  
 25630                                  	; 19/03/2023
 25631                                  slashp_erase:				;AN000; entry point
 25632                                  	;invoke	build_dir_string	;AN000; set up current directory string for output
 25633 00003546 E8FCE8                  	call	build_dir_string
 25634                                  
 25635 00003549 B41A                    	mov	ah,Set_DMA ; 1Ah	;AN000; issue set dta int 21h
 25636                                  	;mov	dx,offset trangroup:destdir
 25637 0000354B BA[628B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25638 0000354E CD21                    	int	21h			;AN000;
 25639                                  
 25640                                  	;mov	ah,11h
 25641 00003550 B411                    	mov	ah,Dir_Search_First	;AN000; do dir search first int 21h
 25642 00003552 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000; use FCB at 5Ch for target
 25643 00003555 CD21                    	int	21h			;AN000;
 25644 00003557 FEC0                    	inc	al			;AN000; did an error occur
 25645                                  	;jz	short eraerr		;AN022; go to error exit
 25646                                  	; 26/04/2023
 25647 00003559 7502                    	jnz	short delete_prompt_loop
 25648                                  
 25649                                  	; 26/04/2023
 25650                                  stop_del:
 25651 0000355B EBD1                    	jmp	short eraerr		;AN022; go to error exit - need long jmp
 25652                                  
 25653                                  delete_prompt_loop:			;AN000;
 25654                                  	;mov	si,offset trangroup:destdir+1
 25655 0000355D BE[638B]                	mov	si,DESTDIR+1		;AN000; set up FCB as source
 25656                                  	;mov	di,offset trangroup:dest
 25657 00003560 BF[328B]                	mov	di,DEST			;AN000; set up dest as target
 25658 00003563 A0[A18A]                	mov	al,[DIRCHAR]		;AN000; store a "\" in the first char
 25659 00003566 AA                      	stosb				;AN000;   of DEST
 25660                                  	;invoke	FCB_TO_ASCZ		;AN000; convert filename from FCB to ASCIIZ string
 25661 00003567 E88CF0                  	call	FCB_TO_ASCZ
 25662                                  
 25663                                  slashp_askagn:				;AN000;
 25664 0000356A E85DF0                  	call	CRLF2			;AN000; print out carriage return, line feed
 25665                                  	;mov	dx,offset trangroup:bwdbuf
 25666 0000356D BA[A58B]                	mov	dx,BWDBUF		;AN000; print out current directory string
 25667 00003570 89D3                    	mov	bx,dx			;AN000; get string pointer in bx
 25668 00003572 807F0300                	cmp	byte [bx+3],END_OF_LINE_OUT ; 0
 25669                                  					;AN000; see if only D:\,0
 25670 00003576 7504                    	jnz	short not_del_root	;AN000; no continue
 25671 00003578 C6470200                	mov	byte [bx+2],END_OF_LINE_OUT ; 0
 25672                                  					;AN000; yes, get rid of \ ;
 25673                                  not_del_root:				;AN000;
 25674 0000357C 8916[8C8C]              	mov	[string_ptr_2],dx 	;AN000;
 25675                                  	;mov	dx,offset trangroup:string_buf_ptr
 25676 00003580 BA[F880]                	mov	dx,string_buf_ptr	;AN000;
 25677                                  	;invoke	std_printf		;AN000;
 25678 00003583 E87D18                  	call	std_printf
 25679                                  	;mov	dx,offset trangroup:dest
 25680 00003586 BA[328B]                	mov	dx,DEST			;AN000; print out file name string
 25681 00003589 8916[8C8C]              	mov	[string_ptr_2],dx 	;AN000;
 25682                                  	;mov	dx,offset trangroup:string_buf_ptr
 25683 0000358D BA[F880]                	mov	dx,string_buf_ptr	;AN000;
 25684                                  	;invoke	std_printf		;AN000;
 25685 00003590 E87018                  	call	std_printf
 25686                                  	;mov	dx,offset trangroup:Del_Y_N_Ptr
 25687 00003593 BA[0D80]                	mov	dx,Del_Y_N_Ptr		;AN000; issue ", Delete (Y/N)?" message
 25688                                  	;invoke	std_printf		;AN000;
 25689 00003596 E86A18                  	call	std_printf
 25690                                  
 25691                                  ;;M029	mov	si,80H			;AN000; set up buffer for input
 25692                                  ;;M029	mov	dx,si			;AN000;
 25693                                  ;;M029	mov	word ptr [si],combuflen ;AN000;
 25694                                  ;;M029	mov	ax,(std_con_input_flush shl 8) or std_con_string_input	;AN000;
 25695                                  ;;M029	int	21h			;AN000; get input from the user
 25696                                  ;;M029	lodsw				;AN000;
 25697                                  ;;M029	or	ah,ah			;AN000; was a character entered?
 25698                                  ;;M029	jz	short slashp_askagn	;AN000; no - ask again
 25699                                  ;;M029	invoke	scanoff 		;AN000; scan off leading delimiters
 25700                                  
 25701                                  ;	Get a single character input.
 25702                                  
 25703                                  	;;mov	ax,(STD_CON_INPUT_FLUSH shl 8) or STD_CON_INPUT	;M029
 25704                                  	;mov	ax,(STD_CON_INPUT_FLUSH<<8)|STD_CON_INPUT
 25705 00003599 B8010C                  	mov	ax,0C01h
 25706 0000359C CD21                    	int	21h			;M029
 25707                                  
 25708 0000359E E87C01                  	call	char_in_xlat		;AN000; yes - upper case it
 25709                                  	;retc				;AN000; return if function not supported
 25710                                  	; 19/03/2023
 25711 000035A1 7301                    	jnc	short slashp_check_yn
 25712                                  slashp_ans_no:
 25713 000035A3 C3                      	retn
 25714                                  
 25715                                  slashp_check_yn:
 25716                                  	; 19/03/2023
 25717                                  	; AL = 0 if it was (country depended) NO character
 25718                                  	; AL = 1 if it was (country depenced) YES character
 25719                                  
 25720                                  	;cmp	al,capital_n		;AN000; was it no?
 25721                                  	;cmp	al,0
 25722 000035A4 20C0                    	and	al,al ; 0
 25723 000035A6 7420                    	jz	short next_del_file	;AN000; yes - don't delete file
 25724                                  	;cmp	al,capital_y		;AN000; was it yes?
 25725                                  	;cmp	al,1
 25726 000035A8 FEC8                    	dec	al  ; 1-> 0 --> zf = 1
 25727                                  	;jz	short delete_this_file	;AN000; yes - delete the file
 25728                                  	;jmp	short slashp_askagn	;AN000; it was neither - ask again
 25729                                  	; 19/03/2023
 25730 000035AA 75BE                    	jnz	short slashp_askagn
 25731                                  
 25732                                  delete_this_file:			;AN000;
 25733 000035AC B413                    	mov	ah,FCB_Delete ; 13h	;AN000; delete the file
 25734                                  	;mov	dx,offset trangroup:destdir
 25735 000035AE BA[628B]                	mov	dx,DESTDIR		;AN000; use Destdir for target
 25736 000035B1 CD21                    	int	21h			;AN000;
 25737 000035B3 FEC0                    	inc	al			;AN000; did an error occur?
 25738 000035B5 7511                    	jnz	short next_del_file	;AN000; no - get next file
 25739                                  ;
 25740                                  ;M041; Begin changes
 25741                                  ; We got an error deleting the file. If this is access denied, we can go on
 25742                                  ;to the next file after printing an error message.
 25743                                  ;
 25744                                  	;invoke	Get_ext_error_number	;see what error we got
 25745 000035B7 E842E7                  	call	get_ext_error_number
 25746 000035BA 83F805                  	cmp	ax,ERROR_ACCESS_DENIED ; 5
 25747                                  					;is it access denied?
 25748 000035BD 759C                    	jne	short stop_del		;no, some other error
 25749                                  	;invoke	CrLf2			;print a CR-LF
 25750 000035BF E808F0                  	call	CRLF2
 25751                                  	;invoke set_ext_error_msg	;error message
 25752 000035C2 E827E7                  	call	Set_Ext_Error_Msg
 25753                                  	;invoke	std_eprintf		;"Access denied"
 25754 000035C5 E83318                  	call	std_eprintf
 25755                                  	; 26/04/2023
 25756                                  	;jmp	short next_del_file	;try next file
 25757                                  	; 26/04/2023
 25758                                  ;stop_del:
 25759                                  ;;
 25760                                  ;;M041; End changes
 25761                                  ;;
 25762                                  ;	jmp	eraerr			;AN022; go to error exit - need long jmp
 25763                                  
 25764                                  next_del_file:				;AN000;
 25765                                  ;
 25766                                  ; M050 - begin
 25767                                  ; 	Norton Utilities 5.0 has a bug. DiskMon when invoked
 25768                                  ;       with /protect+ and /light+ makes it intercept all
 25769                                  ;       deletes. This hook does not save and restore the DTA correctly.
 25770                                  ;       They save the DWORD in a WORD by mistake! They save both the
 25771                                  ;       segment and the offset in the SAME variable (WORD)!!!
 25772                                  ;
 25773 000035C8 B41A                    	mov	ah,Set_DMA ; 1Ah
 25774                                  	;mov	dx,offset trangroup:destdir
 25775 000035CA BA[628B]                	mov	dx,DESTDIR
 25776 000035CD CD21                    	int	21h
 25777                                  ;
 25778                                  ; M050 - end
 25779                                  
 25780 000035CF B412                    	mov	ah,Dir_Search_Next ; 12h
 25781                                  					;AN000; search for another file
 25782 000035D1 BA5C00                  	mov	dx,FCB	; 5Ch		;AN000;
 25783 000035D4 CD21                    	int	21h			;AN000;
 25784 000035D6 FEC0                    	inc	al			;AN000; was a file found?
 25785                                  	;jz	short slash_p_exit	;AN000; no - exit
 25786                                  	;jmp	delete_prompt_loop	;AN000; yes - continue (need long jump)
 25787                                  	; 26/04/2023
 25788 000035D8 7583                    	jnz	short delete_prompt_loop
 25789                                  
 25790                                  slash_p_exit:
 25791                                  	;invoke	get_ext_error_number	;AN022; get the extended error number
 25792 000035DA E81FE7                  	call	get_ext_error_number
 25793 000035DD 83F812                  	cmp	ax,ERROR_NO_MORE_FILES	;AN022; was error file not found?
 25794 000035E0 7403                    	jz	short good_erase_exit 	;AN022; yes - clean exit
 25795 000035E2 E95AE4                  	jmp	extend_setup		;AN022; go issue error message
 25796                                  
 25797                                  good_erase_exit:
 25798                                  	;invoke	restudir		;AN000; we're finished - restore user's dir
 25799 000035E5 E89FEE                  	call	RestUDir
 25800                                  	;call	CRLF2			;AN000; print out carriage return, line feed
 25801                                  	;retn				;AN000; exit
 25802                                  	; 19/03/2023
 25803 000035E8 E9DFEF                  	jmp	CRLF2
 25804                                  
 25805                                  ; =============== S U B	R O U T	I N E =======================================
 25806                                  
 25807                                  ; ECHO, BREAK, and VERIFY commands. Check for "ON" and "OFF"
 25808                                  
 25809                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 25810                                  _ECHO:
 25811 000035EB E89900                  	call	ON_OFF
 25812 000035EE 7212                    	jb	short DOEMES
 25813 000035F0 8E1E[9C8A]              	mov	ds,[RESSEG]
 25814 000035F4 7506                    	jnz	short ECH_OFF
 25815 000035F6 800E[A001]01            	or	byte [EchoFlag],1
 25816 000035FB C3                      	retn
 25817                                  
 25818                                  ECH_OFF:
 25819 000035FC 8026[A001]FE            	and	byte [EchoFlag],0FEh
 25820 00003601 C3                      	retn
 25821                                  
 25822                                  	; 19/03/2023
 25823                                  	; MSDOS 6.0 (& MSDOS 5.0)
 25824                                  ;CERRORJ:
 25825                                  	;jmp	cerror
 25826                                  
 25827                                  ; There was no discrenable ON or OFF after the ECHO. If there is nothing but
 25828                                  ; delimiters on the command line, we issue the ECHO is ON/OFF message.
 25829                                  
 25830                                  DOEMES:
 25831                                  	; 19/03/2023
 25832                                  	; MSDOS 6.0
 25833                                  	;cmp	cl,0		;AC000; was anything on the line?
 25834 00003602 20C9                    	and	cl,cl
 25835 00003604 7409                    	jz	short PECHO	; just display current state.
 25836 00003606 BA8200                  	mov	dx,82h		; Skip one char after "ECHO"
 25837 00003609 E817F0                  	call	CRPRINT
 25838 0000360C E9BBEF                  	jmp	CRLF2
 25839                                  
 25840                                  	; 19/03/2023
 25841                                  	; MSDOS 3.3
 25842                                  	;call	MOVE_TO_FIRST_ARG
 25843                                  	;jz	short PECHO
 25844                                  	;mov	dx,82h
 25845                                  	;call	CRPRINT
 25846                                  	;jmp	CRLF2
 25847                                  
 25848                                  PECHO:
 25849                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25850 0000360F 8E1E[9C8A]              	mov	ds,[RESSEG]
 25851 00003613 8A1E[A001]              	mov	bl,[EchoFlag]
 25852 00003617 0E                      	push	cs
 25853 00003618 1F                      	pop	ds
 25854 00003619 80E301                  	and	bl,1
 25855 0000361C BA[B480]                	mov	dx,EchoMes_Ptr
 25856 0000361F EB24                    	jmp	short PYN
 25857                                  
 25858                                  ; ---------------------------------------------------------------------------
 25859                                  
 25860                                  	; 19/03/2023
 25861                                  	; MSDOS 3.3
 25862                                  CERRORJ:
 25863 00003621 E927F3                  	jmp	cerror
 25864                                  
 25865                                  ; =============== S U B	R O U T	I N E =======================================
 25866                                  
 25867                                  	; 19/03/2023
 25868                                  	; MSDOS 3.3
 25869                                  ;MOVE_TO_FIRST_ARG:
 25870                                  	;mov	si,81h
 25871                                  	;call	SCANOFF
 25872                                  	;cmp	al,0Dh
 25873                                  	;retn
 25874                                  
 25875                                  ; =============== S U B	R O U T	I N E =======================================
 25876                                  
 25877                                  CNTRLC:
 25878 00003624 E86000                  	call	ON_OFF
 25879 00003627 B80133                  	mov	ax,(Set_CTRL_C_Trapping<<8)|1 ; 3301h
 25880 0000362A 720C                    	jc	short PCNTRLC
 25881 0000362C 7505                    	jnz	short CNTRLC_OFF
 25882 0000362E B201                    	mov	dl,1
 25883 00003630 CD21                    	int	21h	; DOS -	EXTENDED CONTROL-BREAK CHECKING
 25884                                  			; AL = 00h get state / 01h set state / 02h set AND get
 25885                                  			; DL = 00h for OFF or 01h for ON
 25886 00003632 C3                      	retn
 25887                                  
 25888                                  ; ---------------------------------------------------------------------------
 25889                                  
 25890                                  CNTRLC_OFF:
 25891 00003633 30D2                    	xor	dl,dl
 25892 00003635 CD21                    	int	21h		; Turn off ^C check
 25893 00003637 C3                      	retn
 25894                                  
 25895                                  ; ---------------------------------------------------------------------------
 25896                                  
 25897                                  PCNTRLC:
 25898                                  	; 19/03/2023
 25899                                  	; MSDOS 6.0
 25900                                  	;cmp	cl,0		;AC000; rest of line blank?
 25901 00003638 08C9                    	or	cl,cl
 25902 0000363A 75E5                    	jnz	short CERRORJ 	; no, oops!
 25903                                  
 25904                                  	; 19/03/2023
 25905                                  	; MSDOS 3.3
 25906                                  	;call	MOVE_TO_FIRST_ARG
 25907                                  	;jnz	short CERRORJ
 25908                                  ;pccont:
 25909                                  	; MSDOS 3.3 (& MSDOS 6.0)
 25910 0000363C 30C0                    	xor	al,al
 25911 0000363E CD21                    	int	21h		; get Ctrl-Break state (ah=33h)
 25912 00003640 88D3                    	mov	bl,dl
 25913 00003642 BA[9880]                	mov	dx,CtrlcMes_Ptr
 25914                                  
 25915                                  ; ---------------------------------------------------------------------------
 25916                                  
 25917                                  PYN:	; write "ON" or "OFF" state 
 25918                                  
 25919                                  	; 26/04/2023
 25920                                  	; 19/03/2023
 25921                                  	; MSDOS 3.3
 25922                                  	;call	STD_PRINTF
 25923                                  	;mov	dx,ONMES_PTR	;AC000; get ON pointer
 25924                                  	;or	bl,bl
 25925                                  	;jnz	short PRINTVAL
 25926                                  	;mov	dx,OFFMES_PTR	;AC000; get OFF pointer
 25927                                  	
 25928                                  	; 26/04/2023
 25929                                  	; 19/03/2023
 25930                                  	; MSDOS 6.0
 25931 00003645 BE[C580]                	mov	si,ONMES_PTR
 25932 00003648 08DB                    	or	bl,bl
 25933 0000364A 7503                    	jnz	short PRINTVAL
 25934 0000364C BE[C280]                	mov	si,OFFMES_PTR
 25935                                  PRINTVAL:
 25936                                  	; 19/03/2023
 25937                                  	; MSDOS 3.3
 25938                                  	;jmp	STD_PRINTF
 25939                                  
 25940                                  	; 19/03/2023
 25941                                  	; MSDOS 6.0
 25942 0000364F 52                      	push	dx		;AN000; save offset of message block
 25943 00003650 89D3                    	mov	bx,dx		;AN000; save offset value
 25944 00003652 AD                      	lodsw			;AN000; get message number of on or off
 25945 00003653 B6FF                    	mov	dh,util_msg_class ; -1 ; 0FFh
 25946                                  				;AN000; this is a utility message
 25947 00003655 E89218                  	call	TSYSGETMSG	;AN000; get the address of the message
 25948                                  	;add	bx,5
 25949 00003658 83C305                  	add	bx,Ptr_off_pos	;AN000; point to offset of ON/OFF
 25950                                  	
 25951 0000365B 8937                    	mov	[bx],si		;AN000; put the offset in the message block
 25952 0000365D 5A                      	pop	dx		;AN000; get message back
 25953 0000365E E8A217                  	call	std_printf	;AC000; go print message
 25954 00003661 C7070000                	mov	word [bx],0	;AN000; zero out message pointer
 25955 00003665 C3                      	retn			;AN000; exit
 25956                                  
 25957                                  ; =============== S U B	R O U T	I N E =======================================
 25958                                  
 25959                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.CO
 25960                                  VERIFY:
 25961 00003666 E81E00                  	call	ON_OFF
 25962 00003669 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 25963 0000366C 720A                    	jc	short PVERIFY
 25964 0000366E 7503                    	jnz	short VER_OFF
 25965 00003670 CD21                    	int	21h	; DOS -	SET VERIFY FLAG
 25966                                  			; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 25967 00003672 C3                      	retn
 25968                                  
 25969                                  ; ---------------------------------------------------------------------------
 25970                                  
 25971                                  VER_OFF:
 25972 00003673 FEC8                    	dec	al
 25973 00003675 CD21                    	int	21h		; Turn off verify after write
 25974 00003677 C3                      	retn
 25975                                  
 25976                                  ; ---------------------------------------------------------------------------
 25977                                  
 25978                                  PVERIFY:
 25979                                  	; 19/03/2023
 25980                                  	; MSDOS 6.0
 25981                                  	;cmp	cl,0		;AC000; is rest of line blank?
 25982 00003678 20C9                    	and	cl,cl
 25983 0000367A 75A5                    	jnz	short CERRORJ 	; nope...
 25984                                  
 25985                                  	 ;19/03/2023
 25986                                  	; MSDOS 3.3
 25987                                  	;call	MOVE_TO_FIRST_ARG
 25988                                  	;jnz	short CERRORJ
 25989                                  
 25990 0000367C B454                    	mov	ah,Get_Verify_On_Write ; 54h
 25991 0000367E CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 25992                                  				; Return: AL = 00h if flag OFF
 25993                                  				; AL = 01h if flag ON
 25994 00003680 88C3                    	mov	bl,al
 25995 00003682 BA[A680]                	mov	dx,VeriMes_Ptr
 25996 00003685 EBBE                    	jmp	short PYN
 25997                                  
 25998                                  ; =============== S U B	R O U T	I N E =======================================
 25999                                  
 26000                                  ; ****************************************************************
 26001                                  ; *
 26002                                  ; * ROUTINE:	 ON_OFF
 26003                                  ; *
 26004                                  ; * FUNCTION:	 Parse the command line for an optional ON or
 26005                                  ; *		 OFF string for the BREAK, VERIFY, and ECHO
 26006                                  ; *		 routines.
 26007                                  ; *
 26008                                  ; * INPUT:	 command line at offset 81H
 26009                                  ; *		 PARSE_BREAK control block
 26010                                  ; *
 26011                                  ; * OUTPUT:	 If carry is clear
 26012                                  ; *		    If ON is found
 26013                                  ; *		       Zero flag set
 26014                                  ; *		    If OFF is found
 26015                                  ; *		       Zero flag clear
 26016                                  ; *		 If carry set
 26017                                  ; *		    If nothing on command line
 26018                                  ; *		       CL set to zero
 26019                                  ; *		    If error
 26020                                  ; *		       CL contains error value from parse
 26021                                  ; *
 26022                                  ; ****************************************************************
 26023                                  
 26024                                  	; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26025                                  ON_OFF:
 26026 00003687 BE8100                  	mov	si,81h
 26027                                  
 26028                                  	; 19/03/2023
 26029                                  	; MSDOS 3.3
 26030                                  	;call	SCANOFF		; scan off leading blanks & equal
 26031                                  	;cmp	al,0Dh		; are we at end of line?
 26032                                  	;je	short BAD_ONF	; yes, return error
 26033                                  	;lodsw
 26034                                  	;or	ax,2020h	; convert to lowercase
 26035                                  	;cmp	ax,6E6Fh ;'on'
 26036                                  	;je	short ON_CHECK
 26037                                  	;cmp	ax,666Fh ;'of'
 26038                                  	;jne	short BAD_ONF
 26039                                  	;lodsb
 26040                                  	;or	al,20h		; convert to lowercase		
 26041                                  	;cmp	al,66h	 ; 'f'
 26042                                  	;jne	short BAD_ONF	
 26043                                  	;or	al,66h ; or al,'f'
 26044                                  	;jmp	short OFF_CHECK
 26045                                  ;ON_CHECK:
 26046                                  	;xor	al,al
 26047                                  ;OFF_CHECK:
 26048                                  	;lahf
 26049                                  	;mov	bx,ax
 26050                                  	;call	SCANOFF		; scan off leading blanks & equal
 26051                                  	;cmp	al,0Dh		; are we at end of line?	
 26052                                  	;jne	short BAD_ONF	; no, return error
 26053                                  	;mov	ax,bx
 26054                                  	;sahf
 26055                                  	;clc
 26056                                  	;retn
 26057                                  
 26058                                  	; 19/03/2023
 26059                                  	; MSDOS 6.0
 26060                                  scan_on_off:			;AN032; scan off leading blanks & equal
 26061 0000368A AC                      	lodsb			;AN032; get a char
 26062                                  	;cmp	al,blank	;AN032; if whitespace
 26063 0000368B 3C20                    	cmp	al,20h
 26064 0000368D 74FB                    	je	short scan_on_off
 26065                                  				;AN032;    keep scanning
 26066 0000368F 3C09                    	cmp	al,tab_chr	;AN032; if tab
 26067                                  	;cmp	al,09h
 26068 00003691 74F7                    	je	short scan_on_off
 26069                                  				;AN032;    keep scanning
 26070                                  	;cmp	al,equal_chr	;AN032; if equal char
 26071 00003693 3C3D                    	cmp	al,'=' ; 3Dh
 26072 00003695 7401                    	je	short parse_on_off
 26073                                  				;AN032;    start parsing
 26074 00003697 4E                      	dec	si		;AN032; if none of above - back up
 26075                                  
 26076                                  parse_on_off:			;AN032;    and start parsing
 26077 00003698 BF[A584]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26078 0000369B 31C9                    	xor	cx,cx		;AN000; clear cx,dx
 26079 0000369D 31D2                    	xor	dx,dx		;AN000;
 26080 0000369F E88E0C                  	call	cmd_parse	;AC000; call parser
 26081                                  	;cmp	ax,-1 ; 0FFFFh
 26082 000036A2 83F8FF                  	cmp	ax,END_OF_LINE	;AC000; are we at end of line?
 26083 000036A5 742E                    	je	short BADONF	;AC000; yes, return error
 26084                                  	;cmp	ax,RESULT_NO_ERROR ;AN000; did an error occur
 26085                                  	;cmp	ax,0
 26086 000036A7 21C0                    	and	ax,ax ; ax = 0 ?
 26087 000036A9 7404                    	jz	short on_off_there
 26088                                  				;AN000; no - continue
 26089 000036AB 89C1                    	mov	cx,ax		;AN000; yes - set cl to error code
 26090 000036AD EB26                    	jmp	short BADONF	;AN000; return error
 26091                                  
 26092                                  on_off_there:
 26093 000036AF 803E[CC95]FF            	cmp	byte [PARSE1_CODE],-1 ; 0FFh
 26094                                  				;AN014; was a valid positional present?
 26095 000036B4 7505                    	jnz	short good_on_off
 26096                                  				;AN014; yes - continue
 26097 000036B6 B90A00                  	mov	cx,BadParm_Ptr	;AN014; something other than ON/OFF
 26098                                  	;mov	cx,10 ; 0Ah
 26099 000036B9 EB1A                    	jmp	short BADONF	;AN014; return error
 26100                                  
 26101                                  good_on_off:				;AN014;
 26102 000036BB 31C0                    	xor	ax,ax		;AC000; set up return code for
 26103 000036BD 0A06[CC95]              	or	al,[PARSE1_CODE]
 26104                                  				;AC000;    ON or OFF in AX
 26105 000036C1 9C                      	pushf			;AN000; save flags
 26106 000036C2 BF[A584]                	mov	di,PARSE_BREAK	;AN000; Get address of PARSE_BREAK
 26107 000036C5 31D2                    	xor	dx,dx		;AN000;
 26108 000036C7 E8660C                  	call	cmd_parse	;AN000; call parser
 26109 000036CA 83F8FF                  	cmp	ax,END_OF_LINE	;AN000; are we at end of line?
 26110                                  	;cmp	ax,-1 ; 0FFFFh
 26111 000036CD 7503                    	jne	short BADONF_flags
 26112                                  				;AN000; NO, return error
 26113 000036CF 9D                      	popf			;AN000; restore flags
 26114 000036D0 F8                      	clc			;AC000; no error
 26115                                  	;jmp	short on_off_end
 26116                                  				;AN000; return to caller
 26117                                  	; 26/04/2023
 26118 000036D1 C3                      	retn
 26119                                  
 26120                                  BADONF_flags:
 26121 000036D2 89C1                    	mov	cx,ax
 26122 000036D4 9D                      	popf
 26123                                  
 26124                                  ; ---------------------------------------------------------------------------
 26125                                  
 26126                                  ; No discernable ON or OFF has been found. Put an error message pointer in DX
 26127                                  ; and return the error
 26128                                  
 26129                                  BADONF:
 26130 000036D5 BA[7580]                	mov	dx,bad_on_off_ptr
 26131 000036D8 F9                      	stc
 26132                                  on_off_end:
 26133 000036D9 C3                      	retn
 26134                                  
 26135                                  ; 19/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26136                                  %if 0
 26137                                  
 26138                                  ;============================================================================
 26139                                  ; TCMD1B.ASM, MSDOS 6.0, 1991
 26140                                  ;============================================================================
 26141                                  ; 02/10/2018 - Retro DOS v3.0
 26142                                  
 26143                                  ; Print volume ID info
 26144                                  
 26145                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2982h
 26146                                  
 26147                                  ; ---------------------------------------------------------------------------
 26148                                  
 26149                                  PRINTVOL:
 26150                                  	push	ax		; AX return from SEARCH_FIRST for VOL ID
 26151                                  	mov	al,[FCB] ; 5Ch	; get drive letter
 26152                                  	add	al,'@'
 26153                                  	cmp	al,'@'
 26154                                  	jnz	short DRVOK
 26155                                  	mov	al,[CURDRV]
 26156                                  	add	al,[CAPITAL_A]
 26157                                  DRVOK:
 26158                                  	mov	[VOL_DRV],al	; get drive letter into argument
 26159                                  	pop	ax		; get return code back
 26160                                  	mov	dx,NOVOL ; "has	no label" 
 26161                                  	or	al,al		; volume label found?
 26162                                  	jnz	short PRINTVOL2	; print no volume message
 26163                                  GOODVOL:
 26164                                  	; MSDOS 3.3
 26165                                  	mov	di,CHARBUF
 26166                                  	mov	dx,di
 26167                                  	mov	si,IS	; "is "
 26168                                  	call	STRCPY
 26169                                  	dec	di
 26170                                  	mov	si,DIRBUF+8
 26171                                  	mov	cx,11
 26172                                  	rep	movsb
 26173                                  	xor	ax,ax
 26174                                  	;xor	al,al  ; MSDOS 6.0
 26175                                  	stosb			; store a zero to terminate the string
 26176                                  PRINTVOL2:
 26177                                  	mov	[VOLNAME_ADDR],dx
 26178                                  	mov	dx,VOLMESPTR
 26179                                  	jmp	PRINTF_CRLF
 26180                                  
 26181                                  	; MSDOS 6.0
 26182                                  ;drvok:
 26183                                  ;	mov	vol_drv,al	;AC000; get drive letter into argument
 26184                                  ;	pop	ax		;AC000; get return code back
 26185                                  ;	or	al,al		;AC000; volume label found?
 26186                                  ;	jz	Get_vol_name	;AC000; volume label exists - go get it
 26187                                  ;	mov	dx,offset trangroup:VolMes_ptr_2 
 26188                                  ;				;AC000; set up no volume message
 26189                                  ;	jmp	short print_serial ;AC000; go print it
 26190                                  ;
 26191                                  ;Get_vol_name:
 26192                                  ;	mov	di,offset trangroup:charbuf
 26193                                  ;	mov	dx,di
 26194                                  ;	mov	si,offset trangroup:dirbuf + 8	;AN000;  3/3/KK
 26195                                  ;	mov	cx,11				;AN000;  3/3/KK
 26196                                  ;	rep	movsb				;AN000;  3/3/KK
 26197                                  ;
 26198                                  ;	xor	al,al		;AC000; store a zero to terminate the string
 26199                                  ;	stosb
 26200                                  ;	mov	dx,offset trangroup:VolMes_ptr	;AC000; set up message
 26201                                  ;
 26202                                  ;PRINT_SERIAL:
 26203                                  ;
 26204                                  ;; Attempt to get the volume serial number from the disk.  If an error
 26205                                  ;; occurs, do not print volume serial number.
 26206                                  ;
 26207                                  ;	push	dx		;AN000; save message offset
 26208                                  ;	mov	ax,(GetSetMediaID SHL 8) 
 26209                                  ;				;AC036; Get the volume serial info
 26210                                  ;	mov	bl,DS:[FCB]	;AN000; get drive number from FCB
 26211                                  ;	mov	dx,offset trangroup:vol_ioctl_buf ;AN000;target buffer
 26212                                  ;	int	21h		;AN000; do the call
 26213                                  ;	pop	dx		;AN000; get message offset back
 26214                                  ;	jc	printvol_end	;AN000; if error, just go print label
 26215                                  ;	call	std_printf	;AC000; go print volume message
 26216                                  ;	mov	al,blank	;AN051; Print out a blank
 26217                                  ;	invoke	print_char	;AN051;   before volume message
 26218                                  ;	mov	dx,offset trangroup:VolSerMes_ptr 
 26219                                  ;				;AN000; get serial number message
 26220                                  ;printvol_end:
 26221                                  ;	jmp	std_printf	;AC000; go print and exit
 26222                                  
 26223                                  %endif
 26224                                  
 26225                                  ;============================================================================
 26226                                  ; TUCODE.ASM, MSDOS 6.0, 1991 (2)
 26227                                  ;============================================================================
 26228                                  ; 02/10/2018 - Retro DOS v3.0
 26229                                  
 26230                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29BFh
 26231                                  
 26232                                  ; =============== S U B	R O U T	I N E =======================================
 26233                                  
 26234                                  	; 20/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26235                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3876h
 26236                                  	
 26237                                  PRINT_DATE:
 26238                                  	; 20/03/2023
 26239                                  	; MSDOS 3.3
 26240                                  	;push	es
 26241                                  	;push	di
 26242                                  	;push	cs
 26243                                  	;pop	es
 26244                                  	;mov	di,ARG_BUF
 26245                                  	;mov	ah,Get_Date ; 2Ah
 26246                                  	;int	21h	; DOS -	GET CURRENT DATE
 26247                                  	;		; Return: DL = day,DH = month,	CX = year
 26248                                  	;		; AL = day of the week (0=Sunday,1=Monday,etc.)
 26249                                  	;cbw
 26250                                  	;call	GETDATE
 26251                                  	;call	P_DATE
 26252                                  	;xor	al,al
 26253                                  	;stosb
 26254                                  	;mov	dx,ARG_BUF_PTR
 26255                                  	;call	STD_PRINTF
 26256                                  		; 20/03/2023 (MSDOS 3.3 COMMAND.COM - TRANGROUP:29DAh)
 26257                                  	;pop	es ; !!??!! 
 26258                                  	;pop	di
 26259                                  	;retn
 26260                                  
 26261                                  	; 20/03/2023
 26262                                  	; MSDOS 6.0
 26263 000036DA 06                      	push	es
 26264 000036DB 57                      	push	di
 26265 000036DC 0E                      	push	cs
 26266 000036DD 07                      	pop	es
 26267 000036DE E81300                  	call	GetDate 		; get date
 26268 000036E1 86F2                    	xchg	dh,dl			;AN000; switch month & day
 26269 000036E3 890E[2C81]              	mov	[promptDat_yr],cx 	;AC000; put year into message control block
 26270 000036E7 8916[2E81]              	mov	[promptDat_moday],dx	;AC000; put month and day into message control block
 26271 000036EB BA[1C81]                	mov	dx,promptdat_ptr	;AC000; set up message for output
 26272 000036EE E81217                  	call	std_printf
 26273                                  	;AD061; mov word [promptDat_yr],0 ;AC000; reset year, month and day
 26274                                  	;AD061; mov word [promptDat_moday],0 ;AC000; pointers in control block
 26275 000036F1 5F                      	pop	di			;AC000; restore di,es
 26276 000036F2 07                      	pop	es			;AC000;
 26277 000036F3 C3                      	retn
 26278                                  
 26279                                  ; ---------------------------------------------------------------------------
 26280                                  
 26281                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26282                                  
 26283                                  ;GETDATE:
 26284                                  	; 21/03/2023
 26285                                  	; MSDOS 3.3
 26286                                  	;mov	si,ax
 26287                                  	;shl	si,1
 26288                                  	;add	si,ax
 26289                                  	;add	si,WEEKTAB ; "SunMonTueWedThuFriSat"
 26290                                  	;mov	bx,cx
 26291                                  	;mov	cx,3
 26292                                  	;rep	movsb
 26293                                  	;mov	al,' '
 26294                                  	;stosb
 26295                                  	;retn
 26296                                  
 26297                                  	; 21/03/2023
 26298                                  	; MSDOS 6.0
 26299                                  
 26300                                  ; Do GET DATE system call and set up 3 character day of week in ARG_BUF
 26301                                  ; for output. Date will be returned in CX,DX.
 26302                                  
 26303                                  GetDate:
 26304 000036F4 BF[088C]                	mov	di,Arg_Buf		;AC000; target for day of week
 26305 000036F7 B42A                    	mov	ah,Get_Date ;2Ah	;AC000; get current date
 26306 000036F9 CD21                    	int	21h			;AC000; Get date in CX:DX
 26307 000036FB 98                      	cbw				;AC000;
 26308 000036FC 51                      	push	cx			;AN000; save date returned in
 26309 000036FD 52                      	push	dx			;AN000;  CX:DX
 26310 000036FE 89C6                    	mov	si,ax
 26311 00003700 D1E6                    	shl	si,1
 26312 00003702 01C6                    	add	si,ax			; SI=AX*3
 26313 00003704 89F1                    	mov	cx,si			;AN000; save si
 26314 00003706 A1[E87F]                	mov	ax,[WeekTab]		;AN000; get message number of weektab
 26315 00003709 B6FF                    	mov	dh,util_msg_class ;0FFh	;AN000; this is a utility message
 26316 0000370B 57                      	push	di			;AN000; save argument buffer
 26317 0000370C E8DB17                  	call	TSYSGETMSG		;AN000; get the address of the message
 26318 0000370F 5F                      	pop	di			;AN000; retrieve argument buffer
 26319 00003710 01CE                    	add	si,cx			;AC000; get day of week
 26320 00003712 B90300                  	mov	cx,3
 26321 00003715 F3A4                      	rep	movsb
 26322 00003717 B000                    	mov	al,END_OF_LINE_OUT ; 0	;AC000; terminate the string
 26323 00003719 AA                      	stosb
 26324 0000371A 5A                      	pop	dx			;AN000; get back date
 26325 0000371B 59                      	pop	cx			;AN000;
 26326 0000371C C3                      	retn
 26327                                  
 26328                                  ; =============== S U B	R O U T	I N E =======================================
 26329                                  
 26330                                  	; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26331                                  
 26332                                  	; MSDOS 6.0
 26333                                  
 26334                                  ; This routine determines whether the character in AL is a
 26335                                  ; Yes or No character. On return, if AL=0, the character is
 26336                                  ; No, if AL=1, the character is Yes.
 26337                                  
 26338                                  ;	assume	ds:trangroup
 26339                                  
 26340                                  char_in_xlat:	; proc	near
 26341                                  	; 21/03/2023
 26342 0000371D 88C2                    	mov	dl,al			;AC000; get character into DX
 26343 0000371F 30F6                    	xor	dh,dh			;AC000;
 26344                                  	;mov	ax,(GetExtCntry<<8)+35	;AC000; Yes/No char call
 26345 00003721 B82365                  	mov	ax,6523h
 26346 00003724 CD21                    	int	21h			;AC000;
 26347 00003726 C3                      	retn
 26348                                  
 26349                                  ;char_in_xlat	endp
 26350                                  
 26351                                  ;============================================================================
 26352                                  ; TENV.ASM, MSDOS 6.0, 1991
 26353                                  ;============================================================================
 26354                                  ; 02/10/2018 - Retro DOS v3.0
 26355                                  
 26356                                  ;	Environment utilities and misc. routines
 26357                                  
 26358                                  ; MSDOS 6.0
 26359                                  ; ****************************************************************
 26360                                  ; *
 26361                                  ; * ROUTINE:	 UPCONV     (ADDED BY EMG 4.00)
 26362                                  ; *
 26363                                  ; * FUNCTION:	 This routine returns the upper case equivalent of
 26364                                  ; *		 the character in AL from the file upper case table
 26365                                  ; *		 in DOS if character if above  ascii 128, else
 26366                                  ; *		 subtracts 20H if between "a" and "z".
 26367                                  ; *
 26368                                  ; * INPUT:	 AL	      char to be upper cased
 26369                                  ; *		 FUCASE_ADDR  set to the file upper case table
 26370                                  ; *
 26371                                  ; * OUTPUT:	 AL	      upper cased character
 26372                                  ; *
 26373                                  ; ****************************************************************
 26374                                  ;
 26375                                  ;assume	ds:trangroup				;AN000;
 26376                                  ;
 26377                                  ;upconv	proc	near				;AN000;
 26378                                  ;
 26379                                  ;	cmp	al,80h				;AN000;  see if char is > ascii 128
 26380                                  ;	jb	oth_fucase			;AN000;  no - upper case math
 26381                                  ;	sub	al,80h				;AN000;  only upper 128 chars in table
 26382                                  ;	push	ds				;AN000;
 26383                                  ;	push	bx				;AN000;
 26384                                  ;	mov	ds,[resseg]			;AN000;  get resident data segment
 26385                                  ;assume	ds:resgroup				;AN000;
 26386                                  ;	lds	bx,dword ptr FUCase_Addr+1	;AN000;  get table address
 26387                                  ;	add	bx,2				;AN000;  skip over first word
 26388                                  ;	xlat	ds:byte ptr [bx]		;AN000;  convert to upper case
 26389                                  ;	pop	bx				;AN000;
 26390                                  ;	pop	ds				;AN000;
 26391                                  ;assume	ds:trangroup				;AN000;
 26392                                  ;	jmp	short upconv_end		;AN000;  we finished - exit
 26393                                  ;
 26394                                  ;oth_fucase:					;AN000;
 26395                                  ;	cmp	al,small_a			;AC000; if between "a" and "z",
 26396                                  ;	jb	upconv_end			;AC000;     subtract 20h to get
 26397                                  ;	cmp	al,small_z			;AC000;    upper case equivalent.
 26398                                  ;	ja	upconv_end			;AC000;
 26399                                  ;	sub	al,20h				;AC000; Change lower-case to upper
 26400                                  ;
 26401                                  ;upconv_end:					;AN000;
 26402                                  ;	ret
 26403                                  ;
 26404                                  ;upconv	endp					;AN000;
 26405                                  
 26406                                  
 26407                                  ; =============== S U B	R O U T	I N E =======================================
 26408                                  
 26409                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 29F2h
 26410                                  
 26411                                  ; 21/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26412                                  %if 0
 26413                                  
 26414                                  UPCONV:
 26415                                  	cmp	al,80h
 26416                                  	jb	short OTH_UCASE
 26417                                  	sub	al,80h
 26418                                  	push	ds
 26419                                  	push	bx
 26420                                  	mov	ds,[RESSEG]
 26421                                  	lds	bx,[UPPERCASETBL]
 26422                                  	add	bx,2
 26423                                  	xlat
 26424                                  	pop	bx
 26425                                  	pop	ds
 26426                                  	jmp	short UPCONV_RETN
 26427                                  
 26428                                  OTH_UCASE:
 26429                                  	cmp	al,'a'
 26430                                  	jb	short UPCONV_RETN
 26431                                  	cmp	al,'z'
 26432                                  	ja	short UPCONV_RETN
 26433                                  	sub	al,20h
 26434                                  
 26435                                  UPCONV_RETN:
 26436                                  	retn
 26437                                  
 26438                                  %endif
 26439                                  
 26440                                  ;============================================================================
 26441                                  ; COPY.ASM, MSDOS 6.0, 1991
 26442                                  ;============================================================================
 26443                                  ; 01/10/2018 - Retro DOS v3.0
 26444                                  
 26445                                  ;	title	COMMAND COPY routines.
 26446                                  
 26447                                  ;/*
 26448                                  ; *                      Microsoft Confidential
 26449                                  ; *                      Copyright (C) Microsoft Corporation 1991
 26450                                  ; *                      All Rights Reserved.
 26451                                  ; */
 26452                                  
 26453                                  ;***	COPY.ASM
 26454                                  
 26455                                  ;Source files:  copy.asm, copypr1.asm, copypr2.asm
 26456                                  
 26457                                  
 26458                                  ;***	MODIFICATION HISTORY
 26459                                  
 26460                                  ;11/01/83 EE  Added a few lines at the end of SCANSRC2 to get multiple
 26461                                  ;	     file concatenations (eg copy a.*+b.*+c.*) to work properly.
 26462                                  ;11/02/83 EE  Commented out the code in CPARSE which added drive designators
 26463                                  ;	     to tokens which begin with path characters so that PARSELINE
 26464                                  ;	     will work correctly.
 26465                                  ;11/04/83 EE  Commented out the code in CPARSE that considered paren's to be
 26466                                  ;	     individual tokens. That distinction is no longer needed for
 26467                                  ;	     FOR loop processing.
 26468                                  ;11/17/83 EE  CPARSE upper case conversion is now flag dependent. Flag is
 26469                                  ;	     1 when Cparse is called from COPY.
 26470                                  ;11/17/83 EE  Took out the comment chars around code described in 11/04/83
 26471                                  ;	     mod. It now is conditional on flag like previous mod.
 26472                                  ;11/21/83 NP  Added printf
 26473                                  ;12/09/83 EE  CPARSE changed to use CPYFLAG to determine when a colon should
 26474                                  ;	     be added to a token.
 26475                                  ;05/30/84 MZ  Initialize all copy variables. Fix confusion with destclosed
 26476                                  ;	     NOTE: DestHand is the destination handle. There are two
 26477                                  ;	     special values: -1 meaning destination was never opened and
 26478                                  ;	     0 which means that the destination has been openned and
 26479                                  ;	     closed.
 26480                                  ;06/01/84 MZ  Above reasoning totally specious. Returned things to normal
 26481                                  ;06/06/86 EG  Change to fix problem of source switches /a and /b getting
 26482                                  ;	     lost on large and multiple file (wildcard) copies.
 26483                                  ;06/09/86 EG  Change to use xnametrans call to verify that source and
 26484                                  ;	     destination are not equal.
 26485                                  ;
 26486                                  ;06/24/90 DO  If the destination of a file concatenation is the same as
 26487                                  ;	     first source file AND we run out of disk space before
 26488                                  ;	     completing the concatenation, restore the first source
 26489                                  ;	     file as best we can. See SeekEnd and CopErr. Bug #859.
 26490                                  ;
 26491                                  ;M031 SR 10/11/90  Bug #3069. Use deny write sharing mode to open files
 26492                                  ;		instead of compatibility mode. This gives lesser sharing
 26493                                  ;		violations when files are opened for read on a copy.
 26494                                  
 26495                                  ; ---------------------------------------------------------------------------
 26496                                  ;***	COPY CODE
 26497                                  ; ---------------------------------------------------------------------------
 26498                                  
 26499                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2A15h
 26500                                  
 26501                                  ; 23/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26502                                  ; MSDOS 5.0 - COMMAND.COM, transient portion/segment offset 38C3h
 26503                                  
 26504                                  COPY:
 26505                                  	; 	Initialize internal variables.
 26506                                  
 26507 00003727 31C0                    	xor	ax,ax		; AX = 0
 26508 00003729 A3[8E8C]                	mov	[Copy_num],ax	; # files copied (destinations) = 0
 26509 0000372C A3[BC8D]                	mov	[SRCPT],ax	; cmd line ptr for source scan = 0
 26510 0000372F A3[088D]                	mov	[SrcTail],ax	; ptr to last element of source pathname = 0
 26511 00003732 A2[BB8A]                	mov	[CFLAG],al	; 'destination file created' = false
 26512 00003735 A3[BF8A]                	mov	[NXTADD],ax	; ptr into TPA buffer = 0
 26513 00003738 A3[B78A]                	mov	[DestSwitch],ax	; destination switches = none
 26514 0000373B A3[D28D]                	mov	[STARTEL],ax	; CParse ptr to last pathname element = 0
 26515 0000373E A3[A58C]                	mov	[DestTail],ax	; ptr to last element of dest pathname = 0
 26516 00003741 A2[BC8A]                	mov	[DestClosed],al	; 'destination file closed' = false
 26517 00003744 A2[A48C]                	mov	[DestSiz],al	; length of destination pathname = 0
 26518 00003747 A2[078D]                	mov	[SrcSiz],al	; length of source pathname = 0
 26519 0000374A A2[A78C]                	mov	[DestInfo],al	; destination pathname flags = none
 26520 0000374D A2[0A8D]                	mov	[SrcInfo],al	; source pathname flags = none
 26521 00003750 A2[BE8D]                	mov	[INEXACT],al	; 'inexact copy' = false
 26522 00003753 A2[A38C]                	mov	[DestVars],al	; 'dest pathname is directory' = false  ;*!*
 26523 00003756 A2[068D]                	mov	[SrcVars],al	; 'source pathname is directory' = false
 26524 00003759 A2[7E89]                	mov	[USERDIR1],al	; saved working directory = null
 26525 0000375C A2[BF8D]                	mov	[NOWRITE],al	; 'no write' (source = dest) = false
 26526 0000375F A2[AF8A]                	mov	[RDEOF],al	; 'read end of file' = false
 26527 00003762 A3[628D]                	mov	[SRCHAND],ax	; source handle = 0
 26528 00003765 A3[C78D]                	mov	[CPDATE],ax	; copy date = 0
 26529 00003768 A3[C98D]                	mov	[CPTIME],ax	; copy time = 0
 26530 0000376B A2[648D]                	mov	[SRCISDEV],al	; 'source is device' = false
 26531                                  	; 23/03/2023
 26532                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM	
 26533 0000376E A2[CF8D]                	mov	[OCtrlZ],al	; 'Ctrl+Z removed from original' = false
 26534 00003771 A3[CB8D]                	mov	[OFilePtr_Lo],ax
 26535 00003774 A3[CD8D]                	mov	[OFilePtr_Hi],ax ; original destination file ptr = null
 26536 00003777 A2[C38D]                	mov	[TERMREAD],al	; 'terminate read' = false
 26537 0000377A A2[018C]                	mov	[comma],al	; '"+,," found' = false
 26538 0000377D A2[028C]                	mov	[plus_comma],al ; '"+,," found last time' = false (?)
 26539 00003780 A2[0E8E]                	mov	[msg_flag],al	;AN022; 'non-utility msg issued' = false
 26540 00003783 A3[B98A]                	mov	[AllSwitch],ax	; all switches = none
 26541 00003786 A2[B28A]                	mov	[ArgC],al	; source/dest argument count = 0
 26542 00003789 A2[C58D]                	mov	[PLUS],al	; '"+" in command line' = false
 26543 0000378C A2[C08D]                	mov	[BINARY],al	; 'binary copy' = false
 26544 0000378F A2[C48D]                	mov	[ASCII],al	; 'ascii copy' = false
 26545 00003792 A3[C88A]                	mov	[FileCnt],ax	; # files copied (destinations) = 0
 26546 00003795 A3[C18D]                	mov	[WRITTEN],ax	; 'destination written to' = false
 26547 00003798 A2[B18A]                	mov	[Concat],al	; 'concatenating' = false
 26548 0000379B A2[038D]                	mov	[MELCOPY],al	; 'Mel Hallerman copy' = false
 26549 0000379E A3[048D]                	mov	[MELSTART],ax	; Mel Hallerman cmd line ptr = 0
 26550                                  
 26551                                  	;	Initialize buffers with double-nulls.
 26552                                  
 26553 000037A1 A3[658D]                	mov	[ScanBuf],ax
 26554 000037A4 A3[A88C]                	mov	[DestBuf],ax
 26555 000037A7 A3[0B8D]                	mov	[SrcBuf],ax
 26556 000037AA A3[EB8B]                	mov	[SDIRBUF],ax
 26557 000037AD A3[A58B]                	mov	[DIRBUF],ax
 26558 000037B0 A3[628B]                	mov	[DestFcb],ax
 26559                                  
 26560 000037B3 A2[C68D]                	mov	[objcnt],al	; # CParse cmd-line objects found = 0
 26561                                  		
 26562 000037B6 48                      	dec	ax ; -1		; AX = 0FFFFh
 26563 000037B7 A3[FF8C]                	mov	[DESTHAND],ax	; destination handle = 'never opened'
 26564 000037BA A2[C18A]                	mov	[FRSTSRCH],al	; 'first search for source' = true
 26565 000037BD A2[028D]                	mov	[FIRSTDEST],al	; 'first time for dest' = true
 26566 000037C0 A2[A38C]                	mov	[DestIsDir],al	; 'haven't analyzed destination' ; *!*
 26567                                  		
 26568 000037C3 BE8100                  	mov	si,81h		; SI = ptr to command line
 26569                                  	;mov	bl,[PLUS_CHR]	; BL = special delimiter = "+"
 26570                                  	; 23/03/2023
 26571 000037C6 B32B                    	mov	bl,'+'
 26572 000037C8 FE06[0D8E]              	inc	byte [expand_star] ; CParse 'expand * to ?s' = true
 26573 000037CC C606[908C]01            	mov	byte [cpyflag],1 ; CParse 'called from COPY' = true
 26574                                  
 26575                                  	;*	Scan the command line for destination information.
 26576                                  
 26577                                  DESTSCAN:
 26578 000037D1 31ED                    	xor	bp,bp			; BP = switch flag accumulator
 26579 000037D3 BF[658D]                	mov	di,ScanBuf		; ES:DI = ptr to pathname buf
 26580                                  	; 23/03/2023
 26581 000037D6 8936[048C]              	mov	[parse_last],si		;AN018; save cmd line ptr
 26582 000037DA E88E09                  	call	cparse			; parse next object
 26583 000037DD 9C                      	pushf				; save CParse flags
 26584 000037DE FE06[C68D]              	inc	byte [objcnt]		; count object
 26585 000037E2 F6C780                  	test	bh,80h
 26586 000037E5 7405                    	jz	short NOCOPY		; no "+" delimiter
 26587 000037E7 C606[C58D]01            	mov	byte [PLUS],1		; "+" delimiter occurred
 26588                                  NOCOPY:
 26589 000037EC F6C701                  	test	bh,1
 26590 000037EF 742E                    	jz	short TESTP2		; not a switch
 26591                                  
 26592                                  	;	Found a switch.
 26593                                  
 26594                                  	; 23/03/2023 - Retro DOS v4.0 COMMAND.COM
 26595                                  	; MSDOS 6.0
 26596 000037F1 F7C51000                	test	bp,10h
 26597                                  	;test	bp,SwitchV ; 10h	;AN038; Verify requested?
 26598 000037F5 740B                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26599 000037F7 F606[B98A]10            	test	byte [AllSwitch],10h
 26600                                  	;test	byte [AllSwitch],SwitchV ;AN038; Verify already entered?
 26601 000037FC 7404                    	jz	short NOT_SLASHV	;AN038; No - set the switch
 26602                                  ;AD018; ;or	word [AllSwitch],FBadSwitch ;AN038; Set up bad switch
 26603                                  	;or	bp,FBadSwitch		;AN018; Set up bad switch
 26604 000037FE 81CD0040                	or	bp,4000h
 26605                                  NOT_SLASHV:
 26606 00003802 092E[B78A]              	or	[DestSwitch],bp		; assume destination
 26607 00003806 092E[B98A]              	or	[AllSwitch],bp		; keep tabs on all switches
 26608                                  
 26609                                  	; 23/03/2023
 26610                                  	; MSDOS 6.0
 26611                                  	;test	bp,not SwitchCopy	;AN018; Bad switch?
 26612 0000380A F7C5E37F                	test	bp,7FE3h ; test bp,~SwitchCopy
 26613 0000380E 740A                    	jz	short NOT_BAD_SWITCH	;AN018; Switches are okay
 26614 00003810 9D                      	popf				;AN018; fix up stack
 26615 00003811 B80300                  	mov	ax,BadSwt_Ptr ; 3	;AN018; get "Invalid switch" message number
 26616 00003814 E8AAE9                  	call	setup_parse_error_msg	;AN018; setup to print the message
 26617 00003817 E931F1                  	jmp	cerror			;AC018; exit
 26618                                  NOT_BAD_SWITCH:
 26619 0000381A 9D                      	popf				; restore CParse flags
 26620 0000381B 7233                    	jc	short CHECKDONE		; found CR
 26621 0000381D EBB2                    	jmp	short DESTSCAN		; continue scanning for destination
 26622                                  TESTP2:
 26623 0000381F 9D                      	popf				; restore CParse flags
 26624 00003820 722E                    	jc	short CHECKDONE		; found CR
 26625 00003822 F6C780                  	test	bh,80h
 26626 00003825 7504                    	jnz	short GOTPLUS		; found a "+pathname" argument
 26627 00003827 FE06[B28A]              	inc	byte [ArgC]		; count independent pathname args
 26628                                  GOTPLUS:
 26629 0000382B 56                      	push	si			; save cmd line ptr
 26630 0000382C A1[D28D]                	mov	ax,[STARTEL]		; AX = ptr to last path element
 26631 0000382F BE[658D]                	mov	si,ScanBuf		; SI = ptr to path string
 26632 00003832 29F0                    	sub	ax,si			; AX = offset of last element
 26633 00003834 BF[A88C]                	mov	di,DestBuf		; DI = ptr to destination buf
 26634 00003837 01F8                    	add	ax,di			; AX = ptr to last element in
 26635                                  					;  destination path buffer
 26636 00003839 A3[A58C]                	mov	[DestTail],ax		; save ptr to last element
 26637 0000383C 880E[A48C]              	mov	[DestSiz],cl		; save path string length
 26638 00003840 41                      	inc	cx			; CX = mov length (incl null)
 26639 00003841 F3A4                    	rep	movsb			; DestBuf = possible destination path
 26640 00003843 883E[A78C]              	mov	[DestInfo],bh		; save CParse info flags
 26641 00003847 C706[B78A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26642 0000384D 5E                      	pop	si			; SI = ptr into cmd line again
 26643 0000384E EB81                    	jmp	short DESTSCAN		;AC018; continue scanning for dest
 26644                                  
 26645                                  CHECKDONE:
 26646                                  	;	We reached the CR. The destination scan is finished.
 26647                                  
 26648                                  	;	Disallow "copy file1+" as file overwriting itself.
 26649                                  	;
 26650                                  	;	(Note that "copy file1+file2+" will be accepted, and
 26651                                  	;	equivalent to "copy file1+file2".)
 26652                                  
 26653                                  	;	Bugbug: it looks like "copy /x file1+" would slip
 26654                                  	;	through this check, since the switch would count
 26655                                  	;	as another object in ObjCnt.
 26656                                  
 26657 00003850 803E[C58D]01            	cmp	byte [PLUS],1		; "+" with
 26658 00003855 7514                    	jnz	short CDCONT
 26659 00003857 803E[B28A]01            	cmp	byte [ArgC],1		; one arg,
 26660 0000385C 750D                    	jnz	short CDCONT
 26661 0000385E 803E[C68D]02            	cmp	byte [objcnt],2		; two objects..
 26662 00003863 7506                    	jnz	short CDCONT
 26663 00003865 BA[5A7F]                	mov	dx,OVERWR_PTR
 26664 00003868 E91A06                  	jmp	COPYERR			; is file overwrite
 26665                                  
 26666                                  CDCONT:
 26667 0000386B A0[C58D]                	mov	al,[PLUS]		; AL = '"+" occurred'
 26668 0000386E A2[B18A]                	mov	[Concat],al		; if "+" occurred, we're concatenating
 26669 00003871 D0E0                    	shl	al,1
 26670 00003873 D0E0                    	shl	al,1
 26671 00003875 A2[BE8D]                	mov	[INEXACT],al		; therefore making an inexact copy
 26672                                  	;mov	dx,BADARGSPTR ; MSDOS 3.3 ; 18/04/2023
 26673 00003878 A0[B28A]                	mov	al,[ArgC]		; AL = # independent arguments
 26674                                  
 26675                                  	; 23/03/2023
 26676                                  	; MSDOS 3.3		
 26677                                  	;or	al,al
 26678                                  	;jz	short CERROR4J
 26679                                  	; MSDOS 6.0
 26680 0000387B 08C0                    	or	al,al
 26681 0000387D 750B                    	jnz	short TRY_TOO_MANY	; more than 0 args; check if too many
 26682                                  		
 26683 0000387F BA[317F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26684 00003882 C706[317F]0200          	mov	word [extend_buf_ptr],LessArgs_Ptr ; 2
 26685                                  	;mov	word [extend_buf_ptr],2	; set msg # "param missing"
 26686 00003888 EB0D                    	jmp	short CERROR_PARSEJ	; take parse error exit		
 26687                                  
 26688                                  	; more than 0 args; check if too many
 26689                                  TRY_TOO_MANY:
 26690 0000388A 3C02                    	cmp	al,2
 26691 0000388C 7611                    	jbe	short ACOUNTOK		; <= 2 arguments - ok
 26692                                  
 26693                                  	; 23/03/2023
 26694                                  	; MSDOS 6.0
 26695 0000388E BA[317F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26696 00003891 C706[317F]0100          	mov	word [extend_buf_ptr],MoreArgs_Ptr
 26697                                  	;mov	word [extend_buf_ptr],1 ; set msg # "too many params"
 26698                                  CERROR_PARSEJ:
 26699 00003897 C606[2F7F]02            	mov	byte [msg_disp_class],parse_msg_class ; 2
 26700                                  					; parse error message	
 26701                                  CERROR4J:
 26702 0000389C E9ACF0                  	jmp	cerror
 26703                                  
 26704                                  ACOUNTOK:
 26705 0000389F BD[A38C]                	mov	bp,DestVars		; BP = base of dest variables
 26706                                  
 26707 000038A2 3C01                    	cmp	al,1
 26708 000038A4 7520                    	jnz	short GOT2ARGS
 26709                                  
 26710                                  	;	Only one independent pathname argument on command line.
 26711                                  	;	Set destination to d:*.*, where d: is current drive.
 26712                                  
 26713                                  	;	Bugbug: but is this appropriate for "copy x:file1+x:file2"?
 26714                                  	;	The two files would be appended as d:file1, rather than x:file1.
 26715                                  
 26716 000038A6 A0[B08A]                	mov	al,[CURDRV]		; AL = current drive (0 = A)
 26717                                  	;add	al,[CAPITAL_A]		; AL = current drive letter
 26718                                  	; 23/03/2023
 26719 000038A9 0441                    	add	al,'A'
 26720 000038AB B43A                    	mov	ah,':'			; AX = "d:"
 26721                                  	;mov	byte [bp+1],2
 26722 000038AD C6460102                	mov	byte [bp+VARSTRUC.SIZ],2 ; pathname length = 2
 26723                                  
 26724 000038B1 BF[A88C]                	mov	di,DestBuf		; ES:DI = ptr to dest path buf
 26725 000038B4 AB                      	stosw				; store "d:"
 26726                                  		
 26727 000038B5 C706[B78A]0000          	mov	word [DestSwitch],0	; clear destination switches
 26728                                  	;mov	byte [bp+4],2		
 26729 000038BB C6460402                	mov	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26730                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26731                                  	;mov	byte [bp+0],0		
 26732 000038BF C6460000                	mov	byte [bp],0
 26733 000038C3 E87608                  	call	SETSTARS		; add wildcards
 26734                                  GOT2ARGS:
 26735                                  	;	If destination pathname is "d:", add full wildcard filename
 26736                                  
 26737                                  	;cmp	byte [bp+1],2
 26738 000038C6 807E0102                	cmp	byte [bp+VARSTRUC.SIZ],2
 26739 000038CA 7516                    	jnz	short NOTSHORTDEST	; not two chars, can't be "d:"
 26740 000038CC B03A                    	mov	al,':'  ; 3Ah
 26741 000038CE 3806[A98C]              	cmp	byte [DestBuf+1],al
 26742 000038D2 750E                    	jnz	short NOTSHORTDEST	; it's just a 2-character filename
 26743                                  	;or	byte [bp+4],2
 26744 000038D4 804E0402                	or	byte [bp+VARSTRUC.INFO],2 ; mark destination 'wildcard present'
 26745 000038D8 BF[AA8C]                	mov	di,DestBuf+2		; ES:DI = ptr after "d:"
 26746                                  	;mov	byte [bp+VARSTRUC.ISDIR],0 ; mark destination 'not a directory'
 26747                                  	;mov	byte [bp+0],0		
 26748 000038DB C6460000                	mov	byte [bp],0
 26749 000038DF E85A08                  	call	SETSTARS		; add wildcards
 26750                                  NOTSHORTDEST:
 26751                                  	;	If destination pathname ends with "\", try to make
 26752                                  	;	sure it's "d:\".
 26753                                  
 26754                                  	;mov	di,[bp+2]
 26755 000038E2 8B7E02                  	mov	di,[bp+VARSTRUC.TTAIL]	; DI = ptr to last path element
 26756 000038E5 803D00                  	cmp	byte [di],0
 26757 000038E8 7515                    	jnz	short CHKSWTCHES	; not a null, so last char not "\"
 26758                                  
 26759 000038EA BA[6C80]                	mov	dx,badcd_ptr
 26760 000038ED B03A                    	mov	al,':'
 26761 000038EF 3845FE                  	cmp	[di-2],al
 26762 000038F2 75A8                    	jne	short CERROR4J		; it's not "d:\", exit with error msg
 26763                                  	;mov	byte [bp+0],2
 26764                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; destination 'is a directory'
 26765 000038F4 C6460002                	mov	byte [bp],2
 26766                                  	;or	byte [bp+4],6
 26767 000038F8 804E0406                	or	byte [bp+VARSTRUC.INFO],6 ; destination wildcarded and contains
 26768                                  					  ;  path character
 26769 000038FC E83D08                  	call	SETSTARS		; add wildcards
 26770                                  CHKSWTCHES:
 26771                                  	;	We have enough information about the destination for now.
 26772                                  
 26773                                  	;	Turn on verify if requested. Save the current verify flag.
 26774                                  
 26775                                  	; 23/03/2023
 26776                                  	; MSDOS 6.0 (& MSDOS 5.0) COMMAND.COM
 26777                                  	;mov	dx,BADPARMPTR
 26778                                  	
 26779 000038FF A1[B98A]                	mov	ax,[AllSwitch]		; AX = all switch flags
 26780                                  
 26781                                  	; 23/03/2023
 26782                                  	; MSDOS 3.3
 26783                                  	;;test	ax,~SWITCHCOPY ; 7FE3h
 26784                                  	;test	ax,NOT_SWITCHCOPY ; 7FE3h ; 13/10/2018
 26785                                  	;jnz	short CERROR4J
 26786                                  	
 26787                                  	; 23/03/2023
 26788                                  	; MSDOS 3.3 (& MSDOS 6.0)
 26789                                  	;test	ax,SwitchV ; 10h
 26790                                  	; 18/04/2023
 26791                                  	;test	ax,10h
 26792 00003902 A810                    	test	al,10h  ; test al,SwitchV
 26793 00003904 7414                    	jz	short NOVERIF		; no /v, no verify
 26794                                  
 26795 00003906 B454                    	mov	ah,Get_Verify_On_Write ; 54h
 26796 00003908 CD21                    	int	21h		; DOS -	2+ - GET VERIFY	FLAG
 26797                                  				; Return: AL = 00h if flag OFF
 26798                                  				; AL = 01h if flag ON
 26799 0000390A 1E                      	push	ds
 26800 0000390B 8E1E[9C8A]              	mov	ds,[RESSEG]
 26801 0000390F 30E4                    	xor	ah,ah
 26802 00003911 A3[A801]                	mov	[VerVal],ax		; save current verify flag
 26803 00003914 1F                      	pop	ds
 26804 00003915 B8012E                  	mov	ax,(SET_VERIFY_ON_WRITE<<8)|1 ; 2E01h
 26805 00003918 CD21                    	int	21h		; DOS -	SET VERIFY FLAG
 26806                                  				; DL = 00h,AL = 01h VERIFY on / 00h VERIFY off
 26807                                  NOVERIF:
 26808                                  	;*	Scan for first source.
 26809                                  
 26810 0000391A 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 26811 0000391C BE8100                  	mov	si,81h			; SI = ptr into command line
 26812                                  	;mov	bl,[PLUS_CHR]		; BL = special CParse delimiter = "+"
 26813                                  	; 23/03/2023
 26814 0000391F B32B                    	mov	bl,'+' ; 2Bh
 26815                                  SCANFSRC:
 26816 00003921 BF[658D]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 26817 00003924 E84408                  	call	cparse			; parse first source pathname
 26818 00003927 F6C701                  	test	bh,1			; switch?
 26819 0000392A 75F5                    	jnz	short SCANFSRC		; yes, try again
 26820 0000392C 092E[B78A]              	or	[DestSwitch],bp		; include copy-wide switches on dest
 26821                                  
 26822                                  ;	Set ascii copying mode if concatenating, unless /b is specified.
 26823                                  
 26824                                  	; 23/03/2023
 26825 00003930 F7C50800                	test	bp,8
 26826                                  	;test	bp,SWITCHB
 26827 00003934 750C                    	jnz	short NOSETCASC		; /b - explicit binary copy
 26828 00003936 803E[B18A]00            	cmp	byte [Concat],0
 26829 0000393B 7405                    	jz	short NOSETCASC		; we're not concatenating
 26830 0000393D C606[C48D]04            	mov	byte [ASCII],4
 26831                                  	;mov	byte [ASCII],SWITCHA	; set ascii copy
 26832                                  NOSETCASC:
 26833 00003942 E8B503                  	call	SOURCE_SET		; set source variables
 26834 00003945 E84400                  	call	FRSTSRC			; set up first source copy
 26835 00003948 E99500                  	jmp	FIRSTENT		; jump into the copy loop
 26836                                  
 26837                                  ; ---------------------------------------------------------------------------
 26838                                  
 26839                                  	; 24/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26840                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3AE9h
 26841                                  ENDCOPY:
 26842                                  	;*	End of the road. Close destination, display # files
 26843                                  	;	copied (meaning # destinations), and go back to main
 26844                                  	;	transient COMMAND code.
 26845                                  
 26846 0000394B E8C102                  	call	CLOSEDEST
 26847                                  ENDCOPY2:
 26848 0000394E BA[637F]                	mov	dx,copied_ptr
 26849 00003951 8B36[C88A]              	mov	si,[FileCnt]
 26850 00003955 8936[8E8C]              	mov	[Copy_num],si
 26851 00003959 E8A714                  	call	std_printf
 26852 0000395C E9A5C7                  	jmp	TCOMMAND		; stack could be messed up
 26853                                  
 26854                                  ; ---------------------------------------------------------------------------
 26855                                  
 26856                                  SRCNONEXIST:
 26857                                  	;*	Source doesn't exist. If concatenating, ignore and continue.
 26858                                  	;	Otherwise, say 'file not found' and quit.
 26859                                  
 26860 0000395F 803E[B18A]00            	cmp	byte [Concat],0
 26861 00003964 7543                    	jne	short NEXTSRC		; concatenating - go on to next source
 26862                                  
 26863                                  	; 24/03/2023
 26864                                  	; MSDOS 3.3
 26865                                  	;mov	dx,SRCBUF
 26866                                  	;mov	[STRING_PTR_1],dx
 26867                                  	;mov	dx,STRINGBUF1PTR
 26868                                  	;call	STD_PRINTF
 26869                                  	;mov	dx,FNOTFOUNDPTR
 26870                                  	;jmp	COPYERR
 26871                                  
 26872                                  	; 24/*03/2023
 26873                                  	; MSDOS 6.0
 26874                                  	;	Set up error message.
 26875 00003966 C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 26876                                  				  	; extended error msg
 26877 0000396B BA[317F]                	mov	dx,extend_buf_ptr	; DX = ptr to msg block
 26878 0000396E C706[317F]0200          	mov	word [extend_buf_ptr],ERROR_FILE_NOT_FOUND ; 2
 26879                                  					; 'file not found' msg#
 26880 00003974 C706[8C8C][0B8D]        	mov	word [string_ptr_2],SrcBuf
 26881                                  					; point at bad pathname
 26882 0000397A C606[337F]01            	mov	byte [extend_buf_sub],one_subst ; 1
 26883                                  					; 1 substitution
 26884 0000397F E90305                  	jmp	COPYERR			; print msg and clean up
 26885                                  
 26886                                  ; ---------------------------------------------------------------------------
 26887                                  
 26888                                  SOURCEPROC:
 26889                                  
 26890                                  	;*	Preparatory processing for each source file.
 26891                                  	;	Called at FrstSrc for first source file.
 26892                                  
 26893 00003982 E87503                  	call	SOURCE_SET		; set source variables & ascii/binary
 26894 00003985 803E[B18A]00            	cmp	byte [Concat],0
 26895 0000398A 750B                    	jne	short LEAVECFLAG	; concatenating - leave CFlag alone
 26896                                  
 26897                                  ; ---------------------------------------------------------------------------
 26898                                  
 26899                                  FRSTSRC:
 26900 0000398C 31C0                    	xor	ax,ax
 26901 0000398E A2[BB8A]                	mov	[CFLAG],al		; 'destination not created'
 26902 00003991 A3[BF8A]                	mov	[NXTADD],ax		; copy buffer ptr = 0
 26903 00003994 A2[BC8A]                	mov	[DestClosed],al		; 'destination not closed'
 26904                                  
 26905                                  LEAVECFLAG:
 26906 00003997 8936[BC8D]              	mov	[SRCPT],si		; save cmd-line ptr
 26907 0000399B BF[7E89]                	mov	di,USERDIR1		; DI = ptr to buf for user's 
 26908                                  						;   current dir
 26909 0000399E BD[068D]                	mov	bp,SrcVars		; BP = base of source variables
 26910 000039A1 E84606                  	call	BUILDPATH		; cd to source dir, figure
 26911                                  						;   out stuff about source
 26912 000039A4 8B36[088D]              	mov	si,[SrcTail]		; SI = ptr to source filename
 26913 000039A8 C3                      	retn
 26914                                  
 26915                                  ; ---------------------------------------------------------------------------
 26916                                  
 26917                                  	; 25/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 26918                                  NEXTSRC:
 26919                                  	;*	Next source. Come here after handling each pathname.
 26920                                  	;	We're done unless there are additional source pathnames
 26921                                  	;	to be appended.
 26922                                  	;
 26923                                  	;	Note that all files matching an ambiguous pathname
 26924                                  	;	are processed before coming here.
 26925                                  
 26926 000039A9 803E[C58D]00            	cmp	byte [PLUS],0
 26927                                  	;jne	short MORECP		; copying "+" sources - keep going
 26928                                  	; 26/04/2023
 26929                                  ;ENDCOPYJ2:
 26930                                  	;jmp	short ENDCOPY
 26931 000039AE 749B                    	je	short ENDCOPY
 26932                                  MORECP:
 26933 000039B0 31ED                    	xor	bp,bp			; BP = switch flags accumulator
 26934 000039B2 8B36[BC8D]              	mov	si,[SRCPT]		; SI = ptr to current pos'n in cmd line
 26935                                  	;mov	bl,[PLUS_CHR]		; BL = special delimiter = "+"
 26936 000039B6 B32B                    	mov	bl,'+' ; 2Bh
 26937                                  SCANSRC:
 26938 000039B8 BF[658D]                	mov	di,ScanBuf		; DI = ptr to pathname buf
 26939 000039BB E8AD07                  	call	cparse			; parse first source name
 26940                                  	;jb	short ENDCOPYJ2		; CR found - we're done
 26941                                  	; 26/04/2023
 26942 000039BE 728B                    	jb	short ENDCOPY
 26943                                  
 26944 000039C0 F6C780                  	test	bh,80h
 26945                                  	;jz	short ENDCOPYJ2		; no "+" delimiter - we're done
 26946                                  	; 26/04/2023
 26947 000039C3 7486                    	jz	short ENDCOPY
 26948                                  
 26949 000039C5 F6C701                  	test	bh,1
 26950 000039C8 75EE                    	jnz	short SCANSRC		; switch found - keep looking
 26951                                  
 26952                                  	;	ScanBuf contains the next source pathname.
 26953                                  
 26954 000039CA E8B5FF                  	call	SOURCEPROC		; prepare this source
 26955 000039CD 803E[018C]01            	cmp	byte [comma],1		; was +,, found last time?
 26956 000039D2 7507                    	jnz	short NOSTAMP		;  no - try for a file
 26957 000039D4 C606[028C]01            	mov	byte [plus_comma],1	; yes - set flag
 26958 000039D9 EB84                    	jmp	short SRCNONEXIST	; we know we won't find it
 26959                                  
 26960                                  NOSTAMP:
 26961 000039DB C606[028C]00            	mov	byte [plus_comma],0	; reset +,, flag
 26962                                  
 26963                                  ; ---------------------------------------------------------------------------
 26964                                  
 26965                                  FIRSTENT:
 26966                                  
 26967                                  ;M047
 26968                                  ; The only case we need to worry about is when the source is wildcarded and
 26969                                  ;the destination is not. For this case, ConCat is not yet set to indicate
 26970                                  ;concatenation. We check for this case.
 26971                                  ;
 26972                                  ;NB: This change has been backed out and replaced by M048. This is not the
 26973                                  ;right place to do this check.
 26974                                  
 26975                                  	;	This is where we enter the loop with the first source.
 26976                                  
 26977 000039E0 BF5C00                  	mov	di,FCB ; 5Ch		; DI = ptr to FCB
 26978 000039E3 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 26979 000039E6 CD21                    	int	21h		; DOS -	PARSE FILENAME
 26980                                  				; DS:SI	-> string to parse
 26981                                  				; ES:DI	-> buffer to fill with unopened	FCB
 26982                                  				; AL = bit mask	to control parsing
 26983 000039E8 803C00                  	cmp	byte [si],0		; did we parse the whole thing?
 26984 000039EB 7516                    	jne	short SRCHDONE		; no, error, simulate 'not found'
 26985 000039ED A1[0B8D]                	mov	ax,[SrcBuf]		; AX = possible "d:"
 26986 000039F0 80FC3A                  	cmp	ah,':'
 26987 000039F3 7402                    	je	short DRVSPEC1		; AX = definite "d:"
 26988 000039F5 B040                    	mov	al,'@'	; 40h		; AL = drive 'letter' for current drive
 26989                                  DRVSPEC1:
 26990 000039F7 0C20                    	or	al,20h			; AL = lowercase drive letter
 26991 000039F9 2C60                    	sub	al,60h			; AL = drive id (0=current,1=A,..)
 26992                                  	;mov	[5Ch],al
 26993 000039FB A25C00                  	mov	[FCB],al		; put drive id in FCB
 26994                                  
 26995                                  	;	FCB contains drive and filename to search.
 26996                                  		
 26997 000039FE B411                    	mov	ah,Dir_Search_First ; 11h  ; AH = 'Find First File'	
 26998 00003A00 E8FC00                  	call	SEARCH
 26999                                  SRCHDONE:
 27000 00003A03 9C                      	pushf				; save flags from Search
 27001 00003A04 E873EA                  	call	RestUDir1		; restore users current directory
 27002 00003A07 9D                      	popf				; restore flags from search
 27003 00003A08 7403                    	jz	short NEXTAMBIG0	; found the source - continue
 27004 00003A0A E952FF                  	jmp	SRCNONEXIST		; didn't find the source
 27005                                  
 27006                                  NEXTAMBIG0:
 27007 00003A0D 30C0                    	xor	al,al
 27008 00003A0F 8606[C18A]              	xchg	al,[FRSTSRCH]
 27009 00003A13 08C0                    	or	al,al
 27010 00003A15 740B                    	jz	short NEXTAMBIG
 27011                                  SETNMEL:
 27012 00003A17 B90C00                  	mov	cx,12
 27013 00003A1A BF[EB8B]                	mov	di,SDIRBUF
 27014 00003A1D BE[A58B]                	mov	si,DIRBUF
 27015 00003A20 F3A4                    	rep	movsb			; save very first source name
 27016                                  NEXTAMBIG:
 27017 00003A22 30C0                    	xor	al,al
 27018 00003A24 A2[BF8D]                	mov	[NOWRITE],al		; turn off nowrite
 27019 00003A27 8B3E[088D]              	mov	di,[SrcTail]
 27020 00003A2B BE[A68B]                	mov	si,DIRBUF+1
 27021 00003A2E E8C5EB                  	call	FCB_TO_ASCZ		; SrcBuf has complete name
 27022                                  MELDO:
 27023 00003A31 803E[B18A]00            	cmp	byte [Concat],0
 27024 00003A36 7507                    	jnz	short SHOWCPNAM		; concatenating - show name
 27025 00003A38 F606[0A8D]02            	test	byte [SrcInfo],2	; wildcard - show name
 27026 00003A3D 7409                    	jz	short DOREAD
 27027                                  SHOWCPNAM:
 27028                                  	; 25/03/2023
 27029                                  	; MSDOS 3.3
 27030                                  	;mov	dx,SRCBUF
 27031                                  	;mov	[STRING_PTR_2],dx
 27032                                  	;mov	dx,STRINGBUF2PTR
 27033                                  	;call	STD_PRINTF
 27034                                  	;call	CRLF2
 27035                                  	; 25/03/2023 - Retro DOS 4.0 COMMAND.COM
 27036                                  	; MSDOS 6.0 (& MSDOS 5.0
 27037 00003A3F BA[DC80]                	mov	dx,file_name_ptr
 27038 00003A42 E8BE13                  	call	std_printf
 27039 00003A45 E882EB                  	call	CRLF2
 27040                                  DOREAD:
 27041 00003A48 E8C500                  	call	DOCOPY
 27042 00003A4B 803E[B18A]00            	cmp	byte [Concat],0
 27043 00003A50 750A                    	jnz	short NODCLOSE		; concatenating - don't close dest
 27044                                  
 27045 00003A52 E8BA01                  	call	CLOSEDEST		; close current destination
 27046 00003A55 7205                    	jc	short NODCLOSE		; concatenating - dest not closed
 27047                                  
 27048 00003A57 C606[BB8A]00            	mov	byte [CFLAG],0		; 'destination not created'
 27049                                  NODCLOSE:
 27050 00003A5C 803E[B18A]00            	cmp	byte [Concat],0		
 27051 00003A61 740A                    	jz	short NOFLUSH
 27052                                  
 27053                                  ;	Concatenating - flush output between source files so LostErr
 27054                                  ;	stuff works correctly.
 27055                                  
 27056                                  	;invoke	FlshFil  ; MSDOS 6.0
 27057                                  	; 25/03/2023
 27058 00003A63 E8E202                  	call	FlshFil
 27059                                  	;call	FLUSHFIL ; MSDOS 3.3
 27060                                  
 27061 00003A66 F606[038D]FF            	test	byte [MELCOPY],0FFh
 27062                                  	;jz	short NOFLUSH
 27063                                  	;jmp	short DOMELCOPY
 27064                                  	; 25/03/2023
 27065 00003A6B 750C                    	jnz	short DOMELCOPY
 27066                                  NOFLUSH:
 27067 00003A6D E88300                  	call	SEARCHNEXT		; try next match
 27068 00003A70 755D                    	jnz	short NEXTSRCJ		; not found - finished with 
 27069                                  					;   this source spec
 27070 00003A72 C606[BC8A]00            	mov	byte [DestClosed],0	; 'destination not closed'
 27071 00003A77 EBA9                    	jmp	short NEXTAMBIG		; do next ambig match
 27072                                  
 27073                                  DOMELCOPY:
 27074 00003A79 803E[038D]FF            	cmp	byte [MELCOPY],0FFh
 27075 00003A7E 740D                    	je	short CONTMEL
 27076 00003A80 8B36[BC8D]              	mov	si,[SRCPT]
 27077 00003A84 8936[048D]              	mov	[MELSTART],si
 27078 00003A88 C606[038D]FF            	mov	byte [MELCOPY],0FFh
 27079                                  
 27080                                  CONTMEL:
 27081 00003A8D 31ED                    	xor	bp,bp
 27082 00003A8F 8B36[BC8D]              	mov	si,[SRCPT]
 27083                                  	;mov	bl,[PLUS_CHR]
 27084                                  	; 25/03/2023
 27085 00003A93 B32B                    	mov	bl,'+'
 27086                                  SCANSRC2:
 27087 00003A95 BF[658D]                	mov	di,ScanBuf
 27088 00003A98 E8D006                  	call	cparse
 27089 00003A9B F6C780                  	test	bh,80h
 27090 00003A9E 7432                    	jz	short NEXTMEL		; no "+" - go back to start
 27091 00003AA0 F6C701                  	test	bh,1
 27092 00003AA3 75F0                    	jnz	short SCANSRC2		; switch - keep scanning
 27093 00003AA5 E8DAFE                  	call	SOURCEPROC
 27094 00003AA8 E8CFE9                  	call	RestUDir1
 27095 00003AAB BF[268B]                	mov	di,DESTFCB2
 27096 00003AAE B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 27097 00003AB1 CD21                    	int	21h		; DOS -	PARSE FILENAME
 27098                                  				; DS:SI	-> string to parse
 27099                                  				; ES:DI	-> buffer to fill with unopened	FCB
 27100                                  				; AL = bit mask	to control parsing
 27101 00003AB3 BB[EC8B]                	mov	bx,SDIRBUF+1
 27102 00003AB6 BE[278B]                	mov	si,DESTFCB2+1
 27103 00003AB9 8B3E[088D]              	mov	di,[SrcTail]
 27104                                  
 27105 00003ABD E8FB04                  	call	BUILDNAME
 27106                                  
 27107 00003AC0 803E[B18A]00            	cmp	byte [Concat],0
 27108 00003AC5 7405                    	je	short MELDOJ		; not concatenating - continue
 27109                                  
 27110                                  	;	Yes, turn off nowrite because this part of the code 
 27111                                  	;	is only reached after the first file has been dealt with.
 27112                                  
 27113 00003AC7 C606[BF8D]00            	mov	byte [NOWRITE],0
 27114                                  MELDOJ:
 27115 00003ACC E962FF                  	jmp	MELDO
 27116                                  NEXTSRCJ:
 27117 00003ACF E9D7FE                  	jmp	NEXTSRC
 27118                                  
 27119                                  NEXTMEL:
 27120 00003AD2 E83A01                  	call	CLOSEDEST
 27121 00003AD5 31C0                    	xor	ax,ax
 27122 00003AD7 A2[BB8A]                	mov	[CFLAG],al
 27123 00003ADA A3[BF8A]                	mov	[NXTADD],ax
 27124 00003ADD A2[BC8A]                	mov	[SPECDRV],al
 27125 00003AE0 8B36[048D]              	mov	si,[MELSTART]
 27126 00003AE4 8936[BC8D]              	mov	[SRCPT],si
 27127 00003AE8 E80800                  	call	SEARCHNEXT
 27128 00003AEB 7403                    	jz	short SETNMELJ
 27129 00003AED E95EFE                  	jmp	ENDCOPY2
 27130                                  SETNMELJ:
 27131 00003AF0 E924FF                  	jmp	SETNMEL
 27132                                  
 27133                                  ; ---------------------------------------------------------------------------
 27134                                  
 27135                                  SEARCHNEXT:
 27136 00003AF3 B412                    	mov	ah,Dir_Search_Next ; 12h
 27137 00003AF5 F606[0A8D]02            	test	byte [SrcInfo],2
 27138 00003AFA 7503                    	jnz	short SEARCH		; do search-next if ambig
 27139 00003AFC 08E4                    	or	ah,ah			; reset zero flag
 27140 00003AFE C3                      	retn
 27141                                  
 27142                                  ; ---------------------------------------------------------------------------
 27143                                  
 27144                                  SEARCH:
 27145 00003AFF 50                      	push	ax
 27146 00003B00 B41A                    	mov	ah,Set_DMA ; 1Ah
 27147 00003B02 BA[A58B]                	mov	dx,DIRBUF	; put result of search in dirbuf
 27148 00003B05 CD21                    	int	21h	; DOS -	SET DISK TRANSFER AREA ADDRESS
 27149                                  			; DS:DX	-> disk	transfer buffer
 27150 00003B07 58                      	pop	ax		; restore search first/next command
 27151 00003B08 BA5C00                  	mov	dx,FCB ; 5Ch
 27152 00003B0B CD21                    	int	21h		; Do the search
 27153 00003B0D 08C0                    	or	al,al
 27154 00003B0F C3                      	retn
 27155                                  
 27156                                  ; ---------------------------------------------------------------------------
 27157                                  
 27158                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27159                                  DOCOPY:
 27160 00003B10 BE[0B8D]                	mov	si,SrcBuf	; do name translate of source
 27161 00003B13 BF[CA87]                	mov	di,SRCXNAME	; save for name comparison
 27162 00003B16 B460                    	mov	ah,xNameTrans ; 60h
 27163 00003B18 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 27164                                  			; DS:SI	-> ASCIZ relative path string or directory name
 27165                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 27166 00003B1A C606[AF8A]00            	mov	byte [RDEOF],0	; no EOF yet
 27167                                  
 27168                                  	; MSDOS 6.0
 27169                                  	;mov	ax,ExtOpen shl 8	; open the file
 27170                                  	; 26/03/2023
 27171 00003B1F B8006C                  	mov	ax,6C00h
 27172                                  ;M046
 27173                                  ; For reads, the sharing mode should be deny none so that any process can
 27174                                  ;open this file again in any other sharing mode. This is mainly to allow
 27175                                  ;multiple command.com's to access the same file without getting sharing
 27176                                  ;violations
 27177                                  ;
 27178                                  	;mov	bx,deny_none|read_open_mode
 27179 00003B22 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 27180 00003B25 31C9                    	xor	cx,cx			; no special files
 27181                                  	;mov	dx,read_open_flag	; set up open flags
 27182 00003B27 BA0101                  	mov	dx,101h
 27183 00003B2A CD21                    	int	21h
 27184                                  	; 26/03/2023
 27185 00003B2C 7230                    	jc	short Error_On_Source
 27186                                  	;jnc	short OPENOK
 27187                                  
 27188                                  	;	Bogosity: IBM wants us to issue Access Denied in this case.
 27189                                  	;	They asked for it...
 27190                                  
 27191                                  	;jmp	short Error_On_Source ;AC022; clean up and exit
 27192                                  
 27193                                  	; 26/03/2023
 27194                                  	; MSDOS 3.3
 27195                                  	;mov	dx,SRCBUF
 27196                                  	;mov	ax,OPEN*256 ; 3D00h
 27197                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 27198                                  	;			; DS:DX	-> ASCIZ filename
 27199                                  	;			; AL = access mode
 27200                                  	;			; 0 - read
 27201                                  	;jnc	short OPENOK
 27202                                  	;call	GET_EXT_ERR_NUMBER
 27203                                  	;pushf
 27204                                  	;cmp	ax,65
 27205                                  	;jnz	short DOCOPY_ERR
 27206                                  	;mov	dx,ACCDENPTR
 27207                                  	;call	STD_PRINTF
 27208                                  ;DOCOPY_ERR:
 27209                                  	;popf
 27210                                  	;retn
 27211                                  
 27212                                  	; 26/03/2023
 27213                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27214                                  OPENOK:
 27215 00003B2E 89C3                    	mov	bx,ax
 27216 00003B30 891E[628D]              	mov	[SRCHAND],bx		; save handle
 27217 00003B34 B80057                  	mov	ax,File_Times*256 ; 5700h
 27218 00003B37 CD21                    	int	21h		; DOS -	2+ - GET FILE'S DATE/TIME
 27219                                  				; BX = file handle
 27220                                  
 27221 00003B39 7223                    	jc	short Error_On_Source ; MSDOS 6.0
 27222                                  
 27223 00003B3B 8916[C78D]              	mov	[CPDATE],dx		; save date
 27224 00003B3F 890E[C98D]              	mov	[CPTIME],cx		; save time
 27225                                  
 27226                                  	; MSDOS 6.0
 27227                                  	;jmp	short No_Copy_Xa 	; (xa copy code removed)
 27228                                  	; 26/04/2023
 27229                                  No_Copy_Xa:
 27230                                  	; 26/03/2023
 27231                                  	;mov	bx,[SRCHAND]		;AN022; get handle back
 27232                                  
 27233                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27234 00003B43 B80044                  	mov	ax,(IOCTL<<8) ; 4400h
 27235 00003B46 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27236                                  				; BX = file or device handle
 27237                                  	;and	dl,devid_ISDEV ; 80h
 27238                                  	; 18/04/2023
 27239 00003B48 80E280                  	and	dl,80h ; devid_ISDEV
 27240 00003B4B 8816[648D]              	mov	[SRCISDEV],dl		; set source info
 27241 00003B4F 7436                    	jz	short COPYLP		; source not a device
 27242 00003B51 803E[C08D]00            	cmp	byte [BINARY],0
 27243 00003B56 742F                    	je	short COPYLP		; ascii device ok
 27244 00003B58 BA[9580]                	mov	dx,INBDEV_PTR		; cannot do binary input
 27245 00003B5B E92703                  	jmp	COPYERR
 27246                                  
 27247                                  Error_On_Source:			;AN022; we have a BAD error
 27248 00003B5E E88BE1                  	call	Set_Ext_Error_Msg	;AN022; set up the error message
 27249 00003B61 C706[8C8C][0B8D]        	mov	word [string_ptr_2],SrcBuf
 27250                                  				;AN022; get address of failed string
 27251 00003B67 C606[337F]01            	mov	byte [extend_buf_sub],one_subst ; 1
 27252                                  				;AN022; put number of subst in control block
 27253 00003B6C E88C12                  	call	std_eprintf		;AN022; print it
 27254                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27255 00003B6F 8B1E[628D]              	mov	bx,[SRCHAND]
 27256                                  	;cmp	word [SRCHAND],0	;AN022; did we open the file?
 27257                                  	;je	short No_Close_Src	;AN022; no - don't close
 27258 00003B73 09DB                    	or	bx,bx
 27259 00003B75 7403                    	jz	short No_Close_Src
 27260                                  	;call	CLOSESRC		;AN022; clean up
 27261                                  	; 26/03/2023
 27262 00003B77 E89000                  	call	CLOSESRC2 ; bx = [SRCHAND]
 27263                                  No_Close_Src:				;AN022;
 27264 00003B7A 803E[BB8A]00            	cmp	byte [CFLAG],0		;AN022; was destination created?
 27265 00003B7F 7403                    	je	short EndCopyJ3		;AN022; no - just cleanup and exit
 27266 00003B81 E9C7FD                  	jmp	ENDCOPY			;AN022; clean up concatenation and exit
 27267                                  EndCopyJ3:				;AN022;
 27268 00003B84 E9C7FD                  	jmp	ENDCOPY2		;AN022;
 27269                                  
 27270                                  	; 26/04/2023
 27271                                  ;No_Copy_Xa:
 27272                                  ;	; 26/03/2023
 27273                                  ;	;mov	bx,[SRCHAND]		;AN022; get handle back
 27274                                  ;
 27275                                  ;	; MSDOS 3.3 (& MSDOS 6.0)
 27276                                  ;	mov	ax,(IOCTL<<8) ; 4400h
 27277                                  ;	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27278                                  ;				; BX = file or device handle
 27279                                  ;	;and	dl,devid_ISDEV ; 80h
 27280                                  ;	; 18/04/2023
 27281                                  ;	and	dl,80h ; devid_ISDEV
 27282                                  ;	mov	[SRCISDEV],dl		; set source info
 27283                                  ;	jz	short COPYLP		; source not a device
 27284                                  ;	cmp	byte [BINARY],0
 27285                                  ;	je	short COPYLP		; ascii device ok
 27286                                  ;	mov	dx,INBDEV_PTR		; cannot do binary input
 27287                                  ;	jmp	COPYERR
 27288                                  
 27289                                  COPYLP:
 27290                                  	; 26/03/2023
 27291 00003B87 8B1E[628D]              	mov	bx,[SRCHAND] ; ? ; 26/03/2023
 27292 00003B8B 8B0E[BD8A]              	mov	cx,[BYTCNT]
 27293 00003B8F 8B16[BF8A]              	mov	dx,[NXTADD]
 27294 00003B93 29D1                    	sub	cx,dx			; compute available space
 27295 00003B95 750E                    	jnz	short GOTROOM
 27296 00003B97 E8AE01                  	call	FlshFil   ; MSDOS 6.0
 27297                                  	;call	FLUSHFIL  ; MSDOS 3.3
 27298 00003B9A 803E[C38D]00            	cmp	byte [TERMREAD],0
 27299 00003B9F 7565                    	jne	short CLOSESRC		; give up
 27300 00003BA1 8B0E[BD8A]              	mov	cx,[BYTCNT]
 27301                                  GOTROOM:
 27302 00003BA5 1E                      	push	ds
 27303 00003BA6 8E1E[9E8A]              	mov	ds,[TPA]
 27304 00003BAA B43F                    	mov	ah,READ ; 3Fh
 27305 00003BAC CD21                    	int	21h		; DOS -	2+ - READ FROM FILE WITH HANDLE
 27306                                  				; BX = file handle,CX = number of bytes to read
 27307                                  				; DS:DX	-> buffer
 27308 00003BAE 1F                      	pop	ds
 27309                                  	;jc	short CLOSESRC	; MSDOS 3.3
 27310                                  	; 26/03/2023
 27311 00003BAF 72AD                    	jc	short Error_On_Source ; MSDOS 6.0
 27312 00003BB1 89C1                    	mov	cx,ax			; get count
 27313 00003BB3 E351                    	jcxz	CLOSESRC		; no more to read
 27314 00003BB5 803E[648D]00            	cmp	byte [SRCISDEV],0
 27315 00003BBA 7507                    	jne	short NOTESTA		; is a device, ascii mode
 27316 00003BBC 803E[C48D]00            	cmp	byte [ASCII],0
 27317 00003BC1 741B                    	je	short BINREAD
 27318                                  NOTESTA:
 27319 00003BC3 89CA                    	mov	dx,cx
 27320 00003BC5 8B3E[BF8A]              	mov	di,[NXTADD]
 27321 00003BC9 B01A                    	mov	al,1Ah
 27322 00003BCB 06                      	push	es
 27323 00003BCC 8E06[9E8A]              	mov	es,[TPA]		; scan for EOF
 27324 00003BD0 F2AE                    	repne	scasb
 27325 00003BD2 07                      	pop	es
 27326 00003BD3 7505                    	jnz	short USEALL
 27327 00003BD5 FE06[AF8A]              	inc	byte [RDEOF]
 27328 00003BD9 41                      	inc	cx
 27329                                  USEALL:
 27330 00003BDA 29CA                    	sub	dx,cx
 27331 00003BDC 89D1                    	mov	cx,dx
 27332                                  BINREAD:
 27333 00003BDE 030E[BF8A]              	add	cx,[NXTADD]
 27334 00003BE2 890E[BF8A]              	mov	[NXTADD],cx
 27335 00003BE6 3B0E[BD8A]              	cmp	cx,[BYTCNT]		; is buffer full?
 27336 00003BEA 720C                    	jb	short TESTDEV		; if not, we may have found eof
 27337                                  	; 26/03/2023
 27338 00003BEC E85901                  	call	FlshFil
 27339                                  	;call	FLUSHFIL
 27340 00003BEF 803E[C38D]00            	cmp	byte [TERMREAD],0
 27341 00003BF4 7510                    	jne	short CLOSESRC		; give up
 27342 00003BF6 EB8F                    	jmp	short COPYLP
 27343                                  TESTDEV:
 27344 00003BF8 803E[648D]00            	cmp	byte [SRCISDEV],0	; if file then EOF
 27345 00003BFD 7407                    	je	short CLOSESRC
 27346 00003BFF 803E[AF8A]00            	cmp	byte [RDEOF],0
 27347 00003C04 7481                    	je	short COPYLP		; on device, go till ^Z
 27348                                  CLOSESRC:
 27349 00003C06 8B1E[628D]              	mov	bx,[SRCHAND]
 27350                                  CLOSESRC2:
 27351 00003C0A B43E                    	mov	ah,CLOSE ; 3Eh
 27352 00003C0C CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27353                                  				; BX = file handle
 27354                                  CLOSESRCDEST_RETN:
 27355 00003C0E C3                      	retn
 27356                                  
 27357                                  ; ---------------------------------------------------------------------------
 27358                                  
 27359                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27360                                  CLOSEDEST:
 27361                                  
 27362                                  	;	We are called to close the destination.
 27363                                  	;	We need to note whether or not there is any internal data left
 27364                                  	;	to be flushed out.
 27365                                  
 27366 00003C0F 803E[BC8A]00            	cmp	byte [DestClosed],0
 27367 00003C14 75F8                    	jne	short CLOSESRCDEST_RETN	; don't double close
 27368 00003C16 A0[B78A]                	mov	al,[DestSwitch]
 27369 00003C19 E8C502                  	call	SETASC			; check for b or a switch
 27370 00003C1C 742E                    	jz	short BINCLOS		;   on destination
 27371 00003C1E 8B1E[BF8A]              	mov	bx,[NXTADD]
 27372                                  ;
 27373                                  ;M048 -- TryFlush changes the state of ConCat flag. So, before we append a
 27374                                  ;^Z, let's always flush out. This way if the ConCat flag changes, we will
 27375                                  ;just return without appending a ^Z incorrectly for the first file (since we
 27376                                  ;are concatenating now). Also, in case it is a single file copy, we will
 27377                                  ;anyway write the ^Z out separately. The only drawback is that there is a
 27378                                  ;performance overhead on single ASCII file copies which now always involve
 27379                                  ;2 writes instead of 1 before. Is this really that important?
 27380                                  ;
 27381                                  ;M048;	cmp	bx,[BYTCNT]		; is memory full?
 27382                                  ;M048;	jne	short PutZ
 27383                                  
 27384                                  	; 26/03/2023
 27385                                  	; MSDOS 3.3
 27386                                  	;cmp	bx,[BYTCNT]		; is memory full?
 27387                                  	;jne	short PUTZ
 27388                                  
 27389                                  	; 26/03/2023
 27390 00003C22 E81601                  	call	TRYFLUSH		; flush (and double-check for concat)	
 27391 00003C25 7402                    	jz	short NOCONC
 27392                                  CONCHNG:
 27393 00003C27 F9                      	stc
 27394 00003C28 C3                      	retn
 27395                                  
 27396                                  NOCONC:	
 27397 00003C29 31DB                    	xor	bx,bx
 27398                                  PUTZ:
 27399 00003C2B 1E                      	push	ds
 27400 00003C2C 8E1E[9E8A]              	mov	ds,[TPA]
 27401 00003C30 C7071A00                	mov	word [bx],1Ah	; add EOF mark (ctrl-Z)
 27402 00003C34 1F                      	pop	ds
 27403 00003C35 FF06[BF8A]              	inc	word [NXTADD]	; make sure our ^z gets written	
 27404 00003C39 C606[BF8D]00            	mov	byte [NOWRITE],0
 27405 00003C3E A1[C18D]                	mov	ax,[WRITTEN]
 27406 00003C41 0306[BF8A]              	add	ax,[NXTADD]
 27407 00003C45 7205                    	jc	short BINCLOS	; > 1
 27408 00003C47 83F801                  	cmp	ax,1
 27409 00003C4A 740C                    	je	short FORGETITJ	; Written = 0 NxtAdd = 1 (the ^Z)
 27410                                  BINCLOS:
 27411 00003C4C E8EC00                  	call	TRYFLUSH
 27412 00003C4F 75D6                    	jnz	short CONCHNG
 27413                                  
 27414                                  	; 26/04/2023
 27415 00003C51 833E[C18D]00            	cmp	word [WRITTEN],0
 27416                                  	; 26/03/2023
 27417 00003C56 7503                    	jnz	short NO_FORGET
 27418                                  FORGETITJ:
 27419                                  	;jz	short FORGETIT	; never wrote nothing
 27420                                  	; 26/03/2023
 27421 00003C58 E98500                  	jmp	FORGETIT ; 18/04/2023
 27422                                  NO_FORGET:			; wrote something
 27423 00003C5B 8B1E[FF8C]              	mov	bx,[DESTHAND]
 27424 00003C5F 8B0E[C98D]              	mov	cx,[CPTIME]
 27425 00003C63 8B16[C78D]              	mov	dx,[CPDATE]
 27426 00003C67 803E[BE8D]00            	cmp	byte [INEXACT],0 ; copy not exact?
 27427 00003C6C 7431                    	je	short DODCLOSE	; if no, copy date & time
 27428 00003C6E B42C                    	mov	ah,Get_Time ; 2Ch
 27429 00003C70 CD21                    	int	21h		; DOS -	GET CURRENT TIME
 27430                                  				; Return: CH = hours,CL = minutes,DH = seconds
 27431                                  				; DL = hundredths of seconds
 27432 00003C72 D0E1                    	shl	cl,1
 27433 00003C74 D0E1                    	shl	cl,1		; left justify min in cl
 27434 00003C76 D1E1                    	shl	cx,1
 27435 00003C78 D1E1                    	shl	cx,1
 27436 00003C7A D1E1                    	shl	cx,1		; hours to high 5 bits, min to 5-10
 27437 00003C7C D0EE                    	shr	dh,1		; divide seconds by 2 (now 5 bits)
 27438 00003C7E 08F1                    	or	cl,dh		; and stick into low 5 bits of cx
 27439 00003C80 51                      	push	cx		; save packed time
 27440 00003C81 B42A                    	mov	ah,Get_Date ; 2Ah
 27441 00003C83 CD21                    	int	21h		; DOS -	GET CURRENT DATE
 27442                                  				; Return: DL = day,DH = month,	CX = year
 27443                                  				; AL = day of the week (0=Sunday,1=Monday,etc.)
 27444 00003C85 81E9BC07                	sub	cx,1980
 27445 00003C89 86E9                    	xchg	ch,cl
 27446 00003C8B D1E1                    	shl	cx,1		; year to high 7 bits
 27447 00003C8D D0E6                    	shl	dh,1		; month to high 3 bits
 27448 00003C8F D0E6                    	shl	dh,1
 27449 00003C91 D0E6                    	shl	dh,1
 27450 00003C93 D0E6                    	shl	dh,1
 27451 00003C95 D0E6                    	shl	dh,1		; most sig bit of month in carry
 27452 00003C97 80D500                  	adc	ch,0		; put that bit next to year
 27453 00003C9A 08F2                    	or	dl,dh		; or low three of month into day
 27454 00003C9C 88EE                    	mov	dh,ch		; get year and high bit of month
 27455 00003C9E 59                      	pop	cx
 27456                                  DODCLOSE:
 27457 00003C9F 83FB00                  	cmp	bx,0
 27458 00003CA2 7E36                    	jle	short CLOSEDONE
 27459 00003CA4 B80157                  	mov	ax,(File_Times<<8)|1 ; 5701h
 27460 00003CA7 CD21                    	int	21h		; DOS -	2+ - SET FILE'S DATE/TIME
 27461                                  				; BX = file handle,CX = time to be set
 27462                                  				; DX = date to be set
 27463                                  	; 26/03/2023
 27464                                  	; MSDOS 6.0
 27465 00003CA9 721A                    	jc	short Cleanup_Err ;AN022; handle error
 27466                                  
 27467                                  	;	See if the destination has *anything* in it.
 27468                                  	;	If not, just close and delete it.
 27469                                  
 27470 00003CAB B80242                  	mov	ax,(LSEEK<<8)+2 ; 4202h	; seek to EOF
 27471 00003CAE 31D2                    	xor	dx,dx
 27472 00003CB0 89D1                    	mov	cx,dx
 27473 00003CB2 CD21                    	int	21h	; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 27474                                  			; AL = method: offset from end of file
 27475                                  	;	DX:AX is file size
 27476                                  
 27477 00003CB4 09C2                    	or	dx,ax
 27478 00003CB6 9C                      	pushf
 27479 00003CB7 B80044                  	mov	ax,(IOCTL<<8)+0 ; 4400h	; get the destination attributes
 27480 00003CBA CD21                    	int	21h	; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 27481                                  			; BX = file or device handle
 27482 00003CBC 52                      	push	dx		; save them away
 27483 00003CBD B43E                    	mov	ah,CLOSE ; 3Eh
 27484 00003CBF CD21                    	int	21h	; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27485                                  			; BX = file handle
 27486 00003CC1 5A                      	pop	dx
 27487                                  
 27488                                  	; 26/03/2023 - Retro DOS v4.0 COMMAND.COM
 27489                                  	; MSDOS 6.0
 27490 00003CC2 730D                    	jnc	short Close_Cont ;AN022; handle error on close
 27491 00003CC4 9D                      	popf			;AN022; get the flags back
 27492                                  Cleanup_Err: 			;AN022;
 27493 00003CC5 E85A00                  	call	CleanUpErr	;AN022; attempt to delete the target
 27494                                  	; 26/03/2023
 27495                                  	;call	DestDelete	;AN022; attempt to delete the target
 27496                                  	;jmp	short FILECLOSED
 27497                                  	;			;AN022; close the file
 27498                                  	; 26/03/2023
 27499                                  DestDel_fclosed:
 27500 00003CC8 E82700                  	call	DestDelete
 27501                                  FILECLOSED:
 27502 00003CCB FE06[BC8A]              	inc	byte [DestClosed]
 27503                                  RET50:
 27504 00003CCF F8                      	clc
 27505 00003CD0 C3                      	retn
 27506                                  	
 27507                                  Close_Cont:			;AN022; no error - co
 27508                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27509 00003CD1 9D                      	popf
 27510 00003CD2 7506                    	jnz	short CLOSEDONE
 27511 00003CD4 F7C28000                	test	dx,80h		; is the destination a device?
 27512                                  	;jnz	short CLOSEDONE	; yes, copy succeeded
 27513                                  	;call	DestDelete
 27514                                  	;jmp	short FILECLOSED
 27515                                  	; 26/03/2023
 27516 00003CD8 74EE                    	jz	short DestDel_fclosed
 27517                                  CLOSEDONE:
 27518 00003CDA FF06[C88A]              	inc	word [FileCnt]
 27519                                  	; 26/03/2023
 27520 00003CDE EBEB                    	jmp	short FILECLOSED
 27521                                  	
 27522                                  ;FILECLOSED:
 27523                                  ;	inc	byte [DestClosed]
 27524                                  ;RET50:
 27525                                  	;clc
 27526                                  	;retn
 27527                                  
 27528                                  FORGETIT:
 27529 00003CE0 8B1E[FF8C]              	mov	bx,[DESTHAND]
 27530 00003CE4 E8B8FF                  	call	DODCLOSE	 ; close the dest	
 27531 00003CE7 E80800                  	call	DestDelete
 27532 00003CEA C706[C88A]0000          	mov	word [FileCnt],0 ; no files transferred
 27533 00003CF0 EBDD                    	jmp	short RET50
 27534                                  
 27535                                  ; ---------------------------------------------------------------------------
 27536                                  
 27537                                  	; 26/03/2023
 27538                                  DestDelete:
 27539 00003CF2 BA[A88C]                	mov	dx,DestBuf
 27540 00003CF5 B441                    	mov	ah,Unlink ; 41h
 27541 00003CF7 CD21                    	int	21h	; DOS -	2+ - DELETE A FILE (UNLINK)
 27542                                  			; DS:DX	-> ASCIZ pathname of file to delete 
 27543                                  			;		(no wildcards allowed)
 27544 00003CF9 C3                      	retn
 27545                                  
 27546                                  ; ---------------------------------------------------------------------------
 27547                                  
 27548                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27549                                  SOURCE_SET:
 27550 00003CFA 56                      	push	si
 27551 00003CFB A1[D28D]                	mov	ax,[STARTEL]
 27552 00003CFE BE[658D]                	mov	si,ScanBuf	; adjust to copy
 27553 00003D01 29F0                    	sub	ax,si
 27554 00003D03 BF[0B8D]                	mov	di,SrcBuf
 27555 00003D06 01F8                    	add	ax,di
 27556 00003D08 A3[088D]                	mov	[SrcTail],ax
 27557 00003D0B 880E[078D]              	mov	[SrcSiz],cl	; save its size
 27558 00003D0F 41                      	inc	cx		; include the nul
 27559 00003D10 F3A4                    	rep	movsb		; save this source
 27560 00003D12 883E[0A8D]              	mov	[SrcInfo],bh	; save info about it
 27561 00003D16 5E                      	pop	si
 27562 00003D17 89E8                    	mov	ax,bp		; switches so far
 27563 00003D19 E8C501                  	call	SETASC		; set a,b switches accordingly
 27564 00003D1C E856EA                  	call	SWITCH		; get any more switches on this arg
 27565                                  	;call	SETASC		; set
 27566                                  	;retn
 27567                                  	; 26/03/2023
 27568 00003D1F E9BF01                  	jmp	SETASC
 27569                                  
 27570                                  ; =============== S U B	R O U T	I N E =======================================
 27571                                  
 27572                                  ; MSDOS 6.0
 27573                                  
 27574                                  ;****************************************************************
 27575                                  ;*
 27576                                  ;* ROUTINE:	CleanupErr
 27577                                  ;*
 27578                                  ;* FUNCTION:	Issues extended error message for destination
 27579                                  ;*		if not alreay issued
 27580                                  ;*
 27581                                  ;* INPUT:	return from INT 21
 27582                                  ;*
 27583                                  ;* OUTPUT:	none
 27584                                  ;*
 27585                                  ;****************************************************************
 27586                                  
 27587                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27588                                  	; MSDOS 6.0 (MSDOS 5.0) COMMAND.COM
 27589                                  CleanUpErr:	; proc	near		;AN022;
 27590                                  
 27591 00003D22 803E[0E8E]00            	cmp	byte [msg_flag],0	;AN022; have we already issued a message?
 27592 00003D27 7511                    	jnz	short CleanupErr_Cont	;AN022; yes - don't issue duplicate error
 27593 00003D29 E8C0DF                  	call	Set_Ext_Error_Msg	;AN022; set up error message
 27594 00003D2C C706[8C8C][A88C]        	mov	word [string_ptr_2],DestBuf 
 27595                                  					;AN022; get address of failed string
 27596 00003D32 C606[337F]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27597                                  					;AN022; put number of subst in control block
 27598 00003D37 E8C110                  	call	std_eprintf		;AN022; issue the error message
 27599                                  CleanupErr_Cont:			;AN022;
 27600 00003D3A C3                      	retn				;AN022; return to caller
 27601                                  
 27602                                  ;CleanUpErr	endp			;AN022;
 27603                                  
 27604                                  ;============================================================================
 27605                                  ; COPYPR1.ASM, MSDOS 6.0, 1991
 27606                                  ;============================================================================
 27607                                  ; 01/10/2018 - Retro DOS v3.0
 27608                                  
 27609                                  ; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 2FBBh
 27610                                  
 27611                                  ; =============== S U B	R O U T	I N E =======================================
 27612                                  
 27613                                  ;***	TryFlush - flush copy buffer, double-check for concatenation
 27614                                  ;
 27615                                  ;	EXIT	ZR set if concatenate flag unchanged
 27616                                  
 27617                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27618                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3EEAh
 27619                                  TRYFLUSH:
 27620 00003D3B A0[B18A]                	mov	al,[Concat]
 27621 00003D3E 50                      	push	ax
 27622                                  	;call	FLUSHFIL
 27623 00003D3F E80600                  	call	FlshFil
 27624 00003D42 58                      	pop	ax
 27625 00003D43 3A06[B18A]              	cmp	al,[Concat]
 27626 00003D47 C3                      	retn
 27627                                  
 27628                                  ; =============== S U B	R O U T	I N E =======================================
 27629                                  
 27630                                  	; 26/03/2023
 27631                                  	; MSDOS 3.3
 27632                                  ;FLUSHFIL:
 27633                                  	;mov	al,[BINARY]
 27634                                  	;mov	ah,[ASCII]
 27635                                  	;push	ax
 27636                                  	;call	FLSHFIL
 27637                                  	;pop	ax
 27638                                  	;mov	[ASCII],ah
 27639                                  	;mov	[BINARY],al
 27640                                  	;retn
 27641                                  
 27642                                  ; =============== S U B	R O U T	I N E =======================================
 27643                                  
 27644                                  ;***	Flshfil - write out any data remaining in copy buffer.
 27645                                  ;
 27646                                  ;	Inputs:
 27647                                  ;	  [NXTADD] = No. of bytes to write
 27648                                  ;	  [CFLAG] <> 0 if file has been created
 27649                                  ;	Outputs:
 27650                                  ;	  [NXTADD] = 0
 27651                                  
 27652                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27653                                  FlshFil:
 27654 00003D48 C606[C38D]00            	mov	byte [TERMREAD],0
 27655 00003D4D 803E[BB8A]00            	cmp	byte [CFLAG],0
 27656 00003D52 7403                    	jz	short NotExists
 27657 00003D54 E99600                  	jmp	Exists
 27658                                  NotExists:
 27659 00003D57 E8A101                  	call	BUILDDEST		; find out all about the destination
 27660 00003D5A E8FB03                  	call	COMPNAME		; source and dest. the same?
 27661 00003D5D 7519                    	jnz	short ProcDest		; if not, go ahead
 27662 00003D5F 803E[648D]00            	cmp	byte [SRCISDEV],0
 27663 00003D64 7512                    	jnz	short ProcDest		; same name on device ok
 27664 00003D66 803E[B18A]00            	cmp	byte [Concat],0		; concatenation?
 27665 00003D6B BA[5A7F]                	mov	dx,OVERWR_PTR
 27666                                  	;je	short COPERR		; not concatenating - overwrite error
 27667                                  	; 26/03/2023
 27668 00003D6E 7503                    	jne	short No_Concat_Err
 27669 00003D70 E91201                  	jmp	COPYERR
 27670                                  	
 27671                                  No_Concat_Err:	; concatenating
 27672 00003D73 C606[BF8D]01            	mov	byte [NOWRITE],1 	; flag not writing (just seeking)
 27673                                  ProcDest:
 27674                                  	; MSDOS 6.0
 27675                                  	;mov	ax,(ExtOpen<<8)		; open the file
 27676                                  	; 26/03/2023
 27677 00003D78 B8006C                  	mov	ax,6C00h
 27678 00003D7B BE[A88C]                	mov	si,DestBuf		; get file name
 27679                                  ;M046
 27680                                  ; For writes, we want to deny writes by anyone else at the same time that we
 27681                                  ;are writing to it. For instance, on a network, 2 workstations could try
 27682                                  ;writing to the same file. Also, because we opened the source file with
 27683                                  ;DENY NONE, it is fine if the source and destination files are the same as
 27684                                  ;would happen when we append to an existing file.
 27685                                  
 27686                                  	; 26/03/2023
 27687                                  	;mov	bx,deny_write|write_open_mode
 27688 00003D7E BB2100                  	mov	bx,21h			; get open mode for copy; M046
 27689 00003D81 31C9                    	xor	cx,cx			; no special files
 27690                                  	;mov	dx,write_open_flag	; set up open flags
 27691 00003D83 BA0101                  	mov	dx,101h	
 27692                                  
 27693 00003D86 803E[BF8D]00            	cmp	byte [NOWRITE],0
 27694 00003D8B 7503                    	jne	short DoDestOpen	; don't actually create if nowrite set
 27695                                  	;mov	dx,creat_open_flag	; set up create flags
 27696 00003D8D BA1201                  	mov	dx,112h
 27697                                  
 27698                                  	; 26/03/2023
 27699                                  	; MSDOS 3.3
 27700                                  	;mov	ax,(OPEN*256)+1 ; 3D01h ; open file, write access
 27701                                  	;cmp	byte [NOWRITE],0
 27702                                  	;jne	short DODESTOPEN
 27703                                  	;mov	ah,CREAT ; 3Ch
 27704                                  	;xor	cx,cx
 27705                                  ;DODESTOPEN:
 27706                                  	;mov	dx,DESTBUF
 27707                                  	;int	21h	; DOS -	2+ - CREATE A FILE WITH	HANDLE (CREAT)
 27708                                  	;		; CX = attributes for file
 27709                                  	;		; DS:DX	-> ASCIZ filename (may include drive and path)
 27710                                  
 27711                                  ; 26/03/2023
 27712                                  ;	; MSDOS 3.3 - COMMAND.COM, transient portion/segment offset 301Ch
 27713                                  ;	;mov	dx,FULDIRPTR
 27714                                  ;	;call	GET_EXT_ERR_NUMBER
 27715                                  ;	;jc	short COPERR
 27716                                  ;
 27717                                  ;	; 01/10/2018
 27718                                  ;	;jnc	short DEST_OPEN_OKAY
 27719                                  ;		
 27720                                  ;	;mov	dx,FULDIRPTR
 27721                                  ;	;call	GET_EXT_ERR_NUMBER
 27722                                  ;	;jmp	short COPERR
 27723                                  ;
 27724                                  ;	jc	short DEST_OPEN_ERROR
 27725                                  
 27726                                  	; 26/03/2023
 27727                                  DoDestOpen:
 27728 00003D90 CD21                    	int     21h	; DOS - 4.0 - EXTENDED OPEN/CREATE
 27729                                  			; BL = open mode as in AL for normal open (INT 21h/AH=3Dh)
 27730                                  			; BH = flags
 27731                                  			; CX = create attribute
 27732                                  			; DL = action if file exists/does not exists
 27733                                  			; DH = 00h (reserved), DS:SI -> ASCIZ file name
 27734                                  
 27735                                  ;	We assume that the error is normal.
 27736                                  ;	TriageError will correct the DX value appropriately.
 27737                                  	
 27738 00003D92 7311                    	jnc	short Dest_Open_Okay
 27739                                  Xa_Set_Error:				;AN030; error occurred on XA
 27740 00003D94 E855DF                  	call	Set_Ext_Error_Msg	;AN030; get extended error
 27741                                  
 27742                                  	; 26/04/2023 - Retro DOS v4.0 ( 4.1) COMMAND.COM
 27743                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:3F46h
 27744                                  Ext_Err_Set:				;AN030;
 27745 00003D97 C706[8C8C][A88C]        	mov	word [string_ptr_2],DestBuf
 27746                                  					;AN000; get address of failed string
 27747 00003D9D C606[337F]01            	mov	byte [extend_buf_sub],one_subst ; 1 
 27748                                  					;AN030; put number of subst in control block
 27749                                  CopErrJ2:				;AN030;
 27750 00003DA2 E9E000                  	jmp	COPYERR			;AN030; go issue message
 27751                                  
 27752                                  ;DEST_OPEN_OKAY:
 27753                                  	; 26/03/2023
 27754                                  Dest_Open_Okay:
 27755 00003DA5 A3[FF8C]                	mov	[DESTHAND],ax		; save handle
 27756 00003DA8 C606[BB8A]01            	mov	byte [CFLAG],1		; destination now exists
 27757 00003DAD 89C3                    	mov	bx,ax
 27758 00003DAF B80044                  	mov	ax,IOCTL*256 ; 4400h 	; get device stuff
 27759 00003DB2 CD21                    	int	21h	   	; DOS - 2+ - IOCTL - GET DEVICE INFORMATION
 27760                                  			   	; BX = file or device handle
 27761                                  
 27762 00003DB4 8816[018D]              	mov	[DESTISDEV],dl		; set dest info
 27763                                  	; 18/04/2023
 27764 00003DB8 F6C280                  	test	dl,80h
 27765                                  	;test	dl,devid_ISDEV
 27766 00003DBB 7430                    	jz	short Exists		; Dest not a device
 27767                                  
 27768                                  ;	Destination is device.
 27769                                  
 27770 00003DBD A0[B78A]                	mov	al,byte [DestSwitch]
 27771                                  	; 26/03/2023
 27772 00003DC0 240C                    	and	al,0Ch
 27773                                  	;and	al,SWITCHA+SWITCHB ; 4+8
 27774 00003DC2 7509                    	jnz	short TestBoth
 27775 00003DC4 A0[C48D]                	mov	al,[ASCII]		; neither set, use current setting
 27776 00003DC7 0A06[C08D]              	or	al,[BINARY]
 27777 00003DCB 7416                    	jz	short ExSetA		; neither set, default to ascii
 27778                                  TestBoth:
 27779 00003DCD 7A1E                    	jpe	short Exists		; both are set, ignore
 27780 00003DCF A808                    	test	al,8
 27781                                  	;test	al,SWITCHB
 27782 00003DD1 741A                    	jz	short Exists
 27783                                  	;mov	ax,(IOCTL shl 8) or 1
 27784 00003DD3 B80144                  	mov	ax,(IOCTL<<8)|1 ; 4401h
 27785 00003DD6 30F6                    	xor	dh,dh
 27786                                  	; 18/04/2023
 27787 00003DD8 80CA20                  	or	dl,20h
 27788                                  	;or	dl,devid_RAW
 27789 00003DDB 8816[018D]              	mov	[DESTISDEV],dl
 27790 00003DDF CD21                    	int	21h	; DOS -	2+ - IOCTL - SET DEVICE	INFORMATION
 27791                                  			; BX = device handle,DH = 0
 27792                                  			; DL = device information to set (bits 0-7 from	function 0)
 27793 00003DE1 EB0A                    	jmp	short Exists
 27794                                  
 27795                                  	; 26/03/2023
 27796                                  	; 01/10/2018 - Retro DOS v3.0 modification
 27797                                  ;DEST_OPEN_ERROR:
 27798                                  	;mov	dx,FULDIRPTR
 27799                                  	;call	GET_EXT_ERR_NUMBER
 27800                                  ;COPERR:
 27801                                  	; 26/03/2023
 27802                                  ;CopyErrj:
 27803                                  	;jmp	short COPYERR
 27804                                  
 27805                                  ExSetA:
 27806                                  ;	What we read in may have been in binary mode, flag zapped write OK
 27807                                  
 27808 00003DE3 C606[C48D]04            	mov	byte [ASCII],4
 27809                                  	;mov	byte [ASCII],SWITCHA	; set ascii mode
 27810 00003DE8 800E[BE8D]04            	or	byte [INEXACT],4
 27811                                  	;or	byte [INEXACT],SWITCHA	; ascii -> inexact
 27812                                  Exists:
 27813 00003DED 803E[BF8D]00            	cmp	byte [NOWRITE],0
 27814 00003DF2 7524                    	jnz	short NoChecking	; if nowrite don't bother with name check
 27815 00003DF4 803E[028C]01            	cmp	byte [plus_comma],1	; don't check if just doing +,,
 27816 00003DF9 741D                    	jz	short NoChecking
 27817 00003DFB E85A03                  	call	COMPNAME		; source and dest. the same?
 27818 00003DFE 7518                    	jnz	short NoChecking	; if not, go ahead
 27819 00003E00 803E[648D]00            	cmp	byte [SRCISDEV],0
 27820 00003E05 7511                    	jne	short NoChecking	; same name on device ok
 27821                                  
 27822                                  ;	At this point we know in append (would have gotten overwrite error
 27823                                  ;	on first destination create otherwise), and user trying to specify
 27824                                  ;	destination which has been scribbled already (if dest had been named
 27825                                  ;	first, NoWrite would be set).
 27826                                  
 27827 00003E07 BA[5D7F]                	mov	dx,LOSTERR_PTR		; tell him he's not going to get it
 27828                                  	;invoke	Std_EprintF		;ac022;
 27829                                  	; 26/03/2023
 27830 00003E0A E8EE0F                  	call	std_eprintf ; MSDOS 6.0 (& 5.0)
 27831                                  	;call	STD_PRINTF  ; MSDOS 3.3	
 27832 00003E0D C706[BF8A]0000          	mov	word [NXTADD],0		; set return
 27833 00003E13 FE06[C38D]              	inc	byte [TERMREAD]		; tell read to give up
 27834                                  Ret60:
 27835 00003E17 C3                      	retn
 27836                                  
 27837                                  NoChecking:
 27838 00003E18 8B1E[FF8C]              	mov	bx,[DESTHAND]		; get handle
 27839 00003E1C 31C9                    	xor	cx,cx
 27840 00003E1E 870E[BF8A]              	xchg	cx,[NXTADD]
 27841 00003E22 E3F3                    	jcxz	Ret60			; if nothing to write, forget it
 27842 00003E24 FF06[C18D]              	inc	word [WRITTEN]		; flag that we wrote something
 27843 00003E28 803E[BF8D]00            	cmp	byte [NOWRITE],0	; if nowrite set, just seek cx bytes
 27844 00003E2D 7514                    	jnz	short SeekEnd
 27845 00003E2F 31D2                    	xor	dx,dx
 27846 00003E31 1E                      	push	ds
 27847 00003E32 8E1E[9E8A]              	mov	ds,[TPA]
 27848 00003E36 B440                    	mov	ah,Write ; 40h
 27849 00003E38 CD21                    	int	21h	; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 27850                                  			; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 27851 00003E3A 1F                      	pop	ds
 27852 00003E3B BA[457F]                	mov	dx,NOSPACE_PTR
 27853                                  	;jc	short COPERRP		; failure
 27854                                  	; 26/03/2023
 27855                                  	; MSDOS 6.0
 27856 00003E3E 7326                    	jnc	short NoChecking2
 27857 00003E40 E951FF                  	jmp	Xa_Set_Error
 27858                                  
 27859                                  	; 18/04/2023
 27860                                  	; 26/03/2023
 27861                                  SeekEnd:
 27862 00003E43 31D2                    	xor	dx,dx
 27863 00003E45 87D1                    	xchg	dx,cx
 27864                                  	;mov	ax,(LSEEK shl 8) or 1
 27865 00003E47 B80142                  	mov	ax,(LSEEK<<8)|1 ; 4201h
 27866 00003E4A CD21                    	int	21h		; DOS -	2+ - MOVE FILE READ/WRITE POINTER (LSEEK)
 27867                                  				; AL = method: offset from present location
 27868                                  
 27869                                  	; 26/03/2023
 27870                                  	; MSDOS 6.0
 27871                                  
 27872                                  ;	Save the file pointer in DX:AX to restore the file
 27873                                  ;	with in case the copy should fail.
 27874                                  
 27875 00003E4C A3[CB8D]                	mov	[OFilePtr_Lo],ax
 27876 00003E4F 8916[CD8D]              	mov	[OFilePtr_Hi],dx
 27877                                  
 27878                                  	; 26/03/2023
 27879                                  	; MSDOS 3.3  MSDOS 6.0
 27880                                  
 27881 00003E53 803E[AF8A]00            	cmp	byte [RDEOF],0
 27882 00003E58 740B                    	jz	short Retz60
 27883                                  
 27884                                  ;	^Z has been read - we must set the file size to the current
 27885                                  ;	file pointer location
 27886                                  
 27887 00003E5A B440                    	mov	ah,Write ; 40h
 27888 00003E5C CD21                    	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 27889                                  				; BX = file handle,CX = number	of bytes to write,DS:DX -> buffer
 27890                                  
 27891                                  	; 26/03/2023
 27892                                  	; MSDOS 6.0
 27893 00003E5E 727E                    	jc	short Xa_Set_Error_Jmp	;AC022; failure
 27894                                  
 27895                                  ;	Make note that ^Z was removed, in case the
 27896                                  ;	copy should fail and we need to restore the file.
 27897                                  
 27898 00003E60 C606[CF8D]1A            	mov	byte [OCtrlZ],1Ah
 27899                                  Retz60:
 27900 00003E65 C3                      	retn
 27901                                  
 27902                                  NoChecking2:
 27903 00003E66 29C1                    	sub	cx,ax
 27904 00003E68 74AD                    	jz	short Ret60		; wrote all supposed to
 27905                                  	; 18/04/2023
 27906 00003E6A F606[018D]80            	test	byte [DESTISDEV],80h ; devid_ISDEV
 27907                                  	;test	byte [DESTISDEV],devid_ISDEV ;80h
 27908 00003E6F 7414                    	jz	short COPYERR		; is a file, error
 27909 00003E71 F606[018D]20            	test	byte [DESTISDEV],20h  ; devid_RAW
 27910                                  	;test	byte [DESTISDEV],devid_RAW ; 20h
 27911 00003E76 750A                    	jnz	short DevWrtErr	; is a raw device, error
 27912 00003E78 803E[BE8D]00            	cmp	byte [INEXACT],0
 27913 00003E7D 7598                    	jnz	short Ret60		; inexact so ok
 27914 00003E7F 49                      	dec	cx
 27915                                  ;Retz60:
 27916 00003E80 7495                    	jz	short Ret60		; wrote one byte less (the ^z)		
 27917                                  
 27918                                  DevWrtErr:
 27919 00003E82 BA[C880]                	mov	dx,DEVWMES_PTR
 27920                                  	; 26/03/2023
 27921                                  COPYERR:
 27922                                  	;invoke	Std_EPrintF		;AC022;
 27923 00003E85 E8730F                  	call	std_eprintf  ; MSDOS 6.0
 27924                                  	;call	STD_PRINTF   ; MSDOS 3.3
 27925                                  CopErrP:
 27926 00003E88 FE06[BC8A]              	inc	byte [DestClosed]
 27927 00003E8C 803E[BB8A]00            	cmp	byte [CFLAG],0
 27928 00003E91 7448                    	jz	short EndCopyJ		; never actually got it open
 27929 00003E93 8B1E[FF8C]              	mov	bx,[DESTHAND]
 27930 00003E97 83FB00                  	cmp	bx,0
 27931 00003E9A 7E33                    	jle	short NoClose
 27932                                  
 27933                                  ;	Check to see if we should save part of the destination file.
 27934                                  
 27935                                  	; 26/03/2023
 27936                                  	; MSDOS 6.0
 27937 00003E9C 8B0E[CD8D]              	mov	cx,[OFilePtr_Hi]	; CX = hi word of original file ptr
 27938 00003EA0 8B16[CB8D]              	mov	dx,[OFilePtr_Lo]	; DX = lo word of original file ptr
 27939                                  			
 27940 00003EA4 89C8                    	mov	ax,cx
 27941 00003EA6 09D0                    	or	ax,dx
 27942 00003EA8 7421                    	jz	short ceClose		; null file ptr means nothing to save
 27943                                  
 27944                                  ;	Destination was also the first source. Do the best we can to
 27945                                  ;	restore it. Truncate it back to the size we took from it (which
 27946                                  ;	may have been due to a Ctrl-Z, so may not have included the whole
 27947                                  ;	file). If a Ctrl-Z was originally read, put it back.
 27948                                  
 27949 00003EAA B80042                  	mov	ax,(LSEEK<<8) ; 4200h
 27950 00003EAD CD21                    	int	21h
 27951                                  
 27952 00003EAF 31C9                    	xor	cx,cx			; CX = # bytes to write = 0
 27953 00003EB1 B440                    	mov	ah,Write ; 40h
 27954 00003EB3 CD21                    	int	21h			; truncate file
 27955                                  
 27956 00003EB5 803E[CF8D]00            	cmp	byte [OCtrlZ],0
 27957 00003EBA 7408                    	je	short ceClose0		; no ctrl-z removed from original
 27958 00003EBC 41                      	inc	cx			; CX = # bytes to write = 1
 27959 00003EBD BA[CF8D]                	mov	dx,OCtrlZ		; DS:DX = ptr to original ctrl-z
 27960 00003EC0 B440                    	mov	ah,Write ; 40h
 27961 00003EC2 CD21                    	int	21h			; write ctrl-z
 27962                                  ceClose0:
 27963 00003EC4 B43E                    	mov	ah,CLOSE ; 3Eh
 27964 00003EC6 CD21                    	int	21h			; close it
 27965                                  ;;	;mov	byte [CFLAG],0
 27966 00003EC8 E980FA                  	jmp	ENDCOPY			; and go home
 27967                                  
 27968                                  	; MSDOS 3.3 (& MSDOS 6.0)
 27969                                  ceClose:
 27970 00003ECB B43E                    	mov	ah,CLOSE ; 3Eh		; close the file
 27971 00003ECD CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 27972                                  				; BX = file handle
 27973                                  NoClose:
 27974 00003ECF BA[A88C]                	mov	dx,DestBuf
 27975 00003ED2 B441                    	mov	ah,Unlink ; 41h 	; and delete it
 27976 00003ED4 CD21                    	int	21h		; DOS -	2+ - DELETE A FILE (UNLINK)
 27977                                  				; DS:DX	-> ASCIZ pathname of file to delete (no	wildcards allowed)
 27978 00003ED6 C606[BB8A]00            	mov	byte [CFLAG],0
 27979                                  EndCopyJ:
 27980 00003EDB E96DFA                  	jmp	ENDCOPY
 27981                                  
 27982                                  Xa_Set_Error_Jmp:			;AN022; go set up error message
 27983 00003EDE E9B3FE                  	jmp	Xa_Set_Error
 27984                                  
 27985                                  ;============================================================================
 27986                                  ; COPYPR2.ASM, MSDOS 6.0, 1991
 27987                                  ;============================================================================
 27988                                  ; 01/10/2018 - Retro DOS v3.0
 27989                                  
 27990                                  ; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 311Fh
 27991                                  
 27992                                  	; 26/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 27993                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4095h
 27994                                  
 27995                                  ; =============== S U B	R O U T	I N E =======================================
 27996                                  
 27997                                  ;***	SetAsc - set Ascii, Binary, Inexact flags based on switches
 27998                                  ;
 27999                                  ;	Given switch vector in AX,
 28000                                  ;	  Set Ascii flag if /a is set
 28001                                  ;	  Clear Ascii flag if /b is set
 28002                                  ;	  Binary set if /b specified
 28003                                  ;	  Leave Ascii unchanged if neither or both are set
 28004                                  ; 	Also sets Inexact if Ascii is ever set. 
 28005                                  ;	AL = Ascii on exit, flags set
 28006                                  
 28007                                  	; 26/03/2023
 28008                                  SETASC:
 28009                                  	;and	al,SWITCHA+SWITCHB ; 0Ch ; AL = /a, /b flags
 28010 00003EE1 240C                    	and	al,0Ch ; 4+8
 28011 00003EE3 7A10                    	jpe	short LOADSW	; even parity - both or neither
 28012 00003EE5 50                      	push	ax
 28013                                  	;and	al,SWITCHB  ; 8
 28014 00003EE6 2408                    	and	al,8
 28015 00003EE8 A2[C08D]                	mov	[BINARY],al
 28016 00003EEB 58                      	pop	ax
 28017                                  	;and	al,SWITCHA
 28018 00003EEC 2404                    	and	al,4	
 28019 00003EEE A2[C48D]                	mov	[ASCII],al
 28020 00003EF1 0806[BE8D]              	or	[INEXACT],al
 28021                                  LOADSW:
 28022 00003EF5 A0[C48D]                	mov	al,[ASCII]
 28023 00003EF8 08C0                    	or	al,al
 28024 00003EFA C3                      	retn
 28025                                  
 28026                                  ; =============== S U B	R O U T	I N E =======================================
 28027                                  
 28028                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28029                                  BUILDDEST:
 28030 00003EFB 803E[A38C]FF            	cmp	byte [DestIsDir],-1 ; 0FFh
 28031 00003F00 750C                    	jnz	short KNOWABOUTDEST	; figuring already done
 28032 00003F02 BF[7E89]                	mov	di,USERDIR1
 28033 00003F05 BD[A38C]                	mov	bp,DestVars
 28034 00003F08 E8DF00                  	call	BUILDPATH
 28035 00003F0B E86CE5                  	call	RestUDir1
 28036                                  
 28037                                  ;	We now know all about the destination
 28038                                  
 28039                                  KNOWABOUTDEST:
 28040 00003F0E 30C0                    	xor	al,al
 28041 00003F10 8606[028D]              	xchg	al,[FIRSTDEST]
 28042 00003F14 08C0                    	or	al,al
 28043 00003F16 7503                    	jnz	short FIRSTDST
 28044 00003F18 E98C00                  	jmp	NOFIRSTDEST
 28045                                  
 28046                                  FIRSTDST:
 28047                                  ;	Create an fcb of the original dest.
 28048                                  
 28049 00003F1B 8B36[A58C]              	mov	si,[DestTail]
 28050 00003F1F BF[628B]                	mov	di,DestFcb
 28051 00003F22 B80029                  	mov	ax,Parse_File_Descriptor*256 ; 2900h
 28052 00003F25 CD21                    	int	21h		; DOS -	PARSE FILENAME
 28053                                  				; DS:SI	-> string to parse
 28054                                  				; ES:DI	-> buffer to fill with unopened	FCB
 28055                                  				; AL = bit mask	to control parsing
 28056 00003F27 803C00                  	cmp	byte [si],0
 28057 00003F2A 7406                    	jz	short GOODPARSE
 28058                                  
 28059                                  	; 27/03/2023	
 28060                                  	; MSDOS 6.0
 28061                                  	;mov	byte [di+1],"|"	;AD052; must be illegal file name character
 28062                                  	
 28063 00003F2C BA[4B7F]                	mov	dx,FULLDIR_PTR		;AN052; issue "file creation error"
 28064 00003F2F E953FF                  	jmp	COPYERR			;AN052;
 28065                                  GOODPARSE:
 28066 00003F32 A1[A88C]                	mov	ax,[DestBuf]		; AX = possible "d:"
 28067 00003F35 80FC3A                  	cmp	ah,':'
 28068 00003F38 7402                    	jz	short DRVSPEC4
 28069 00003F3A B040                    	mov	al,'@'  ; 40h
 28070                                  DRVSPEC4:
 28071                                  ;	AX = "d:" for following FCB drive computation
 28072                                  
 28073 00003F3C 8A0E[C48D]              	mov	cl,[ASCII]		; CL = saved Ascii flag
 28074 00003F40 0C20                    	or	al,20h
 28075 00003F42 2C60                    	sub	al,60h
 28076 00003F44 A2[628B]                	mov	[DestFcb],al		; store drive # in FCB
 28077                                  
 28078                                  ;*	Figure out what copy mode we're in.
 28079                                  ;	Letters stand for unambiguous, * for ambiguous pathnames.
 28080                                  ;	+n stands for additional sources delimited by +'s.
 28081                                  ;
 28082                                  ;	copy a b	not concatenating
 28083                                  ;	copy a *	not concatenating
 28084                                  ;	copy * a	concatenating
 28085                                  ;	copy * *	not concatenating
 28086                                  ;	copy a+n b	concatenating
 28087                                  ;	copy *+n a	concatenating
 28088                                  ;	copy *+n *	concatenating, Mel Hallerman style
 28089                                  
 28090                                  ;	Bugbug:  copy *.a+a.b *.t  picks up only 1st *.a file.. Why?
 28091                                  ;		 copy a.b+*.a *.t  picks up all *.a files.
 28092                                  
 28093 00003F47 A0[A78C]                	mov	al,[DestInfo]		; AL = destination CParse flags
 28094 00003F4A 8A26[0A8D]              	mov	ah,[SrcInfo]		; AH = source CParse flags
 28095 00003F4E 250202                  	and	ax,202h			; AH,AL = source,dest wildcard flags
 28096 00003F51 08C0                    	or	al,al
 28097 00003F53 7413                    	jz	short NOTMELCOPY 	; no destination wildcard
 28098                                  
 28099                                  ;	Destination is wildcarded.
 28100                                  	
 28101 00003F55 38E0                    	cmp	al,ah
 28102 00003F57 750F                    	jnz	short NOTMELCOPY ; no source wildcard
 28103                                  
 28104                                  ;	Source and destination are both wildcarded.
 28105                                  
 28106 00003F59 803E[C58D]00            	cmp	byte [PLUS],0
 28107 00003F5E 7408                    	jz	short NOTMELCOPY	; no +'s in source
 28108                                  
 28109                                  ;	Source and destination are wildcarded, and source includes +'s.
 28110                                  ;	It's Mel Hallorman copy time.
 28111                                  
 28112 00003F60 FE06[038D]              	inc	byte [MELCOPY]		; 'Mel copy' = true
 28113 00003F64 30C0                    	xor	al,al
 28114 00003F66 EB06                    	jmp	short SETCONC
 28115                                  
 28116                                  NOTMELCOPY:
 28117 00003F68 3402                    	xor	al,2			; AL=0 -> ambiguous destination, 2 otherwise
 28118 00003F6A 20E0                    	and	al,ah
 28119 00003F6C D0E8                    	shr	al,1			; AL=1 -> ambiguous source, unambiguous dest
 28120                                  					;   (implies concatenation)
 28121                                  SETCONC:
 28122 00003F6E 0A06[C58D]              	or	al,[PLUS]		; "+" always infers concatenation
 28123                                  
 28124                                  ;	Whew. AL = 1 if concatenating, 0 if not.
 28125                                  
 28126 00003F72 A2[B18A]                	mov	[Concat],al
 28127 00003F75 D0E0                    	shl	al,1
 28128 00003F77 D0E0                    	shl	al,1
 28129 00003F79 A2[BE8D]                	mov	[INEXACT],al		; concatenation -> inexact copy
 28130 00003F7C 803E[C08D]00            	cmp	byte [BINARY],0
 28131 00003F81 7524                    	jne	short NOFIRSTDEST 	; explicit binary copy	
 28132                                  
 28133 00003F83 A2[C48D]                	mov	[ASCII],al		; otherwise, concatenate in ascii mode	
 28134 00003F86 08C9                    	or	cl,cl
 28135 00003F88 751D                    	jnz	short NOFIRSTDEST 	; Ascii flag set before, data read correctly	
 28136 00003F8A 08C0                    	or	al,al
 28137 00003F8C 7419                    	jz	short NOFIRSTDEST 	; Ascii flag did not change state
 28138                                  
 28139                                  ;	At this point there may already be binary read data in the read
 28140                                  ;	buffer. We need to find the first ^Z (if there is one) and trim the
 28141                                  ;	amount of data in the buffer correctly.
 28142                                  
 28143 00003F8E 8B0E[BF8A]              	mov	cx,[NXTADD]
 28144 00003F92 E313                    	jcxz	NOFIRSTDEST		; no data, everything ok
 28145 00003F94 B01A                    	mov	al,1Ah
 28146 00003F96 06                      	push	es
 28147 00003F97 31FF                    	xor	di,di
 28148 00003F99 8E06[9E8A]              	mov	es,[TPA]
 28149 00003F9D F2AE                    	repne	scasb			; scan for EOF
 28150 00003F9F 07                      	pop	es
 28151 00003FA0 7505                    	jnz	short NOFIRSTDEST 	; no ^z in buffer, everything ok
 28152 00003FA2 4F                      	dec	di			; point at ^z
 28153 00003FA3 893E[BF8A]              	mov	[NXTADD],di		; new buffer length
 28154                                  
 28155                                  NOFIRSTDEST:
 28156 00003FA7 BB[A68B]                	mov	bx,DIRBUF+1		; Source of replacement chars
 28157 00003FAA 803E[B18A]00            	cmp	byte [Concat],0
 28158 00003FAF 7403                    	jz	short GOTCHRSRC		; Not a concat
 28159 00003FB1 BB[EC8B]                	mov	bx,SDIRBUF+1		; Source of replacement chars
 28160                                  GOTCHRSRC:
 28161 00003FB4 BE[638B]                	mov	si,DestFcb+1		; Original dest name
 28162 00003FB7 8B3E[A58C]              	mov	di,[DestTail]		; Where to put result
 28163                                  
 28164                                  ; --------------- S U B	R O U T	I N E --------------------------------------- 
 28165                                  
 28166                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28167                                  BUILDNAME:
 28168 00003FBB B90800                  	mov	cx,8
 28169                                  BUILDMAIN:
 28170 00003FBE AC                      	lodsb
 28171 00003FBF 3C3F                    	cmp	al,'?'
 28172 00003FC1 7502                    	jne	short NOTAMBIG
 28173 00003FC3 8A07                    	mov	al,[bx]
 28174                                  NOTAMBIG:
 28175 00003FC5 3C20                    	cmp	al,' '
 28176 00003FC7 7401                    	je	short NOSTORE
 28177 00003FC9 AA                      	stosb
 28178                                  NOSTORE:
 28179 00003FCA 43                      	inc	bx
 28180 00003FCB E2F1                    	loop	BUILDMAIN
 28181 00003FCD B103                    	mov	cl,3
 28182                                  	;mov	al,' ' ; 20h
 28183                                  	;cmp	[si],al
 28184                                  	; 27/03/2023
 28185 00003FCF 803C20                  	cmp	byte [si],20h ; ' '
 28186 00003FD2 7412                    	je	short ENDDEST		; No extension
 28187                                  	;mov	al,[DOT_CHR]
 28188                                  	; 27/03/2023
 28189 00003FD4 B02E                    	mov	al,'.' ; 2Eh ; dot_chr
 28190 00003FD6 AA                      	stosb
 28191                                  BUILDEXT:
 28192 00003FD7 AC                      	lodsb
 28193 00003FD8 3C3F                    	cmp	al,'?'
 28194 00003FDA 7502                    	jne	short NOTAMBIGE
 28195 00003FDC 8A07                    	mov	al,[bx]
 28196                                  NOTAMBIGE:
 28197 00003FDE 3C20                    	cmp	al,' '
 28198 00003FE0 7401                    	je	short NOSTOREE
 28199 00003FE2 AA                      	stosb
 28200                                  NOSTOREE:
 28201 00003FE3 43                      	inc	bx
 28202 00003FE4 E2F1                    	loop	BUILDEXT
 28203                                  ENDDEST:
 28204 00003FE6 30C0                    	xor	al,al
 28205 00003FE8 AA                      	stosb				; NUL terminate
 28206 00003FE9 C3                      	retn
 28207                                  
 28208                                  ; =============== S U B	R O U T	I N E =======================================
 28209                                  	
 28210                                  	; 28/03/2023
 28211                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28212                                  BUILDPATH:
 28213 00003FEA F6460402                	test	byte [bp+VARSTRUC.INFO],2 ; test byte [bp+4],2
 28214 00003FEE 7543                    	jnz	short NOTPFILE		; If ambig don't bother with open
 28215 00003FF0 89EA                    	mov	dx,bp			; Set DX to spec
 28216 00003FF2 83C205                  	add	dx,VARSTRUC.BUF 	; add dx,5
 28217                                  
 28218                                  	; 27/03/2023
 28219                                  	; MSDOS 6.0
 28220 00003FF5 57                      	push	di			;AN000;
 28221 00003FF6 B8006C                  	mov	ax,(ExtOpen<<8)	; 6C00h	;AC000; open the file
 28222                                  	;mov	bx,deny_none|read_open_mode
 28223 00003FF9 BB4000                  	mov	bx,40h			; open mode for COPY ;M046
 28224 00003FFC 31C9                    	xor	cx,cx			;AN000; no special files
 28225 00003FFE 89D6                    	mov	si,dx			;AN030; get file name offset
 28226                                  	;mov	dx,read_open_flag	;AN000; set up open flags
 28227 00004000 BA0101                  	mov	dx,101h
 28228 00004003 CD21                    	INT	21h
 28229 00004005 5F                      	pop	di			;AN000;
 28230 00004006 7315                    	jnc	short PURE_FILE		;AN022; is pure file
 28231 00004008 E8F1DC                  	call	get_ext_error_number	;AN022; get the extended error
 28232                                  	;cmp	ax,2
 28233 0000400B 83F802                  	cmp	ax,ERROR_FILE_NOT_FOUND ;AN022; if file not found - okay
 28234 0000400E 7423                    	jz	short NOTPFILE		;AN022;
 28235                                  	;cmp	ax,3
 28236 00004010 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28237 00004013 741E                    	jz	short NOTPFILE		;AN022;
 28238                                  	;cmp	ax,5
 28239 00004015 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28240 00004018 7419                    	jz	short NOTPFILE		;AN022;
 28241 0000401A E922DA                  	jmp	extend_setup		;AN022; exit with error
 28242                                  
 28243                                  	; 27/03/2023
 28244                                  	; MSDOS 3.3
 28245                                  	;mov	ax,OPEN*256 ; 3D00h
 28246                                  	;int	21h		; DOS -	2+ - OPEN DISK FILE WITH HANDLE
 28247                                  	;			; DS:DX	-> ASCIZ filename
 28248                                  	;			; AL = access mode
 28249                                  	;			; 0 - read
 28250                                  	;jc	short NOTPFILE
 28251                                  
 28252                                  PURE_FILE:
 28253 0000401D 89C3                    	mov	bx,ax
 28254 0000401F B80044                  	mov	ax,IOCTL*256 ; 4400h
 28255 00004022 CD21                    	int	21h		; DOS -	2+ - IOCTL - GET DEVICE	INFORMATION
 28256                                  				; BX = file or device handle
 28257 00004024 B43E                    	mov	ah,CLOSE ;3Eh
 28258 00004026 CD21                    	int	21h		; DOS -	2+ - CLOSE A FILE WITH HANDLE
 28259                                  				; BX = file handle
 28260                                  	; 18/04/2023
 28261 00004028 F6C280                  	test	dl,80h
 28262                                  	;test	dl,devid_ISDEV ; test dl,80h
 28263 0000402B 7553                    	jnz	short ISADEV
 28264 0000402D F6460404                	test	byte [bp+VARSTRUC.INFO],4 ; test byte [bp+4],4
 28265 00004031 744D                    	jz	short ISADEV
 28266                                  NOTPFILE:
 28267 00004033 8B5605                  	mov	dx,[bp+VARSTRUC.BUF] ; mov dx,[bp+5]
 28268                                  	
 28269                                  	; 27/03/2023	
 28270                                  	; MSDOS 6.0
 28271 00004036 80FA00                  	cmp	dl,0		     	;AN034; If no drive specified, get
 28272 00004039 7405                    	je	short SET_DRIVE_SPEC	;AN034;    default drive dir
 28273                                  
 28274 0000403B 80FE3A                  	cmp	dh,':'
 28275 0000403E 7402                    	je	short DRVSPEC5
 28276                                  SET_DRIVE_SPEC:
 28277 00004040 B240                    	mov	dl,'@' ; 40h
 28278                                  DRVSPEC5:
 28279 00004042 80CA20                  	or	dl,20h
 28280 00004045 80EA60                  	sub	dl,60h		; A = 1
 28281 00004048 E85CE5                  	call	SAVUDIR1
 28282                                  	
 28283                                  	; 27/03/2023
 28284                                  	; MSDOS 6.0
 28285 0000404B 7306                    	jnc	short CURDIR_OK		;AN022; if error - exit
 28286 0000404D E8ACDC                  	call	get_ext_error_number	;AN022; get the extended error
 28287 00004050 E9ECD9                  	jmp	extend_setup		;AN022; exit with error
 28288                                  
 28289                                  CURDIR_OK:
 28290 00004053 89EA                    	mov	dx,bp
 28291                                  	;add	dx,5
 28292 00004055 83C205                  	add	dx,VARSTRUC.BUF		; Set DX for upcomming CHDIRs
 28293                                  	;mov	bh,[bp+4]
 28294 00004058 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28295 0000405B 80E706                  	and	bh,6
 28296 0000405E 80FF06                  	cmp	bh,6			; Ambig and path ?
 28297 00004061 7518                    	jne	short CHECKAMB		; jmp if no
 28298                                  	;mov	si,[bp+2]
 28299 00004063 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28300 00004066 B33A                    	mov	bl,':'
 28301 00004068 385CFE                  	cmp	[si-2],bl
 28302 0000406B 7506                    	jne	short KNOWNOTSPEC
 28303                                  	;mov	byte [bp+VARSTRUC.ISDIR],2
 28304                                  					; Know is d:/file
 28305                                  	;mov	byte [bp+0],2
 28306 0000406D C6460002                	mov	byte [bp],2
 28307 00004071 EB05                    	jmp	short DOPCDJ
 28308                                  KNOWNOTSPEC:
 28309                                  	;mov	byte [bp+VARSTRUC.ISDIR],1
 28310                                  					; Know is path/file
 28311                                  	;mov	byte [bp+0],1		
 28312 00004073 C6460001                	mov	byte [bp],1
 28313 00004077 4E                      	dec	si
 28314                                  DOPCDJ:
 28315 00004078 E98500                  	jmp	DOPCD
 28316                                  CHECKAMB:
 28317 0000407B 80FF02                  	cmp	bh,2
 28318 0000407E 7505                    	jnz	short CHECKCD
 28319                                  ISSIMPFILE:
 28320                                  ISADEV:
 28321                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28322                                  	;mov	byte [bp+0],0		
 28323 00004080 C6460000                	mov	byte [bp],0
 28324 00004084 C3                      	retn
 28325                                  CHECKCD:
 28326 00004085 E854EC                  	call	SetRest1
 28327 00004088 B43B                    	mov	ah,CHDir ; 3Bh
 28328 0000408A CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28329                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28330 0000408C 723B                    	jb	short NOTPDIR
 28331 0000408E 89D7                    	mov	di,dx
 28332 00004090 31C0                    	xor	ax,ax
 28333 00004092 89C1                    	mov	cx,ax
 28334 00004094 49                      	dec	cx
 28335 00004095 F2AE                    	repne	scasb
 28336                                  
 28337                                  	; 27/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28338                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:424Ah)
 28339                                  	; MSDOS 6.0
 28340                                  Kloop:					;AN000;  3/3/KK
 28341 00004097 268A05                  	mov	al,[es:di]		;AN000;  3/3/KK
 28342 0000409A 47                      	inc	di			;AN000;  3/3/KK
 28343 0000409B 08C0                    	or	al,al			;AN000;  3/3/KK
 28344 0000409D 740C                    	jz	short DONE		;AN000;  3/3/KK
 28345 0000409F 30E4                    	xor	ah,ah			;AN000;  3/3/KK
 28346 000040A1 E814E3                  	call	testkanj		;AN000;  3/3/KK
 28347 000040A4 74F1                    	jz	short Kloop		;AN000;  3/3/KK
 28348 000040A6 47                      	inc	di			;AN000;  3/3/KK
 28349 000040A7 FEC4                    	inc	ah			;AN000;  3/3/KK
 28350 000040A9 EBEC                    	jmp	short Kloop		;AN000;  3/3/KK
 28351                                  DONE:
 28352 000040AB 4F                      	dec	di
 28353 000040AC A0[A18A]                	mov	al,[DIRCHAR]
 28354                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28355                                  	;mov	byte [bp+0],2
 28356 000040AF C6460002                	mov	byte [bp],2
 28357                                  	; 27/03/2023
 28358                                  	; MSDOS 6.0
 28359 000040B3 08E4                    	or	ah,ah			;AN000; 3/3/KK
 28360 000040B5 7505                    	jnz	short _STORE_PCHAR	;AN000; 3/3/KK	 this is the tra
 28361                                  	;
 28362 000040B7 3A45FF                  	cmp	al,[di-1]
 28363 000040BA 7405                    	jz	short GOTSRCSLSH
 28364                                  _STORE_PCHAR:
 28365 000040BC AA                      	stosb
 28366                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 ; know path/file
 28367                                  	;mov	byte [bp+0],1
 28368 000040BD C6460001                	mov	byte [bp],1
 28369                                  GOTSRCSLSH:
 28370                                  	;or	byte [bp+4],6
 28371 000040C1 804E0406                	or 	byte [bp+VARSTRUC.INFO],6 
 28372 000040C5 E87400                  	call	SETSTARS
 28373                                  NOTPDIR_RETN:
 28374 000040C8 C3                      	retn
 28375                                  
 28376                                  	; 28/03/2023
 28377                                  NOTPDIR:
 28378                                  	; MSDOS 6.0
 28379 000040C9 E830DC                  	call	get_ext_error_number	;AN022; get the extended error
 28380                                  	;cmp	ax,3
 28381 000040CC 83F803                  	cmp	ax,ERROR_PATH_NOT_FOUND ;AN022; if path not found - okay
 28382 000040CF 7405                    	je	short NOTPDIR_TRY	;AN022;
 28383                                  	;cmp	ax,5
 28384 000040D1 83F805                  	cmp	ax,ERROR_ACCESS_DENIED	;AN022; if access denied - okay
 28385 000040D4 7560                    	jne	short EXTEND_SETUPJ	;AN022; otherwise - exit error
 28386                                  NOTPDIR_TRY:
 28387                                  	; MSDOS 3.3 (& MSDOS 6.0)
 28388                                  	;mov	byte [bp+VARSTRUC.ISDIR],0
 28389                                  	;mov	byte [bp+0],0
 28390 000040D6 C6460000                	mov	byte [bp],0
 28391                                  	;mov	bh,[bp+4]
 28392 000040DA 8A7E04                  	mov	bh,[bp+VARSTRUC.INFO]
 28393 000040DD F6C704                  	test	bh,4
 28394 000040E0 74E6                    	jz	short NOTPDIR_RETN	; Know pure file, no path seps
 28395                                  	;mov	byte [bp+VARSTRUC.ISDIR],2 ; assume d:/file
 28396                                  	;mov	byte [bp+0],2		
 28397 000040E2 C6460002                	mov	byte [bp],2
 28398                                  	;mov	si,[bp+2]
 28399 000040E6 8B7602                  	mov	si,[bp+VARSTRUC.TTAIL]
 28400 000040E9 803C00                  	cmp	byte [si],0
 28401 000040EC 744B                    	je	short BADCDERRJ2	; Trailing '/'	
 28402                                  	;mov	bl,[DOT_CHR]
 28403                                  	; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 28404                                  	; MSDOS 6.0 (& 5.0) COMMAND.COM
 28405 000040EE B32E                    	mov	bl,'.'  ; 2Eh ; dot_chr
 28406 000040F0 381C                    	cmp	[si],bl
 28407 000040F2 7445                    	je	short BADCDERRJ2	; If . or .. pure cd should have worked
 28408 000040F4 B33A                    	mov	bl,':'  ; 3Ah
 28409 000040F6 385CFE                  	cmp	[si-2],bl
 28410 000040F9 7405                    	je	short DOPCD		; Know d:/file
 28411                                  	;mov	byte [bp+VARSTRUC.ISDIR],1 
 28412                                  					; Know path/file
 28413                                  	;mov	byte [bp+0],1
 28414 000040FB C6460001                	mov	byte [bp],1
 28415 000040FF 4E                      	dec	si			; Point at last '/'
 28416                                  DOPCD:
 28417 00004100 30DB                    	xor	bl,bl
 28418 00004102 861C                    	xchg	bl,[si]			; Stick in a NUL
 28419 00004104 E8D5EB                  	call	SetRest1
 28420                                  
 28421                                  	; 28/03/2023
 28422                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28423 00004107 39F2                    	cmp	dx,si			;AN000;  3/3/KK
 28424 00004109 771B                    	ja	short LookBack		;AN000;  3/3/KK
 28425 0000410B 56                      	push	si			;AN000;  3/3/KK
 28426 0000410C 51                      	push	cx			;AN000;  3/3/KK
 28427 0000410D 89F1                    	mov	cx,si			;AN000;  3/3/KK
 28428 0000410F 89D6                    	mov	si,dx			;AN000;  3/3/KK
 28429                                  Kloop2: 				;AN000;  3/3/KK
 28430 00004111 AC                      	lodsb				;AN000;  3/3/KK
 28431 00004112 E8A3E2                  	call	testkanj		;AN000;  3/3/KK
 28432 00004115 7409                    	jz	short NotKanj4		;AN000;  3/3/KK
 28433 00004117 AC                      	lodsb				;AN000;  3/3/KK
 28434 00004118 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28435 0000411A 72F5                    	jb	short Kloop2		;AN000;  3/3/KK
 28436 0000411C 59                      	pop	cx			;AN000;  3/3/KK
 28437 0000411D 5E                      	pop	si			;AN000;  3/3/KK
 28438 0000411E EB0B                    	jmp	short DoCdr		;AN000;  3/3/KK  Last char is ECS code, don't check for
 28439                                  					;		 trailing path sep
 28440                                  NotKanj4:				;AN000;  3/3/KK
 28441 00004120 39CE                    	cmp	si,cx			;AN000;  3/3/KK
 28442 00004122 72ED                    	jb	short Kloop2		;AN000;  3/3/KK
 28443 00004124 59                      	pop	cx			;AN000;  3/3/KK
 28444 00004125 5E                      	pop	si			;AN000;  3/3/KK
 28445                                  LookBack:				;AN000;  3/3/KK
 28446                                  	; 28/03/2023
 28447                                  	; MSDOS 3.3 & MSDOS 6.0
 28448 00004126 3A5CFF                  	cmp	bl,[si-1]		; if double slash, then complain.
 28449 00004129 740E                    	je	short BADCDERRJ2
 28450                                  DoCdr:
 28451 0000412B B43B                    	mov	ah,CHDir ; 3Bh
 28452 0000412D CD21                    	int	21h		; DOS -	2+ - CHANGE THE	CURRENT	DIRECTORY (CHDIR)
 28453                                  				; DS:DX	-> ASCIZ directory name	(may include drive)
 28454 0000412F 861C                    	xchg	bl,[si]
 28455 00004131 7395                    	jnc	short NOTPDIR_RETN
 28456                                  	
 28457                                  	; 28/03/2023
 28458                                  	; MSDOS 3.3
 28459                                  ;BADCDERRJ2:
 28460                                  	;stc
 28461                                  	;jmp	BADCDERR
 28462                                  
 28463                                  	; 28/03/2023
 28464                                  	; MSDOS 6.0 (& MSDOS 5.0)
 28465 00004133 E8C6DB                  	call	get_ext_error_number	;AN022; get the extended error
 28466                                  EXTEND_SETUPJ:					;AN022;
 28467 00004136 E906D9                  	jmp	extend_setup		;AN022; go issue the error message
 28468                                  BADCDERRJ2:
 28469 00004139 E900D9                  	jmp	badpath_err		;AC022; go issue path not found message
 28470                                  
 28471                                  ; =============== S U B	R O U T	I N E =======================================
 28472                                  
 28473                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28474                                  SETSTARS:
 28475                                  	;mov	[bp+2],di
 28476 0000413C 897E02                  	mov	[bp+VARSTRUC.TTAIL],di
 28477                                  	;add	byte [bp+1],12
 28478 0000413F 8046010C                	add	byte [bp+VARSTRUC.SIZ],12
 28479                                  	;;mov	ax,[DOT_QMARK] ; '?.' (2E3Fh)
 28480                                  	; 28/03/2023
 28481                                  	; MSDOS 6.0
 28482 00004143 B83F2E                  	mov	ax,dot_qmark ; 2E3Fh
 28483                                  	;mov	ax,'?.' ; dot_qmark
 28484                                  
 28485 00004146 B90800                  	mov	cx,8
 28486 00004149 F3AA                    	rep	stosb
 28487 0000414B 86C4                    	xchg	al,ah
 28488 0000414D AA                      	stosb
 28489 0000414E 86C4                    	xchg	al,ah
 28490 00004150 B103                    	mov	cl,3
 28491 00004152 F3AA                    	rep	stosb
 28492 00004154 30C0                    	xor	al,al
 28493 00004156 AA                      	stosb
 28494 00004157 C3                      	retn
 28495                                  
 28496                                  ; =============== S U B	R O U T	I N E =======================================
 28497                                  
 28498                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28499                                  COMPNAME:
 28500 00004158 BE[A88C]                	mov	si,DestBuf	; do name translate of target
 28501 0000415B BF[2188]                	mov	di,TRGXNAME	; save for name comparison
 28502 0000415E B460                    	mov	ah,xNameTrans ; 60h
 28503 00004160 CD21                    	int	21h	; DOS -	RESOLVE	PATH STRING TO CANONICAL PATH STRING
 28504                                  			; DS:SI	-> ASCIZ relative path string or directory name
 28505                                  			; ES:DI	-> 128-byte buffer for ASCIZ canonical fully qualified name
 28506 00004162 BE[CA87]                	mov	si,SRCXNAME	; get name translate of source
 28507 00004165 BF[2188]                	mov	di,TRGXNAME	; get name translate of target
 28508                                  	;call	STRCOMP
 28509                                  	;retn
 28510                                  	; 28/03/2023
 28511 00004168 E9AEE4                  	jmp	STRCOMP
 28512                                  
 28513                                  ;============================================================================
 28514                                  ; CPARSE.ASM, MSDOS 6.0, 1991
 28515                                  ;============================================================================
 28516                                  ; 30/09/2018 - Retro DOS v3.0
 28517                                  ; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28518                                  
 28519                                  ;-----------------------------------------------------------------------;
 28520                                  ; ENTRY:								;
 28521                                  ;	DS:SI	Points input buffer					;
 28522                                  ;	ES:DI	Points to the token buffer				;
 28523                                  ;	BL	Special delimiter for this call 			;
 28524                                  ;		    Always checked last 				;
 28525                                  ;		    set it to space if there is no special delimiter	;
 28526                                  ; EXIT: 								;
 28527                                  ;	DS:SI	Points to next char in the input buffer 		;
 28528                                  ;	ES:DI	Points to the token buffer				;
 28529                                  ;	[STARTEL] Points to start of last element of path in token	;
 28530                                  ;		points to a NUL for no element strings 'd:' 'd:/'       ;
 28531                                  ;	CX	Character count 					;
 28532                                  ;	BH	Condition Code						;
 28533                                  ;			Bit 1H of BH set if switch character		;
 28534                                  ;				Token buffer contains char after	;
 28535                                  ;				switch character			;
 28536                                  ;				BP has switch bits set (ORing only)	;
 28537                                  ;			Bit 2H of BH set if ? or * in token		;
 28538                                  ;				if * found element ? filled		;
 28539                                  ;			Bit 4H of BH set if path sep in token		;
 28540                                  ;			Bit 80H of BH set if the special delimiter	;
 28541                                  ;			   was skipped at the start of this token	;
 28542                                  ;		Token buffer always starts d: for non switch tokens	;
 28543                                  ;	CARRY SET							;
 28544                                  ;	    if CR on input						;
 28545                                  ;		token buffer not altered				;
 28546                                  ;									;
 28547                                  ;	DOES NOT RETURN ON BAD PATH, OR TRAILING SWITCH CHAR ERROR	;
 28548                                  ; MODIFIES:								;
 28549                                  ;	CX, SI, AX, BH, DX and the Carry Flag				;
 28550                                  ;									;
 28551                                  ;-----------------------------------------------------------------------;
 28552                                  
 28553                                  ; Modifications to cparse: recognition of right and left parentheses
 28554                                  ; as integral tokens, and removal of automatic upper-case conversion code.
 28555                                  ;
 28556                                  ; Both modifications were installed in the course of adding a coherent
 28557                                  ; command-line parser to COMMAND.COM which builds a UNIX-style argv[]/argc
 28558                                  ; structure for command-line arguments. This parser relies on cparse to
 28559                                  ; recognize individual tokens.
 28560                                  ;
 28561                                  ; To process for-loops correctly, parentheses must therefore be
 28562                                  ; recognized as tokens. The upper-case conversion code was removed so
 28563                                  ; that commands (such as for and echo) would be able to use the "original"
 28564                                  ; text of the command line.
 28565                                  ;
 28566                                  ; Note also the modification to prevent the automatic conversion of colons
 28567                                  ; into spaces WITHIN THE SOURCE TEXT!
 28568                                  ;
 28569                                  ; Also note that BP is also clobbered if cparse recognizes any switches
 28570                                  ; on the command line.
 28571                                  ;
 28572                                  ; Alan L, OS/MSDOS				    14 August 1983
 28573                                  
 28574                                  ; ---------------------------------------------------------------------------
 28575                                  
 28576                                  ; COMEQU.ASM (MSDOS 6.0, 1991)
 28577                                  
 28578                                  ;FSWITCH	EQU	8000h
 28579                                  ;FBADSWITCH	EQU	4000h
 28580                                  
 28581                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3334h
 28582                                  
 28583                                  ; =============== S U B	R O U T	I N E =======================================
 28584                                  		
 28585                                  	; 28/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28586                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 431Fh
 28587                                  
 28588                                  cparse:
 28589 0000416B 31C0                    	xor	ax,ax
 28590 0000416D 893E[D28D]              	mov	[STARTEL],di		; No path element (Is DI correct?)
 28591 00004171 A2[D58D]                	mov	[ELPOS],al		; Start in 8 char prefix
 28592                                  	; MSDOS 3.3
 28593                                  	;mov	[SOURCE],al		
 28594                                  	; MSDOS 6.0
 28595 00004174 A2[D68D]                	mov	[SKPDEL], al		; No skip delimiter yet
 28596 00004177 88C7                    	mov	bh,al			; Init nothing
 28597 00004179 9C                      	pushf				; save flags
 28598 0000417A 57                      	push	di			; save the token buffer addrss
 28599 0000417B 31C9                    	xor	cx,cx			; no chars in token buffer
 28600 0000417D 880E[018C]              	mov	[comma],cl		; reset comma flag
 28601                                  moredelim:
 28602 00004181 AC                      	lodsb
 28603 00004182 E85AE4                  	call	DELIM
 28604 00004185 751D                    	jnz	short SCANCDONE
 28605 00004187 3C20                    	cmp	al,' '
 28606 00004189 74F6                    	jz	short moredelim
 28607 0000418B 3C09                    	cmp	al,9
 28608 0000418D 74F2                    	jz	short moredelim
 28609                                  	;xchg	al,[SOURCE]
 28610                                  	; 28/03/2023
 28611 0000418F 8606[D68D]              	xchg	al,[SKPDEL]
 28612 00004193 08C0                    	or	al,al
 28613 00004195 74EA                    	jz	short moredelim		; One non space/tab delimiter allowed
 28614 00004197 F6C780                  	test	bh,80h			; has a special char been found?
 28615 0000419A 7405                    	jz	short no_comma		; no - just exit
 28616 0000419C C606[018C]01            	mov	byte [comma],1		; set comma flag
 28617                                  no_comma:
 28618 000041A1 E92A01                  	jmp	x_done			; Nul argument
 28619                                  
 28620                                  SCANCDONE:
 28621                                  	; 28/03/2023
 28622                                  	; MSDOS 6.0
 28623                                  	; -----------------------------------
 28624                                  	; Mod to avoid upper-case conversion.
 28625                                  	; -----------------------------------
 28626                                  	; MSDOS 3.3
 28627                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28628                                  	;jnz	short cpcont1		; 3/3/KK
 28629                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28630                                  cpcont1:
 28631                                  	; -----------------------------------
 28632                                  	; 28/03/2023
 28633 000041A4 38D8                    	cmp	al,bl			; Special delimiter?
 28634 000041A6 7505                    	jne	short nospec
 28635 000041A8 80CF80                  	or	bh,80h
 28636 000041AB EBD4                    	jmp	short moredelim
 28637                                  nospec:
 28638 000041AD 3C0D                    	cmp	al,0Dh			; a CR?
 28639 000041AF 7503                    	jne	short ncperror
 28640 000041B1 E91501                  	jmp	cperror
 28641                                  ncperror:
 28642 000041B4 3A06[A08A]              	cmp	al,[SWITCHAR]		; is the char the switch char?
 28643 000041B8 7503                    	jne	short na_switch		; yes, process...
 28644 000041BA E91401                  	jmp	a_switch
 28645                                  na_switch:
 28646 000041BD B23A                    	mov	dl,':'
 28647 000041BF 3814                    	cmp	[si],dl
 28648 000041C1 751D                    	jne	short anum_chard	; Drive not specified
 28649                                  	; 28/03/2023
 28650                                  	; MSDOS 6.0 
 28651 000041C3 803E[908C]01            	cmp	byte [cpyflag],1	; 3/3/KK
 28652 000041C8 7503                    	jne	short cpcont2		; 3/3/KK
 28653 000041CA E815E2                  	call	UPCONV			; 3/3/KK
 28654                                  cpcont2:
 28655 000041CD E85901                  	call	move_char
 28656 000041D0 AC                      	lodsb				; Get the ':'
 28657 000041D1 E85501                  	call	move_char
 28658 000041D4 893E[D28D]              	mov	[STARTEL],di
 28659 000041D8 C606[D48D]00            	mov	byte [ELCNT],0
 28660 000041DD E9B300                  	jmp	anum_test
 28661                                  anum_chard:
 28662 000041E0 893E[D28D]              	mov	[STARTEL],di
 28663 000041E4 C606[D48D]00            	mov	byte [ELCNT],0		; Store of this char sets it to one
 28664 000041E9 803E[908C]01            	cmp	byte [cpyflag],1	; Was CPARSE called from COPY?
 28665 000041EE 751D                    	jnz	short anum_char		; No, don't add drive spec.
 28666 000041F0 E872E4                  	call	pathchrcmp		; Starts with a pathchar?
 28667 000041F3 7518                    	jnz	short anum_char		; no
 28668 000041F5 50                      	push	ax
 28669 000041F6 A0[B08A]                	mov	al,[CURDRV]		; Insert drive spec
 28670                                  	;add	al,[CAPITAL_A]
 28671                                  	; 28/03/2023
 28672                                  	; MSDOS 6.0
 28673 000041F9 0441                    	add	al,'A' ; 41h
 28674 000041FB E82B01                  	call	move_char
 28675 000041FE B03A                    	mov	al,':' ; 3Ah
 28676 00004200 E82601                  	call	move_char
 28677 00004203 58                      	pop	ax
 28678 00004204 893E[D28D]              	mov	[STARTEL],di
 28679 00004208 C606[D48D]00            	mov	byte [ELCNT],0
 28680                                  anum_char:
 28681                                  	; 28/03/2023
 28682                                  	; MSDOS 6.0
 28683 0000420D E8A8E1                  	call	testkanj		;AC048			
 28684 00004210 7406                    	jz	short NOTKANJ		;AC048;
 28685 00004212 E81401                  	call	move_char
 28686 00004215 AC                      	lodsb
 28687 00004216 EB78                    	jmp	short notspecial
 28688                                  
 28689                                  NOTKANJ:				;AN048; If not kanji
 28690 00004218 803E[908C]01            	cmp	byte [cpyflag],1	;AN048; and if we're in COPY
 28691 0000421D 7503                    	jne	short TESTDOT 		;AN048;
 28692 0000421F E8C0E1                  	call	UPCONV			;AN048; upper case the char
 28693                                  TESTDOT:
 28694                                  	; 28/03/2023
 28695                                  	;cmp	al,dot_chr  ; 2Eh
 28696 00004222 3C2E                    	cmp	al,'.'
 28697 00004224 7509                    	jne	short testquest
 28698 00004226 FE06[D58D]              	inc	byte [ELPOS] 		; flag in extension
 28699 0000422A C606[D48D]FF            	mov	byte [ELCNT],0FFh	; Store of the '.' resets it to 0
 28700                                  testquest:
 28701 0000422F 3C3F                    	cmp	al,'?'  ; 3Fh
 28702 00004231 7503                    	jnz	short testsplat
 28703 00004233 80CF02                  	or	bh,2
 28704                                  testsplat:
 28705                                  	;cmp	al,[STAR]
 28706 00004236 3C2A                    	cmp	al,star	; 2Ah
 28707                                  	; 27/04/2023
 28708                                  	;cmp	al,'*' 
 28709 00004238 7530                    	jne	short testpath
 28710 0000423A 80CF02                  	or	bh,2
 28711 0000423D 803E[0D8E]00            	cmp	byte [expand_star],0
 28712 00004242 7504                    	jne	short expand_filename
 28713 00004244 EB24                    	jmp	short testpath
 28714                                  
 28715                                  BADPERR2J:
 28716                                  	;jmp	BADPERR2
 28717                                  	; 28/03/2023
 28718                                  	; MSDOS 6.0
 28719 00004246 EB75                    	jmp	short BADPERR2
 28720                                  
 28721                                  expand_filename:
 28722 00004248 B407                    	mov	ah,7
 28723 0000424A 803E[D58D]00            	cmp	byte [ELPOS],0
 28724 0000424F 7402                    	jz	short gotelcnt
 28725 00004251 B402                    	mov	ah,2
 28726                                  gotelcnt:
 28727 00004253 B03F                    	mov	al,'?'
 28728 00004255 2A26[D48D]              	sub	ah,[ELCNT]
 28729 00004259 72EB                    	jb	short BADPERR2J
 28730 0000425B 86E1                    	xchg	ah,cl
 28731 0000425D E309                    	jcxz	testpathx
 28732                                  qmove:
 28733 0000425F 86E1                    	xchg	ah,cl
 28734 00004261 E8C500                  	call	move_char
 28735 00004264 86E1                    	xchg	ah,cl
 28736 00004266 E2F7                    	loop	qmove
 28737                                  testpathx:
 28738 00004268 86E1                    	xchg	ah,cl
 28739                                  testpath:
 28740 0000426A E8F8E3                  	call	pathchrcmp
 28741 0000426D 7521                    	jnz	short notspecial
 28742 0000426F 80CF04                  	or	bh,4
 28743 00004272 803E[0D8E]00            	cmp	byte [expand_star],0
 28744 00004277 7405                    	jz	short no_err_check
 28745 00004279 F6C702                  	test	bh,2			; If just hit a '/', cannot have ? or * yet
 28746 0000427C 7545                    	jnz	short BADPERR
 28747                                  no_err_check:
 28748 0000427E 893E[D28D]              	mov	[STARTEL],di	  	; New element
 28749 00004282 FF06[D28D]              	inc	word [STARTEL]	  	; Point to char after /
 28750 00004286 C606[D48D]FF            	mov	byte [ELCNT],0FFh 	; Store of '/' sets it to 0
 28751 0000428B C606[D58D]00            	mov	byte [ELPOS],0
 28752                                  notspecial:
 28753 00004290 E89600                  	call	move_char		; just an alphanum string
 28754                                  anum_test:
 28755 00004293 AC                      	lodsb
 28756                                  
 28757                                  	; 28/03/2023
 28758                                  	; MSDOS 6.0
 28759                                  	; -----------------------------------
 28760                                  	; Mod to avoid upper-case conversion.
 28761                                  	; -----------------------------------
 28762                                  	; MSDOS 3.3
 28763                                  	;cmp	byte [CPYFLAG],1	; 3/3/KK
 28764                                  	;jnz	short cpcont3		; 3/3/KK
 28765                                  	;call	UPCONV_MAPCALL		; 3/3/KK
 28766                                  cpcont3:
 28767                                  	; -----------------------------------
 28768                                  
 28769 00004294 E848E3                  	call	DELIM
 28770 00004297 7435                    	jz	short x_done
 28771 00004299 3C0D                    	cmp	al,0Dh
 28772 0000429B 7431                    	je	short x_done
 28773 0000429D 3A06[A08A]              	cmp	al,[SWITCHAR]
 28774 000042A1 742B                    	je	short x_done
 28775 000042A3 38D8                    	cmp	al,bl
 28776 000042A5 7427                    	je	short x_done
 28777 000042A7 3C3A                    	cmp	al,':'			; ':' allowed as trailer because of devices
 28778                                  	; 28/03/2023
 28779                                  	; MSDOS 3.3
 28780                                  	;jnz	short ANUM_CHARJ 
 28781                                  	; MSDOS 6.0
 28782 000042A9 7403                    	je	short FOO15
 28783 000042AB E95FFF                  	jmp	anum_char
 28784                                  
 28785                                  ; Modification made for parseline.
 28786                                  ; Why would it be necessary to change colons to spaces? In this
 28787                                  ; case, EVERY colon is changed to a space; e.g., 'f:' yields 'f ',
 28788                                  ; but so does 'echo foo:bar' yield 'echo foo bar'.
 28789                                  
 28790                                  FOO15:
 28791 000042AE 803E[908C]02            	cmp	byte [cpyflag],2
 28792 000042B3 7505                    	jnz	short cpcont4
 28793 000042B5 E87100                  	call	move_char
 28794 000042B8 EBD9                    	jmp	short anum_test
 28795                                  cpcont4:
 28796 000042BA 46                      	inc	si			; Skip the ':'
 28797 000042BB EB11                    	jmp	short x_done
 28798                                  
 28799                                  	; 28/03/2023
 28800                                  ;ANUM_CHARJ:
 28801                                  	;jmp	anum_char
 28802                                  
 28803                                  BADPERR2:
 28804 000042BD BA[427F]                	mov	dx,BADCPMES_PTR
 28805 000042C0 E988E6                  	jmp	cerror
 28806                                  
 28807                                  BADPERR:
 28808                                  	; 28/03/2023
 28809                                  	;jmp	BADCDERR  ; MSDOS 3.3	
 28810                                  BADCDERR:
 28811                                  	; MSDOS 6.0
 28812 000042C3 BA[6C80]                	mov	dx,badcd_ptr		;AC022; Issue "Invalid Directory"
 28813 000042C6 E982E6                  	jmp	cerror			;AC022;  message
 28814                                  	
 28815                                  cperror:
 28816 000042C9 4E                      	dec	si			; adjust the pointer
 28817 000042CA 5F                      	pop	di			; retrive token buffer address
 28818 000042CB 9D                      	popf				; restore flags
 28819 000042CC F9                      	stc				; set the carry bit
 28820 000042CD C3                      	retn
 28821                                  
 28822                                  x_done:
 28823 000042CE 4E                      	dec	si			; adjust for next round
 28824                                  
 28825                                  ; Mod to recognize right and left parens as integral tokens.
 28826                                  ;x_done2:
 28827 000042CF EB51                    	jmp	short out_token
 28828                                  
 28829                                  a_switch:
 28830 000042D1 80CF01                  	or	bh,1			; Indicate switch
 28831                                  	;or	bp,FSWITCH ; 8000h
 28832                                  	; 28/03/2023
 28833 000042D4 81CD0080                	or	bp,8000h
 28834 000042D8 E8FCE2                  	call	scanoff
 28835 000042DB 46                      	inc	si
 28836                                  	; 28/03/2023
 28837                                  	; MSDOS 6.0
 28838 000042DC E8D9E0                  	call	testkanj		;AN057; See if DBCS lead byte
 28839 000042DF 740D                    	jz	short a_switch_notkanj	;AN057; no - continue processing
 28840 000042E1 E84500                  	call	move_char		;AN057; DBCS - store first byte
 28841 000042E4 AC                      	lodsb				;AN057; get second byte
 28842 000042E5 E84100                  	call	move_char		;AN057; store second byte
 28843                                  	;or	bp,FBADSWITCH ; 4000h	;AN057; DBCS switch is invalid
 28844 000042E8 81CD0040                	or	bp,4000h
 28845 000042EC EB34                    	jmp	short out_token 	;AN057; don't bother checking switch
 28846                                  a_switch_notkanj:			;AN057;
 28847 000042EE 3C0D                    	cmp	al,0Dh
 28848 000042F0 7509                    	jne	short Store_swt
 28849 000042F2 B000                    	mov	al,0
 28850 000042F4 AA                      	stosb
 28851                                  	;or	bp,FBADSWITCH ; 4000h
 28852 000042F5 81CD0040                	or	bp,4000h
 28853 000042F9 EBCE                    	jmp	short cperror		; Trailing switch character error
 28854                                  					;   BP = fSwitch but no switch
 28855                                  					;   bit is set (unknown switch)
 28856                                  Store_swt:
 28857 000042FB E82B00                  	call	move_char		; store the character
 28858                                  
 28859                                  ; This upconv call must stay. It is used to identify copy-switches
 28860                                  ; on the command line, and won't store anything into the output buffer.
 28861                                  
 28862                                  	;call	UPCONV_MAPCALL ; MSDOS 3.3 (Retro DOS 3.0)
 28863                                  	; 28/03/2023
 28864 000042FE E8E1E0                  	call	UPCONV 	; MSDOS 6.0 & MSDOS 5.0 (Retro DOS 4.0)
 28865                                  	
 28866 00004301 06                      	push	es
 28867 00004302 57                      	push	di
 28868 00004303 51                      	push	cx
 28869 00004304 0E                      	push	cs
 28870 00004305 07                      	pop	es
 28871                                  	; 28/03/2023
 28872                                  	; MSDOS 3.3
 28873                                  	;mov	di,SWITCH_LIST ; "VBAPW"
 28874                                  	; MSDOS 6.0
 28875 00004306 BF[6784]                	mov	di,switch_list ; "?VBAPW"
 28876                                  	; MSDOS 3.3
 28877                                  	;mov	cx,SWCOUNT ; 5
 28878                                  	; MSDOS 6.0
 28879 00004309 B90600                  	mov	cx,6  ; SWCOUNT = 6
 28880                                  	;or	bp,FBADSWITCH  ; 4000h
 28881 0000430C 81CD0040                	or	bp,4000h
 28882 00004310 F2AE                    	repne	scasb
 28883 00004312 750B                    	jnz	short out_tokenp
 28884                                  	;and	bp,~FBADSWITCH ; 0BFFFh
 28885 00004314 81E5FFBF                	and	bp,0BFFFh
 28886 00004318 B80100                  	mov	ax,1
 28887 0000431B D3E0                    	shl	ax,cl
 28888 0000431D 09C5                    	or	bp,ax
 28889                                  out_tokenp:
 28890 0000431F 59                      	pop	cx
 28891 00004320 5F                      	pop	di
 28892 00004321 07                      	pop	es
 28893                                  out_token:
 28894 00004322 B000                    	mov	al,0			; null at the end
 28895 00004324 AA                      	stosb
 28896 00004325 5F                      	pop	di			; restore token buffer pointer	
 28897 00004326 9D                      	popf
 28898 00004327 F8                      	clc				; clear carry flag
 28899 00004328 C3                      	retn
 28900                                  
 28901                                  ; =============== S U B	R O U T	I N E =======================================
 28902                                  
 28903                                  	; 28/03/2023
 28904                                  move_char:
 28905 00004329 AA                      	stosb				; store char in token buffer
 28906 0000432A 41                      	inc	cx			; increment char count
 28907 0000432B FE06[D48D]              	inc	byte [ELCNT]		; increment element count for * substi
 28908 0000432F C3                      	retn
 28909                                  
 28910                                  ;============================================================================
 28911                                  ; PARSE.ASM, MSDOS 6.0, 1991
 28912                                  ;============================================================================
 28913                                  ; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 28914                                  
 28915                                  ; -----------------------------
 28916                                  ; (PSDATA.INC, MSDOS 6.0, 1991)
 28917                                  ; -----------------------------
 28918                                  
 28919                                  ;**** Equation field
 28920                                  ;-------- Character code definition
 28921                                  
 28922                                  $P_DBSP1	   equ	20h ; DB_SP_HI	;AN000; 1st byte of DBCS blank
 28923                                  $P_DBSP2	   equ	20h ; DB_SP_LO	;AN000; 2nd byte of DBCS blank
 28924                                  $P_Period	   equ	"."             ;AN020;
 28925                                  $P_Slash	   equ	"/"             ;AN020;
 28926                                  $P_Space	   equ	" "             ;AN000; SBCS blank
 28927                                  $P_Comma	   equ	","             ;AN000;
 28928                                  $P_Switch	   equ	"/"             ;AN000;
 28929                                  $P_Keyword	   equ	"="             ;AN000;
 28930                                  $P_Colon	   equ	":"             ;AN000;
 28931                                  $P_Plus 	   equ	"+"             ;AN000;
 28932                                  $P_Minus	   equ	"-"             ;AN000;
 28933                                  $P_Rparen	   equ	")"             ;AN000;
 28934                                  $P_Lparen	   equ	"("             ;AN000;
 28935                                  ;(deleted ;AN025;) $P_SQuote	      equ  "'"
 28936                                  $P_DQuote	   equ	'"'             ;AN000;
 28937                                  $P_NULL 	   equ	0		;AN000;
 28938                                  $P_TAB		   equ	9		;AN000;
 28939                                  $P_CR		   equ	0Dh		;AN000;
 28940                                  $P_LF		   equ	0Ah		;AN000;
 28941                                  $P_ASCII80	   equ	80h		;AN000; ASCII 80h character code
 28942                                  
 28943                                  $P_DOSTBL_File	   equ	4		;AN000; get file uppercase table
 28944                                  $P_DOSTBL_Char	   equ	2		;AN000; get character uppercase table
 28945                                  
 28946                                  $P_error_filespec  equ  1
 28947                                  
 28948                                  ;----------------------------------------------------------------------------
 28949                                  ; PARMS LABEL	BYTE
 28950                                  ;	DW	PARMSX
 28951                                  ;	DB	2		; NUMBER OF STRINGS (0, 1, 2)
 28952                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 28953                                  ;	DB	" .. "          ; EXTRA DELIMITER LIST,
 28954                                  ;				; TYPICAL ARE ";", "="
 28955                                  ;				; "," & WHITESPACE ALWAYS
 28956                                  ;	DB	length		; LENGTH OF THE NEXT LIST, 0 IF NONE
 28957                                  ;	DB	" .. "          ; EXTRA END OF LINE LIST, CR, LF OR 0 ALWAYS
 28958                                  ;----------------------------------------------------------------------------
 28959                                  
 28960                                  struc $P_PARMS_BLK			;AN000;
 28961 00000000 ????                    .$P_PARMSX_Address:  resw 1		;AN000; Address of PARMSX
 28962 00000002 ??                      .$P_Num_Extra:	     resb 1		;AN000; Number of extra stuff
 28963 00000003 ??                      .$P_Len_Extra_Delim: resb 1		;AN000; Length of extra delimiter
 28964                                  endstruc 				;AN000;
 28965                                  
 28966                                  $P_Len_PARMS	   equ	4		;AN000;
 28967                                  $P_I_Use_Default   equ	0		;AN000; no extra stuff specified
 28968                                  $P_I_Have_Delim    equ	1		;AN000; extra delimiter specified
 28969                                  $P_I_Have_EOL	   equ	2		;AN000; extra EOL specified
 28970                                  
 28971                                  ;----------------------------------------------------------------------------
 28972                                  ; PARMSX LABEL	BYTE
 28973                                  ;	DB	minp,maxp		; MIN, MAX POSITIONAL OPERANDS ALLOWED
 28974                                  ;	DW	CONTROL 		; DESCRIPTION OF POSITIONAL 1
 28975                                  ;	:				; REPEATS maxp-1 TIMES
 28976                                  ;	DB	maxs			; # OF SWITCHES
 28977                                  ;	DW	CONTROL 		; DESCRIPTION OF SWITCH 1
 28978                                  ;	:				; REPEATS maxs-1 TIMES
 28979                                  ;	DB	maxk			; # OF KEYWORD
 28980                                  ;	DW	CONTROL 		; DESCRIPTION OF KEYWORD 1
 28981                                  ;	:				; REPEATS maxk-1 TIMES
 28982                                  ;----------------------------------------------------------------------------
 28983                                  
 28984                                  struc $P_PARMSX_BLK			;AN000;
 28985 00000000 ??                      .$P_MinP: 	 resb 1	 ; 27/04/2023	;AN000; Minimum positional number
 28986 00000001 ??                      .$P_MaxP: 	 resb 1			;AN000; Maximum positional number
 28987 00000002 ??                      .$P_1st_Control: resb 1			;AN000; Address of the 1st CONTROL block
 28988                                  endstruc				;AN000;
 28989                                  
 28990                                  ; 31/03/2023
 28991                                  ;----------------------------------------------------------------------------
 28992                                  ; << Control field definition >>
 28993                                  ;
 28994                                  ;CONTROL   LABEL   BYTE
 28995                                  ;	   DW MATCH_FLAGS	; CONTROLS TYPE MATCHED
 28996                                  ;				; 8000H=NUMERIC VALUE, (VALUE LIST WILL BE CHECKED)
 28997                                  ;				; 4000H=SIGNED NUMERIC VALUE (VALUE LIST WILL BE CHECKED)
 28998                                  ;				; 2000H=SIMPLE STRING(VALUE LIST WILL BE CHECKED)
 28999                                  ;				; 1000H=DATE STRING (VALUE LIST WON'T BE CHECKED)
 29000                                  ;				; 0800H=TIME STRING (VALUE LIST WON'T BE CHECKED)
 29001                                  ;				; 0400H=COMPLEX LIST (VALUE LIST WON'T BE CHECKED)
 29002                                  ;				; 0200H=FILE SPEC (VALUE LIST WON'T BE CHECKED)
 29003                                  ;				; 0100H=DRIVE ONLY (VALUE LIST WON'T BE CHECKED)
 29004                                  ;				; 0080H=QUOTED STRING (VALUE LIST WON'T BE CHECKED)
 29005                                  ;				; 0010H=IGNORE ":" AT END IN MATCH
 29006                                  ;				; 0002H=REPEATS ALLOWED
 29007                                  ;				; 0001H=OPTIONAL
 29008                                  ;	   DW FUNCTION_FLAGS
 29009                                  ;				; 0001H=CAP RESULT BY FILE TABLE
 29010                                  ;				; 0002H=CAP RESULT BY CHAR TABLE
 29011                                  ;				; 0010H=REMOVE ":" AT END
 29012                                  ; (tm10)			; 0020H=colon is not necessary for switch
 29013                                  ;
 29014                                  ;	   DW RESULT		; RESULT BUFFER
 29015                                  ;	   DW VALUES		; VALUE LISTS
 29016                                  ;	   DB nid		; NUMBER OF KEYWORD/SWITCH SYNONYMS IN FOLLOWING LIST
 29017                                  ;	   DB "...",0		; IF n >0, KEYWORD 1
 29018                                  ;	   :
 29019                                  ;
 29020                                  ;Note:
 29021                                  ;    - The MATCH_FLAG is bit significant. You can set, for example, TIME bit and
 29022                                  ;      DATE bit simalteniously.
 29023                                  ;
 29024                                  ;      The parser examins each bit along with the following priority.
 29025                                  ;
 29026                                  ;      COMPLEX -> DATE -> TIME -> NUMERIC VAL -> SIGNED NUMERIC VAL -> DRIVE ->
 29027                                  ;      FILE SPEC -> SIMPLE STRING.
 29028                                  ;
 29029                                  ;
 29030                                  ;    - When the FUNCTION_FLAG is 0001 or 0002, the STRING pointed to by a pointer
 29031                                  ;      in the result buffer is capitalized.
 29032                                  ;
 29033                                  ;    - Match_Flags 0001H and 0002H have meaning only for the positional.
 29034                                  ;
 29035                                  ;
 29036                                  ;    - The "...",0 (bottom most line) does require '=' or '/'. When you need a
 29037                                  ;      switch, for example, '/A', then STRING points to;
 29038                                  ;
 29039                                  ;		DB    1 	; number of following synonyms
 29040                                  ;		DB   '/A',0
 29041                                  ;
 29042                                  ;      When you need a keyword, for example, 'CODEPAGE=', then "...",0 will be;
 29043                                  ;
 29044                                  ;		DB    1 	; number of following synonyms
 29045                                  ;		DB   'CODEPAGE=',0
 29046                                  ;
 29047                                  ;
 29048                                  ;    - "..." must consist of upper case characters only because the parser
 29049                                  ;      performs pattern matching after converting input to upper case (by
 29050                                  ;      using the current country upper case table)
 29051                                  ;
 29052                                  ;
 29053                                  ;    - One "..." can contain only one switch or keyword. If you need, for
 29054                                  ;      example /A and /B, the format will be;
 29055                                  ;
 29056                                  ;		DB    2 	; number of following synonyms
 29057                                  ;		DB    '/A',0
 29058                                  ;		DB    '/B',0
 29059                                  ;----------------------------------------------------------------------------
 29060                                  
 29061                                  ;**** Match_Flags
 29062                                  
 29063                                  $P_Num_Val	   equ	8000h		;AN000; Numeric Value
 29064                                  $P_SNum_Val	   equ	4000h		;AN000; Signed numeric value
 29065                                  $P_Simple_S	   equ	2000h		;AN000; Simple string
 29066                                  $P_Date_S	   equ	1000h		;AN000; Date string
 29067                                  $P_Time_S	   equ	0800h		;AN000; Time string
 29068                                  $P_Cmpx_S	   equ	0400h		;AN000; Complex string
 29069                                  $P_File_Spc	   equ	0200h		;AN000; File Spec
 29070                                  $P_Drv_Only	   equ	0100h		;AN000; Drive Only
 29071                                  $P_Qu_String	   equ	0080h		;AN000; Quoted string
 29072                                  $P_Ig_Colon	   equ	0010h		;AN000; Ignore colon at end in match
 29073                                  $P_Repeat	   equ	0002h		;AN000; Repeat allowed
 29074                                  $P_Optional	   equ	0001h		;AN000; Optional
 29075                                  
 29076                                  ;**** Function flags
 29077                                  
 29078                                  $P_CAP_File	   equ	0001h		;AN000; CAP result by file table
 29079                                  $P_CAP_Char	   equ	0002h		;AN000; CAP result by character table
 29080                                  $P_Rm_Colon	   equ	0010h		;AN000; Remove ":" at the end
 29081                                  $P_colon_is_not_necessary equ 0020h	;AN000;(tm10) /+10 and /+:10
 29082                                  
 29083                                  ;-------------------------------- Control block structure
 29084                                  struc $P_CONTROL_BLK
 29085 00000000 ????                    .$P_Match_Flag:	   resw 1		;AN000; Controls type matched
 29086 00000002 ????                    .$P_Function_Flag: resw 1		;AN000; Function should be taken
 29087 00000004 ????                    .$P_Result_Buf:	   resw 1		;AN000; Result buffer address
 29088 00000006 ????                    .$P_Value_List:	   resw 1		;AN000; Value list address
 29089 00000008 ??                      .$P_nid:	   resb 1		;AN000; # of keyword/SW synonyms
 29090 00000009 ??                      .$P_KEYorSW:	   resb 1		;AN000; keyword or sw
 29091                                  endstruc
 29092                                  
 29093                                  ; 31/03/2023
 29094                                  ;----------------------------------------------------------------------------
 29095                                  ;
 29096                                  ;VALUES LABEL	BYTE
 29097                                  ;	DB	nval		; NUMBER OF VALUE DEFINITIONS (0 - 3)
 29098                                  ;	+-
 29099                                  ;	| DB	nrng		; NUMBER OF RANGES
 29100                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF RANGE MATCHED
 29101                                  ;	| +DD	X,Y		; RANGE OF VALUES
 29102                                  ;	|	:
 29103                                  ;	| DB	nnval		; NUMBER OF CHOICES
 29104                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF NUMBER CHOICE MATCHED
 29105                                  ;	| +DD	VALUE		; SPECIFIC CHOICE IF NUMBER
 29106                                  ;	|	:
 29107                                  ;	| DB	nstrval 	; NUMBER OF CHOICES
 29108                                  ;	| +DB	ITEM_TAG	; RETURN VALUE IF STRING CHOICE MATCHED
 29109                                  ;	| +DW	STRING		; SPECIFIC CHOICE IF STING
 29110                                  ;	+-	:
 29111                                  ;
 29112                                  ;STRING DB	"...",0		; ASCIIZ STRING IMAGE
 29113                                  ;
 29114                                  ;Note:
 29115                                  ;    - ITEM_TAG must not be 0FFH, which will be used in the result buffer
 29116                                  ;      when no choice lists are provided.
 29117                                  ;
 29118                                  ;    - STRING must consist of upper case characters only because the parser
 29119                                  ;      performs pattern matching after converting input to upper case (by
 29120                                  ;      using the current country upper case table)
 29121                                  ;----------------------------------------------------------------------------
 29122                                  
 29123                                  $P_nval_None	equ 0		;AN000; no value list ID
 29124                                  $P_nval_Range	equ 1		;AN000; range list ID
 29125                                  $P_nval_Value	equ 2		;AN000; value list ID
 29126                                  $P_nval_String	equ 3		;AN000; string list ID
 29127                                  $P_Len_Range	equ 9		;AN000; Length of a range choice(two DD plus one DB)
 29128                                  $P_Len_Value	equ 5		;AN000; Length of a value choice(one DD plus one DB)
 29129                                  $P_Len_String	equ 3		;AN000; Length of a string choice(one DW plus one DB)
 29130                                  $P_No_nrng	equ 0		;AN000; (tm07) no nrng. nnval must not be 0.
 29131                                  
 29132                                  struc $P_VAL_LIST
 29133 00000000 ??                      .$P_NumofList:	resb 1		;AN000; number of following choice
 29134 00000001 ????                    .$P_Val_XL:	resw 1		;AN000; lower word of value
 29135 00000003 ????                    .$P_Val_XH:	resw 1		;AN000; higher word of value
 29136 00000005 ????                    .$P_Val_YL:	resw 1		;AN000; lower word of another value
 29137 00000007 ????                    .$P_Val_YH:	resw 1		;AN000; higher word of another value
 29138                                  endstruc
 29139                                  
 29140                                  ; 31/03/2023
 29141                                  ;----------------------------------------------------------------------------
 29142                                  ;
 29143                                  ;RESULT LABEL	BYTE			; BELOW FILLED IN FOR DEFAULTS
 29144                                  ;	DB	type			; TYPE RETURNED: 0=RESERVED,
 29145                                  ;					;	1=NUMBER, 2=LIST INDEX,
 29146                                  ;					;	3=STRING, 4=COMPLEX,
 29147                                  ;					;	5=FILESPEC, 6=DRIVE
 29148                                  ;					;	7=DATE, 8=TIME
 29149                                  ;					;	9=QUOTED STRING
 29150                                  ;	DB	ITEM_TAG		; MATCHED ITEM TAG
 29151                                  ;
 29152                                  ;	dw	synonym@		; es:@ points to found SYNONYM if provided.
 29153                                  ;
 29154                                  ;       +-
 29155                                  ;       | DD	n			; VALUE IF NUMBER
 29156                                  ;       | or
 29157                                  ;       |	DW i			; INDEX (OFFSET) INTO VALUE LIST
 29158                                  ;       |				; (ES presents Segment address)
 29159                                  ;       | or
 29160                                  ;       |	DD STRING		; OFFSET OF STRING VALUE
 29161                                  ;       | or
 29162                                  ;       |	DB drv			; DRIVE NUMBER (1-A, 2-B,..., 26-Z)
 29163                                  ;       | or
 29164                                  ;       |	DW YEAR	   		;(1980-2099)  IN CASE OF DATE
 29165                                  ;       |	DB MONTH   ;(1-12)	 Note: Range check is not performed.
 29166                                  ;       |	DB DATE	   ;(1-31)	 0 is filled when the corresponding field was not specified.
 29167                                  ;       | or
 29168                                  ;       |	DB HOUR	   ;(0-23)	 IN CASE OF TIME
 29169                                  ;       |	DB MINUTES    ;(0-59)	 Note: Range check is not performed .
 29170                                  ;       |	DB SECONDS    ;(0-59)	 0 is filled when the corresponding field was not specified .
 29171                                  ;       |	DB HUNDREDTHS ;(0-99)
 29172                                  ;       +-
 29173                                  ;
 29174                                  ;Note: ITEM_TAG is 0FFH when the caller does not specify the choice
 29175                                  ;      list.
 29176                                  ;
 29177                                  ;      YEAR: If the input value for the year is less than 100, parser
 29178                                  ;	     adds 1900 to it. For example, when 87 is input to parser for
 29179                                  ;	     the year value, he returns 1987.
 29180                                  ;----------------------------------------------------------------------------
 29181                                  
 29182                                  ;-------------------------------- Result block structure
 29183                                  struc $P_RESULT_BLK;
 29184 00000000 ??                      .$P_Type:	 resb 1		;AN000; Type returned
 29185 00000001 ??                      .$P_Item_Tag:	 resb 1		;AN000; Matched item tag
 29186 00000002 ????                    .$P_SYNONYM_Ptr: resw 1		;AN000; pointer to Synonym list returned
 29187 00000004 ????????                .$P_Picked_Val:	 resb 4		;AN000; value
 29188                                  endstruc
 29189                                  
 29190                                  ;**** values for the type field in the result block
 29191                                  
 29192                                  $P_EOL		 equ 0		;AN000; End of line
 29193                                  $P_Number	 equ 1		;AN000; Number
 29194                                  $P_List_Idx	 equ 2		;AN000; List Index
 29195                                  $P_String	 equ 3		;AN000; String
 29196                                  $P_Complex	 equ 4		;AN000; Complex
 29197                                  $P_File_Spec	 equ 5		;AN000; File Spec
 29198                                  $P_Drive	 equ 6		;AN000; Drive
 29199                                  $P_Date_F	 equ 7		;AN000; Date
 29200                                  $P_Time_F	 equ 8		;AN000; Time
 29201                                  $P_Quoted_String equ 9		;AN000; Quoted String
 29202                                  
 29203                                  $P_No_Tag	 equ 0FFh	;AN000; No ITEM_TAG found
 29204                                  
 29205                                  ;**** Return code
 29206                                  ;
 29207                                  ; following return code will be returned in the AX register.
 29208                                  
 29209                                  $P_No_Error	 equ 0		;AN000; No error
 29210                                  $P_Too_Many	 equ 1		;AN000; Too many operands
 29211                                  $P_Op_Missing	 equ 2		;AN000; Required operand missing
 29212                                  $P_Not_In_SW	 equ 3		;AN000; Not in switch list provided
 29213                                  $P_Not_In_Key	 equ 4		;AN000; Not in keyword list provided
 29214                                  $P_Out_Of_Range  equ 6		;AN000; Out of range specified
 29215                                  $P_Not_In_Val	 equ 7		;AN000; Not in value list provided
 29216                                  $P_Not_In_Str	 equ 8		;AN000; Not in string list provided
 29217                                  $P_Syntax	 equ 9		;AN000; Syntax error
 29218                                  $P_RC_EOL	 equ -1		;AN000; End of command line
 29219                                  
 29220                                  ;in second byte of $P_Flags, referenced as $P_Flags2:
 29221                                  $P_equ		 equ 01h	;AN000; "=" packed in string buffet
 29222                                  $P_Neg		 equ 02h	;AN000; Negative value
 29223                                  $P_Time12	 equ 04h	;AN000; set when PM is specified
 29224                                  $P_Key_Cmp	 equ 08h	;AN000; set when keyword compare
 29225                                  $P_SW_Cmp	 equ 10h	;AN000; set when switch compare
 29226                                  $P_Extra	 equ 20h	;AN000; set when extra delimiter found
 29227                                  $P_SW		 equ 40h	;AN000; set when switch found (tm08)
 29228                                  $P_Signed	 equ 80h	;AN000; signed numeric specified
 29229                                  
 29230                                  ;-------- Masks
 29231                                  $P_Make_Lower	 equ 20h	;AN000; make lower case character
 29232                                  $P_Make_Upper	 equ 0FFh-$P_Make_Lower ;AN000; make upper case character
 29233                                  
 29234                                  ;-------------
 29235                                  
 29236                                  struc $P_DOS_TBL
 29237 00000000 ??                      .$P_DOS_InfoID:	 resb 1		;AN000; information id for the table
 29238 00000001 ????                    .$P_DOS_TBL_Off: resw 1		;AN000; offset address of the table
 29239 00000003 ????                    .$P_DOS_TBL_Seg: resw 1		;AN000; segment address of the table
 29240                                  endstruc
 29241                                  
 29242                                  $P_DOS_Get_TBL	 equ 65h	;AN000; get uppercase table call
 29243                                  				;AN000; following parameters are set
 29244                                  				;AN000; to get casemap table.
 29245                                  $P_DOSTBL_Def	 equ -1		;AN000; get default
 29246                                  $P_DOSTBL_BL	 equ 5		;AN000; buffer length for Tbl pointer
 29247                                  $P_DOSTBL_File	 equ 4		;AN000; get file uppercase table
 29248                                  $P_DOSTBL_Char	 equ 2		;AN000; get character uppercase table
 29249                                  				; By this call following information
 29250                                  				; is returned.
 29251                                  
 29252                                  ; 03/04/2023
 29253                                  ;-------------------------------- country dependent information
 29254                                  
 29255                                  $P_DOS_Get_CDI	equ 3800h
 29256                                  
 29257                                  struc $P_CDI
 29258 00000000 ????                    .$P_CDI_DateF:	resw 1		;AN000;
 29259 00000002 ????????                .$P_CDI_Money:	resb 4		;AN000;
 29260 00000006 ????                    .$P_CDI_1000:	resb 2		;AN000;
 29261 00000008 ????                    .$P_CDI_Dec:	resb 2		;AN000;
 29262 0000000A ????                    .$P_CDI_DateS:	resb 2		;AN000;
 29263 0000000C ????                    .$P_CDI_TimeS:	resb 2		;AN000;
 29264 0000000E ??                      		resb 1		;AN000;
 29265 0000000F ??                      		resb 1		;AN000;
 29266 00000010 ??                      .$P_CDI_TimeF:	resb 1		;AN000;
 29267 00000011 ????????                		resw 2		;AN000;
 29268 00000015 ????                    		resb 2		;AN000;
 29269 00000017 <res Ah>                		resw 5		;AN000;
 29270                                  endstruc
 29271                                  
 29272                                  $P_Date_MDY	equ 0		;AN000;
 29273                                  $P_Date_DMY	equ 1		;AN000;
 29274                                  $P_Date_YMD	equ 2		;AN000;
 29275                                  
 29276                                  ; ----------------------------
 29277                                  ; (PARSE.ASM, MSDOS 6.0, 1991)
 29278                                  ; ----------------------------
 29279                                  
 29280                                  ;***********************************************************************
 29281                                  ; SysParse;
 29282                                  ;
 29283                                  ;  Function : Parser Entry
 29284                                  ;
 29285                                  ;  Input: DS:SI -> command line
 29286                                  ;	  ES:DI -> parameter block
 29287                                  ;	  psdata_seg -> psdata.inc
 29288                                  ;	  CX = operand ordinal
 29289                                  ;
 29290                                  ;	  Note:  ES is the segment containing all the control blocks defined
 29291                                  ;		 by the caller, except for the DOS COMMAND line parms, which
 29292                                  ;		 is in DS.
 29293                                  ;
 29294                                  ;  Output: CY = 1   error of caller, means invalid parameter block or
 29295                                  ;		    invalid value list. But this parser does NOT implement
 29296                                  ;		    this feature. Therefore CY always zero.
 29297                                  ;
 29298                                  ;	   CY = 0   AX = return code
 29299                                  ;		    BL = terminated delimiter code
 29300                                  ;		    CX = new operand ordinal
 29301                                  ;		    SI = set past scaned operand
 29302                                  ;		    DX = selected result buffer
 29303                                  ;
 29304                                  ; Use:	$P_Skip_Delim, $P_Chk_EOL, $P_Chk_Delim, $P_Chk_DBCS
 29305                                  ;	$P_Chk_Swtch, $P_Chk_Pos_Control, $P_Chk_Key_Control
 29306                                  ;	$P_Chk_Sw_Control, $P_Fill_Result
 29307                                  ;
 29308                                  ; Vars: $P_Ordinal(RW), $P_RC(RW), $P_SI_Save(RW), $P_DX(R), $P_Terminator(R)
 29309                                  ;	$P_SaveSI_Cmpx(W), $P_Flags(RW), $P_Found_SYNONYM(R), $P_Save_EOB(W)
 29310                                  ;
 29311                                  ;-------- Modification History -----------------------------------------
 29312                                  ;
 29313                                  ;  4/04/87 : Created by K. K,
 29314                                  ;  4/28/87 : $P_Val_YH assemble error (tm01)
 29315                                  ;	   : JMP SHORT assemble error (tm02)
 29316                                  ;  5/14/87 : Someone doesn't want to include psdata (tm03)
 29317                                  ;  6/12/87 : $P_Bridge is missing when TimeSw equ 0 and (CmpxSw equ 1 or
 29318                                  ;	     DateSW equ 1)	      (tm04)
 29319                                  ;  6/12/87 : $P_SorD_Quote is missing when QusSw equ 0 and CmpxSW equ 1
 29320                                  ;				      (tm05) in PSDATA.INC
 29321                                  ;  6/12/87 : $P_FileSp_Char and $P_FileSP_Len are missing
 29322                                  ;	     when FileSW equ 0 and DrvSW equ 1 (tm06) in PSDATA.INC
 29323                                  ;  6/18/87 : $VAL1 and $VAL3, $VAL2 and $VAL3 can be used in the same
 29324                                  ;	     value-list block	      (tm07)
 29325                                  ;  6/20/87 : Add $P_SW to check if there's an omiting parameter after
 29326                                  ;	     switch (keyword) or not. If there is, backup si for next call
 29327                                  ;	     (tm08)
 29328                                  ;  6/24/87 : Complex Item checking does not work correctly when CmpSW equ 1
 29329                                  ;	     and DateSW equ 0 and TimeSW equ 0 (tm09)
 29330                                  ;  6/24/87 : New function flag $P_colon_is_not_necessary for switch
 29331                                  ;	     /+15 and /+:15 are allowed for user (tm10)
 29332                                  ;  6/29/87 : ECS call changes DS register but it causes the address problem
 29333                                  ;	     in user's routines. $P_Chk_DBCS (tm11)
 29334                                  ;  7/10/87 : Switch with no_match flag (0x0000H) does not work correctly
 29335                                  ;					  (tm12)
 29336                                  ;  7/10/87 : Invalid switch/keyword does not work correctly
 29337                                  ;					  (tm13)
 29338                                  ;  7/10/87 : Drive_only breaks 3 bytes after the result buffer
 29339                                  ;					  (tm14)
 29340                                  ;  7/12/87 : Too_Many_Operands sets DX=0 as the PARSE result
 29341                                  ;					  (tm15)
 29342                                  ;  7/24/87 : Negative lower bound on numeric ranges cause trouble
 29343                                  ;
 29344                                  ;  7/24/87 : Quoted strings being returned with quotes.
 29345                                  ;
 29346                                  ;  7/28/87 : Kerry S (;AN018;)
 29347                                  ;	     Non optional value on switch (match flags<>0 and <>1) not flagged
 29348                                  ;	     as an error when missing.	Solution: return error 2.  Modules
 29349                                  ;	     affected: $P_Chk_SW_Control.
 29350                                  ;
 29351                                  ;  7/29/87 : Kerry S (;AN019;)
 29352                                  ;	     Now allow the optional bit in match flags for switches.  This
 29353                                  ;	     allows the switch to be encountered with a value or without a
 29354                                  ;	     value and no error is returned.
 29355                                  ;
 29356                                  ;
 29357                                  ;  8/28/87 : Ed K, Kerry S (;AN020;)
 29358                                  ;  9/14/87   In PROC $P_Get_DecNum, when checking for field separators
 29359                                  ;	     within a date response, instead of checking just for the one
 29360                                  ;	     character defined by the COUNTRY DEPENDENT INFO, check for
 29361                                  ;	     all three chars, "-", "/", and ".". Change $P_Chk_Switch to allow
 29362                                  ;	     slashes in date strings when DateSw (assembler switch) is set.
 29363                                  ;
 29364                                  ;  9/1/87  : Kerry S (;AN021)
 29365                                  ;	     In PROC $P_String_Comp, when comparing the switch or keyword on
 29366                                  ;	     the command line with the string in the control block the
 29367                                  ;	     comparing was stopping at a colon (switch) or equal (keyword)
 29368                                  ;	     on the command line and assuming a match.	This allowed a shorter
 29369                                  ;	     string on the command line than in the synonym list in the control
 29370                                  ;	     block.  I put in a test for a null in the control block so the
 29371                                  ;	     string in the control block must be the same length as the string
 29372                                  ;	     preceeding the colon or equal on the command line.
 29373                                  ;
 29374                                  ;  8/28/87 : Kerry S (;AN022;)
 29375                                  ;	     All references to data in PSDATA.INC had CS overrides.  This caused
 29376                                  ;	     problems for people who included it themselves in a segment other
 29377                                  ;	     than CS.  Added switch to allow including PSDATA.INC in any
 29378                                  ;	     segment.
 29379                                  ;
 29380                                  ;  9/16/87 : Ed K (;AN023;) PTM1040
 29381                                  ;	     in $p_set_cdi PROC, it assumes CS points to psdata. Change Push CS
 29382                                  ;	     into PUSH PSDATA_SEG.  In $P_Get_DecNum PROC, fix AN020
 29383                                  ;	     forced both TIME and DATE to use the delims, "-","/",".".
 29384                                  ;	     Created FLag, in $P_time_Format PROC, to request the delim in
 29385                                  ;	     BL be used if TIME is being parsed.
 29386                                  ;
 29387                                  ;  9/24/87 : Ed K
 29388                                  ;	     Removed the include to STRUC.INC.	Replaced the STRUC macro
 29389                                  ;	     invocations with their normally expanded code; made comments
 29390                                  ;	     out of the STRUC macro invocation statements to maintain readability.
 29391                                  ;
 29392                                  ;  9/24/87 : Ed K (;AN024;) PTM1222
 29393                                  ;	     When no CONTROL for a keyword found, tried to fill in RESULT
 29394                                  ;	     pointed to by non-existant CONTROL.
 29395                                  ;
 29396                                  ; 10/15/87 : Ed K (;AN025;) PTM1672
 29397                                  ;	     A quoted text string can be framed only by double quote.  Remove
 29398                                  ;	     support to frame quoted text string with single quote.
 29399                                  ;	     (apostrophe) $P_SorD_Quote is removed from PSDATA.INC.
 29400                                  ;	     $P_SQuote EQU also removed from PSDATA.INC.  Any references to
 29401                                  ;	     single quote in PROC prologues are left as is for history reasons.
 29402                                  ;
 29403                                  ;	     This fixes another bug, not mentioned in p1672, in that two
 29404                                  ;	     quote chars within a quoted string is supposed to be reported as
 29405                                  ;	     one quote character, but is reported as two quotes.  This changed
 29406                                  ;	     two instructions in PROC $P_Quoted_Str.
 29407                                  ;
 29408                                  ;	     Also fixed are several JMP that caused a NOP, these changed to
 29409                                  ;	     have the SHORT operator to avoid the unneeded NOP.
 29410                                  ;
 29411                                  ;	     The code and PSDATA.INC have been aligned for ease of reading.
 29412                                  ;
 29413                                  ; 10/26/87 : Ed K (;AN026;) PTM2041, DATE within SWITCH, BX reference to
 29414                                  ;	     psdata buffer should have psdata_seg.
 29415                                  ;
 29416                                  ; 10/27/87 : Ed K (;AN027;) PTM2042 comma between keywords implies
 29417                                  ;	     positional missing.
 29418                                  ;
 29419                                  ; 11/06/87 : Ed K (;AN028;) PTM 2315 Parser should not use line feed
 29420                                  ;	     as a line delimiter, should use carriage return.
 29421                                  ;	     Define switch: LFEOLSW, if on, accept LF as end of line char.
 29422                                  ;
 29423                                  ; 11/11/87 : Ed K (;AN029;) PTM 1651 GET RID OF WHITESPACE AROUND "=".
 29424                                  ;
 29425                                  ; 11/18/87 : Ed K (;AN030;) PTM 2551 If filename is just "", then
 29426                                  ;	     endless loop since SI is returned still pointing to start
 29427                                  ;	     of that parm.
 29428                                  ;
 29429                                  ; 11/19/87 : Ed K (;AN031;) PTM 2585 date & time getting bad values.
 29430                                  ;	     Vector to returned string has CS instead of Psdata_Seg, but
 29431                                  ;	     when tried to fix it on previous version, changed similar
 29432                                  ;	     but wrong place.
 29433                                  ;
 29434                                  ; 12/09/87 : Bill L (;AN032;) PTM 2772 colon and period are now valid
 29435                                  ;	     delimiters between hours, minutes, seconds for time. And period
 29436                                  ;	     and comma are valid delimiters between seconds and 100th second.
 29437                                  ;
 29438                                  ; 12/14/87 : Bill L (;AN033;) PTM 2722 if illegal delimiter characters
 29439                                  ;	     in a filespec, then flag an error.
 29440                                  ;
 29441                                  ; 12/22/87 : Bill L (;AN034;)	    All local data to parser is now
 29442                                  ;	     indexed off of the psdata_seg equate instead of the DS register.
 29443                                  ;	     Using this method, DS can point to the segment of PSP or to psdata
 29444                                  ;  -->	     local parser data. Why were some references to local data changed
 29445                                  ;	     to do this before, but not all ?????
 29446                                  ;
 29447                                  ; 02/02/88 : Ed K (;AC035;) INSPECT utility, suggests optimizations.
 29448                                  ;
 29449                                  ; 02/05/88 : Ed K (;AN036;) P3372-UPPERCASE TRANSLATION, PSDATA_SEG HOSED.
 29450                                  ;
 29451                                  ; 02/08/88 : Ed K (;AN037;) P3410-AVOID POP OF CS, CHECK BASESW FIRST.
 29452                                  ;
 29453                                  ; 02/19/88 : Ed K (;AN038;) p3524 above noon and "am" should be error
 29454                                  ;
 29455                                  ; 02/23/88 : Ed K (;AN039;) p3518 accept "comma" and "period" as decimal
 29456                                  ;	     separator in TIME before hundredths field.
 29457                                  ;
 29458                                  ; 08/09/90 : SA	M005	Prevented parser from recognizing '=' signs within
 29459                                  ;			strings as keywords.
 29460                                  ;
 29461                                  ;***********************************************************************
 29462                                  
 29463                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29464                                  cmd_parse:
 29465                                  	;call	sysparse
 29466                                  	;retn
 29467                                  
 29468                                  ; -----------------------------------
 29469                                  
 29470                                  	; 29/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29471                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:44E7h
 29472                                  
 29473                                  sysparse:
 29474 00004330 2EC706[F485]0000        	mov	word [cs:$P_Flags],0	;AC034; Clear all internal flags
 29475 00004337 2E890E[7E86]            	mov	[cs:$P_ORIG_ORD],cx	;AN039; ORIGINAL ORDINAL FROM CX
 29476 0000433C 2E8926[8086]            	mov	[cs:$P_ORIG_STACK],sp	;AN039; ORIGINAL VALUE OF STACK FROM SP
 29477 00004341 2E8936[8286]            	mov	[cs:$P_ORIG_SI],si	;AN039; ORIGINAL START PARSE POINTER FROM SI
 29478                                  $P_Redo_Time:				;AN039; try to parse time again
 29479 00004346 FC                      	cld				;AN000; confirm forward direction
 29480 00004347 2E890E[E785]            	mov	[cs:$P_ORDINAL],cx      ;AC034; save operand ordinal
 29481                                  	;mov	word [cs:$P_RC],$P_No_Error
 29482 0000434C 2EC706[E985]0000        	mov	word [cs:$P_RC],0	;AC034; Assume no error
 29483 00004353 2EC706[FC85]0000        	mov	word [cs:$P_Found_SYNONYM],0
 29484                                  					;AC034; initalize synonym pointer
 29485 0000435A 2EC706[ED85]0000        	mov	word [cs:$P_DX],0	;AC034; (tm15)
 29486                                  
 29487                                  ;M029 -- Begin changes
 29488                                  ; The table of special chars $P_FileSp_Char should be initialized on every
 29489                                  ;entry to SysParse. This is in the non-checksum region and any program that
 29490                                  ;corrupts this table but does not corrupt the checksum region will leave
 29491                                  ;command.com parsing in an inconsistent state.
 29492                                  ; NB: The special characters string has been hardcoded here. If any change
 29493                                  ;is made to it in psdata.inc, a corresponding change needs to be made here.
 29494                                  
 29495 00004361 2EC706[B986]5B5D        	mov	word [cs:$P_FileSp_Char], '[]'	 ; "[]|<>+=;\""
 29496 00004368 2EC706[BB86]7C3C        	mov	word [cs:$P_FileSp_Char+2], '|<'
 29497 0000436F 2EC706[BD86]3E2B        	mov	word [cs:$P_FileSp_Char+4], '>+'
 29498 00004376 2EC706[BF86]3D3B        	mov 	word [cs:$P_FileSp_Char+6], '=;'
 29499                                  
 29500                                  ;M029 -- End of changes
 29501                                  
 29502 0000437D E83809                  	call	$P_Skip_Delim		;AN000; Move si to 1st non white space
 29503 00004380 7312                    	jnc	short $P_Start		;AN000; If EOL is not encountered, do parse
 29504                                  
 29505                                  ;--------------------------- End of Line
 29506                                  	;mov	ax,$P_RC_EOL		;AN000; set exit code to -1
 29507 00004382 B8FFFF                  	mov	ax,0FFFFh
 29508 00004385 53                      	push	bx			;AN000;
 29509                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29510 00004386 268B1D                  	mov	bx,[es:di]		;AN000; Get the PARMSX address to
 29511                                  	
 29512                                  	;cmp	cl,[es:bx+$P_PARMSX_BLK.$P_MinP]
 29513 00004389 263A0F                  	cmp	cl,[es:bx]		;AN000; check ORDINAL to see if the minimum
 29514 0000438C 7304                    	jae	short $P_Fin		;AN000; positional found.
 29515                                  
 29516                                  	;mov	ax,2
 29517 0000438E B80200                  	mov	ax,$P_Op_Missing ; 2	;AN000; If no, set exit code to missing operand
 29518                                  	; 27/04/2023
 29519 00004391 F8                      	clc
 29520                                  $P_Fin: 				;AN000;
 29521 00004392 5B                      	pop	bx			;AN000;
 29522                                  	;jmp	$P_Single_Exit		;AN000; return to the caller
 29523                                  	; 27/04/2023
 29524                                  	; cf = 0
 29525                                  	;clc
 29526 00004393 C3                      	retn
 29527                                  
 29528                                  ;---------------------------
 29529                                  $P_Start:				;AN000;
 29530 00004394 2E8936[F685]            	mov	[cs:$P_SaveSI_Cmpx],si	;AN000;AC034;  save ptr to command line for later use by complex,
 29531 00004399 53                      	push	bx			;AN000; quoted string or file spec.
 29532 0000439A 57                      	push	di			;AN000;
 29533 0000439B 55                      	push	bp			;AN000;
 29534 0000439C 8D1E[FE85]              	lea	bx,$P_STRING_BUF	;AC034; set buffer to copy from command string
 29535 000043A0 2EF606[F585]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29536                                  	;test	byte [cs:$P_Flags2],20h	;AC034; 3/9 extra delimiter encountered ?
 29537 000043A6 7543                    	jnz	short $P_Pack_End	;AN000; 3/9 if yes, no need to copy
 29538                                  $P_Pack_Loop:				;AN000;
 29539 000043A8 AC                      	lodsb				;AN000; Pick a operand from buffer
 29540 000043A9 E8C109                  	call	$P_Chk_Switch		;AN000; Check switch character
 29541 000043AC 723C                    	jc	short $P_Pack_End_BY_EOL ;AN020; if carry set found delimiter type slash, need backup si, else continue
 29542                                  
 29543 000043AE E82909                  	call	$P_Chk_EOL		;AN000; Check EOL character
 29544 000043B1 7437                    	je	short $P_Pack_End_BY_EOL ;AN000; need backup si
 29545                                  
 29546 000043B3 E85609                  	call	$P_Chk_Delim		;AN000; Check delimiter
 29547 000043B6 7518                    	jne	short $P_PL01 		;AN000; If no, process next byte
 29548                                  
 29549 000043B8 2EF606[F585]20          	test	byte [cs:$P_Flags2],$P_Extra ; 20h
 29550                                  	;test	byte [cs:$P_Flags2],20h ;AC034; 3/9 If yes and white spec,
 29551 000043BE 7505                    	jnz	short $P_Pack_End_backup_si
 29552                                  					;AN000; (tm08)
 29553 000043C0 E8F508                  	call	$P_Skip_Delim		;AN000; skip subsequent white space,too
 29554 000043C3 EB26                    	jmp	short $P_Pack_End	;AN000; finish copy by placing NUL at end
 29555                                  
 29556                                  $P_Pack_End_backup_si:			;AN000; (tm08)
 29557 000043C5 2EF606[F585]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ ; 41h
 29558                                  	;test	byte [cs:$P_Flags2],41h ;AN000;AC034;  (tm08)
 29559 000043CB 741E                    	jz	short $P_Pack_End	;AN000; (tm08)
 29560                                  
 29561 000043CD 4E                      	dec	si			;AN000; (tm08)
 29562 000043CE EB1B                    	jmp	short $P_Pack_End	;AN025; (tm08)
 29563                                  $P_PL01:				;AN000;
 29564 000043D0 2E8807                  	mov	[cs:bx],al		;AN000; move byte to STRING_BUF
 29565                                  	;cmp	al,'='
 29566 000043D3 3C3D                    	cmp	al,$P_Keyword ; '='	;AN000; if it is equal character,
 29567 000043D5 7506                    	jne	short $P_PL00 		;AN000; then
 29568                                  
 29569 000043D7 2E800E[F585]01          	or	byte [cs:$P_Flags2],$P_equ
 29570                                  	;or	byte [cs:$P_Flags_2],1	;AC034; remember it in flag
 29571                                  $P_PL00:				;AN000;
 29572 000043DD 43                      	inc	bx			;AN000; ready to see next byte
 29573 000043DE E8B709                  	call	$P_Chk_DBCS		;AN000; was it 1st byte of DBCS ?
 29574 000043E1 73C5                    	jnc	short $P_Pack_Loop	;AN000; if no, process to next byte
 29575                                  
 29576 000043E3 AC                      	lodsb				;AN000; if yes, store
 29577 000043E4 2E8807                  	mov	[cs:bx],al		;AN000;    2nd byte of DBCS
 29578 000043E7 43                      	inc	bx			;AN000; update pointer
 29579 000043E8 EBBE                    	jmp	short $P_Pack_Loop	;AN000; process to next byte
 29580                                  
 29581                                  $P_Pack_End_BY_EOL:			;AN000;
 29582 000043EA 4E                      	dec	si			;AN000; backup si pointer
 29583                                  $P_Pack_End:				;AN000;
 29584 000043EB 2E8936[EB85]            	mov	[cs:$P_SI_Save],si	;AC034; save next pointer, SI
 29585                                  	;mov	byte [cs:bx],0
 29586 000043F0 2EC60700                	mov	byte [cs:bx],$P_NULL	;AN000; put NULL at the end
 29587 000043F4 2E891E[FA85]            	mov	[cs:$P_Save_EOB],bx
 29588                                  					;AC034; 3/17/87 keep the address for later use of complex
 29589                                  	;mov	bx,[es:di+$P_PARMS_BLK.$P_PARMSX_Address]
 29590 000043F9 268B1D                  	mov	bx,[es:di]		;AN000; get PARMSX address
 29591 000043FC 8D36[FE85]              	lea	si,$P_STRING_BUF	;AC034;
 29592                                  	;cmp	byte [cs:si],'/'
 29593 00004400 2E803C2F                	cmp	byte [cs:si],$P_Switch	;AN000; the operand begins w/ switch char ?
 29594 00004404 7436                    	je	short $P_SW_Manager	;AN000; if yes, process as switch
 29595                                  
 29596 00004406 2E803C22                	cmp	byte [cs:si],$P_DQuote	;M005;is it a string?
 29597 0000440A 7408                    	je	short $P_Positional_Manager
 29598                                  					;M005;if so, process as one!
 29599 0000440C 2EF606[F585]01          	test	byte [cs:$P_Flags2],$P_equ
 29600                                  	;test	byte [cs:$P_Flags2],1	;AC034; the operand includes equal char ?
 29601 00004412 7554                    	jnz	short $P_Key_Manager	;AN000; if yes, process as keyword
 29602                                  
 29603                                  $P_Positional_Manager:			;AN000; else process as positional
 29604                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29605 00004414 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29606 00004418 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29607 0000441A 2E3906[E785]            	cmp	[cs:$P_ORDINAL],ax	;AC034; too many positional ?
 29608 0000441F 7312                    	jae	short $P_Too_Many_Error	;AN000; if yes, set exit code to too many
 29609                                  
 29610 00004421 2EA1[E785]              	mov	ax,[cs:$P_ORDINAL]	;AC034; see what the current ordinal
 29611 00004425 D1E0                    	shl	ax,1			;AN000; ax = ax*2
 29612 00004427 43                      	inc	bx			;AC035; add '2' to
 29613 00004428 43                      	inc	bx			;AC035;  BX reg
 29614                                  					;AN000; now bx points to 1st CONTROL
 29615 00004429 01C3                    	add	bx,ax			;AN000; now bx points to specified CONTROL address
 29616 0000442B 268B1F                  	mov	bx,[es:bx]		;AN000; now bx points to specified CONTROL itself
 29617 0000442E E88800                  	call	$P_Chk_Pos_Control	;AN000; Do process for positional
 29618 00004431 EB69                    	jmp	short $P_Return_to_Caller
 29619                                  					;AN000; and return to the caller
 29620                                  $P_Too_Many_Error:			;AN000;
 29621                                  	;mov	word [cs:$P_RC],1
 29622 00004433 2EC706[E985]0100        	mov	word [cs:$P_RC],$P_Too_Many
 29623                                  					;AC034; set exit code
 29624 0000443A EB60                    	jmp	short $P_Return_to_Caller
 29625                                  					;AN000; and return to the caller
 29626                                  $P_SW_Manager:				;AN000;
 29627                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29628 0000443C 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29629 00004440 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29630 00004442 40                      	inc	ax			;AN000;
 29631 00004443 D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 29632 00004445 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 29633 00004447 268A0F                  	mov	cl,[es:bx]		;AN000;
 29634 0000444A 30ED                    	xor	ch,ch			;AN000; cx = maxs
 29635 0000444C 09C9                    	or	cx,cx			;AN000; at least one switch ?
 29636 0000444E 740F                    	jz	short $P_SW_Not_Found 	;AN000;
 29637 00004450 43                      	inc	bx			;AN000; now bx points to 1st CONTROL address
 29638                                  $P_SW_Mgr_Loop: 			;AN000;
 29639 00004451 53                      	push	bx			;AN000;
 29640 00004452 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to Switch CONTROL itself
 29641 00004455 E8C300                  	call	$P_Chk_SW_Control	;AN000; do process for switch
 29642 00004458 5B                      	pop	bx			;AN000;
 29643 00004459 7341                    	jnc	short $P_Return_to_Caller
 29644                                  					;AN000; if the CONTROL is for the switch, exit
 29645 0000445B 43                      	inc	bx			;AC035; add '2' to
 29646 0000445C 43                      	inc	bx			;AC035;  BX reg
 29647                                  					;AN000; else bx points to the next CONTROL
 29648 0000445D E2F2                    	loop	$P_SW_Mgr_Loop		;AN000; and loop
 29649                                  $P_SW_Not_Found:			;AN000;
 29650                                  	;mov	word [cs:$P_RC],3
 29651 0000445F 2EC706[E985]0300        	mov	word [cs:$P_RC],$P_Not_In_SW
 29652                                  					;AC034; here no CONTROL for the switch has
 29653 00004466 EB34                    	jmp	short $P_Return_to_Caller0
 29654                                  					;AN000; not been found, means error.
 29655                                  $P_Key_Manager: 			;AN000;
 29656                                  	;mov	al,[es:bx+1]		;AN000; get maxp
 29657 00004468 268A4701                	mov	al,[es:bx+$P_PARMSX_BLK.$P_MaxP]
 29658 0000446C 30E4                    	xor	ah,ah			;AN000; ax = maxp
 29659 0000446E 40                      	inc	ax			;AN000;
 29660 0000446F D1E0                    	shl	ax,1			;AN000; ax = (ax+1)*2
 29661 00004471 01C3                    	add	bx,ax			;AN000; now bx points to maxs
 29662 00004473 268A07                  	mov	al,[es:bx]		;AN000;
 29663 00004476 30E4                    	xor	ah,ah			;AN000; ax = maxs
 29664 00004478 D1E0                    	shl	ax,1			;AN000;
 29665 0000447A 40                      	inc	ax			;AN000; ax = ax*2+1
 29666 0000447B 01C3                    	add	bx,ax			;AN000; now bx points to maxk
 29667 0000447D 268A0F                  	mov	cl,[es:bx]		;AN000;
 29668 00004480 30ED                    	xor	ch,ch			;AN000; cx = maxk
 29669 00004482 09C9                    	or	cx,cx			;AN000; at least one keyword ?
 29670 00004484 740F                    	jz	short $P_Key_Not_Found	;AN000;
 29671 00004486 43                      	inc	bx			;AN000; now bx points to 1st CONTROL
 29672                                  $P_Key_Mgr_Loop:			;AN000;
 29673 00004487 53                      	push	bx			;AN000;
 29674 00004488 268B1F                  	mov	bx,[es:bx]		;AN000; bx points to keyword CONTROL itself
 29675 0000448B E85A00                  	call	$P_Chk_Key_Control	;AN000; do process for keyword
 29676 0000448E 5B                      	pop	bx			;AN000;
 29677 0000448F 730B                    	jnc	short $P_Return_to_Caller
 29678                                  					;AN000; if the CONTROL is for the keyword, exit
 29679 00004491 43                      	inc	bx			;AC035; add '2' to
 29680 00004492 43                      	inc	bx			;AC035;  BX reg
 29681                                  					;AN000; else bx points to the next CONTROL
 29682 00004493 E2F2                    	loop	$P_Key_Mgr_Loop 	;AN000; and loop
 29683                                  $P_Key_Not_Found:			;AN000;
 29684                                  	;mov	word [cs:$P_RC],4
 29685 00004495 2EC706[E985]0400        	mov	word [cs:$P_RC],$P_Not_In_Key
 29686                                  					;AC034; here no CONTROL for the keyword has
 29687                                  $P_Return_to_Caller0:
 29688                                  $P_Return_to_Caller:			;AN000; not been found, means error.
 29689 0000449C 5D                      	pop	bp			;AN000;
 29690 0000449D 5F                      	pop	di			;AN000;
 29691 0000449E 5B                      	pop	bx			;AN000;
 29692 0000449F 2E8B0E[E785]            	mov	cx,[cs:$P_ORDINAL]	;AC034; return next ordinal
 29693 000044A4 2EA1[E985]              	mov	ax,[cs:$P_RC]		;AC034; return exit code
 29694 000044A8 2E8B36[EB85]            	mov	si,[cs:$P_SI_Save]	;AC034; return next operand pointer
 29695 000044AD 2E8B16[ED85]            	mov	dx,[cs:$P_DX]		;AC034; return result buffer address
 29696 000044B2 2E8A1E[EF85]            	mov	bl,[cs:$P_Terminator]	;AC034; return delimiter code found
 29697                                  $P_Single_Exit: 			;AN000;
 29698 000044B7 F8                      	clc				;AN000;
 29699 000044B8 C3                      	retn				;AN000;
 29700                                  
 29701                                  ;***********************************************************************
 29702                                  ; $P_Chk_Pos_Control
 29703                                  ;
 29704                                  ; Function: Parse CONTROL block for a positional
 29705                                  ;
 29706                                  ; Input:     ES:BX -> CONTROL block
 29707                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29708                                  ;
 29709                                  ; Output:    None
 29710                                  ;
 29711                                  ; Use:	 $P_Fill_Result, $P_Check_Match_Flags
 29712                                  ;
 29713                                  ; Vars: $P_Ordinal(W), $P_RC(W)
 29714                                  ;***********************************************************************
 29715                                  
 29716                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29717                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4671h
 29718                                  
 29719                                  $P_Chk_Pos_Control:
 29720 000044B9 50                      	push	ax			;AN000;
 29721                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 29722 000044BA 268B07                  	mov	ax,[es:bx]		;AN000;
 29723                                  	;test	ax,2
 29724 000044BD A90200                  	test	ax,$P_Repeat		;AN000; repeat allowed ?
 29725 000044C0 7505                    	jnz	short $P_CPC00		;AN000; then do not increment ORDINAL
 29726                                  
 29727 000044C2 2EFF06[E785]            	inc	word [cs:$P_ORDINAL]	;AC034; update the ordinal
 29728                                  $P_CPC00:				;AN000;
 29729                                  	;cmp	byte [cs:si],0
 29730 000044C7 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; no data ?
 29731 000044CB 7516                    	jne	short $P_CPC01		;AN000;
 29732                                  
 29733                                  	;test	ax,1
 29734 000044CD A90100                  	test	ax,$P_Optional		;AN000; yes, then is it optional ?
 29735 000044D0 7509                    	jnz	short $P_CPC02		;AN000;
 29736                                  
 29737 000044D2 2EC706[E985]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 29738                                  					;AC034; no, then error	 3/17/87
 29739 000044D9 EB0B                    	jmp	short $P_CPC_Exit	;AN000;
 29740                                  $P_CPC02:				;AN000;
 29741                                  	; 27/04/2023
 29742                                  	;push	ax ; *			;AN000;
 29743                                  	;
 29744                                  	;;mov	al,3
 29745                                  	;mov	al,$P_String		;AN000; if it is optional return NULL
 29746                                  	;;mov	ah,0FFh
 29747                                  	;mov	ah,$P_No_Tag		;AN000; no item tag indication
 29748                                  	;31/03/2023
 29749 000044DB B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 29750 000044DE E89700                  	call	$P_Fill_Result		;AN000;
 29751                                  	; 27/04/2023
 29752                                  	;pop	ax ; *			;AN000;
 29753 000044E1 EB03                    	jmp	short $P_CPC_Exit	;AN000;
 29754                                  $P_CPC01:				;AN000;
 29755 000044E3 E81301                  	call	$P_Check_Match_Flags	;AN000;
 29756                                  $P_CPC_Exit:				;AN000;
 29757 000044E6 58                      	pop	ax			;AN000;
 29758 000044E7 C3                      	retn				;AN000;
 29759                                  
 29760                                  ;***********************************************************************
 29761                                  ; $P_Chk_Key_Control
 29762                                  ;
 29763                                  ; Function: Parse CONTROL block for a keyword
 29764                                  ;
 29765                                  ; Input:     ES:BX -> CONTROL block
 29766                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29767                                  ;
 29768                                  ; Output:    CY = 1 : not match
 29769                                  ;
 29770                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 29771                                  ;
 29772                                  ; Vars: $P_RC(W), $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 29773                                  ;***********************************************************************
 29774                                  
 29775                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29776                                  $P_Chk_Key_Control:			;AN000;
 29777 000044E8 F9                      	stc				;AN000;this logic works when the KeySW
 29778 000044E9 C3                      	retn				;AN000;is reset.
 29779                                  
 29780                                  ;***********************************************************************
 29781                                  ; $P_Search_KEYorSW:
 29782                                  ;
 29783                                  ; Function: Seach specified keyword or switch from CONTROL
 29784                                  ;
 29785                                  ; Input:     ES:BX -> CONTROL block
 29786                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29787                                  ;
 29788                                  ; Output:    CY = 1 : not match
 29789                                  ;
 29790                                  ; Use:	 $P_String_Comp, $P_MoveBP_NUL, $P_Found_SYNONYM
 29791                                  ;***********************************************************************
 29792                                  
 29793                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29794                                  
 29795                                  $P_Search_KEYorSW:
 29796 000044EA 55                      	push	bp			;AN000;
 29797 000044EB 51                      	push	cx			;AN000;
 29798 000044EC 268A4F08                	mov	cl,[es:bx+$P_CONTROL_BLK.$P_nid]
 29799                                  	;mov	cl,[es:bx+8]		;AN000; Get synonym count
 29800 000044F0 30ED                    	xor	ch,ch			;AN000; and set it to cx
 29801 000044F2 09C9                    	or	cx,cx			;AN000; No synonyms specified ?
 29802 000044F4 740E                    	jz	short $P_KEYorSW_Not_Found
 29803                                  					;AN000; then indicate not found by CY
 29804 000044F6 268D6F09                	lea	bp,[es:bx+$P_CONTROL_BLK.$P_KEYorSW]
 29805                                  	;lea	bp,[es:bx+9]		;AN000; BP points to the 1st synonym
 29806                                  $P_KEYorSW_Loop:			;AN000;
 29807 000044FA E8F803                  	call	$P_String_Comp		;AN000; compare string in buffer w/ the synonym
 29808 000044FD 7308                    	jnc	short $P_KEYorSW_Found	;AN000; If match, set it to synonym pointer
 29809 000044FF E80D00                  	call	$P_MoveBP_NUL		;AN000; else, bp points to the next string
 29810 00004502 E2F6                    	loop	$P_KEYorSW_Loop 	;AN000; loop nid times
 29811                                  $P_KEYorSW_Not_Found:			;AN000;
 29812 00004504 F9                      	stc				;AN000; indicate not found in synonym list
 29813 00004505 EB05                    	jmp	short $P_KEYorSW_Exit	;AN000; and exit
 29814                                  $P_KEYorSW_Found:			;AN000;
 29815 00004507 2E892E[FC85]            	mov	[cs:$P_Found_SYNONYM],bp
 29816                                  					;AC034; set synonym pointer
 29817                                  	; 27/04/2023
 29818                                  	; cf = 0
 29819                                  	;clc				;AN000; indicate found
 29820                                  $P_KEYorSW_Exit:			;AN000;
 29821 0000450C 59                      	pop	cx			;AN000;
 29822 0000450D 5D                      	pop	bp			;AN000;
 29823 0000450E C3                      	retn				;AN000;
 29824                                  
 29825                                  ;***********************************************************************
 29826                                  ; $P_MoveBP_NUL
 29827                                  ;***********************************************************************
 29828                                  
 29829                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29830                                  
 29831                                  $P_MoveBP_NUL:
 29832                                  $P_MBP_Loop:				;AN000;
 29833                                  	;cmp	byte [es:bp+0],0
 29834 0000450F 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000; Increment BP that points
 29835 00004514 7403                    	je	short $P_MBP_Exit	;AN000; to the synomym list
 29836 00004516 45                      	inc	bp			;AN000; until
 29837 00004517 EBF6                    	jmp	short $P_MBP_Loop	;AN000; NULL encountered.
 29838                                  $P_MBP_Exit:				;AN000;
 29839 00004519 45                      	inc	bp			;AN000; bp points to next to NULL
 29840 0000451A C3                      	retn				;AN000;
 29841                                  
 29842                                  ;***********************************************************************
 29843                                  ; $P_Chk_SW_Control
 29844                                  ;
 29845                                  ; Function: Parse CONTROL block for a switch
 29846                                  ;
 29847                                  ; Input:     ES:BX -> CONTROL block
 29848                                  ;	     psdata_seg:SI -> $P_STRING_BUF
 29849                                  ;
 29850                                  ; Output:    CY = 1 : not match
 29851                                  ;
 29852                                  ; Use:	 $P_Fill_Result, $P_Search_KEYorSW, $P_Check_Match_Flags
 29853                                  ;
 29854                                  ; Vars:  $P_SaveSI_Cmpx(W), $P_KEYorSW_Ptr(R), $P_Flags(W)
 29855                                  ;***********************************************************************
 29856                                  
 29857                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29858                                  
 29859                                  $P_Chk_SW_Control:
 29860 0000451B 2E800E[F585]10          	or	byte [cs:$P_Flags2],$P_SW_Cmp
 29861                                  	;or	byte [cs:$P_Flags2],10h	;AC034; Indicate switch for later string comparison
 29862 00004521 E8C6FF                  	call	$P_Search_KEYorSW	;AN000; Search the switch in the CONTROL block
 29863 00004524 7251                    	jc	short $P_Chk_SW_Err0	;AN000; not found, then try next CONTROL
 29864                                  
 29865 00004526 2E8026[F585]EF          	and	byte [cs:$P_Flags2],0FFh-$P_SW_Cmp
 29866                                  	;and	byte [cs:$P_Flags2],0EFh
 29867                                  					;AC034; reset the indicator previously set
 29868 0000452C 50                      	push	ax			;AN000;       /switch:
 29869 0000452D 2EA1[F885]              	mov	ax,[cs:$P_KEYorSW_Ptr]	;AC034;	      ^       ^
 29870 00004531 29F0                    	sub	ax,si			;AN000;  SI	KEYorSW
 29871 00004533 2E0106[F685]            	add	[cs:$P_SaveSI_Cmpx],ax	;AC034; update for complex list
 29872 00004538 58                      	pop	ax			;AN000;
 29873                                  
 29874 00004539 2E8B36[F885]            	mov	si,[cs:$P_KEYorSW_Ptr]	;AC034; set si at the end or colon
 29875                                  	;cmp	byte [cs:si],0
 29876 0000453E 2E803C00                	cmp	byte [cs:si],$P_NULL	;AN000; any data after colon
 29877 00004542 7525                    	jne	short $P_CSW00		;AN000; if yes, process match flags
 29878                                  
 29879                                  	;cmp	byte [cs:si],':'
 29880 00004544 2E807CFF3A              	cmp	byte [cs:si-1],$P_Colon
 29881                                  					;AN000; if no, the switch terminated by colon ?
 29882 00004549 7509                    	jne	short $P_Chk_if_data_required
 29883                                  					;AN000; if yes,
 29884                                  
 29885 0000454B 2EC706[E985]0900        	mov	word [cs:$P_RC],$P_Syntax
 29886                                  	;mov	word [cs:$P_RC],9	;AC034; return syntax error
 29887 00004552 EB1A                    	jmp	short $P_Chk_SW_Exit	;AN000;
 29888                                  
 29889                                  $P_Chk_if_data_required:		;AN018; no data, no colon
 29890                                  	;cmp	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],0
 29891                                  	; 27/04/2023
 29892 00004554 26833F00                	cmp	word [es:bx],0		;AN018; should have data? zero match flag means switch followed by nothing is OK
 29893 00004558 7414                    	je	short $P_Chk_SW_Exit	;AN018; match flags not zero so should have something if optional bit is not on
 29894                                  
 29895                                  	;;test	word [es:bx],1 ; $P_Optional
 29896                                  	;test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 29897 0000455A 26F60701                	test	byte [es:bx],$P_Optional
 29898                                  					;AN019; see if no value is valid
 29899 0000455E 750E                    	jnz	short $P_Chk_SW_Exit	;AN019; if so, then leave, else yell
 29900                                  
 29901 00004560 2EC706[E985]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 29902                                  	;mov	word [cs:$P_RC],2	;AC034; return required operand missing
 29903 00004567 EB05                    	jmp	short $P_Chk_SW_Exit	;AN018;
 29904                                  
 29905                                  $P_CSW00:				;AN000;
 29906 00004569 E88D00                  	call	$P_Check_Match_Flags	;AN000; process match flag
 29907 0000456C F8                      	clc				;AN000; indicate match
 29908                                  	;jmp	short $P_Chk_SW_Single_Exit
 29909 0000456D C3                      	retn	; 31/03/2023		;AN000;
 29910                                  	; 31/03/2023
 29911                                  ;$P_Chk_SW_Err0: 			;AN000;
 29912                                  ;	stc				;AN000; not found in switch synonym list
 29913                                  ;	;jmp	short $P_Chk_SW_Single_Exit
 29914                                  ;	retn	; 31/03/2023		;AN000;
 29915                                  	
 29916                                  $P_Chk_SW_Exit: 			;AN000;
 29917 0000456E 50                      	push	ax			;AN000;
 29918                                  	; 31/03/2023
 29919 0000456F B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 29920                                  	;;mov	al,3
 29921                                  	;;mov	ah,0FFh
 29922                                  	;mov	al,$P_String		;AN000; set
 29923                                  	;mov	ah,$P_No_Tag		;AN000;    result
 29924 00004572 E80300                  	call	$P_Fill_Result		;AN000; 	 buffer
 29925 00004575 58                      	pop	ax			;AN000;
 29926 00004576 F8                      	clc				;AN000;
 29927                                  	; 31/03/2023
 29928                                  $P_Chk_SW_Err0:
 29929                                  $P_Chk_SW_Single_Exit:			;AN000;
 29930 00004577 C3                      	retn				;AN000;
 29931                                  
 29932                                  ;***********************************************************************
 29933                                  ; $P_Fill_Result
 29934                                  ;
 29935                                  ; Function: Fill the result buffer
 29936                                  ;
 29937                                  ; Input:    AH = Item tag
 29938                                  ;	    AL = type
 29939                                  ;		  AL = 1: CX,DX has 32bit number (CX = high)
 29940                                  ;		  AL = 2: DX has index(offset) into value list
 29941                                  ;		  AL = 6: DL has driver # (1-A, 2-B, ... , 26 - Z)
 29942                                  ;		  AL = 7: DX has year, CL has month and CH has date
 29943                                  ;		  AL = 8: DL has hours, DH has minutes, CL has secondsn,
 29944                                  ;			  amd CH has hundredths
 29945                                  ;		  AL = else: psdata_seg:SI points to returned string buffer
 29946                                  ;	    ES:BX -> CONTROL block
 29947                                  ;
 29948                                  ; Output:   None
 29949                                  ;
 29950                                  ; Use:	$P_Do_CAPS_String, $P_Remove_Colon, $P_Found_SYNONYM
 29951                                  ;
 29952                                  ; Vars: $P_DX(W)
 29953                                  ;***********************************************************************
 29954                                  
 29955                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 29956                                  
 29957                                  $P_Fill_Result:
 29958 00004578 57                      	push	di			;AN000;
 29959 00004579 268B7F04                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Result_Buf]
 29960                                  	;mov	di,[es:bx+4]		;AN000; di points to result buffer
 29961 0000457D 2E893E[ED85]            	mov	[cs:$P_DX],di		;AC034; set returned result address
 29962                                  	;mov	[es:di+$P_RESULT_BLK.$P_Type],al
 29963                                  	;;mov	[es:di],al		;AN000; store type
 29964                                  	;mov	[es:di+$P_RESULT_BLK.$P_Item_Tag],ah
 29965                                  	;;mov	[es:di+1],ah		;AN000; store item tag
 29966                                  	; 31/03/2023
 29967 00004582 268905                  	mov	[es:di],ax
 29968 00004585 50                      	push	ax			;AN000;
 29969 00004586 2EA1[FC85]              	mov	ax,[cs:$P_Found_SYNONYM]
 29970                                  					;AC034; if yes,
 29971 0000458A 26894502                	mov	[es:di+$P_RESULT_BLK.$P_SYNONYM_Ptr],ax
 29972                                  	;mov	[es:di+2],ax		;AN000;   then set it to the result
 29973 0000458E 58                      	pop	ax			;AN000;
 29974                                  $P_RLT04:				;AN000;
 29975                                  	;cmp	al,1
 29976 0000458F 3C01                    	cmp	al,$P_Number		;AN000; if number
 29977 00004591 750A                    	jne	short $P_RLT00		;AN000;
 29978                                  $P_RLT02:				;AN000;
 29979 00004593 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 29980                                  	;mov	[es:di+4],dx		;AN000; then store 32bit
 29981 00004597 26894D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cx
 29982                                  	;mov	[es:di+6],cx		;AN000;	number
 29983 0000459B EB5A                    	jmp	short $P_RLT_Exit	;AN000;
 29984                                  $P_RLT00:				;AN000;
 29985                                  	;cmp	al,2
 29986 0000459D 3C02                    	cmp	al,$P_List_Idx		;AN000; if list index
 29987 0000459F 7506                    	jne	short $P_RLT01		;AN000;
 29988 000045A1 26895504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dx
 29989                                  	;mov	[es:di+4],dx		;AN000; then store list index
 29990 000045A5 EB50                    	jmp	short $P_RLT_Exit	;AN000;
 29991                                  $P_RLT01:				;AN000;
 29992                                  	;cmp	al,7
 29993 000045A7 3C07                    	cmp	al,$P_Date_F ; 7	;AN000; Date format ?
 29994 000045A9 74E8                    	je	short $P_RLT02		;AN000;
 29995                                  	;cmp	al,8
 29996 000045AB 3C08                    	cmp	al,$P_Time_F ; 8	;AN000; Time format ?
 29997 000045AD 74E4                    	je	short $P_RLT02		;AN000;
 29998                                  	;cmp	al,6
 29999 000045AF 3C06                    	cmp	al,$P_Drive  ; 6	;AN000; drive format ?
 30000 000045B1 7506                    	jne	short $P_RLT03		;AN000;
 30001                                  
 30002 000045B3 26885504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],dl
 30003                                  	;mov	[es:di+4],dl		;AN000; store drive number
 30004 000045B7 EB3E                    	jmp	short $P_RLT_Exit	;AN000;
 30005                                  
 30006                                  $P_RLT03:				;AN000;
 30007                                  	;cmp	al,4
 30008 000045B9 3C04                    	cmp	al,$P_Complex		;AN000; complex format ?
 30009 000045BB 750F                    	jne	short $P_RLT05		;AN000;
 30010                                  
 30011 000045BD 2EA1[F685]              	mov	ax,[cs:$P_SaveSI_Cmpx]	;AC034; then get pointer in command buffer
 30012 000045C1 40                      	inc	ax			;AN000; skip left Parentheses
 30013 000045C2 26894504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],ax
 30014                                  	;mov	[es:di+4],ax		;AN000; store offset
 30015 000045C6 268C5D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],ds
 30016                                  	;mov	[es:di+6],ds		;AN000; store segment
 30017 000045CA EB2B                    	jmp	short $P_RLT_Exit	;AN000;
 30018                                  
 30019                                  $P_RLT05:				;AN000;
 30020                                  ;------------------------  AL = 3, 5, or 9
 30021 000045CC 26897504                	mov	[es:di+$P_RESULT_BLK.$P_Picked_Val],si
 30022                                  	;mov	[es:di+4],si		;AN000; store offset of STRING_BUF
 30023 000045D0 268C4D06                	mov	[es:di+2+$P_RESULT_BLK.$P_Picked_Val],cs
 30024                                  	;mov	[es:di+6],cs		;AN031; store segment of STRING_BUF
 30025                                  
 30026 000045D4 50                      	push	ax			;AN000;
 30027 000045D5 26F6470201              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_File
 30028                                  	;test	byte [es:bx+2],1	;AN000; need CAPS by file table?
 30029 000045DA 7404                    	jz	short $P_RLT_CAP00	;AN000;
 30030                                  
 30031                                  	;mov	al,4
 30032 000045DC B004                    	mov	al,$P_DOSTBL_File ; 4	;AN000; use file upper case table
 30033 000045DE EB09                    	jmp	short $P_RLT_CAP02	;AN000;
 30034                                  
 30035                                  $P_RLT_CAP00:				;AN000;
 30036 000045E0 26F6470202              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_CAP_Char
 30037                                  	;test	byte [es:bx+2],2	;AN000; need CAPS by char table ?
 30038 000045E5 7405                    	jz	short $P_RLT_CAP01	;AN000;
 30039                                  
 30040                                  	;mov	al,2
 30041 000045E7 B002                    	mov	al,$P_DOSTBL_Char ; 2	;AN000; use character upper case table
 30042                                  $P_RLT_CAP02:				;AN000;
 30043 000045E9 E80C01                  	call	$P_Do_CAPS_String	;AN000;  process CAPS along the table
 30044                                  $P_RLT_CAP01:				;AN000;
 30045 000045EC 58                      	pop	ax			;AN000;
 30046 000045ED 26F6470210              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_Rm_Colon
 30047                                  	;test	byte [es:bx+2],10h	;AN000; removing colon at end ?
 30048 000045F2 7403                    	jz	short $P_RLT_Exit	;AN000;
 30049                                  
 30050 000045F4 E8DD00                  	call	$P_Remove_Colon 	;AN000; then process it.
 30051                                  $P_RLT_Exit:				;AN000;
 30052 000045F7 5F                      	pop	di			;AN000;
 30053 000045F8 C3                      	retn				;AN000;
 30054                                  
 30055                                  ;***********************************************************************
 30056                                  ; $P_Check_Match_Flags
 30057                                  ;
 30058                                  ; Function:  Check the mutch_flags and make the exit code and set the
 30059                                  ;	     result buffer
 30060                                  ;
 30061                                  ;	    Check for types in this order:
 30062                                  ;		Complex
 30063                                  ;		Date
 30064                                  ;		Time
 30065                                  ;		Drive
 30066                                  ;		Filespec
 30067                                  ;		Quoted String
 30068                                  ;		Simple String
 30069                                  ;
 30070                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30071                                  ;	     ES:BX -> CONTROL block
 30072                                  ;
 30073                                  ; Output:    None
 30074                                  ;
 30075                                  ; Use:	     $P_Value, P$_SValue, $P_Simple_String, $P_Date_Format
 30076                                  ;	     $P_Time_Format, $P_Complex_Format, $P_File_Foemat
 30077                                  ;	     $P_Drive_Format
 30078                                  ;***********************************************************************
 30079                                  
 30080                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30081                                  
 30082                                  $P_Check_Match_Flags:
 30083 000045F9 2EC606[C286]00          	mov	byte [cs:$P_err_flag],$P_NULL ; 0
 30084                                  					;AN033;AC034;; clear filespec error flag.
 30085 000045FF 50                      	push	ax			;AN000;
 30086                                  	;mov	ax,[es:bx+$P_CONTROL_BLK.$P_Match_Flag]
 30087 00004600 268B07                  	mov	ax,[es:bx]		;AN000; load match flag(16bit) to ax
 30088 00004603 09C0                    	or	ax,ax			;AC035; test ax for zero
 30089 00004605 7518                    	jnz	short $P_Mat		;AN000; (tm12)
 30090 00004607 50                      	push	ax			;AN000; (tm12)
 30091 00004608 53                      	push	bx			;AN000; (tm12)
 30092 00004609 52                      	push	dx			;AN000; (tm12)
 30093 0000460A 57                      	push	di			;AN000; (tm12)
 30094 0000460B 2EC706[E985]0900        	mov	word [cs:$P_RC],$P_Syntax
 30095                                  	;mov	word [cs:$P_RC],9	;AC034; (tm12)
 30096                                  	; 31/03/2023
 30097 00004612 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30098                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; (tm12)
 30099                                  	;mov	al,$P_String ; 3	;AN000; (tm12)
 30100 00004615 E860FF                  	call	$P_Fill_Result		;AN000; (tm12)
 30101 00004618 5F                      	pop	di			;AN000; (tm12)
 30102 00004619 5A                      	pop	dx			;AN000; (tm12)
 30103 0000461A 5B                      	pop	bx			;AN000; (tm12)
 30104 0000461B 58                      	pop	ax			;AN000; (tm12)
 30105                                  	;jmp	short $P_Bridge 	;AC035; (tm12)
 30106                                  	; 31/03/2023
 30107                                  $P_Bridge:	; 18/04/2023		;AN000;
 30108 0000461C E99C00                  	jmp	$P_Match_Exit		;AN000; (tm02)
 30109                                  $P_Mat: 				;AN000; (tm12)
 30110                                  $P_Match01:				;AN000;
 30111                                  	;test	ax,1000h
 30112 0000461F A90010                  	test	ax,$P_Date_S		;AN000; Date string
 30113 00004622 7412                    	jz	short $P_Match02	;AN000;
 30114 00004624 2EC706[E985]0000        	mov	word [cs:$P_RC],$P_No_Error
 30115                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30116 0000462B E86503                  	call	$P_Date_Format		;AN000; do process
 30117 0000462E 2E833E[E985]09          	cmp	word [cs:$P_RC],$P_Syntax
 30118                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30119                                  	; 18/04/2023
 30120 00004634 75E6                    	jne	short $P_Bridge		;AN000;
 30121                                  $P_Match02:				;AN000;
 30122                                  	;test	ax,800h
 30123 00004636 A90008                  	test	ax,$P_Time_S		;AN000; Time string
 30124 00004639 7412                    	jz	short $P_Match03	;AN000;
 30125 0000463B 2EC706[E985]0000        	mov	word [cs:$P_RC],$P_No_Error
 30126                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30127 00004642 E86004                  	call	$P_Time_Format		;AN000; do process
 30128 00004645 2E833E[E985]09          	cmp	word [cs:$P_RC],$P_Syntax
 30129                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30130                                  	;jne	short $P_Bridge		;AN000; (tm09)
 30131                                  	;jmp	short $P_Match03	;AN025; (tm09)
 30132                                  	; 31/03/2023
 30133 0000464B 756E                    	jne	short $P_Match_Exit
 30134                                  ;$P_Bridge:				;AN000;
 30135                                  	;jmp	short $P_Match_Exit	;AN000; (tm02)
 30136                                  $P_Match03:				;AN000;
 30137                                  	;test	ax,8000h
 30138 0000464D A90080                  	test	ax,$P_Num_Val		;AN000; Numeric value
 30139 00004650 7412                    	jz	short $P_Match04	;AN000;
 30140 00004652 2EC706[E985]0000        	mov	word [cs:$P_RC],$P_No_Error
 30141                                  	;mov	word [cs:$P_RC],0	;AC034; assume no error
 30142 00004659 E82C01                  	call	$P_Value		;AN000; do process
 30143 0000465C 2E833E[E985]09          	cmp	word [cs:$P_RC],$P_Syntax
 30144                                  	;cmp	word [cs:$P_RC],9	;AC034; if error, examine the next type
 30145 00004662 7557                    	jne	short $P_Match_Exit	;AN000;
 30146                                  $P_Match04:				;AN000;
 30147                                  	;test	ax,4000h
 30148 00004664 A90040                  	test	ax,$P_SNum_Val		;AN000; Signed numeric value
 30149 00004667 7412                    	jz	short $P_Match05	;AN000;
 30150 00004669 2EC706[E985]0000        	mov	word [cs:$P_RC],$P_No_Error
 30151                                  					;AC034; assume no error
 30152 00004670 E8F100                  	call	$P_SValue		;AN000; do process
 30153 00004673 2E833E[E985]09          	cmp	word [cs:$P_RC],$P_Syntax
 30154                                  					;AC034; if error, examine the next type
 30155 00004679 7540                    	jne	short $P_Match_Exit	;AN000;
 30156                                  $P_Match05:				;AN000;
 30157                                  	;test	ax,100h
 30158 0000467B A90001                  	test	ax,$P_Drv_Only		;AN000; Drive only
 30159 0000467E 7415                    	jz	short $P_Match06	;AN000;
 30160 00004680 2EC706[E985]0000        	mov	word [cs:$P_RC],$P_No_Error
 30161                                  					;AC034; assume no error
 30162 00004687 E86805                  	call	$P_File_Format		;AN000; 1st, call file format
 30163 0000468A E8E905                  	call	$P_Drive_Format 	;AN000; check drive format, next
 30164 0000468D 2E833E[E985]09          	cmp	word [cs:$P_RC],$P_Syntax
 30165                                  					;AC034; if error, examinee the next type
 30166 00004693 7526                    	jne	short $P_Match_Exit	;AN000;
 30167                                  $P_Match06:				;AN000;
 30168                                  	;test	ax,200h
 30169 00004695 A90002                  	test	ax,$P_File_Spc		;AN000; File spec
 30170 00004698 7412                    	jz	short $P_Match07	;AN000;
 30171 0000469A 2EC706[E985]0000        	mov	word [cs:$P_RC],$P_No_Error
 30172                                  					;AC034; assume no error
 30173 000046A1 E84E05                  	call	$P_File_Format		;AN000; do process
 30174 000046A4 2E833E[E985]09          	cmp	word [cs:$P_RC],$P_Syntax
 30175                                  					;AC034; if error, examine the next type
 30176 000046AA 750F                    	jne	short $P_Match_Exit	;AN000;
 30177                                  $P_Match07:				;AN000;
 30178                                  $P_Match08:				;AN000;
 30179                                  	;test	ax,2000h
 30180 000046AC A90020                  	test	ax,$P_Simple_S		;AN000; Simple string
 30181 000046AF 740A                    	jz	short $P_Match09	;AN000;
 30182 000046B1 2EC706[E985]0000        	mov	word [cs:$P_RC],$P_No_Error
 30183                                  					;AC034; assume no error
 30184 000046B8 E8D601                  	call	$P_Simple_String	;AN000; do process
 30185                                  $P_Match09:				;AN000;
 30186                                  $P_Match_Exit:				;AN000;
 30187 000046BB 2E833E[C286]01          	cmp	word [cs:$P_err_flag],$P_error_filespec
 30188                                  	;cmp	word [cs:$P_err_flag],1 ;AC034; bad filespec ?
 30189 000046C1 750F                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30190 000046C3 2E833E[E985]00          	cmp	word [cs:$P_RC],$P_No_Error
 30191                                  	;cmp	word [cs:$P_RC],0	;AN033;AC034;; check for other errors ?
 30192 000046C9 7507                    	jne	short $P_Match2_Exit	;AN033; no, continue
 30193 000046CB 2EC706[E985]0900        	mov	word [cs:$P_RC],$P_Syntax
 30194                                  	;mov	word [cs:$P_RC],9	;AN033;AC034;; set error flag
 30195                                  $P_Match2_Exit: 			;AN033;
 30196 000046D2 58                      	pop	ax			;AN000;
 30197 000046D3 C3                      	retn
 30198                                  
 30199                                  ;***********************************************************************
 30200                                  ; $P_Remove_Colon;
 30201                                  ;
 30202                                  ; Function: Remove colon at end
 30203                                  ;
 30204                                  ; Input:    psdata_seg:SI points to string buffer to be examineed
 30205                                  ;
 30206                                  ; Output:   None
 30207                                  ;
 30208                                  ; Use:	$P_Chk_DBCS
 30209                                  ;***********************************************************************
 30210                                  
 30211                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30212                                  
 30213                                  $P_Remove_Colon:
 30214 000046D4 50                      	push	ax			;AN000;
 30215 000046D5 56                      	push	si			;AN000;
 30216                                  $P_RCOL_Loop:				;AN000;
 30217 000046D6 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30218 000046D9 08C0                    	or	al,al			;AN000; end of string ?
 30219 000046DB 740F                    	jz	short $P_RCOL_Exit	;AN000; if yes, just exit
 30220                                  
 30221 000046DD 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; is it colon ?
 30222 000046DF 750E                    	jne	short $P_RCOL00		;AN000;
 30223                                  
 30224                                  	;cmp	byte [cs:si+1],0
 30225 000046E1 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; if so, next is NULL ?
 30226 000046E6 7507                    	jne	short $P_RCOL00		;AN000; no, then next char
 30227                                  
 30228 000046E8 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; yes, remove colon
 30229                                  	; 31/03/2023
 30230                                  	;jmp	short $P_RCOL_Exit	;AN000; and exit.
 30231                                  $P_RCOL_Exit:
 30232 000046EC 5E                      	pop	si
 30233 000046ED 58                      	pop	ax
 30234 000046EE C3                      	retn
 30235                                  
 30236                                  $P_RCOL00:				;AN000;
 30237 000046EF E8A606                  	call	$P_Chk_DBCS		;AN000; if not colon, then check if
 30238 000046F2 7301                    	jnc	short $P_RCOL01		;AN000; DBCS leading byte.
 30239                                  
 30240 000046F4 46                      	inc	si			;AN000; if yes, skip trailing byte
 30241                                  $P_RCOL01:				;AN000;
 30242 000046F5 46                      	inc	si			;AN000; si points to next byte
 30243 000046F6 EBDE                    	jmp	short $P_RCOL_Loop	;AN000; loop until NULL encountered
 30244                                  
 30245                                  	; 31/03/2023
 30246                                  ;$P_RCOL_Exit:				;AN000;
 30247                                  	;pop	si			;AN000;
 30248                                  	;pop	ax			;AN000;
 30249                                  	;retn
 30250                                  
 30251                                  ;***********************************************************************
 30252                                  ; $P_Do_CAPS_String;
 30253                                  ;
 30254                                  ; Function: Perform capitalization along with the file case map table
 30255                                  ;	    or character case map table.
 30256                                  ;
 30257                                  ; Input:    AL = 2 : Use character table
 30258                                  ;	    AL = 4 : Use file table
 30259                                  ;	    psdata_seg:SI points to string buffer to be capitalized
 30260                                  ;
 30261                                  ; Output:   None
 30262                                  ;
 30263                                  ; Use:	$P_Do_CAPS_Char, $P_Chk_DBCS
 30264                                  ;***********************************************************************
 30265                                  
 30266                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30267                                  
 30268                                  $P_Do_CAPS_String:
 30269 000046F8 56                      	push	si			;AN000;
 30270 000046F9 52                      	push	dx			;AN000;
 30271 000046FA 88C2                    	mov	dl,al			;AN000; save info id
 30272                                  $P_DCS_Loop:				;AN000;
 30273 000046FC 2E8A04                  	mov	al,[cs:si]		;AN000; load character and
 30274 000046FF E89606                  	call	$P_Chk_DBCS		;AN000; check if DBCS leading byte
 30275 00004702 720C                    	jc	short $P_DCS00		;AN000; if yes, do not need CAPS
 30276                                  
 30277 00004704 08C0                    	or	al,al			;AN000; end of string ?
 30278 00004706 740C                    	jz	short $P_DCS_Exit	;AN000; then exit.
 30279                                  
 30280 00004708 E80C00                  	call	$P_Do_CAPS_Char 	;AN000; Here a SBCS char need to be CAPS
 30281 0000470B 2E8804                  	mov	[cs:si],al		;AN000; stored upper case char to buffer
 30282 0000470E EB01                    	jmp	short $P_DCS01		;AN000; process nexit
 30283                                  $P_DCS00:				;AN000;
 30284 00004710 46                      	inc	si			;AN000; skip DBCS leading and trailing byte
 30285                                  $P_DCS01:				;AN000;
 30286 00004711 46                      	inc	si			;AN000; si point to next byte
 30287 00004712 EBE8                    	jmp	short $P_DCS_Loop	;AN000; loop until NULL encountered
 30288                                  $P_DCS_Exit:				;AN000;
 30289 00004714 5A                      	pop	dx			;AN000;
 30290 00004715 5E                      	pop	si			;AN000;
 30291 00004716 C3                      	retn
 30292                                  
 30293                                  ;***********************************************************************
 30294                                  ; $P_Do_CAPS_Char;
 30295                                  ;
 30296                                  ; Function: Perform capitalization along with the file case map table
 30297                                  ;	    or character case map table.
 30298                                  ;
 30299                                  ; Input:    DL = 2 : Use character table
 30300                                  ;	    DL = 4 : Use file table
 30301                                  ;	    AL = character to be capitalized
 30302                                  ;
 30303                                  ; Output:   None
 30304                                  ;
 30305                                  ; Use:	INT 21h /w AH=65h
 30306                                  ;***********************************************************************
 30307                                  
 30308                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30309                                  
 30310                                  $P_Do_CAPS_Char:
 30311 00004717 3C80                    	cmp	al,$P_ASCII80	; 80h	;AN000; need upper case table ?
 30312 00004719 730B                    	jae	short $P_DCC_Go		;AN000;
 30313                                  
 30314 0000471B 3C61                    	cmp	al,"a"  ; 61h		;AN000; if no,
 30315 0000471D 7244                    	jb	short $P_CAPS_Ret	;AN000;   check if  "a" <= AL <= "z"
 30316                                  
 30317 0000471F 3C7A                    	cmp	al,"z"  ; 7Ah		;AN000;
 30318 00004721 7740                    	ja	short $P_CAPS_Ret	;AN000;   if yes, make CAPS
 30319                                  
 30320 00004723 24DF                    	and	al,$P_Make_Upper ; 0DFh	;AN000;   else do nothing.
 30321                                  	;jmp	short $P_CAPS_Ret	;AN000;
 30322                                  	; 18/04/2023
 30323 00004725 C3                      	retn
 30324                                  
 30325                                  $P_DCC_Go:				;AN000;
 30326 00004726 53                      	push	bx			;AN000;
 30327 00004727 06                      	push	es			;AN000;
 30328 00004728 57                      	push	di			;AN000;
 30329                                  	; 18/04/2023
 30330 00004729 8D3E[B486]              	lea	di,$P_File_CAP_Ptr	;AC034;
 30331 0000472D 80FA04                  	cmp	dl,$P_DOSTBL_File ; 4	;AN000; Use file CAPS table ?
 30332 00004730 7404                    	je	short $P_DCC00		;AN000;
 30333                                  	; 27/04/2023
 30334 00004732 8D3E[AF86]              	lea	di,[$P_Char_CAP_Ptr]	;AC034; or use char CAPS table ?
 30335                                  $P_DCC00:				;AN000;
 30336 00004736 2E3815                  	cmp	[cs:di],dl		;AN000; already got table address ?
 30337 00004739 7417                    	je	short $P_DCC01		;AN000; if no,
 30338                                  
 30339                                  ;In this next section, ES will be used to pass a 5 byte workarea to INT 21h,
 30340                                  ; the GET COUNTYRY INFO call. This usage of ES is required by the function
 30341                                  ; call, regardless of what base register is currently be defined as PSDATA_SEG.
 30342                                  
 30343 0000473B 50                      	push	ax			;AN000; get CAPS table thru DOS call
 30344 0000473C 51                      	push	cx			;AN000;
 30345 0000473D 52                      	push	dx			;AN000;
 30346 0000473E 0E                      	push	cs			;AC036; pass current base seg into
 30347                                  					;(Note: this used to push CS. BUG...
 30348 0000473F 07                      	pop	es			;AN000;   ES reg, required for
 30349                                  					;get extended country information
 30350                                  	; 31/03/2023
 30351 00004740 B465                    	mov	ah,$P_DOS_Get_TBL ; 65h	;AN000; get extended CDI
 30352                                  	;mov	ah,65h
 30353 00004742 88D0                    	mov	al,dl			;AN000; upper case table
 30354                                  	;mov	bx,-1 ; 0FFFFh
 30355                                  	;mov	cx,5
 30356                                  	;mov	dx,-1
 30357 00004744 BBFFFF                  	mov	bx,$P_DOSTBL_Def ; -1	;AN000; get active CON
 30358 00004747 B90500                  	mov	cx,$P_DOSTBL_BL  ; 5 	;AN000; buffer length
 30359 0000474A BAFFFF                  	mov	dx,$P_DOSTBL_Def ; -1	;AN000; get for default code page
 30360                                  					;DI already set to point to buffer
 30361 0000474D CD21                    	int	21h			;AN000; es:di point to buffer that
 30362                                  					;now has been filled in with info
 30363 0000474F 5A                      	pop	dx			;AN000;
 30364 00004750 59                      	pop	cx			;AN000;
 30365 00004751 58                      	pop	ax			;AN000;
 30366                                  
 30367                                  $P_DCC01:				;AN000;
 30368                                  
 30369                                  ;In this next section, ES will be used as the base of the XLAT table, provided
 30370                                  ; by the previous GET COUNTRY INFO DOS call. This usage of ES is made
 30371                                  ; regardless of which base reg is currently the PSDATA_SEG reg.
 30372                                  
 30373 00004752 2E8B5D01                	mov	bx,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Off]
 30374                                  	;mov	bx,[cs:di+1]		;AN000; get offset of table
 30375 00004756 2E8E4503                	mov	es,[cs:di+$P_DOS_TBL.$P_DOS_TBL_Seg]
 30376                                  	;mov	es,[cs:di+3]		;AN000; get segment of table
 30377 0000475A 43                      	inc	bx			;AC035; add '2' to
 30378 0000475B 43                      	inc	bx			;AC035;  BX reg
 30379                                  					;AN000; skip length field
 30380 0000475C 2C80                    	sub	al,$P_ASCII80 ; 80h	;AN000; make char to index
 30381                                  	;xlat	es:[bx] 		;AN000; perform case map
 30382                                  	; 31/03/2023
 30383 0000475E 26D7                    	es	xlat
 30384                                  
 30385 00004760 5F                      	pop	di			;AN000;
 30386 00004761 07                      	pop	es			;AN000;
 30387 00004762 5B                      	pop	bx			;AN000;
 30388                                  $P_CAPS_Ret:				;AN000;
 30389 00004763 C3                      	retn
 30390                                  
 30391                                  ;***********************************************************************
 30392                                  ; $P_Value / $P_SValue
 30393                                  ;
 30394                                  ; Function:  Make 32bit value from psdata_seg:SI and see value list
 30395                                  ;	     and make result buffer.
 30396                                  ;	     $P_SValue is an entry point for the signed value
 30397                                  ;	     and this will simply call $P_Value after the handling
 30398                                  ;	     of the sign character, "+" or "-"
 30399                                  ;
 30400                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30401                                  ;	     ES:BX -> CONTROL block
 30402                                  ;
 30403                                  ; Output:    None
 30404                                  ;
 30405                                  ; Use:	$P_Fill_Result, $P_Check_OVF
 30406                                  ;
 30407                                  ; Vars: $P_RC(W), $P_Flags(RW)
 30408                                  ;***********************************************************************
 30409                                  
 30410                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30411                                  $P_SValue:
 30412 00004764 50                      	push	ax			;AN000;
 30413                                  	;or	byte [cs:$P_Flags2],80h
 30414 00004765 2E800E[F585]80          	or	byte [cs:$P_Flags2],$P_Signed
 30415                                  					;AC034; indicate a signed numeric
 30416                                  	;and	byte [cs:$P_Flags2],0FDh
 30417 0000476B 2E8026[F585]FD          	and	byte [cs:$P_Flags2],0FFh-$P_Neg
 30418                                  					;AC034; assume positive value
 30419 00004771 2E8A04                  	mov	al,[cs:si]		;AN000; get sign
 30420 00004774 3C2B                    	cmp	al,'+' ; 2Bh
 30421                                  	;cmp	al,$P_Plus ; '+'	;AN000; "+" ?
 30422 00004776 740A                    	je	short $P_SVal00		;AN000;
 30423                                  
 30424 00004778 3C2D                    	cmp	al,'-' ; 2Dh
 30425                                  	;cmp	al,$P_Minus ; '-'	;AN000; "-" ?
 30426 0000477A 7507                    	jne	short $P_Sval01		;AN000; else
 30427                                  
 30428 0000477C 2E800E[F585]02          	or	byte [cs:$P_Flags2],$P_Neg ; 2
 30429                                  					;AC034; set this is negative value
 30430                                  $P_SVal00:				;AN000;
 30431 00004782 46                      	inc	si			;AN000; skip sign char
 30432                                  $P_Sval01:				;AN000;
 30433 00004783 E80200                  	call	$P_Value		;AN000; and process value
 30434 00004786 58                      	pop	ax			;AN000;
 30435 00004787 C3                      	retn				;AN000;
 30436                                  
 30437                                  ;***********************************************************************
 30438                                  
 30439                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30440                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4955h
 30441                                  
 30442                                  $P_Value:
 30443 00004788 50                      	push	ax			;AN000;
 30444 00004789 51                      	push	cx			;AN000;
 30445 0000478A 52                      	push	dx			;AN000;
 30446 0000478B 56                      	push	si			;AN000;
 30447 0000478C 31C9                    	xor	cx,cx			;AN000; cx = higher 16 bits
 30448 0000478E 31D2                    	xor	dx,dx			;AN000; dx = lower 16 bits
 30449 00004790 53                      	push	bx			;AN000; save control pointer
 30450                                  $P_Value_Loop:				;AN000;
 30451 00004791 2E8A04                  	mov	al,[cs:si]		;AN000; get character
 30452 00004794 08C0                    	or	al,al			;AN000; end of line ?
 30453 00004796 7442                    	jz	short $P_Value00	;AN000;
 30454                                  
 30455 00004798 E8EB00                  	call	$P_0099 		;AN000; make asc(0..9) to bin(0..9)
 30456 0000479B 7239                    	jc	short $P_Value_Err0	;AN000;
 30457                                  
 30458 0000479D 30E4                    	xor	ah,ah			;AN000;
 30459 0000479F 89C5                    	mov	bp,ax			;AN000; save binary number
 30460 000047A1 D1E2                    	shl	dx,1			;AN000; to have 2*x
 30461 000047A3 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30462 000047A5 E8CC00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30463 000047A8 722C                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30464                                  
 30465 000047AA 89D3                    	mov	bx,dx			;AN000; save low(2*x)
 30466 000047AC 89C8                    	mov	ax,cx			;AN000; save high(2*x)
 30467 000047AE D1E2                    	shl	dx,1			;AN000; to have 4*x
 30468 000047B0 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30469 000047B2 E8BF00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30470 000047B5 721F                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30471                                  
 30472 000047B7 D1E2                    	shl	dx,1			;AN000; to have 8*x
 30473 000047B9 D1D1                    	rcl	cx,1			;AN000; shift left w/ carry
 30474 000047BB E8B600                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30475 000047BE 7216                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30476                                  
 30477 000047C0 01DA                    	add	dx,bx			;AN000; now have 10*x
 30478 000047C2 11C1                    	adc	cx,ax			;AN000; 32bit ADD
 30479 000047C4 E8AD00                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30480 000047C7 720D                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30481                                  
 30482 000047C9 01EA                    	add	dx,bp			;AN000; Add the current one degree decimal
 30483 000047CB 83D100                  	adc	cx,0			;AN000; if carry, add 1 to high 16bit
 30484 000047CE E8A300                  	call	$P_Check_OVF		;AN000; Overflow occurred ?
 30485 000047D1 7203                    	jc	short $P_Value_Err0	;AN000; then error, exit
 30486                                  
 30487 000047D3 46                      	inc	si			;AN000; update pointer
 30488 000047D4 EBBB                    	jmp	short $P_Value_Loop	;AN000; loop until NULL encountered
 30489                                  
 30490                                  $P_Value_Err0:				;AN000;
 30491 000047D6 5B                      	pop	bx			;AN000;
 30492 000047D7 E98800                  	jmp	$P_Value_Err		;AN000; Bridge
 30493                                  
 30494                                  $P_Value00:				;AN000;
 30495 000047DA 5B                      	pop	bx			;AN000; restore control pointer
 30496 000047DB 2EF606[F585]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2 
 30497                                  					;AC034; here cx,dx = 32bit value
 30498 000047E1 740A                    	jz	short $P_Value01	;AN000; was it negative ?
 30499                                  
 30500 000047E3 F7D1                    	not	cx			;AN000; +
 30501 000047E5 F7D2                    	not	dx			;AN000; |- Make 2's complement
 30502 000047E7 83C201                  	add	dx,1			;AN000; |
 30503 000047EA 83D100                  	adc	cx,0			;AN000; +
 30504                                  $P_Value01:				;AN000; / nval =0
 30505 000047ED 268B7706                	mov	si,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30506                                  	;mov	si,[es:bx+6]		;AN000; si points to value list
 30507 000047F1 268A04                  	mov	al,[es:si]		;AN000; get nval
 30508 000047F4 3C00                    	cmp	al,$P_nval_None ; 0	;AN000; no value list ?
 30509 000047F6 7505                    	jne	short $P_Value02	;AN000;
 30510                                  
 30511                                  	;mov	al,$P_Number	; 1	;AN000; Set type
 30512                                  	;mov	ah,$P_No_Tag	; 0FFh	;AN000; No ITEM_TAG set
 30513                                  	; 31/03/2023
 30514 000047F8 B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30515 000047FB EB6F                    	jmp	short $P_Value_Exit	;AN000;
 30516                                  
 30517                                  $P_Value02:				;AN000; / nval = 1
 30518 000047FD 46                      	inc	si			;AN000;
 30519 000047FE 268A04                  	mov	al,[es:si]		;AN000; al = number of range
 30520 00004801 3C00                    	cmp	al,$P_No_nrng	; 0	;AN000; (tm07)
 30521 00004803 745D                    	je	short $P_Value03	;AN000; (tm07)
 30522                                  
 30523 00004805 46                      	inc	si			;AN000; si points to 1st item_tag
 30524                                  $P_Val02_Loop:				;AN000;
 30525 00004806 2EF606[F585]80          	test	byte [cs:$P_Flags2],$P_Signed ; 80h
 30526                                  	;test	byte [cs:$P_Flags2],80h	;AC034;
 30527 0000480C 751E                    	jnz	short $P_Val02_Sign	;AN000;
 30528                                  
 30529 0000480E 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30530                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30531 00004812 723B                    	jb	short $P_Val02_Next	;AN000;
 30532 00004814 7706                    	ja	short $P_Val_In		;AN000;
 30533                                  
 30534 00004816 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30535                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30536 0000481A 7233                    	jb	short $P_Val02_Next	;AN000;
 30537                                  
 30538                                  $P_Val_In:				;AN000;
 30539 0000481C 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30540                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH (tm01)
 30541 00004820 772D                    	ja	short $P_Val02_Next	;AN000;
 30542 00004822 7224                    	jb	short $P_Val_Found	;AN000;
 30543                                  
 30544 00004824 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30545                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30546 00004828 7725                    	ja	short $P_Val02_Next	;AN000;
 30547                                  
 30548 0000482A EB1C                    	jmp	short $P_Val_Found	;AN000;
 30549                                  
 30550                                  $P_Val02_Sign:				;AN000;
 30551 0000482C 263B4C03                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_XH]
 30552                                  	;cmp	cx,[es:si+3]		;AN000; comp cx with XH
 30553 00004830 7C1D                    	jl	short $P_Val02_Next	;AN000;
 30554 00004832 7F06                    	jg	short $P_SVal_In	;AN000;
 30555                                  
 30556 00004834 263B5401                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_XL]
 30557                                  	;cmp	dx,[es:si+1]		;AN000; comp dx with XL
 30558 00004838 7C15                    	jl	short $P_Val02_Next	;AN000;
 30559                                  
 30560                                  $P_SVal_In:				;AN000;
 30561 0000483A 263B4C07                	cmp	cx,[es:si+$P_VAL_LIST.$P_Val_YH]
 30562                                  	;cmp	cx,[es:si+7]		;AN000; comp cx with YH
 30563 0000483E 7F0F                    	jg	short $P_Val02_Next	;AN000;
 30564 00004840 7C06                    	jl	short $P_Val_Found	;AN000;
 30565                                  
 30566 00004842 263B5405                	cmp	dx,[es:si+$P_VAL_LIST.$P_Val_YL]
 30567                                  	;cmp	dx,[es:si+5]		;AN000; comp dx with YL
 30568 00004846 7F07                    	jg	short $P_Val02_Next	;AN000;
 30569                                  
 30570                                  	;jmp	short $P_Val_Found	;AN000;
 30571                                  	; 27/04/2023
 30572                                  $P_Val_Found:				;AN000;
 30573 00004848 B001                    	mov	al,$P_Number ; 1	;AN000;
 30574 0000484A 268A24                  	mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30575 0000484D EB1D                    	jmp	short $P_Value_Exit	;AN000;
 30576                                  
 30577                                  $P_Val02_Next:				;AN000;
 30578 0000484F 83C609                  	add	si,$P_Len_Range ; 9 	;AN000;
 30579 00004852 FEC8                    	dec	al			;AN000; loop nrng times in AL
 30580 00004854 75B0                    	jnz	short $P_Val02_Loop	;AN000;
 30581                                  					; / Not found
 30582 00004856 2EC706[E985]0600        	mov	word [cs:$P_RC],$P_Out_Of_Range
 30583                                  	;mov	word [cs:$P_RC],6	;AC034;
 30584                                  	
 30585                                  	;mov	al,$P_Number ; 1	;AN000;
 30586                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30587                                  	; 31/03/2023
 30588 0000485D B801FF                  	mov	ax,($P_No_Tag<<8)+$P_Number
 30589 00004860 EB0A                    	jmp	short $P_Value_Exit	;AN000;
 30590                                  
 30591                                  	; 27/04/2023
 30592                                  ;$P_Val_Found:				;AN000;
 30593                                  	;mov	al,$P_Number ; 1	;AN000;
 30594                                  	;mov	ah,[es:si]		;AN000; found ITEM_TAG set
 30595                                  	;jmp	short $P_Value_Exit	;AN000;
 30596                                  
 30597                                  $P_Value03:				;AN000; / nval = 2
 30598                                  $P_Value04:				;AN000; / nval = 3 or else
 30599                                  $P_Value_Err:				;AN000;
 30600 00004862 2EC706[E985]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 30601                                  					;AC034;
 30602                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30603                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30604                                  	; 31/03/2023
 30605 00004869 B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30606                                  $P_Value_Exit:				;AN000;
 30607 0000486C E809FD                  	call	$P_Fill_Result		;AN000;
 30608 0000486F 5E                      	pop	si			;AN000;
 30609 00004870 5A                      	pop	dx			;AN000;
 30610 00004871 59                      	pop	cx			;AN000;
 30611 00004872 58                      	pop	ax			;AN000;
 30612 00004873 C3                      	retn				;AN000;
 30613                                  
 30614                                  ;***********************************************************************
 30615                                  ; $P_Check_OVF
 30616                                  ;
 30617                                  ; Function:  Check if overflow is occurred with consideration of
 30618                                  ;	     signed or un-signed numeric value
 30619                                  ;
 30620                                  ; Input:     Flag register
 30621                                  ;
 30622                                  ; Output:    CY = 1  :	Overflow
 30623                                  ;
 30624                                  ; Vars:     $P_Flags(R)
 30625                                  ;***********************************************************************
 30626                                  
 30627                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30628                                  $P_Check_OVF:
 30629 00004874 9C                      	pushf				;AN000;
 30630 00004875 2EF606[F585]02          	test	byte [cs:$P_Flags2],$P_Neg ; 2
 30631                                  					;AC034; is it negative value ?
 30632 0000487B 7502                    	jnz	short $P_COVF		;AN000; if no, check overflow
 30633 0000487D 9D                      	popf				;AN000; by the CY bit
 30634 0000487E C3                      	retn				;AN000;
 30635                                  $P_COVF:				;AN000;
 30636 0000487F 9D                      	popf				;AN000; else,
 30637 00004880 7002                    	jo	short $P_COVF00		;AN000; check overflow by the OF
 30638 00004882 F8                      	clc				;AN000; indicate it with CY bit
 30639 00004883 C3                      	retn				;AN000; CY=0 means no overflow
 30640                                  $P_0099Err:	; 31/03/2023
 30641                                  $P_COVF00:				;AN000;
 30642 00004884 F9                      	stc				;AN000; and CY=1 means overflow
 30643                                  $P_0099Err2:	; 31/03/2023
 30644 00004885 C3                      	retn				;AN000;
 30645                                  
 30646                                  ;***********************************************************************
 30647                                  ; $P_0099;
 30648                                  ;
 30649                                  ; Function:  Make ASCII 0-9 to Binary 0-9
 30650                                  ;
 30651                                  ; Input:     AL = character code
 30652                                  ;
 30653                                  ; Output:    CY = 1 : AL is not number
 30654                                  ;	     CY = 0 : AL contains binary value
 30655                                  ;***********************************************************************
 30656                                  
 30657                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30658                                  $P_0099:
 30659 00004886 3C30                    	cmp	al,"0"                  ;AN000;
 30660                                  	;jb	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30661                                  	; 31/03/2023
 30662 00004888 72FB                    	jb	short $P_0099Err2
 30663                                  
 30664 0000488A 3C39                    	cmp	al,"9"                  ;AN000;
 30665 0000488C 77F6                    	ja	short $P_0099Err	;AN000;  must be 0 =< al =< 9
 30666                                  
 30667 0000488E 2C30                    	sub	al,"0"                  ;AN000; make char -> bin
 30668                                  	; 31/03/2023
 30669                                  	;clc				;AN000; indicate no error
 30670 00004890 C3                      	retn				;AN000;
 30671                                  	 ;31/03/2023
 30672                                  ;$P_0099Err:				;AN000;
 30673                                  ;	stc				;AN000; indicate error
 30674                                  ;	retn				;AN000;
 30675                                  
 30676                                  ;***********************************************************************
 30677                                  ; $P_Simple_String
 30678                                  ;
 30679                                  ; Function:  See value list for the simple string
 30680                                  ;	     and make result buffer.
 30681                                  ;
 30682                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30683                                  ;	     ES:BX -> CONTROL block
 30684                                  ;
 30685                                  ; Output:    None
 30686                                  ;
 30687                                  ; Use:	$P_Fill_Result, $P_String_Comp
 30688                                  ;
 30689                                  ; Vars: $P_RC(W)
 30690                                  ;***********************************************************************
 30691                                  
 30692                                  	; 31/03/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30693                                  
 30694                                  $P_Simple_String:
 30695 00004891 50                      	push	ax			;AN000;
 30696 00004892 53                      	push	bx			;AN000;
 30697 00004893 52                      	push	dx			;AN000;
 30698 00004894 57                      	push	di			;AN000;
 30699 00004895 268B7F06                	mov	di,[es:bx+$P_CONTROL_BLK.$P_Value_List]
 30700                                  	;mov	di,[es:bx+6]		;AN000; di points to value list
 30701 00004899 268A05                  	mov	al,[es:di]		;AN000; get nval
 30702 0000489C 08C0                    	or	al,al			;AN000; no value list ?
 30703 0000489E 7502                    	jnz	short $P_Sim00		;AN000; then
 30704                                  	; 31/03/2023
 30705                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30706 000048A0 EB48                    	jmp	short $P_Sim_Exit	;AN000; and set result buffer
 30707                                  $P_Sim00:				;AN000;
 30708 000048A2 3C03                    	cmp	al,$P_nval_String ; 3	;AN000; String choice list provided ?
 30709 000048A4 753D                    	jne	short $P_Sim01		;AN000; if no, syntax error
 30710                                  
 30711 000048A6 47                      	inc	di			;AN000;
 30712 000048A7 268A05                  	mov	al,[es:di]		;AN000; al = nrng
 30713 000048AA B409                    	mov	ah,$P_Len_Range ; 9	;AN000;
 30714 000048AC F6E4                    	mul	ah			;AN000;  Skip nrng field
 30715 000048AE 40                      	inc	ax			;AN000; ax = (nrng*9)+1
 30716 000048AF 01C7                    	add	di,ax			;AN000; di points to nnval
 30717 000048B1 268A05                  	mov	al,[es:di]		;AN000; get nnval
 30718 000048B4 B405                    	mov	ah,$P_Len_Value ; 5	;AN000;
 30719 000048B6 F6E4                    	mul	ah			;AN000; Skip nnval field
 30720 000048B8 40                      	inc	ax			;AN000; ax = (nnval*5)+1
 30721 000048B9 01C7                    	add	di,ax			;AN000; di points to nstrval
 30722 000048BB 268A05                  	mov	al,[es:di]		;AN000; get nstrval
 30723 000048BE 47                      	inc	di			;AC035; add '2' to
 30724 000048BF 47                      	inc	di			;AC035;  DI reg
 30725                                  					;AN000; di points to 1st string in list
 30726                                  $P_Sim_Loop:				;AN000;
 30727 000048C0 268B2D                  	mov	bp,[es:di]		;AN000; get string pointer
 30728 000048C3 E82F00                  	call	$P_String_Comp		;AN000; compare it with operand
 30729 000048C6 7310                    	jnc	short $P_Sim_Found	;AN000; found on list ?
 30730                                  
 30731 000048C8 83C703                  	add	di,$P_Len_String ; 3	;AN000; if no, point to next choice
 30732 000048CB FEC8                    	dec	al			;AN000; loop nstval times in AL
 30733 000048CD 75F1                    	jnz	short $P_Sim_Loop	;AN000;
 30734                                  					;AN000; / Not found
 30735 000048CF 2EC706[E985]0800        	mov	word [cs:$P_RC],$P_Not_In_Str
 30736                                  	;mov	[cs:$P_RC],8		;AC034;
 30737                                  	; 31/03/2023
 30738                                  	;mov	ah,$P_No_Tag		;AN000; No ITEM_TAG set
 30739 000048D6 EB12                    	jmp	short $P_Sim_Exit	;AN000;
 30740                                  $P_Sim_Found:				;AN000;
 30741 000048D8 268A65FF                	mov	ah,[es:di-1]		;AN000; set item_tag
 30742 000048DC B002                    	mov	al,$P_List_Idx	; 2	;AN000;
 30743 000048DE 268B15                  	mov	dx,[es:di]		;AN000; get address of STRING
 30744 000048E1 EB0A                    	jmp	short $P_Sim_Exit0	;AN000;
 30745                                  $P_Sim01:				;AN000;
 30746 000048E3 2EC706[E985]0900        	mov	word [cs:$P_RC],$P_Syntax
 30747                                  	;mov	word [cs:$P_RC],9	;AC034;
 30748                                  $P_Sim_Exit:
 30749                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; No ITEM_TAG set
 30750                                  ;$P_Sim_Exit:				;AN000;
 30751                                  	;mov	al,$P_String ; 3	;AN000; Set type
 30752                                  	; 31/03/2023
 30753 000048EA B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 30754                                  $P_Sim_Exit0:				;AN000;
 30755 000048ED E888FC                  	call	$P_Fill_Result		;AN000;
 30756 000048F0 5F                      	pop	di			;AN000;
 30757 000048F1 5A                      	pop	dx			;AN000;
 30758 000048F2 5B                      	pop	bx			;AN000;
 30759 000048F3 58                      	pop	ax			;AN000;
 30760 000048F4 C3                      	retn				;AN000;
 30761                                  
 30762                                  ;***********************************************************************
 30763                                  ; $P_String_Comp:
 30764                                  ;
 30765                                  ; Function:  Compare two string
 30766                                  ;
 30767                                  ; Input:     psdata_seg:SI -> 1st string
 30768                                  ;	     ES:BP -> 2nd string  (Must be upper case)
 30769                                  ;	     ES:BX -> CONTROL block
 30770                                  ;
 30771                                  ; Output:    CY = 1 if not match
 30772                                  ;
 30773                                  ; Use:	$P_Chk_DBCS, $P_Do_CAPS_Char
 30774                                  ;
 30775                                  ; Vars: $P_KEYor_SW_Ptr(W), $P_Flags(R). $P_KEYorSW_Ptr
 30776                                  ;***********************************************************************
 30777                                  
 30778                                  	; 01/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30779                                  
 30780                                  $P_String_Comp:
 30781 000048F5 50                      	push	ax			;AN000;
 30782 000048F6 55                      	push	bp			;AN000;
 30783 000048F7 52                      	push	dx			;AN000;
 30784 000048F8 56                      	push	si			;AN000;
 30785 000048F9 B202                    	mov	dl,$P_DOSTBL_Char ; 2	;AN000; use character case map table
 30786                                  $P_SCOM_Loop:				;AN000;
 30787 000048FB 2E8A04                  	mov	al,[cs:si]		;AN000; get command character
 30788 000048FE E89704                  	call	$P_Chk_DBCS		;AN000; DBCS ?
 30789 00004901 723C                    	jc	short $P_SCOM00		;AN000; yes,DBCS
 30790                                  
 30791 00004903 E811FE                  	call	$P_Do_CAPS_Char 	;AN000; else, upper case map before comparison
 30792                                  	
 30793 00004906 2EF606[F585]08          	test	byte [cs:$P_Flags2],$P_Key_Cmp ; 8
 30794                                  					;AC034; keyword search ?
 30795 0000490C 740D                    	jz	short $P_SCOM04		;AN000;
 30796                                  
 30797                                  	;cmp	al,'=' ; 3Dh
 30798 0000490E 3C3D                    	cmp	al,$P_Keyword  ;'='	;AN000; "=" is delimiter
 30799 00004910 751F                    	jne	short $P_SCOM03		;AN000;IF "=" on command line AND  (bp+1=> char after the "=" in synonym list)
 30800                                  
 30801 00004912 26807E0100              	cmp	byte [es:bp+1],$P_NULL	;AN021;   at end of keyword string in the control block THEN
 30802 00004917 7562                    	jne	short $P_SCOM_Differ	;AN021;
 30803                                  
 30804 00004919 EB13                    	jmp	short $P_SCOM05 	;AN000;   keyword found in synonym list
 30805                                  
 30806                                  $P_SCOM04:				;AN000;
 30807 0000491B 2EF606[F585]10          	test	byte [cs:$P_Flags2],$P_SW_Cmp ; 10h 
 30808                                  					;AC034; switch search ?
 30809 00004921 740E                    	jz	short $P_SCOM03		;AN000;
 30810                                  
 30811 00004923 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; ":" is delimiter, at end of switch on command line
 30812 00004925 750A                    	jne	short $P_SCOM03		;AN000; continue compares
 30813                                  
 30814 00004927 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN021; IF at end of switch on command AND
 30815 0000492C 754D                    	jne	short $P_SCOM_Differ	;AN021;   at end of switch string in the control block THEN
 30816                                  
 30817                                  $P_SCOM05:				;AN000;   found a match
 30818 0000492E 46                      	inc	si			;AN000; si points to just after "=" or ":"
 30819 0000492F EB58                    	jmp	short $P_SCOM_Same	;AN000; exit
 30820                                  
 30821                                  $P_SCOM03:				;AN000;
 30822 00004931 263A4600                	cmp	al,[es:bp]		;AN000; compare operand w/ a synonym
 30823 00004935 751D                    	jne	short $P_SCOM_Differ0 	;AN000; if different, check ignore colon option
 30824                                  
 30825 00004937 08C0                    	or	al,al			;AN000; end of line
 30826 00004939 744E                    	jz	short $P_SCOM_Same	;AN000; if so, exit
 30827                                  
 30828 0000493B 46                      	inc	si			;AN000; update operand pointer
 30829 0000493C 45                      	inc	bp			;AN000;    and synonym pointer
 30830 0000493D EB13                    	jmp	short $P_SCOM01 	;AN000; loop until NULL or "=" or ":" found in case
 30831                                  
 30832                                  $P_SCOM00:				;AN000; Here al is DBCS leading byte
 30833 0000493F 263A4600                	cmp	al,[es:bp]		;AN000; compare leading byte
 30834 00004943 7536                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different
 30835                                  
 30836 00004945 46                      	inc	si			;AN000; else, load next byte
 30837 00004946 2E8A04                  	mov	al,[cs:si]		;AN000; and
 30838 00004949 45                      	inc	bp			;AN000;
 30839 0000494A 263A4600                	cmp	al,[es:bp]		;AN000; compare 2nd byte
 30840 0000494E 752B                    	jne	short $P_SCOM_Differ	;AN000; if not match, say different, too
 30841                                  
 30842 00004950 46                      	inc	si			;AN000; else update operand pointer
 30843 00004951 45                      	inc	bp			;AN000; 	and synonym pointer
 30844                                  $P_SCOM01:				;AN000;
 30845 00004952 EBA7                    	jmp	short $P_SCOM_Loop	;AN000; loop until NULL or "=" or "/" found in case
 30846                                  
 30847                                  $P_SCOM_Differ0:			;AN000;
 30848 00004954 2EF606[F585]40          	test	byte [cs:$P_Flags2],$P_SW ; 40h 
 30849                                  	;test	byte [cs:$P_Flags2],40h	;AC034;(tm10)
 30850 0000495A 740E                    	jz	short $P_not_applicable	;AN000;(tm10)
 30851                                  
 30852                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary
 30853                                  	;;test	word [es:bx+2],20h	;AN000;(tm10)
 30854                                  	; 03/04/2023
 30855 0000495C 26F6470220              	test	byte [es:bx+$P_CONTROL_BLK.$P_Function_Flag],$P_colon_is_not_necessary	
 30856 00004961 7407                    	jz	short $P_not_applicable	;AN000;(tm10)
 30857                                  
 30858 00004963 26807E0000              	cmp	byte [es:bp],$P_NULL	;AN000;(tm10)
 30859 00004968 741F                    	je	short $P_SCOM_Same	;AN025;(tm10)
 30860                                  
 30861                                  $P_not_applicable:			;AN000;(tm10)
 30862                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 30863                                  	;;test	word [es:bx],10h	;AN000; ignore colon option specified ?
 30864                                  	; 03/04/2023
 30865 0000496A 26F60710                	test	byte [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 30866 0000496E 740B                    	jz	short $P_SCOM_Differ	;AN000; if no, say different.
 30867                                  
 30868 00004970 3C3A                    	cmp	al,$P_Colon ; ':' ; 3Ah	;AN000; End up with ":" and
 30869 00004972 750A                    	jne	short $P_SCOM02		;AN000;    subseqently
 30870                                  
 30871 00004974 26807E0000              	cmp	byte [es:bp],$P_NULL 	;AN000;      NULL ?
 30872                                  	;jne	short $P_SCOM_Differ	;AN000; if no, say different
 30873                                  	;jmp	short $P_SCOM_Same	;AN000; else, say same
 30874                                  	; 01/04/2023
 30875 00004979 740E                    	je	short $P_SCOM_Same
 30876                                  $P_SCOM_Differ:
 30877 0000497B F9                      	stc
 30878 0000497C EB10                    	jmp	short $P_SCOM_Exit
 30879                                  
 30880                                  $P_SCOM02:				;AN000;
 30881 0000497E 3C00                    	cmp	al,$P_NULL ; 0		;AN000; end up NULL and :
 30882 00004980 75F9                    	jne	short $P_SCOM_Differ	;AN000;
 30883                                  
 30884                                  	;cmp	byte [es:bp],':'
 30885 00004982 26807E003A              	cmp	byte [es:bp],$P_Colon	;AN000; if no, say different
 30886                                  	;je	short $p_SCOM_Same	;AN000; else, say same
 30887                                  	; 01/04/2023
 30888 00004987 75F2                    	jne	short $P_SCOM_Differ
 30889                                  ;$P_SCOM_Differ: 			;AN000;
 30890                                  	;stc				;AN000; indicate not found
 30891                                  	;jmp	short $P_SCOM_Exit	;AN000;
 30892                                  
 30893                                  $P_SCOM_Same:				;AN000;
 30894 00004989 2E8936[F885]            	mov	[cs:$P_KEYorSW_Ptr],si	;AC034; for later use by keyword or switch
 30895                                  	; 01/04/2023
 30896                                  	;clc
 30897                                  	; cf = 0			;AN000; indicate found
 30898                                  $P_SCOM_Exit:				;AN000;
 30899 0000498E 5E                      	pop	si			;AN000;
 30900 0000498F 5A                      	pop	dx			;AN000;
 30901 00004990 5D                      	pop	bp			;AN000;
 30902 00004991 58                      	pop	ax			;AN000;
 30903 00004992 C3                      	retn				;AN000;
 30904                                  
 30905                                  ;***********************************************************************
 30906                                  ; $P_Date_Format
 30907                                  ;
 30908                                  ; Function:  Convert a date string to DOS date format for int 21h
 30909                                  ;	     with format validation.
 30910                                  ;
 30911                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 30912                                  ;	     ES:BX -> CONTROL block
 30913                                  ;
 30914                                  ; Output:    None
 30915                                  ;
 30916                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum
 30917                                  ;
 30918                                  ; Vars: $P_RC(W), $P_1st_Val(RW), $P_2nd_Val(RW), $P_3rd_Val(RW)
 30919                                  ;***********************************************************************
 30920                                  
 30921                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 30922                                  
 30923                                  $P_Date_Format:
 30924 00004993 50                      	push	ax			;AN000;
 30925 00004994 51                      	push	cx			;AN000;
 30926 00004995 52                      	push	dx			;AN000;
 30927 00004996 56                      	push	si			;AN000;
 30928 00004997 53                      	push	bx			;AN000;
 30929 00004998 56                      	push	si			;AN000;
 30930 00004999 E89F00                  	call	$P_Set_CDI		;AN000; set country dependent information before process
 30931                                  	; 03/04/2023
 30932                                  	;pop	si			;AN000;
 30933                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 30934                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 30935                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 30936 0000499C 31F6                    	xor	si,si
 30937 0000499E 2E8936[A786]            	mov	[cs:$P_1st_Val],si ; 0	;AC034; set initial value
 30938 000049A3 2E8936[A986]            	mov	[cs:$P_2nd_Val],si ; 0	;AC034; set initial value
 30939                                  	;mov	[cs:$P_3rd_Val],si ; 0	;AC034; set initial value
 30940 000049A8 5E                      	pop	si
 30941 000049A9 E8A900                  	call	$P_Get_DecNum		;AN000; get 1st number
 30942 000049AC 7218                    	jc	short $P_DateF_Err0	;AN000;-----------------------+
 30943 000049AE 2EA3[A786]              	mov	[cs:$P_1st_Val],ax	;AC034;			      |
 30944 000049B2 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 30945 000049B4 741A                    	jz	short $P_DateF_YMD	;AN000; 		      |
 30946 000049B6 E89C00                  	call	$P_Get_DecNum		;AN000; get 2nd number	      |
 30947 000049B9 726D                    	jc	short $P_DateF_Error	;AN000; 		      |
 30948 000049BB 2EA3[A986]              	mov	[cs:$P_2nd_Val],ax	;AC034;			      |
 30949 000049BF 08DB                    	or	bl,bl			;AN000; end of line ?	      |
 30950 000049C1 740D                    	jz	short $P_DateF_YMD	;AN000; 		      |
 30951 000049C3 E88F00                  	call	$P_Get_DecNum		;AN000; get 3rd number	      |
 30952                                  $P_DateF_Err0:				;AN000; Bridge	  <-----------+
 30953 000049C6 7260                    	jc	short $P_DateF_Error	;AN000;
 30954 000049C8 2EA3[AB86]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 30955 000049CC 08DB                    	or	bl,bl			;AN000; end of line ?
 30956 000049CE 7558                    	jnz	short $P_DateF_Error	;AN000;
 30957                                  $P_DateF_YMD:				;AN000;
 30958 000049D0 2E8B1E[8586]            	mov	bx,[cs:$P_Country_Info+$P_CDI.$P_CDI_DateF]
 30959                                  	;mov	bx,[cs:$P_Country_Info]	;AC034; get date format
 30960 000049D5 83FB02                  	cmp	bx,$P_Date_YMD ; 2	;AN000;
 30961 000049D8 7422                    	je	short $P_DateF00	;AN000;
 30962 000049DA 2EA1[A786]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 30963 000049DE 08E4                    	or	ah,ah			;AN000;
 30964 000049E0 7546                    	jnz	short $P_DateF_Error	;AN000;
 30965 000049E2 88C1                    	mov	cl,al			;AN000; set month
 30966 000049E4 2EA1[A986]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 30967 000049E8 08E4                    	or	ah,ah			;AN000; if overflow, error.
 30968 000049EA 753C                    	jnz	short $P_DateF_Error	;AN000;
 30969 000049EC 88C5                    	mov	ch,al			;AN000; set date
 30970 000049EE 2E8B16[AB86]            	mov	dx,[cs:$P_3rd_Val]	;AC034; set year
 30971 000049F3 83FB01                  	cmp	bx,$P_Date_DMY ; 1	;AN000; from here format = MDY
 30972 000049F6 7502                    	jne	short $P_DateF01	;AN000; if it is DMY
 30973 000049F8 86E9                    	xchg	ch,cl			;AN000;  then swap M <-> D
 30974                                  $P_DateF01:				;AN000;
 30975 000049FA EB19                    	jmp	short $P_DateF02	;AN000;
 30976                                  $P_DateF00:				;AN000; / here format = YMD
 30977 000049FC 2E8B16[A786]            	mov	dx,[cs:$P_1st_Val]	;AC034; set year
 30978 00004A01 2EA1[A986]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 30979 00004A05 08E4                    	or	ah,ah			;AN000; if overflow, error
 30980 00004A07 751F                    	jnz	short $P_DateF_Error	;AN000;
 30981                                  
 30982 00004A09 88C1                    	mov	cl,al			;AN000; set month
 30983 00004A0B 2EA1[AB86]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 30984 00004A0F 08E4                    	or	ah,ah			;AN000; if overflow, error
 30985 00004A11 7515                    	jnz	short $P_DateF_Error	;AN000;
 30986 00004A13 88C5                    	mov	ch,al			;AN000; set date
 30987                                  $P_DateF02:				;AN000;
 30988 00004A15 83FA64                  	cmp	dx,100			;AN000; year is less that 100 ?
 30989 00004A18 7304                    	jae	short $P_DateF03	;AN000;
 30990 00004A1A 81C26C07                	add	dx,1900 		;AN000; set year 19xx
 30991                                  $P_DateF03:				;AN000;
 30992 00004A1E 5B                      	pop	bx			;AN000; recover CONTROL block
 30993 00004A1F 5E                      	pop	si			;AN000; recover string pointer
 30994                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 30995                                  	;mov	al,$P_Date_F ; 7	;AN000;   result
 30996                                  	; 03/04/2023
 30997 00004A20 B807FF                  	mov	ax,($P_No_Tag<<8)+$P_Date_F
 30998 00004A23 E852FB                  	call	$P_Fill_Result		;AN000;        buffer
 30999 00004A26 EB0F                    	jmp	short $P_Date_Format_Exit
 31000                                  					;AN000;	to Date
 31001                                  $P_DateF_Error: 			;AN000;
 31002 00004A28 5B                      	pop	bx			;AN000; recover CONTROL block
 31003 00004A29 5E                      	pop	si			;AN000; recover string pointer
 31004                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31005                                  	;mov	al,$P_String ; 3	;AN000;   result
 31006                                  	; 03/04/2023
 31007 00004A2A B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31008 00004A2D E848FB                  	call	$P_Fill_Result		;AN000; 	buffer
 31009                                  					;AN000; to string
 31010 00004A30 2EC706[E985]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9
 31011                                  					;AC034; indicate syntax error
 31012                                  $P_Date_Format_Exit:			;AN000;
 31013 00004A37 5A                      	pop	dx			;AN000;
 31014 00004A38 59                      	pop	cx			;AN000;
 31015 00004A39 58                      	pop	ax			;AN000;
 31016 00004A3A C3                      	retn				;AN000;
 31017                                  
 31018                                  ;***********************************************************************
 31019                                  ; $P_Set_CDI:
 31020                                  ;
 31021                                  ; Function: Read CDI from DOS if it has not been read yet
 31022                                  ;
 31023                                  ; Input:    None
 31024                                  ;
 31025                                  ; Output:   psdata_seg:SI -> CDI
 31026                                  ;
 31027                                  ; Use:	INT 21h w/ AH = 38h
 31028                                  ;***********************************************************************
 31029                                  
 31030                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31031                                  $P_Set_CDI:
 31032                                  	; 18/04/2023
 31033 00004A3B 8D36[8586]              	lea	si,$P_Country_Info	;AC034;
 31034                                  	;cmp	word [cs:si+$P_CDI.$P_CDI_DateF],-1 ; $P_NeedToBeRead
 31035 00004A3F 2E833CFF                	cmp	word [cs:si],-1 ; $P_NeedToBeRead ; 0FFFFh
 31036                                  					;AN000; already read ?
 31037                                  	;je	short $P_Read_CDI	;AN000;
 31038                                  	;jmp	short $P_Set_CDI_Exit	;AN000; then do nothing
 31039                                  	; 03/04/2023
 31040 00004A43 750F                    	jne	short $P_Set_CDI_Exit
 31041                                  $P_Read_CDI:				;AN000; else read CDI thru DOS
 31042 00004A45 1E                      	push	ds			;AN000;
 31043 00004A46 52                      	push	dx			;AN000;
 31044 00004A47 50                      	push	ax			;AN000;
 31045 00004A48 0E                      	push	cs			;AC023;
 31046 00004A49 1F                      	pop	ds			;AN000; set segment register
 31047                                  	;mov	ax,3800h
 31048 00004A4A B80038                  	mov	ax,$P_DOS_Get_CDI	;AN000; get country information
 31049 00004A4D 89F2                    	mov	dx,si			;AN000; set offset of CDI in local data area
 31050 00004A4F CD21                    	int	21h			;AN000;
 31051 00004A51 58                      	pop	ax			;AN000;
 31052 00004A52 5A                      	pop	dx			;AN000;
 31053 00004A53 1F                      	pop	ds			;AN000;
 31054                                  $P_Set_CDI_Exit:			;AN000;
 31055 00004A54 C3                      	retn				;AN000;
 31056                                  
 31057                                  ;***********************************************************************
 31058                                  ; $P_Get_DecNum:
 31059                                  ;
 31060                                  ; Function:  Read a chcrater code from psdata_seg:SI until specified delimiter
 31061                                  ;	     or NULL encountered. And make a decimal number.
 31062                                  ;
 31063                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31064                                  ;
 31065                                  ; Output:    BL = delimiter code or NULL
 31066                                  ;	     AX = Decimal number
 31067                                  ;	     SI advanced to the next number
 31068                                  ;	     CY = 1 : Syntax error, AL = Latest examineed number
 31069                                  ;
 31070                                  ; Use:	$P_0099
 31071                                  ;***********************************************************************
 31072                                  
 31073                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31074                                  $P_Get_DecNum:
 31075 00004A55 51                      	push	cx			;AN000;
 31076 00004A56 52                      	push	dx			;AN000;
 31077 00004A57 31C9                    	xor	cx,cx			;AN000; cx will have final value
 31078                                  $P_GetNum_Loop: 			;AN000;
 31079 00004A59 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31080 00004A5C 08C0                    	or	al,al			;AN000; end of line ?
 31081 00004A5E 7438                    	jz	short $P_GetNum00	;AN000; if yes, exit
 31082 00004A60 2E803E[8486]00          	cmp	byte [cs:$P_Got_Time],0 ;AC034; is this numeric in a time field? ;AC023
 31083 00004A66 740B                    	je	short $P_Do_Date_Delims	;AN000; no, go check out Date delimiters ;AC023
 31084                                  
 31085                                  ; Determine which delimiter(s) to check for. Colon & period  or period only
 31086                                  	;cmp	bl,$P_colon_period
 31087 00004A68 80FB01                  	cmp	bl,1 ; $P_colon_period	;AN032; ;Time
 31088 00004A6B 750E                    	jne	short $P_Do_Time_Delim1	;AN032; ;only check for period
 31089                                  
 31090 00004A6D 3C3A                    	cmp	al,$P_Colon ; ':'	;AN032; ;Is this a valid delimiter ?
 31091 00004A6F 742B                    	je	short $P_GetNum01	;AN032; ;yes, exit
 31092                                  
 31093                                  	; 03/04/2023
 31094 00004A71 EB08                    	jmp	short $P_Do_Time_Delim1
 31095                                  ;$P_Do_Time_Delim1:			;AN000;
 31096                                  	;cmp	al,$P_Period ; '.'	;;AC032;;AC023;Is this a valid delimiter ?
 31097                                  	;je	short $P_GetNum01	;AC023; yes, exit
 31098                                  	;
 31099                                  	;jmp	short $P_Neither_Delims ;AN023;
 31100                                  
 31101                                  $P_Do_Date_Delims:			;AN000;
 31102                                  ;Regardless of the date delimiter character specified in the country
 31103                                  ;dependent information, check for the presence of any one of these
 31104                                  ;three field delimiters: "-", "/", or ".".
 31105 00004A73 3C2D                    	cmp	al,$P_Minus ;'-'	;AN020;is this a date delimiter character?
 31106 00004A75 7425                    	je	short $P_GetNum01	;AN020;if yes, exit
 31107                                  
 31108 00004A77 3C2F                    	cmp	al,$P_Slash ; '/'	;AN020;is this a date delimiter character?
 31109 00004A79 7421                    	je	short $P_GetNum01	;AN020;if yes, exit
 31110                                  
 31111                                  $P_Do_Time_Delim1:  ; 03/04/2023
 31112 00004A7B 3C2E                    	cmp	al,$P_Period ; '.'	;AN020;is this a date delimiter character?
 31113 00004A7D 741D                    	je	short $P_GetNum01	;AN000; if yes, exit
 31114                                  
 31115                                  $P_Neither_Delims:			;AN023;
 31116 00004A7F E804FE                  	call	$P_0099 		;AN000; convert it to binary
 31117 00004A82 721C                    	jc	short $P_GetNum_Exit	;AN000; if error exit
 31118                                  
 31119 00004A84 B400                    	mov	ah,0			;AN000;
 31120 00004A86 91                      	xchg	ax,cx			;AN000;
 31121 00004A87 BA0A00                  	mov	dx,10			;AN000;
 31122 00004A8A F7E2                    	mul	dx			;AN000; ax = ax * 10
 31123 00004A8C 09D2                    	or	dx,dx			;AN000; overflow
 31124 00004A8E 750F                    	jnz	short $P_GetNum02	;AN000; then exit
 31125                                  
 31126 00004A90 01C8                    	add	ax,cx			;AN000;
 31127 00004A92 720C                    	jc	short $P_GetNum_Exit	;AN000;
 31128                                  
 31129 00004A94 91                      	xchg	ax,cx			;AN000;
 31130 00004A95 46                      	inc	si			;AN000;
 31131 00004A96 EBC1                    	jmp	short $P_GetNum_Loop	;AN000;
 31132                                  
 31133                                  $P_GetNum00:				;AN000;
 31134 00004A98 88C3                    	mov	bl,al			;AN000; set bl to NULL
 31135                                  	;03/04/2023
 31136                                  	; cf=0
 31137                                  	;clc				;AN000; indicate no error
 31138 00004A9A EB04                    	jmp	short $P_GetNum_Exit	;AN000;
 31139                                  
 31140                                  $P_GetNum01:				;AN000;
 31141 00004A9C 46                      	inc	si			;AN000; si points to next number
 31142                                  	;03/04/2023
 31143                                  	; cf=0
 31144                                  	;clc				;AN000; indicate no error
 31145 00004A9D EB01                    	jmp	short $P_GetNum_Exit	;AN000;
 31146                                  
 31147                                  $P_GetNum02:				;AN000;
 31148 00004A9F F9                      	stc				;AN000; indicate error
 31149                                  $P_GetNum_Exit: 			;AN000;
 31150 00004AA0 89C8                    	mov	ax,cx			;AN000;return value
 31151 00004AA2 5A                      	pop	dx			;AN000;
 31152 00004AA3 59                      	pop	cx			;AN000;
 31153 00004AA4 C3                      	retn				;AN000;
 31154                                  
 31155                                  ;***********************************************************************
 31156                                  ; $P_Time_Format
 31157                                  ;
 31158                                  ; Function:  Convert a time string to DOS time format for int 21h
 31159                                  ;	     with format validation.
 31160                                  ;
 31161                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31162                                  ;	     ES:BX -> CONTROL block
 31163                                  ;
 31164                                  ; Output:    None
 31165                                  ;
 31166                                  ; Use:	$P_Fill_Result, $P_Set_CDI, $P_Get_DecNum, $P_Time_2412
 31167                                  ;
 31168                                  ; Vars: $P_RC(W), $P_Flags(R), $P_1st_Val(RW), $P_2nd_Val(RW)
 31169                                  ;	$P_3rd_Val(RW), $P_4th_Val(RW)
 31170                                  ;***********************************************************************
 31171                                  
 31172                                  	; 03/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31173                                  
 31174                                  $P_Time_Format:				;AN000;
 31175 00004AA5 50                      	push	ax			;AN000;
 31176 00004AA6 51                      	push	cx			;AN000;
 31177 00004AA7 52                      	push	dx			;AN000;
 31178 00004AA8 56                      	push	si			;AN000;
 31179 00004AA9 53                      	push	bx			;AN000;
 31180 00004AAA 56                      	push	si			;AN000;
 31181 00004AAB E88DFF                  	call	$P_Set_CDI		;AN000; Set country independent
 31182                                  					; information before process
 31183                                  	;test	byte [cs:si+11h], 1
 31184 00004AAE 2EF6441001              	test	byte [cs:si+$P_CDI.$P_CDI_TimeF],1 
 31185                                  					;AN000; 24 hour system
 31186 00004AB3 5E                      	pop	si			;AN000;
 31187 00004AB4 7503                    	jnz	short $P_TimeF00	;AN000; if no, means 12 hour system
 31188 00004AB6 E8F800                  	call	$P_Time_2412		;AN000; this routine handle "am" "pm"
 31189                                  $P_TimeF00:				;AN000;
 31190                                  	;mov	word [cs:$P_1st_Val],0	;AC034; set initial value
 31191                                  	;mov	word [cs:$P_2nd_Val],0	;AC034; set initial value
 31192                                  	;mov	word [cs:$P_3rd_Val],0	;AC034; set initial value
 31193                                  	;mov	word [cs:$P_4th_Val],0	;AC034; set initial value
 31194                                  	;mov	byte [cs:$P_Got_Time],1	;AN023;AC034;; use time delimiter
 31195                                  	; 03/04/2023
 31196 00004AB9 31DB                    	xor	bx,bx
 31197 00004ABB 2E891E[A786]            	mov	[cs:$P_1st_Val],bx ; 0
 31198 00004AC0 2E891E[A986]            	mov	[cs:$P_2nd_Val],bx ; 0
 31199 00004AC5 2E891E[AB86]            	mov	[cs:$P_3rd_Val],bx ; 0
 31200 00004ACA 2E891E[AD86]            	mov	[cs:$P_4th_Val],bx ; 0
 31201                                  	;inc	bl
 31202                                  	;mov	[cs:$P_Got_Time],bl ; 1
 31203                                  
 31204                                  	;mov	bl,$P_colon_period
 31205                                  	;mov	bl,1 ; $P_colon_period	;AN032; flag, indicates use of
 31206                                  					; delimiters between hours,
 31207                                  					;  minutes,seconds
 31208                                  	; 03/04/2023 - Retro DOS v4.0 COMMAND.COM
 31209 00004ACF FEC3                    	inc	bl ; bl = 1
 31210 00004AD1 2E881E[8486]            	mov	[cs:$P_Got_Time],bl ; 1
 31211                                  	;
 31212 00004AD6 E87CFF                  	call	$P_Get_DecNum		;AN000; get 1st number
 31213 00004AD9 725D                    	jc	short $P_TimeF_Err0	;AN000;
 31214 00004ADB 2EA3[A786]              	mov	[cs:$P_1st_Val],ax	;AC034;
 31215 00004ADF 08DB                    	or	bl,bl			;AN000; end of line ?
 31216 00004AE1 745F                    	jz	short $P_TimeF_Rlt	;AN000;
 31217 00004AE3 E86FFF                  	call	$P_Get_DecNum		;AN000; get 2nd number
 31218 00004AE6 7250                    	jc	short $P_TimeF_Err0	;AC038; if OK
 31219 00004AE8 2EA3[A986]              	mov	[cs:$P_2nd_Val],ax	;AC034;
 31220 00004AEC 08DB                    	or	bl,bl			;AN000; end of line ?
 31221 00004AEE 7452                    	jz	short $P_TimeF_Rlt	;AN000;
 31222 00004AF0 B302                    	mov	bl,2 ; $P_period_only	;AN032; flag, which to decimal separator
 31223 00004AF2 E860FF                  	call	$P_Get_DecNum		;AN000; get 3rd number
 31224 00004AF5 7241                    	jc	short $P_TimeF_Err0	;AC039; if problem, bridge to error
 31225 00004AF7 2EA3[AB86]              	mov	[cs:$P_3rd_Val],ax	;AC034;
 31226 00004AFB 08DB                    	or	bl,bl			;AN000; end of line ?
 31227 00004AFD 7536                    	jnz	short $P_Time_4		;AN039; NOT END OF LINE,
 31228                                  					;AN039;   GO TO 4TH NUMBER
 31229                                  	;test	byte [cs:$P_Flags1],$P_Time_Again ; 2
 31230 00004AFF 2EF606[F485]02          	test	byte [cs:$P_Flags1],2 	;AN039; HAS TIME PARSE
 31231                                  					;AN039;    BEEN REPEATED?
 31232 00004B05 753B                    	jnz	short $P_TimeF_Rlt	;AN039; yes, this is really
 31233                                  					;AN039;   the end of line
 31234                                  					;AN039; no, time has not been repeated
 31235 00004B07 2E8B36[EB85]            	mov	si,[cs:$P_SI_Save]	;AN039; get where parser quit
 31236                                  					;AN039;   in command line
 31237 00004B0C 807CFF2C                	cmp	byte [si-1],$P_Comma ; ','
 31238                                  					;AN039; look at delimiter
 31239                                  					;AN039;   from command line
 31240 00004B10 7530                    	jne	short $P_TimeF_Rlt	;AN039; was not a comma, this is
 31241                                  					;AN039;  really end of line
 31242                                  					;AN039; is comma before hundredths,
 31243                                  					;AN039;   redo TIME
 31244 00004B12 C644FF2E                	mov	byte [si-1],$P_Period ; '.' 
 31245                                  					;AN039; change that ambiguous
 31246                                  					;AN039;    comma to a decimal point
 31247                                  					;AN039;     parse can understand
 31248 00004B16 2EC706[F485]0000        	mov	word [cs:$P_Flags],0	;AN039; Clear all internal flags
 31249                                  	;or	byte [cs:$P_Flags1],$P_Time_Again
 31250 00004B1D 2E800E[F485]02          	or	byte [cs:$P_Flags1],2	;AN039; indicate TIME
 31251                                  					;AN039; is being repeated
 31252 00004B23 2E8B0E[7E86]            	mov	cx,[cs:$P_ORIG_ORD]	;AN039; ORIGINAL ORDINAL FROM CX
 31253 00004B28 2E8B26[8086]            	mov	sp,[cs:$P_ORIG_STACK]	;AN039; ORIGINAL VALUE
 31254                                  					;AN039;   OF STACK FROM SP
 31255 00004B2D 2E8B36[8286]            	mov	si,[cs:$P_ORIG_SI]	;AN039; ORIGINAL START
 31256                                  					;AN039;   PARSE POINTER FROM SI
 31257 00004B32 E911F8                  	jmp	$P_Redo_Time		;AN039; go try TIME again
 31258                                  $P_Time_4:				;AN039; READY FOR 4TH (HUNDREDTHS) NUMBER
 31259 00004B35 E81DFF                  	call	$P_Get_DecNum		;AN000; get 4th number
 31260                                  $P_TimeF_Err0:				;AN000; Bridge
 31261 00004B38 725E                    	jc	short $P_TimeF_Error	;AN000;
 31262                                  	;
 31263 00004B3A 2EA3[AD86]              	mov	[cs:$P_4th_Val],ax	;AC034;
 31264 00004B3E 08DB                    	or	bl,bl			;AN000; After hundredth, no data allowed
 31265 00004B40 7556                    	jnz	short $P_TimeF_Error	;AN000; if some, then error
 31266                                  $P_TimeF_Rlt:				;AN000;
 31267 00004B42 2EA1[A786]              	mov	ax,[cs:$P_1st_Val]	;AC034;
 31268 00004B46 08E4                    	or	ah,ah			;AN000; if overflow then error
 31269 00004B48 754E                    	jnz	short $P_TimeF_Err	;AN000;
 31270                                  	;test	byte [cs:$P_Flags1],$P_Time12am ; 1
 31271 00004B4A 2EF606[F485]01          	test	byte [cs:$P_Flags1],1	;AN038;if "am" specified
 31272 00004B50 7408                    	jz	short $P_Time_notAM	;AN038;skip if no "AM" specified
 31273                                  					;since "AM" was specified,
 31274 00004B52 3C0C                    	cmp	al,12			;AN038: if hour specified as later than noon
 31275 00004B54 7742                    	ja	short $P_TimeF_Err	;AN038; error if "AM" on more than noon
 31276 00004B56 7502                    	jne	short $P_Time_notAM	;AN038; for noon exactly,
 31277 00004B58 30C0                    	xor	al,al			;AN038; set hour = zero
 31278                                  $P_Time_notAM:				;AN038;
 31279                                  	;test	byte [cs:$P_Flags2],$P_Time12
 31280 00004B5A 2EF606[F585]04          	test	byte [cs:$P_Flags2],4	;AC034; if 12 hour system and pm is specified
 31281 00004B60 740C                    	jz	short $P_TimeSkip00	;AN000; then
 31282 00004B62 3C0C                    	cmp	al,12			;AN038; if 12:00 o'clock already
 31283 00004B64 7408                    	je	short $P_TimeSkip00	;AN038; it is PM already
 31284 00004B66 040C                    	add	al,12			;AN000; add 12 hours to make it afternoon
 31285 00004B68 722E                    	jc	short $P_TimeF_Err	;AN000; if overflow then error
 31286 00004B6A 3C18                    	cmp	al,24			;AN038; after adding 12, now cannot be >24
 31287 00004B6C 772A                    	ja	short $P_TimeF_Err	;AN038; if too big, error
 31288                                  $P_TimeSkip00:				;AN000;
 31289 00004B6E 88C2                    	mov	dl,al			;AN000; set hour
 31290 00004B70 2EA1[A986]              	mov	ax,[cs:$P_2nd_Val]	;AC034;
 31291 00004B74 08E4                    	or	ah,ah			;AN000; if overflow then error
 31292 00004B76 7520                    	jnz	short $P_TimeF_Err	;AN000;
 31293 00004B78 88C6                    	mov	dh,al			;AN000; set minute
 31294 00004B7A 2EA1[AB86]              	mov	ax,[cs:$P_3rd_Val]	;AC034;
 31295 00004B7E 08E4                    	or	ah,ah			;AN000; if overflow then error
 31296 00004B80 7516                    	jnz	short $P_TimeF_Err	;AN000;
 31297 00004B82 88C1                    	mov	cl,al			;AN000; set second
 31298 00004B84 2EA1[AD86]              	mov	ax,[cs:$P_4th_Val]	;AC034;
 31299 00004B88 08E4                    	or	ah,ah			;AN000; if overflow then error
 31300 00004B8A 750C                    	jnz	short $P_TimeF_Err	;AN000;
 31301 00004B8C 88C5                    	mov	ch,al			;AN000; set hundredth
 31302 00004B8E 5B                      	pop	bx			;AN000; recover CONTROL block
 31303 00004B8F 5E                      	pop	si			;AN000; recover string pointer
 31304                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31305                                  	;mov	al,$P_Time_F ; 8 	;AN000;   result
 31306                                  	; 03/04/2023
 31307 00004B90 B808FF                  	mov	ax,($P_No_Tag<<8)+$P_Time_F
 31308 00004B93 E8E2F9                  	call	$P_Fill_Result		;AN000;        buffer
 31309 00004B96 EB0F                    	jmp	short $P_Time_Format_Exit
 31310                                  					;AN000; to time
 31311                                  $P_TimeF_Error: 			;AN000;
 31312                                  $P_TimeF_Err:				;AN000;
 31313 00004B98 5B                      	pop	bx			;AN000; recover CONTROL block
 31314 00004B99 5E                      	pop	si			;AN000; recover string pointer
 31315                                  	;mov	ah,$P_No_Tag		;AN000; set
 31316                                  	;mov	al,$P_String		;AN000;     result
 31317                                  	; 03/04/2023
 31318 00004B9A B803FF                  	mov	ax,($P_No_Tag<<8)+$P_String
 31319 00004B9D E8D8F9                  	call	$P_Fill_Result		;AN000; 	  buffer
 31320                                  					;AN000; to string
 31321 00004BA0 2EC706[E985]0900        	mov	word [cs:$P_RC],$P_Syntax ; 9	
 31322                                  					;AC034; return syntax error
 31323                                  $P_Time_Format_Exit:			;AN000;
 31324 00004BA7 2EC606[8486]00          	mov	byte [cs:$P_Got_Time],0	;AN023;AC034; finished with this time field
 31325 00004BAD 5A                      	pop	dx			;AN000;
 31326 00004BAE 59                      	pop	cx			;AN000;
 31327 00004BAF 58                      	pop	ax			;AN000;
 31328 00004BB0 C3                      	retn
 31329                                  
 31330                                  ;***********************************************************************
 31331                                  ; $P_Time_2412:
 31332                                  ;
 31333                                  ; Function:  Remove "a", "p", "am", or "pm" from the end of stinrg
 31334                                  ;
 31335                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31336                                  ;
 31337                                  ; Output:    Set $P_Time12 flag when the string is terminated by "p"
 31338                                  ;	     or "pm"
 31339                                  ;
 31340                                  ; Vars:  $P_Flags(W)
 31341                                  ;***********************************************************************
 31342                                  
 31343                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31344                                  
 31345                                  $P_Time_2412:				;AN000;
 31346 00004BB1 50                      	push	ax			;AN000;
 31347 00004BB2 56                      	push	si			;AN000;
 31348                                  $P_T12_Loop:				;AN000;
 31349 00004BB3 2E8A04                  	mov	al,[cs:si]		;AN000; Move
 31350 00004BB6 46                      	inc	si			;AN000;     si
 31351 00004BB7 08C0                    	or	al,al			;AN000;       to
 31352 00004BB9 75F8                    	jnz	short $P_T12_Loop	;AN000; 	end of string
 31353                                  
 31354 00004BBB 2E8A44FE                	mov	al,[cs:si-2]		;AN000; get char just before NULL
 31355                                  	;or	al,20h
 31356 00004BBF 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31357 00004BC1 3C70                    	cmp	al,"p"                  ;AN000; only "p" of "pm" ?
 31358 00004BC3 7425                    	je	short $P_T1200		;AN000;
 31359                                  
 31360 00004BC5 3C61                    	cmp	al,"a"                  ;AN000; only "a" of "am" ?
 31361 00004BC7 7413                    	je	short $P_T1201		;AN000;
 31362                                  
 31363 00004BC9 3C6D                    	cmp	al,"m"                  ;AN000; "m" of "am" or "pm"
 31364 00004BCB 751A                    	jne	short $P_T12_Exit	;AN000;
 31365                                  
 31366 00004BCD 4E                      	dec	si			;AN000;
 31367 00004BCE 2E8A44FE                	mov	al,[cs:si-2]		;AN000;
 31368                                  	;or	al,20h
 31369 00004BD2 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case map
 31370 00004BD4 3C70                    	cmp	al,"p"                  ;AN000; "p" of "pm" ?
 31371 00004BD6 7412                    	je	short $P_T1200		;AN000;
 31372                                  
 31373 00004BD8 3C61                    	cmp	al,"a"                  ;AN000; "a" of "am" ?
 31374                                  	;je	short $P_T1201		;AN000; go process "a"
 31375                                  	;jmp	short $P_T12_Exit	;AN000; no special chars found
 31376                                  	; 05/04/2023
 31377 00004BDA 750B                    	jne	short $P_T12_Exit
 31378                                  
 31379                                  ;$P_T1200:				;AN000; "P" found
 31380                                  	;;or	byte [cs:$P_Flags2],$P_Time12
 31381                                  	;or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31382                                  	;jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31383                                  
 31384                                  $P_T1201:				;AN000; "A" found
 31385                                  	;or	byte [cs:$P_Flags1],$P_Time12AM
 31386 00004BDC 2E800E[F485]01          	or	byte [cs:$P_Flags1],1	;AN038; flag "AM" found
 31387                                  $P_Tclr_chr:				;AN038;
 31388 00004BE2 2EC644FE00              	mov	byte [cs:si-2],$P_NULL	;AN000; null out special char
 31389                                  $P_T12_Exit:				;AN000;
 31390 00004BE7 5E                      	pop	si			;AN000;
 31391 00004BE8 58                      	pop	ax			;AN000;
 31392 00004BE9 C3                      	retn				;AN000;
 31393                                  
 31394                                  	; 05/04/2023
 31395                                  $P_T1200:				;AN000; "P" found
 31396                                  	;or	byte [cs:$P_Flags2],$P_Time12
 31397 00004BEA 2E800E[F585]04          	or	byte [cs:$P_Flags2],4	;AC034; flag "PM" found
 31398 00004BF0 EBF0                    	jmp	short $P_Tclr_chr	;AN038; go clear the special char
 31399                                  
 31400                                  ;***********************************************************************
 31401                                  ; $P_File_Format;
 31402                                  ;
 31403                                  ; Function:  Check if the input string is valid file spec format.
 31404                                  ;	     And set the result buffer.
 31405                                  ;
 31406                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31407                                  ;	     ES:BX -> CONTROL block
 31408                                  ;
 31409                                  ; Output:    None
 31410                                  ;
 31411                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS, $P_FileSp_Chk
 31412                                  ;
 31413                                  ; Vars: $P_RC(W), $P_SI_Save(W), $P_Terminator(W), $P_SaveSI_Cmpx(R)
 31414                                  ;	$P_SaveSI_Cmpx(R)
 31415                                  ;***********************************************************************
 31416                                  
 31417                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31418                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4DF0h
 31419                                  $P_File_Format:
 31420 00004BF2 50                      	push	ax			;AN000;
 31421 00004BF3 57                      	push	di			;AN000;
 31422 00004BF4 56                      	push	si			;AN000;
 31423 00004BF5 2E8B3E[F685]            	mov	di,[cs:$P_SaveSI_Cmpx]	;AC034; get user buffer address
 31424 00004BFA 2E8A04                  	mov	al,[cs:si]		;AN000; load character
 31425 00004BFD 08C0                    	or	al,al			;AN000; end of line ?
 31426 00004BFF 7413                    	je	short $P_FileF_Err	;AN000; if yes, error exit
 31427 00004C01 E85D00                  	call	$P_FileSp_Chk		;AN000; else, check if file special character
 31428 00004C04 7523                    	jne	short $P_FileF03	;AN000; if yes,
 31429 00004C06 2EC606[C286]01          	mov	byte [cs:$P_err_flag],$P_error_filespec ; 1
 31430                                  					;AN033;AC034;; set error flag- bad char.
 31431 00004C0C 5E                      	pop	si			;AN033;
 31432 00004C0D 2EC60400                	mov	byte [cs:si],$P_NULL	;AN033;
 31433 00004C11 5F                      	pop	di			;AN033;
 31434 00004C12 EB3E                    	jmp	short $P_FileF02	;AN033;
 31435                                  $P_FileF_Err:				;AN000;
 31436 00004C14 5E                      	pop	si			;AN000;
 31437 00004C15 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000;
 31438 00004C19 5F                      	pop	di			;AN000;
 31439                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Optional
 31440                                  	;test	word [es:bx],1		;AN000; is it optional ?
 31441 00004C1A 26F60701                	test	byte [es:bx],$P_Optional ; 1
 31442 00004C1E 7532                    	jnz	short $P_FileF02	;AN000;
 31443 00004C20 2EC706[E985]0200        	mov	word [cs:$P_RC],$P_Op_Missing
 31444                                  	;mov	word [cs:$P_RC],2	;AC034; 3/17/87
 31445 00004C27 EB29                    	jmp	short $P_FileF02	;AN000;
 31446                                  $P_FileF03:				;AN000;
 31447 00004C29 58                      	pop	ax			;AN000; discard save si
 31448 00004C2A 56                      	push	si			;AN000; save new si
 31449                                  $P_FileF_Loop1: 			;AN000;
 31450 00004C2B 2E8A04                  	mov	al,[cs:si]		;AN000; load character (not special char)
 31451 00004C2E 08C0                    	or	al,al			;AN000; end of line ?
 31452 00004C30 741E                    	jz	short $P_FileF_RLT	;AN000;
 31453 00004C32 E82C00                  	call	$P_FileSp_Chk		;AN000; File special character ?
 31454 00004C35 740B                    	jz	short $P_FileF00	;AN000;
 31455 00004C37 E85E01                  	call	$P_Chk_DBCS		;AN000; no, then DBCS ?
 31456 00004C3A 7302                    	jnc	short $P_FileF01	;AN000;
 31457 00004C3C 47                      	inc	di			;AN000; if yes, skip next byte
 31458 00004C3D 46                      	inc	si			;AN000;
 31459                                  $P_FileF01:				;AN000;
 31460 00004C3E 47                      	inc	di			;AN000;
 31461 00004C3F 46                      	inc	si			;AN000;
 31462 00004C40 EBE9                    	jmp	short $P_FileF_Loop1	;AN000;
 31463                                  $P_FileF00:				;AN000;
 31464 00004C42 2EA2[EF85]              	mov	[cs:$P_Terminator],al	;AC034;
 31465 00004C46 2EC60400                	mov	byte [cs:si],$P_NULL	;AN000; update end of string
 31466 00004C4A 47                      	inc	di			;AN000;
 31467 00004C4B 2E893E[EB85]            	mov	[cs:$P_SI_Save],di	;AC034; update next pointer in command line
 31468                                  $P_FileF_RLT:				;AN000;
 31469 00004C50 5E                      	pop	si			;AN000;
 31470 00004C51 5F                      	pop	di			;AN000;
 31471                                  $P_FileF02:				;AN000;
 31472 00004C52 58                      	pop	ax			;AN000; (tm14)
 31473                                  	;;test	ax,200h
 31474                                  	;test	ax,$P_File_Spc		;AN000; (tm14)
 31475                                  	; 05/04/2023
 31476 00004C53 F6C402                  	test	ah,($P_File_Spc>>8)
 31477 00004C56 7408                    	jz	short $P_Drv_Only_Exit	;AN000; (tm14)
 31478 00004C58 50                      	push	ax			;AN000; (tm14)
 31479                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000; set
 31480                                  	;mov	al,$P_File_Spec ; 5 	;AN000;    result
 31481                                  	; 05/04/2023
 31482 00004C59 B805FF                  	mov	ax,($P_No_Tag<<8)+$P_File_Spec
 31483 00004C5C E819F9                  	call	$P_Fill_Result		;AN000; 	buffer to file spec
 31484 00004C5F 58                      	pop	ax			;AN000;
 31485                                  $P_Drv_Only_Exit:			;AN000; (tm14)
 31486 00004C60 C3                      	retn				;AN000;
 31487                                  
 31488                                  ;***********************************************************************
 31489                                  ; $P_FileSp_Chk
 31490                                  ;
 31491                                  ; Function:  Check if the input byte is one of file special characters
 31492                                  ;
 31493                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31494                                  ;	     AL = character code to be examineed
 31495                                  ;
 31496                                  ; Output:    ZF = 1 , AL is one of special characters
 31497                                  ;***********************************************************************
 31498                                  
 31499                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31500                                  $P_FileSp_Chk:
 31501 00004C61 53                      	push	bx			;AN000;
 31502 00004C62 51                      	push	cx			;AN000;
 31503                                  	;lea	bx,[cs:$P_FileSp_Char]	;AC034; special character table
 31504 00004C63 8D1E[B986]              	lea	bx,$P_FileSp_Char
 31505 00004C67 B90900                  	mov	cx,$P_FileSp_Len ; 9
 31506                                  	;mov	cx,9			;AN000; load length of it
 31507                                  $P_FileSp_Loop: 			;AN000;
 31508 00004C6A 2E3A07                  	cmp	al,[cs:bx]		;AN000; is it one of special character ?
 31509 00004C6D 7404                    	je	short $P_FileSp_Exit	;AN000;
 31510 00004C6F 43                      	inc	bx			;AN000;
 31511 00004C70 E2F8                    	loop	$P_FileSp_Loop		;AN000;
 31512 00004C72 41                      	inc	cx			;AN000; reset ZF
 31513                                  $P_FileSp_Exit: 			;AN000;
 31514 00004C73 59                      	pop	cx			;AN000;
 31515 00004C74 5B                      	pop	bx			;AN000;
 31516 00004C75 C3                      	retn				;AN000;
 31517                                  
 31518                                  ;***********************************************************************
 31519                                  ; $P_Drive_Format;
 31520                                  ;
 31521                                  ; Function:  Check if the input string is valid drive only format.
 31522                                  ;	     And set the result buffer.
 31523                                  ;
 31524                                  ; Input:     psdata_seg:SI -> $P_STRING_BUF
 31525                                  ;	     ES:BX -> CONTROL block
 31526                                  ;
 31527                                  ; Output:    None
 31528                                  ;
 31529                                  ; Use:	$P_Fill_Result, $P_Chk_DBCS
 31530                                  ;
 31531                                  ; Vars: $P_RC(W)
 31532                                  ;***********************************************************************
 31533                                  
 31534                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31535                                  $P_Drive_Format:
 31536 00004C76 50                      	push	ax			;AN000;
 31537 00004C77 52                      	push	dx			;AN000;
 31538 00004C78 2E8A04                  	mov	al,[cs:si]		;AN000;
 31539 00004C7B 08C0                    	or	al,al			;AN000; if null string
 31540 00004C7D 7436                    	jz	short $P_Drv_Exit	;AN000; do nothing
 31541 00004C7F E81601                  	call	$P_Chk_DBCS		;AN000; is it leading byte ?
 31542 00004C82 722A                    	jc	short $P_Drv_Err	;AN000;
 31543                                  	;cmp	word [cs:si+1],3Ah ; $P_Colon  ; ':'
 31544 00004C84 2E837C013A              	cmp	word [cs:si+1],$P_Colon ;AN000; "d", ":", 0  ?
 31545 00004C89 740D                    	je	short $P_DrvF00		;AN000;
 31546                                  	;test	word [es:bx+$P_CONTROL_BLK.$P_Match_Flag],$P_Ig_Colon
 31547                                  	;test	word [es:bx],10h	;AN000; colon can be ignored?
 31548 00004C8B 26F60710                	test	byte [es:bx],$P_Ig_Colon ; 10h
 31549 00004C8F 741D                    	jz	short $P_Drv_Err	;AN000;
 31550 00004C91 2E807C0100              	cmp	byte [cs:si+1],$P_NULL	;AN000; "d", 0  ?
 31551 00004C96 7516                    	jne	short $P_Drv_Err	;AN000;
 31552                                  $P_DrvF00:				;AN000;
 31553 00004C98 0C20                    	or	al,$P_Make_Lower ; 20h	;AN000; lower case
 31554 00004C9A 3C61                    	cmp	al,"a" ; 61h            ;AN000; drive letter must
 31555 00004C9C 7210                    	jb	short $P_Drv_Err	;AN000; in range of
 31556 00004C9E 3C7A                    	cmp	al,"z" ; 7Ah            ;AN000; "a" - "z"
 31557 00004CA0 770C                    	ja	short $P_Drv_Err	;AN000; if no, error
 31558 00004CA2 2C60                    	sub	al,"a"-1  ; 60h         ;AN000; make text drive to binary drive
 31559 00004CA4 88C2                    	mov	dl,al			;AN000; set
 31560                                  	;mov	ah,$P_No_Tag ; 0FFh	;AN000;    result
 31561                                  	;mov	al,$P_Drive ; 6		;AN000; 	 buffer
 31562                                  	; 05/04/2023
 31563 00004CA6 B806FF                  	mov	ax,($P_No_Tag<<8)+$P_Drive ; 06FFh
 31564 00004CA9 E8CCF8                  	call	$P_Fill_Result		;AN000; 	       to drive
 31565 00004CAC EB07                    	jmp	short $P_Drv_Exit	;AN000;
 31566                                  $P_Drv_Err:				;AN000;
 31567 00004CAE 2EC706[E985]0900        	mov	word [cs:$P_RC],$P_Syntax
 31568                                  	;mov	word [cs:$P_RC],9	;AC034;
 31569                                  $P_Drv_Exit:				;AN000;
 31570 00004CB5 5A                      	pop	dx			;AN000;
 31571 00004CB6 58                      	pop	ax			;AN000;
 31572 00004CB7 C3                      	retn				;AN000;
 31573                                  
 31574                                  ;***********************************************************************
 31575                                  ; $P_Skip_Delim;
 31576                                  ;
 31577                                  ; Function: Skip delimiters specified in the PARMS list, white space
 31578                                  ;	    and comma.
 31579                                  ;
 31580                                  ; Input:    DS:SI -> Command String
 31581                                  ;	    ES:DI -> Parameter List
 31582                                  ;
 31583                                  ; Output:   CY = 1 if the end of line encounterd
 31584                                  ;	    CY = 0 then SI move to 1st non-delimiter character
 31585                                  ;	    AL = Last examineed character
 31586                                  ;
 31587                                  ; Use:	    $P_Chk_EOL, $P_Chk_Delim,
 31588                                  ;
 31589                                  ; Vars:     $P_Flags(R)
 31590                                  ;***********************************************************************
 31591                                  
 31592                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31593                                  
 31594                                  $P_Skip_Delim:				;AN000;
 31595                                  $P_Skip_Delim_Loop:			;AN000;
 31596 00004CB8 AC                      	lodsb				;AN000;
 31597 00004CB9 E81E00                  	call	$P_Chk_EOL		;AN000; is it EOL character ?
 31598 00004CBC 7416                    	je	short $P_Skip_Delim_CY	;AN000; if yes, exit w/ CY on
 31599                                  
 31600 00004CBE E84B00                  	call	$P_Chk_Delim		;AN000; is it one of delimiters ?
 31601 00004CC1 7514                    	jne	short $P_Skip_Delim_NCY	;AN000; if no, exit w/ CY off
 31602                                  
 31603 00004CC3 2EF606[F585]20          	test	byte [cs:$P_Flags2],$P_Extra
 31604                                  	;test	byte [cs:$P_Flags2],20h ;AC034; extra delim or comma found ?
 31605 00004CC9 74ED                    	jz	short $P_Skip_Delim_Loop
 31606                                  					;AN000; if no, loop
 31607 00004CCB 2EF606[F585]41          	test	byte [cs:$P_Flags2],$P_SW+$P_equ
 31608                                  	;;test	byte [cs:$P_Flags2],41h	;AC034; /x , or xxx=zzz , (tm08)
 31609                                  	;jz	short $P_Exit_At_Extra	;AN000; no switch, no keyword (tm08)
 31610                                  	;dec	si ; *			;AN000; backup si for next call (tm08)
 31611                                  	;;jmp	short $P_Exit_At_Extra	;AN000; else exit w/ CY off
 31612                                  	; 05/04/2023
 31613 00004CD1 7505                    	jnz	short $P_Skip_Delim_Exit ; cf = 0
 31614                                  $P_Exit_At_Extra:			;AN000;
 31615                                  	; cf = 0
 31616                                  	;clc				;AN000; indicate extra delim
 31617 00004CD3 C3                      	retn				;AN000;
 31618                                  
 31619                                  $P_Skip_Delim_CY:			;AN000;
 31620 00004CD4 F9                      	stc				;AN000; indicate EOL
 31621 00004CD5 EB01                    	jmp	short $P_Skip_Delim_Exit
 31622                                  					;AN000;
 31623                                  $P_Skip_Delim_NCY:			;AN000;
 31624 00004CD7 F8                      	clc				;AN000; indicate non delim
 31625                                  $P_Skip_Delim_Exit:			;AN000; in this case, need
 31626 00004CD8 4E                      	dec	si ; *			;AN000;  backup index pointer
 31627 00004CD9 C3                      	retn				;AN000;
 31628                                  	; 05/04/2023
 31629                                  ;$P_Exit_At_Extra:			;AN000;
 31630                                  	;clc				;AN000; indicate extra delim
 31631                                  	;retn				;AN000;
 31632                                  
 31633                                  ;***********************************************************************
 31634                                  ; $P_Chk_EOL;
 31635                                  ;
 31636                                  ; Function: Check if AL is one of End of Line characters.
 31637                                  ;
 31638                                  ; Input:    AL = character code
 31639                                  ;	    ES:DI -> Parameter List
 31640                                  ;
 31641                                  ; Output:   ZF = 1 if one of End of Line characters
 31642                                  ;***********************************************************************
 31643                                  
 31644                                  	; 05/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31645                                  
 31646                                  $P_Chk_EOL:
 31647 00004CDA 53                      	push	bx			;AN000;
 31648 00004CDB 51                      	push	cx			;AN000;
 31649 00004CDC 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; Carriage return ?
 31650 00004CDE 7429                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31651 00004CE0 3C00                    	cmp	al,$P_NULL ; 0		;AN000; zero ?
 31652 00004CE2 7425                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31653 00004CE4 26807D0202              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_EOL
 31654                                  	;cmp	byte [es:di+2],2	;AN000; EOL character specified ?
 31655 00004CE9 721E                    	jb	short $P_Chk_EOL_Exit 	;AN000;
 31656 00004CEB 31DB                    	xor	bx,bx			;AN000;
 31657 00004CED 268A5D03                	mov	bl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 31658                                  	;mov	bl,[es:di+3]		;AN000; get length of delimiter list
 31659 00004CF1 83C304                  	add	bx,$P_Len_PARMS; 4 	;AN000; skip it
 31660 00004CF4 26803900                	cmp	byte [es:bx+di],$P_I_Use_Default
 31661                                  	;cmp	byte [es:bx+di],0	;AN000; No extra EOL character ?
 31662 00004CF8 740D                    	je	short $P_Chk_EOL_NZ	;AN000;
 31663 00004CFA 31C9                    	xor	cx,cx			;AN000; Get number of extra chcracter
 31664 00004CFC 268A09                  	mov	cl,[es:bx+di]		;AN000;
 31665                                  $P_Chk_EOL_Loop:			;AN000;
 31666 00004CFF 43                      	inc	bx			;AN000;
 31667 00004D00 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra EOL character
 31668 00004D03 7404                    	je	short $P_Chk_EOL_Exit 	;AN000;
 31669 00004D05 E2F8                    	loop	$P_Chk_EOL_Loop 	;AN000;
 31670                                  $P_Chk_EOL_NZ:				;AN000;
 31671 00004D07 3C0D                    	cmp	al,$P_CR ; 0Dh		;AN000; reset ZF
 31672                                  $P_Chk_EOL_Exit:			;AN000;
 31673 00004D09 59                      	pop	cx			;AN000;
 31674 00004D0A 5B                      	pop	bx			;AN000;
 31675 00004D0B C3                      	retn				;AN000;
 31676                                  
 31677                                  ;***********************************************************************
 31678                                  ; $P_Chk_Delim;
 31679                                  ;
 31680                                  ; Function: Check if AL is one of delimiter characters.
 31681                                  ;	    if AL+[si] is DBCS blank, it is replaced with two SBCS
 31682                                  ;	    blanks.
 31683                                  ;
 31684                                  ; Input:    AL = character code
 31685                                  ;	    DS:SI -> Next Character
 31686                                  ;	    ES:DI -> Parameter List
 31687                                  ;
 31688                                  ; Output:   ZF = 1 if one of delimiter characters
 31689                                  ;	    SI points to the next character
 31690                                  ; Vars:  $P_Terminator(W), $P_Flags(W)
 31691                                  ;***********************************************************************
 31692                                  
 31693                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31694                                  
 31695                                  $P_Chk_Delim:
 31696 00004D0C 53                      	push	bx			;AN000;
 31697 00004D0D 51                      	push	cx			;AN000;
 31698 00004D0E 2EC606[EF85]20          	mov	byte [cs:$P_Terminator],$P_Space ; 20h
 31699                                  					;AC034; Assume terminated by space
 31700 00004D14 2E8026[F585]DF          	and	byte [cs:$P_Flags2],0FFh-$P_Extra ; 0DFh
 31701                                  					;AC034;
 31702 00004D1A 3C20                    	cmp	al,$P_Space ; 20h ; ' '	;AN000; Space ?
 31703 00004D1C 7436                    	je	short $P_Chk_Delim_Exit	;AN000;
 31704                                  
 31705 00004D1E 3C09                    	cmp	al,$P_TAB ; 09h		;AN000; TAB ?
 31706 00004D20 7432                    	je	short $P_Chk_Delim_Exit	;AN000;
 31707                                  
 31708 00004D22 3C2C                    	cmp	al,$P_Comma  ; ',' 	;AN000; Comma ?
 31709 00004D24 7431                    	je	short $P_Chk_Delim_Exit0
 31710                                  					;AN000;
 31711                                  $P_Chk_Delim00: 			;AN000;
 31712 00004D26 3C20                    	cmp	al,20h ; $P_DBSP1	;AN000; 1st byte of DBCS Space ?
 31713 00004D28 750C                    	jne	short $P_Chk_Delim01	;AN000;
 31714 00004D2A 803C20                  	cmp	byte [si],20h ; $P_DBSP2
 31715                                  					;AN000; 2nd byte of DBCS Space ?
 31716 00004D2D 7507                    	jne	short $P_Chk_Delim01	;AN000;
 31717 00004D2F B020                    	mov	al,$P_Space ; 20h	;AN000;
 31718 00004D31 46                      	inc	si			;AN000; make si point to next character
 31719 00004D32 38C0                    	cmp	al,al			;AN000; Set ZF
 31720 00004D34 EB1E                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 31721                                  
 31722                                  $P_Chk_Delim01: 			;AN000;
 31723                                  	;cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],$P_I_Have_Delim
 31724 00004D36 26807D0201              	cmp	byte [es:di+$P_PARMS_BLK.$P_Num_Extra],1
 31725                                  	;cmp	byte [es:di+2],1	;AN000; delimiter character specified ?
 31726 00004D3B 7217                    	jb	short $P_Chk_Delim_Exit	;AN000;
 31727                                  
 31728 00004D3D 31C9                    	xor	cx,cx			;AN000;
 31729 00004D3F 268A4D03                	mov	cl,[es:di+$P_PARMS_BLK.$P_Len_Extra_Delim]
 31730                                  	;mov	cl,[esi:di+3]		;AN000; get length of delimiter list
 31731 00004D43 09C9                    	or	cx,cx			;AN000; No extra Delim character ?
 31732 00004D45 740B                    	jz	short $P_Chk_Delim_NZ	;AN000;
 31733                                  
 31734 00004D47 BB0300                  	mov	bx,$P_Len_PARMS-1 ; 3	;AN000; set bx to 1st extra delimiter
 31735                                  $P_Chk_Delim_Loop:			;AN000;
 31736 00004D4A 43                      	inc	bx			;AN000;
 31737 00004D4B 263A01                  	cmp	al,[es:bx+di]		;AN000; Check extra Delim character
 31738 00004D4E 7407                    	je	short $P_Chk_Delim_Exit0
 31739                                  					;AN000;
 31740 00004D50 E2F8                    	loop	$P_Chk_Delim_Loop	;AN000; examine all extra delimiter
 31741                                  
 31742                                  $P_Chk_Delim_NZ:			;AN000;
 31743 00004D52 3C20                    	cmp	al,$P_Space ; 20h	;AN000; reset ZF
 31744                                  $P_Chk_Delim_Exit:			;AN000;
 31745 00004D54 59                      	pop	cx			;AN000;
 31746 00004D55 5B                      	pop	bx			;AN000;
 31747 00004D56 C3                      	retn				;AN000;
 31748                                  
 31749                                  $P_Chk_Delim_Exit0:			;AN000;
 31750 00004D57 2EA2[EF85]              	mov	[cs:$P_Terminator],al	;AC034; keep terminated delimiter
 31751 00004D5B 2EF606[F585]01          	test	byte [cs:$P_Flags2],$P_equ
 31752                                  	;test	byte [cs:$P_Flags2],1	;AN027;AC034;; if terminating a key=
 31753 00004D61 7506                    	jnz	short $P_No_Set_Extra 	;AN027; then do not set the EXTRA bit
 31754                                  
 31755 00004D63 2E800E[F585]20          	or	byte [cs:$P_Flags2],$P_Extra ; 20h
 31756                                  	;or	byte [cs:$P_Flags2],20h	;AC034; flag terminated extra delimiter or comma
 31757                                  $P_No_Set_Extra:			;AN027;
 31758 00004D69 38C0                    	cmp	al,al			;AN000; set ZF
 31759 00004D6B EBE7                    	jmp	short $P_Chk_Delim_Exit ;AN000;
 31760                                  
 31761                                  ;***********************************************************************
 31762                                  ; $P_Chk_Switch;
 31763                                  ;
 31764                                  ; Function: Check if AL is the switch character not in first position of
 31765                                  ;	    $P_STRING_BUF
 31766                                  ;
 31767                                  ; Input:    AL = character code
 31768                                  ;	    BX = current pointer within $P_String_Buf
 31769                                  ;	    SI =>next char on command line (following the one in AL)
 31770                                  ;
 31771                                  ; Output:   CF = 1 (set)if AL is switch character, and not in first
 31772                                  ;		 position, and has no chance of being part of a date string,
 31773                                  ;		 i.e. should be treated as a delimiter.
 31774                                  ;
 31775                                  ;	    CF = 0 (reset, cleared) if AL is not a switch char, is in the first
 31776                                  ;		 position, or is a slash but may be part of a date string, i.e.
 31777                                  ;		 should not be treated as a delimiter.
 31778                                  ;
 31779                                  ; Vars:  $P_Terminator(W)
 31780                                  ;
 31781                                  ; Use:	 $P_0099
 31782                                  ;***********************************************************************
 31783                                  
 31784                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31785                                  
 31786                                  $P_Chk_Switch:
 31787                                  	; 18/04/2023
 31788 00004D6D 8D2E[FE85]              	lea	bp,$P_STRING_BUF	;AN020;AC034; BP=OFFSET of $P_String_Buf even in group addressing
 31789                                  
 31790 00004D71 39EB                    	cmp	bx,bp			;AN000;
 31791 00004D73 7418                    	je	short $P_STRUC_L2	;AN000;
 31792                                  
 31793 00004D75 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 31794 00004D77 7512                    	jne	short $P_STRUC_L5	;AN000;
 31795                                  
 31796 00004D79 F9                      	stc				;AN020;not in first position and is slash, now see if might be in date string
 31797 00004D7A 50                      	push	ax			;AN020;save input char
 31798 00004D7B 2E8A47FF                	mov	al,[cs:bx-1]		;AN026;AL=char before the current char
 31799 00004D7F E804FB                  	call	$P_0099 		;AN020;return carry set if not numeric
 31800 00004D82 7205                    	jc	short $P_STRUC_L7	;AN000;
 31801                                  
 31802 00004D84 8A04                    	mov	al,[si]			;AN020;AL=char after the current char
 31803 00004D86 E8FDFA                  	call	$P_0099			;AN020;return carry set if not numeric
 31804                                  $P_STRUC_L7:				;AN000;
 31805 00004D89 58                      	pop	ax			;AN020;restore AL to input char
 31806                                  	;jmp	short $P_STRUC_L1	;AN000;
 31807                                  	; 18/04/2023
 31808 00004D8A C3                      	retn
 31809                                  
 31810                                  $P_STRUC_L5:				;AN000;
 31811 00004D8B F8                      	clc				;AN020;not a slash
 31812                                  	;jmp	short $P_STRUC_L1	;AN000;
 31813                                  	 ;18/04/2023
 31814 00004D8C C3                      	retn
 31815                                  
 31816                                  $P_STRUC_L2:				;AN000;
 31817 00004D8D 3C2F                    	cmp     al,$P_Switch ; '/'	;AN000;
 31818                                  	;jne	short $P_STRUC_L12	;AN000;
 31819                                  	; 18/04/2023
 31820 00004D8F 75FA                    	jne	short $P_STRUC_L5
 31821                                  
 31822 00004D91 2E800E[F585]40          	or	byte [cs:$P_Flags2],$P_SW
 31823                                  	;or	byte [cs:$P_Flags2],40h	;AN020;AC034;;could be valid switch, first char and is slash
 31824                                  	; 18/04/2023
 31825                                  ;$P_STRUC_L12:				;AN000;
 31826                                  	;clc				;AN020;CF=0 indicating first char
 31827                                  $P_STRUC_L1:				;AN000;
 31828 00004D97 C3                      	retn				;AN000;
 31829                                  
 31830                                  ;**************************************************************************
 31831                                  ; $P_Chk_DBCS:
 31832                                  ;
 31833                                  ;  Function: Check if a specified byte is in ranges of the DBCS lead bytes
 31834                                  ;
 31835                                  ;  Input:
 31836                                  ;	  AL	= Code to be examineed
 31837                                  ;
 31838                                  ;  Output:
 31839                                  ;	  If CF is on then a lead byte of DBCS
 31840                                  ;
 31841                                  ; Use: INT 21h w/AH=63
 31842                                  ;
 31843                                  ; Vars:  $P_DBCSEV_Seg(RW), $P_DBCSEV_Off(RW)
 31844                                  ;***************************************************************************
 31845                                  
 31846                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31847                                  
 31848                                  $P_Chk_DBCS:
 31849 00004D98 1E                      	push	ds			;AN000;
 31850 00004D99 56                      	push	si			;AN000;
 31851 00004D9A 53                      	push	bx			;AN000; (tm11)
 31852 00004D9B 2E833E[F285]00          	cmp	word [cs:$P_DBCSEV_SEG],0
 31853                                  					;AC034; ALREADY SET ?
 31854 00004DA1 7527                    	jne	short $P_DBCS00		;AN000;
 31855 00004DA3 50                      	push	ax			;AN000;
 31856 00004DA4 1E                      	push	ds			;AN000; (tm11)
 31857 00004DA5 51                      	push	cx			;AN000;
 31858 00004DA6 52                      	push	dx			;AN000;
 31859 00004DA7 57                      	push	di			;AN000;
 31860 00004DA8 55                      	push	bp			;AN000;
 31861 00004DA9 06                      	push	es			;AN000;
 31862 00004DAA 31F6                    	xor	si,si			;AN000;
 31863 00004DAC 8EDE                    	mov	ds,si			;AN000;
 31864                                  	;mov	ax,$P_DOS_GetEV 	;AN000; GET DBCS EV CALL
 31865 00004DAE B80063                  	mov	ax,6300h
 31866 00004DB1 CD21                    	int	21h			;AN000;
 31867 00004DB3 8CDB                    	mov	bx,ds			;AN000; (tm11)
 31868 00004DB5 09DB                    	or	bx,bx			;AN000; (tm11)
 31869 00004DB7 07                      	pop	es			;AN000;
 31870 00004DB8 5D                      	pop	bp			;AN000;
 31871 00004DB9 5F                      	pop	di			;AN000;
 31872 00004DBA 5A                      	pop	dx			;AN000;
 31873 00004DBB 59                      	pop	cx			;AN000;
 31874 00004DBC 1F                      	pop	ds			;AN000; (tm11)
 31875 00004DBD 58                      	pop	ax			;AN000;
 31876 00004DBE 7429                    	jz	short $P_NON_DBCS	;AN000;
 31877                                  $P_DBCS02:				;AN000;
 31878 00004DC0 2E8936[F085]            	mov	[cs:$P_DBCSEV_OFF],si	;AC034; save EV offset
 31879 00004DC5 2E891E[F285]            	mov	[cs:$P_DBCSEV_SEG],bx	;AC034; save EV segment (tm11)
 31880                                  $P_DBCS00:				;AN000;
 31881 00004DCA 2E8B36[F085]            	mov	si,[cs:$P_DBCSEV_OFF]	;AC034; load EV offset
 31882 00004DCF 2E8E1E[F285]            	mov	ds,[cs:$P_DBCSEV_SEG]	;AC034; and segment
 31883                                  $P_DBCS_LOOP:				;AN000;
 31884 00004DD4 833C00                  	cmp	word [si],0 		;AN000; zero vector ?
 31885 00004DD7 7410                    	je	short $P_NON_DBCS	;AN000; then exit
 31886 00004DD9 3A04                    	cmp	al,[si] 		;AN000;
 31887 00004DDB 7208                    	jb	short $P_DBCS01		;AN000; Check if AL is in
 31888 00004DDD 3A4401                  	cmp	al,[si+1]		;AN000;   range of
 31889 00004DE0 7703                    	ja	short $P_DBCS01		;AN000;      the vector
 31890 00004DE2 F9                      	stc				;AN000; if yes, indicate DBCS and exit
 31891 00004DE3 EB04                    	jmp	short $P_DBCS_EXIT	;AN000;
 31892                                  $P_DBCS01:				;AN000;
 31893 00004DE5 46                      	inc	si			;AC035; add '2' to
 31894 00004DE6 46                      	inc	si			;AC035;  SI reg
 31895                                  					;AN000; get next vector
 31896 00004DE7 EBEB                    	jmp	short $P_DBCS_LOOP	;AN000; loop until zero vector found
 31897                                  
 31898                                  $P_NON_DBCS:				;AN000;
 31899                                  	; 18/04/2023
 31900                                  	; cf=0
 31901                                  	;clc				;AN000; indicate SBCS
 31902                                  $P_DBCS_EXIT:				;AN000;
 31903 00004DE9 5B                      	pop	bx			;AN000; (tm11)
 31904 00004DEA 5E                      	pop	si			;AN000;
 31905 00004DEB 1F                      	pop	ds			;AN000;
 31906 00004DEC C3                      	retn				;AN000;
 31907                                  
 31908                                  ;============================================================================
 31909                                  ; TPARSE.ASM, MSDOS 6.0, 1991
 31910                                  ;============================================================================
 31911                                  ; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31912                                  
 31913                                  ; ****************************************************************
 31914                                  ; *
 31915                                  ; * ROUTINE:	 CMD_PARSE
 31916                                  ; *
 31917                                  ; * FUNCTION:	 Interface for transient COMMAND to invoke
 31918                                  ; *		 SYSPARSE.
 31919                                  ; *
 31920                                  ; * INPUT:	 inputs to SYSPARSE
 31921                                  ; *
 31922                                  ; * OUTPUT:	 outputs from SYSPARSE
 31923                                  ; *
 31924                                  ; ****************************************************************
 31925                                  
 31926                                  	; 06/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31927                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:4FF7h
 31928                                  ;cmd_parse:
 31929                                  	;call	sysparse		;AN000;
 31930                                  	;retn				;AN000;
 31931                                  	; 06/04/2023
 31932                                  	;jmp	sysparse
 31933                                  
 31934                                  append_parse:
 31935 00004DED E840F5                  	call	sysparse		;AN010;
 31936 00004DF0 CB                      	retf				;AN010;
 31937                                  
 31938                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 31939                                  %if 0
 31940                                  
 31941                                  ;============================================================================
 31942                                  ; NPRINTF.ASM, PRINTF.ASM, MSDOS 3.3, 1987
 31943                                  ;============================================================================
 31944                                  ; 30/09/2018 - Retro DOS v3.0
 31945                                  
 31946                                  ; BREAK	<Message Printing Routine>
 31947                                  
 31948                                  ;
 31949                                  ;	MSDOS V3.00 PRINT
 31950                                  ;
 31951                                  ;	Message Printing Routine
 31952                                  ;
 31953                                  
 31954                                  ;PRINTF.ASM (MSDOS 3.3, LIBC)
 31955                                  ;
 31956                                  ;TITLE   PRINTF ROUTINE FOR MS-DOS
 31957                                  ;
 31958                                  ; PRINTF(Control String, arg1, arg2,...,argn-1,argn)
 31959                                  ;
 31960                                  ; Characters are output to PFHandle according to the
 31961                                  ; specifications contained in the Control String.
 31962                                  ;
 31963                                  ; The conversion characters are as follow:
 31964                                  ;
 31965                                  ;               %c - output the next argument as a character
 31966                                  ;               %s - output the next argument as a string
 31967                                  ;               %x - output the next argument as a hexidecimal number
 31968                                  ;                    using abcedf
 31969                                  ;               %X - output the next argument as a hexidecimal number
 31970                                  ;                    using ABCDEF
 31971                                  ;               %d - output the next argument as a decimal number
 31972                                  ;
 31973                                  ;
 31974                                  ; Other format specifiers that may precede the conversion character are:
 31975                                  ;
 31976                                  ;               - (minus sign) - causes the field to be left-adjusted
 31977                                  ;               + (plus sign)  - causes the field to be right-adjusted (default)
 31978                                  ;               n - digit specifing the minimum field width (default to 1)
 31979                                  ;               L - specifing a long integer
 31980                                  ;
 31981                                  ;   On entry to PRINTF the stack contains the return address and a pointer
 31982                                  ;   to an argument list.
 31983                                  ;
 31984                                  ;   ____________________
 31985                                  ;   |   Ret Addr       |      <= SP
 31986                                  ;   --------------------
 31987                                  ;   |  Ptr to Arg List |
 31988                                  ;   --------------------
 31989                                  ;
 31990                                  ;   And the argument list contains the following:
 31991                                  ;
 31992                                  ;       String_ptr                  (a pointer to the control string)
 31993                                  ;       Arg 1
 31994                                  ;       Arg 2
 31995                                  ;         .
 31996                                  ;         .
 31997                                  ;         .
 31998                                  ;       Arg n-1
 31999                                  ;       Arg n
 32000                                  ;
 32001                                  ;   If the argument is a %s or %c the arg contains a pointer to the string
 32002                                  ;   or character.
 32003                                  ;
 32004                                  ;   The arguments are used in one-to-one correspondence to % specifiers.
 32005                                  
 32006                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34E0h
 32007                                  
 32008                                  ; =============== S U B	R O U T	I N E =======================================
 32009                                  
 32010                                  PRINTF_INIT:
 32011                                  	call	STD_PRINTF
 32012                                  	retf
 32013                                  
 32014                                  ; =============== S U B	R O U T	I N E =======================================
 32015                                  
 32016                                  PRINTF_CRLF:
 32017                                  	call	STD_PRINTF
 32018                                  	;call	CRLF2
 32019                                  	;retn
 32020                                  	; 07/04/2023
 32021                                  	jmp	CRLF2
 32022                                  
 32023                                  ; =============== S U B	R O U T	I N E =======================================
 32024                                  
 32025                                  STD_EPRINTF:
 32026                                  	mov	word [cs:PRINTF_HANDLE],2
 32027                                  	jmp	short new_printf
 32028                                  
 32029                                  ; =============== S U B	R O U T	I N E =======================================
 32030                                  
 32031                                  STD_PRINTF:
 32032                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 34F4h
 32033                                  
 32034                                  	mov	word [cs:PRINTF_HANDLE],1
 32035                                  NEW_PRINTF:				;Save the callers' registers
 32036                                  	cld
 32037                                  	push	dx
 32038                                  	push	bp
 32039                                  	mov	bp,sp
 32040                                  	push	cx
 32041                                  	push	bx
 32042                                  	push	ax
 32043                                  	push	di
 32044                                  	push	si
 32045                                  	push	es
 32046                                  	push	ds
 32047                                  	push	cs
 32048                                  	pop	es		;ES points to Printf segment
 32049                                  	mov	di,PRINTF_BUF	;DI points to the output buffer
 32050                                  	mov	bp,[bp+2]  ; dx ;BP points to the argument list
 32051                                  	;mov	si,[ds:bp+0]	;SI points to the control string
 32052                                  	mov	si,[ds:bp] ; bp
 32053                                  	add	bp,2
 32054                                  	xor	bx,bx
 32055                                  	call	CLEAR_FLAGS	; initialize the world
 32056                                  
 32057                                  GET_CHAR:
 32058                                  	lodsb			;Get a character
 32059                                  	cmp	al,'%'		;Is it a conversion specifier?
 32060                                  	jz	short CONV_CHAR	;Yes - find out which one
 32061                                  	or	al,al		;Is it the end of the control string?
 32062                                  	jz	short PRINTF_DONE ;Yes - then we're done
 32063                                  PRINTF_PERCENT:				
 32064                                  	call	OUTCHR		;Otherwise store the character
 32065                                  	jmp	short GET_CHAR	;And go get another
 32066                                  
 32067                                  PRINTF_DONE:
 32068                                  	call	FLUSH
 32069                                  	pop	ds
 32070                                  	pop	es
 32071                                  	pop	si
 32072                                  	pop	di
 32073                                  	pop	ax
 32074                                  	pop	bx
 32075                                  	pop	cx
 32076                                  	pop	bp
 32077                                  	pop	dx
 32078                                  	retn
 32079                                  
 32080                                  CONV_CHAR:
 32081                                  	mov	byte [cs:PRINTF_LEFT],0
 32082                                  
 32083                                  NXT_CONV_CHAR:	
 32084                                  	;Look for any format specifiers preceeding the conversion character
 32085                                  	lodsb
 32086                                  	cmp	al,'%'			;Just print the %
 32087                                  	jz	short PRINTF_PERCENT
 32088                                  	cmp	al,[cs:CHAR_SUB] ; "-"	;Right justify the field	
 32089                                  	jz	short LEFT_ADJ
 32090                                  	cmp	al,[cs:PLUS_CHR] ; "+"	;Left justify the field
 32091                                  	jz	short CONV_CHAR
 32092                                  	cmp	al,[cs:CHAR_L]	 ; "L"	;Is it a long integer
 32093                                  	jz	short LONG_INT
 32094                                  	cmp	al,[cs:char_l]	 ; "l"		
 32095                                  	jz	short LONG_INT
 32096                                  	cmp	al,'0'			;Is it a precision specification
 32097                                  	jb	short LOOK_CONV_CHAR
 32098                                  	cmp	al,'9'
 32099                                  	ja	short LOOK_CONV_CHAR
 32100                                  	cmp	al,'0'
 32101                                  	jnz	short NOT_PAD
 32102                                  	cmp	word [cs:PRINTF_WIDTH],0
 32103                                  	jnz	short NOT_PAD
 32104                                  	mov	ah,'0'
 32105                                  	mov	[cs:PAD_CHAR],ah
 32106                                  NOT_PAD:					;Adjust decimal place on precision
 32107                                  	push	ax
 32108                                  	mov	ax,[cs:PRINTF_WIDTH]
 32109                                  	mov	cx,10
 32110                                  	mul	cx
 32111                                  	pop	dx
 32112                                  	xor	dh,dh
 32113                                  	sub	dl,'0'
 32114                                  	add	ax,dx
 32115                                  	mov	[cs:PRINTF_WIDTH],ax	;And save the total
 32116                                  	jmp	short NXT_CONV_CHAR
 32117                                  
 32118                                  LEFT_ADJ:
 32119                                  	mov	byte [cs:PRINTF_LEFT],1
 32120                                  	jmp	short NXT_CONV_CHAR
 32121                                  
 32122                                  LONG_INT:
 32123                                  	or	byte [cs:PRINTF_LONG],1
 32124                                  	jmp	short NXT_CONV_CHAR
 32125                                  
 32126                                  LOOK_CONV_CHAR:
 32127                                  	and	al,0DFh
 32128                                  	cmp	al,[cs:CHAR_X]	 ; "X"
 32129                                  	jz	short HEX_UP
 32130                                  	cmp	al,[cs:CHAR_D]	 ; "D"
 32131                                  	jz	short DECIMAL
 32132                                  	cmp	al,[cs:CHAR_C]	 ; "C"
 32133                                  	jz	short C_PUT_CHAR
 32134                                  	cmp	al,[cs:CHAR_S]	 ; "S"
 32135                                  	jz	short S_PUT_STRG
 32136                                  	call	CLEAR_FLAGS
 32137                                  	jmp	GET_CHAR
 32138                                  
 32139                                  HEX_UP:
 32140                                  	mov	word [cs:PRINTF_BASE],16 ;Hex conversion
 32141                                  	jmp	short CONV_TO_NUM
 32142                                  DECIMAL:
 32143                                  	mov	word [cs:PRINTF_BASE],10 ;Decimal conversion
 32144                                  	jmp	short CONV_TO_NUM
 32145                                  
 32146                                  C_PUT_CHAR:
 32147                                  	call	NEXT_CHRS
 32148                                  	mov	al,dl
 32149                                  	call	OUTCHR
 32150                                  	call	CLEAR_FLAGS
 32151                                  	jmp	GET_CHAR
 32152                                  
 32153                                  S_PUT_STRG:
 32154                                  	push	si			;Save pointer to control string
 32155                                  	call	NEXT_CHRS
 32156                                  	mov	si,dx
 32157                                  S_PUT_1:
 32158                                  	mov	cx,[cs:PRINTF_WIDTH]
 32159                                  	or	cx,cx
 32160                                  	jz	short S_PUT_2
 32161                                  	cmp	byte [cs:PRINTF_LEFT],0
 32162                                  	jnz	short S_PUT_2
 32163                                  	call	PAD_STRING
 32164                                  S_PUT_2:
 32165                                  	push	si
 32166                                  S_PUT_3:
 32167                                  	lodsb
 32168                                  	or	al,al
 32169                                  	jz	short S_PUT_4
 32170                                  	call	OUTCHR			;Put it into our buffer
 32171                                  	jmp	short S_PUT_3
 32172                                  S_PUT_4:
 32173                                  	pop	si
 32174                                  	cmp	byte [cs:PRINTF_LEFT],0
 32175                                  	jz	short C_S_END
 32176                                  	mov	cx,[cs:PRINTF_WIDTH]
 32177                                  	or	cx,cx
 32178                                  	jz	short C_S_END
 32179                                  	call	PAD_STRING
 32180                                  C_S_END:
 32181                                  	pop	si			;Restore control string pointer
 32182                                  	call	CLEAR_FLAGS
 32183                                  	jmp	GET_CHAR		;Go get another character	
 32184                                  
 32185                                  
 32186                                  ; =============== S U B	R O U T	I N E =======================================
 32187                                  
 32188                                  PAD_STRING:
 32189                                  	xor	dx,dx
 32190                                  	push	si
 32191                                  
 32192                                  COUNT_LOOP:
 32193                                  	lodsb
 32194                                  	or	al,al
 32195                                  	jz	short COUNT_DONE
 32196                                  	inc	dx
 32197                                  	jmp	short COUNT_LOOP
 32198                                  
 32199                                  COUNT_DONE:
 32200                                  	pop	si
 32201                                  	sub	cx,dx
 32202                                  	jbe	short COUNT_RET
 32203                                  	call	PAD
 32204                                  
 32205                                  COUNT_RET:
 32206                                  	retn
 32207                                  
 32208                                  ; ---------------------------------------------------------------------------
 32209                                  
 32210                                  CONV_TO_NUM:
 32211                                  	call	NEXT_CHRS
 32212                                  	mov	ax,dx
 32213                                  	xor	dx,dx
 32214                                  	cmp	byte [cs:PRINTF_LONG],0 
 32215                                  			;Is this is a short or long integer?
 32216                                  	jz	short NOT_LONG_INT
 32217                                  	call	NEXT_CHRS
 32218                                  
 32219                                  NOT_LONG_INT:
 32220                                  	push	bx
 32221                                  	push	si
 32222                                  	mov	si,[cs:PRINTF_BASE]
 32223                                  	mov	cx,[cs:PRINTF_WIDTH]
 32224                                  	call	PNUM
 32225                                  	pop	si
 32226                                  	pop	bx
 32227                                  	call	PAD
 32228                                  	call	CLEAR_FLAGS
 32229                                  	jmp	GET_CHAR
 32230                                  
 32231                                  
 32232                                  ; =============== S U B	R O U T	I N E =======================================
 32233                                  
 32234                                  PNUM:
 32235                                  	dec	cx
 32236                                  	push	ax
 32237                                  	mov	ax,dx
 32238                                  	xor	dx,dx
 32239                                  	div	si
 32240                                  	mov	bx,ax
 32241                                  	pop	ax
 32242                                  	div	si
 32243                                  	xchg	bx,dx
 32244                                  	push	ax
 32245                                  	or	ax,dx
 32246                                  	pop	ax
 32247                                  	jz	short DO_PAD
 32248                                  	push	bx
 32249                                  	call	PNUM
 32250                                  	pop	bx
 32251                                  	jmp	short REM
 32252                                  
 32253                                  DO_PAD:
 32254                                  	cmp	byte [cs:PRINTF_LEFT],0
 32255                                  	jnz	short REM
 32256                                  	call	PAD
 32257                                  REM:
 32258                                  	cmp	bl,10
 32259                                  	jb	short NOT_HEX
 32260                                  	add	bx,6
 32261                                  NOT_HEX:
 32262                                  	mov	al,byte [cs:PRINTF_TABLE+bx] ; "0123456789ABCDEF"
 32263                                  	push	cx
 32264                                  	call	OUTCHR
 32265                                  	pop	cx
 32266                                  	retn
 32267                                  
 32268                                  ; =============== S U B	R O U T	I N E =======================================
 32269                                  
 32270                                  PAD:
 32271                                  	or	cx,cx
 32272                                  	jle	short PAD_DONE
 32273                                  	mov	al,[cs:PAD_CHAR]
 32274                                  PAD_LOOP:
 32275                                  	push	cx
 32276                                  	call	OUTCHR
 32277                                  	pop	cx
 32278                                  	loop	PAD_LOOP
 32279                                  PAD_DONE:
 32280                                  	retn
 32281                                  
 32282                                  ; =============== S U B	R O U T	I N E =======================================
 32283                                  
 32284                                  OUTCHR:
 32285                                  	stosb
 32286                                  	cmp	di,PRINTF_BUF_END ; SRCXNAME
 32287                                  	je	short FLUSH
 32288                                  OUTCHR_RETN:
 32289                                  	retn
 32290                                  
 32291                                  ; =============== S U B	R O U T	I N E =======================================
 32292                                  
 32293                                  FLUSH:
 32294                                  	mov	cx,PRINTF_BUF
 32295                                  	xchg	cx,di
 32296                                  	sub	cx,di
 32297                                  	jz	short OUTCHR_RETN
 32298                                  WRITE_CHARS:
 32299                                  	push	bx
 32300                                  	mov	bx,[cs:PRINTF_HANDLE]
 32301                                  	push	ds
 32302                                  	push	cs
 32303                                  	pop	ds
 32304                                  	mov	dx,PRINTF_BUF
 32305                                  	mov	ah,Write ; 40h
 32306                                  	int	21h		; DOS -	2+ - WRITE TO FILE WITH	HANDLE
 32307                                  				; BX = file handle, CX = number	of bytes to write,
 32308                                  				; DS:DX -> buffer
 32309                                  	jnb	short FOOB2_1
 32310                                  	call	GET_EXT_ERR_NUMBER
 32311                                  	cmp	ax,6
 32312                                  	jz	short FOOB2_4
 32313                                  	jmp	short FOOB2_2
 32314                                  
 32315                                  FOOB2_1:
 32316                                  	cmp	cx,ax
 32317                                  	jz	short FOOB2_4
 32318                                  FOOB2_2:
 32319                                  	mov	bx,dx
 32320                                  	add	bx,ax
 32321                                  	cmp	byte [bx],1Ah
 32322                                  	jz	short FOOB2_4
 32323                                  	pop	ds
 32324                                  	pop	bx
 32325                                  	mov	es,[cs:RESSEG]
 32326                                  	mov	dx,NOSPACEPTR
 32327                                  	test	byte [es:PIPEFLAG],0FFh
 32328                                  	jz	short PRINT_ERR_EXIT
 32329                                  	call	PIPEOFF
 32330                                  	mov	dx,PIPEEMESPTR
 32331                                  PRINT_ERR_EXIT:	
 32332                                  	jmp	CERROR
 32333                                  
 32334                                  FOOB2_4:
 32335                                  	pop	ds
 32336                                  	pop	bx
 32337                                  	retn
 32338                                  
 32339                                  ; =============== S U B	R O U T	I N E =======================================
 32340                                  
 32341                                  NEXT_CHRS:
 32342                                  	push	si		;Save pointer to control string
 32343                                  	mov	si,bx		;Get index into argument list
 32344                                  	add	bx,2		;Increment the index
 32345                                  	mov	si,[ds:bp+si]	; Get pointer to next argument
 32346                                  	mov	dx,[si]		; Get (address of the) next argument			
 32347                                  	pop	si
 32348                                  	retn
 32349                                  
 32350                                  ; =============== S U B	R O U T	I N E =======================================
 32351                                  
 32352                                  CLEAR_FLAGS:
 32353                                  	xor	ax,ax
 32354                                  	mov	[cs:PRINTF_LEFT],al	;Reset justifing flag
 32355                                  	mov	[cs:PRINTF_LONG],al	;Reset long flag
 32356                                  	mov	[cs:PRINTF_WIDTH],ax	;Reinitialize width to 0
 32357                                  	mov	al,' '			
 32358                                  	mov	[cs:PAD_CHAR],al 	;Reset padding character
 32359                                  	retn
 32360                                  
 32361                                  ; ---------------------------------------------------------------------------
 32362                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3729h
 32363                                  
 32364                                  	; times 7 db 0
 32365                                  
 32366                                  %endif
 32367                                  
 32368                                  ;============================================================================
 32369                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 32370                                  ;============================================================================
 32371                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32372                                  
 32373                                  ; ----------------------------
 32374                                  ; MSDOS 6.0, MSGSERV.ASM, 1991
 32375                                  ; ----------------------------
 32376                                  
 32377                                  ;; Replacable parameters are described by a sublist structure
 32378                                  
 32379                                  struc $M_SUBLIST_STRUC		;;AN000;;
 32380 00000000 ??                       .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32381 00000001 ??                       .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32382 00000002 ????????                 .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32383 00000006 ??                       .$M_S_ID:	resb 1		;;AN000;; n of %n
 32384 00000007 ??                       .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32385 00000008 ??                       .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32386 00000009 ??                       .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32387 0000000A ??                       .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32388                                  endstruc
 32389                                  
 32390                                  ; ---------------------------------------------------------------------------
 32391                                  ; ---------------------------------------------------------------------------
 32392                                  
 32393                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32394                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 4FFFh
 32395                                  
 32396                                  Printf_Init:
 32397 00004DF1 E80F00                  	call	std_printf
 32398 00004DF4 CB                      	retf
 32399                                  
 32400                                  Printf_Crlf:
 32401 00004DF5 E80B00                  	call	std_printf
 32402                                  	;call	CRLF2
 32403                                  	;retn
 32404                                  	; 07/04/2023
 32405 00004DF8 E9CFD7                  	jmp	CRLF2
 32406                                  
 32407                                  
 32408                                  ;****************************************************************
 32409                                  ;*
 32410                                  ;* ROUTINE:	STD_PRINTF/STD_EPRINTF
 32411                                  ;*
 32412                                  ;* FUNCTION:	Set up to print out a message using SYSDISPMSG.
 32413                                  ;*		Set up substitutions if utility message.  Make
 32414                                  ;*		sure any changes to message variables in TDATA
 32415                                  ;*		are reset to avoid reloading the transient.
 32416                                  ;*
 32417                                  ;* INPUT:	Msg_Disp_Class	-  set to message class
 32418                                  ;*		Msg_Cont_Flag	-  set to control flags
 32419                                  ;*		DS	points to transient segment
 32420                                  ;*
 32421                                  ;*		if utility message:
 32422                                  ;*		DX	points to a block with message number
 32423                                  ;*			(word), number of substitutions (byte),
 32424                                  ;*			followed by substitution list if there
 32425                                  ;*			are substitutions.  If substitutions
 32426                                  ;*			are not in transient segment they must
 32427                                  ;*			be set.
 32428                                  ;*		else
 32429                                  ;*		AX	set to message number
 32430                                  ;*
 32431                                  ;* OUTPUT:	none
 32432                                  ;*
 32433                                  ;****************************************************************
 32434                                  
 32435                                  std_eprintf:
 32436 00004DFB C706[C887]0200          	mov	word [PRINTF_HANDLE],2 		;AC000;Print to STDERR
 32437 00004E01 EB06                    	jmp	short new_printf		;AC000;
 32438                                  
 32439                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32440                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 5012h
 32441                                  
 32442                                  std_printf:
 32443 00004E03 C706[C887]0100          	mov	word [PRINTF_HANDLE],1 		;AC000;Print to STDOUT
 32444                                  
 32445                                  new_printf:
 32446 00004E09 50                      	push	ax				;AN000;save registers
 32447 00004E0A 53                      	push	bx				;AN000;
 32448 00004E0B 51                      	push	cx				;AN000;
 32449 00004E0C 06                      	push	es				;AN000;get local ES
 32450 00004E0D 1E                      	push	ds				;AN000;
 32451 00004E0E 07                      	pop	es				;AN000;
 32452 00004E0F 57                      	push	di				;AN000;
 32453 00004E10 56                      	push	si				;AN000;
 32454 00004E11 52                      	push	dx				;AN000;
 32455                                  
 32456                                  	; 07/04/2023
 32457                                  	;mov	word [print_err_flag],0		;AN000;
 32458 00004E12 31C9                    	xor	cx,cx
 32459 00004E14 890E[128E]              	mov	[print_err_flag],cx ; 0
 32460                                  
 32461 00004E18 89D6                    	mov	si,dx				;AN000;Get offset of message number
 32462 00004E1A AD                      	lodsw					;AN000;load message number
 32463 00004E1B 50                      	push	ax				;AN000;save it
 32464 00004E1C AC                      	lodsb					;AN000;get number of substitutions
 32465 00004E1D 88C1                    	mov	cl,al				;AN000;set up CX as # of subst
 32466                                  	; 07/04/2023
 32467                                  	;xor	ch,ch				;AN000;SI now points to subst list
 32468 00004E1F 58                      	pop	ax				;AN000;get message number back
 32469                                  	;cmp	cx,0				;AN000;Any substitutions?
 32470                                  	; 07/04/2023
 32471 00004E20 21C9                    	and	cx,cx
 32472 00004E22 745C                    	jz	short ready_to_print		;AN000;No - continue
 32473                                  
 32474 00004E24 BF[148E]                	mov	di,subst_buffer			;AN061; Get address of message subst buffer
 32475 00004E27 57                      	push	di				;AN061; save it
 32476 00004E28 51                      	push	cx				;AN061; save number of subst
 32477                                  
 32478                                  move_subst:
 32479 00004E29 51                      	push	cx				;AN061;save number of subst
 32480 00004E2A 89F3                    	mov	bx,si				;AN061;save start of sublist
 32481                                  	;mov	cx,parm_block_size ; 11		;AN061;get size of sublist
 32482                                  	; 07/04/2023
 32483 00004E2C B10B                    	mov	cl,parm_block_size ; 11
 32484 00004E2E F3A4                    	rep	movsb				;AN061;move sublist
 32485                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32486 00004E30 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32487                                  	;test	byte [bx+7],4			;AN061;are we doing date/time?
 32488 00004E34 7406                    	jz	short move_subst_cont 		;AN061;no - no need to reset
 32489                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],0
 32490                                  	;mov	word [bx+2],0			;AN061;reset original date or time to 0
 32491 00004E36 894F02                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],cx ; 0
 32492                                  	;mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32493                                  	;mov	word [bx+4],0			;AN061;
 32494 00004E39 894F04                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cx ; 0
 32495                                  
 32496                                  move_subst_cont:				;AN061;
 32497 00004E3C 59                      	pop	cx				;AN061;get number of subst back
 32498 00004E3D E2EA                    	loop	move_subst			;AN061;move cx sublists
 32499                                  
 32500 00004E3F 59                      	pop	cx				;AN061;get number of subst
 32501 00004E40 50                      	push	ax				;AN061;save message number
 32502 00004E41 803E[2F7F]FF            	cmp	byte [msg_disp_class],util_msg_class
 32503                                  	;cmp	byte [msg_disp_class],0FFh	;AN061;Is this a utility message
 32504 00004E46 740C                    	je	short check_fix			;AN061;YES - go see if substitutions
 32505                                  	;mov	byte [msg_flag],1 ; ext_msg_class
 32506 00004E48 C606[0E8E]01            	mov	byte [msg_flag],ext_msg_class	;AN061;set message flag
 32507 00004E4D BF[317F]                	mov	di,extend_buf_ptr		;AN061; Get address of extended message block
 32508 00004E50 31C0                    	xor	ax,ax				;AN061;clear ax register
 32509 00004E52 AB                      	stosw					;AN061;clear out message number
 32510 00004E53 AA                      	stosb					;AN061;clear out subst count
 32511                                  
 32512                                  check_fix:					;AN061;
 32513 00004E54 58                      	pop	ax				;AN061;get message number back
 32514 00004E55 5F                      	pop	di				;AN061;get start of sublists
 32515 00004E56 89FE                    	mov	si,di				;AN061;get into SI for msgserv
 32516 00004E58 89F3                    	mov	bx,si				;AN061;get into BX for addressing
 32517 00004E5A 51                      	push	cx				;AN061;save number of subst
 32518                                  
 32519                                  set_subst:					;AN061;store the segment of the subst
 32520 00004E5B 837F0400                	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],0
 32521                                  	;cmp	word [bx+4],0			;AN061;was it set already?
 32522 00004E5F 7509                    	jnz	short subst_seg_set		;AN061;if not 0, don't replace it
 32523 00004E61 F6470704                	test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],4
 32524                                  	;test	byte [bx+$M_SUBLIST_STRUC.$M_S_FLAG],date_type
 32525                                  	;test	byte [bx+7],4			;AN061;don't replace if date or time
 32526 00004E65 7503                    	jnz	short subst_seg_set		;AN061;yes - skip it
 32527 00004E67 8C4F04                  	mov	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE+2],cs
 32528                                  	;mov	word [bx+4],cs			;AN061;set segment value
 32529                                  
 32530                                  subst_seg_set:					;AN061;
 32531 00004E6A 83C30B                  	add	bx,parm_block_size ; add bx,11	;AN061;go to next sublist
 32532 00004E6D E2EC                    	loop	set_subst			;AN061;loop CX times
 32533 00004E6F 59                      	pop	cx				;AN061;get number of subst back
 32534                                  
 32535 00004E70 89F3                    	mov	bx,si				;AN061;get start of sublist to BX
 32536 00004E72 817F02[8C8C]            	cmp	word [bx+$M_SUBLIST_STRUC.$M_S_VALUE],string_ptr_2
 32537                                  	;cmp	word [bx+2],string_ptr_2	;AN061;are we using double indirection?
 32538 00004E77 7507                    	jne	short ready_to_print		;AN061;no - we already have address
 32539                                  	; 01/05/2023
 32540 00004E79 8B16[8C8C]              	mov	dx,[string_ptr_2] 		;AN061;get address in string_ptr_2
 32541 00004E7D 895702                  	mov	[bx+$M_SUBLIST_STRUC.$M_S_VALUE],dx
 32542                                  						;AN061;put it into the subst block
 32543                                  	;mov	[bx+2],dx
 32544                                  
 32545                                  ready_to_print:
 32546 00004E80 8B1E[C887]              	mov	bx,[PRINTF_HANDLE]		;AN000;get print handle
 32547 00004E84 8A16[307F]              	mov	dl,[msg_cont_flag]		;AN000;set up control flag
 32548 00004E88 8A36[2F7F]              	mov	dh,[msg_disp_class]		;AN000;set up display class
 32549 00004E8C C606[307F]00            	mov	byte [msg_cont_flag],0 ; no_cont_flag
 32550                                  						;AN061;reset flags to avoid
 32551 00004E91 C606[2F7F]FF            	mov	byte [msg_disp_class],util_msg_class
 32552                                  	;mov	byte [msg_disp_class],0FFh	;AN061; transient reload
 32553                                  
 32554 00004E96 1E                      	push	ds				;AN026;
 32555 00004E97 06                      	push	es				;AN026;
 32556                                  
 32557 00004E98 E83702                  	call	SYSDISPMSG			;AN000;call Rod
 32558                                  
 32559 00004E9B 07                      	pop	es				;AN026; restore registers
 32560 00004E9C 1F                      	pop	ds				;AN026;
 32561                                  
 32562 00004E9D 7303                    	jnc	short print_success		;AN000; everything went okay
 32563 00004E9F A3[128E]                	mov	[print_err_flag],ax		;AN000;
 32564                                  
 32565                                  print_success:
 32566 00004EA2 5A                      	pop	dx				;AN061;restore dx
 32567 00004EA3 5E                      	pop	si				;AN000;restore registers
 32568 00004EA4 5F                      	pop	di				;AN000;
 32569 00004EA5 07                      	pop	es				;AN000;restore registers
 32570 00004EA6 59                      	pop	cx				;AN000;
 32571 00004EA7 5B                      	pop	bx				;AN000;
 32572 00004EA8 58                      	pop	ax				;AN000;
 32573 00004EA9 833E[128E]00            	cmp	word [print_err_flag],0		;AN000; if an error occurred - handle it
 32574 00004EAE 7501                    	jnz	short print_err			;AN000;
 32575                                  
 32576 00004EB0 C3                      	retn					;AC000;
 32577                                  
 32578                                  print_err:
 32579 00004EB1 0E                      	push	cs
 32580 00004EB2 07                      	pop	es
 32581 00004EB3 833E[C887]02            	cmp	word [PRINTF_HANDLE],2 		;AN026;Print to STDERR?
 32582 00004EB8 7503                    	jne	short not_stderr		;AN026;no - continue
 32583 00004EBA E947B2                  	jmp	TCOMMAND			;AN026;Yes - hopless - just exit
 32584                                  
 32585                                  not_stderr:
 32586 00004EBD A1[128E]                	mov	ax,[print_err_flag]		;AN026;get extended error number back
 32587 00004EC0 8E06[9C8A]              	mov	es,[RESSEG]			; No, set up for error, load the
 32588                                  						;  right error msg, and jmp to cerror.
 32589 00004EC4 26F606[1802]FF          	test	byte [es:PipeFlag],-1 ; 0FFh
 32590 00004ECA 7408                    	jz	short _go_to_error
 32591 00004ECC E894E0                  	call	PipeOff
 32592 00004ECF BA[9280]                	mov	dx,PIPEEMES_PTR
 32593 00004ED2 EB0B                    	jmp	short print_err_exit			;AC000;
 32594                                  
 32595                                  _go_to_error:
 32596 00004ED4 C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class
 32597                                  	;mov	byte [msg_disp_class],1		;AN000; set up extended error msg class
 32598 00004ED9 BA[317F]                	mov	dx,extend_buf_ptr		;AC000; get extended message pointer
 32599 00004EDC A3[317F]                	mov	[extend_buf_ptr],ax		;AN000; get message number in control block
 32600                                  
 32601                                  print_err_exit: 				;AC000;
 32602 00004EDF 0E                      	push	cs
 32603 00004EE0 07                      	pop	es
 32604 00004EE1 E967DA                  	jmp	cerror
 32605                                  
 32606                                  ;****************************************************************
 32607                                  ;*
 32608                                  ;* ROUTINE:	TSYSLOADMSG
 32609                                  ;*
 32610                                  ;* FUNCTION:	Interface to call SYSLOADMSG to avoid duplicate
 32611                                  ;*		names since these routines are also used in the
 32612                                  ;*		resident.
 32613                                  ;*
 32614                                  ;* INPUT:	Inputs to SYSLOADMSG
 32615                                  ;*
 32616                                  ;* OUTPUT:	Outputs from SYSLOADMSG
 32617                                  ;*
 32618                                  ;****************************************************************
 32619                                  
 32620                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32621                                  TSYSLOADMSG:
 32622 00004EE4 53                      	push	bx				;AN000;
 32623 00004EE5 E80800                  	call	SYSLOADMSG			;AN000; call routine
 32624 00004EE8 5B                      	pop	bx				;AN000;
 32625 00004EE9 C3                      	retn					;AN000; exit
 32626                                  
 32627                                  ;****************************************************************
 32628                                  ;*
 32629                                  ;* ROUTINE:	TSYSGETMSG
 32630                                  ;*
 32631                                  ;* FUNCTION:	Interface to call SYSGETMSG to avoid duplicate
 32632                                  ;*		names since these routines are also used in the
 32633                                  ;*		resident.
 32634                                  ;*
 32635                                  ;* INPUT:	Inputs to SYSGETMSG
 32636                                  ;*
 32637                                  ;* OUTPUT:	Outputs from SYSGETMSG
 32638                                  ;*
 32639                                  ;****************************************************************
 32640                                  
 32641                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32642                                  TSYSGETMSG:
 32643 00004EEA 51                      	push	cx				;AN000;
 32644 00004EEB E8B500                  	call	SYSGETMSG			;AN000; call routine
 32645 00004EEE 59                      	pop	cx				;AN000;
 32646 00004EEF C3                      	retn					;AN000; exit
 32647                                  
 32648                                  ;============================================================================
 32649                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 32650                                  ;============================================================================
 32651                                  ; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32652                                  
 32653                                  ; ---------------------------------------------------------------------------
 32654                                  ; MODULE NAME: MSGSERV.SAL
 32655                                  ;
 32656                                  ; DESCRIPTIVE NAME: Message Services SALUT file
 32657                                  ;
 32658                                  ; FUNCTION: This module incorporates all the messages services and
 32659                                  ;	    is called upon at build time to INCLUDE the code requested
 32660                                  ;	    by a utility. Code is requested using the macro MSG_SERVICES.
 32661                                  ;
 32662                                  ; ENTRY POINT: Since this a collection of subroutines, entry point is at
 32663                                  ;	    requested procedure.
 32664                                  ;
 32665                                  ; INPUT: Since this a collection of subroutines, input is dependent on
 32666                                  ;	    function requested.
 32667                                  ;
 32668                                  ; EXIT-NORMAL: In all cases, CARRY FLAG = 0
 32669                                  ;
 32670                                  ; EXIT-ERROR: In all cases, CARRY FLAG = 1
 32671                                  ;
 32672                                  ; INTERNAL REFERENCES: (list of included subroutines)
 32673                                  ;
 32674                                  ;	- SYSLOADMSG
 32675                                  ;	- SYSDISPMSG
 32676                                  ;	- SYSGETMSG
 32677                                  ;
 32678                                  ; EXTERNAL REFERENCES: None
 32679                                  ;
 32680                                  ; NOTES: At build time, some modules must be included. These are only included
 32681                                  ;	 once using assembler switches. Other logic is included at the request
 32682                                  ;	 of the utility.
 32683                                  ;
 32684                                  ;	 COMR and COMT are assembler switches to conditionally assemble code
 32685                                  ;	 for RESIDENT COMMAND.COM and TRANSIENT COMMAND.COM to reduce resident
 32686                                  ;	 storage and multiple EQUates.
 32687                                  ;
 32688                                  ; REVISION HISTORY: Created MAY 1987
 32689                                  ;
 32690                                  ;     Label: DOS - - Message Retriever
 32691                                  ;	     (c) Copyright 1988 Microsoft
 32692                                  ; ---------------------------------------------------------------------------
 32693                                  
 32694                                  ;	Revision History
 32695                                  ;	================
 32696                                  ;
 32697                                  ;	M007	SR	08/24/90	Fixed bug #1818 -- changed
 32698                                  ;				$M_DISPLAY_H_STRING to properly
 32699                                  ;				handle Ctrl-Z being passed
 32700                                  ;
 32701                                  ;	M013	SR	9/12/90	Make SETSTDIO flag false so that all
 32702                                  ;				these routines are no longer assembled.
 32703                                  ;
 32704                                  ;	M016	SR	10/14/90	Bug #3380. Changed SYSLOADMSG so that
 32705                                  ;				CR-LF string also gets reinitialized
 32706                                  ;				on every cycle.
 32707                                  ;
 32708                                  ;	M020	SR	10/26/90	Bug #3380 again. Initialize $M_DIVISOR
 32709                                  ;				& $_MSG_NUM also in SYSLOADMSG.
 32710                                  
 32711                                  ; ---------------------------------------------------------------------------
 32712                                  
 32713                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32714                                  
 32715                                  ;;; Replacable parameters are described by a sublist structure
 32716                                  ;
 32717                                  ;struc $M_SUBLIST_STRUC		;;AN000;;
 32718                                  ; .$M_S_SIZE:	resb 1		;;AN000;; SUBLIST size (PTR to next SUBLIST)
 32719                                  ; .$M_S_RESV:	resb 1		;;AN000;; RESERVED
 32720                                  ; .$M_S_VALUE:	resd 1 		;;AN000;; Time, Date or PTR to data item
 32721                                  ; .$M_S_ID:	resb 1		;;AN000;; n of %n
 32722                                  ; .$M_S_FLAG:	resb 1		;;AN000;; Data-type flags
 32723                                  ; .$M_S_MAXW:	resb 1		;;AN000;; Maximum field width
 32724                                  ; .$M_S_MINW:	resb 1		;;AN000;; Minimum field width
 32725                                  ; .$M_S_PAD:	resb 1		;;AN000;; Character for Pad field
 32726                                  ;endstruc
 32727                                  
 32728                                  ;; Each class will be defined by this structure.
 32729                                  
 32730                                  struc $M_CLASS_ID		;;AN000;;
 32731 00000000 ??                       .$M_CLS_ID:	  resb 1	;;AN000;; Class identifer
 32732 00000001 ????                     .$M_COMMAND_VER: resw 1	;;AN003;; COMMAND.COM version check
 32733 00000003 ??                       .$M_NUM_CLS_MSG: resb 1	;;AN000;; Total number of message in class
 32734                                   .size:
 32735                                  endstruc
 32736                                  
 32737                                  $M_CLASS_ID_SZ	EQU $M_CLASS_ID.size	;;AN000;;
 32738                                  
 32739                                  ;; Each message will be defined by this structure.
 32740                                  
 32741                                  struc $M_ID			;;AN000;;
 32742 00000000 ????                     .$M_NUM:	resw 1		;;AN000;; Message Number
 32743 00000002 ????                     .$M_TXT_PTR:	resw 1		;;AN000;; Pointer to message text
 32744                                   .size:	
 32745                                  endstruc
 32746                                  
 32747                                  $M_ID_SZ	EQU  $M_ID.size	;;AN000;;
 32748                                  
 32749                                  ; ---------------------------
 32750                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 32751                                  ; ---------------------------
 32752                                  $M_TEMP_BUF_SZ	EQU 64     ;; Size of temporary buffer	 ;AN003;
 32753                                  
 32754                                  ; --------------------------- 
 32755                                  
 32756                                  ; 07/04/2023
 32757                                  $M_NUM_CLS equ 3
 32758                                  
 32759                                  ;; Resident data area definition of variables
 32760                                  
 32761                                  struc $M_RES_ADDRS			;;AN000;;
 32762 00000000 ????????                 .$M_EXT_ERR_ADDRS: resd 1		;;AN000;; Allow pointers to THREE Extended error locations
 32763 00000004 ????????                 .$M_EXT_FILE:	    resd 1		;;AN001;;
 32764 00000008 ????????                 .$M_EXT_COMMAND:   resd 1		;;AN000;;
 32765 0000000C ????????                 .$M_EXT_TERM:	    resd 1		;;AN000;;
 32766 00000010 ????????                 .$M_PARSE_COMMAND: resd 1		;;AN000;;
 32767 00000014 ????????                 .$M_PARSE_ADDRS:   resd 1		;;AN000;; Allow pointers to TWO Parse error locations
 32768 00000018 ????????                 .$M_PARSE_TERM:    resd 1		;;AN000;;
 32769 0000001C ????????                 .$M_CRIT_ADDRS:    resd 1		;;AN000;; Allow pointers to TWO Critical error locations
 32770 00000020 ????????                 .$M_CRIT_COMMAND:  resd 1		;;AN000;;
 32771 00000024 ????????                 .$M_CRIT_TERM:	    resd 1		;;AN000;;
 32772 00000028 ????????                 .$M_DISK_PROC_ADDR: resd 1		;;AN004;; Address of READ_DISK_PROC
 32773 0000002C <res Ch>                 .$M_CLASS_ADDRS:   resd $M_NUM_CLS ; 3	;;AN000;; Allow pointers to specified classes
 32774 00000038 ????????                 .$M_CLS_TERM:	    resd 1		;;AN000;;
 32775 0000003C ????????                 .$M_DBCS_VEC:	    resd 1		;;AN000;; Save DBCS vector
 32776 00000040 ????                     .$M_HANDLE:	    resw 1 		;;AN000;;
 32777 00000042 ??                       .$M_SIZE:	    resb 1		;;AN000;;
 32778 00000043 ????                     .$M_CRLF:	    resb 2  		;;AN004;; CR LF message
 32779 00000045 ??                       .$M_CLASS:	    resb 1		;;AN004;; Saved class
 32780 00000046 ????                     .$M_RETURN_ADDR:   resw 1		;;AN000;;
 32781 00000048 ????                     .$M_MSG_NUM:	    resw 1		;;AN000;;
 32782 0000004A ????                     .$M_DIVISOR:	    resw 1		;;AN000;; Default = 10 (must be a WORD for division)
 32783 0000004C <res 40h>                .$M_TEMP_BUF:	    resb $M_TEMP_BUF_SZ	;;AN000;; Temporary buffer
 32784 0000008C ??                       .$M_BUF_TERM:	    resb 1		;;AN000;;
 32785                                   .size:
 32786                                  endstruc				;;AN000;;
 32787                                  
 32788                                  $M_RES_ADDRS_SZ	EQU $M_RES_ADDRS.size	;;AN000;;
 32789                                  
 32790                                  ;; Important fields of the Get Country Information call
 32791                                  
 32792                                  struc $M_COUNTRY_INFO			;;AN000;; Expected Country infomation
 32793 00000000 <res 4Ch>                .$M_HEADER:	    resb $M_RES_ADDRS_SZ-$M_TEMP_BUF_SZ-1
 32794                                  					;;AN000;; Go past first part of struc
 32795 0000004C ????                     .$M_DATE_FORMAT:   resw 1		;;AN000;; <------- Date Format
 32796 0000004E ??????????               .$M_CURR_SEPARA:   resb 5		;;AN000;;
 32797 00000053 ????                     .$M_THOU_SEPARA:   resb 2		;;AN000;; <------- Thou Separator
 32798 00000055 ????                     .$M_DECI_SEPARA:   resb 2		;;AN000;; <------- Decimal Separator
 32799 00000057 ????                     .$M_DATE_SEPARA:   resb 2		;;AN000;; <------- Date Separator
 32800 00000059 ????                     .$M_TIME_SEPARA:   resb 2		;;AN000;; <------- Time Separator
 32801 0000005B ??                       .$M_CURR_FORMAT:   resb 1		;;AN000;;
 32802 0000005C ??                       .$M_SIG_DIGS_CU:   resb 1		;;AN000;;
 32803 0000005D ??                       .$M_TIME_FORMAT:   resb 1		;;AN000;; <------- Time Format
 32804                                  endstruc				;;AN000;;
 32805                                  
 32806                                  ; ---------------------------------------------------------------------------
 32807                                  
 32808                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32809                                  ;;
 32810                                  ;;	PROC NAME: SYSLOADMSG
 32811                                  ;;
 32812                                  ;;	FUNCTION:
 32813                                  ;;	INPUTS:
 32814                                  ;;
 32815                                  ;;	OUTPUTS:
 32816                                  ;;
 32817                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32818                                  
 32819                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32820                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5107h
 32821                                  
 32822                                  SYSLOADMSG:
 32823 00004EF0 50                      	push	ax				;;AN000;
 32824 00004EF1 53                      	push	bx				;;AN000;
 32825 00004EF2 52                      	push	dx				;;AN000;
 32826 00004EF3 06                      	push	es				;;AN000;
 32827 00004EF4 57                      	push	di				;;AN000;
 32828 00004EF5 31C9                    	xor	cx,cx				;;AN000;  Reset to zero
 32829 00004EF7 8EC1                    	mov	es,cx				;;AN000;
 32830 00004EF9 31FF                    	xor	di,di				;;AN000;
 32831 00004EFB B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 32832 00004EFE B200                    	mov	dl,0 ; DOS_GET_EXTENDED		;;AN000;; Where are the Extended errors in COMMAND.COM
 32833 00004F00 CD2F                    	int	2Fh				;;AN000;; Private interface
 32834                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32835                                  		; DL = subfunction - get standard DOS error table (errors 00h-12h,50h-5Bh)
 32836                                  		; Return: ES:DI -> error table
 32837                                  	
 32838 00004F02 8C06[CD86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND+2],es
 32839                                  	;mov	[$M_RT+10],es			;;AN000;; Move into first avaliable table location
 32840 00004F06 893E[CB86]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_COMMAND],di
 32841                                  	;mov	[$M_RT+8],di			;;AN000;;
 32842                                  
 32843 00004F0A B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 32844 00004F0D B202                    	mov	dl,2 ; DOS_GET_PARSE		;;AN000;; Where are the Parse errors in COMMAND.COM
 32845 00004F0F CD2F                    	int	2Fh				;;AN000;; Private interface
 32846                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32847                                  		; DL = subfunction - get critical/SHARE error table (errors 13h-2Bh)
 32848                                  		; ES:DI -> error table
 32849                                  
 32850 00004F11 8C06[D586]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND+2],es
 32851                                  	;mov	[$M_RT+18],es			;;AN000;; Move into first avaliable table location
 32852 00004F15 893E[D386]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND],di
 32853                                  	;mov	[$M_RT+16],di			;;AN000;;
 32854                                  
 32855 00004F19 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN000;; 2FH Interface
 32856 00004F1C B204                    	mov	dl,4 ; DOS_GET_CRITICAL		;;AN000;; Where are the Critical errors in COMMAND.COM
 32857 00004F1E CD2F                    	int	2Fh				;;AN000;; Private interface
 32858                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32859                                  		; DL = subfunction - get ??? error table
 32860                                  		; ES:DI -> error table
 32861                                  
 32862 00004F20 8C06[E586]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND+2],es
 32863                                  	;mov	[$M_RT+34],es			;;AN000;; Move into first avaliable table location
 32864 00004F24 893E[E386]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_COMMAND],di
 32865                                  	;mov	[$M_RT+32],di			;;AN000;;
 32866                                  
 32867 00004F28 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 32868 00004F2B B206                    	mov	dl,6 ; DOS_GET_FILE		;;AN001;; Where are the FILE dependant in IFSFUNC.EXE
 32869 00004F2D CD2F                    	int	2Fh					     ;;AN001;; Private interface
 32870                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32871                                  		; DL = subfunction - get ??? error table
 32872                                  		; ES:DI -> error table
 32873                                  
 32874 00004F2F 8C06[C986]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE+2],es
 32875                                  	;mov	[$M_RT+6],es			;;AN001;; Move into first avaliable table location
 32876 00004F33 893E[C786]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_FILE],di
 32877                                  	;mov	[$M_RT+4],di			;;AN001;;
 32878                                  
 32879 00004F37 E8D02F                  	call	$M_MSGSERV_1			;;AN000;; Get addressibility to MSGSERV CLASS 1 (EXTENDED Errors)
 32880                                  						;;AN000;;
 32881 00004F3A 8C06[C586]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS+2],es
 32882                                  	;mov	[$M_RT+2],es			;;AN000;; Move into first avaliable table location
 32883 00004F3E 893E[C386]              	mov	[$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS],di
 32884                                  	;mov	[$M_RT+0],di			;;AN000;;
 32885 00004F42 8C06[E186]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS+2],es
 32886                                  	;mov	[$M_RT+30],es			;;AN000;; Move into first avaliable table location
 32887 00004F46 893E[DF86]              	mov	[$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS],di
 32888                                  	;mov	[$M_RT+28],di			;;AN000;;
 32889                                  
 32890 00004F4A E8DB2F                  	call	$M_MSGSERV_2			;;AN000;; Get addressibility to MSGSERV CLASS 2 (PARSE Errors)
 32891                                  
 32892 00004F4D 8C06[D986]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS+2],es
 32893                                  	;mov	[$M_RT+22],es			;;AN000;; Move into first avaliable table location
 32894 00004F51 893E[D786]              	mov	[$M_RT+$M_RES_ADDRS.$M_PARSE_ADDRS],di
 32895                                  	;mov	[$M_RT+20],di			;;AN000;;
 32896                                  
 32897 00004F55 B82E12                  	mov	ax,122Eh ; DOS_GET_EXT_PARSE_ADD ;;AN001;; 2FH Interface
 32898 00004F58 B208                    	mov	dl,8 ; DOS_GET_ADDR 		;;AN001;; Where is the READ_DISK_PROC in COMMAND.COM
 32899 00004F5A CD2F                    	int	2Fh				;;AN001;; Private interface
 32900                                  		; Multiplex - DOS 3+ internal - GET OR SET ERROR TABLE ADDRESSES
 32901                                  		; DL = subfunction - get ??? error table
 32902                                  		; ES:DI -> error table
 32903                                  
 32904 00004F5C 8C06[ED86]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR+2],es
 32905                                  	;mov	[$M_RT+42],es			;;AN001;; Move into first avaliable table location
 32906 00004F60 893E[EB86]              	mov	[$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],di
 32907                                  	;mov	[$M_RT+40],di			;;AN001;;
 32908                                  
 32909                                  ;M016; M020
 32910                                  ; Reinitialize the CR-LF string. Also, reinit the buffer terminator just to
 32911                                  ;be safe. Initialize $M_MSG_NUM and $M_DIVISOR also.
 32912                                  
 32913 00004F64 C706[0687]0D0A          	mov	word [$M_RT+$M_RES_ADDRS.$M_CRLF],0A0Dh
 32914                                  	;mov	word [$M_RT+67],0A0Dh		; Reinit CR-LF ;M016
 32915 00004F6A C606[4F87]24            	mov	byte [$M_RT+$M_RES_ADDRS.$M_BUF_TERM],'$'
 32916                                  	;mov	word [$M_RT+140],'$'		; Reinit buffer end;M016
 32917 00004F6F C706[0B87]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 32918                                  	;mov	word [$M_RT+72],0		; M020
 32919 00004F75 C706[0D87]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 32920                                  	;mov	word [$M_RT+74],10		; M020
 32921                                  
 32922                                  	; 07/04/2023 - Retro DOS v4.0 COMMAND.COM
 32923                                  	; --------------------------
 32924                                  	; MSDOS 6.0 SYSMSG.INC, 1991
 32925                                  	; --------------------------
 32926                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP5192h
 32927                                  
 32928                                  	;$M_BUILD_PTRS %$M_NUM_CLS     		;;AN000;; Build all utility classes	
 32929 00004F7B E82D2F                  	call    $M_CLS_3			; Get addressibility to class F
 32930 00004F7E 893E[EF86]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS],di
 32931                                  	;mov	[$M_RT+44],di
 32932                                  	
 32933 00004F82 E80600                  	CALL	$M_GET_DBCS_VEC 		;;AN000;; Save the DBCS vector
 32934                                  
 32935                                  	; 15/04/2023
 32936                                  	;clc					;;AN000;; Make sure carry is clear
 32937                                  	;jc	short $MIF20
 32938                                  	
 32939 00004F85 5F                      	pop	di				;;AN000;; Restore REGS
 32940 00004F86 07                      	pop	es				;;AN000;;
 32941 00004F87 5A                      	pop	dx				;;AN000;;
 32942 00004F88 5B                      	pop	bx				;;AN000;;
 32943 00004F89 58                      	pop	ax				;;AN000;;
 32944                                  	;jmp	short $MEN20
 32945                                  	; 15/04/2023
 32946 00004F8A C3                      	retn
 32947                                  
 32948                                  	; 15/04/2023
 32949                                  ;$MIF20:
 32950                                  	;add	sp,10				;;AN000;;
 32951                                  	;stc					;;AN000;; Reset carry flag
 32952                                  ;$MEN20:
 32953                                  	;retn					;;AN000;;
 32954                                  
 32955                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32956                                  ;;
 32957                                  ;;  Proc Name:	$M_GET_DBCS_VEC
 32958                                  ;;
 32959                                  ;;  Function:	Get the DBCS vector and save it for later use
 32960                                  ;;
 32961                                  ;;  Inputs:	None
 32962                                  ;;
 32963                                  ;;  Outputs:	None
 32964                                  ;;
 32965                                  ;;  Regs Changed:
 32966                                  ;;
 32967                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32968                                  
 32969                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 32970                                  
 32971                                  $M_GET_DBCS_VEC:
 32972 00004F8B 50                      	push	ax				;;AN000;; Save character to check
 32973 00004F8C 56                      	push	si				;;AN000;;
 32974 00004F8D 1E                      	push	ds				;;AN000;;
 32975 00004F8E B80063                  	mov	ax,6300h ;DOS_GET_DBCS_INFO	;;AN000;; DOS function to get DBSC environment
 32976 00004F91 CD21                    	int	21h				;;AN000;; Get environment pointer
 32977 00004F93 1E                      	push	ds				;;AN000;; Get environment pointer
 32978 00004F94 07                      	pop	es				;;AN000;; Get environment pointer
 32979 00004F95 1F                      	pop	ds				;;AN000;; Get environment pointer
 32980 00004F96 7208                    	jc	short $MIF23
 32981                                  	
 32982 00004F98 8936[FF86]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC],si
 32983                                  	;mov	word [$M_RT+60],si		;;AN000;; Save DBCS Vector
 32984 00004F9C 8C06[0187]              	mov	word [$M_RT+$M_RES_ADDRS.$M_DBCS_VEC+2],es
 32985                                  	;mov	word [$M_RT+62],es		;;AN000;;
 32986                                  $MIF23:
 32987 00004FA0 5E                      	pop	si				;;AN000;;
 32988 00004FA1 58                      	pop	ax				;;AN000;; Retrieve character to check
 32989 00004FA2 C3                      	retn					;;AN000;; Return
 32990                                  
 32991                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 32992                                  ;;
 32993                                  ;;  Proc Name:	SYSGETMSG
 32994                                  ;;
 32995                                  ;;  Function:	The GET service returns the segment, offset and size of the
 32996                                  ;;		message text to the caller based on a message number.
 32997                                  ;;		The GET function will not display the message thus assumes
 32998                                  ;;		caller will handle replaceable parameters.
 32999                                  ;;
 33000                                  ;;  Inputs:
 33001                                  ;;
 33002                                  ;;  Outputs:
 33003                                  ;;
 33004                                  ;;  Psuedocode:
 33005                                  ;;		Call $M_GET_MSG_ADDRESS
 33006                                  ;;		IF MSG_NUM exists THEN
 33007                                  ;;		   Set DS:SI = MSG_TXT_PTR + 1
 33008                                  ;;		   CARRY_FLAG = 0
 33009                                  ;;		ELSE
 33010                                  ;;		   CARRY_FLAG = 1
 33011                                  ;;		ENDIF
 33012                                  ;;
 33013                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33014                                  
 33015                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33016                                  
 33017                                  	utility_msg_class equ 0FFh ; 18/04/2023
 33018                                  
 33019                                  SYSGETMSG:
 33020                                  	;; Save registers needed later
 33021 00004FA3 50                      	push	ax				;;AN000;; Save changed regs
 33022 00004FA4 06                      	push	es				;;AN000;;
 33023 00004FA5 57                      	push	di				;;AN000;;
 33024 00004FA6 55                      	push	bp				;;AN000;;
 33025                                  
 33026 00004FA7 E81400                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33027 00004FAA 720D                    	jc	short $MIF31
 33028                                  	
 33029 00004FAC 80FEFF                  	cmp	dh,utility_msg_class ; 0FFh	;;AN000;; Were utility messages requested?
 33030 00004FAF F8                      	clc					;;AN000;;
 33031 00004FB0 7403                    	je	short $MIF32			;;AN000;;
 33032                                  
 33033 00004FB2 06                      	push	es				;;AN000;;
 33034                                  	;pop	ds				;;AN000;;
 33035 00004FB3 EB01                    	jmp	short $MEN32
 33036                                  $MIF32:
 33037 00004FB5 0E                      	push	cs				;;AN000;;			
 33038                                  	;pop	ds				;;AN000;;
 33039                                  $MEN32:
 33040                                  	; 07/04/2023
 33041 00004FB6 1F                      	pop	ds
 33042 00004FB7 89FE                    	mov	si,di				;;AN000;; Return message in DS:SI
 33043                                  $MIF31:
 33044 00004FB9 5D                      	pop	bp				;;AN000;; Restore changed regs
 33045 00004FBA 5F                      	pop	di				;;AN000;;
 33046 00004FBB 07                      	pop	es				;;AN000;;
 33047 00004FBC 58                      	pop	ax				;;AN000;;
 33048 00004FBD C3                      	retn					;;AN000;; Return
 33049                                  
 33050                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33051                                  ;;
 33052                                  ;;	PROC NAME: $M_GET_MSG_ADDRESS
 33053                                  ;;
 33054                                  ;;	FUNCTION:  To scan thru classes to return pointer to the message header
 33055                                  ;;	INPUTS:    Access to $M_RES_ADDRESSES
 33056                                  ;;	OUTPUTS:   IF CX = 0 THEN Message was not found
 33057                                  ;;		   IF CX > 1 THEN ES:DI points to the specified message
 33058                                  ;;	REGS CHANGED: ES,DI,CX
 33059                                  ;;
 33060                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33061                                  
 33062                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33063                                  
 33064                                  $M_GET_MSG_ADDRESS:
 33065 00004FBE 56                      	push	si				;;AN000;;
 33066 00004FBF 53                      	push	bx				;;AN000;;
 33067 00004FC0 31F6                    	xor	si,si				;;AN000;; Use SI as an index
 33068 00004FC2 31C9                    	xor	cx,cx				;;AN000;; Use CX as an size
 33069                                  $MDO36:
 33070 00004FC4 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Were utility messages requested?
 33071 00004FC7 7508                    	jne	short $MIF37			;;AN000;; No			
 33072                                  	
 33073                                  	; 07/04/2023
 33074                                  	;;mov	di,[si+89CAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33075 00004FC9 8BBC[EF86]              	mov	di,[si+$M_RT+$M_RES_ADDRS.$M_CLASS_ADDRS]
 33076                                  	;mov	di,[si+$M_RT+44]		;;AN000;; Get address of class
 33077 00004FCD 89FB                    	mov	bx,di				;;AN000;;
 33078 00004FCF EB21                    	jmp	short $MEN37
 33079                                  $MIF37:
 33080 00004FD1 F6C602                  	test	dh,2 ; parse_err_class		;;AN000;; Were parse errors requested?
 33081 00004FD4 7406                    	jz	short $MIF39
 33082                                  	
 33083                                  	; 07/04/2023
 33084                                  	;;les	di,[si+89AEh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33085 00004FD6 C4BC[D386]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_PARSE_COMMAND]
 33086                                  	;les	di,[si+$M_RT+16]		;;AN000;; Get address of class
 33087                                  	
 33088                                  	; 07/04/2023
 33089                                  	;mov	bx,es ; *			;;AN000;;
 33090 00004FDA EB14                    	jmp	short $MEN39
 33091                                  $MIF39:
 33092 00004FDC 83F813                  	cmp	ax,19 ; $M_CRIT_LO		;;AN000;; Is this a critical error?
 33093 00004FDF 720B                    	jnae	short $MIF41  ; jb short $MIF41 ;;AN000;;
 33094                                  
 33095 00004FE1 83F827                  	cmp	ax,39 ; $M_CRIT_HI		;;AN000;;
 33096 00004FE4 7706                    	jnbe	short $MIF41  ; ja short $MIF41 ;;AN000;;
 33097                                  
 33098                                  	; 07/04/2023
 33099                                  	;;les	di,[si+89BAh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33100 00004FE6 C4BC[DF86]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_CRIT_ADDRS]
 33101                                  	;les	di,[si+$M_RT+28]		;;AN000;; Get address of class
 33102                                  	
 33103                                  	; 07/04/2023
 33104                                  	;mov	bx,es ; *			;;AN000;;
 33105 00004FEA EB04                    	jmp	short $MEN41
 33106                                  $MIF41:
 33107                                  	; 07/04/2023
 33108                                  	;;les	di,[si+899Eh] ; MSDOS 5.0 COMMAND.COM ($M_RT at offset 899Eh)
 33109 00004FEC C4BC[C386]              	les	di,[si+$M_RT+$M_RES_ADDRS.$M_EXT_ERR_ADDRS]
 33110                                  	;les	di,[si+$M_RT+0]			;;AN000;; Get address of class
 33111                                  	
 33112                                  	; 07/04/2023
 33113                                  	;mov	bx,es ; *			;;AN000;;
 33114                                  $MEN41:
 33115                                  $MEN39:
 33116                                  	; 07/04/2023
 33117 00004FF0 8CC3                    	mov	bx,es ; *
 33118                                  $MEN37:						;;AN000;;
 33119 00004FF2 83FBFF                  	cmp	bx,-1 ; $M_TERMINATING_FLAG	;;AN000;; Are we finished all classes?
 33120 00004FF5 7515                    	jne	short $MIF46			;;AN000;; No
 33121                                  
 33122 00004FF7 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN000;; Was it a UTILITY class?
 33123 00004FFA 7503                    	jne	short $MIF47			;;AN000;; No
 33124 00004FFC F9                      	stc		     ; **-		;;AN000;; Set the carry flag
 33125                                  	; 07/04/2023
 33126                                  	;jmp	short $MEN47 ; **-
 33127 00004FFD EB1B                    	jmp	short $MEN36 ; **-
 33128                                  $MIF47:
 33129 00004FFF A3[0B87]                	mov	[$M_RT+$M_RES_ADDRS.$M_MSG_NUM],AX
 33130                                  	;mov	[$M_RT+72],ax			;;AN000;; Save message number
 33131 00005002 B8FFFF                  	mov	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN000;; Set special message number
 33132 00005005 BD0100                  	mov	bp,1 ; $M_ONE_REPLACE		;;AN000;; Set one replace in message
 33133 00005008 31F6                    	xor	si,si				;;AN000;; Reset the SI index to start again
 33134                                  	; 28/04/2023
 33135                                  	; 07/04/2023
 33136                                  	;clc	; **+				;;AN000;;
 33137                                  ;$MEN47:
 33138                                  	;jmp	short $MEN46 ; ***
 33139 0000500A EB0A                    	jmp	short $MEN47 ; ***
 33140                                  $MIF46:
 33141                                  	;cmp	bx,0 ; $M_CLASS_NOT_EXIST	;;AN000;; Does this class exist?
 33142 0000500C 21DB                    	and	bx,bx ; 0 ?
 33143 0000500E 7403                    	jz	short $MIF51			;;AN000;; No
 33144                                  	
 33145 00005010 E84D00                  	call	$M_FIND_SPECIFIED_MSG		;;AN000;; Try to find the message
 33146                                  $MIF51:
 33147 00005013 83C604                  	add	si,4 ; $M_ADDR_SZ_FAR 		;;AN000;; Get next class
 33148                                  	; 07/04/2023
 33149                                  	;clc					;;AN000;;
 33150                                  ;$MEN46:
 33151                                  	;jc	short $MEN36 ; **- ; **+	;;AN000;;
 33152                                  $MEN47:	; 07/04/2023	; **+
 33153 00005016 09C9                    	or	cx,cx				;;AN000;; Was the message found?
 33154                                  	;jnz	short $MXL2			;;AN000;; Yes
 33155                                  	;jmp	short $MDO36
 33156                                  	; 07/04/2023
 33157 00005018 74AA                    	jz	short $MDO36	
 33158                                  $MXL2:
 33159                                  $MEN36:
 33160 0000501A 9C                      	pushf 					;;AN006;; Save the flag state
 33161                                  	
 33162 0000501B 80FE01                  	cmp	dh,1 ; EXT_ERR_CLASS		;;AN006;; Was an extended error requested?
 33163                                  	;jne	short $MIF56			;;AN006;; No
 33164                                  	; 28/04/2023
 33165 0000501E 752A                    	jne	short $M_MYRET	
 33166                                  
 33167 00005020 52                      	push	dx				;;AN006;; Save all needed registers
 33168 00005021 55                      	push	bp				;;AN006;;
 33169 00005022 51                      	push	cx				;;AN006;;
 33170 00005023 06                      	push	es				;;AN006;;
 33171 00005024 57                      	push	di				;;AN006;;
 33172 00005025 50                      	push	ax				;;AN006;;
 33173                                  
 33174 00005026 B80005                  	mov	ax,500h ; IFSFUNC_INSTALL_CHECK	;;AN006;; Check if IFSFUNC is installed
 33175 00005029 CD2F                    	int	2Fh				;;AN006;;
 33176                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER - INSTALLATION CHECK
 33177                                  		; Return: AL = 00h not installed, OK to install
 33178                                  		; 01h not installed, can't install
 33179                                  		; FFh installed
 33180                                  
 33181 0000502B 3CFF                    	cmp	al, 0FFh ; IFSFUNC_INSTALLED	;;AN006;; Is it installed?
 33182 0000502D 58                      	pop	ax				;;AN006;; Restore msg number
 33183 0000502E 7513                    	jne	short $MIF57			;;AN006;; No (not installed)
 33184                                  
 33185 00005030 89C3                    	mov	bx,ax				;;AN006;; BX is the extended error number
 33186 00005032 B80205                  	mov	ax,502h ; IFS_GET_ERR_TEXT	;;AN006;; AX is the muliplex number
 33187 00005035 CD2F                    	int	2Fh				;;AN006;; Call IFSFUNC
 33188                                  		; Multiplex - DOS 3+ CRITICAL ERROR HANDLER
 33189                                  
 33190                                  	;jmp	short $MEN57			;;AN006;;
 33191                                  	; 28/04/2023
 33192 00005037 720B                    	jc	short $MEN57
 33193                                  $MIF60:
 33194 00005039 83C406                  	add	sp,6				;;AN006;; Throw away old pointer
 33195 0000503C E81200                  	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33196                                  $MEN60:
 33197 0000503F 5D                      	pop	bp				;;AN006;; Restore other Regs
 33198 00005040 5A                      	pop	dx				;;AN006;;
 33199                                  $MIF56:
 33200                                  	; 07/04/2023
 33201                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33202 00005041 EB07                    	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33203                                  
 33204                                  $MIF57:
 33205 00005043 F9                      	stc					;;AN006;; Carry conditon
 33206                                  $MEN57:
 33207                                  	; 28/04/2023
 33208                                  	;jnc	short $MIF60			;;AN006;;
 33209                                  
 33210 00005044 5F                      	pop	di				;;AN006;;
 33211 00005045 07                      	pop	es				;;AN006;; Restore old pointer
 33212 00005046 59                      	pop	cx				;;AN006;;
 33213 00005047 EBF6                    	jmp	short $MEN60
 33214                                  
 33215                                  ;$MIF60:
 33216                                  ;	add	sp,6				;;AN006;; Throw away old pointer
 33217                                  ;	call	$M_SET_LEN_IN_CX		;;AN006;; Get the length of the ASCIIZ string
 33218                                  ;$MEN60:
 33219                                  ;	pop	bp				;;AN006;; Restore other Regs
 33220                                  ;	pop	dx				;;AN006;;
 33221                                  ;$MIF56:
 33222                                  ;	; 07/04/2023
 33223                                  ;	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33224                                  ;	jmp	short $M_MYRET			;;AN006;; Restore the flag state
 33225                                  
 33226                                  ; 07/04/2023
 33227                                  ; ---------------------------
 33228                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33229                                  ; ---------------------------
 33230                                  	; $M_POPF macro
 33231                                  	;jmp	short $+3
 33232                                  m_popf_iret:
 33233 00005049 CF                      	iret
 33234                                  $M_MYRET:
 33235 0000504A 0E                      	push	cs
 33236 0000504B E8FBFF                  	call	m_popf_iret
 33237                                  	;;; end macro	
 33238                                  ; ---------------------------
 33239                                  
 33240 0000504E 5B                      	pop	bx				;;AN000;;
 33241 0000504F 5E                      	pop	si				;;AN000;;
 33242 00005050 C3                      	retn					;;AN000;; Return ES:DI pointing to the message
 33243                                  
 33244                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33245                                  
 33246                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33247                                  $M_SET_LEN_IN_CX:			
 33248 00005051 57                      	push	di				;;AN006;; Save position
 33249 00005052 50                      	push	ax				;;AN006;;
 33250 00005053 B9FFFF                  	mov	cx,-1 ; 65535 ; 0FFFFh		;;AN006;; Set CX for decrements
 33251 00005056 30C0                    	xor	al,al				;;AN006;; Prepare compare register
 33252 00005058 F2AE                    	repne	scasb				;;AN006;; Scan for zero
 33253 0000505A F7D1                    	not	cx				;;AN006;; Change decrement into number
 33254 0000505C 49                      	dec	cx				;;AN006;; Don't include the zero
 33255 0000505D 58                      	pop	ax				;;AN006;;
 33256 0000505E 5F                      	pop	di				;;AN006;; Restore position
 33257 0000505F C3                      	retn					;;AN006;;
 33258                                  
 33259                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33260                                  ;;
 33261                                  ;;	PROC NAME: $M_FIND_SPECIFIED_MSG
 33262                                  ;;
 33263                                  ;;	FUNCTION:  To scan thru message headers until message is found
 33264                                  ;;	INPUTS:    ES:DI points to beginning of msg headers
 33265                                  ;;		   CX contains the number of messages in class
 33266                                  ;;		   DH contains the message class
 33267                                  ;;	OUPUTS:    IF CX = 0 THEN Message was not found
 33268                                  ;;		   IF CX > 1 THEN ES:DI points to header of specified message
 33269                                  ;;
 33270                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33271                                  
 33272                                  	; 07/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33273                                  
 33274                                  $M_FIND_SPECIFIED_MSG:
 33275 00005060 83FB01                  	cmp	bx,1				;;AN004;; Do we have an address to CALL?
 33276 00005063 751F                    	jne	short $MIF64
 33277 00005065 833E[EB86]FF            	cmp	word [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR],-1
 33278                                  	;cmp	word [$M_RT+40],-1 ; 0FFFFh	;;AN004;; Do we have an address to CALL?
 33279 0000506A 7518                    	jne	short $MIF64
 33280                                  
 33281 0000506C 83F8FF                  	cmp	ax,0FFFFh ; $M_SPECIAL_MSG_NUM	;;AN004;; Are we displaying a default Ext Err?
 33282 0000506F 750B                    	jne	short $MIF65
 33283                                  	
 33284 00005071 50                      	push	ax				;;AN004;; Reset the special message number
 33285 00005072 A1[0B87]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 33286                                  	;mov	ax,[$M_RT+72]			;;AN004;; Get the old message number
 33287 00005075 FF1E[EB86]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33288                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33289 00005079 58                      	pop	ax				;;AN004;; Reset the special message number
 33290                                  	; 28/04/2023
 33291 0000507A EB04                    	jmp	short $MEN65
 33292                                  	; 18/04/2023
 33293                                  	;jmp	short $MEN64
 33294                                  $MIF65:
 33295 0000507C FF1E[EB86]              	call	far [$M_RT+$M_RES_ADDRS.$M_DISK_PROC_ADDR]
 33296                                  						;;AN004;; Call the READ_DISK_PROC to get error text
 33297                                  $MEN65:
 33298                                  	; 28/04/2023
 33299 00005080 7344                    	jnc	short $MIF75
 33300                                  	;
 33301 00005082 EB19                    	jmp	short $MEN64 ; $MDO76		;;AN004;;
 33302                                  $MIF64:
 33303 00005084 31C9                    	xor	cx,cx				;;AN002;; CX = 0 will allow us to
 33304 00005086 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33305 00005089 7406                    	je	short $MIF69
 33306                                  	
 33307 0000508B 268A4D03                	mov	cl,[es:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33308                                  	;mov	cl,[es:di+3]			;;AN001;; Get number of messages in class
 33309 0000508F EB09                    	jmp	short $MEN69
 33310                                  $MIF69:
 33311                                  	;cmp	[cs:di+$M_CLASS_ID.$M_CLS_ID],dh
 33312                                  	;cmp	[cs:di+0],dh
 33313 00005091 2E3835                  	cmp	[cs:di],dh			;;AN002;; Check if class still exists at
 33314 00005094 7504                    	jne	short $MIF71
 33315                                  
 33316 00005096 2E8A4D03                	mov	cl,[cs:di+$M_CLASS_ID.$M_NUM_CLS_MSG]
 33317                                  	;mov	cl,[cs:di+3]			;;AN000;; Get number of messages in class
 33318                                  $MIF71:						;;AN001;;
 33319                                  $MEN69:
 33320 0000509A 83C704                  	add	di,$M_CLASS_ID_SZ ; add di,4	;;AN000;; Point past the class header
 33321                                  	; 02/05/2023
 33322                                  	;stc					;;AN004;; Flag that we haven't found anything yet
 33323                                  $MEN64:
 33324                                  	;jnc	short $MIF75
 33325                                  	; 28/04/2023
 33326                                  	; (or instruction clears carry flag)
 33327                                  	;clc					;;AN004;; No, reset carry
 33328                                  $MDO76:
 33329 0000509D 09C9                    	or	cx,cx				;;AN000;; Do we have any to check?
 33330 0000509F 7417                    	jz	short $MEN76
 33331                                  
 33332 000050A1 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;;
 33333 000050A4 7405                    	je	short $MIF78
 33334                                  
 33335                                  	;cmp	ax,[es:di+$M_ID.$M_NUM]		;;AN001;; Is this the message requested?
 33336 000050A6 263B05                  	cmp	ax,[es:di]
 33337 000050A9 EB03                    	jmp	short $MEN78
 33338                                  $MIF78:
 33339                                  	;cmp	ax,[cs:di+$M_ID.$M_NUM]		;;AN000;; Is this the message requested?
 33340 000050AB 2E3B05                  	cmp	ax,[cs:di]
 33341                                  $MEN78:
 33342                                  	;jne	short $MIF76
 33343                                  	;jmp	short $MSR76
 33344                                  	; 07/04/2023
 33345 000050AE 740B                    	je	short $MSR76 ; *
 33346                                  $MIF76:
 33347 000050B0 49                      	dec	cx				;;AN000;; No, well do we have more to check?
 33348 000050B1 7405                    	jz	short $MEN76
 33349                                  
 33350 000050B3 83C704                  	add	di,$M_ID_SZ ; add di,4		;;AN000;; Yes, skip past msg header
 33351 000050B6 EBE5                    	jmp	short $MDO76			;;AN000;;
 33352                                  $MEN76:
 33353 000050B8 F9                      	stc					;;AN000;;
 33354                                  ;$MSR76:	; 07/04/2023
 33355                                  	;jc	short $MIF86			;;AN000;;
 33356                                  	; 07/04/2023
 33357                                  	;jc	short $MIF91
 33358 000050B9 EB11                    	jmp	short $MIF91 ;*
 33359                                  $MSR76:	; 07/04/2023 ; *	
 33360 000050BB 80FEFF                  	cmp	dh,utility_msg_class ; -1	;;AN001;; Yes, is it a utility message?
 33361                                  	; 07/04/2023
 33362                                  	;clc					;;AN001;;
 33363 000050BE 7502                    	jne	short $MIF87
 33364                                  
 33365 000050C0 0E                      	push	cs				;;AN000;;
 33366 000050C1 07                      	pop	es				;;AN000;; Return ES:DI pointing to the message
 33367                                  $MIF87:
 33368                                  	;add	di,[es:di+2]
 33369 000050C2 26037D02                	add	di,[es:di+$M_ID.$M_TXT_PTR]     ;;AN000;; Prepare ES:DI pointing to the message
 33370                                  $MIF86:
 33371                                  ;$MIF75:
 33372                                  	; 02/05/2023
 33373                                  	;jc	short $MIF91
 33374                                  $MIF75:	; 28/04/2023
 33375 000050C6 30ED                    	xor	ch,ch				;;AN000;;
 33376 000050C8 268A0D                  	mov	cl,[es:di]			;;AN000;; Move size into CX
 33377 000050CB 47                      	inc	di				;;AN000;; Increment past length
 33378                                  $MIF91:
 33379 000050CC C606[0587]00            	mov	byte [$M_RT+$M_RES_ADDRS.$M_SIZE],0 ; $M_NULL
 33380                                  	;mov	byte [$M_RT+66],0		;;AN004;; Reset variable
 33381 000050D1 C3                      	retn					;;AN000;; Return
 33382                                  
 33383                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33384                                  ;;
 33385                                  ;;  Proc Name:	SYSDISPMSG
 33386                                  ;;
 33387                                  ;;  Function:	The DISPLAY service will output a defined message to a handle
 33388                                  ;;		requested by the caller. It also provides function to display
 33389                                  ;;		messages when handles are not applicable (ie. DOS function calls
 33390                                  ;;		00h to 0Ah) Replaceable parameters are allowed and are
 33391                                  ;;		defined previous to entry.
 33392                                  ;;
 33393                                  ;;		It is assumes that a PRELOAD function has already determined
 33394                                  ;;		the addressibilty internally to the message retriever services.
 33395                                  ;;  Inputs:
 33396                                  ;;
 33397                                  ;;  Outputs:
 33398                                  ;;
 33399                                  ;;  Psuedocode:
 33400                                  ;;		Save registers needed later
 33401                                  ;;		Get address of the message requested
 33402                                  ;;		IF Message number exists THEN
 33403                                  ;;		  IF replacable parameters were specified THEN
 33404                                  ;;		     Display message with replacable parms
 33405                                  ;;		  ELSE
 33406                                  ;;		     Display string without replacable parms
 33407                                  ;;		  ENDIF
 33408                                  ;;		  IF character input was requested THEN
 33409                                  ;;		     Wait for character input
 33410                                  ;;		  ENDIF
 33411                                  ;;		  Clear CARRY FLAG
 33412                                  ;;		ELSE
 33413                                  ;;		   Set CARRY FLAG
 33414                                  ;;		ENDIF
 33415                                  ;;		Return
 33416                                  ;;
 33417                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33418                                  
 33419                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33420                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5307h
 33421                                  
 33422                                  SYSDISPMSG:
 33423                                  	;; Save registers and values needed later
 33424 000050D2 50                      	push	ax				;;AN000;; Save changed REGs
 33425 000050D3 53                      	push	bx				;;AN000;;
 33426 000050D4 51                      	push	cx				;;AN000;;
 33427 000050D5 55                      	push	bp				;;AN000;;
 33428 000050D6 57                      	push	di				;;AN000;; Save pointer to input buffer (offset)
 33429 000050D7 06                      	push	es				;;AN000;; Save pointer to input buffer (segment)
 33430 000050D8 52                      	push	dx				;;AN000;; Save Input/Class request
 33431                                  
 33432 000050D9 89CD                    	mov	bp,cx				;;AN000;; Use BP to hold replace count
 33433 000050DB 891E[0387]              	mov	[$M_RT+$M_RES_ADDRS.$M_HANDLE],bx
 33434                                  	;mov	[$M_RT+64],bx			;;AN000;; Save handle
 33435 000050DF 8836[0887]              	mov	[$M_RT+$M_RES_ADDRS.$M_CLASS],dh
 33436                                  	;mov	[$M_RT+69],dh			;;AN004;; Save class
 33437                                  
 33438                                  	;; Get address of the message requested
 33439 000050E3 E8D8FE                  	call	$M_GET_MSG_ADDRESS		;;AN000;; Scan thru classes to find message
 33440 000050E6 09C9                    	or	cx,cx				;;AN000;; Was message found?
 33441 000050E8 7420                    	jz	short $MIF93
 33442                                  						;;AN000;; Yes, Message address in ES:DI
 33443                                  	
 33444                                  	;; Test if replacable parameters were specified
 33445 000050EA 09ED                    	or	bp,bp				;;AN000;; Were replacable parameters requested
 33446 000050EC 7505                    	jnz	short $MIF94
 33447                                  
 33448                                  	;; Display string without replacable parms
 33449 000050EE E82100                  	call	$M_DISPLAY_STRING		;;AN000;; No, great . . . Display message
 33450 000050F1 EB03                    	jmp	short $MEN94
 33451                                  $MIF94:
 33452                                  	;; Display message with replacable parms
 33453 000050F3 E88401                  	call	$M_DISPLAY_MESSAGE		;;AN000;; Display the message with substitutions
 33454                                  $MEN94:
 33455 000050F6 720D                    	jc	short $MIF97
 33456 000050F8 5A                      	pop	dx				;;AN000;; Get Input/Class request
 33457 000050F9 E8F500                  	call	$M_ADD_CRLF 			;;AN004;; Check if we need to add the CR LF chars.
 33458 000050FC 07                      	pop	es				;;AN000;; Get location of input buffer (if specified)
 33459 000050FD 5F                      	pop	di				;;AN000;;
 33460                                  	;jmp	short $MEN97 ; ***
 33461                                  	; 08/04/2023
 33462                                  	;jmp	short $MEN93 ; **
 33463                                  
 33464                                  	; 08/04/2023
 33465                                  ;$MEN93:
 33466 000050FE 720D                    	jc	short $MIF104
 33467                                  ;$MEN97:
 33468 00005100 5D                      	pop	bp				;;AN000;;
 33469 00005101 59                      	pop	cx				;;AN000;;
 33470 00005102 5B                      	pop	bx				;;AN000;;
 33471 00005103 58                      	pop	ax				;;AN000;;
 33472 00005104 C3                      	retn
 33473                                   
 33474                                  $MIF97:
 33475                                  	; 08/04/2023
 33476                                  	;add	sp,6				;;AN000;;
 33477                                  	;stc					;;AN000;; Reset carry flag
 33478                                  ;$MEN97: ; ***
 33479                                  	;jmp	short $MEN93
 33480                                  	; 08/04/2023
 33481                                  	;jmp	short $MIF104
 33482                                  	; 08/04/2023
 33483 00005105 83C40E                  	add	sp,14 ; 6+8
 33484 00005108 F9                      	stc
 33485 00005109 C3                      	retn
 33486                                  $MIF93:
 33487                                  	; 08/04/2023
 33488                                  	; (wrong pops ?) - correct order: pop dx, pop es, pop di -
 33489                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:533Bh
 33490 0000510A 07                      	pop	es				;;AN000;; Get pointer to input buffer (segment)
 33491 0000510B 5F                      	pop	di				;;AN000;; Get base pointer to first sublist (offset)
 33492 0000510C 5A                      	pop	dx				;;AN000;; Get base pointer to first sublist (segment)
 33493                                  	;stc	; * 				;;AN000;; Set carry flag
 33494                                  	; 08/04/2023
 33495                                  	;jmp short $MIF104 ; *
 33496                                  
 33497                                  ;$MEN93: ; **
 33498                                  ;	jc	short $MIF104
 33499                                  ;$MEN97: ; 08/04/2023
 33500                                  ;	pop	bp				;;AN000;;
 33501                                  ;	pop	cx				;;AN000;;
 33502                                  ;	pop	bx				;;AN000;;
 33503                                  ;	pop	ax				;;AN000;;
 33504                                  ;	;jmp	short $MEN104
 33505                                  ;	; 08/04/2023
 33506                                  ;	retn
 33507                                  
 33508                                  $MIF104: ; *
 33509 0000510D 83C408                  	add	sp,8				;;AN000;; Eliminate from stack
 33510 00005110 F9                      	stc					;;AN000;;
 33511                                  $MEN104:
 33512 00005111 C3                      	retn					;;AN000;; Return
 33513                                  
 33514                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33515                                  ;;
 33516                                  ;;	PROC NAME: $M_DISPLAY_STRING
 33517                                  ;;
 33518                                  ;;	FUNCTION:  Will display or write string
 33519                                  ;;	INPUTS:    ES:DI points to beginning of message
 33520                                  ;;		   CX contains the length of string to write (if applicable)
 33521                                  ;;	OUTPUTS:   None
 33522                                  ;;	REGS Revised: None
 33523                                  ;;
 33524                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33525                                  
 33526                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33527                                  
 33528                                  $M_DISPLAY_STRING:
 33529 00005112 50                      	push	ax				;;AN000;;
 33530 00005113 53                      	push	bx				;;AN000;;
 33531 00005114 52                      	push	dx				;;AN000;;
 33532 00005115 8B1E[0387]              	mov	bx,[$M_RT+$M_RES_ADDRS.$M_HANDLE]
 33533                                  	;mov	bx,[$M_RT+64]			;;AN000;; Retrieve handle
 33534                                  	
 33535 00005119 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE 	;;AN000;; Was there a handle specified?
 33536 0000511C 7505                    	jne	short $MIF107
 33537                                  
 33538 0000511E E82600                  	call	$M_DISPLAY_$_STRING		;;AN000;; No, display $ terminated string
 33539 00005121 EB03                    	jmp	short $MEN107
 33540                                  $MIF107:
 33541 00005123 E86E00                  	call	$M_DISPLAY_H_STRING		;;AN000;; Yes, display string to handle
 33542                                  $MEN107:
 33543 00005126 730D                    	jnc	short $MIF110
 33544                                  	
 33545 00005128 B459                    	mov	ah,59h	; DOS_GET_EXT_ERROR	;;AN000;;
 33546                                  	;mov	bx,0	; DOS_GET_EXT_ERROR_BX	;;AN000;; Get extended error
 33547                                  	; 08/04/2023
 33548 0000512A 31DB                    	xor	bx,bx
 33549 0000512C CD21                    	int	21h				;;AN000;;
 33550                                  		; DOS - 3+ - GET EXTENDED ERROR CODE
 33551                                  		; BX = version code (0000h for DOS 3.x)
 33552 0000512E 30E4                    	xor	ah,ah				;;AN000;; Clear AH
 33553                                  $MEN110: ; 08/04/2023 ; ***
 33554 00005130 83C406                  	add	sp,6				;;AN000;; Clean up stack
 33555 00005133 F9                      	stc					;;AN000;; Flag that there was an error
 33556                                  	;jmp	short $MEN110 ; ****
 33557                                  	; 08/04/2023
 33558 00005134 C3                      	retn
 33559                                  $MIF110:
 33560                                  	;cmp	bx,$M_NO_HANDLE
 33561 00005135 83FBFF                  	cmp	bx,0FFFFh ; $M_NO_HANDLE	;;AN000;; Was there a handle specified?
 33562 00005138 7409                    	je	short $MIF112 ; *  ; cf = 0
 33563 0000513A 39C8                    	cmp	ax,cx				;;AN001;; Was it ALL written?
 33564 0000513C 7405                    	je	short $MIF113 ; ** ; cf = 0
 33565 0000513E E8A700                  	call	$M_GET_EXT_ERR_39		;;AN001;; Set Extended error
 33566                                  	;add	sp,6				;;AN001;; Clean up stack
 33567                                  	;stc					;;AN001;; Flag that there was an error
 33568                                  	; 08/04/2023
 33569 00005141 EBED                    	jmp	short $MEN110 ; ***
 33570                                  	; 08/04/2023
 33571                                  ;$MIF112:
 33572                                  ;$MEN110: ; ****
 33573                                  	;jc	short $MIF117
 33574                                  $MIF112: ; 08/04/2023	; *
 33575                                  $MIF113:	; **
 33576 00005143 5A                      	pop	dx				;;AN000;; Restore regs
 33577 00005144 5B                      	pop	bx				;;AN000;;
 33578 00005145 58                      	pop	ax				;;AN000;;
 33579                                  $MIF117:
 33580 00005146 C3                      	retn
 33581                                  
 33582                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33583                                  ;;
 33584                                  ;;	PROC NAME: $M_DISPLAY_$_STRING
 33585                                  ;;
 33586                                  ;;	FUNCTION:  Will display a $ terminated string
 33587                                  ;;	INPUTS:    ES:DI points to beginning of message text (not the length)
 33588                                  ;;	OUTPUTS:   None
 33589                                  ;;	REGS USED: AX,DX
 33590                                  ;;
 33591                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33592                                  
 33593                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33594                                  
 33595                                  $M_DISPLAY_$_STRING:
 33596 00005147 1E                      	push	ds				;;AN000;;
 33597 00005148 06                      	push	es				;;AN000;;
 33598 00005149 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33599                                  
 33600                                  	; 08/04/2023
 33601 0000514A B402                    	mov	ah,2 ; DOS_DISP_CHAR
 33602                                  
 33603                                  	;cmp	cx,$M_SINGLE_CHAR		;;AN000;; Is this a single character?
 33604 0000514C 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR
 33605 0000514F 7518                    	jne	short $MIF119			;;AN000;; No
 33606                                  	
 33607                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33608 00005151 268A15                  	mov	dl,[es:di]			;;AN000;; Get the character
 33609 00005154 CD21                    	int	21h				;;AN000;; Write character
 33610                                  		; DOS - DISPLAY OUTPUT
 33611                                  		; DL = character to send to standard output
 33612 00005156 1F                      	pop	ds				;;AN000;;
 33613 00005157 88D0                    	mov	al,dl				;;AN000;; Get the character in AL
 33614 00005159 E8AC00                  	call	$M_IS_IT_DBCS 			;;AN000;; Is this the first byte of a DB character
 33615 0000515C 1E                      	push	ds				;;AN000;;
 33616 0000515D 06                      	push	es				;;AN000;;
 33617 0000515E 1F                      	pop	ds				;;AN000;; Set DS to segment of message text
 33618 0000515F 7316                    	jnc	short $MIF120 ; *
 33619                                  
 33620 00005161 268A5501                	mov	dl,[es:di+1]			;;AN000;; Get the next character
 33621 00005165 CD21                    	int	21h				;;AN000;; Write character
 33622                                  		; DOS - DISPLAY OUTPUT
 33623                                  		; DL = character to send to standard output
 33624                                  	; 08/04/2023
 33625                                  	;clc					;;AN000;; Clear the DBCS indicator
 33626                                  ;$MIF120:
 33627 00005167 EB0D                    	jmp	short $MEN119
 33628                                  $MIF119:
 33629                                  	; 08/04/2023
 33630                                  	;mov	ah,2 ; DOS_DISP_CHAR		;;AN000;; DOS Function to display CHARACTER
 33631                                  ;$MDO123:
 33632 00005169 09C9                    	or	cx,cx				;;AN002;; Are there any left to display?
 33633                                  	;jz	short $MEN123
 33634                                  	; 18/04/2023
 33635 0000516B 740A                    	jz	short $MIF120 ; cf = 0
 33636                                  $MDO123: ; 08/04/2023
 33637 0000516D 268A15                  	mov	dl,[es:di]			;;AN002;; Get the character
 33638 00005170 CD21                    	int	21h				;;AN002;; Display the character
 33639                                  		; DOS - DISPLAY OUTPUT
 33640                                  		; DL = character to send to standard output
 33641 00005172 47                      	inc	di				;;AN002;; Set pointer to next character
 33642 00005173 49                      	dec	cx				;;AN002;; Count this character
 33643 00005174 75F7                    	jnz	short $MDO123
 33644                                  ;$MEN123:
 33645                                  $MEN119:
 33646 00005176 F8                      	clc					;;AN000;;Char functions used don't return carry as error
 33647                                  $MIF120: ; 08/04/2023 ; *
 33648 00005177 1F                      	pop	ds				;;AN000;;
 33649 00005178 C3                      	retn
 33650                                  
 33651                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33652                                  ;;
 33653                                  ;; Scan_ctrlZ: This routine looks through the string to be printed and 
 33654                                  ;; truncates it at the Ctrl-Z if any present.
 33655                                  ;;
 33656                                  ;;	ENTRY:	ds:dx = String to be displayed
 33657                                  ;;		cx = number of chars to be displayed
 33658                                  ;;
 33659                                  ;;	EXIT:	cx = number of chars to be displayed
 33660                                  ;;
 33661                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33662                                  
 33663                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33664                                  scan_ctrlz:
 33665 00005179 57                      	push	di
 33666 0000517A 50                      	push	ax
 33667 0000517B 06                      	push	es
 33668 0000517C 53                      	push	bx
 33669                                  
 33670 0000517D 89D7                    	mov	di,dx
 33671 0000517F 1E                      	push	ds
 33672 00005180 07                      	pop	es   			;es:di points at string
 33673                                  
 33674 00005181 89CB                    	mov	bx,cx			;save current count
 33675                                  
 33676 00005183 B01A                    	mov	al,1Ah	; Ctrl-Z
 33677 00005185 FC                      	cld
 33678 00005186 F2AE                    	repne	scasb			;find first Ctrl-Z
 33679 00005188 7503                    	jnz	short noCtrlZ		;no CtrlZ found in string
 33680                                  
 33681 0000518A 29CB                    	sub	bx,cx
 33682 0000518C 4B                      	dec	bx			;bx = new count to display
 33683                                  noCtrlZ:
 33684 0000518D 89D9                    	mov	cx,bx			;cx = actual display count
 33685                                  
 33686 0000518F 5B                      	pop	bx
 33687 00005190 07                      	pop	es
 33688 00005191 58                      	pop	ax
 33689 00005192 5F                      	pop	di
 33690                                  $MIF127:	; 08/04/2023
 33691 00005193 C3                      	retn
 33692                                  
 33693                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33694                                  ;;
 33695                                  ;;	PROC NAME: $M_DISPLAY_H_STRING
 33696                                  ;;
 33697                                  ;;	FUNCTION:  Will display a string to a specified handle
 33698                                  ;;	INPUTS:    ES:DI points to beginning of message
 33699                                  ;;		   CX contains the number of bytes to write
 33700                                  ;;		   BX contains the handle to write to
 33701                                  ;;	OUPUTS:    None
 33702                                  ;;	REGS USED: AX,DX
 33703                                  ;;
 33704                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33705                                  
 33706                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33707                                  
 33708                                  $M_DISPLAY_H_STRING:
 33709 00005194 31C0                    	xor	ax,ax			;;AN002;; Set number of bytes written to 0
 33710 00005196 09C9                    	or	cx,cx			;;AN002;; For performance, don't write if not necessary
 33711 00005198 74F9                    	jz	short $MIF127
 33712                                  	
 33713 0000519A 1E                      	push	ds			;;AN000;;
 33714 0000519B 06                      	push	es			;;AN000;;
 33715 0000519C 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33716                                  	
 33717 0000519D B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 33718 0000519F 89FA                    	mov	dx,di			;;AN000;; Pointer to data to write
 33719                                  
 33720 000051A1 83F901                  	cmp	cx,1 ; $M_SINGLE_CHAR	;;AN000;; Is this a single character?
 33721 000051A4 7528                    	jne	short $MIF128		;;AN000;; No
 33722                                  
 33723 000051A6 CD21                    	int	21h			;;AN000;; Write character
 33724                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 33725                                  		; BX = file handle, CX = number of bytes to writ
 33726                                  
 33727 000051A8 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33728 000051A9 50                      	push	ax			;;AN000;;
 33729 000051AA 268A05                  	mov	al,[es:di] 		;;AN000;; Get the character
 33730 000051AD E85800                  	CALL    $M_IS_IT_DBCS		;;AN000;; Is this the first byte of a DB character
 33731 000051B0 58                      	pop	ax			;;AN000;;
 33732 000051B1 1E                      	push	ds			;;AN000;;
 33733 000051B2 06                      	push	es			;;AN000;;
 33734 000051B3 1F                      	pop	ds			;;AN000;; Set DS to segment of message text
 33735 000051B4 7306                    	jnc	short $MIF129
 33736                                  	
 33737 000051B6 F8                      	clc				;;AN000;; Clear the DBCS indicator
 33738 000051B7 B440                    	mov	ah,40h ; DOS_WRITE_HANDLE ;;AN000;; DOS function to write to a handle
 33739 000051B9 42                      	inc	dx			;;AN000;; Point to next character
 33740 000051BA CD21                    	int	21h			;;AN000;; Write character
 33741                                  		; DOS - 2+ - WRITE TO FILE WITH HANDLE
 33742                                  		; BX = file handle, CX = number of bytes to write, 
 33743                                  $MIF129:
 33744                                  ;SR;
 33745                                  ; If the single char happened to be a Ctrl-Z, the dos write would return
 33746                                  ;0 chars written making the caller think there was an error writing. To 
 33747                                  ;avoid this, we check if the single char was a Ctrl-Z and if so, return that
 33748                                  ;the char was written, thus fooling the caller.
 33749                                  
 33750 000051BC 9C                      	pushf				;save flags
 33751 000051BD 26803D1A                	cmp	byte [es:di],1Ah	;is char a Ctrl-Z?
 33752 000051C1 7502                    	jne	short m_popf_j		;no, continue
 33753                                  
 33754 000051C3 89C8                    	mov	ax,cx			;yes, fake as if it was written
 33755                                  m_popf_j:
 33756                                  	; 08/04/2023
 33757                                  	;$M_POPF  ; macro in 'sysmsg.inc' (MSDOS 6.0)
 33758 000051C5 EB01                    	jmp	short m_popf		;restore flags
 33759                                  
 33760                                  ; 07/04/2023
 33761                                  ; ---------------------------
 33762                                  ; MSDOS 6.0, SYSMSG.INC, 1991
 33763                                  ; ---------------------------
 33764                                  	; $M_POPF macro
 33765                                  	;jmp	short $+3
 33766                                  intret:
 33767 000051C7 CF                      	iret
 33768                                  m_popf:
 33769 000051C8 0E                      	push	cs
 33770 000051C9 E8FBFF                  	call	intret
 33771                                  	;;; end macro	
 33772                                  ; ---------------------------
 33773                                  
 33774 000051CC EB18                    	jmp	short $MEN128
 33775                                  
 33776                                  $MIF128:
 33777                                  ;SR;
 33778                                  ; Prescan the string looking for Ctrl-Z. We terminate the message the moment 
 33779                                  ;we hit a Ctrl-Z. cx will contain the number of characters to be printed.
 33780                                  
 33781 000051CE 55                      	push	bp			; M007
 33782 000051CF 51                      	push	cx
 33783 000051D0 E8A6FF                  	call	scan_ctrlz		;cx = count without Ctrl-Z
 33784 000051D3 89CD                    	mov	bp,cx			;store no ^Z count in bp ;M007
 33785 000051D5 59                      	pop	cx			;get old count back ;M007
 33786                                  	
 33787 000051D6 CD21                    	int	21h			;;AN000;; Write String at DS:SI to handle
 33788                                  	;jnc	short chk_count		;no error, adjust return count
 33789                                  	;jmp	short m_cnt_ok		;error, return with carry set;M007
 33790                                  	; 08/04/2023
 33791 000051D8 720B                    	jc	short m_cnt_ok 
 33792                                  ;M007
 33793                                  ; If we are writing to con and there is a Ctrl-Z in the string, the
 33794                                  ;return count will be much less and if this returns to the caller we can get
 33795                                  ;spurious error messages. We check here if the count returned is same as
 33796                                  ;original count or same as the count if we stop at Ctrl-Z. In the second
 33797                                  ;case, we fake it as if all bytes have been written. If the return count
 33798                                  ;does not match either count, then we had some other disk error (such as
 33799                                  ;insufficient disk space) and we pass it through
 33800                                  
 33801                                  chk_count:
 33802 000051DA 39C1                    	cmp	cx,ax			;have all bytes been written?;M007
 33803 000051DC 7407                    	je	short m_cnt_ok		;there was an error writing ;M007
 33804 000051DE 39C5                    	cmp	bp,ax			;count = Ctrl-Z count? ;M007
 33805 000051E0 F8                      	clc				;no error either way ;M007
 33806 000051E1 7502                    	jne	short m_cnt_ok		;no, pass it through ;M007
 33807 000051E3 89C8                    	mov	ax,cx			;return old count ;M007
 33808                                  m_cnt_ok:				; M007
 33809 000051E5 5D                      	pop	bp			; M007
 33810                                  $MEN128:
 33811 000051E6 1F                      	pop	ds			;;AN000;;
 33812                                  ;$MIF127: ; 08/04/2023
 33813 000051E7 C3                      	retn
 33814                                  
 33815                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33816                                  ;;
 33817                                  ;;	PROC NAME: $M_GET_EXT_ERR_39
 33818                                  ;;
 33819                                  ;;	FUNCTION:  Will set registers for extended error #39
 33820                                  ;;	INPUTS:    None
 33821                                  ;;	OUPUTS:    AX,BX,CX set
 33822                                  ;;	REGS USED:
 33823                                  ;;
 33824                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33825                                  
 33826                                  	; 08/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33827                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:542Dh
 33828                                  $M_GET_EXT_ERR_39:
 33829 000051E8 B82700                  	mov	ax,27h ; EXT_ERR_39	;AN001; Set AX=39
 33830                                  	;mov	bx,(ERROR_CLASS_39 SHR 8) + ACTION_39
 33831 000051EB BB0400                  	mov	bx,4			;AN001; Set BH=1 BL=4
 33832                                  	;mov	ch,LOCUS_39		;AN001; Set CH=1
 33833 000051EE B501                    	mov	ch,1			;AN001;
 33834 000051F0 C3                      	retn				;AN001;
 33835                                  
 33836                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33837                                  ;;
 33838                                  ;;	PROC NAME: $M_ADD_CRLF
 33839                                  ;;
 33840                                  ;;	FUNCTION:  Will decide whether to display a CRLF
 33841                                  ;;	INPUTS:    DX contains the Input/Class requested
 33842                                  ;;	OUTPUTS:   None
 33843                                  ;;	REGS Revised: CX,ES,DI
 33844                                  ;;
 33845                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33846                                  
 33847                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33848                                  
 33849                                  $M_ADD_CRLF:
 33850                                  	;cmp	dh,0FFh
 33851 000051F1 80FEFF                  	cmp	dh,utility_msg_class	;;AN004;; Is it a utility message?
 33852 000051F4 7411                    	je	short $MIF134		;;AN004;; Yes
 33853 000051F6 F6C680                  	test	dh,80h; $M_NO_CRLF_MASK	;;AN004;; Are we to supress the CR LF?
 33854 000051F9 750C                    	jnz	short $MIF135
 33855                                  					;;AN004;; No	
 33856 000051FB 1E                      	push	ds			;;AN004;;
 33857 000051FC 07                      	pop	es			;;AN004;; Set ES to data segment
 33858 000051FD 8D3E[0687]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_CRLF]
 33859                                  	;lea	di,[$M_RT+67]		;;AN004;; Point at CRLF message
 33860 00005201 B90200                  	mov	cx,2 ; $M_CRLF_SIZE	;;AN004;; Set the message size
 33861 00005204 E80BFF                  	call	$M_DISPLAY_STRING	;;AN004;; Display the CRLF
 33862                                  $MIF135:
 33863                                  $MIF134:
 33864 00005207 C3                      	retn				;;AN004;; Return
 33865                                  
 33866                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33867                                  ;;
 33868                                  ;;	PROC NAME: $M_IS_IT_DBCS
 33869                                  ;;
 33870                                  ;;	FUNCTION:  Will decide whether character is Single or Double Byte
 33871                                  ;;	INPUTS:    AL contains the byte to be checked
 33872                                  ;;	OUTPUTS:   Carry flag = 0 if byte is NOT in DBCS range
 33873                                  ;;		   Carry flag = 1 if byte IS in DBCS range
 33874                                  ;;	REGS USED: All restored
 33875                                  ;;
 33876                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33877                                  
 33878                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33879                                  
 33880                                  $M_IS_IT_DBCS:
 33881 00005208 06                      	push	es			;;AN000;; Save Extra Segment register
 33882 00005209 57                      	push	di			;;AN000;; Save DI register
 33883                                  
 33884 0000520A C43E[FF86]              	les	di,[$M_RT+$M_RES_ADDRS.$M_DBCS_VEC]
 33885                                  	;les	di,[$M_RT+60]		;;AN000;;
 33886 0000520E 09FF                    	or	di,di			;;AN000;; Was the DBCS vector set?
 33887 00005210 7417                    	jz	short $MIF138		;;AN000;; No
 33888                                  $MDO139:
 33889 00005212 26833D00                	cmp	word [es:di],0 ; $M_DBCS_TERM
 33890                                  					;;AN000;; Is this the terminating flag?
 33891 00005216 F8                      	clc				;;AN000;;
 33892 00005217 7410                    	jz	short $MEN139
 33893                                  					;;AN000;; No
 33894 00005219 263A05                  	cmp	al,[es:di]		;;AN000;; Does the character fall in the DBCS range?
 33895 0000521C 7207                    	jnae	short $MIF141 ; jb	;;AN000;; No		
 33896 0000521E 263A4501                	cmp	al,[es:di+1]		;;AN000;; Does the character fall in the DBCS range?
 33897 00005222 7701                    	jnbe	short $MIF141 ; ja	;;AN000;; No
 33898                                  					;;AN000;; Yes
 33899 00005224 F9                      	stc				;;AN000;; Set carry flag
 33900                                  $MIF141:
 33901 00005225 47                      	inc	di			;;AN000;;
 33902 00005226 47                      	inc	di			;;AN000;;
 33903 00005227 EBE9                    	jmp	short $MDO139		;;AN000;; Go to next vector
 33904                                  $MEN139:
 33905                                  $MIF138:
 33906 00005229 5F                      	pop	di			;;AN000;; Restore DI register
 33907 0000522A 07                      	pop	es			;;AN000;; Restore Extra Segment register
 33908 0000522B C3                      	retn				;;AN000;; Return
 33909                                  
 33910                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33911                                  ;;
 33912                                  ;;	PROC NAME: $M_CONVERT2ASC
 33913                                  ;;
 33914                                  ;;	FUNCTION: Convert a binary number to a ASCII string
 33915                                  ;;	INPUTS: DX:AX contains the number to be converted
 33916                                  ;;		$M_RT_DIVISOR contains the divisor
 33917                                  ;;	OUTPUTS: CX contains the number of characters
 33918                                  ;;		Top of stack  --> Last character
 33919                                  ;;				     . . .
 33920                                  ;;		Bot of stack  --> First character
 33921                                  ;;	REGS USED:
 33922                                  ;;
 33923                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 33924                                  
 33925                                  	; 09/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 33926                                  
 33927                                  $M_CONVERT2ASC:
 33928 0000522C 8F06[0987]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 33929                                  	;pop	word [$M_RT+70]			;;AN000;; Save Return Address
 33930                                  	
 33931 00005230 31DB                    	xor	bx,bx				;;AN000;; Use BX as a swapping register
 33932 00005232 93                      	xchg	bx,ax				;;AN000;; Initialize - Low Word in BX
 33933 00005233 92                      	xchg	ax,dx				;;AN000;;	  - High Word in AX
 33934                                  $MDO145:					;;AN000;; DO UNTIL Low Word becomes zero
 33935 00005234 F736[0D87]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 33936                                  	;div	word [$M_RT+74]			;;AN000;; Divide High Word by divisor
 33937 00005238 93                      	xchg	bx,ax				;;AN000;; Setup to divide Low Word using remainder
 33938                                  						;;AN000;;  and save reduced High Word in BX
 33939 00005239 F736[0D87]              	div	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR]
 33940                                  	;div	word [$M_RT+74]			;;AN000;; Divide Low Word by divisor
 33941                                  
 33942 0000523D 83FA09                  	cmp	dx,9				;;AN000;; Make a digit of the remainder
 33943 00005240 7605                    	jna	short $MIF146			;;AN000;; 0-9
 33944 00005242 80C237                  	add	dl,55	; add dl,37h		;;AN000;; Make A to F ASCII
 33945 00005245 EB03                    	jmp	short $MEN146
 33946                                  $MIF146:
 33947 00005247 80C230                  	add	dl,'0'				;;AN000;; Make 0 to 9 ASCII
 33948                                  $MEN146:
 33949 0000524A 52                      	push	dx				;;AN000;; Save the digit on the stack
 33950 0000524B 41                      	inc	cx				;;AN000;; Count that digit
 33951 0000524C 09C0                    	or	ax,ax				;;AN000;; Are we done?
 33952 0000524E 7504                    	jnz	short $MLL149			;;AN000;; No
 33953 00005250 09DB                    	or	bx,bx				;;AN000;; AX and BX must be ZERO!!
 33954 00005252 741F                    	jz	short $MEN145 ; * ; ax = 0	;;AN000;; Yes
 33955                                  $MLL149:
 33956 00005254 83F903                  	cmp	cx,3 ; $M_FIRST_THOU		;;AN000;; Are we at the first thousands mark
 33957                                  ; 28/04/2023
 33958 00005257 740A                    	je	short $MIF153
 33959                                  ;	jne	short $MIF150			;;AN000;; No
 33960                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 33961                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 33962                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 33963                                  ;	;jne	short $MIF151
 33964                                  ;	; 09/04/2023
 33965                                  ;	jne	short $MEN150
 33966                                  ;						;;AN000;; Yes
 33967                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 33968                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 33969                                  ;	inc	cx				;;AN000;;
 33970                                  ;$MIF151:
 33971                                  ;	jmp	short $MEN150
 33972                                  
 33973                                  $MIF150:
 33974 00005259 83F906                  	cmp	cx,6 ; $M_SECOND_THOU		;;AN000;; Are we at the first thousands mark
 33975                                  ; 28/04/2023
 33976 0000525C 7405                    	je	short $MIF153
 33977                                  ;	jne	short $MIF154			;;AN000;; No
 33978                                  ;	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 33979                                  ;	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 33980                                  ;	;cmp	byte [si+0Ah],',' ; $M_COMMA
 33981                                  ;	;jne	short $MIF155			;;AN000;; No
 33982                                  ;	; 09/04/2023
 33983                                  ;	jne	short $MEN154
 33984                                  ;						;;AN000;; Yes				
 33985                                  ;	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 33986                                  ;	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 33987                                  ;	inc	cx				;;AN000;;
 33988                                  ;$MIF155:
 33989                                  ;	jmp	short $MEN154
 33990                                  
 33991                                  $MIF154:
 33992 0000525E 83F909                  	cmp	cx,9 ; $M_THIRD_THOU		;;AN000;; Are we at the first thousands mark
 33993 00005261 750B                    	jne	short $MIF158			;;AN000;; No  
 33994                                  ; 28/04/2023
 33995                                  $MIF153:
 33996                                  	;cmp	$M_SL.$M_S_PAD,$M_COMMA		;;AN000;; Is the pad character a comma?
 33997 00005263 807C0A2C                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_PAD],','	
 33998                                  	;cmp	byte [si+0Ah],',' ; $M_COMMA
 33999 00005267 7505                    	jne	short $MIF159			;;AN000;; No
 34000                                  						;;AN000;; Yes
 34001 00005269 FF36[1687]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_THOU_SEPARA]
 34002                                  	;push	word [$M_RT+83]			;;AN000;; Insert a thousand separator
 34003 0000526D 41                      	inc	cx				;;AN000;;
 34004                                  $MIF159:
 34005                                  $MIF158:
 34006                                  $MEN154:
 34007                                  $MEN150:					;;AN000;;
 34008 0000526E 93                      	xchg	ax,bx				;;AN000;; Setup to divide the reduced High Word
 34009                                  						;;AN000;;  and Revised Low Word
 34010 0000526F 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34011                                  	; 28/04/2023
 34012 00005271 EBC1                    	jmp	short $MDO145
 34013                                  ;$MEN145:
 34014                                  	; 28/04/2023
 34015                                  	;xor	ax,ax				;;AN000;; Reset remainder
 34016                                  $MEN145: ; 09/04/2023 ; * ; ax = 0
 34017 00005273 31D2                    	xor	dx,dx				;;AN000;; Reset remainder
 34018 00005275 FF36[0987]              	push	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34019                                  	;push	word [$M_RT+70]			;;AN000;; Restore Return Address
 34020 00005279 C3                      	retn					;;AN000;; Return
 34021                                  
 34022                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34023                                  ;;
 34024                                  ;;	PROC NAME: $M_DISPLAY_MESSAGE
 34025                                  ;;
 34026                                  ;;	FUNCTION:  Will display or write entire message (with replacable parameters)
 34027                                  ;;	INPUTS:    ES:DI points to beginning of message
 34028                                  ;;		   DS:SI points to first sublist structure in chain
 34029                                  ;;		   BX contains the handle to write to (if applicable)
 34030                                  ;;		   CX contains the length of string to write (before substitutions)
 34031                                  ;;		   BP contains the count of replacables
 34032                                  ;;
 34033                                  ;;	OUTPUTS:
 34034                                  ;;	REGS USED: All
 34035                                  ;;
 34036                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34037                                  
 34038                                  	; 10/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34039                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:54DBh
 34040                                  
 34041                                  $M_DISPLAY_MESSAGE:
 34042                                  ; $DO						;;AN000;; Note: DS:SI -> message
 34043                                  $MDO165:
 34044 0000527A 31D2                    	xor	dx,dx				;;AN000;; Set size = 0
 34045 0000527C 09C9                    	or	cx,cx				;;AN000;; Are we finished the message yet?
 34046                                  ;; $IF NZ					;;AN000;; No
 34047 0000527E 7421                    	jz	short $MIF166			;;AN000;; Yes
 34048 00005280 B425                    	mov	ah,"%"				;;AN000;; Prepare to scan for %
 34049 00005282 B000                    	mov	al,0				;;AN004;;
 34050                                  ;; $DO						;;AN000;; Scan through string until %
 34051                                  $MDO167:
 34052 00005284 263825                  	cmp	byte [es:di],ah			;;AN000;; Is this character NOT a %
 34053                                  ;; $LEAVE E,AND					;;AN000;; No
 34054 00005287 750A                    	jne	short $MLL168
 34055 00005289 26386501                	cmp	byte [es:di+1],ah		;;AN000;; Is the next character also a %
 34056                                  ;; $LEAVE NE,AND				;;AN000;; No
 34057 0000528D 7404                    	je	short $MLL168
 34058                                  
 34059 0000528F 38E0                    	cmp	al,ah				;;AN000;; Was the character before a %
 34060                                  ;; $LEAVE NE					;;AN000;; No, GREAT found it
 34061 00005291 750E                    	jne	short MEN167
 34062                                  $MLL168:
 34063 00005293 268A05                  	mov	al,[es:di]			;;AN004;; Yes, (to any of the above)
 34064 00005296 E86FFF                  	call	$M_IS_IT_DBCS			;;AN004;; Is this character the first part of a DBCS?
 34065                                  ;;; $IF C					;;AN004;; Yes
 34066 00005299 7301                    	jnc	short $MIF169
 34067 0000529B 47                      	inc	di				;;AN004;; Increment past second part
 34068                                  ;;; $ENDIF					;;AN004;;
 34069                                  $MIF169:
 34070 0000529C 47                      	inc	di				;;AN000;; Next character in string
 34071 0000529D 42                      	inc	dx				;;AN000;; Size = Size + 1
 34072 0000529E 49                      	dec	cx				;;AN000;; Decrement total size
 34073                                  ;; $ENDDO Z					;;AN000;; Exit scan if we're at the end of the line
 34074 0000529F 75E3                    	jnz	short $MDO167
 34075                                  $MEN167:
 34076                                  ;; $ENDIF					;;AN000;;
 34077                                  $MIF166:
 34078 000052A1 56                      	push	si				;;AN000;; Save beginning of sublists
 34079 000052A2 87CA                    	xchg	cx,dx				;;AN000;; Get size of message to display (tot sz in DX)
 34080 000052A4 09ED                    	or	bp,bp				;;AN000;; Do we have any replacables to do?
 34081                                  ;; $IF NZ					;;AN000;; Yes
 34082 000052A6 7431                    	jz	short $MIF173
 34083 000052A8 4D                      	dec	bp				;;AN000;; Decrement number of replacables
 34084                                  
 34085                                  ;; Search through sublists to find applicable one
 34086                                  
 34087 000052A9 833E[0B87]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34088                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34089                                  ;;; $IF E					;;AN000;; No
 34090 000052AE 7529                    	jne	short $MIF174
 34091                                  ;;; $SEARCH					;;AN000;;
 34092                                  $MDO175:
 34093                                  	;mov	al,$M_SL.$M_S_ID ;$M_SL=DS:[SI]	;;AN000;; Get ID byte
 34094 000052B0 8A4406                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_ID]
 34095                                  	;mov	al,[si+6]
 34096 000052B3 0430                    	add	al,30h				;;AN000;; Convert to ASCII
 34097                                  	; 28/04/2023					
 34098 000052B5 263A4501                	cmp	al,[es:di+1]			;;AN000;; Is this the right sublist?
 34099                                  ;;; $EXITIF E					;;AN000;;
 34100                                  	;jne	short $MIF175
 34101                                  ;;; $ORELSE					;;AN000;; No
 34102                                  	;jmp	short $MSR175
 34103                                  	; 28/04/2023
 34104 000052B9 741E                    	je	short $MSR175
 34105                                  $MIF175:
 34106 000052BB 3C30                    	cmp	al,30h ; $M_SPECIAL_CASE	;;AN000;; Does this sublist have ID = 0
 34107                                  ;;; $LEAVE E,AND				;;AN000;; Yes
 34108 000052BD 7504                    	jne	short $MLL178
 34109 000052BF 09D2                    	or	dx,dx				;;AN000;; Are we at the end of the message?
 34110                                  ;;; $LEAVE Z					;;AN000;; No
 34111 000052C1 7404                    	jz	short $MEN175
 34112                                  $MLL178:
 34113                                  	;add	si,$M_SL.$M_S_SIZE		;;AN000;; Next SUBLIST
 34114                                  	;add	si,[si+$M_SUBLIST_STRUC.$M_S_SIZE] ; [si+0]
 34115                                  	;;add	si,[si+0]
 34116 000052C3 0334                    	add	si,[si]
 34117                                  ;;; ENDLOOP					;;AN000;; Yes
 34118 000052C5 EBE9                    	jmp	short $MDO175
 34119                                  $MEN175:
 34120 000052C7 803E[0887]FF            	cmp	byte [$M_RT+$M_RES_ADDRS.$M_CLASS],utility_msg_class
 34121                                  	;cmp	byte [$M_RT+69],0FFh		;;AN004;; Is it a utility message?
 34122                                  ;;;; $IF E					;;AN004;; Yes
 34123 000052CC 7508                    	jne	short $MIF180
 34124 000052CE 42                      	inc	dx				;;AN000;; Remember to display CR,LF
 34125 000052CF 42                      	inc	dx				;;AN000;;  at the end of the message
 34126 000052D0 49                      	dec	cx				;;AN000;; Adjust message length
 34127 000052D1 49                      	dec	cx				;;AN000;;
 34128 000052D2 4F                      	dec	di				;;AN000;; Adjust ending address of message
 34129 000052D3 4F                      	dec	di				;;AN000;;
 34130                                  ;;;; $ELSE					;;AN004;; No
 34131 000052D4 EB03                    	jmp	short $MEN180
 34132                                  $MIF180:
 34133 000052D6 BAFFFF                  	mov	dx,-1 				;;AN004;; Set special case
 34134                                  ;;;; $ENDIF					;;AN004;;
 34135                                  $MEN180:
 34136                                  ;;; $ENDSRCH					;;AN000;;
 34137                                  $MSR175:
 34138                                  ;; $ENDIF					;;AN000;;
 34139                                  $MIF174:
 34140                                  ; $ENDIF					;;AN000;;
 34141                                  $MIF173:
 34142                                  ;; Prepare and display this part of message
 34143                                  
 34144 000052D9 57                      	push	di				;;AN000;; Save pointer to replace number
 34145 000052DA 29CF                    	sub	di,cx				;;AN000;; Determine beginning of string
 34146 000052DC E833FE                  	call	$M_DISPLAY_STRING		;;AN000;; Display string until % (or end)
 34147 000052DF 5F                      	pop	di				;;AN000;; Get back pointer to replace number
 34148 000052E0 59                      	pop	cx				;;AN000;; Clean up stack in case error
 34149                                  ; $LEAVE C,LONG					;;AN000;; Fail if carry was set
 34150                                  	;jnc	short $MXL3
 34151                                  	;jmp	$MEN165
 34152                                  	; 02/05/2023
 34153 000052E1 7214                    	jc	short $MEN165
 34154                                  $MXL3:
 34155 000052E3 51                      	push	cx				;;AN000;;
 34156                                  
 34157                                  ;; Save and reset pointer registers
 34158                                  
 34159 000052E4 89D1                    	mov	cx,dx				;;AN000;; Get the size of the rest of the message
 34160                                  	;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h
 34161 000052E6 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0 ; $M_SPECIAL_CASE-30h
 34162                                  	;cmp	byte [si+6],0 			;;AN000;; Is this the %0 case?
 34163                                  ; $IF NE					;;AN000;; No
 34164 000052EA 7412                    	je	short $MIF187			;;AN000;; Yes			
 34165 000052EC 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34166                                  ;; $IF NZ					;;AN000;; No
 34167 000052EE 7406                    	jz	short $MIF188			;;AN000;; Yes
 34168 000052F0 49                      	dec	cx				;;AN000;; Decrement total size (%)
 34169 000052F1 49                      	dec	cx				;;AN000;; Decrement total size (#)
 34170 000052F2 47                      	inc	di				;;AN000;; Go past %
 34171 000052F3 47                      	inc	di				;;AN000;; Go past replace number
 34172                                  ;; $ELSE					;;AN000;; Yes, (Note this will not leave because INC)
 34173                                  	;jmp	short $MEN188
 34174                                  	; 28/04/2023
 34175 000052F4 EB15                    	jmp	short $MEN187
 34176                                  $MIF188:
 34177 000052F6 5E                      	pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34178                                  ;; $ENDIF					;;AN000;; Yes, Note this will not leave because INC
 34179                                  $MEN188:
 34180                                  ; $ELSE 					;;AN000;;
 34181                                  	;jmp	short $MEN187
 34182                                  	; 28/04/2023
 34183                                  	; zf = 1
 34184                                  	;jmp	short $MEN165 
 34185                                  
 34186                                  ; 28/04/2023
 34187                                  $MXL4:
 34188                                  $MLL214:
 34189                                  $MEN165:
 34190 000052F7 C706[0B87]0000          	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34191                                  	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34192                                  						;;AN000;; Reset message number to null
 34193 000052FD C3                      	retn					;;AN000;; Return
 34194                                  
 34195                                  $MIF187:
 34196 000052FE 09C9                    	or	cx,cx				;;AN000;; Are we finished the whole message?
 34197                                  ;; $IF Z					;;AN004;; No
 34198                                  	;jnz	short $MIF192
 34199                                  	;pop	si				;;AN000;; Get back pointer to beginning of SUBLISTs
 34200                                  ;; $ELSE					;;AN000;; No
 34201                                  	;jmp	short $MEN192
 34202                                  	; 28/04/2023
 34203 00005300 74F4                    	jz	short $MIF188
 34204                                  $MIF192:
 34205 00005302 83F9FF                  	cmp	cx,-1				;;AN004;; Are we at the end of the message?
 34206                                  ;;; $IF Z					;;AN004;; No
 34207 00005305 7502                    	jnz	short $MIF194
 34208 00005307 31C9                    	xor	cx,cx				;;AN004;;
 34209                                  ;;; $ENDIF					;;AN000;;
 34210                                  $MIF194:
 34211 00005309 09FF                    	or	di,di				;;AN004;; Turn ZF off
 34212                                  ;; $ENDIF					;;AN000;;
 34213                                  $MEN192:
 34214                                  ; $ENDIF					;;AN000;; Note this will not leave because INC
 34215                                  $MEN187:
 34216                                  ; $LEAVE Z					;;AN000;;
 34217 0000530B 74EA                    	jz	short $MEN165
 34218                                  	;
 34219 0000530D 55                      	push	bp				;;AN000;; Save the replace count
 34220 0000530E 57                      	push	di				;;AN000;; Save location to complete message
 34221 0000530F 06                      	push	es				;;AN000;;
 34222 00005310 51                      	push	cx				;;AN000;; Save size of the rest of the message
 34223 00005311 31C9                    	xor	cx,cx				;;AN000;; Reset CX used for character count
 34224                                  
 34225                                  ;; Determine what action is required on parameter
 34226                                  
 34227 00005313 833E[0B87]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34228                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34229                                  ; $IF E						;;AN000;;
 34230 00005318 753B                    	jne	short $MIF199
 34231                                  
 34232                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34233 0000531A F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34234                                  	;test	byte [si+7],0Fh			;;AN000;;
 34235                                  ;; $IF Z					;;AN000;;
 34236 0000531E 7508                    	jnz	short $MIF200
 34237                                  
 34238                                  ;; Character type requested
 34239                                  
 34240                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34241 00005320 C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34242                                  	;les	di,[si+2]
 34243 00005323 E84801                  	call	$M_CHAR_REPLACE			;;AN000;;
 34244                                  ;; $ELSE					;;AN000;; Get the rest of the message to display
 34245 00005326 EB28                    	jmp	short $MEN200
 34246                                  $MIF200:
 34247                                  ;; ENDIF					;;AN000;;
 34248                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34249 00005328 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34250                                  	;test	byte [si+7],0Dh			;;AN000;;
 34251                                  ;; $IF Z,OR					;;AN000;;
 34252 0000532C 740C                    	jz	short $MLL202
 34253                                  	;test	byte ptr $M_SL.$M_S_FLAG,NOT Unsgn_Bin_Type AND $M_TYPE_MASK
 34254 0000532E F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34255                                  	;test	byte [si+7],0Eh			;;AN000;;
 34256                                  ;;; $IF Z,OR					;;AN000;;
 34257 00005332 7406                    	jz	short $MLL202
 34258                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Bin_Hex_Type and $M_TYPE_MASK
 34259 00005334 F644070C                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Ch
 34260                                  	;test	byte [si+7],0Ch			;;AN000;;
 34261                                  ;;;; $IF Z 					;;AN000;;
 34262 00005338 7508                    	jnz	short $MIF202
 34263                                  $MLL202:
 34264                                  
 34265                                  ;; Numeric type requested
 34266                                  
 34267                                  	;les	di,dword ptr $M_SL.$M_S_VALUE	;;AN000;; Load pointer to replacing parameter
 34268 0000533A C47C02                  	les	di,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34269 0000533D E85601                  	call	$M_BIN2ASC_REPLACE		;;AN000;;
 34270                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34271 00005340 EB0E                    	jmp	short $MEN202
 34272                                  $MIF202:
 34273                                  ;;;; ENDIF					;;AN000;;
 34274                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Date_Type and $M_TYPE_MASK
 34275 00005342 F644070B                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Bh
 34276                                  	;test	byte [si+7],0Bh			;;AN000;;
 34277                                  ;;;; $IF E					;;AN000;;
 34278 00005346 7505                    	jnz	short $MIF204
 34279                                  
 34280                                  ;; Date type requested
 34281                                  
 34282 00005348 E8BE01                  	call	$M_DATE_REPLACE			;;AN000;;
 34283                                  ;;;; $ELSE					;;AN000;; Get the rest of the message to display
 34284 0000534B EB03                    	jmp	short $MEN204
 34285                                  $MIF204:					;;AN000;;
 34286                                  
 34287                                  ;; Time type requested (Default if we have not matched until here)
 34288                                  
 34289 0000534D E87002                  	call	$M_TIME_REPLACE			;;AN000;;
 34290                                  
 34291                                  ;;;; $ENDIF					;;AN000;;
 34292                                  $MEN204:
 34293                                  ;;; $ENDIF					;;AN000;;
 34294                                  $MEN202:
 34295                                  ;; $ENDIF					;;AN000;;
 34296                                  $MEN200:
 34297                                  
 34298                                  ;; With the replace information of the Stack, display the replaceable field
 34299                                  
 34300 00005350 E85F00                  	call	$M_DISPLAY_REPLACE		;;AN000;; Display the replace
 34301                                  
 34302                                  ;; None of the above - Extended/Parse replace
 34303                                  ; $ELSE 					;;AN000;;
 34304 00005353 EB03                    	jmp	short $MEN199
 34305                                  $MIF199:
 34306 00005355 E81600                  	call	$M_EXT_PAR_REPLACE		;;AN000;;
 34307                                  ; $ENDIF					;;AN000;;
 34308                                  $MEN199:
 34309                                  
 34310                                  ;; We must go back and complete the message after the replacable parameter if there is any left
 34311                                  
 34312                                  ; $IF NC					;;AN000;; IF there was an error displaying then EXIT
 34313 00005358 7207                    	jc	short $MIF211
 34314                                  	;
 34315 0000535A 59                      	pop	cx				;;AN000;; Get size of the rest of the message
 34316 0000535B 07                      	pop	es				;;AN000;; Get address of the rest of the message
 34317 0000535C 5F                      	pop	di				;;AN000;;
 34318 0000535D 5D                      	pop	bp				;;AN000;; Get replacment count
 34319 0000535E 5E                      	pop	si				;;AN000;; ELSE get address of first sublist structure
 34320                                  ; $ELSE						;;AN000;;
 34321 0000535F EB03                    	jmp	short $MEN211
 34322                                  $MIF211:
 34323 00005361 83C40A                  	add	sp,10				;;AN000;; Clean up stack if error
 34324                                  	; 28/04/2023
 34325                                  	;stc					;;AN000;;
 34326                                  ; $ENDIF					;;AN000;;
 34327                                  $MEN211:
 34328 00005364 833E[0B87]00            	cmp	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0 ; $M_NULL
 34329                                  	;cmp	word [$M_RT+72],0		;;AN000;; Is this an Extended/Parse case
 34330                                  ; $ENDDO NE,OR					;;AN000;;
 34331 00005369 758C                    	jne	short $MLL214
 34332                                  ; $ENDDO C,LONG					;;AN000;; Go back and display the rest of the message
 34333                                  	; 10/04/2023
 34334                                  	;jc	short $MXL4
 34335 0000536B E90CFF                  	jmp	$MDO165
 34336                                  
 34337                                  ; 28/04/2023
 34338                                  ;$MXL4:
 34339                                  ;$MLL214:
 34340                                  ;$MEN165:
 34341                                  ;	mov	word [$M_RT+$M_RES_ADDRS.$M_MSG_NUM],0
 34342                                  ;	;mov	word [$M_RT+72],0		;;AN000;; IF there was an error displaying then EXIT
 34343                                  ;						;;AN000;; Reset message number to null
 34344                                  ;	retn					;;AN000;; Return
 34345                                  
 34346                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34347                                  ;;
 34348                                  ;;	PROC NAME: $M_EXT_PAR_REPLACE
 34349                                  ;;
 34350                                  ;;	FUNCTION:
 34351                                  ;;	INPUTS:
 34352                                  ;;	OUPUTS:
 34353                                  ;;
 34354                                  ;;	REGS USED:
 34355                                  ;;
 34356                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34357                                  
 34358                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34359                                  
 34360                                  $M_EXT_PAR_REPLACE:
 34361 0000536E 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34362 00005370 A1[0B87]                	mov	ax,[$M_RT+$M_RES_ADDRS.$M_MSG_NUM]
 34363                                  	;mov	ax,[$M_RT+72]			;;AN000;; Prepare for get binary value (LOW)
 34364 00005373 C706[0D87]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34365                                  	;mov	word [$M_RT+74],10 ; $M_BASE10	;;AN000;; Set default divisor
 34366 00005379 E8B0FE                  	call	$M_CONVERT2ASC			;;AN000;;
 34367                                  $MDO215:
 34368 0000537C 58                      	pop	ax				;;AN000;; Get character in register
 34369 0000537D 8887[0F87]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34370                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34371 00005381 43                      	inc	bx				;;AN000;; Increase buffer count
 34372 00005382 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34373 00005385 7503                    	jne	short $MIF216			;;AN000;; No
 34374 00005387 E80D00                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34375                                  $MIF216:
 34376 0000538A FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34377 0000538C 75EE                    	jnz	short $MDO215
 34378                                  
 34379 0000538E B80D0A                  	mov	ax,0A0Dh ; mov ax,$M_CR_LF	;;AN000;; Move char into the buffer
 34380 00005391 8987[0F87]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],ax
 34381                                  	;;mov	[bx+$M_RT+76],ax		;;AN000;; Move char into the buffer
 34382 00005395 43                      	inc	bx				;;AN000;; Increase buffer count
 34383 00005396 43                      	inc	bx				;;AN000;; Increase buffer count
 34384                                  	;call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34385                                  	;retn					;;AN000::
 34386                                  	; 11/04/2023
 34387                                  	;jmp	$M_FLUSH_BUF
 34388                                  
 34389                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34390                                  ;;
 34391                                  ;;	PROC NAME: $M_FLUSH_BUFFER
 34392                                  ;;
 34393                                  ;;	FUNCTION: Display the contents of the temporary buffer
 34394                                  ;;	INPUTS: DI contains the number of bytes to display
 34395                                  ;;	OUTPUTS: BX reset to zero
 34396                                  ;;
 34397                                  ;;	REGS USED:
 34398                                  ;;
 34399                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34400                                  	
 34401                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34402                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:56C8h
 34403                                  
 34404                                  $M_FLUSH_BUF:
 34405 00005397 51                      	push	cx				;;AN000;; Save changed regs
 34406 00005398 06                      	push	es				;;AN000;;
 34407 00005399 57                      	push	di				;;AN000;;
 34408 0000539A 1E                      	push	ds				;;AN000;; Set ES pointing to buffer
 34409 0000539B 07                      	pop	es				;;AN000;;
 34410 0000539C 89D9                    	mov	cx,bx				;;AN000;; Set number of bytes to display
 34411 0000539E 31DB                    	xor	bx,bx				;;AN000;; Reset buffer counter
 34412 000053A0 8D3E[0F87]              	lea	di,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34413                                  	;lea	di,[$M_RT+76]			;;AN000;; Reset buffer location pointer
 34414 000053A4 E86BFD                  	call	$M_DISPLAY_STRING		;;AN000;; Display the buffer
 34415 000053A7 7204                    	jc	short $MIF314
 34416 000053A9 5F                      	pop	di				;;AN000;; No, Restore changed regs
 34417 000053AA 07                      	pop	es				;;AN000;;
 34418 000053AB 59                      	pop	cx				;;AN000;;
 34419                                  	;jmp	short $MEN314
 34420                                  	; 11/04/2023
 34421 000053AC C3                      	retn
 34422                                  $MIF314:
 34423 000053AD 83C406                  	add	sp,6				;;AN000;; Fix stack
 34424 000053B0 F9                      	stc					;;AN000;;
 34425                                  $MEN314:
 34426 000053B1 C3                      	retn					;;AN000;; Return
 34427                                  
 34428                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34429                                  ;;
 34430                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34431                                  
 34432                                  	; 11/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34433                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5609h
 34434                                  
 34435                                  $M_DISPLAY_REPLACE:
 34436 000053B2 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34437                                  	;;cmp	$M_SL.$M_S_ID,$M_SPECIAL_CASE-30h ; 0
 34438 000053B4 807C0600                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_ID],0	
 34439                                  	;cmp	byte [si+6],0			;;AN000;; Is this the special case (convert to ASCII)
 34440 000053B8 7511                    	jne	short $MIF276
 34441                                  	
 34442 000053BA C787[0F87]202D          	mov	word [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],2D20h ; $M_SPACE_HYP
 34443                                  	;mov	word [bx+$M_RT+76],2D20h	;;AN000;; Move in a " -"
 34444                                  	
 34445 000053C0 43                      	inc	bx				;;AN000;; Increment count
 34446 000053C1 43                      	inc	bx				;;AN000;; Increment count
 34447                                  	
 34448 000053C2 C687[0F87]20            	mov	byte [bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],20h; $M_SPACE
 34449                                  	;mov	byte [bx+$M_RT+76],20h		;;AN000;; Move in a " "
 34450                                  	
 34451 000053C7 43                      	inc	bx				;;AN000;; Increment count
 34452 000053C8 E8CCFF                  	call	$M_FLUSH_BUF			;;AN000;; Write out " - " to prepare for special case
 34453                                  $MIF276:
 34454 000053CB 5D                      	pop	bp				;;AN000;; Remember the return address
 34455 000053CC 31DB                    	xor	bx,bx				;;AN000;; Use BX for buffer count
 34456 000053CE 31D2                    	xor	dx,dx				;;AN000;; Use DX for count of parms taken off the stack
 34457                                  
 34458 000053D0 880E[0587]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl	;;AN000;; Save size to later clear stack
 34459                                  	;mov	[$M_RT+66],cl
 34460                                  	
 34461                                  	;mov	al,byte ptr $M_SL.$M_S_MINW	;;AN000;; Get the minimum width
 34462 000053D4 8A4409                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_MINW]
 34463                                  	;mov	al,[si+9]
 34464                                  	
 34465 000053D7 38C8                    	cmp	al,cl				;;AN000;; Do we need pad chars added?
 34466 000053D9 761E                    	jna	short $MIF278
 34467 000053DB 28C8                    	sub	al,cl				;;AN000;; Calculate how many pad chars are needed.
 34468 000053DD 88C6                    	mov	dh,al				;;AN000;; Save the number of pad characters
 34469                                  	
 34470                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34471 000053DF F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34472                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be right aligned?
 34473 000053E3 7414                    	jz	short $MIF279			;;AN000;; No
 34474                                  $MDO280:
 34475                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34476 000053E5 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34477                                  	;mov	al,[si+0Ah]
 34478 000053E8 8887[0F87]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34479                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34480                                  	
 34481 000053EC 43                      	inc	bx				;;AN000;;
 34482 000053ED 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; 64		;;AN000;; Is buffer full?
 34483 000053F0 7503                    	jne	short $MIF281
 34484 000053F2 E8A2FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34485                                  $MIF281:
 34486 000053F5 FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34487 000053F7 75EC                    	jnz	short $MDO280
 34488                                  $MIF279:
 34489                                  $MIF278:
 34490                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,$M_UNLIM_W
 34491 000053F9 807C0800                	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],0 ; $M_UNLIM_W
 34492                                  	;cmp	byte [si+8],0			;;AN000;; Is maximum width unlimited
 34493 000053FD 740C                    	je	short $MIF286
 34494                                  	
 34495                                  	;cmp	byte ptr $M_SL.$M_S_MAXW,CL	;;AN000;; Will we exceed maximum width?
 34496 000053FF 384C08                  	cmp	byte [si+$M_SUBLIST_STRUC.$M_S_MAXW],cl
 34497                                  	;;cmp	byte [si+8],cl
 34498 00005402 7307                    	jnb	short $MIF287
 34499                                  
 34500                                  	; 03/05/2023
 34501                                  	;;sub	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Calculate how many extra chars
 34502                                  	;sub	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34503                                  	;;sub	cl,[si+8]
 34504 00005404 88CA                    	mov	dl,cl				;;AN000;; Remember how many chars to pop off
 34505                                  	;;mov	cl,byte ptr $M_SL.$M_S_MAXW	;;AN000;; Set new string length
 34506                                  	;mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34507                                  	;;mov	cl,[si+8]
 34508                                  	; 03/05/2023
 34509 00005406 8A4C08                  	mov	cl,[si+$M_SUBLIST_STRUC.$M_S_MAXW]
 34510 00005409 28CA                    	sub	dl,cl
 34511                                  $MIF287:
 34512                                  $MIF286:
 34513 0000540B 09C9                    	or	cx,cx				;;AN000;;
 34514 0000540D 7424                    	jz	short $MIF290			;;AN000;;
 34515                                  $MDO291:
 34516                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type not $M_TYPE_MASK
 34517 0000540F F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34518                                  	;test	byte [si+7],0Fh			;;AN000;;
 34519 00005413 750C                    	jnz	short $MIF292
 34520                                  
 34521                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34522 00005415 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34523                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?			 
 34524 00005419 7406                    	jz	short $MIF292			;;AN000;; No
 34525                                  
 34526 0000541B 268A05                  	mov	al,[es:di]			;;AN000;; Get first character from string
 34527 0000541E 47                      	inc	di				;;AN000;; Next character in string
 34528 0000541F EB01                    	jmp	short $MEN292
 34529                                  $MIF292:
 34530 00005421 58                      	pop	ax				;;AN000;; Get character in register
 34531                                  $MEN292:
 34532                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34533 00005422 8887[0F87]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34534                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move char into the buffer
 34535                                  	; 03/05/2023
 34536 00005426 43                      	inc	bx				;;AN000;; Increase buffer count
 34537 00005427 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ ; cmp bx,64	;;AN000;; Is buffer full?
 34538 0000542A 7503                    	jne	short $MIF295			;;AN000;;
 34539 0000542C E868FF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34540                                  $MIF295:
 34541 0000542F FEC9                    	dec	cl				;;AN000;; Have we completed replace?
 34542 00005431 75DC                    	jnz	short $MDO291
 34543                                  $MIF290:
 34544                                  	;test	byte ptr $M_SL.$M_S_FLAG,Right_Align
 34545 00005433 F6440780                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],80h
 34546                                  	;test	byte [si+7],80h			;;AN000;; Was replaceable parm to be left aligned?
 34547 00005437 7518                    	jnz	short $MIF299			;;AN000;; Yes
 34548 00005439 08F6                    	or	dh,dh				;;AN000;; Do we need pad chars added?
 34549 0000543B 7414                    	jz	short $MIF300
 34550                                  $MDO301:
 34551                                  	;mov	al,byte ptr $M_SL.$M_S_PAD	;;AN000;;
 34552 0000543D 8A440A                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_PAD]
 34553                                  	;mov	al,[si+0Ah]
 34554                                  
 34555                                  	;mov	byte ptr $M_RT.$M_TEMP_BUF[bx],al
 34556 00005440 8887[0F87]              	mov	[bx+$M_RT+$M_RES_ADDRS.$M_TEMP_BUF],al
 34557                                  	; 03/05/2023
 34558                                  	;mov	[bx+$M_RT+76],al		;;AN000;; Move in a pad char
 34559                                  
 34560 00005444 43                      	inc	bx				;;AN000;;
 34561 00005445 83FB40                  	cmp	bx,$M_TEMP_BUF_SZ  ; 64		;;AN000;; Is buffer full?
 34562 00005448 7503                    	jne	short $MIF302			;;AN000;; No
 34563                                  						;;AN000;; Yes
 34564 0000544A E84AFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer
 34565                                  $MIF302:
 34566 0000544D FECE                    	dec	dh				;;AN000;; Have we filled with enough pad chars?
 34567 0000544F 75EC                    	jnz	short $MDO301			;;AN000;;
 34568                                  $MIF300:
 34569                                  $MIF299:
 34570                                  	;test	byte ptr $M_SL.$M_S_FLAG,not Char_Type and $M_TYPE_MASK
 34571 00005451 F644070F                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Fh
 34572                                  	;test	byte [si+7],0Fh			;;AN000;;
 34573 00005455 7506                    	jnz	short $MIF307
 34574                                  	
 34575                                  	;test	$M_SL.$M_S_FLAG,Char_field_ASCIIZ and $M_SIZE_MASK
 34576 00005457 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34577                                  	;test	byte [si+7],10h			;;AN000;; Is this replace a ASCIIZ string?
 34578                                  	; 11/04/2023
 34579                                  	;jz	short $MIF307			;;AN000;;
 34580                                  	;jmp	short $MEN307			;;AN000;;
 34581 0000545B 750C                    	jnz	short $MEN307
 34582                                  $MIF307:
 34583 0000545D 08D2                    	or	dl,dl				;;AN000;;
 34584 0000545F 7408                    	jz	short $MIF309			;;AN000;;
 34585                                  $MDO310:
 34586 00005461 8F06[0987]              	pop	word [$M_RT+$M_RES_ADDRS.$M_RETURN_ADDR]
 34587                                  	;pop	word [$M_RT+70]			;;AN000;; Clean Up stack using spare variable
 34588 00005465 FECA                    	dec	dl				;;AN000;; Are we done?
 34589 00005467 75F8                    	jnz	short $MDO310
 34590                                  $MIF309:
 34591                                  $MEN307:
 34592 00005469 E82BFF                  	call	$M_FLUSH_BUF			;;AN000;; Flush the buffer for the final time
 34593 0000546C 55                      	push	bp				;;AN000;; Restore the return address
 34594 0000546D C3                      	retn					;;AN000;;
 34595                                  
 34596                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34597                                  ;;
 34598                                  ;;	PROC NAME: $M_CHAR_REPLACE
 34599                                  ;;
 34600                                  ;;	FUNCTION: Will prepare a single char or ASCIIZ string for replace
 34601                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34602                                  ;;		ES:DI contains the VALUE from SUBLIST
 34603                                  ;;	OUTPUTS: CX contains number of characters on stack
 34604                                  ;;		 Top of stack  --> Last character
 34605                                  ;;					. . .
 34606                                  ;;		 Bot of stack  --> First character
 34607                                  ;;
 34608                                  ;;	OTHER REGS Revised: AX
 34609                                  ;;
 34610                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34611                                  
 34612                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34613                                  
 34614                                  $M_CHAR_REPLACE:
 34615 0000546E 5D                      	pop	bp				;;AN000;; Save return address
 34616                                  	;test	$M_SL.$M_S_FLAG,not Char_Field_Char and $M_SIZE_MASK
 34617 0000546F F6440730                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],30h
 34618                                  	;test	byte [si+7],30h			;;AN000;; Was Character specified?
 34619 00005473 7512                    	jnz	short $MIF317			;;AN000;; No
 34620 00005475 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34621 00005478 50                      	push	ax				;;AN000;; Put it on the stack
 34622 00005479 41                      	inc	cx				;;AN000;; Increase the count
 34623 0000547A E88BFD                  	call	$M_IS_IT_DBCS			;;AN000;; Is this the first byte of a DB character
 34624 0000547D 7306                    	jnc	short $MIF318
 34625 0000547F 268A4501                	mov	al,[es:di+1]			;;AN000;; Get the next character
 34626 00005483 50                      	push	ax				;;AN000;; Put it on the stack
 34627 00005484 F8                      	clc					;;AN000;; Clear the carry
 34628                                  $MIF318:
 34629 00005485 EB0D                    	jmp	short $MEN317
 34630                                  $MIF317:
 34631                                  $MDO321:
 34632 00005487 268A05                  	mov	al,[es:di]			;;AN000;; Get the character
 34633 0000548A 08C0                    	or	al,al				;;AN000;; Is it the NULL?
 34634 0000548C 7404                    	jz	short $MEN321			;;AN000;; Yes
 34635 0000548E 47                      	inc	di				;;AN000;; Next character
 34636 0000548F 41                      	inc	cx				;;AN000;; Increment the count
 34637 00005490 EBF5                    	jmp	short $MDO321
 34638                                  $MEN321:
 34639 00005492 29CF                    	sub	di,cx				;;AN000;; Set DI at the beginning of the string
 34640                                  $MEN317:
 34641 00005494 55                      	push	bp				;;AN000;; Restore return address
 34642 00005495 C3                      	retn					;;AN000;;	
 34643                                  
 34644                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34645                                  ;;
 34646                                  ;;	PROC NAME: $M_BIN2ASC_REPLACE
 34647                                  ;;
 34648                                  ;;	FUNCTION: Convert a signed or unsigned binary number to an ASCII string
 34649                                  ;;		  and prepare to display
 34650                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34651                                  ;;		ES:DI contains the VALUE from SUBLIST
 34652                                  ;;	OUTPUTS: CX contains number of characters on stack
 34653                                  ;;		 Top of stack  --> Last character
 34654                                  ;;					. . .
 34655                                  ;;		 Bot of stack  --> First character
 34656                                  ;;	OTHER REGS Revised: BX,DX,AX
 34657                                  ;;
 34658                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34659                                  
 34660                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34661                                  
 34662                                  $M_BIN2ASC_REPLACE:
 34663 00005496 5D                      	pop	bp				;;AN000;; Save return address
 34664 00005497 31D2                    	xor	dx,dx				;;AN000;; Prepare for get binary value (HIGH)
 34665 00005499 31C0                    	xor	ax,ax				;;AN000;; Prepare for get binary value (LOW)
 34666 0000549B C706[0D87]1000          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],16 ; $M_BASE16
 34667                                  	;mov	word [$M_RT+74],16  ; $M_BASE16	;;AN000;; Set default divisor
 34668                                  
 34669 000054A1 31DB                    	xor	bx,bx				;;AN000;; Use BX as the NEG flag (if applicable)
 34670                                  
 34671                                  	;test	$M_SL.$M_S_FLAG,not $M_BYTE and $M_SIZE_MASK
 34672 000054A3 F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 34673                                  	;test	byte [si+7],20h			;;AN000;; Was BYTE specified?		
 34674 000054A7 7511                    	jnz	short $MIF325			;;AN000;; No
 34675                                  	
 34676 000054A9 268A05                  	mov	al,[es:di]			;;AN000;; Setup byte in AL
 34677                                  
 34678                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34679 000054AC F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34680                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?
 34681 000054B0 753D                    	jnz	short $MIF326			;;AN000;; No
 34682                                  			 
 34683 000054B2 A880                    	test	al,10000000b ; 80h		;;AN000;; Is this number negative?
 34684 000054B4 7433                    	jz	short $MIF327			;;AN000;; No
 34685                                  						;;AN000;; Yes				
 34686                                  	; 12/04/2023
 34687                                  	;inc	bx				;;AN000;; Remember that it was negative
 34688 000054B6 247F                    	and	al,01111111b			;;AN000;; Make it positive
 34689                                  
 34690                                  	; 12/04/2023 - Retrop DOS v4.0 COMMAND.COM
 34691                                  	;jmp	short $MIF327
 34692 000054B8 EB2E                    	jmp	short $MIF350 ; inc bx
 34693                                  
 34694                                  ; 12/04/2023
 34695                                  %if 0
 34696                                  
 34697                                  $MIF327:
 34698                                  $MIF335:	; 12/04/2023
 34699                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34700                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34701                                  $MIF326:
 34702                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34703                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34704                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34705                                  	jnz	short $MIF330			;;AN000;; No
 34706                                  						;;AN000;; Yes
 34707                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34708                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34709                                  $MIF330:
 34710                                  	jmp	short $MEN325
 34711                                  
 34712                                  %endif
 34713                                  
 34714                                  $MIF325:
 34715                                  	;test	$M_SL.$M_S_FLAG,not $M_WORD and $M_SIZE_MASK
 34716 000054BA F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34717                                  	;test	byte [si+7],10h			;;AN000;; Was WORD specified?
 34718 000054BE 7513                    	jnz	short $MIF333			;;AN000;; No
 34719                                  						;;AN000;; Yes
 34720 000054C0 268B05                  	mov	ax,[es:di]			;;AN000;; Setup byte in AL
 34721                                  
 34722                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34723 000054C3 F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34724                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 34725 000054C7 7526                    	jnz	short $MIF334			;;AN000;; No
 34726                                  						;;AN000;; Yes
 34727 000054C9 F6C480                  	test	ah,10000000b ; 80h		;;AN000;; Is this number negative?
 34728 000054CC 741B                    	jz	short $MIF335			;;AN000;; No
 34729                                  						;;AN000;; Yes
 34730                                  	; 12/04/2023
 34731                                  	;inc	bx				;;AN000;; Remember that it was negative
 34732 000054CE 80E47F                  	and	ah,01111111b			;;AN000;; Make it positive
 34733                                  
 34734                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 34735                                  	;jmp	short $MIF335
 34736 000054D1 EB15                    	jmp	short $MIF350 ; inc bx
 34737                                  
 34738                                  ; 12/04/2023
 34739                                  %if 0
 34740                                  
 34741                                  $MIF335:
 34742                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34743                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34744                                  $MIF334:
 34745                                  	test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK ;;AN000;; Was Signed binary specified?
 34746                                  	jnz	short $MIF338
 34747                                  
 34748                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34749                                  	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34750                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34751                                  	jnz	short $MIF338			;;AN000;; No
 34752                                  						;;AN000;; Yes
 34753                                  	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34754                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34755                                  $MIF338:
 34756                                  	jmp	short $MEN333			;;AN000;;
 34757                                  %endif
 34758                                  
 34759                                  $MIF333:
 34760 000054D3 268B05                  	mov	ax,[es:di]			;;AN000;; Setup Double word in DX:AX
 34761 000054D6 268B5502                	mov	dx,[es:di+2]			;;AN000;;
 34762                                  
 34763                                  	;test	$M_SL.$M_S_FLAG,not Sgn_Bin_Type and $M_TYPE_MASK
 34764 000054DA F644070D                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Dh
 34765                                  	;test	byte [si+7],0Dh			;;AN000;; Was Signed binary specified?	
 34766 000054DE 750F                    	jnz	short $MIF341			;;AN000;; No
 34767                                  						;;AN000;; Yes
 34768 000054E0 F6C680                  	test	dh,10000000b ; 80h		;;AN000;; Is this number negative?
 34769 000054E3 7404                    	jz	short $MIF342			;;AN000;; No
 34770                                  						;;AN000;; Yes
 34771                                  	; 12/04/2023
 34772                                  	;inc	bx				;;AN000;; Remember that it was negative
 34773 000054E5 80E67F                  	and	dh,01111111b			;;AN000;; Make it positive
 34774                                  	
 34775                                  	; 12/04/2023 - Retro DOS v4.0 COMMAND.COM
 34776                                  $MIF350:
 34777 000054E8 43                      	inc	bx
 34778                                  $MIF342:
 34779                                  	; 12/04/2023
 34780                                  $MIF327:
 34781                                  $MIF335:
 34782 000054E9 C706[0D87]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34783                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34784                                  $MIF341:
 34785                                  $MIF326:
 34786                                  	; 18/04/2023
 34787                                  $MIF334:
 34788                                  	;test	$M_SL.$M_S_FLAG,not Unsgn_Bin_Type and $M_TYPE_MASK
 34789 000054EF F644070E                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],0Eh
 34790                                  	;test	byte [si+7],0Eh			;;AN000;; Was Signed binary specified?
 34791 000054F3 7506                    	jnz	short $MIF345			;;AN000;; No
 34792                                  						;;AN000;; Yes
 34793 000054F5 C706[0D87]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34794                                  	;mov	word [$M_RT+74],10		;;AN000;;
 34795                                  $MIF345:
 34796                                  $MEN333:
 34797                                  $MEN325:
 34798 000054FB E82EFD                  	call	$M_CONVERT2ASC			;;AN000;; Convert to ASCII string
 34799                                  
 34800 000054FE 09DB                    	or	bx,bx				;;AN000;; Was number negative?
 34801 00005500 7405                    	jz	short $MIF349			;;AN000;; No
 34802                                  						;;AN000;; Yes
 34803 00005502 31D2                    	xor	dx,dx				;;AN000;;
 34804 00005504 B22D                    	mov	dl,'-'	; $M_NEG_SIGN		;;AN000;; Put "-" on the stack with the number
 34805 00005506 52                      	push	dx				;;AN000;;
 34806                                  $MIF349:
 34807 00005507 55                      	push	bp				;;AN000;; Restore return address
 34808 00005508 C3                      	retn					;;AN000;; Return
 34809                                  
 34810                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34811                                  ;;
 34812                                  ;;	PROC NAME: $M_DATE_REPLACE
 34813                                  ;;
 34814                                  ;;	FUNCTION: Convert a date to a decimal ASCII string using current
 34815                                  ;;		  country format and prepare to display
 34816                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 34817                                  ;;		ES:DI points at VALUE from SUBLIST
 34818                                  ;;	OUTPUTS: CX contains number of characters on stack
 34819                                  ;;		 Top of stack  --> Last character
 34820                                  ;;					. . .
 34821                                  ;;		 Bot of stack  --> First character
 34822                                  ;;	OTHER REGS Revised: DX,AX
 34823                                  ;;
 34824                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34825                                  
 34826                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34827                                  $M_DATE_REPLACE:
 34828 00005509 5D                      	pop	bp				;;AN000;; Save return address
 34829                                  
 34830 0000550A C706[0D87]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 34831                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 34832                                  	
 34833 00005510 E86700                  	call	$M_GET_DATE			;;AN000;; Set date format/separator in $M_RT
 34834                                  						;;AN000;; All O.K.?
 34835 00005513 31D2                    	xor	dx,dx				;;AN000;; Reset DX value
 34836                                  	; 12/04/2023
 34837                                  	;xor	ax,ax				;;AN000;; Reset AX value
 34838                                  	
 34839                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0
 34840                                  	;;cmp	word [$M_RT+76],0		;;AN000;; USA Date Format
 34841                                  	;jne	short $MIF351
 34842                                  	; 12/04/2023
 34843 00005515 A1[0F87]                	mov	ax,[$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 34844 00005518 09C0                    	or	ax,ax
 34845 0000551A 751D                    	jnz	short $MIF351
 34846                                  
 34847 0000551C E87200                  	call	$M_YEAR				;;AN000;; Get Year
 34848 0000551F E88100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34849                                  
 34850 00005522 FF36[1A87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34851                                  	;push	word [$M_RT+87]			;;AN000;;
 34852                                  	
 34853 00005526 41                      	inc	cx				;;AN000;; Increment count
 34854 00005527 31C0                    	xor	ax,ax				;;AN000;; Reset AX value
 34855                                  
 34856 00005529 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34857                                  	;mov	al,[si+5]			;;AN000;; Get Day
 34858 0000552C E87400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34859                                  	
 34860 0000552F FF36[1A87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34861                                  	;push	word [$M_RT+87]			;;AN000;;
 34862                                  
 34863 00005533 41                      	inc	cx				;;AN000;; Increment count
 34864 00005534 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34865                                  	;mov	al,[si+4]			;;AN000;; Get Month
 34866                                  	; 12/04/2023
 34867                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34868 00005537 EB3C                    	jmp	short $MIF354 ; **
 34869                                  $MIF351:
 34870                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],1
 34871                                  	;;cmp	word [$M_RT+76],1		;;AN000;; EUROPE Date Format
 34872                                  	;jne	short $MIF353
 34873                                  	; 12/04/2023
 34874                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] ; *
 34875 00005539 48                      	dec	ax 
 34876 0000553A 751D                    	jnz	short $MIF352 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] <> 1
 34877                                  
 34878 0000553C E85200                  	call	$M_YEAR				;;AN000;; Get Year
 34879 0000553F E86100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34880                                  
 34881 00005542 FF36[1A87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34882                                  	;push	word [$M_RT+87]			;;AN000;;
 34883                                  	
 34884 00005546 41                      	inc	cx				;;AN000;; Increment count
 34885 00005547 31C0                    	xor	ax,ax				;;AN000;; Reset AX
 34886                                  
 34887 00005549 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34888                                  	;mov	al,[si+4]			;;AN000;; Get Month
 34889 0000554C E85400                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34890                                  
 34891 0000554F FF36[1A87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34892                                  	;push	word [$M_RT+87]			;;AN000;;
 34893                                  
 34894 00005553 41                      	inc	cx				;;AN000;;
 34895                                  	      
 34896 00005554 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34897                                  	;mov	al,[si+5]			;;AN000;; Get Day
 34898                                  
 34899                                  	; 12/04/2023
 34900                                  	;call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34901 00005557 EB1C                    	jmp	short $MIF354 ; **
 34902                                  	; 12/04/2023
 34903                                  $MIF352:
 34904                                  	; ax = [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT]-1 ; *
 34905 00005559 48                      	dec	ax
 34906                                  	;jz	short $MIF353 ; word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT] = 2
 34907                                  	;xor	ax,ax
 34908                                  	;jmp	short $MIF355
 34909                                  	; 12/04/2023
 34910 0000555A 751C                    	jnz	short $MIF355
 34911                                  $MIF353:
 34912                                  	;cmp	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],2
 34913                                  	;;cmp	word [$M_RT+76],2		;;AN000;; JAPAN Date Format
 34914                                  	;jne	short $MIF355
 34915                                  
 34916 0000555C 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 34917                                  	;mov	al,[si+5]			;;AN000;; Get Day
 34918 0000555F E84100                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34919                                  	
 34920 00005562 FF36[1A87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34921                                  	;push	word [$M_RT+87]			;;AN000;;
 34922                                  
 34923 00005566 41                      	inc	cx				;;AN000;;
 34924                                  
 34925 00005567 8A4404                  	 mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 34926                                  	;mov	al,[si+4]			;;AN000;; Get Month
 34927 0000556A E83600                  	call	$M_CONVERTDATE			;;AN000;; Convert it to an ASCII string
 34928                                  	
 34929 0000556D FF36[1A87]              	 push	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA]
 34930                                  	;push	word [$M_RT+87]			;;AN000;;
 34931                                  	
 34932 00005571 41                      	inc	cx				;;AN000;;
 34933                                  
 34934 00005572 E81C00                  	call	$M_YEAR				;;AN000;; Get Year
 34935                                  	; 12/04/2023
 34936                                  $MIF354:
 34937 00005575 E82B00                  	call	$M_CONVERTDATE	; **		;;AN000;; Convert it to an ASCII string
 34938                                  $MIF355:
 34939 00005578 55                      	push	bp				;;AN000;; Restore return address
 34940 00005579 C3                      	retn					;;AN000;; Return
 34941                                  
 34942                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34943                                  ;;
 34944                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34945                                  
 34946                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34947                                  $M_GET_DATE:
 34948                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 34949                                  	;mov	al,0 				;;AN000;; Get current country info
 34950                                  	; 12/04/2023
 34951 0000557A B80038                  	mov	ax,3800h
 34952                                  	;
 34953 0000557D 8D16[0F87]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34954                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 34955 00005581 CD21                    	int	21h				;;AN000;;
 34956 00005583 730B                    	jnc	short $MIF357
 34957                                  	;
 34958 00005585 C706[0F87]0000          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_DATE_FORMAT],0 ; $M_DEF_DATE_FORM
 34959                                  	;mov	word [$M_RT+76+0],0		;;AN000;; Set default date format (BH)
 34960 0000558B C606[1A87]2D            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DATE_SEPARA],'-' ; $M_DEF_DATE_SEP
 34961                                  	;mov	byte [$M_RT+87],'-'		;;AN000;; Set default date separator (BL)
 34962                                  $MIF357:
 34963 00005590 C3                      	retn					;;AN000;;
 34964                                  
 34965                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34966                                  ;;
 34967                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34968                                  
 34969                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34970                                  $M_YEAR:
 34971 00005591 8B4402                  	mov	ax,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 34972                                  	;mov	ax,[si+2]			;;AN000;; Get Year
 34973                                  
 34974                                  	;test	$M_SL.$M_S_FLAG,Date_MDY_4 and $M_DATE_MASK
 34975 00005594 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 34976                                  	;test	byte [si+7],10h			;;AN000;; Was Month/Day/Year (2 Digits) specified?
 34977 00005598 7508                    	jnz	short $MIF359			;;AN000;; No
 34978                                  						;;AN000;; Yes
 34979 0000559A 83F863                  	cmp	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 34980 0000559D 7603                    	jna	short $MIF360			;;AN000;;
 34981 0000559F B86300                  	mov	ax,99 ; $M_MAX_2_YEAR		;;AN000;;
 34982                                  $MIF360:
 34983                                  $MIF359:
 34984 000055A2 C3                      	retn					;;AN000;;
 34985                                  
 34986                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34987                                  ;;
 34988                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 34989                                  
 34990                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 34991                                  $M_CONVERTDATE:
 34992                                  $M_CONVERTTIME: ; *!*!  ; 12/04/2023
 34993 000055A3 8F06[0F87]              	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 34994                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 34995 000055A7 880E[0587]              	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 34996                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 34997 000055AB E87EFC                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 34998 000055AE 49                      	dec	cx				;;AN000;; Test if size only grew by 1
 34999 000055AF 3A0E[0587]              	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35000 000055B3 7505                    	jne	short $MIF363			;;AN000;; No
 35001 000055B5 B83000                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35002 000055B8 50                      	push	ax				;;AN000;; Save it
 35003 000055B9 41                      	inc	cx				;;AN000;; Count it
 35004                                  $MIF363:
 35005 000055BA 41                      	inc	cx				;;AN000;; Restore CX
 35006 000055BB FF36[0F87]              	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35007                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35008 000055BF C3                      	retn
 35009                                  
 35010                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35011                                  ;;
 35012                                  ;;	PROC NAME: $M_TIME_REPLACE
 35013                                  ;;
 35014                                  ;;	FUNCTION: Convert a time to a decimal ASCII string
 35015                                  ;;		  and prepare to display
 35016                                  ;;	INPUTS: DS:SI points at corresponding SUBLIST
 35017                                  ;;		ES:DI points at VALUE from SUBLIST
 35018                                  ;;	OUTPUTS: CX contains number of characters on stack
 35019                                  ;;		 Top of stack  --> Last character
 35020                                  ;;					. . .
 35021                                  ;;		 Bot of stack  --> First character
 35022                                  ;;	REGS USED: BP,CX,AX
 35023                                  ;;
 35024                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35025                                  
 35026                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM							     ;;
 35027                                  $M_TIME_REPLACE:
 35028 000055C0 5D                      	pop	bp				;;AN000;; Save return address
 35029                                  
 35030 000055C1 C706[0D87]0A00          	mov	word [$M_RT+$M_RES_ADDRS.$M_DIVISOR],10 ; $M_BASE10
 35031                                  	;mov	word [$M_RT+74],10		;;AN000;; Set default divisor
 35032                                  
 35033 000055C7 E87800                  	call	$M_GET_TIME			;;AN000;; All O.K.?
 35034                                  
 35035                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35036 000055CA F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1
 35037                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35038 000055CE 741A                    	jz	short $MIF365			;;AN000;; No
 35039                                  						;;AN000;; Yes
 35040 000055D0 803E[2087]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35041                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35042 000055D5 7513                    	jne	short $MIF366			;;AN000;; No
 35043                                  						;;AN000;; Yes
 35044 000055D7 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35045                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35046 000055DA 3C0C                    	cmp	al,12				;;AN000;; Is hour 12 or less?
 35047 000055DC 7C04                    	jl	short $MLL367 ; jnge		;;AN000;; Yes	
 35048 000055DE 3C17                    	cmp	al,23				;;AN000;; Is hour 24 or greater?
 35049 000055E0 7E04                    	jng	short $MIF367 ; jle		;;AN000;; No
 35050                                  $MLL367:
 35051 000055E2 B061                    	mov	al,'a'	; $M_AM			;;AN000;;
 35052                                  	;push	ax				;;AN000;; Push an "a" to represent AM.
 35053                                  	;inc	cx				;;AN000;;
 35054                                  	;jmp	short $MEN367			;;AN000;;
 35055                                  	; 12/04/2023
 35056 000055E4 EB02                    	jmp	short $MEN367 ; *
 35057                                  $MIF367:
 35058 000055E6 B070                    	mov	al,'p'	; $M_PM			;;AN000;;
 35059                                  $MEN367:	; * ; 12/04/2023
 35060 000055E8 50                      	push	ax				;;AN000;; Push an "p" to represent PM.
 35061 000055E9 41                      	inc	cx				;;AN000;;
 35062                                  ;$MEN367:
 35063                                  $MIF366:
 35064                                  $MIF365:					;;AN000;;
 35065 000055EA 31C0                    	xor	ax,ax				;;AN000;;
 35066 000055EC 31D2                    	xor	dx,dx				;;AN000;;
 35067                                  	
 35068                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35069 000055EE F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35070                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35071 000055F2 740B                    	jz	short $MIF372			;;AN000;;
 35072                                  
 35073 000055F4 8A4405                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+3]
 35074                                  	;mov	al,[si+5]			;;AN000;; Get Hundreds
 35075 000055F7 E8A9FF                  	call	$M_CONVERTTIME			;;AN000;;
 35076                                  
 35077 000055FA FF36[1887]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA]
 35078                                  	;push	word [$M_RT+85]			;;AN000;;
 35079 000055FE 41                      	inc	cx				;;AN000;;
 35080                                  $MIF372:
 35081                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSSHH_Cty and $M_SIZE_MASK
 35082 000055FF F6440720                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],20h
 35083                                  	;test	byte [si+7],20h			;;AN000;; Was Hour/Min/Sec/Hunds (12 Hour) specified?
 35084 00005603 7506                    	jnz	short $MLL374			;;AN000;; No
 35085                                  
 35086                                  	;test	$M_SL.$M_S_FLAG,Time_HHMMSS_Cty AND $M_SIZE_MASK
 35087 00005605 F6440710                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],10h
 35088                                  	;test	byte [si+7],10h			;;AN000;; Was Hour/Min/Sec (12 Hour) specified?
 35089 00005609 740B                    	jz	short $MIF374			;;AN000;; No
 35090                                  $MLL374:
 35091 0000560B 8A4404                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+2]
 35092                                  	;mov	al,[si+4]			;;AN000;; Get Seconds
 35093 0000560E E892FF                  	call	$M_CONVERTTIME			;;AN000;;
 35094                                  
 35095 00005611 FF36[1C87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35096                                  	;push	word [$M_RT+89]			;;AN000;;
 35097 00005615 41                      	inc	cx				;;AN000;;
 35098                                  $MIF374:	;;  Do Hour/Min (12 Hour)
 35099 00005616 8A4403                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE+1]
 35100                                  	;mov	al,[si+3]			;;AN000;; Get Minutes
 35101 00005619 E887FF                  	call	$M_CONVERTTIME			;;AN000;;
 35102                                  
 35103 0000561C FF36[1C87]              	push	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA]
 35104                                  	;push	word [$M_RT+89]			;;AN000;;
 35105 00005620 41                      	inc	cx				;;AN000;;
 35106                                  
 35107 00005621 8A4402                  	mov	al,[si+$M_SUBLIST_STRUC.$M_S_VALUE]
 35108                                  	;mov	al,[si+2]			;;AN000;; Get Hours
 35109                                  
 35110                                  	;test	$M_SL.$M_S_FLAG,Time_Cty_Type and $M_TIME_MASK
 35111 00005624 F6440701                	test	byte [si+$M_SUBLIST_STRUC.$M_S_FLAG],1 
 35112                                  	;test	byte [si+7],1			;;AN000;; Is this a request for current country info?
 35113 00005628 7413                    	jz	short $MIF376			;;AN000;; No
 35114                                  
 35115 0000562A 803E[2087]00            	cmp	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],0
 35116                                  	;cmp	byte [$M_RT+93],0		;;AN000;; Is the current country format 12 Hour?
 35117 0000562F 750C                    	jne	short $MIF377			;;AN000;; No
 35118                                  
 35119 00005631 3C0D                    	cmp	al,13				;;AN000;; Is hour less than 12?
 35120 00005633 7C02                    	jnge	short $MIF378 ; jl
 35121 00005635 2C0C                    	sub	al,12				;;AN000;; Set to a 12 hour value
 35122                                  $MIF378:
 35123                                  	;cmp	al,0				;;AN000;; Is hour less than 12?
 35124                                  	;jne	short $MIF380			;;AN000;; No
 35125                                  	; 12/04/2023
 35126 00005637 20C0                    	and	al,al
 35127 00005639 7502                    	jnz	short $MIF380	
 35128 0000563B B00C                    	mov	al,12				;;AN000;; Set to a 12 hour value
 35129                                  $MIF380:
 35130                                  $MIF377:
 35131                                  $MIF376:
 35132 0000563D E8ECFB                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to ASCII
 35133 00005640 55                      	push	bp				;;AN000;; Restore return address
 35134 00005641 C3                      	retn					;;AN000;; Return
 35135                                  
 35136                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35137                                  ;;
 35138                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35139                                  
 35140                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35141                                  $M_GET_TIME:
 35142                                  	;mov	ah,38h ; DOS_GET_COUNTRY	;;AN000;; Call DOS for country dependant info
 35143                                  	;mov	al,0 				;;AN000;; Get current country info
 35144                                  	; 12/04/2023
 35145 00005642 B80038                  	mov	ax,3800h
 35146                                  	;
 35147 00005645 8D16[0F87]              	lea	dx,[$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35148                                  	;lea	dx,[$M_RT+76]			;;AN000;; Set up addressibility to buffer
 35149 00005649 CD21                    	int	21h				;;AN000;;
 35150 0000564B 7310                    	jnc	short $MIF384
 35151                                  
 35152 0000564D C706[2087]0100          	mov	word [$M_RT+$M_COUNTRY_INFO.$M_TIME_FORMAT],1 ; $M_DEF_TIME_FORM
 35153                                  	;mov	word [$M_RT+93],1		;;AN000;; Set default time format (BH)
 35154 00005653 C606[1C87]3A            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_TIME_SEPARA],':' ; $M_DEF_TIME_SEP
 35155                                  	;mov	byte [$M_RT+89],':'		;;AN000;; Set default time separator (BL)
 35156 00005658 C606[1887]2E            	mov	byte [$M_RT+$M_COUNTRY_INFO.$M_DECI_SEPARA],'.' ; $M_DEF_DECI_SEP
 35157                                  	;mov	byte [$M_RT+85],'.'		;;AN000;; Set default time separator (BL)		
 35158                                  $MIF384:
 35159 0000565D C3                      	retn					;;AN000;;
 35160                                  
 35161                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35162                                  ;;
 35163                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 35164                                  
 35165                                  	; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35166                                  
 35167                                  ; 12/04/2023 
 35168                                  ;; ($M_CONVERTTIME is same with $M_CONVERTDATE)
 35169                                  %if 0
 35170                                  $M_CONVERTTIME:
 35171                                  $M_CONVERTDATE: ; *!*!  ; 12/04/2023
 35172                                  	pop	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35173                                  	;pop	word [$M_RT+76]			;;AN000;; Save return address
 35174                                  	mov	[$M_RT+$M_RES_ADDRS.$M_SIZE],cl
 35175                                  	;mov	[$M_RT+66],cl			;;AN000;; Save the size before conversion
 35176                                  	call	$M_CONVERT2ASC			;;AN000;; Convert it to an ASCII string
 35177                                  	dec	cx				;;AN000;; Test if size only grew by 1
 35178                                  	cmp	cl,[$M_RT+$M_RES_ADDRS.$M_SIZE] ;;AN000;; Did size only grow by one?
 35179                                  	jne	short $MIF386			;;AN000;; No
 35180                                  	mov	ax,'0' ; $M_TIMEDATE_PAD ; 30h  ;;AN000;; Get a pad character (0)
 35181                                  	push	ax				;;AN000;; Save it
 35182                                  	inc	cx				;;AN000;; Count itount it
 35183                                  $MIF386:
 35184                                  	inc	cx				;;AN000;; Restore CX
 35185                                  	push	word [$M_RT+$M_RES_ADDRS.$M_TEMP_BUF]
 35186                                  	;push	word [$M_RT+76]			;;AN000;; Restore return address
 35187                                  	retn
 35188                                  %endif
 35189                                  
 35190                                  ; ----------------------------
 35191                                  ; MSDOS 6.0, TPRINTF.ASM, 1991
 35192                                  ; ----------------------------
 35193                                  ; include msgdcl.inc
 35194                                  ; ----------------------------
 35195                                  
 35196                                  ;============================================================================
 35197                                  ; LOADHIGH.ASM, MSDOS 6.0, 1991
 35198                                  ;============================================================================
 35199                                  ; 12/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35200                                  
 35201                                  ; This is a new module added to support loading programs into UMBs provided
 35202                                  ; by DOS 5.0. 
 35203                                  ; ---------------------------------------------------------------------------
 35204                                  ; Usage:
 35205                                  ;
 35206                                  ; LOADHIGH [/L:umb[,size][;umb[,size]]*] <filespec>
 35207                                  ;
 35208                                  ; <filespec> has to be a filename that is not wildcarded.
 35209                                  
 35210                                  ; ---------------------------------------------------------------------------
 35211                                  ;
 35212                                  ;	Revision History
 35213                                  ;	================
 35214                                  ;
 35215                                  ;	M009	SR	08/01/90	Set flags to indicate that we are
 35216                                  ;				loading and high and also remember
 35217                                  ;				current UMB state.
 35218                                  ;
 35219                                  ;	M016	SR	08/09/90	Give special error message on attempt
 35220                                  ;				to loadhigh batch files and invalid
 35221                                  ;				filename on Loadhigh command line.
 35222                                  ;
 35223                                  ;	M039	SR	11/19/90	Bug #4270. Copy all the whitespaces
 35224                                  ;				after the program name also as part
 35225                                  ;				of the command line being passed to
 35226                                  ;				the program to be invoked.
 35227                                  ;
 35228                                  ; ---------------------------------------------------------------------------
 35229                                  
 35230                                  ; ---------------------------------------------------------------------------
 35231                                  ;
 35232                                  ;	include highload.inc		; Grab code for ParseVar and such
 35233                                  
 35234                                  iCmdLine	equ	81h		; PSP:81h points to command-line
 35235                                  
 35236                                  ;
 35237                                  ; ---------------------------------------------------------------------------
 35238                                  
 35239                                  ;****	LoadHigh -- Main routine for Loadhigh command
 35240                                  ;
 35241                                  ;	ENTRY	Command line tail is at PSP:iCmdLine terminated by 0dh
 35242                                  ;		CS = DS = SS = TRANGROUP
 35243                                  ;
 35244                                  ;	EXIT	None
 35245                                  ;
 35246                                  ;	USED	ax, bx, cx, dx, si, di, es
 35247                                  ;
 35248                                  ;	ERROR EXITS
 35249                                  ;		Message pointers are setup at the error locations and then
 35250                                  ;	we jump back to CERROR which is the transient error recycle point.
 35251                                  ;	Apart from parse errors, the other errors handled are too many
 35252                                  ;	switches anf invalid filenames.
 35253                                  ;
 35254                                  ;	EFFECTS
 35255                                  ;		The allocation strategy and the state of the arena chain are
 35256                                  ;	put in the requested state according to the given options. If a 
 35257                                  ;	filename is also given, it is executed as well.
 35258                                  ; ---------------------------------------------------------------------------
 35259                                  
 35260                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35261                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5927h
 35262                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35263                                  LoadHigh:
 35264 0000565E 1E                      	push	ds
 35265 0000565F 07                      	pop	es
 35266                                  
 35267 00005660 E86700                  	call	SkipLhDelims
 35268                                  
 35269                                  ;Get command tail to be passed to the program. This includes any whitespace
 35270                                  ;chars between the program name and its parameters as well.
 35271                                  ;On return, ds:si points at the start of the command tail.
 35272                                  
 35273 00005663 56                      	push	si
 35274 00005664 E81400                  	call	ParseLhCmd
 35275 00005667 5E                      	pop	si
 35276 00005668 720E                    	jc	short LhErr
 35277                                  	
 35278 0000566A E87500                  	call	SetupCmdLine		;setup pgm's command line
 35279                                  
 35280 0000566D E8C800                  	call	SetupPath		;setup path for file
 35281 00005670 7206                    	jc	short LhErr		;file not found
 35282                                  
 35283                                  ;Set allocation strategy to HighFirst and link in UMBs for exec. This will
 35284                                  ;be reset after return from the Exec
 35285                                  ;We will also set a resident flag to indicate that UMBs were activated for
 35286                                  ;the Exec. On return from the Exec, this flag will be used to deactivate UMBs
 35287                                  
 35288 00005672 E8A600                  	call	HideUMBs		;prepare upper-memory for load
 35289                                  
 35290 00005675 E980D2                  	jmp	LH_EXECUTE		;go and exec file ;M051
 35291                                  
 35292                                  LhErr:
 35293                                  ;The error message has been setup at this stage
 35294                                  
 35295 00005678 E9D0D2                  	jmp	cerror			;print error message and recycle 
 35296                                  
 35297                                  ; ---------------------------------------------------------------------------
 35298                                  					
 35299                                  ;*** 	ParseLhCmd - parses any command-line options
 35300                                  ;
 35301                                  ;	ENTRY	None
 35302                                  ;
 35303                                  ;	EXIT	Carry clear -- command line parsed successfully
 35304                                  ;		Carry set -- appropriate error message setup
 35305                                  ;
 35306                                  ;	USED	ax, si
 35307                                  ;
 35308                                  ;	EFFECTS
 35309                                  ;		Options set up (see highvar.inc)
 35310                                  ;		Filename to be executed setup
 35311                                  ;
 35312                                  ;	ParseLhCmd calls InitVar to initialize data filled in by ParseVar,
 35313                                  ;	then calls ParseVar itself to actually parse the commmand-line.  On
 35314                                  ;	return from ParseVar, DS:SI will point to the beginning of the child
 35315                                  ;	module's name on the command-line; thus it calls LhCopyFilename to
 35316                                  ;	prepare the command-line for that program.
 35317                                  ; ---------------------------------------------------------------------------
 35318                                  
 35319                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35320                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5944h
 35321                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35322                                  	; 11/06/2023
 35323                                  ParseLhCmd:
 35324                                  	;mov	si,81h
 35325 0000567B BE8100                  	mov	si,iCmdLine	;ds:si points at command line
 35326                                  
 35327 0000567E C706[B38A]0000          	mov	word [COMSW],0
 35328 00005684 BF[D885]                	mov	di,Parse_LoadHi
 35329 00005687 31C9                    	xor	cx,cx
 35330 00005689 E826CB                  	call	Parse_With_Msg
 35331                                  
 35332                                  	; 11/06/2023
 35333                                  	;cmp	ax,0FFFFh ; -1
 35334                                  	;jz	short PLhCmd2
 35335                                  	;cmp	ax,0
 35336                                  	;jnz	short PLhCmd1
 35337                                  	; 11/06/2023
 35338 0000568C 40                      	inc	ax ; cmp ax,-1
 35339 0000568D 7408                    	jz	short PLhCmd2 ; 0FFFFh -> 0
 35340 0000568F 48                      	dec	ax ; cmp ax,0
 35341 00005690 7504                    	jnz	short PLhCmd1 ; 1 -> 0
 35342                                  	; ax = 0
 35343                                  
 35344 00005692 89D3                    	mov	bx,dx
 35345                                  	; 14/04/2023
 35346                                  	;call	LhCopyFilename
 35347                                  	;; 13/04/2023
 35348                                  	;;;jc	short PLhCmd2  ; !!! jmp short PLhCmd2 !!!
 35349                                  	;;jmp	short PLhCmd2
 35350                                  	;retn
 35351                                  	; 14/04/2023
 35352 00005694 EB02                    	jmp	short LhCopyFilename
 35353                                  PLhCmd1:
 35354 00005696 F9                      	stc
 35355                                  PLhCmd2:
 35356 00005697 C3                      	retn
 35357                                  
 35358                                  ; ---------------------------------------------------------------------------
 35359                                  
 35360                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35361                                  
 35362                                  ; ---------------------------------------------------------------------------
 35363                                  ; HIGHlOAD.INC, MSDOS 6.0, 1992
 35364                                  ; ---------------------------------------------------------------------------
 35365                                  
 35366                                  	; 13/04/2023
 35367                                  	; MSDOS 5.0 COMMAND.COM only !
 35368                                  	; (Procedure names are not from original Microsoft source code!)
 35369                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35370                                  ;set_strategy:
 35371                                  	;mov	ax,5800h	; DOS_CHECK_STRATEGY
 35372                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35373                                  	;		; AL = function code: get allocation strategy
 35374                                  	;mov	bx,ax
 35375                                  	;or	bx,80h
 35376                                  	;mov	ax,5801h	; DOS_SET_STRATEGY
 35377                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35378                                  	;		; AL = function code: set allocation strategy
 35379                                  	;retn
 35380                                  
 35381                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35382                                  ;set_umblink:
 35383                                  	;mov	ax,5803h	; DOS_SET_UMBLINK
 35384                                  	;mov	bx,1
 35385                                  	;int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35386                                  	;		; AL = function code: (DOS 5beta) set UMB link state
 35387                                  	;retn
 35388                                  
 35389                                  ; ---------------------------------------------------------------------------
 35390                                  
 35391                                  ;***	LhCopyFilename -- copy filename from command line to buffer
 35392                                  ;
 35393                                  ;	ENTRY	ds:si points at primary argument (filename)
 35394                                  ;
 35395                                  ;	EXIT	Carry set -- filename has wildcards.  In this event, DX will
 35396                                  ;				already contain an appropriate error number.
 35397                                  ;		Carry clear -- filename has been copied as needed; DS:SI
 35398                                  ;				points to first character (most likely space)
 35399                                  ;				after filename.
 35400                                  ;
 35401                                  ;	USED	ax, si
 35402                                  ;
 35403                                  ;	EFFECTS
 35404                                  ;		ExecPath contains the filename
 35405                                  ;
 35406                                  ; If there are any wildcards in the filename, then we have an error
 35407                                  ; ---------------------------------------------------------------------------
 35408                                  
 35409                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35410                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5984h
 35411                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35412                                  LhCopyFilename:
 35413 00005698 1E                      	push	ds
 35414 00005699 56                      	push	si
 35415 0000569A 57                      	push	di
 35416 0000569B C57704                  	lds	si,[bx+4]
 35417 0000569E BF[C489]                	mov	di,EXECPATH
 35418                                  lhcpfn1:
 35419 000056A1 AC                      	lodsb
 35420 000056A2 3C2A                    	cmp	al,2Ah ; '*'
 35421 000056A4 740D                    	jz	short lhfilerr
 35422 000056A6 3C3F                    	cmp	al,3Fh ; '?'
 35423 000056A8 7409                    	jz	short lhfilerr
 35424 000056AA AA                      	stosb
 35425 000056AB 08C0                    	or	al,al
 35426 000056AD 75F2                    	jnz	short lhcpfn1
 35427                                  	; 14/04/2023
 35428                                  	; cf = 0
 35429                                  	;clc
 35430                                  lhfilerr2:
 35431 000056AF 5F                      	pop	di
 35432 000056B0 5E                      	pop	si
 35433 000056B1 1F                      	pop	ds
 35434 000056B2 C3                      	retn
 35435                                  lhfilerr:
 35436 000056B3 BA[9B81]                	mov	dx,LhInvFil_Ptr
 35437 000056B6 F9                      	stc
 35438 000056B7 EBF6                    	jmp	short lhfilerr2
 35439                                  
 35440                                  ; ---------------------------------------------------------------------------
 35441                                  	
 35442                                  	; 14/04/2023
 35443                                  	; 13/04/2023
 35444                                  	; MSDOS 5.0 COMMAND.COM only !
 35445                                  	; (Procedure name is not from original Microsoft source code!)
 35446                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:596Ah
 35447                                  set_strategy:
 35448 000056B9 B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35449 000056BC CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35450                                  			; AL = function code: get allocation strategy
 35451 000056BE 89C3                    	mov	bx,ax
 35452 000056C0 81CB8000                	or	bx,80h
 35453 000056C4 B80158                  	mov	ax,5801h	; DOS_SET_STRATEGY
 35454 000056C7 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35455                                  			; AL = function code: set allocation strategy
 35456 000056C9 C3                      	retn
 35457                                  
 35458                                  ; ---------------------------------------------------------------------------
 35459                                  
 35460                                  	; 13/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35461                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59A6h
 35462                                  	; MSDOS 5.0 COMMAND.COM only !
 35463                                  	; (Procedure name is not from original Microsoft source code!)
 35464                                  SkipLhDelims:
 35465 000056CA BE8100                  	mov	si,81h
 35466 000056CD E807CF                  	call	scanoff
 35467                                  stfn1:
 35468 000056D0 AC                      	lodsb
 35469 000056D1 E80BCF                  	call	DELIM
 35470 000056D4 740A                    	jz	short stfn2
 35471 000056D6 3C0D                    	cmp	al,0Dh
 35472 000056D8 7406                    	jz	short stfn2
 35473 000056DA 3A06[A08A]              	cmp	al,[SWITCHAR]
 35474 000056DE 75F0                    	jnz	short stfn1
 35475                                  stfn2:
 35476 000056E0 4E                      	dec	si
 35477 000056E1 C3                      	retn
 35478                                  
 35479                                  ; ---------------------------------------------------------------------------
 35480                                  
 35481                                  ;***	SetupCmdLine -- prepare command line for the program
 35482                                  ;
 35483                                  ;	ENTRY	{es/ds}:si = points just after the end of the child program
 35484                                  ;
 35485                                  ;	EXIT	None
 35486                                  ;
 35487                                  ;	USED
 35488                                  ;
 35489                                  ;	EFFECTS		
 35490                                  ;		The rest of the command line following the pgm name is 
 35491                                  ;	moved to the top of the command line buffer (at TRANGROUP:81h)
 35492                                  ;	and a new command line length is put in
 35493                                  ; ---------------------------------------------------------------------------
 35494                                  
 35495                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35496                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59BEh
 35497                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35498                                  SetupCmdLine:
 35499                                  	;mov	di,81h
 35500 000056E2 BF8100                  	mov	di,iCmdLine
 35501 000056E5 30C9                    	xor	cl,cl
 35502 000056E7 FEC9                    	dec	cl			;just CR means count = 0
 35503                                  SetCmdL1:
 35504 000056E9 AC                      	lodsb
 35505 000056EA AA                      	stosb
 35506 000056EB FEC1                    	inc	cl			;update count
 35507                                  	; 14/04/2023
 35508                                  	; * ; MSDOS 6.0 only !
 35509                                  	;or	al,al	; *
 35510                                  	;jz	short SetCmdL2 ; *
 35511 000056ED 3C0D                    	cmp	al,0Dh			;carriage return?
 35512 000056EF 75F8                    	jnz	short SetCmdL1		;no, continue storing
 35513                                  SetCmdL2:
 35514 000056F1 26880E8000              	mov	[es:80h],cl		;store new cmd line length
 35515 000056F6 C3                      	retn
 35516                                  
 35517                                  ; ---------------------------------------------------------------------------
 35518                                  
 35519                                  ;***	LhSetupErrMsg -- Sets up error messages
 35520                                  ;
 35521                                  ;	ENTRY	ax = error message number
 35522                                  ;
 35523                                  ;	EXIT	None
 35524                                  ;
 35525                                  ;	USED	dx
 35526                                  ;
 35527                                  ;	EFFECTS
 35528                                  ;		Everything setup to display error message
 35529                                  ; ---------------------------------------------------------------------------
 35530                                  	
 35531                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35532                                  LhSetupErrMsg:
 35533 000056F7 C606[2F7F]01            	mov	byte [msg_disp_class],ext_msg_class ; 1
 35534 000056FC BA[317F]                	mov	dx,extend_buf_ptr
 35535 000056FF A3[317F]                	mov	[extend_buf_ptr],ax
 35536 00005702 C3                      	retn
 35537                                  
 35538                                  ; ---------------------------------------------------------------------------
 35539                                  
 35540                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35541                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59DFh
 35542                                  	; MSDOS 5.0 COMMAND.COM only !
 35543                                  	; (Procedure name is not from original Microsoft source code!)
 35544                                  check_umblink:
 35545 00005703 B80058                  	mov	ax,5800h	; DOS_CHECK_STRATEGY
 35546 00005706 CD21                    	int	21h 	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35547                                  			 ; AL = function code: get allocation strategy
 35548 00005708 88C3                    	mov	bl,al
 35549 0000570A B80258                  	mov	ax,5802h	; DOS_CHECK_UMBLINK
 35550 0000570D CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35551                                  			; AL = function code: (DOS 5beta) get UMB link state
 35552 0000570F 88C7                    	mov	bh,al
 35553 00005711 93                      	xchg	ax,bx
 35554 00005712 D0C0                    	rol	al,1
 35555 00005714 2401                    	and	al,1
 35556 00005716 D0E4                    	shl	ah,1
 35557 00005718 08E0                    	or	al,ah
 35558 0000571A C3                      	retn
 35559                                  
 35560                                  ; ---------------------------------------------------------------------------
 35561                                  
 35562                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35563                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:59F7h
 35564                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35565                                  HideUMBs:
 35566 0000571B 1E                      	push	ds
 35567 0000571C E8E4FF                  	call	check_umblink
 35568 0000571F 8E1E[9C8A]              	mov	ds,[RESSEG]
 35569 00005723 A2[3A04]                	mov	[fInHigh],al
 35570 00005726 800E[3A04]80            	or	byte [fInHigh],80h
 35571 0000572B 1F                      	pop	ds
 35572 0000572C E88AFF                  	call	set_strategy
 35573                                  	;call	set_umblink
 35574                                  	;retn
 35575                                  	; 14/04/023
 35576                                  	;jmp	short set_ubmlink
 35577                                  
 35578                                  ; ---------------------------------------------------------------------------
 35579                                  
 35580                                  	; 14/04/2023
 35581                                  	; 13/04/2023
 35582                                  	; MSDOS 5.0 COMMAND.COM only !
 35583                                  	; (Procedure name is not from original Microsoft source code!)
 35584                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:597Bh
 35585                                  set_umblink:
 35586 0000572F B80358                  	mov	ax,5803h	; DOS_SET_UMBLINK
 35587 00005732 BB0100                  	mov	bx,1
 35588 00005735 CD21                    	int	21h	; DOS - 3+ - GET/SET MEMORY ALLOCATION STRATEGY
 35589                                  			; AL = function code: (DOS 5beta) set UMB link state
 35590 00005737 C3                      	retn
 35591                                  
 35592                                  ; ---------------------------------------------------------------------------
 35593                                  
 35594                                  ;***	SetupPath -- Do path search for the file to be executed
 35595                                  ;
 35596                                  ;	ENTRY	None
 35597                                  ;
 35598                                  ;	EXIT	Carry set if file not found or not executable file
 35599                                  ;
 35600                                  ;	EFFECTS
 35601                                  ;		ExecPath contains the full path of the file to be executed
 35602                                  ; ---------------------------------------------------------------------------
 35603                                  
 35604                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35605                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A0Fh
 35606                                  	; MSDOS 5.0 COMMAND.COM only ! (MSDOS 6.0 code is different)
 35607                                  SetupPath:
 35608                                  
 35609                                  ;Juggle around the argv pointers to make argv[1] into argv[0]. This is 
 35610                                  ;because the path search routine that we are about to invoke expects the
 35611                                  ;filename to search for to be argv[0].
 35612                                  ;
 35613                                  ;If our new argv[0] starts with a switcharacter, it's an option... skip right
 35614                                  ;over it by doing the whole move again (smaller, of course, this time).
 35615                                  
 35616                                  
 35617                                  	;mov	ax,arg.argvcnt		;total number of arguments
 35618                                  	; 14/04/2023
 35619                                  	;mov	ax,[ARG_ARGVCNT]
 35620 00005738 A1[EB90]                	mov	ax,[ARG+ARG_UNIT.argvcnt]
 35621                                  
 35622 0000573B 48                      	dec	ax			;less one - skip "LoadHigh"
 35623                                  	;mov	bx,SIZE Argv_ele
 35624 0000573C BB0B00                  	mov	bx,ARGV_ELE.SIZE ; 11
 35625                                  	;mov	bx,11
 35626 0000573F F7E3                    	mul	bx			;dx:ax = size of argument lists
 35627                                  
 35628                                  	; 14/04/2023
 35629 00005741 89C1                    	mov	cx,ax			;size to move
 35630                                  
 35631                                  	;mov	di,offset TRANGROUP:Arg	;Copy TO argv[0]
 35632                                  	;mov	di,ARG_ARGV ;mov di,[ARG+ARG_UNIT.argv] ; mov di,[ARG]
 35633 00005743 BF[2B8E]                	mov	di,ARG	
 35634 00005746 89FE                    	mov	si,di			;
 35635                                  	;add	si,SIZE Argv_ele	;Copy FROM argv[1]
 35636 00005748 83C60B                  	add	si,ARGV_ELE.SIZE ; 11
 35637                                  	
 35638                                  	; 14/04/2023
 35639                                  	;mov	cx,ax
 35640                                  
 35641 0000574B FC                      	cld
 35642 0000574C F3A4                    	rep	movsb			;Move the argument list
 35643                                  	
 35644                                  	;dec	arg.argvcnt		;Fake one less argument, and
 35645                                  	;dec	word [ARG_ARGVCNT]
 35646 0000574E FF0E[EB90]              	dec	word [ARG+ARG_UNIT.argvcnt]
 35647                                  	
 35648                                  ; Done moving... argv[0] is now the child program's name, and [1] its first arg
 35649                                  
 35650 00005752 E81BDA                  	call	path_search		;look in the path
 35651                                  
 35652                                  ;ax = 0, no file found
 35653                                  ;ax < 4, batch file found -- cant be executed
 35654                                  ;ax = 4,8 => .com or .exe file found
 35655                                  
 35656 00005755 09C0                    	or	ax,ax			;any file found?
 35657 00005757 740B                    	jz	short no_exec_file	;no, error
 35658                                  
 35659 00005759 83F804                  	cmp	ax,4			;executable file?
 35660                                  	;jl	short no_exec_bat	;no, indicate fail ; M016
 35661                                  	;clc
 35662                                  	;retn
 35663                                  	; 14/04/2023
 35664 0000575C 7201                    	jb	short no_exec_bat
 35665 0000575E C3                      	retn 
 35666                                  
 35667                                  no_exec_bat:
 35668 0000575F BA[9881]                	mov	dx,NoExecBat_Ptr	;Setup message ptr ; M016
 35669 00005762 EB06                    	jmp	short lhsp_errret	;return error; M016
 35670                                  
 35671                                  no_exec_file:
 35672 00005764 B80200                  	mov	ax,ERROR_FILE_NOT_FOUND ; 2
 35673 00005767 E88DFF                  	call	LhSetupErrMsg		;setup error message
 35674                                  lhsp_errret:				; M016
 35675 0000576A F9                      	stc
 35676 0000576B C3                      	retn
 35677                                  
 35678                                  ;============================================================================
 35679                                  ; COMMAND.SKL (MESSAGE.SKL), BUILDMSG.C, MSDOS 6.0, 1991
 35680                                  ;============================================================================
 35681                                  ; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35682                                  
 35683                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5A44h
 35684                                  
 35685                                  ; ---------------------------------------------------------------------------
 35686                                  ; Class 3 message table/structure
 35687                                  ; ---------------------------------------------------------------------------
 35688                                  
 35689                                  $M_CLASS_3_STRUC:
 35690 0000576C FF                      	db 0FFh			; $M_CLASS_ID (Class identifer)
 35691 0000576D 0500                    	dw 5			; $M_COMMAND_VER (COMMAND.COM version)
 35692 0000576F A2                      	db 162			; Total number of messages
 35693                                  $M_ID_3_1:
 35694                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:5A48h)
 35695 00005770 FC03                    	dw 1020			; Message Number = 1020
 35696 00005772 8802                    	dw MSG_1020-$+2 ; 288h	; Message offset from message number (5A48h+0288h=5CD0h)
 35697                                  $M_ID_3_2:
 35698 00005774 F703                    	dw 1015			; Message Number = 1015
 35699 00005776 9402                    	dw MSG_1015-$+2 ; 294h  ; Message offset from message number (5A4Ch+0294h=5CE0h)
 35700                                  $M_ID_3_3:	; 26/04/2023
 35701 00005778 EC03B402                	dw 1004,MSG_1004-$ ; 692
 35702 0000577C 0204CA02                	dw 1026,MSG_1026-$ ; 714
 35703 00005780 0704DA02                	dw 1031,MSG_1031-$ ; 730
 35704 00005784 0B04E502                	dw 1035,MSG_1035-$ ; 741
 35705 00005788 2604F002                	dw 1062,MSG_1062-$ ; 752
 35706 0000578C 0404FB02                	dw 1028,MSG_1028-$ ; 763
 35707 00005790 15041903                	dw 1045,MSG_1045-$ ; 793
 35708 00005794 11043203                	dw 1041,MSG_1041-$ ; 818
 35709 00005798 12045003                	dw 1042,MSG_1042-$ ; 848
 35710                                  $M_ID_3_12:
 35711 0000579C 13046703                	dw 1043,MSG_1043-$ ; 871
 35712 000057A0 EA038303                	dw 1002,MSG_1002-$ ; 899
 35713 000057A4 EB03A703                	dw 1003,MSG_1003-$ ; 935
 35714 000057A8 EF03BF03                	dw 1007,MSG_1007-$ ; 959
 35715 000057AC F003D603                	dw 1008,MSG_1008-$ ; 982
 35716 000057B0 F103E803                	dw 1009,MSG_1009-$ ; 1000
 35717 000057B4 F203F903                	dw 1010,MSG_1010-$ ; 1017
 35718 000057B8 F3031504                	dw 1011,MSG_1011-$ ; 1045
 35719 000057BC F6032C04                	dw 1014,MSG_1014-$ ; 1068
 35720 000057C0 F8033904                	dw 1016,MSG_1016-$ ; 1081
 35721 000057C4 F9035F04                	dw 1017,MSG_1017-$ ; 1119
 35722 000057C8 FA038004                	dw 1018,MSG_1018-$ ; 1152
 35723                                  $M_ID_3_24:
 35724 000057CC FB039004                	dw 1019,MSG_1019-$ ; 1168
 35725 000057D0 FD039804                	dw 1021,MSG_1021-$ ; 1176
 35726 000057D4 FE03B204                	dw 1022,MSG_1022-$ ; 1202
 35727 000057D8 FF03D504                	dw 1023,MSG_1023-$ ; 1237
 35728 000057DC 0004FD04                	dw 1024,MSG_1024-$ ; 1277
 35729 000057E0 01041005                	dw 1025,MSG_1025-$ ; 1296
 35730 000057E4 03042405                	dw 1027,MSG_1027-$ ; 1316
 35731 000057E8 05044105                	dw 1029,MSG_1029-$ ; 1345
 35732 000057EC 06044F05                	dw 1030,MSG_1030-$ ; 1359
 35733 000057F0 08045A05                	dw 1032,MSG_1032-$ ; 1370
 35734 000057F4 09046E05                	dw 1033,MSG_1033-$ ; 1390
 35735 000057F8 0A048005                	dw 1034,MSG_1034-$ ; 1408
 35736 000057FC 0C049205                	dw 1036,MSG_1036-$ ; 1426
 35737 00005800 0D04A305                	dw 1037,MSG_1037-$ ; 1443
 35738 00005804 0E04B005                	dw 1038,MSG_1038-$ ; 1456
 35739 00005808 0F04BF05                	dw 1039,MSG_1039-$ ; 1471
 35740                                  $M_ID_3_40:
 35741 0000580C 1004F805                	dw 1040,MSG_1040-$ ; 1528
 35742 00005810 14040906                	dw 1044,MSG_1044-$ ; 1545
 35743 00005814 16041906                	dw 1046,MSG_1046-$ ; 1561
 35744 00005818 17044C06                	dw 1047,MSG_1047-$ ; 1612
 35745 0000581C 18046106                	dw 1048,MSG_1048-$ ; 1633
 35746 00005820 19046F06                	dw 1049,MSG_1049-$ ; 1647
 35747 00005824 1A047506                	dw 1050,MSG_1050-$ ; 1653
 35748 00005828 1B049006                	dw 1051,MSG_1051-$ ; 1680
 35749 0000582C 1C049D06                	dw 1052,MSG_1052-$ ; 1693
 35750 00005830 1D04B006                	dw 1053,MSG_1053-$ ; 1712
 35751 00005834 1E04D206                	dw 1054,MSG_1054-$ ; 1746
 35752                                  $M_ID_3_51:
 35753 00005838 1F04F506                	dw 1055,MSG_1055-$ ; 1781
 35754 0000583C 2004FF06                	dw 1056,MSG_1056-$ ; 1791
 35755 00005840 21040A07                	dw 1057,MSG_1057-$ ; 1802
 35756 00005844 23041307                	dw 1059,MSG_1059-$ ; 1811
 35757 00005848 24041407                	dw 1060,MSG_1060-$ ; 1812
 35758 0000584C 25041407                	dw 1061,MSG_1061-$ ; 1812
 35759 00005850 27042A07                	dw 1063,MSG_1063-$ ; 1834
 35760 00005854 28042907                	dw 1064,MSG_1064-$ ; 1833
 35761 00005858 29042807                	dw 1065,MSG_1065-$ ; 1832
 35762 0000585C 2A042707                	dw 1066,MSG_1066-$ ; 1831
 35763 00005860 2B042607                	dw 1067,MSG_1067-$ ; 1830
 35764 00005864 2C042407                	dw 1068,MSG_1068-$ ; 1828
 35765 00005868 2D042B07                	dw 1069,MSG_1069-$ ; 1835
 35766 0000586C 2E042B07                	dw 1070,MSG_1070-$ ; 1835
 35767 00005870 2F042A07                	dw 1071,MSG_1071-$ ; 1834
 35768 00005874 30042907                	dw 1072,MSG_1072-$ ; 1833
 35769                                  $M_ID_3_67:
 35770 00005878 31042E07                	dw 1073,MSG_1073-$ ; 1838
 35771 0000587C 32043307                	dw 1074,MSG_1074-$ ; 1843
 35772 00005880 33043807                	dw 1075,MSG_1075-$ ; 1848
 35773 00005884 34043A07                	dw 1076,MSG_1076-$ ; 1850
 35774 00005888 35043907                	dw 1077,MSG_1077-$ ; 1849
 35775 0000588C 36043D07                	dw 1078,MSG_1078-$ ; 1853
 35776 00005890 37045407                	dw 1079,MSG_1079-$ ; 1876
 35777 00005894 38045B07                	dw 1080,MSG_1080-$ ; 1883
 35778 00005898 39046D07                	dw 1081,MSG_1081-$ ; 1901
 35779 0000589C 3C049407                	dw 1084,MSG_1084-$ ; 1940
 35780 000058A0 4204A007                	dw 1090,MSG_1090-$ ; 1952
 35781 000058A4 4304AA07                	dw 1091,MSG_1091-$ ; 1962
 35782 000058A8 4404B407                	dw 1092,MSG_1092-$ ; 1972
 35783 000058AC 4504BE07                	dw 1093,MSG_1093-$ ; 1982
 35784 000058B0 4604CF07                	dw 1094,MSG_1094-$ ; 1999
 35785 000058B4 4704E807                	dw 1095,MSG_1095-$ ; 2024
 35786 000058B8 48040108                	dw 1096,MSG_1096-$ ; 2049
 35787                                  $M_ID_3_84:
 35788 000058BC B0042E08                	dw 1200,MSG_1200-$ ; 2094
 35789 000058C0 14052B08                	dw 1300,MSG_1300-$ ; 2091
 35790 000058C4 2805AE08                	dw 1320,MSG_1320-$ ; 2222
 35791 000058C8 2905EA08                	dw 1321,MSG_1321-$ ; 2282
 35792 000058CC 3C055709                	dw 1340,MSG_1340-$ ; 2391
 35793 000058D0 3D05AF09                	dw 1341,MSG_1341-$ ; 2479
 35794 000058D4 3E050E0A                	dw 1342,MSG_1342-$ ; 2574
 35795 000058D8 50059C0A                	dw 1360,MSG_1360-$ ; 2716
 35796 000058DC 7805B40A                	dw 1400,MSG_1400-$ ; 2740
 35797 000058E0 7905420B                	dw 1401,MSG_1401-$ ; 2882
 35798 000058E4 7A05A70B                	dw 1402,MSG_1402-$ ; 2983
 35799 000058E8 7B051A0C                	dw 1403,MSG_1403-$ ; 3098
 35800 000058EC 7C05580C                	dw 1404,MSG_1404-$ ; 3160
 35801 000058F0 8C05DC0C                	dw 1420,MSG_1420-$ ; 3292
 35802 000058F4 A005630D                	dw 1440,MSG_1440-$ ; 3427
 35803 000058F8 A1058D0D                	dw 1441,MSG_1441-$ ; 3469
 35804                                  $M_ID_3_100:
 35805 000058FC B4050D0E                	dw 1460,MSG_1460-$ ; 3597
 35806 00005900 B5056E0E                	dw 1461,MSG_1461-$ ; 3694
 35807 00005904 B605EE0E                	dw 1462,MSG_1462-$ ; 3822
 35808 00005908 C8053A0F                	dw 1480,MSG_1480-$ ; 3898
 35809 0000590C C905D90F                	dw 1481,MSG_1481-$ ; 4057
 35810 00005910 CA053310                	dw 1482,MSG_1482-$ ; 4147
 35811 00005914 CB059110                	dw 1483,MSG_1483-$ ; 4241
 35812 00005918 CC050811                	dw 1484,MSG_1484-$ ; 4360
 35813 0000591C CD05C411                	dw 1485,MSG_1485-$ ; 4548
 35814 00005920 CE055C12                	dw 1486,MSG_1486-$ ; 4700
 35815 00005924 CF05EF12                	dw 1487,MSG_1487-$ ; 4847
 35816 00005928 D0055213                	dw 1488,MSG_1488-$ ; 4946
 35817                                  $M_ID_3_112:
 35818 0000592C DC05E113                	dw 1500,MSG_1500-$ ; 5089
 35819 00005930 F0051C14                	dw 1520,MSG_1520-$ ; 5148
 35820 00005934 04065614                	dw 1540,MSG_1540-$ ; 5206
 35821 00005938 0506B014                	dw 1541,MSG_1541-$ ; 5296
 35822 0000593C 06061815                	dw 1542,MSG_1542-$ ; 5400
 35823 00005940 18065015                	dw 1560,MSG_1560-$ ; 5456
 35824 00005944 19068415                	dw 1561,MSG_1561-$ ; 5508
 35825 00005948 1A06FD15                	dw 1562,MSG_1562-$ ; 5629
 35826 0000594C 1B062916                	dw 1563,MSG_1563-$ ; 5673
 35827 00005950 1C065016                	dw 1564,MSG_1564-$ ; 5712
 35828 00005954 1D068A16                	dw 1565,MSG_1565-$ ; 5770
 35829 00005958 1E06BB16                	dw 1566,MSG_1566-$ ; 5819
 35830 0000595C 1F06E416                	dw 1567,MSG_1567-$ ; 5860
 35831 00005960 20065A17                	dw 1568,MSG_1568-$ ; 5978
 35832 00005964 2C06A317                	dw 1580,MSG_1580-$ ; 6051
 35833                                  $M_ID_3_127:
 35834 00005968 4006E717                	dw 1600,MSG_1600-$ ; 6119
 35835 0000596C 41060018                	dw 1601,MSG_1601-$ ; 6144
 35836 00005970 42065018                	dw 1602,MSG_1602-$ ; 6224
 35837 00005974 54069A18                	dw 1620,MSG_1620-$ ; 6298
 35838 00005978 5506EE18                	dw 1621,MSG_1621-$ ; 6382
 35839 0000597C 56066C19                	dw 1622,MSG_1622-$ ; 6508
 35840 00005980 6806B419                	dw 1640,MSG_1640-$ ; 6580
 35841 00005984 6906E519                	dw 1641,MSG_1641-$ ; 6629
 35842 00005988 7C06651A                	dw 1660,MSG_1660-$ ; 6757
 35843 0000598C 9006A81A                	dw 1680,MSG_1680-$ ; 6824
 35844 00005990 A406CA1A                	dw 1700,MSG_1700-$ ; 6858
 35845 00005994 B806781B                	dw 1720,MSG_1720-$ ; 7032
 35846 00005998 CC06C71B                	dw 1740,MSG_1740-$ ; 7111
 35847 0000599C CD061F1C                	dw 1741,MSG_1741-$ ; 7199
 35848 000059A0 E0068E1C                	dw 1760,MSG_1760-$ ; 7310
 35849 000059A4 F406D71C                	dw 1780,MSG_1780-$ ; 7383
 35850                                  $M_ID_3_143:
 35851 000059A8 08073F1D                	dw 1800,MSG_1800-$ ; 7487
 35852 000059AC 0907891D                	dw 1801,MSG_1801-$ ; 7561
 35853 000059B0 1C07DD1D                	dw 1820,MSG_1820-$ ; 7645
 35854 000059B4 1D07211E                	dw 1821,MSG_1821-$ ; 7713
 35855 000059B8 3007A81E                	dw 1840,MSG_1840-$ ; 7848
 35856 000059BC 4407EF1E                	dw 1860,MSG_1860-$ ; 7919
 35857 000059C0 4507461F                	dw 1861,MSG_1861-$ ; 8006
 35858 000059C4 4607891F                	dw 1862,MSG_1862-$ ; 8073
 35859 000059C8 47070320                	dw 1863,MSG_1863-$ ; 8195
 35860 000059CC 4807A220                	dw 1864,MSG_1864-$ ; 8354
 35861 000059D0 49070521                	dw 1865,MSG_1865-$ ; 8453
 35862 000059D4 4A076C21                	dw 1866,MSG_1866-$ ; 8556
 35863 000059D8 5807D021                	dw 1880,MSG_1880-$ ; 8656
 35864 000059DC 59074422                	dw 1881,MSG_1881-$ ; 8772
 35865 000059E0 5A07BE22                	dw 1882,MSG_1882-$ ; 8894
 35866 000059E4 5B071123                	dw 1883,MSG_1883-$ ; 8977
 35867 000059E8 6C07B023                	dw 1900,MSG_1900-$ ; 9136
 35868 000059EC 8007C423                	dw 1920,MSG_1920-$ ; 9156
 35869 000059F0 8107F023                	dw 1921,MSG_1921-$ ; 9200
 35870                                  $M_ID_3_162:
 35871 000059F4 8207                    	dw 1922			; Message Number = 1922
 35872 000059F6 4324                    	dw MSG_1922-$ ; 9285	; Message offset from message number (5CCCh+2445h=8111h)
 35873                                  
 35874                                  ; ---------------------------------------------------------------------------
 35875                                  ; Class 3 messages
 35876                                  ; ---------------------------------------------------------------------------
 35877                                  	
 35878                                  	; 14/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 35879                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:5CD0h
 35880                                  
 35881                                  MSG_1020:	; COMMON4
 35882 000059F8 0F                      	db 15	; (MSG_1015-MSG_1020)-1
 35883 000059F9 253120627974657320-     	db '%1 bytes free',0Dh,0Ah
 35883 00005A02 667265650D0A       
 35884                                  MSG_1015:	; COMMON18
 35885 00005A08 23                      	db 35
 35886 00005A09 46696C652063616E6E-     	db 'File cannot be copied onto itself',0Dh,0Ah
 35886 00005A12 6F7420626520636F70-
 35886 00005A1B 696564206F6E746F20-
 35886 00005A24 697473656C660D0A   
 35887                                  MSG_1004:	; COMMON20
 35888 00005A2C 19                      	db 25
 35889 00005A2D 496E73756666696369-     	db 'Insufficient disk space',0Dh,0Ah
 35889 00005A36 656E74206469736B20-
 35889 00005A3F 73706163650D0A     
 35890                                  MSG_1026:	; COMMON22
 35891 00005A46 13                      	db 19
 35892 00005A47 496E76616C69642063-     	db 'Invalid code page',0Dh,0Ah
 35892 00005A50 6F646520706167650D-
 35892 00005A59 0A                 
 35893                                  MSG_1031:	; COMMON23
 35894 00005A5A 0E                      	db 14
 35895 00005A5B 496E76616C69642064-     	db 'Invalid date',0Dh,0Ah
 35895 00005A64 6174650D0A         
 35896                                  MSG_1035:	; COMMON24
 35897 00005A69 0E                      	db 14
 35898 00005A6A 496E76616C69642074-     	db 'Invalid time',0Dh,0Ah
 35898 00005A73 696D650D0A         
 35899                                  MSG_1062:	; COMMON25
 35900 00005A78 0E                      	db 14
 35901 00005A79 496E76616C69642070-     	db 'Invalid path',0Dh,0Ah
 35901 00005A82 6174680D0A         
 35902                                  MSG_1028:	; COMMON28
 35903 00005A87 21                      	db 33
 35904 00005A88 507265737320616E79-     	db 'Press any key to continue . . .',0Dh,0Ah
 35904 00005A91 206B657920746F2063-
 35904 00005A9A 6F6E74696E7565202E-
 35904 00005AA3 202E202E0D0A       
 35905                                  MSG_1045:	; COMMON32
 35906 00005AA9 1C                      	db 28
 35907 00005AAA 556E61626C6520746F-     	db 'Unable to create directory',0Dh,0Ah
 35907 00005AB3 206372656174652064-
 35907 00005ABC 69726563746F72790D-
 35907 00005AC5 0A                 
 35908                                  MSG_1041:	; COMMON33
 35909 00005AC6 21                      	db 33
 35910 00005AC7 566F6C756D6520696E-     	db 'Volume in drive %1 has no label',0Dh,0Ah
 35910 00005AD0 206472697665202531-
 35910 00005AD9 20686173206E6F206C-
 35910 00005AE2 6162656C0D0A       
 35911                                  MSG_1042:	; COMMON34
 35912 00005AE8 1A                      	db 26
 35913 00005AE9 566F6C756D6520696E-     	db 'Volume in drive %1 is %2',0Dh,0Ah
 35913 00005AF2 206472697665202531-
 35913 00005AFB 2069732025320D0A   
 35914                                  MSG_1043:	; COMMON36
 35915 00005B03 1F                      	db 31  ; (MSG_1002-MSG_1043)-1
 35916 00005B04 566F6C756D65205365-     	db 'Volume Serial Number is %1-%2',0Dh,0Ah
 35916 00005B0D 7269616C204E756D62-
 35916 00005B16 65722069732025312D-
 35916 00005B1F 25320D0A           
 35917                                  MSG_1002:
 35918 00005B23 27                              db 39
 35919 00005B24 4475706C6963617465-     	db 'Duplicate file name or file not found',0Dh,0Ah
 35919 00005B2D 2066696C65206E616D-
 35919 00005B36 65206F722066696C65-
 35919 00005B3F 206E6F7420666F756E-
 35919 00005B48 640D0A             
 35920                                  MSG_1003:
 35921 00005B4B 1B                      	db 27
 35922 00005B4C 496E76616C69642070-     	db 'Invalid path or file name',0Dh,0Ah
 35922 00005B55 617468206F72206669-
 35922 00005B5E 6C65206E616D650D0A 
 35923                                  MSG_1007:
 35924 00005B67 1A                      	db 26
 35925 00005B68 4F7574206F6620656E-     	db 'Out of environment space',0Dh,0Ah
 35925 00005B71 7669726F6E6D656E74-
 35925 00005B7A 2073706163650D0A   
 35926                                  MSG_1008:
 35927 00005B82 15                      	db 21
 35928 00005B83 46696C652063726561-     	db 'File creation error',0Dh,0Ah
 35928 00005B8C 74696F6E206572726F-
 35928 00005B95 720D0A             
 35929                                  MSG_1009:
 35930 00005B98 14                      	db 20  ; (MSG_1010-MSG_1009)-1
 35931 00005B99 42617463682066696C-     	db 'Batch file missing',0Dh,0Ah
 35931 00005BA2 65206D697373696E67-
 35931 00005BAB 0D0A               
 35932                                  MSG_1010:
 35933 00005BAD 1F                      	db 31
 35934 00005BAE 0D0A                    	db 0Dh,0Ah
 35935 00005BB0 496E73657274206469-     	db 'Insert disk with batch file',0Dh,0Ah
 35935 00005BB9 736B20776974682062-
 35935 00005BC2 617463682066696C65-
 35935 00005BCB 0D0A               
 35936                                  MSG_1011:
 35937 00005BCD 1A                      	db 26
 35938 00005BCE 42616420636F6D6D61-     	db 'Bad command or file name',0Dh,0Ah
 35938 00005BD7 6E64206F722066696C-
 35938 00005BE0 65206E616D650D0A   
 35939                                  MSG_1014:	; EXTEND5
 35940 00005BE8 10                      	db 16
 35941 00005BE9 416363657373206465-     	db 'Access denied ',0Dh,0Ah
 35941 00005BF2 6E696564200D0A     
 35942                                  MSG_1016:
 35943 00005BF9 29                      	db 41
 35944 00005BFA 436F6E74656E74206F-     	db 'Content of destination lost before copy',0Dh,0Ah
 35944 00005C03 662064657374696E61-
 35944 00005C0C 74696F6E206C6F7374-
 35944 00005C15 206265666F72652063-
 35944 00005C1E 6F70790D0A         
 35945                                  MSG_1017:
 35946 00005C23 24                      	db 36
 35947 00005C24 496E76616C69642066-     	db 'Invalid filename or file not found',0Dh,0Ah
 35947 00005C2D 696C656E616D65206F-
 35947 00005C36 722066696C65206E6F-
 35947 00005C3F 7420666F756E640D0A 
 35948                                  MSG_1018:
 35949 00005C48 13                      	db 19
 35950 00005C49 25312066696C652873-     	db '%1 file(s) copied',0Dh,0Ah
 35950 00005C52 2920636F706965640D-
 35950 00005C5B 0A                 
 35951                                  MSG_1019:
 35952 00005C5C 0B                      	db 11
 35953 00005C5D 25312066696C652873-     	db '%1 file(s) '
 35953 00005C66 2920               
 35954                                  MSG_1021:	; EXTEND15
 35955 00005C68 1D                      	db 29
 35956 00005C69 496E76616C69642064-     	db 'Invalid drive specification',0Dh,0Ah
 35956 00005C72 726976652073706563-
 35956 00005C7B 696669636174696F6E-
 35956 00005C84 0D0A               
 35957                                  MSG_1022:
 35958 00005C86 26                      	db 38
 35959 00005C87 436F64652070616765-     	db 'Code page %1 not prepared for system',0Dh,0Ah
 35959 00005C90 202531206E6F742070-
 35959 00005C99 726570617265642066-
 35959 00005CA2 6F722073797374656D-
 35959 00005CAB 0D0A               
 35960                                  MSG_1023:
 35961 00005CAD 2B                      	db 43
 35962 00005CAE 436F64652070616765-     	db 'Code page %1 not prepared for all devices',0Dh,0Ah
 35962 00005CB7 202531206E6F742070-
 35962 00005CC0 726570617265642066-
 35962 00005CC9 6F7220616C6C206465-
 35962 00005CD2 76696365730D0A     
 35963                                  MSG_1024:
 35964 00005CD9 16                      	db 22
 35965 00005CDA 41637469766520636F-     	db 'Active code page: %1',0Dh,0Ah
 35965 00005CE3 646520706167653A20-
 35965 00005CEC 25310D0A           
 35966                                  MSG_1025:
 35967 00005CF0 17                      	db 23
 35968 00005CF1 4E4C5346554E43206E-     	db 'NLSFUNC not installed',0Dh,0Ah
 35968 00005CFA 6F7420696E7374616C-
 35968 00005D03 6C65640D0A         
 35969                                  MSG_1027:
 35970 00005D08 20                      	db 32
 35971 00005D09 43757272656E742064-     	db 'Current drive is no longer valid'
 35971 00005D12 72697665206973206E-
 35971 00005D1B 6F206C6F6E67657220-
 35971 00005D24 76616C6964         
 35972                                  MSG_1029:
 35973 00005D29 11                      	db 17
 35974 00005D2A 4C6162656C206E6F74-     	db 'Label not found',0Dh,0Ah
 35974 00005D33 20666F756E640D0A   
 35975                                  MSG_1030:
 35976 00005D3B 0E                      	db 14
 35977 00005D3C 53796E746178206572-     	db 'Syntax error',0Dh,0Ah
 35977 00005D45 726F720D0A         
 35978                                  MSG_1032:
 35979 00005D4A 17                      	db 23
 35980 00005D4B 43757272656E742064-     	db 'Current date is %1 %2',0Dh,0Ah
 35980 00005D54 617465206973202531-
 35980 00005D5D 2025320D0A         
 35981                                  MSG_1033:
 35982 00005D62 15                      	db 21
 35983 00005D63 53756E4D6F6E547565-     	db 'SunMonTueWedThuFriSat'
 35983 00005D6C 576564546875467269-
 35983 00005D75 536174             
 35984                                  MSG_1034:
 35985 00005D78 15                      	db 21
 35986 00005D79 456E746572206E6577-     	db 'Enter new date (%1): '
 35986 00005D82 206461746520282531-
 35986 00005D8B 293A20             
 35987                                  MSG_1036:
 35988 00005D8E 14                      	db 20
 35989 00005D8F 43757272656E742074-     	db 'Current time is %1',0Dh,0Ah
 35989 00005D98 696D65206973202531-
 35989 00005DA1 0D0A               
 35990                                  MSG_1037:
 35991 00005DA3 10                      	db 16
 35992 00005DA4 456E746572206E6577-     	db 'Enter new time: '
 35992 00005DAD 2074696D653A20     
 35993                                  MSG_1038:
 35994 00005DB4 12                              db 18
 35995 00005DB5 2C2020202044656C65-     	db ',    Delete (Y/N)?'
 35995 00005DBE 74652028592F4E293F 
 35996                                  MSG_1039:
 35997 00005DC7 3C                              db 60
 35998 00005DC8 416C6C2066696C6573-     	db 'All files in directory will be deleted!',0Dh,0Ah
 35998 00005DD1 20696E206469726563-
 35998 00005DDA 746F72792077696C6C-
 35998 00005DE3 2062652064656C6574-
 35998 00005DEC 6564210D0A         
 35999 00005DF1 41726520796F752073-     	db 'Are you sure (Y/N)?'
 35999 00005DFA 7572652028592F4E29-
 35999 00005E03 3F                 
 36000                                  MSG_1040:
 36001 00005E04 14                      	db 20
 36002 00005E05 4D532D444F53205665-     	db 'MS-DOS Version %1.%2'
 36002 00005E0E 7273696F6E2025312E-
 36002 00005E17 2532               
 36003                                  MSG_1044:
 36004 00005E19 13                      	db 19
 36005 00005E1A 496E76616C69642064-     	db 'Invalid directory',0Dh,0Ah
 36005 00005E23 69726563746F72790D-
 36005 00005E2C 0A                 
 36006                                  MSG_1046:
 36007 00005E2D 36                      	db 54
 36008 00005E2E 496E76616C69642070-     	db 'Invalid path, not directory,',0Dh,0Ah
 36008 00005E37 6174682C206E6F7420-
 36008 00005E40 6469726563746F7279-
 36008 00005E49 2C0D0A             
 36009 00005E4C 6F7220646972656374-     	db 'or directory not empty',0Dh,0Ah
 36009 00005E55 6F7279206E6F742065-
 36009 00005E5E 6D7074790D0A       
 36010                                  MSG_1047:
 36011 00005E64 18                      	db 24
 36012 00005E65 4D7573742073706563-     	db 'Must specify ON or OFF',0Dh,0Ah
 36012 00005E6E 696679204F4E206F72-
 36012 00005E77 204F46460D0A       
 36013                                  MSG_1048:
 36014 00005E7D 11                      	db 17
 36015 00005E7E 4469726563746F7279-     	db 'Directory of %1',0Dh,0Ah
 36015 00005E87 206F662025310D0A   
 36016                                  MSG_1049:
 36017 00005E8F 09                      	db 9
 36018 00005E90 4E6F20506174680D0A      	db 'No Path',0Dh,0Ah
 36019                                  MSG_1050:
 36020 00005E99 1E                      	db 30
 36021 00005E9A 496E76616C69642064-     	db 'Invalid drive in search path',0Dh,0Ah
 36021 00005EA3 7269766520696E2073-
 36021 00005EAC 656172636820706174-
 36021 00005EB5 680D0A             
 36022                                  MSG_1051:
 36023 00005EB8 10                      	db 16
 36024 00005EB9 496E76616C69642064-     	db 'Invalid device',0Dh,0Ah
 36024 00005EC2 65766963650D0A     
 36025                                  MSG_1052:
 36026 00005EC9 16                      	db 22
 36027 00005ECA 464F522063616E6E6F-     	db 'FOR cannot be nested',0Dh,0Ah
 36027 00005ED3 74206265206E657374-
 36027 00005EDC 65640D0A           
 36028                                  MSG_1053:
 36029 00005EE0 25                      	db 37
 36030 00005EE1 496E7465726D656469-     	db 'Intermediate file error during pipe',0Dh,0Ah
 36030 00005EEA 6174652066696C6520-
 36030 00005EF3 6572726F7220647572-
 36030 00005EFC 696E6720706970650D-
 36030 00005F05 0A                 
 36031                                  MSG_1054:
 36032 00005F06 26                      	db 38
 36033 00005F07 43616E6E6F7420646F-     	db 'Cannot do binary reads from a device',0Dh,0Ah
 36033 00005F10 2062696E6172792072-
 36033 00005F19 656164732066726F6D-
 36033 00005F22 206120646576696365-
 36033 00005F2B 0D0A               
 36034                                  
 36035                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:6205h)
 36036                                  MSG_1055:
 36037 00005F2D 0D                      	db 13
 36038 00005F2E 425245414B20697320-     	db 'BREAK is %1',0Dh,0Ah
 36038 00005F37 25310D0A           
 36039                                  MSG_1056:
 36040 00005F3B 0E                      	db 14
 36041 00005F3C 564552494659206973-     	db 'VERIFY is %1',0Dh,0Ah
 36041 00005F45 2025310D0A         
 36042                                  MSG_1057:
 36043 00005F4A 0C                      	db 12
 36044 00005F4B 4543484F2069732025-     	db 'ECHO is %1',0Dh,0Ah
 36044 00005F54 310D0A             
 36045                                  MSG_1059:
 36046 00005F57 04                      	db 4
 36047 00005F58 6F666600                	db 'off',0
 36048                                  MSG_1060:
 36049 00005F5C 03                      	db 3
 36050 00005F5D 6F6E00                  	db 'on',0
 36051                                  MSG_1061:
 36052 00005F60 19                      	db 25
 36053 00005F61 4572726F7220777269-     	db 'Error writing to device',0Dh,0Ah
 36053 00005F6A 74696E6720746F2064-
 36053 00005F73 65766963650D0A     
 36054                                  MSG_1063:
 36055 00005F7A 02                      	db 2
 36056 00005F7B 2531                    	db '%1'
 36057                                  MSG_1064:
 36058 00005F7D 02                      	db 2
 36059 00005F7E 2531                    	db '%1'
 36060                                  MSG_1065:
 36061 00005F80 02                      	db 2
 36062 00005F81 2531                    	db '%1'
 36063                                  MSG_1066:
 36064 00005F83 02                      	db 2
 36065 00005F84 2531                    	db '%1'
 36066                                  MSG_1067:
 36067 00005F86 01                      	db 1
 36068 00005F87 09                      	db 9
 36069                                  MSG_1068:
 36070 00005F88 0A                      	db 10
 36071 00005F89 203C4449523E202020-     	db ' <DIR>    '
 36071 00005F92 20                 
 36072                                  MSG_1069:
 36073 00005F93 03                      	db 3
 36074 00005F94 082008                  	db 8, 20h, 8
 36075                                  MSG_1070:	; CRLF		
 36076 00005F97 02                      	db 2
 36077 00005F98 0D                      	db 0Dh
 36078 00005F99 0A                      	db 0Ah
 36079                                  MSG_1071:
 36080 00005F9A 02                      	db 2
 36081 00005F9B 2531                    	db '%1'
 36082                                  MSG_1072:
 36083 00005F9D 08                      	db 8
 36084 00005F9E 6D6D2D64642D7979        	db 'mm-dd-yy'
 36085                                  MSG_1073:
 36086 00005FA6 08                      	db 8
 36087 00005FA7 64642D6D6D2D7979        	db 'dd-mm-yy'
 36088                                  MSG_1074:
 36089 00005FAF 08                      	db 8
 36090 00005FB0 79792D6D6D2D6464        	db 'yy-mm-dd'
 36091                                  MSG_1075:
 36092 00005FB8 05                      	db 5
 36093 00005FB9 2531202532              	db '%1 %2'
 36094                                  MSG_1076:
 36095 00005FBE 02                      	db 2
 36096 00005FBF 2531                    	db '%1'
 36097                                  MSG_1077:
 36098 00005FC1 07                      	db 7
 36099 00005FC2 20253120202532          	db ' %1  %2'
 36100                                  MSG_1078:
 36101 00005FC9 1A                      	db 26
 36102 00005FCA 4469726563746F7279-     	db 'Directory already exists',0Dh,0Ah
 36102 00005FD3 20616C726561647920-
 36102 00005FDC 6578697374730D0A   
 36103                                  MSG_1079:
 36104 00005FE4 0A                      	db 10
 36105 00005FE5 25312062797465730D-     	db '%1 bytes',0Dh,0Ah
 36105 00005FEE 0A                 
 36106                                  MSG_1080:
 36107 00005FEF 15                      	db 21
 36108 00005FF0 546F74616C2066696C-     	db 'Total files listed:',0Dh,0Ah
 36108 00005FF9 6573206C6973746564-
 36108 00006002 3A0D0A             
 36109                                  MSG_1081:
 36110 00006005 2A                      	db 42
 36111 00006006 284572726F72206F63-     	db '(Error occurred in environment variable)',0Dh,0Ah
 36111 0000600F 63757272656420696E-
 36111 00006018 20656E7669726F6E6D-
 36111 00006021 656E74207661726961-
 36111 0000602A 626C65290D0A       
 36112                                  MSG_1084:
 36113 00006030 0F                      	db 15
 36114 00006031 28636F6E74696E7569-     	db '(continuing %1)'
 36114 0000603A 6E6720253129       
 36115                                  MSG_1090:
 36116 00006040 0D                      	db 13
 36117 00006041 5265766973696F6E20-     	db 'Revision %1',0Dh,0Ah
 36117 0000604A 25310D0A           
 36118                                  MSG_1091:
 36119 0000604E 0D                      	db 13
 36120 0000604F 444F5320697320696E-     	db 'DOS is in ROM'
 36120 00006058 20524F4D           
 36121                                  MSG_1092:
 36122 0000605C 0D                      	db 13
 36123 0000605D 444F5320697320696E-     	db 'DOS is in HMA'
 36123 00006066 20484D41           
 36124                                  MSG_1093:
 36125 0000606A 14                      	db 20
 36126 0000606B 444F5320697320696E-     	db 'DOS is in low memory'
 36126 00006074 206C6F77206D656D6F-
 36126 0000607D 7279               
 36127                                  MSG_1094:
 36128 0000607F 1C                      	db 28
 36129 00006080 43616E6E6F74204C6F-     	db 'Cannot Loadhigh batch file',0Dh,0Ah
 36129 00006089 616468696768206261-
 36129 00006092 7463682066696C650D-
 36129 0000609B 0A                 
 36130                                  MSG_1095:
 36131 0000609C 1C                      	db 28
 36132 0000609D 4C6F6164486967683A-     	db 'LoadHigh: Invalid filename',0Dh,0Ah
 36132 000060A6 20496E76616C696420-
 36132 000060AF 66696C656E616D650D-
 36132 000060B8 0A                 
 36133                                  MSG_1096:
 36134 000060B9 30                      	db 48
 36135 000060BA 43616E6E6F74206F70-     	db 'Cannot open specified country information file',0Dh,0Ah
 36135 000060C3 656E20737065636966-
 36135 000060CC 69656420636F756E74-
 36135 000060D5 727920696E666F726D-
 36135 000060DE 6174696F6E2066696C-
 36135 000060E7 650D0A             
 36136                                  
 36137                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C2h)
 36138                                  MSG_1200:
 36139 000060EA 00                      	db 0	; /? unimplemented
 36140                                  	; (MSDOS 5.0 COMMAND.COM - TRANGROUP:63C3h)
 36141                                  MSG_1300:
 36142 000060EB 86                      	db 134
 36143 000060EC 53657473206F722063-     	db 'Sets or clears extended CTRL+C checking.',0Dh,0Ah
 36143 000060F5 6C6561727320657874-
 36143 000060FE 656E64656420435452-
 36143 00006107 4C2B4320636865636B-
 36143 00006110 696E672E0D0A       
 36144 00006116 0D0A                    	db 0Dh,0Ah
 36145 00006118 425245414B205B4F4E-     	db 'BREAK [ON | OFF]',0Dh,0Ah
 36145 00006121 207C204F46465D0D0A 
 36146 0000612A 0D0A                    	db 0Dh,0Ah
 36147 0000612C 547970652042524541-     	db 'Type BREAK without a parameter to display the current BREAK setting.',0Dh,0Ah
 36147 00006135 4B20776974686F7574-
 36147 0000613E 206120706172616D65-
 36147 00006147 74657220746F206469-
 36147 00006150 73706C617920746865-
 36147 00006159 2063757272656E7420-
 36147 00006162 425245414B20736574-
 36147 0000616B 74696E672E0D0A     
 36148                                  MSG_1320:
 36149 00006172 3F                      	db 63
 36150 00006173 446973706C61797320-     	db 'Displays or sets the active code page number.',0Dh,0Ah
 36150 0000617C 6F7220736574732074-
 36150 00006185 686520616374697665-
 36150 0000618E 20636F646520706167-
 36150 00006197 65206E756D6265722E-
 36150 000061A0 0D0A               
 36151 000061A2 0D0A                    	db 0Dh,0Ah
 36152 000061A4 43484350205B6E6E6E-     	db 'CHCP [nnn]',0Dh,0Ah
 36152 000061AD 5D0D0A             
 36153 000061B0 0D0A                    	db 0Dh,0Ah
 36154                                  MSG_1321:
 36155 000061B2 70                      	db 112
 36156 000061B3 20206E6E6E20202053-     	db '  nnn   Specifies a code page number.',0Dh,0Ah
 36156 000061BC 706563696669657320-
 36156 000061C5 6120636F6465207061-
 36156 000061CE 6765206E756D626572-
 36156 000061D7 2E0D0A             
 36157 000061DA 0D0A                    	db 0Dh,0Ah
 36158 000061DC 547970652043484350-     	db 'Type CHCP without a parameter to display the active code page number.',0Dh,0Ah
 36158 000061E5 20776974686F757420-
 36158 000061EE 6120706172616D6574-
 36158 000061F7 657220746F20646973-
 36158 00006200 706C61792074686520-
 36158 00006209 61637469766520636F-
 36158 00006212 64652070616765206E-
 36158 0000621B 756D6265722E0D0A   
 36159                                  MSG_1340:
 36160 00006223 5B                      	db 91
 36161 00006224 446973706C61797320-     	db 'Displays the name of or changes the current directory.',0Dh,0Ah
 36161 0000622D 746865206E616D6520-
 36161 00006236 6F66206F7220636861-
 36161 0000623F 6E6765732074686520-
 36161 00006248 63757272656E742064-
 36161 00006251 69726563746F72792E-
 36161 0000625A 0D0A               
 36162 0000625C 0D0A                    	db 0Dh,0Ah
 36163 0000625E 4348444952205B6472-     	db 'CHDIR [drive:][path]',0Dh,0Ah
 36163 00006267 6976653A5D5B706174-
 36163 00006270 685D0D0A           
 36164 00006274 43484449525B2E2E5D-     	db 'CHDIR[..]',0Dh,0Ah
 36164 0000627D 0D0A               
 36165                                  MSG_1341:
 36166 0000627F 62                      	db 98
 36167 00006280 4344205B6472697665-     	db 'CD [drive:][path]',0Dh,0Ah
 36167 00006289 3A5D5B706174685D0D-
 36167 00006292 0A                 
 36168 00006293 43445B2E2E5D0D0A        	db 'CD[..]',0Dh,0Ah
 36169 0000629B 0D0A                    	db 0Dh,0Ah
 36170 0000629D 20202E2E2020205370-     	db '  ..   Specifies that you want to change to the parent directory.'
 36170 000062A6 656369666965732074-
 36170 000062AF 68617420796F752077-
 36170 000062B8 616E7420746F206368-
 36170 000062C1 616E676520746F2074-
 36170 000062CA 686520706172656E74-
 36170 000062D3 206469726563746F72-
 36170 000062DC 792E               
 36171 000062DE 0D0A                    	db 0Dh,0Ah
 36172 000062E0 0D0A                    	db 0Dh,0Ah
 36173                                  MSG_1342:
 36174 000062E2 91                      	db 145
 36175 000062E3 547970652043442064-     	db 'Type CD drive: to display the current directory in the specified '
 36175 000062EC 726976653A20746F20-
 36175 000062F5 646973706C61792074-
 36175 000062FE 68652063757272656E-
 36175 00006307 74206469726563746F-
 36175 00006310 727920696E20746865-
 36175 00006319 207370656369666965-
 36175 00006322 6420               
 36176 00006324 64726976652E0D0A        	db 'drive.',0Dh,0Ah
 36177 0000632C 547970652043442077-     	db 'Type CD without parameters to display the current drive and directory.',0Dh,0Ah
 36177 00006335 6974686F7574207061-
 36177 0000633E 72616D657465727320-
 36177 00006347 746F20646973706C61-
 36177 00006350 792074686520637572-
 36177 00006359 72656E742064726976-
 36177 00006362 6520616E6420646972-
 36177 0000636B 6563746F72792E0D0A 
 36178                                  MSG_1360:
 36179 00006374 1B                      	db 27
 36180 00006375 436C65617273207468-     	db 'Clears the screen.',0Dh,0Ah
 36180 0000637E 652073637265656E2E-
 36180 00006387 0D0A               
 36181 00006389 0D0A                    	db 0Dh,0Ah
 36182 0000638B 434C530D0A              	db 'CLS',0Dh,0Ah
 36183                                  MSG_1400:
 36184 00006390 91                      	db 145
 36185 00006391 436F70696573206F6E-     	db 'Copies one or more files to another location.',0Dh,0Ah
 36185 0000639A 65206F72206D6F7265-
 36185 000063A3 2066696C657320746F-
 36185 000063AC 20616E6F7468657220-
 36185 000063B5 6C6F636174696F6E2E-
 36185 000063BE 0D0A               
 36186 000063C0 0D0A                    	db 0Dh,0Ah
 36187 000063C2 434F5059205B2F4120-     	db 'COPY [/A | /B] source [/A | /B] [+ source [/A | /B] [+ ...]] [destination',0Dh,0Ah
 36187 000063CB 7C202F425D20736F75-
 36187 000063D4 726365205B2F41207C-
 36187 000063DD 202F425D205B2B2073-
 36187 000063E6 6F75726365205B2F41-
 36187 000063EF 207C202F425D205B2B-
 36187 000063F8 202E2E2E5D5D205B64-
 36187 00006401 657374696E6174696F-
 36187 0000640A 6E0D0A             
 36188 0000640D 20205B2F41207C202F-     	db '  [/A | /B]] [/V]',0Dh,0Ah
 36188 00006416 425D5D205B2F565D0D-
 36188 0000641F 0A                 
 36189 00006420 0D0A                    	db 0Dh,0Ah
 36190                                  MSG_1401:
 36191 00006422 68                      	db 104
 36192 00006423 2020736F7572636520-     	db '  source       Specifies the file or files to be copied.',0Dh,0Ah
 36192 0000642C 202020202020537065-
 36192 00006435 636966696573207468-
 36192 0000643E 652066696C65206F72-
 36192 00006447 2066696C657320746F-
 36192 00006450 20626520636F706965-
 36192 00006459 642E0D0A           
 36193 0000645D 20202F412020202020-     	db '  /A           Indicates an ASCII text file.',0Dh,0Ah
 36193 00006466 202020202020496E64-
 36193 0000646F 69636174657320616E-
 36193 00006478 204153434949207465-
 36193 00006481 78742066696C652E0D-
 36193 0000648A 0A                 
 36194                                  MSG_1402:
 36195 0000648B 76                      	db 118
 36196 0000648C 20202F422020202020-     	db '  /B           Indicates a binary file.',0Dh,0Ah
 36196 00006495 202020202020496E64-
 36196 0000649E 696361746573206120-
 36196 000064A7 62696E617279206669-
 36196 000064B0 6C652E0D0A         
 36197 000064B5 202064657374696E61-     	db '  destination  Specifies the directory and/or filename for the new file(s).',0Dh,0Ah
 36197 000064BE 74696F6E2020537065-
 36197 000064C7 636966696573207468-
 36197 000064D0 65206469726563746F-
 36197 000064D9 727920616E642F6F72-
 36197 000064E2 2066696C656E616D65-
 36197 000064EB 20666F722074686520-
 36197 000064F4 6E65772066696C6528-
 36197 000064FD 73292E0D0A         
 36198                                  MSG_1403:	
 36199 00006502 41                      	db 65
 36200 00006503 20202F562020202020-     	db '  /V           Verifies that new files are written correctly.',0Dh,0Ah
 36200 0000650C 202020202020566572-
 36200 00006515 696669657320746861-
 36200 0000651E 74206E65772066696C-
 36200 00006527 657320617265207772-
 36200 00006530 697474656E20636F72-
 36200 00006539 726563746C792E0D0A 
 36201 00006542 0D0A                    	db 0Dh,0Ah
 36202                                  MSG_1404:
 36203 00006544 87                      	db 135
 36204 00006545 546F20617070656E64-     	db 'To append files, specify a single file for destination, but multiple files',0Dh,0Ah
 36204 0000654E 2066696C65732C2073-
 36204 00006557 706563696679206120-
 36204 00006560 73696E676C65206669-
 36204 00006569 6C6520666F72206465-
 36204 00006572 7374696E6174696F6E-
 36204 0000657B 2C20627574206D756C-
 36204 00006584 7469706C652066696C-
 36204 0000658D 65730D0A           
 36205 00006591 666F7220736F757263-     	db 'for source (using wildcards or file1+file2+file3 format).',0Dh,0Ah
 36205 0000659A 6520287573696E6720-
 36205 000065A3 77696C646361726473-
 36205 000065AC 206F722066696C6531-
 36205 000065B5 2B66696C65322B6669-
 36205 000065BE 6C653320666F726D61-
 36205 000065C7 74292E0D0A         
 36206                                  MSG_1420:
 36207 000065CC 8A                      	db 138
 36208 000065CD 4368616E6765732074-     	db 'Changes the terminal device used to control your system.',0Dh,0Ah
 36208 000065D6 6865207465726D696E-
 36208 000065DF 616C20646576696365-
 36208 000065E8 207573656420746F20-
 36208 000065F1 636F6E74726F6C2079-
 36208 000065FA 6F7572207379737465-
 36208 00006603 6D2E0D0A           
 36209 00006607 0D0A                    	db 0Dh,0Ah
 36210 00006609 435454592064657669-     	db 'CTTY device',0Dh,0Ah
 36210 00006612 63650D0A           
 36211 00006616 0D0A                    	db 0Dh,0Ah
 36212 00006618 202064657669636520-     	db '  device   The terminal device you want to use, such as COM1.',0Dh,0Ah
 36212 00006621 202054686520746572-
 36212 0000662A 6D696E616C20646576-
 36212 00006633 69636520796F752077-
 36212 0000663C 616E7420746F207573-
 36212 00006645 652C20737563682061-
 36212 0000664E 7320434F4D312E0D0A 
 36213                                  MSG_1440:
 36214 00006657 2D                      	db 45
 36215 00006658 446973706C61797320-     	db 'Displays or sets the date.',0Dh,0Ah
 36215 00006661 6F7220736574732074-
 36215 0000666A 686520646174652E0D-
 36215 00006673 0A                 
 36216 00006674 0D0A                    	db 0Dh,0Ah
 36217 00006676 44415445205B646174-     	db 'DATE [date]',0Dh,0Ah
 36217 0000667F 655D0D0A           
 36218 00006683 0D0A                    	db 0Dh,0Ah
 36219                                  MSG_1441:
 36220 00006685 83                      	db 131
 36221 00006686 547970652044415445-     	db 'Type DATE without parameters to display the current date setting and',0Dh,0Ah
 36221 0000668F 20776974686F757420-
 36221 00006698 706172616D65746572-
 36221 000066A1 7320746F2064697370-
 36221 000066AA 6C6179207468652063-
 36221 000066B3 757272656E74206461-
 36221 000066BC 74652073657474696E-
 36221 000066C5 6720616E640D0A     
 36222 000066CC 612070726F6D707420-     	db 'a prompt for a new one.  Press ENTER to keep the same date.',0Dh,0Ah
 36222 000066D5 666F722061206E6577-
 36222 000066DE 206F6E652E20205072-
 36222 000066E7 65737320454E544552-
 36222 000066F0 20746F206B65657020-
 36222 000066F9 7468652073616D6520-
 36222 00006702 646174652E0D0A     
 36223                                  MSG_1460:	
 36224 00006709 64                      	db 100
 36225 0000670A 44656C65746573206F-     	db 'Deletes one or more files.',0Dh,0Ah
 36225 00006713 6E65206F72206D6F72-
 36225 0000671C 652066696C65732E0D-
 36225 00006725 0A                 
 36226 00006726 0D0A                    	db 0Dh,0Ah
 36227 00006728 44454C205B64726976-     	db 'DEL [drive:][path]filename [/P]',0Dh,0Ah
 36227 00006731 653A5D5B706174685D-
 36227 0000673A 66696C656E616D6520-
 36227 00006743 5B2F505D0D0A       
 36228 00006749 4552415345205B6472-     	db 'ERASE [drive:][path]filename [/P]',0Dh,0Ah
 36228 00006752 6976653A5D5B706174-
 36228 0000675B 685D66696C656E616D-
 36228 00006764 65205B2F505D0D0A   
 36229 0000676C 0D0A                    	db 0Dh,0Ah
 36230                                  MSG_1461:
 36231 0000676E 83                      	db 131
 36232 0000676F 20205B64726976653A-     	db '  [drive:][path]filename  Specifies the file(s) to delete.  Specify multiple',0Dh,0Ah
 36232 00006778 5D5B706174685D6669-
 36232 00006781 6C656E616D65202053-
 36232 0000678A 706563696669657320-
 36232 00006793 7468652066696C6528-
 36232 0000679C 732920746F2064656C-
 36232 000067A5 6574652E2020537065-
 36232 000067AE 63696679206D756C74-
 36232 000067B7 69706C650D0A       
 36233 000067BD 202020202020202020-     	db '                          files by using wildcards.',0Dh,0Ah
 36233 000067C6 202020202020202020-
 36233 000067CF 202020202020202066-
 36233 000067D8 696C65732062792075-
 36233 000067E1 73696E672077696C64-
 36233 000067EA 63617264732E0D0A   
 36234                                  MSG_1462:
 36235 000067F2 4F                      	db 79
 36236 000067F3 20202F502020202020-     	db '  /P                      Prompts for confirmation before deleting each file.',0Dh,0Ah
 36236 000067FC 202020202020202020-
 36236 00006805 202020202020202050-
 36236 0000680E 726F6D70747320666F-
 36236 00006817 7220636F6E6669726D-
 36236 00006820 6174696F6E20626566-
 36236 00006829 6F72652064656C6574-
 36236 00006832 696E67206561636820-
 36236 0000683B 66696C652E0D0A     
 36237                                  MSG_1480:
 36238 00006842 A2                      	db 162
 36239 00006843 446973706C61797320-     	db 'Displays a list of files and subdirectories in a directory.',0Dh,0Ah
 36239 0000684C 61206C697374206F66-
 36239 00006855 2066696C657320616E-
 36239 0000685E 642073756264697265-
 36239 00006867 63746F726965732069-
 36239 00006870 6E2061206469726563-
 36239 00006879 746F72792E0D0A     
 36240 00006880 0D0A                    	db 0Dh,0Ah
 36241 00006882 444952205B64726976-     	db 'DIR [drive:][path][filename] [/P] [/W] [/A[[:]attributes]]',0Dh,0Ah
 36241 0000688B 653A5D5B706174685D-
 36241 00006894 5B66696C656E616D65-
 36241 0000689D 5D205B2F505D205B2F-
 36241 000068A6 575D205B2F415B5B3A-
 36241 000068AF 5D6174747269627574-
 36241 000068B8 65735D5D0D0A       
 36242 000068BE 20205B2F4F5B5B3A5D-     	db '  [/O[[:]sortorder]] [/S] [/B] [/L]',0Dh,0Ah
 36242 000068C7 736F72746F72646572-
 36242 000068D0 5D5D205B2F535D205B-
 36242 000068D9 2F425D205B2F4C5D0D-
 36242 000068E2 0A                 
 36243 000068E3 0D0A                    	db 0Dh,0Ah
 36244                                  MSG_1481:
 36245 000068E5 5D                      	db 93
 36246 000068E6 20205B64726976653A-     	db '  [drive:][path][filename]',0Dh,0Ah
 36246 000068EF 5D5B706174685D5B66-
 36246 000068F8 696C656E616D655D0D-
 36246 00006901 0A                 
 36247 00006902 202020202020202020-     	db '              Specifies drive, directory, and/or files to list.',0Dh,0Ah
 36247 0000690B 202020202053706563-
 36247 00006914 696669657320647269-
 36247 0000691D 76652C206469726563-
 36247 00006926 746F72792C20616E64-
 36247 0000692F 2F6F722066696C6573-
 36247 00006938 20746F206C6973742E-
 36247 00006941 0D0A               
 36248                                  MSG_1482:
 36249 00006943 61                      	db 97
 36250 00006944 20202F502020202020-     	db '  /P          Pauses after each screenful of information.',0Dh,0Ah
 36250 0000694D 202020202050617573-
 36250 00006956 657320616674657220-
 36250 0000695F 656163682073637265-
 36250 00006968 656E66756C206F6620-
 36250 00006971 696E666F726D617469-
 36250 0000697A 6F6E2E0D0A         
 36251 0000697F 20202F572020202020-     	db '  /W          Uses wide list format.',0Dh,0Ah
 36251 00006988 202020202055736573-
 36251 00006991 2077696465206C6973-
 36251 0000699A 7420666F726D61742E-
 36251 000069A3 0D0A               
 36252                                  MSG_1483:	
 36253 000069A5 7A                      	db 122
 36254 000069A6 20202F412020202020-     	db '  /A          Displays files with specified attributes.',0Dh,0Ah
 36254 000069AF 202020202044697370-
 36254 000069B8 6C6179732066696C65-
 36254 000069C1 732077697468207370-
 36254 000069CA 656369666965642061-
 36254 000069D3 747472696275746573-
 36254 000069DC 2E0D0A             
 36255 000069DF 202061747472696275-     	db '  attributes   D  Directories                R  Read-only files',0Dh,0Ah
 36255 000069E8 746573202020442020-
 36255 000069F1 4469726563746F7269-
 36255 000069FA 657320202020202020-
 36255 00006A03 202020202020202020-
 36255 00006A0C 522020526561642D6F-
 36255 00006A15 6E6C792066696C6573-
 36255 00006A1E 0D0A               
 36256                                  MSG_1484:
 36257 00006A20 BF                      	db 191
 36258 00006A21 202020202020202020-     	db '               H  Hidden files               A  Files ready for archiving',0Dh,0Ah
 36258 00006A2A 202020202020482020-
 36258 00006A33 48696464656E206669-
 36258 00006A3C 6C6573202020202020-
 36258 00006A45 202020202020202020-
 36258 00006A4E 41202046696C657320-
 36258 00006A57 726561647920666F72-
 36258 00006A60 20617263686976696E-
 36258 00006A69 670D0A             
 36259 00006A6C 202020202020202020-     	db '               S  System files               -  Prefix meaning "not"',0Dh,0Ah
 36259 00006A75 202020202020532020-
 36259 00006A7E 53797374656D206669-
 36259 00006A87 6C6573202020202020-
 36259 00006A90 202020202020202020-
 36259 00006A99 2D2020507265666978-
 36259 00006AA2 206D65616E696E6720-
 36259 00006AAB 226E6F74220D0A     
 36260 00006AB2 20202F4F2020202020-     	db '  /O          List by files in sorted order.',0Dh,0Ah
 36260 00006ABB 20202020204C697374-
 36260 00006AC4 2062792066696C6573-
 36260 00006ACD 20696E20736F727465-
 36260 00006AD6 64206F726465722E0D-
 36260 00006ADF 0A                 
 36261                                  MSG_1485:
 36262 00006AE0 9B                      	db 155
 36263 00006AE1 2020736F72746F7264-     	db '  sortorder    N  By name (alphabetic)       S  By size (smallest first)',0Dh,0Ah
 36263 00006AEA 6572202020204E2020-
 36263 00006AF3 4279206E616D652028-
 36263 00006AFC 616C70686162657469-
 36263 00006B05 632920202020202020-
 36263 00006B0E 53202042792073697A-
 36263 00006B17 652028736D616C6C65-
 36263 00006B20 737420666972737429-
 36263 00006B29 0D0A               
 36264 00006B2B 202020202020202020-     	db '               E  By extension (alphabetic)  D  By date & time (earliest first)',0Dh,0Ah
 36264 00006B34 202020202020452020-
 36264 00006B3D 427920657874656E73-
 36264 00006B46 696F6E2028616C7068-
 36264 00006B4F 616265746963292020-
 36264 00006B58 442020427920646174-
 36264 00006B61 6520262074696D6520-
 36264 00006B6A 286561726C69657374-
 36264 00006B73 206669727374290D0A 
 36265                                  MSG_1486:
 36266 00006B7C 96                      	db 150
 36267 00006B7D 202020202020202020-     	db '               G  Group directories first    -  Prefix to reverse order',0Dh,0Ah
 36267 00006B86 202020202020472020-
 36267 00006B8F 47726F757020646972-
 36267 00006B98 6563746F7269657320-
 36267 00006BA1 666972737420202020-
 36267 00006BAA 2D2020507265666978-
 36267 00006BB3 20746F207265766572-
 36267 00006BBC 7365206F726465720D-
 36267 00006BC5 0A                 
 36268 00006BC6 20202F532020202020-     	db '  /S          Displays files in specified directory and all subdirectories.',0Dh,0Ah
 36268 00006BCF 202020202044697370-
 36268 00006BD8 6C6179732066696C65-
 36268 00006BE1 7320696E2073706563-
 36268 00006BEA 696669656420646972-
 36268 00006BF3 6563746F727920616E-
 36268 00006BFC 6420616C6C20737562-
 36268 00006C05 6469726563746F7269-
 36268 00006C0E 65732E0D0A         
 36269                                  MSG_1487:
 36270 00006C13 66                      	db 102
 36271 00006C14 20202F422020202020-     	db '  /B          Uses bare format (no heading information or summary).',0Dh,0Ah
 36271 00006C1D 202020202055736573-
 36271 00006C26 206261726520666F72-
 36271 00006C2F 6D617420286E6F2068-
 36271 00006C38 656164696E6720696E-
 36271 00006C41 666F726D6174696F6E-
 36271 00006C4A 206F722073756D6D61-
 36271 00006C53 7279292E0D0A       
 36272 00006C59 20202F4C2020202020-     	db '  /L          Uses lowercase.',0Dh,0Ah
 36272 00006C62 202020202055736573-
 36272 00006C6B 206C6F776572636173-
 36272 00006C74 652E0D0A           
 36273 00006C78 0D0A                    	db 0Dh,0Ah
 36274                                  MSG_1488:
 36275 00006C7A 92                      	db 146
 36276 00006C7B 537769746368657320-     	db 'Switches may be preset in the DIRCMD environment variable.  Override',0Dh,0Ah
 36276 00006C84 6D6179206265207072-
 36276 00006C8D 6573657420696E2074-
 36276 00006C96 686520444952434D44-
 36276 00006C9F 20656E7669726F6E6D-
 36276 00006CA8 656E74207661726961-
 36276 00006CB1 626C652E20204F7665-
 36276 00006CBA 72726964650D0A     
 36277 00006CC1 707265736574207377-     	db 'preset switches by prefixing any switch with - (hyphen)--for example, /-W.',0Dh,0Ah
 36277 00006CCA 697463686573206279-
 36277 00006CD3 20707265666978696E-
 36277 00006CDC 6720616E7920737769-
 36277 00006CE5 746368207769746820-
 36277 00006CEE 2D202868797068656E-
 36277 00006CF7 292D2D666F72206578-
 36277 00006D00 616D706C652C202F2D-
 36277 00006D09 572E0D0A           
 36278                                  MSG_1500:
 36279 00006D0D 3E                      	db 62
 36280 00006D0E 517569747320746865-     	db 'Quits the COMMAND.COM program (command interpreter).',0Dh,0Ah
 36280 00006D17 20434F4D4D414E442E-
 36280 00006D20 434F4D2070726F6772-
 36280 00006D29 616D2028636F6D6D61-
 36280 00006D32 6E6420696E74657270-
 36280 00006D3B 7265746572292E0D0A 
 36281 00006D44 0D0A                    	db 0Dh,0Ah
 36282 00006D46 455849540D0A            	db 'EXIT',0Dh,0Ah
 36283                                  MSG_1520:
 36284 00006D4C 3D                      	db 61
 36285 00006D4D 437265617465732061-     	db 'Creates a directory.',0Dh,0Ah
 36285 00006D56 206469726563746F72-
 36285 00006D5F 792E0D0A           
 36286 00006D63 0D0A                    	db 0Dh,0Ah
 36287 00006D65 4D4B444952205B6472-     	db 'MKDIR [drive:]path',0Dh,0Ah
 36287 00006D6E 6976653A5D70617468-
 36287 00006D77 0D0A               
 36288 00006D79 4D44205B6472697665-     	db 'MD [drive:]path',0Dh,0Ah
 36288 00006D82 3A5D706174680D0A   
 36289                                  MSG_1540:
 36290 00006D8A 5D                      	db 93
 36291 00006D8B 446973706C61797320-     	db 'Displays or sets a search path for executable files.',0Dh,0Ah
 36291 00006D94 6F7220736574732061-
 36291 00006D9D 207365617263682070-
 36291 00006DA6 61746820666F722065-
 36291 00006DAF 786563757461626C65-
 36291 00006DB8 2066696C65732E0D0A 
 36292 00006DC1 0D0A                    	db 0Dh,0Ah
 36293 00006DC3 50415448205B5B6472-     	db 'PATH [[drive:]path[;...]]',0Dh,0Ah
 36293 00006DCC 6976653A5D70617468-
 36293 00006DD5 5B3B2E2E2E5D5D0D0A 
 36294 00006DDE 50415448203B0D0A        	db 'PATH ;',0Dh,0Ah
 36295 00006DE6 0D0A                    	db 0Dh,0Ah
 36296                                  MSG_1541:
 36297 00006DE8 6B                      	db 107
 36298 00006DE9 547970652050415448-     	db 'Type PATH ; to clear all search-path settings and direct MS-DOS to search',0Dh,0Ah
 36298 00006DF2 203B20746F20636C65-
 36298 00006DFB 617220616C6C207365-
 36298 00006E04 617263682D70617468-
 36298 00006E0D 2073657474696E6773-
 36298 00006E16 20616E642064697265-
 36298 00006E1F 6374204D532D444F53-
 36298 00006E28 20746F207365617263-
 36298 00006E31 680D0A             
 36299 00006E34 6F6E6C7920696E2074-     	db 'only in the current directory.',0Dh,0Ah
 36299 00006E3D 68652063757272656E-
 36299 00006E46 74206469726563746F-
 36299 00006E4F 72792E0D0A         
 36300                                  MSG_1542:	
 36301 00006E54 3B                      	db 59
 36302 00006E55 547970652050415448-     	db 'Type PATH without parameters to display the current path.',0Dh,0Ah
 36302 00006E5E 20776974686F757420-
 36302 00006E67 706172616D65746572-
 36302 00006E70 7320746F2064697370-
 36302 00006E79 6C6179207468652063-
 36302 00006E82 757272656E74207061-
 36302 00006E8B 74682E0D0A         
 36303                                  MSG_1560:
 36304 00006E90 37                      	db 55
 36305 00006E91 4368616E6765732074-     	db 'Changes the MS-DOS command prompt.',0Dh,0Ah
 36305 00006E9A 6865204D532D444F53-
 36305 00006EA3 20636F6D6D616E6420-
 36305 00006EAC 70726F6D70742E0D0A 
 36306 00006EB5 0D0A                    	db 0Dh,0Ah
 36307 00006EB7 50524F4D5054205B74-     	db 'PROMPT [text]',0Dh,0Ah
 36307 00006EC0 6578745D0D0A       
 36308 00006EC6 0D0A                    	db 0Dh,0Ah
 36309                                  MSG_1561:	
 36310 00006EC8 7C                      	db 124
 36311 00006EC9 202074657874202020-     	db '  text    Specifies a new command prompt.',0Dh,0Ah
 36311 00006ED2 205370656369666965-
 36311 00006EDB 732061206E65772063-
 36311 00006EE4 6F6D6D616E64207072-
 36311 00006EED 6F6D70742E0D0A     
 36312 00006EF4 0D0A                    	db 0Dh,0Ah
 36313 00006EF6 50726F6D7074206361-     	db 'Prompt can be made up of normal characters and the following special codes:',0Dh,0Ah
 36313 00006EFF 6E206265206D616465-
 36313 00006F08 207570206F66206E6F-
 36313 00006F11 726D616C2063686172-
 36313 00006F1A 61637465727320616E-
 36313 00006F23 642074686520666F6C-
 36313 00006F2C 6C6F77696E67207370-
 36313 00006F35 656369616C20636F64-
 36313 00006F3E 65733A0D0A         
 36314 00006F43 0D0A                    	db 0Dh,0Ah
 36315                                  MSG_1562:
 36316 00006F45 2F                      	db 47
 36317 00006F46 202024512020203D20-     	db '  $Q   = (equal sign)',0Dh,0Ah
 36317 00006F4F 28657175616C207369-
 36317 00006F58 676E290D0A         
 36318 00006F5D 202024242020202420-     	db '  $$   $ (dollar sign)',0Dh,0Ah
 36318 00006F66 28646F6C6C61722073-
 36318 00006F6F 69676E290D0A       
 36319                                  MSG_1563:
 36320 00006F75 2A                      	db 42
 36321 00006F76 202024542020204375-     	db '  $T   Current time',0Dh,0Ah
 36321 00006F7F 7272656E742074696D-
 36321 00006F88 650D0A             
 36322 00006F8B 202024442020204375-     	db '  $D   Current date',0Dh,0Ah
 36322 00006F94 7272656E7420646174-
 36322 00006F9D 650D0A             
 36323                                  MSG_1564:
 36324 00006FA0 3D                      	db 61
 36325 00006FA1 202024502020204375-     	db '  $P   Current drive and path',0Dh,0Ah
 36325 00006FAA 7272656E7420647269-
 36325 00006FB3 766520616E64207061-
 36325 00006FBC 74680D0A           
 36326 00006FC0 202024562020204D53-     	db '  $V   MS-DOS version number',0Dh,0Ah
 36326 00006FC9 2D444F532076657273-
 36326 00006FD2 696F6E206E756D6265-
 36326 00006FDB 720D0A             
 36327                                  MSG_1565:
 36328 00006FDE 34                      	db 52
 36329 00006FDF 2020244E2020204375-     	db '  $N   Current drive',0Dh,0Ah
 36329 00006FE8 7272656E7420647269-
 36329 00006FF1 76650D0A           
 36330 00006FF5 202024472020203E20-     	db '  $G   > (greater-than sign)',0Dh,0Ah
 36330 00006FFE 28677265617465722D-
 36330 00007007 7468616E207369676E-
 36330 00007010 290D0A             
 36331                                  MSG_1566:
 36332 00007013 2C                      	db 44
 36333 00007014 2020244C2020203C20-     	db '  $L   < (less-than sign)',0Dh,0Ah
 36333 0000701D 286C6573732D746861-
 36333 00007026 6E207369676E290D0A 
 36334 0000702F 202024422020207C20-     	db '  $B   | (pipe)',0Dh,0Ah
 36334 00007038 2870697065290D0A   
 36335                                  MSG_1567:
 36336 00007040 79                      	db 121
 36337 00007041 202024482020204261-     	db '  $H   Backspace (erases previous character)',0Dh,0Ah
 36337 0000704A 636B73706163652028-
 36337 00007053 657261736573207072-
 36337 0000705C 6576696F7573206368-
 36337 00007065 61726163746572290D-
 36337 0000706E 0A                 
 36338 0000706F 202024452020204573-     	db '  $E   Escape code (ASCII code 27)',0Dh,0Ah
 36338 00007078 6361706520636F6465-
 36338 00007081 202841534349492063-
 36338 0000708A 6F6465203237290D0A 
 36339 00007093 2020245F2020204361-     	db '  $_   Carriage return and linefeed',0Dh,0Ah
 36339 0000709C 727269616765207265-
 36339 000070A5 7475726E20616E6420-
 36339 000070AE 6C696E65666565640D-
 36339 000070B7 0A                 
 36340 000070B8 0D0A                    	db 0Dh,0Ah
 36341                                  MSG_1568:
 36342 000070BA 4C                      	db 76
 36343 000070BB 547970652050524F4D-     	db 'Type PROMPT without parameters to reset the prompt to the default setting.',0Dh,0Ah
 36343 000070C4 505420776974686F75-
 36343 000070CD 7420706172616D6574-
 36343 000070D6 65727320746F207265-
 36343 000070DF 736574207468652070-
 36343 000070E8 726F6D707420746F20-
 36343 000070F1 746865206465666175-
 36343 000070FA 6C742073657474696E-
 36343 00007103 672E0D0A           
 36344                                  MSG_1580:
 36345 00007107 47                      	db 71
 36346 00007108 52656D6F7665732028-     	db 'Removes (deletes) a directory.',0Dh,0Ah
 36346 00007111 64656C657465732920-
 36346 0000711A 61206469726563746F-
 36346 00007123 72792E0D0A         
 36347 00007128 0D0A                    	db 0Dh,0Ah
 36348 0000712A 524D444952205B6472-     	db 'RMDIR [drive:]path',0Dh,0Ah
 36348 00007133 6976653A5D70617468-
 36348 0000713C 0D0A               
 36349 0000713E 5244205B6472697665-     	db 'RD [drive:]path',0Dh,0Ah
 36349 00007147 3A5D706174680D0A   
 36350                                  MSG_1600:
 36351 0000714F 1C                      	db 28
 36352 00007150 52656E616D65732061-     	db 'Renames a file or files.',0Dh,0Ah
 36352 00007159 2066696C65206F7220-
 36352 00007162 66696C65732E0D0A   
 36353 0000716A 0D0A                    	db 0Dh,0Ah
 36354                                  MSG_1601:
 36355 0000716C 53                      	db 83
 36356 0000716D 52454E414D45205B64-     	db 'RENAME [drive:][path]filename1 filename2',0Dh,0Ah
 36356 00007176 726976653A5D5B7061-
 36356 0000717F 74685D66696C656E61-
 36356 00007188 6D65312066696C656E-
 36356 00007191 616D65320D0A       
 36357 00007197 52454E205B64726976-     	db 'REN [drive:][path]filename1 filename2',0Dh,0Ah
 36357 000071A0 653A5D5B706174685D-
 36357 000071A9 66696C656E616D6531-
 36357 000071B2 2066696C656E616D65-
 36357 000071BB 320D0A             
 36358 000071BE 0D0A                    	db 0Dh,0Ah
 36359                                  MSG_1602:
 36360 000071C0 4D                      	db 77
 36361 000071C1 4E6F74652074686174-     	db 'Note that you cannot specify a new drive or path for your destination file.',0Dh,0Ah
 36361 000071CA 20796F752063616E6E-
 36361 000071D3 6F7420737065636966-
 36361 000071DC 792061206E65772064-
 36361 000071E5 72697665206F722070-
 36361 000071EE 61746820666F722079-
 36361 000071F7 6F7572206465737469-
 36361 00007200 6E6174696F6E206669-
 36361 00007209 6C652E0D0A         
 36362                                  MSG_1620:
 36363 0000720E 57                      	db 87
 36364 0000720F 446973706C6179732C-     	db 'Displays, sets, or removes MS-DOS environment variables.',0Dh,0Ah
 36364 00007218 20736574732C206F72-
 36364 00007221 2072656D6F76657320-
 36364 0000722A 4D532D444F5320656E-
 36364 00007233 7669726F6E6D656E74-
 36364 0000723C 207661726961626C65-
 36364 00007245 732E0D0A           
 36365 00007249 0D0A                    	db 0Dh,0Ah
 36366 0000724B 534554205B76617269-     	db 'SET [variable=[string]]',0Dh,0Ah
 36366 00007254 61626C653D5B737472-
 36366 0000725D 696E675D5D0D0A     
 36367 00007264 0D0A                    	db 0Dh,0Ah
 36368                                  MSG_1621:
 36369 00007266 81                      	db 129
 36370 00007267 20207661726961626C-     	db '  variable  Specifies the environment-variable name.',0Dh,0Ah
 36370 00007270 652020537065636966-
 36370 00007279 696573207468652065-
 36370 00007282 6E7669726F6E6D656E-
 36370 0000728B 742D7661726961626C-
 36370 00007294 65206E616D652E0D0A 
 36371 0000729D 2020737472696E6720-     	db '  string    Specifies a series of characters to assign to the variable.',0Dh,0Ah
 36371 000072A6 202020537065636966-
 36371 000072AF 696573206120736572-
 36371 000072B8 696573206F66206368-
 36371 000072C1 617261637465727320-
 36371 000072CA 746F2061737369676E-
 36371 000072D3 20746F207468652076-
 36371 000072DC 61726961626C652E0D-
 36371 000072E5 0A                 
 36372 000072E6 0D0A                    	db 0Dh,0Ah
 36373                                  MSG_1622:
 36374 000072E8 4B                      	db 75
 36375 000072E9 547970652053455420-     	db 'Type SET without parameters to display the current environment variables.',0Dh,0Ah
 36375 000072F2 776974686F75742070-
 36375 000072FB 6172616D6574657273-
 36375 00007304 20746F20646973706C-
 36375 0000730D 617920746865206375-
 36375 00007316 7272656E7420656E76-
 36375 0000731F 69726F6E6D656E7420-
 36375 00007328 7661726961626C6573-
 36375 00007331 2E0D0A             
 36376                                  MSG_1640:
 36377 00007334 34                      	db 52
 36378 00007335 446973706C61797320-     	db 'Displays or sets the system time.',0Dh,0Ah
 36378 0000733E 6F7220736574732074-
 36378 00007347 68652073797374656D-
 36378 00007350 2074696D652E0D0A   
 36379 00007358 0D0A                    	db 0Dh,0Ah
 36380 0000735A 54494D45205B74696D-     	db 'TIME [time]',0Dh,0Ah
 36380 00007363 655D0D0A           
 36381 00007367 0D0A                    	db 0Dh,0Ah
 36382                                  MSG_1641:
 36383 00007369 83                      	db 131
 36384 0000736A 547970652054494D45-     	db 'Type TIME with no parameters to display the current time setting and a prompt',0Dh,0Ah
 36384 00007373 2077697468206E6F20-
 36384 0000737C 706172616D65746572-
 36384 00007385 7320746F2064697370-
 36384 0000738E 6C6179207468652063-
 36384 00007397 757272656E74207469-
 36384 000073A0 6D652073657474696E-
 36384 000073A9 6720616E6420612070-
 36384 000073B2 726F6D70740D0A     
 36385 000073B9 666F722061206E6577-     	db 'for a new one.  Press ENTER to keep the same time.',0Dh,0Ah
 36385 000073C2 206F6E652E20205072-
 36385 000073CB 65737320454E544552-
 36385 000073D4 20746F206B65657020-
 36385 000073DD 7468652073616D6520-
 36385 000073E6 74696D652E0D0A     
 36386                                  MSG_1660:
 36387 000073ED 46                      	db 70
 36388 000073EE 446973706C61797320-     	db 'Displays the contents of a text file.',0Dh,0Ah
 36388 000073F7 74686520636F6E7465-
 36388 00007400 6E7473206F66206120-
 36388 00007409 746578742066696C65-
 36388 00007412 2E0D0A             
 36389 00007415 0D0A                    	db 0Dh,0Ah
 36390 00007417 54595045205B647269-     	db 'TYPE [drive:][path]filename',0Dh,0Ah
 36390 00007420 76653A5D5B70617468-
 36390 00007429 5D66696C656E616D65-
 36390 00007432 0D0A               
 36391                                  MSG_1680:
 36392 00007434 25                      	db 37
 36393 00007435 446973706C61797320-     	db 'Displays the MS-DOS version.',0Dh,0Ah
 36393 0000743E 746865204D532D444F-
 36393 00007447 532076657273696F6E-
 36393 00007450 2E0D0A             
 36394 00007453 0D0A                    	db 0Dh,0Ah
 36395 00007455 5645520D0A              	db 'VER',0Dh,0Ah
 36396                                  MSG_1700:
 36397 0000745A B1                      	db 177
 36398 0000745B 54656C6C73204D532D-     	db 'Tells MS-DOS whether to verify that your files are written correctly to a',0Dh,0Ah
 36398 00007464 444F53207768657468-
 36398 0000746D 657220746F20766572-
 36398 00007476 696679207468617420-
 36398 0000747F 796F75722066696C65-
 36398 00007488 732061726520777269-
 36398 00007491 7474656E20636F7272-
 36398 0000749A 6563746C7920746F20-
 36398 000074A3 610D0A             
 36399 000074A6 6469736B2E0D0A          	db 'disk.',0Dh,0Ah
 36400 000074AD 0D0A                    	db 0Dh,0Ah
 36401 000074AF 564552494659205B4F-     	db 'VERIFY [ON | OFF]',0Dh,0Ah
 36401 000074B8 4E207C204F46465D0D-
 36401 000074C1 0A                 
 36402 000074C2 0D0A                    	db 0Dh,0Ah
 36403 000074C4 547970652056455249-     	db 'Type VERIFY without a parameter to display the current VERIFY setting.',0Dh,0Ah
 36403 000074CD 465920776974686F75-
 36403 000074D6 74206120706172616D-
 36403 000074DF 6574657220746F2064-
 36403 000074E8 6973706C6179207468-
 36403 000074F1 652063757272656E74-
 36403 000074FA 205645524946592073-
 36403 00007503 657474696E672E0D0A 
 36404                                  MSG_1720:              
 36405 0000750C 52                      	db 82
 36406 0000750D 446973706C61797320-     	db 'Displays the disk volume label and serial number, if they exist.',0Dh,0Ah
 36406 00007516 746865206469736B20-
 36406 0000751F 766F6C756D65206C61-
 36406 00007528 62656C20616E642073-
 36406 00007531 657269616C206E756D-
 36406 0000753A 6265722C2069662074-
 36406 00007543 686579206578697374-
 36406 0000754C 2E0D0A             
 36407 0000754F 0D0A                    	db 0Dh,0Ah
 36408 00007551 564F4C205B64726976-     	db 'VOL [drive:]',0Dh,0Ah
 36408 0000755A 653A5D0D0A         
 36409                                  MSG_1740:
 36410 0000755F 5B                      	db 91
 36411 00007560 43616C6C73206F6E65-     	db 'Calls one batch program from another.',0Dh,0Ah
 36411 00007569 206261746368207072-
 36411 00007572 6F6772616D2066726F-
 36411 0000757B 6D20616E6F74686572-
 36411 00007584 2E0D0A             
 36412 00007587 0D0A                    	db 0Dh,0Ah
 36413 00007589 43414C4C205B647269-     	db 'CALL [drive:][path]filename [batch-parameters]',0Dh,0Ah
 36413 00007592 76653A5D5B70617468-
 36413 0000759B 5D66696C656E616D65-
 36413 000075A4 205B62617463682D70-
 36413 000075AD 6172616D6574657273-
 36413 000075B6 5D0D0A             
 36414 000075B9 0D0A                    	db 0Dh,0Ah
 36415                                  MSG_1741:
 36416 000075BB 72                      	db 114
 36417 000075BC 202062617463682D70-     	db '  batch-parameters   Specifies any command-line information required by the',0Dh,0Ah
 36417 000075C5 6172616D6574657273-
 36417 000075CE 202020537065636966-
 36417 000075D7 69657320616E792063-
 36417 000075E0 6F6D6D616E642D6C69-
 36417 000075E9 6E6520696E666F726D-
 36417 000075F2 6174696F6E20726571-
 36417 000075FB 756972656420627920-
 36417 00007604 7468650D0A         
 36418 00007609 202020202020202020-     	db '                     batch program.',0Dh,0Ah
 36418 00007612 202020202020202020-
 36418 0000761B 202020626174636820-
 36418 00007624 70726F6772616D2E0D-
 36418 0000762D 0A                 
 36419                                  MSG_1760:	
 36420 0000762E 4C                      	db 76
 36421 0000762F 5265636F7264732063-     	db 'Records comments (remarks) in a batch file or CONFIG.SYS.',0Dh,0Ah
 36421 00007638 6F6D6D656E74732028-
 36421 00007641 72656D61726B732920-
 36421 0000764A 696E20612062617463-
 36421 00007653 682066696C65206F72-
 36421 0000765C 20434F4E4649472E53-
 36421 00007665 59532E0D0A         
 36422 0000766A 0D0A                    	db 0Dh,0Ah
 36423 0000766C 52454D205B636F6D6D-     	db 'REM [comment]',0Dh,0Ah
 36423 00007675 656E745D0D0A       
 36424                                  MSG_1780:
 36425 0000767B 6B                      	db 107
 36426 0000767C 53757370656E647320-     	db 'Suspends processing of a batch program and displays the message "'
 36426 00007685 70726F63657373696E-
 36426 0000768E 67206F662061206261-
 36426 00007697 7463682070726F6772-
 36426 000076A0 616D20616E64206469-
 36426 000076A9 73706C617973207468-
 36426 000076B2 65206D657373616765-
 36426 000076BB 2022               
 36427 000076BD 507265737320616E79-     	db 'Press any',0Dh,0Ah
 36427 000076C6 0D0A               
 36428 000076C8 6B657920746F20636F-     	db 'key to continue...."',0Dh,0Ah
 36428 000076D1 6E74696E75652E2E2E-
 36428 000076DA 2E220D0A           
 36429 000076DE 0D0A                    	db 0Dh,0Ah
 36430 000076E0 50415553450D0A          	db 'PAUSE',0Dh,0Ah
 36431                                  MSG_1800:
 36432 000076E7 4D                      	db 77
 36433 000076E8 446973706C61797320-     	db 'Displays messages, or turns command-echoing on or off.',0Dh,0Ah
 36433 000076F1 6D657373616765732C-
 36433 000076FA 206F72207475726E73-
 36433 00007703 20636F6D6D616E642D-
 36433 0000770C 6563686F696E67206F-
 36433 00007715 6E206F72206F66662E-
 36433 0000771E 0D0A               
 36434 00007720 0D0A                    	db 0Dh,0Ah
 36435 00007722 20204543484F205B4F-     	db '  ECHO [ON | OFF]',0Dh,0Ah
 36435 0000772B 4E207C204F46465D0D-
 36435 00007734 0A                 
 36436                                  MSG_1801:
 36437 00007735 57                      	db 87
 36438 00007736 20204543484F205B6D-     	db '  ECHO [message]',0Dh,0Ah
 36438 0000773F 6573736167655D0D0A 
 36439 00007748 0D0A                    	db 0Dh,0Ah
 36440 0000774A 54797065204543484F-     	db 'Type ECHO without parameters to display the current echo setting.'
 36440 00007753 20776974686F757420-
 36440 0000775C 706172616D65746572-
 36440 00007765 7320746F2064697370-
 36440 0000776E 6C6179207468652063-
 36440 00007777 757272656E74206563-
 36440 00007780 686F2073657474696E-
 36440 00007789 672E               
 36441 0000778B 0D0A                    	db 0Dh,0Ah
 36442                                  MSG_1820:
 36443 0000778D 47                      	db 71
 36444 0000778E 44697265637473204D-     	db 'Directs MS-DOS to a labelled line in a batch program.',0Dh,0Ah
 36444 00007797 532D444F5320746F20-
 36444 000077A0 61206C6162656C6C65-
 36444 000077A9 64206C696E6520696E-
 36444 000077B2 206120626174636820-
 36444 000077BB 70726F6772616D2E0D-
 36444 000077C4 0A                 
 36445 000077C5 0D0A                    	db 0Dh,0Ah
 36446 000077C7 474F544F206C616265-     	db 'GOTO label',0Dh,0Ah
 36446 000077D0 6C0D0A             
 36447 000077D3 0D0A                    	db 0Dh,0Ah
 36448                                  MSG_1821:
 36449 000077D5 8A                      	db 138
 36450 000077D6 20206C6162656C2020-     	db '  label   Specifies a text string used in the batch program as a label.',0Dh,0Ah
 36450 000077DF 205370656369666965-
 36450 000077E8 732061207465787420-
 36450 000077F1 737472696E67207573-
 36450 000077FA 656420696E20746865-
 36450 00007803 206261746368207072-
 36450 0000780C 6F6772616D20617320-
 36450 00007815 61206C6162656C2E0D-
 36450 0000781E 0A                 
 36451 0000781F 0D0A                    	db 0Dh,0Ah
 36452 00007821 596F75207479706520-     	db 'You type a label on a line by itself, beginning with a colon.',0Dh,0Ah
 36452 0000782A 61206C6162656C206F-
 36452 00007833 6E2061206C696E6520-
 36452 0000783C 627920697473656C66-
 36452 00007845 2C20626567696E6E69-
 36452 0000784E 6E6720776974682061-
 36452 00007857 20636F6C6F6E2E0D0A 
 36453                                  MSG_1840:
 36454 00007860 4A                      	db 74
 36455 00007861 4368616E6765732074-     	db 'Changes the position of replaceable parameters in a batch file.',0Dh,0Ah
 36455 0000786A 686520706F73697469-
 36455 00007873 6F6E206F6620726570-
 36455 0000787C 6C61636561626C6520-
 36455 00007885 706172616D65746572-
 36455 0000788E 7320696E2061206261-
 36455 00007897 7463682066696C652E-
 36455 000078A0 0D0A               
 36456 000078A2 0D0A                    	db 0Dh,0Ah
 36457 000078A4 53484946540D0A          	db 'SHIFT',0Dh,0Ah
 36458                                  MSG_1860:
 36459 000078AB 5A                      	db 90
 36460 000078AC 506572666F726D7320-     	db 'Performs conditional processing in batch programs.',0Dh,0Ah
 36460 000078B5 636F6E646974696F6E-
 36460 000078BE 616C2070726F636573-
 36460 000078C7 73696E6720696E2062-
 36460 000078D0 617463682070726F67-
 36460 000078D9 72616D732E0D0A     
 36461 000078E0 0D0A                    	db 0Dh,0Ah
 36462 000078E2 4946205B4E4F545D20-     	db 'IF [NOT] ERRORLEVEL number command',0Dh,0Ah
 36462 000078EB 4552524F524C455645-
 36462 000078F4 4C206E756D62657220-
 36462 000078FD 636F6D6D616E640D0A 
 36463                                  MSG_1861:
 36464 00007906 46                      	db 70
 36465 00007907 4946205B4E4F545D20-     	db 'IF [NOT] string1==string2 command',0Dh,0Ah
 36465 00007910 737472696E67313D3D-
 36465 00007919 737472696E67322063-
 36465 00007922 6F6D6D616E640D0A   
 36466 0000792A 4946205B4E4F545D20-     	db 'IF [NOT] EXIST filename command',0Dh,0Ah
 36466 00007933 45584953542066696C-
 36466 0000793C 656E616D6520636F6D-
 36466 00007945 6D616E640D0A       
 36467 0000794B 0D0A                    	db 0Dh,0Ah
 36468                                  MSG_1862:
 36469 0000794D 7D                      	db 125
 36470 0000794E 20204E4F5420202020-     	db '  NOT               Specifies that MS-DOS should carry out the command only',0Dh,0Ah
 36470 00007957 202020202020202020-
 36470 00007960 202053706563696669-
 36470 00007969 65732074686174204D-
 36470 00007972 532D444F532073686F-
 36470 0000797B 756C64206361727279-
 36470 00007984 206F75742074686520-
 36470 0000798D 636F6D6D616E64206F-
 36470 00007996 6E6C790D0A         
 36471 0000799B 202020202020202020-     	db '                    if the condition is false.',0Dh,0Ah
 36471 000079A4 202020202020202020-
 36471 000079AD 202069662074686520-
 36471 000079B6 636F6E646974696F6E-
 36471 000079BF 2069732066616C7365-
 36471 000079C8 2E0D0A             
 36472                                  MSG_1863:
 36473 000079CB A2                      	db 162
 36474 000079CC 20204552524F524C45-     	db '  ERRORLEVEL number Specifies a true condition if the last program run returned',0Dh,0Ah
 36474 000079D5 56454C206E756D6265-
 36474 000079DE 722053706563696669-
 36474 000079E7 657320612074727565-
 36474 000079F0 20636F6E646974696F-
 36474 000079F9 6E2069662074686520-
 36474 00007A02 6C6173742070726F67-
 36474 00007A0B 72616D2072756E2072-
 36474 00007A14 657475726E65640D0A 
 36475 00007A1D 202020202020202020-     	db '                    '
 36475 00007A26 202020202020202020-
 36475 00007A2F 2020               
 36476 00007A31 616E20657869742063-     	db 'an exit code equal to or greater than the number specified.',0Dh,0Ah
 36476 00007A3A 6F646520657175616C-
 36476 00007A43 20746F206F72206772-
 36476 00007A4C 656174657220746861-
 36476 00007A55 6E20746865206E756D-
 36476 00007A5E 626572207370656369-
 36476 00007A67 666965642E0D0A     
 36477                                  MSG_1864:
 36478 00007A6E 66                      	db 102
 36479 00007A6F 2020636F6D6D616E64-     	db '  command           Specifies the command to carry out if the condition is',0Dh,0Ah
 36479 00007A78 202020202020202020-
 36479 00007A81 202053706563696669-
 36479 00007A8A 65732074686520636F-
 36479 00007A93 6D6D616E6420746F20-
 36479 00007A9C 6361727279206F7574-
 36479 00007AA5 206966207468652063-
 36479 00007AAE 6F6E646974696F6E20-
 36479 00007AB7 69730D0A           
 36480 00007ABB 202020202020202020-     	db '                    met.',0Dh,0Ah
 36480 00007AC4 202020202020202020-
 36480 00007ACD 20206D65742E0D0A   
 36481                                  MSG_1865:
 36482 00007AD5 6A                      	db 106
 36483 00007AD6 2020737472696E6731-     	db '  string1==string2  Specifies a true condition if the specified text strings',0Dh,0Ah
 36483 00007ADF 3D3D737472696E6732-
 36483 00007AE8 202053706563696669-
 36483 00007AF1 657320612074727565-
 36483 00007AFA 20636F6E646974696F-
 36483 00007B03 6E2069662074686520-
 36483 00007B0C 737065636966696564-
 36483 00007B15 207465787420737472-
 36483 00007B1E 696E67730D0A       
 36484 00007B24 202020202020202020-     	db '                    match.',0Dh,0Ah
 36484 00007B2D 202020202020202020-
 36484 00007B36 20206D617463682E0D-
 36484 00007B3F 0A                 
 36485                                  MSG_1866:
 36486 00007B40 67                      	db 103
 36487 00007B41 202045584953542066-     	db '  EXIST filename    Specifies a true condition if the specified filename',0Dh,0Ah
 36487 00007B4A 696C656E616D652020-
 36487 00007B53 202053706563696669-
 36487 00007B5C 657320612074727565-
 36487 00007B65 20636F6E646974696F-
 36487 00007B6E 6E2069662074686520-
 36487 00007B77 737065636966696564-
 36487 00007B80 2066696C656E616D65-
 36487 00007B89 0D0A               
 36488 00007B8B 202020202020202020-     	db '                    exists.',0Dh,0Ah
 36488 00007B94 202020202020202020-
 36488 00007B9D 20206578697374732E-
 36488 00007BA6 0D0A               
 36489                                  MSG_1880:
 36490 00007BA8 77                      	db 119
 36491 00007BA9 52756E732061207370-     	db 'Runs a specified command for each file in a set of files.',0Dh,0Ah
 36491 00007BB2 656369666965642063-
 36491 00007BBB 6F6D6D616E6420666F-
 36491 00007BC4 722065616368206669-
 36491 00007BCD 6C6520696E20612073-
 36491 00007BD6 6574206F662066696C-
 36491 00007BDF 65732E0D0A         
 36492 00007BE4 0D0A                    	db 0Dh,0Ah
 36493 00007BE6 464F52202576617269-     	db 'FOR %variable IN (set) DO command [command-parameters]',0Dh,0Ah
 36493 00007BEF 61626C6520494E2028-
 36493 00007BF8 7365742920444F2063-
 36493 00007C01 6F6D6D616E64205B63-
 36493 00007C0A 6F6D6D616E642D7061-
 36493 00007C13 72616D65746572735D-
 36493 00007C1C 0D0A               
 36494 00007C1E 0D0A                    	db 0Dh,0Ah
 36495                                  MSG_1881:
 36496 00007C20 7D                      	db 125
 36497 00007C21 202025766172696162-     	db '  %variable  Specifies a replaceable parameter.',0Dh,0Ah
 36497 00007C2A 6C6520205370656369-
 36497 00007C33 666965732061207265-
 36497 00007C3C 706C61636561626C65-
 36497 00007C45 20706172616D657465-
 36497 00007C4E 722E0D0A           
 36498 00007C52 202028736574292020-     	db '  (set)      Specifies a set of one or more files.  Wildcards may be used.',0Dh,0Ah
 36498 00007C5B 202020205370656369-
 36498 00007C64 666965732061207365-
 36498 00007C6D 74206F66206F6E6520-
 36498 00007C76 6F72206D6F72652066-
 36498 00007C7F 696C65732E20205769-
 36498 00007C88 6C646361726473206D-
 36498 00007C91 617920626520757365-
 36498 00007C9A 642E0D0A           
 36499                                  MSG_1882:
 36500 00007C9E 56                      	db 86
 36501 00007C9F 2020636F6D6D616E64-     	db '  command    Specifies the command to carry out for each file.',0Dh,0Ah
 36501 00007CA8 202020205370656369-
 36501 00007CB1 666965732074686520-
 36501 00007CBA 636F6D6D616E642074-
 36501 00007CC3 6F206361727279206F-
 36501 00007CCC 757420666F72206561-
 36501 00007CD5 63682066696C652E0D-
 36501 00007CDE 0A                 
 36502 00007CDF 2020636F6D6D616E64-     	db '  command-parameters',0Dh,0Ah
 36502 00007CE8 2D706172616D657465-
 36502 00007CF1 72730D0A           
 36503                                  MSG_1883:
 36504 00007CF5 A2                      	db 162
 36505 00007CF6 202020202020202020-     	db '             Specifies parameters or switches for the specified command.',0Dh,0Ah
 36505 00007CFF 202020205370656369-
 36505 00007D08 666965732070617261-
 36505 00007D11 6D6574657273206F72-
 36505 00007D1A 207377697463686573-
 36505 00007D23 20666F722074686520-
 36505 00007D2C 737065636966696564-
 36505 00007D35 20636F6D6D616E642E-
 36505 00007D3E 0D0A               
 36506 00007D40 0D0A                    	db 0Dh,0Ah
 36507 00007D42 546F20757365207468-     	db 'To use the FOR command in a batch program, specify %%variable instead of',0Dh,0Ah
 36507 00007D4B 6520464F5220636F6D-
 36507 00007D54 6D616E6420696E2061-
 36507 00007D5D 206261746368207072-
 36507 00007D66 6F6772616D2C207370-
 36507 00007D6F 656369667920252576-
 36507 00007D78 61726961626C652069-
 36507 00007D81 6E7374656164206F66-
 36507 00007D8A 0D0A               
 36508 00007D8C 257661726961626C65-     	db '%variable.',0Dh,0Ah
 36508 00007D95 2E0D0A             
 36509                                  MSG_1900:
 36510 00007D98 17                      	db 23
 36511 00007D99 526573657276656420-     	db 'Reserved command name',0Dh,0Ah
 36511 00007DA2 636F6D6D616E64206E-
 36511 00007DAB 616D650D0A         
 36512                                  MSG_1920:
 36513 00007DB0 2F                      	db 47
 36514 00007DB1 4C6F61647320612070-     	db 'Loads a program into the upper memory area.',0Dh,0Ah
 36514 00007DBA 726F6772616D20696E-
 36514 00007DC3 746F20746865207570-
 36514 00007DCC 706572206D656D6F72-
 36514 00007DD5 7920617265612E0D0A 
 36515 00007DDE 0D0A                    	db 0Dh,0Ah
 36516                                  MSG_1921:
 36517 00007DE0 58                      	db 88
 36518 00007DE1 4C4F41444849474820-     	db 'LOADHIGH [drive:][path]filename [parameters]',0Dh,0Ah
 36518 00007DEA 5B64726976653A5D5B-
 36518 00007DF3 706174685D66696C65-
 36518 00007DFC 6E616D65205B706172-
 36518 00007E05 616D65746572735D0D-
 36518 00007E0E 0A                 
 36519 00007E0F 4C48205B6472697665-     	db 'LH [drive:][path]filename [parameters]',0Dh,0Ah
 36519 00007E18 3A5D5B706174685D66-
 36519 00007E21 696C656E616D65205B-
 36519 00007E2A 706172616D65746572-
 36519 00007E33 735D0D0A           
 36520 00007E37 0D0A                    	db 0Dh,0Ah
 36521                                  MSG_1922:
 36522 00007E39 71                      	db 113
 36523 00007E3A 2020706172616D6574-     	db '  parameters   Specifies any command-line information required by the',0Dh,0Ah
 36523 00007E43 657273202020537065-
 36523 00007E4C 63696669657320616E-
 36523 00007E55 7920636F6D6D616E64-
 36523 00007E5E 2D6C696E6520696E66-
 36523 00007E67 6F726D6174696F6E20-
 36523 00007E70 726571756972656420-
 36523 00007E79 6279207468650D0A   
 36524 00007E81 202020202020202020-     	db '               program you want to load.',0Dh,0Ah
 36524 00007E8A 20202020202070726F-
 36524 00007E93 6772616D20796F7520-
 36524 00007E9C 77616E7420746F206C-
 36524 00007EA5 6F61642E0D0A       
 36525                                  
 36526                                  ; ---------------------------------------------------------------------------
 36527                                  
 36528                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36529                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8183h
 36530                                  
 36531                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36532                                  
 36533                                  $M_CLS_3:
 36534 00007EAB 0E                      	push	cs		; CLASS_F
 36535 00007EAC 07                      	pop	es
 36536 00007EAD 8D3E[6C57]              	lea	di,$M_CLASS_3_STRUC ; LEA DI,$M_CLASS_3_STRUC
 36537                                  	; 15/04/2023
 36538                                  	;add	cx,10053	; ADD CX,$-$M_CLASS_3_STRUC ; 8189h-5A44h
 36539 00007EB1 C3                      	retn
 36540                                  
 36541                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36542                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:818Eh
 36543                                  
 36544                                  ; ---------------------------------------------------------------------------
 36545                                  ; Class 1 messages
 36546                                  ; ---------------------------------------------------------------------------
 36547                                  	
 36548                                  $M_CLASS_1_STRUC:
 36549 00007EB2 01                      	db 1			; $M_CLASS_ID
 36550 00007EB3 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36551 00007EB5 04                      	db 4			; Class_1_MessageCount
 36552                                  $M_ID_1_1:
 36553 00007EB6 0200                    	dw 2			; Message Number = 2
 36554 00007EB8 1000                    	dw EXTEND2-$+2 ; 10h	; Message offset from message number
 36555                                  $M_ID_1_2:
 36556 00007EBA 0300                    	dw 3			; Message Number = 3
 36557 00007EBC 1B00                    	dw EXTEND3-$+2 ; 1Bh	; Message offset from message number
 36558                                  $M_ID_1_3:
 36559 00007EBE 0800                    	dw 8			; Message Number = 8
 36560 00007EC0 2600                    	dw EXTEND8-$+2 ; 26h	; Message offset from message number
 36561                                  $M_ID_1_4:
 36562 00007EC2 FFFF                    	dw 0FFFFh		; Message Number = -1
 36563 00007EC4 3600                    	dw EXTEND999-$+2 ; 36h	; Message offset from message number
 36564                                  
 36565                                  ; ---------------------------------------------------------------------------
 36566                                  
 36567                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81A2h
 36568                                  EXTEND2:
 36569 00007EC6 0E                      	db 14
 36570 00007EC7 46696C65206E6F7420-     	db 'File not found'
 36570 00007ED0 666F756E64         
 36571                                  EXTEND3:
 36572 00007ED5 0E                      	db 14
 36573 00007ED6 50617468206E6F7420-     	db 'Path not found'
 36573 00007EDF 666F756E64         
 36574                                  EXTEND8:
 36575 00007EE4 13                      	db 19
 36576 00007EE5 496E73756666696369-     	db 'Insufficient memory'
 36576 00007EEE 656E74206D656D6F72-
 36576 00007EF7 79                 
 36577                                  EXTEND999:
 36578 00007EF8 11                      	db 17
 36579 00007EF9 457874656E64656420-     	db 'Extended Error %1'
 36579 00007F02 4572726F72202531   
 36580                                  
 36581                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36582                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81E6h
 36583                                  
 36584                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36585                                  $M_MSGSERV_1:
 36586 00007F0A 0E                      	push	cs
 36587 00007F0B 07                      	pop	es
 36588 00007F0C 8D3E[B27E]              	lea	di,$M_CLASS_1_STRUC
 36589                                  	; 15/04/2023
 36590                                  	;add	cx,94		; $-$M_CLASS_1_STRUC ; 81ECh-818Eh
 36591 00007F10 C3                      	retn
 36592                                  
 36593                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36594                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F0h
 36595                                  
 36596                                  ; ---------------------------------------------------------------------------
 36597                                  ; Class 2 messages
 36598                                  ; ---------------------------------------------------------------------------
 36599                                  	
 36600                                  $M_CLASS_2_STRUC:
 36601 00007F11 02                      	db 2			; $M_CLASS_ID
 36602 00007F12 0500                    	dw 5			; EXPECTED_VERSION (COMMAND.COM version)
 36603 00007F14 01                      	db 1			; Class_2_MessageCount
 36604                                  $M_ID_2_1:
 36605 00007F15 FFFF                    	dw 0FFFFh		; Message Number = -1
 36606 00007F17 0400                    	dw PARSE999-$+2 ; 4	; Message offset from message number
 36607                                  ; ---------------------------------------------------------------------------
 36608                                  
 36609                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:81F8h
 36610                                  PARSE999:
 36611 00007F19 0E                      	db 14
 36612 00007F1A 506172736520457272-     	db 'Parse Error %1'
 36612 00007F23 6F72202531         
 36613                                  
 36614                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36615                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8207h
 36616                                  
 36617                                  ; --------------- S U B R O U T I N E ---------------------------------------
 36618                                  $M_MSGSERV_2:
 36619 00007F28 0E                      	push	cs
 36620 00007F29 07                      	pop	es
 36621 00007F2A 8D3E[117F]              	lea	di,$M_CLASS_2_STRUC
 36622                                  	; 15/04/2023
 36623                                  	;add	cx,29	; $-$M_CLASS_2_STRUC ; 820Dh-81F0h
 36624 00007F2E C3                      	retn
 36625                                  
 36626                                  ;============================================================================
 36627                                  ; TRANMSG.ASM, MSDOS 6.0, 1991
 36628                                  ;============================================================================
 36629                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 36630                                  
 36631                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8211h
 36632                                  
 36633                                  ;****************************************************
 36634                                  ;* TRANSIENT MESSAGE POINTERS & SUBSTITUTION BLOCKS *
 36635                                  ;****************************************************
 36636                                  
 36637                                  msg_disp_class:
 36638 00007F2F FF                      	db	util_msg_class ; 0FFh
 36639                                  msg_cont_flag:
 36640 00007F30 00                      	db	no_cont_flag ; 0
 36641                                  
 36642                                  ;  extended error string output
 36643                                  extend_buf_ptr:
 36644 00007F31 0000                    	dw	0			;AN000;set to no message
 36645                                  extend_buf_sub:
 36646 00007F33 00                      	db	0			;AN000;set to no substitutions
 36647 00007F34 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36648 00007F35 00                      	db	0			;AN000;reserved
 36649                                  extend_buf_off:
 36650 00007F36 [8C8C]                  	dw	string_ptr_2		;AN000;offset of arg
 36651                                  extend_buf_seg:
 36652 00007F38 0000                    	dw	0			;AN000;segment of arg
 36653 00007F3A 00                      	db	0			;AN000;first subst
 36654 00007F3B 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36655 00007F3C 80                      	db	128			;AN000;maximum width
 36656 00007F3D 00                      	db	0			;AN000;minimum width
 36657 00007F3E 20                      	db	blank ; 20h		;AN000;pad character
 36658                                  
 36659                                  ;  "Duplicate file name or file not found"
 36660                                  RENERR_PTR:
 36661 00007F3F EA03                    	dw	1002			;AN000;message number
 36662 00007F41 00                      	db	no_subst ; 0		;AN000;number of subst
 36663                                  
 36664                                  ;  "Invalid path or file name"
 36665                                  BADCPMES_PTR:
 36666 00007F42 EB03                    	dw	1003			;AN000;message number
 36667 00007F44 00                      	db	no_subst ; 0		;AN000;number of subst
 36668                                  
 36669                                  ;  "Insufficient disk space"
 36670                                  NOSPACE_PTR:
 36671 00007F45 EC03                    	dw	1004			;AN000;message number
 36672 00007F47 00                      	db	no_subst ; 0		;AN000;number of subst
 36673                                  
 36674                                  ;  "Out of environment space"
 36675                                  ENVERR_PTR:
 36676 00007F48 EF03                    	dw	1007			;AN000;message number
 36677 00007F4A 00                      	db	no_subst ; 0		;AN000;number of subst
 36678                                  
 36679                                  ;  "File creation error"
 36680                                  FULLDIR_PTR:
 36681 00007F4B F003                    	dw	1008			;AN000;message number
 36682 00007F4D 00                      	db	no_subst ; 0		;AN000;number of subst
 36683                                  
 36684                                  ;  "Batch file missing",13,10
 36685                                  BADBAT_PTR:
 36686 00007F4E F103                    	dw	1009			;AN000;message number
 36687 00007F50 00                      	db	no_subst ; 0		;AN000;number of subst
 36688                                  
 36689                                  ;  "Insert disk with batch file",13,10
 36690                                  NEEDBAT_PTR:
 36691 00007F51 F203                    	dw	1010			;AN000;message number
 36692 00007F53 00                      	db	no_subst ; 0		;AN000;number of subst
 36693                                  
 36694                                  ;  "Bad command or file name",13,10
 36695                                  BADNAM_PTR:
 36696 00007F54 F303                    	dw	1011			;AN000;message number
 36697 00007F56 00                      	db	no_subst ; 0		;AN000;number of subst
 36698                                  
 36699                                  ;  "Access denied",13,10
 36700                                  ACCDEN_PTR:
 36701 00007F57 F603                    	dw	1014			;AN000;message number
 36702 00007F59 00                      	db	no_subst ; 0		;AN000;number of subst
 36703                                  
 36704                                  ;  "File cannot be copied onto itself",13,10
 36705                                  OVERWR_PTR:
 36706 00007F5A F703                    	dw	1015			;AN000;message number
 36707 00007F5C 00                      	db	no_subst ; 0		;AN000;number of subst
 36708                                  
 36709                                  ;  "Content of destination lost before copy",13,10
 36710                                  LOSTERR_PTR:
 36711 00007F5D F803                    	dw	1016			;AN000;message number
 36712 00007F5F 00                      	db	no_subst ; 0		;AN000;number of subst
 36713                                  
 36714                                  ;  "Invalid filename or file not found",13,10
 36715                                  INORNOT_PTR:
 36716 00007F60 F903                    	dw	1017			;AN000;message number
 36717 00007F62 00                      	db	no_subst		;AN000;number of subst
 36718                                  
 36719                                  ;  "%1 File(s) copied",13,10
 36720                                  copied_ptr:
 36721 00007F63 FA03                    	dw	1018			;AN000;message number
 36722 00007F65 01                      	db	1			;AN000;number of subst
 36723 00007F66 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36724 00007F67 00                      	db	0			;AN000;reserved
 36725 00007F68 [8E8C]                  	dw	Copy_num		;AN000;offset of arg
 36726 00007F6A 0000                    	dw	0			;AN000;segment of arg
 36727 00007F6C 01                      	db	1			;AN000;first subst
 36728 00007F6D A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36729                                  					;AN000;binary to decimal
 36730 00007F6E 09                      	db	9			;AN000;maximum width
 36731 00007F6F 09                      	db	9			;AN000;minimum width
 36732 00007F70 20                      	db	blank ; 20h		;AN000;pad character
 36733                                  
 36734                                  ;  "%1 File(s) "
 36735                                  dirmes_ptr:
 36736 00007F71 FB03                    	dw	1019			;AN000;message number
 36737 00007F73 01                      	db	1			;AN000;number of subst
 36738 00007F74 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36739 00007F75 00                      	db	0			;AN000;reserved
 36740 00007F76 [918C]                  	dw	Dir_Num			;AN000;offset of arg
 36741 00007F78 0000                    	dw	0			;AN000;segment of arg
 36742 00007F7A 01                      	db	1			;AN000;first subst
 36743 00007F7B A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36744                                  					;AN000;binary to decimal
 36745 00007F7C 09                      	db	9			;AN000;maximum width
 36746 00007F7D 09                      	db	9			;AN000;minimum width
 36747 00007F7E 20                      	db	blank ; 20h		;AN000;pad character
 36748                                  
 36749                                  ;  "%1 bytes free",13,10
 36750                                  bytmes_ptr:
 36751 00007F7F FC03                    	dw	1020			;AN000;message number
 36752 00007F81 01                      	db	1			;AN000;number of subst
 36753 00007F82 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36754 00007F83 00                      	db	0			;AN000;reserved
 36755 00007F84 [938C]                  	dw	Bytes_Free		;AN000;offset of arg
 36756 00007F86 0000                    	dw	0			;AN000;segment of arg
 36757 00007F88 01                      	db	1			;AN000;first subst
 36758 00007F89 B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 36759                                  					;AN000;long binary to decimal
 36760 00007F8A 1C                      	db	28			;AN000;maximum width
 36761 00007F8B 1C                      	db	28			;AN000;minimum width
 36762 00007F8C 20                      	db	blank ; 20h		;AN000;pad character
 36763                                  
 36764                                  ;  "Invalid drive specification",13,10
 36765                                  baddrv_ptr:
 36766 00007F8D FD03                    	dw	1021			;AN000;message number
 36767 00007F8F 00                      	db	no_subst ; 0		;AN000;number of subst
 36768                                  
 36769                                  ;  "Code page %1 not prepared for system",13,10
 36770                                  cp_not_set_ptr:
 36771 00007F90 FE03                    	dw	1022			;AN000;message number
 36772 00007F92 01                      	db	1			;AN000;number of subst
 36773 00007F93 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36774 00007F94 00                      	db	0			;AN000;reserved
 36775 00007F95 [068C]                  	dw	system_cpage		;AN000;offset of arg
 36776 00007F97 0000                    	dw	0			;AN000;segment of arg
 36777 00007F99 01                      	db	1			;AN000;first subst
 36778 00007F9A A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36779                                  					;AN000;binary to decimal
 36780 00007F9B 05                      	db	5			;AN000;maximum width
 36781 00007F9C 01                      	db	1			;AN000;minimum width
 36782 00007F9D 20                      	db	blank ; 20h		;AN000;pad character
 36783                                  
 36784                                  ;  "Code page %1 not prepared for all devices",13,10
 36785                                  cp_not_all_ptr:
 36786 00007F9E FF03                    	dw	1023			;AN000;message number
 36787 00007FA0 01                      	db	1			;AN000;number of subst
 36788 00007FA1 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 36789 00007FA2 00                      	db	0			;AN000;reserved
 36790 00007FA3 [068C]                  	dw	system_cpage		;AN000;offset of arg
 36791 00007FA5 0000                    	dw	0			;AN000;segment of arg
 36792 00007FA7 01                      	db	1			;AN000;first subst
 36793 00007FA8 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36794                                  					;AN000;binary to decimal
 36795 00007FA9 05                      	db	5			;AN000;maximum width
 36796 00007FAA 01                      	db	1			;AN000;minimum width
 36797 00007FAB 20                      	db	blank ; 20h		;AN000;pad character
 36798                                  
 36799                                  ;  "Active code page: %1",13,10
 36800                                  cp_active_ptr:
 36801 00007FAC 0004                    	dw	1024			;AN000;message number
 36802 00007FAE 01                      	db	1			;AN000;number of subst
 36803 00007FAF 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36804 00007FB0 00                      	db	0			;AN000;reserved
 36805 00007FB1 [068C]                  	dw	system_cpage		;AN000;offset of arg
 36806 00007FB3 0000                    	dw	0			;AN000;segment of arg
 36807 00007FB5 01                      	db	1			;AN000;first subst
 36808 00007FB6 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36809                                  					;AN000;binary to decimal
 36810 00007FB7 05                      	db	5			;AN000;maximum width
 36811 00007FB8 01                      	db	1			;AN000;minimum width
 36812 00007FB9 20                      	db	blank ; 20h		;AN000;pad character
 36813                                  
 36814                                  ;  "NLSFUNC not installed",13,10
 36815                                  NLSFUNC_PTR:
 36816 00007FBA 0104                    	dw	1025			;AN000;message number
 36817 00007FBC 00                      	db	no_subst ; 0		;AN000;number of subst
 36818                                  
 36819                                  ;  "Invalid code page",13,10
 36820                                  INV_CODE_PAGE:
 36821 00007FBD 0204                    	dw	1026			;AN000;message number
 36822 00007FBF 00                      	db	no_subst ; 0		;AN000;number of subst
 36823                                  
 36824                                  ;  "Current drive is no longer valid"
 36825                                  BADCURDRV:
 36826 00007FC0 0304                    	dw	1027			;AN000;message number
 36827 00007FC2 00                      	db	no_subst ; 0		;AN000;number of subst
 36828                                  
 36829                                  ;  "Press any key to continue"
 36830                                  PAUSEMES_PTR:
 36831 00007FC3 0404                    	dw	1028			;AN000;message number
 36832 00007FC5 00                      	db	no_subst ; 0		;AN000;number of subst
 36833                                  
 36834                                  ;  "Label not found",13,10
 36835                                  BADLAB_PTR:
 36836 00007FC6 0504                    	dw	1029			;AN000;message number
 36837 00007FC8 00                      	db	no_subst ; 0		;AN000;number of subst
 36838                                  
 36839                                  ;  "Syntax error",13,10
 36840                                  SYNTMES_PTR:
 36841 00007FC9 0604                    	dw	1030			;AN000;message number
 36842 00007FCB 00                      	db	no_subst ; 0		;AN000;number of subst
 36843                                  
 36844                                  ;  "Invalid date",13,10
 36845                                  BADDAT_PTR:
 36846 00007FCC 0704                    	dw	1031			;AN000;message number
 36847 00007FCE 00                      	db	no_subst ; 0		;AN000;number of subst
 36848                                  
 36849                                  ;  "Current date is %1 %2",13,10
 36850                                  CurDat_Ptr:
 36851 00007FCF 0804                    	dw	1032			;AN000;message number
 36852 00007FD1 02                      	db	2			;AN000;number of subst
 36853 00007FD2 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36854 00007FD3 00                      	db	0			;AN000;reserved
 36855 00007FD4 [088C]                  	dw	Arg_Buf			;AN000;offset of arg
 36856 00007FD6 0000                    	dw	0			;AN000;segment of arg
 36857 00007FD8 01                      	db	1			;AN000;first subst
 36858 00007FD9 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36859 00007FDA 03                      	db	3			;AN000;maximum width
 36860 00007FDB 03                      	db	3			;AN000;minimum width
 36861 00007FDC 20                       	db	blank ; 20h		;AN000;pad character
 36862 00007FDD 0B                      	db	parm_block_size 	;AN000;size of sublist
 36863 00007FDE 00                      	db	0			;AN000;reserved
 36864                                  CurDat_yr:
 36865 00007FDF 0000                    	dw	0			;AN000;year
 36866                                  CurDat_mo_day:
 36867 00007FE1 0000                    	dw	0			;AN000;month,day
 36868 00007FE3 02                      	db	2			;AN000;second subst
 36869 00007FE4 34                      	db	34h ; DATE_MDY_4	;AN000;date
 36870 00007FE5 0A                      	db	10			;AN000;maximum width
 36871 00007FE6 0A                      	db	10			;AN000;minimum width
 36872 00007FE7 20                      	db	blank ; 20h		;AN000;pad character
 36873                                  
 36874                                  ;  "SunMonTueWedThuFriSat"
 36875                                  WeekTab:
 36876 00007FE8 0904                    	dw	1033			;AN000;message number
 36877 00007FEA 00                      	db	no_subst ; 0		;AN000;number of subst
 36878                                  
 36879                                  ;  "Enter new date (%1):"
 36880                                  
 36881                                  NewDat_Ptr:
 36882 00007FEB 0A04                    	dw	1034			;AN000;message number
 36883 00007FED 01                      	db	1			;AN000;number of subst
 36884 00007FEE 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36885 00007FEF 00                      	db	0			;AN000;reserved
 36886                                  NewDat_Format:
 36887 00007FF0 0000                    	dw	0			;AN000;offset of replacement
 36888 00007FF2 0000                    	dw	0			;AN000;segment of arg
 36889 00007FF4 01                      	db	1			;AN000;first subst
 36890 00007FF5 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36891 00007FF6 08                      	db	8			;AN000;maximum width
 36892 00007FF7 08                      	db	8			;AN000;minimum width
 36893 00007FF8 20                      	db	blank ; 20h		;AN000;pad character
 36894                                  
 36895                                  ;  "Invalid time",13,10
 36896                                  
 36897                                  BadTim_Ptr:
 36898 00007FF9 0B04                    	dw	1035			;AN000;message number
 36899 00007FFB 00                      	db	no_subst ; 0		;AN000;number of subst
 36900                                  
 36901                                  ;  "Current time is %1",13,10
 36902                                  CurTim_Ptr:
 36903 00007FFC 0C04                    	dw	1036			;AN000;message number
 36904 00007FFE 01                      	db	1			;AN000;number of subst
 36905 00007FFF 0B                      	db	parm_block_size 	;AN000;size of sublist
 36906 00008000 00                      	db	0			;AN000;reserved
 36907                                  CurTim_hr_min:
 36908 00008001 0000                    	dw	0			;AN000;hours,minutes
 36909                                  CurTim_Sec_hn:
 36910 00008003 0000                    	dw	0			;AN000;seconds,hundredths
 36911 00008005 01                      	db	1			;AN000;first subst
 36912 00008006 A5                      	db	0A5h ; Right_Align+TIME_HHMMSSHH_Cty
 36913                                  					;AC059;time
 36914 00008007 0C                      	db	12			;AC059;maximum width
 36915 00008008 0C                      	db	12			;AC059;minimum width
 36916 00008009 20                      	db	blank ; 20h		;AN000;pad character
 36917                                  
 36918                                  ;  "Enter new time:"
 36919                                  NewTim_Ptr:
 36920 0000800A 0D04                    	dw	1037			;AN000;message number
 36921 0000800C 00                      	db	no_subst ; 0		;AN000;number of subst
 36922                                  
 36923                                  ;  ",    Delete (Y/N)?",13,10
 36924                                  Del_Y_N_Ptr:
 36925 0000800D 0E04                    	dw	1038			;AN000;message number
 36926 0000800F 00                      	db	no_subst ; 0		;AN000;number of subst
 36927                                  
 36928                                  ;  "All files in directory will be deleted!",13,10
 36929                                  ;  "Are you sure (Y/N)?",13,10
 36930                                  SureMes_Ptr:
 36931 00008010 0F04                    	dw	1039			;AN000;message number
 36932 00008012 00                      	db	no_subst ; 0		;AN000;number of subst
 36933                                  
 36934                                  ;  "Microsoft DOS Version %1.%2",13,10
 36935                                  VerMes_Ptr:
 36936 00008013 1004                    	dw	1040			;AN000;message number
 36937 00008015 02                      	db	2			;AN000;number of subst
 36938 00008016 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 36939 00008017 00                      	db	0			;AN000;reserved
 36940 00008018 [978C]                  	dw	Major_Ver_Num		;AN000;offset of arg
 36941 0000801A 0000                    	dw	0			;AN000;segment of arg
 36942 0000801C 01                      	db	1			;AN000;first subst
 36943 0000801D A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36944                                  					;AN000;binary to decimal
 36945 0000801E 01                      	db	1			;AN000;maximum width
 36946 0000801F 01                      	db	1			;AN000;minimum width
 36947 00008020 20                      	db	blank ; 20h		;AN000;pad character
 36948 00008021 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36949 00008022 00                      	db	0			;AN000;reserved
 36950 00008023 [998C]                  	dw	Minor_Ver_Num	;AN000;offset of arg
 36951 00008025 0000                    	dw	0			;AN000;segment of arg
 36952 00008027 02                      	db	2			;AN000;second subst
 36953 00008028 A1                      	db	0A1h ; Right_Align+Unsgn_Bin_Word
 36954                                  					;AN000;binary to decimal
 36955 00008029 02                      	db	2			;AN000;maximum width
 36956 0000802A 02                      	db	2			;AN000;minimum width
 36957 0000802B 30                      	db	'0' ; 30h		;AN000;pad character
 36958                                  
 36959                                  ;  "Volume in drive %1 has no label",13,10
 36960                                  VolMes_Ptr_2:
 36961 0000802C 1104                    	dw	1041			;AN000;message number
 36962 0000802E 01                      	db	1			;AN000;number of subst
 36963 0000802F 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 36964 00008030 00                      	db	0			;AN000;reserved
 36965 00008031 [9D8C]                  	dw	vol_drv			;AN000;offset of drive
 36966 00008033 0000                    	dw	0			;AN000;segment of arg
 36967 00008035 01                      	db	1			;AN000;first subst
 36968 00008036 00                      	db	0 ; Char_field_Char 	;AN000;character
 36969 00008037 80                      	db	128			;AN000;maximum width
 36970 00008038 01                      	db	1			;AN000;minimum width
 36971 00008039 20                      	db	blank ; 20h		;AN000;pad character
 36972                                  
 36973                                  ;  "Volume in drive %1 is %2",13,10
 36974                                  VolMes_Ptr:
 36975 0000803A 1204                    	dw	1042			;AN000;message number
 36976 0000803C 02                      	db	2			;AN000;number of subst
 36977 0000803D 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36978 0000803E 00                      	db	0			;AN000;reserved
 36979 0000803F [9D8C]                  	dw	vol_drv			;AN000;offset of drive
 36980 00008041 0000                    	dw	0			;AN000;segment of arg
 36981 00008043 01                      	db	1			;AN000;first subst
 36982 00008044 00                      	db	00000000b		;AN000;character
 36983 00008045 80                      	db	128			;AN000;maximum width
 36984 00008046 01                      	db	1			;AN000;minimum width
 36985 00008047 20                      	db	blank ; 20h		;AN000;pad character
 36986 00008048 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 36987 00008049 00                      	db	0			;AN000;reserved
 36988 0000804A [D68A]                  	dw	CHARBUF			;AN000;offset of string
 36989 0000804C 0000                    	dw	0			;AN000;segment of arg
 36990 0000804E 02                      	db	2			;AN000;second subst
 36991 0000804F 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 36992 00008050 80                      	db	128			;AN000;maximum width
 36993 00008051 01                      	db	1			;AN000;minimum width
 36994 00008052 20                      	db	blank ; 20h		;AN000;pad character
 36995                                  
 36996                                  ;  "Volume Serial Number is %1-%2",13,10
 36997                                  VolSerMes_Ptr:
 36998 00008053 1304                    	dw	1043			;AN000;message number
 36999 00008055 02                      	db	2			;AN000;number of subst
 37000 00008056 0B                      	db	parm_block_size ; 11  	;AN000;size of sublist
 37001 00008057 00                      	db	0			;AN000;reserved
 37002 00008058 [F88D]                  	dw	vol_serial+2		;AN000;offset of serial
 37003 0000805A 0000                    	dw	0			;AN000;segment of arg
 37004 0000805C 01                      	db	1			;AN000;first subst
 37005 0000805D A3                      	db	0A3h ; Right_Align+Bin_Hex_Word 
 37006                                  					;AN000;binary to hex
 37007 0000805E 04                      	db	4			;AN000;maximum width
 37008 0000805F 04                      	db	4			;AN000;minimum width
 37009 00008060 30                      	db	'0' ; 30h		;AN000;pad character
 37010 00008061 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37011 00008062 00                      	db	0			;AN000;reserved
 37012 00008063 [F68D]                  	dw	vol_serial		;AN000;offset of serial
 37013 00008065 0000                    	dw	0			;AN000;segment of arg
 37014 00008067 02                      	db	2			;AN000;second subst
 37015 00008068 A3                      	db	0A3h ; Right_Align+Bin_Hex_Word
 37016                                  					;AN000;binary to hex
 37017 00008069 04                      	db	4			;AN000;maximum width
 37018 0000806A 04                      	db	4			;AN000;minimum width
 37019 0000806B 30                      	db	'0' ; 30h		;AN000;pad character
 37020                                  
 37021                                  ;  "Invalid directory",13,10
 37022                                  badcd_ptr:
 37023 0000806C 1404                    	dw	1044			;AN000;message number
 37024 0000806E 00                      	db	no_subst ; 0		;AN000;number of subst
 37025                                  
 37026                                  ;  "Unable to create directory",13,10
 37027                                  badmkd_ptr:
 37028 0000806F 1504                    	dw	1045			;AN000;message number
 37029 00008071 00                      	db	no_subst ; 0		;AN000;number of subst
 37030                                  
 37031                                  ;  "Invalid path, not directory,",13,10
 37032                                  ;  "or directory not empty",13,10
 37033                                  badrmd_ptr:
 37034 00008072 1604                    	dw	1046			;AN000;message number
 37035 00008074 00                      	db	no_subst ; 0		;AN000;number of subst
 37036                                  
 37037                                  ;  "Must specify ON or OFF",13,10
 37038                                  bad_on_off_ptr:
 37039 00008075 1704                    	dw	1047			;AN000;message number
 37040 00008077 00                      	db	no_subst ; 0		;AN000;number of subst
 37041                                  
 37042                                  ;  "Directory of %1",13,10
 37043                                  dirhead_ptr:
 37044 00008078 1804                    	dw	1048			;AN000;message number
 37045 0000807A 01                      	db	1			;AN000;number of subst
 37046 0000807B 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37047 0000807C 00                      	db	0			;AN000;reserved
 37048 0000807D [A58B]                  	dw	BWDBUF			;AN000;offset of arg
 37049 0000807F 0000                    	dw	0			;AN000;segment of arg
 37050 00008081 01                      	db	1			;AN000;first subst
 37051 00008082 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37052 00008083 80                      	db	128			;AN000;maximum width
 37053 00008084 00                      	db	0			;AN000;minimum width
 37054 00008085 20                      	db	blank ; 20h		;AN000;pad character
 37055                                  
 37056                                  ;  "No Path",13,10
 37057                                  NULLPATH_PTR:
 37058 00008086 1904                    	dw	1049			;AN000;message number
 37059 00008088 00                      	db	no_subst ; 0		;AN000;number of subst
 37060                                  
 37061                                  ;  "Invalid drive in search path",13,10
 37062                                  BADPMES_PTR:
 37063 00008089 1A04                    	dw	1050			;AN000;message number
 37064 0000808B 00                      	db	no_subst ; 0		;AN000;number of subst
 37065                                  
 37066                                  ;  "Invalid device",13,10
 37067                                  BADDEV_PTR:
 37068 0000808C 1B04                    	dw	1051			;AN000;message number
 37069 0000808E 00                      	db	no_subst ; 0		;AN000;number of subst
 37070                                  
 37071                                  ;  "FOR cannot be nested",13,10
 37072                                  FORNESTMES_PTR:
 37073 0000808F 1C04                    	dw	1052			;AN000;message number
 37074 00008091 00                      	db	no_subst ; 0		;AN000;number of subst
 37075                                  
 37076                                  ;  "Intermediate file error during pipe",13,10
 37077                                  PIPEEMES_PTR:
 37078 00008092 1D04                    	dw	1053			;AN000;message number
 37079 00008094 00                      	db	no_subst ; 0		;AN000;number of subst
 37080                                  
 37081                                  ;  "Cannot do binary reads from a device",13,10
 37082                                  INBDEV_PTR:
 37083 00008095 1E04                    	dw	1054			;AN000;message number
 37084 00008097 00                      	db	no_subst ; 0		;AN000;number of subst
 37085                                  
 37086                                  ;  "BREAK is %1",13,10
 37087                                  CtrlcMes_Ptr:
 37088 00008098 1F04                    	dw	1055			;AN000;message number
 37089 0000809A 01                      	db	1			;AN000;number of subst
 37090 0000809B 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37091 0000809C 00                      	db	0			;AN000;reserved
 37092 0000809D 0000                    	dw	0			;AN000;offset of on/off (new)
 37093 0000809F 0000                    	dw	0			;AN000;segment of arg
 37094 000080A1 01                      	db	1			;AN000;first subst
 37095 000080A2 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37096 000080A3 80                      	db	128			;AN000;maximum width
 37097 000080A4 01                      	db	1			;AN000;minimum width
 37098 000080A5 20                      	db	blank ; 20h		;AN000;pad character
 37099                                  
 37100                                  ;  "VERIFY is %1",13,10
 37101                                  VeriMes_Ptr:
 37102 000080A6 2004                    	dw	1056			;AN000;message number
 37103 000080A8 01                      	db	1			;AN000;number of subst
 37104 000080A9 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37105 000080AA 00                      	db	0			;AN000;reserved
 37106 000080AB 0000                    	dw	0			;AN000;offset of on/off (new)
 37107 000080AD 0000                    	dw	0			;AN000;segment of arg
 37108 000080AF 01                      	db	1			;AN000;first subst
 37109 000080B0 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37110 000080B1 80                      	db	128			;AN000;maximum width
 37111 000080B2 01                      	db	1			;AN000;minimum width
 37112 000080B3 20                      	db	blank ; 20h		;AN000;pad character
 37113                                  
 37114                                  ;  "ECHO is %1",13,10
 37115                                  EchoMes_Ptr:
 37116 000080B4 2104                    	dw	1057			;AN000;message number
 37117 000080B6 01                      	db	1			;AN000;number of subst
 37118 000080B7 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37119 000080B8 00                      	db	0			;AN000;reserved
 37120 000080B9 0000                    	dw	0			;AN000;offset of on/off (new)
 37121 000080BB 0000                    	dw	0			;AN000;segment of arg
 37122 000080BD 01                      	db	1			;AN000;first subst
 37123 000080BE 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37124 000080BF 80                      	db	128			;AN000;maximum width
 37125 000080C0 01                      	db	1			;AN000;minimum width
 37126 000080C1 20                      	db	blank ; 20h		;AN000;pad character
 37127                                  
 37128                                  ;  "off"
 37129                                  OFFMES_PTR:
 37130 000080C2 2304                    	dw	1059			;AN000;message number
 37131 000080C4 00                      	db	no_subst		;AN000;number of subst
 37132                                  
 37133                                  ;  "on"
 37134                                  ONMES_PTR:
 37135 000080C5 2404                    	dw	1060			;AN000;message number
 37136 000080C7 00                      	db	no_subst ; 0		;AN000;number of subst
 37137                                  
 37138                                  ;  "Error writing to device",13,10
 37139                                  DEVWMES_PTR:
 37140 000080C8 2504                    	dw	1061			;AN000;message number
 37141 000080CA 00                      	db	no_subst ; 0		;AN000;number of subst
 37142                                  
 37143                                  ;  "Invalid path",13,10
 37144                                  INVAL_PATH_PTR:
 37145 000080CB 2604                    	dw	1062			;AN000;message number
 37146 000080CD 00                      	db	no_subst ; 0		;AN000;number of subst
 37147                                  
 37148                                  ;  unformatted string output
 37149                                  arg_buf_ptr:
 37150 000080CE 2704                    	dw	1063			;AN000;message number
 37151 000080D0 01                      	db	1			;AN000;number of subst
 37152 000080D1 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37153 000080D2 00                      	db	0			;AN000;reserved
 37154 000080D3 [088C]                  	dw	Arg_Buf 		;AN000;offset of arg
 37155 000080D5 0000                    	dw	0			;AN000;segment of arg
 37156 000080D7 01                      	db	1			;AN000;first subst
 37157 000080D8 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37158 000080D9 80                      	db	128			;AN000;maximum width
 37159 000080DA 00                      	db	0			;AN000;minimum width
 37160 000080DB 20                      	db	blank ; 20h		;AN000;pad character
 37161                                  
 37162                                  ;  file name output
 37163                                  file_name_ptr:
 37164 000080DC 2804                    	dw	1064			;AN000;message number
 37165 000080DE 01                      	db	1			;AN000;number of subst
 37166 000080DF 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37167 000080E0 00                      	db	0			;AN000;reserved
 37168 000080E1 [0B8D]                  	dw	SrcBuf			;AN000;offset of arg
 37169 000080E3 0000                    	dw	0			;AN000;segment of arg
 37170 000080E5 01                      	db	1			;AN000;first subst
 37171 000080E6 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37172 000080E7 80                      	db	128			;AN000;maximum width
 37173 000080E8 00                      	db	0			;AN000;minimum width
 37174 000080E9 20                      	db	blank ; 20h		;AN000;pad character
 37175                                  
 37176                                  ;  file size output for dir
 37177                                  disp_file_size_ptr:
 37178 000080EA 2904                    	dw	1065			;AN000;message number
 37179 000080EC 01                      	db	1			;AN000;number of subst
 37180 000080ED 0B                      	db	parm_block_size ; 11 	;AN000;size of sublist
 37181 000080EE 00                      	db	0			;AN000;reserved
 37182 000080EF [888C]                  	dw	File_Size_Low		;AN000;offset of arg
 37183 000080F1 0000                    	dw	0			;AN000;segment of arg
 37184 000080F3 01                      	db	1			;AN000;first subst
 37185 000080F4 B1                      	db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37186                                  					;AN000;long binary to decimal
 37187 000080F5 0A                      	db	10			;AN000;maximum width
 37188 000080F6 0A                      	db	10			;AN000;minimum width
 37189 000080F7 20                      	db	blank ; 20h		;AN000;pad character
 37190                                  
 37191                                  ;  unformatted string output
 37192                                  ; %s
 37193                                  string_buf_ptr:
 37194 000080F8 2A04                    	dw	1066			;AN000;message number
 37195 000080FA 01                      	db	1			;AN000;number of subst
 37196 000080FB 0B                      	db	parm_block_size 	;AN000;size of sublist
 37197 000080FC 00                      	db	0			;AN000;reserved
 37198 000080FD [8C8C]                  	dw	string_ptr_2		;AN000;offset of arg
 37199 000080FF 0000                    	dw	0			;AN000;segment of arg
 37200 00008101 01                      	db	1			;AN000;first subst
 37201 00008102 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37202 00008103 80                      	db	128			;AN000;maximum width
 37203 00008104 00                      	db	0			;AN000;minimum width
 37204 00008105 20                      	db	blank ; 20h		;AN000;pad character
 37205 00008106 00                      	db	0			;AN000;
 37206                                  
 37207                                  ;  tab character
 37208                                  tab_ptr:
 37209 00008107 2B04                    	dw	1067			;AN000;message number
 37210 00008109 00                      	db	no_subst ; 0		;AN000;number of subst
 37211                                  
 37212                                  ;  " <DIR>   "
 37213                                  dmes_ptr:
 37214 0000810A 2C04                    	dw	1068			;AN000;message number
 37215 0000810C 00                      	db	no_subst ; 0		;AN000;number of subst
 37216                                  
 37217                                  ;  destructive back space
 37218                                  dback_ptr:
 37219 0000810D 2D04                    	dw	1069			;AN000;message number
 37220 0000810F 00                      	db	no_subst ; 0		;AN000;number of subst
 37221                                  
 37222                                  ;  carriage return / line feed
 37223                                  acrlf_ptr:
 37224 00008110 2E04                    	dw	1070			;AN000;message number
 37225 00008112 00                      	db	no_subst ; 0		;AN000;number of subst
 37226                                  
 37227                                  ;  "mm-dd-yy"
 37228                                  usadat_ptr:
 37229 00008113 3004                    	dw	1072			;AN000;message number
 37230 00008115 00                      	db	no_subst ; 0		;AN000;number of subst
 37231                                  
 37232                                  ;  "dd-mm-yy"
 37233                                  eurdat_ptr:
 37234 00008116 3104                    	dw	1073			;AN000;message number
 37235 00008118 00                      	db	no_subst ; 0		;AN000;number of subst
 37236                                  
 37237                                  ;  "yy-mm-dd"
 37238                                  japdat_ptr:
 37239 00008119 3204                    	dw	1074			;AN000;message number
 37240 0000811B 00                      	db	no_subst ; 0		;AN000;number of subst
 37241                                  
 37242                                  ;  date string for prompt
 37243                                  promptdat_ptr:
 37244 0000811C 3304                    	dw	1075			;AN000;message number
 37245 0000811E 02                      	db	2			;AN000;number of subst
 37246 0000811F 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37247 00008120 00                      	db	0			;AN000;reserved
 37248 00008121 [088C]                  	dw	Arg_Buf			;AN000;offset of arg
 37249 00008123 0000                    	dw	0			;AN000;segment of arg
 37250 00008125 01                      	db	1			;AN000;first subst
 37251 00008126 10                      	db	10h ; Char_field_ASCIIZ ;AN000;character string
 37252 00008127 03                      	db	3			;AN000;maximum width
 37253 00008128 03                      	db	3			;AN000;minimum width
 37254 00008129 20                       	db	blank ; 20h		;AN000;pad character
 37255 0000812A 0B                      	db	parm_block_size  ; 11	;AN000;size of sublist
 37256 0000812B 00                      	db	0			;AN000;reserved
 37257                                  promptDat_yr:
 37258 0000812C 0000                    	dw	0			;AN000;year
 37259                                  promptDat_moday:
 37260 0000812E 0000                    	dw	0			;AN000;month,day
 37261 00008130 02                      	db	2			;AN000;second subst
 37262 00008131 34                       	db	34h ; DATE_MDY_4	;AN000;date
 37263 00008132 0A                      	db	10			;AN000;maximum width
 37264 00008133 08                      	db	8			;AN000;minimum width
 37265 00008134 20                      	db	blank ; 20h		;AN000;pad character
 37266                                  
 37267                                  ;  Time for prompt
 37268                                  promtim_ptr:
 37269 00008135 3404                    	dw	1076			;AN000;message number
 37270 00008137 01                      	db	1			;AN000;number of subst
 37271 00008138 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37272 00008139 00                      	db	0			;AN000;reserved
 37273                                  PromTim_hr_min:
 37274 0000813A 0000                    	dw	0			;AN000;hours,minutes
 37275                                  PromTim_Sec_hn:
 37276 0000813C 0000                    	dw	0			;AN000;seconds,hundredths
 37277 0000813E 01                      	db	1			;AN000;first subst
 37278 0000813F A6                      	db	0A6h ; Right_Align+TIME_HHMMSSHH_24
 37279                                  					;AC013;time
 37280 00008140 0B                      	db	11			;AN000;maximum width
 37281 00008141 0B                      	db	11			;AC013;minimum width
 37282 00008142 20                      	db	blank ; 20h		;AN000;pad character
 37283                                  
 37284                                  ;  Date and time for DIR
 37285                                  dirdattim_ptr:
 37286 00008143 3504                    	dw	1077			;AN000;message number
 37287 00008145 02                      	db	2			;AN000;number of subst
 37288 00008146 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37289 00008147 00                      	db	0			;AN000;reserved
 37290                                  DirDat_Yr:
 37291 00008148 0000                    	dw	0			;AN000;year
 37292                                  DirDat_Mo_Day:
 37293 0000814A 0000                    	dw	0			;AN000;month,day
 37294 0000814C 01                      	db	1			;AN000;first subst
 37295 0000814D A4                      	db	0A4h ; Right_Align+DATE_MDY_2
 37296                                  					;AN000;date
 37297 0000814E 0A                      	db	10			;AN000;maximum width
 37298 0000814F 08                      	db	8			;AN000;minimum width
 37299 00008150 20                      	db	blank ; 20h		;AN000;pad character
 37300 00008151 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37301 00008152 00                      	db	0			;AN000;reserved
 37302                                  DirTim_Hr_Min:
 37303 00008153 0000                    	dw	0			;AN000;hours,minutes
 37304                                  DirTim_Sec_hn:
 37305 00008155 0000                    	dw	0			;AN000;seconds,hundredths
 37306 00008157 02                      	db	2			;AN000;second subst
 37307 00008158 85                      	db	85h ; Right_align+TIME_HHMM_Cty
 37308                                  					;AN000;time
 37309 00008159 06                      	db	6			;AN000;maximum width
 37310 0000815A 06                      	db	6			;AN000;minimum width
 37311 0000815B 20                      	db	blank ; 20h		;AN000;pad character
 37312                                  
 37313                                  ;  "Directory already exists"
 37314                                  MD_EXISTS_PTR:
 37315 0000815C 3604                    	dw	1078			;AN000;message number
 37316 0000815E 00                      	db	no_subst		;AN000;number of subst
 37317                                  
 37318                                  ;  "%1 bytes",13,10
 37319                                  bytes_ptr:
 37320 0000815F 3704                    	dw	1079			; message number
 37321 00008161 01                      	db	1			; number of subst
 37322 00008162 0B                              db	parm_block_size ; 11	; size of sublist
 37323 00008163 00                              db	0			; reserved
 37324 00008164 [CA8A]                          dw	FileSiz			; offset of arg
 37325 00008166 0000                            dw	0			; segment of arg
 37326 00008168 01                              db	1			; first subst
 37327 00008169 B1                              db	0B1h ; Right_Align+Unsgn_Bin_DWord
 37328                                  					; long binary to decimal
 37329 0000816A 0A                              db	10			; maximum width
 37330 0000816B 0A                              db	10			; minimum width
 37331 0000816C 20                              db	blank ; 20h		; pad character
 37332                                  
 37333                                  ;  "Total:",13,10
 37334                                  total_ptr:
 37335 0000816D 3804                    	dw	1080			; message number
 37336 0000816F 00                      	db	no_subst ; 0		; number of subst
 37337                                  
 37338                                  ;  "Error parsing environment variable:",13,10
 37339                                  errparsenv_ptr:
 37340 00008170 3904                    	dw	1081			; message number
 37341 00008172 00                      	db	no_subst ; 0		; number of subst
 37342                                  
 37343                                  ;  "(continuing %1)",13,10
 37344                                  dircont_ptr:
 37345 00008173 3C04                    	dw	1084			;AN000;message number
 37346 00008175 01                      	db	1			;AN000;number of subst
 37347 00008176 0B                      	db	parm_block_size ; 11	;AN000;size of sublist
 37348 00008177 00                      	db	0			;AN000;reserved
 37349 00008178 [A58B]                  	dw	BWDBUF			;AN000;offset of arg
 37350 0000817A 0000                    	dw	0			;AN000;segment of arg
 37351 0000817C 01                      	db	1			;AN000;first subst
 37352 0000817D 10                      	db	10h ; Char_field_ASCIIZ	;AN000;character string
 37353 0000817E 80                      	db	128			;AN000;maximum width
 37354 0000817F 00                      	db	0			;AN000;minimum width
 37355 00008180 20                      	db	blank ; 20h		;AN000;pad character
 37356                                  
 37357                                  ;  "Revision %1",CR,LF
 37358                                  dosrev_ptr:
 37359 00008181 4204                    	dw	1090
 37360 00008183 01                      	db	1			; one substitution
 37361 00008184 0B                      	db	parm_block_size ; 11
 37362 00008185 00                      	db	0
 37363 00008186 [9B8C]                  	dw	One_Char_Val		; ptr to char
 37364 00008188 0000                    	dw	0			; segment addr?
 37365 0000818A 01                      	db	1			; 1st substitution
 37366 0000818B 00                      	db	0 ; CHAR_FIELD_CHAR	; character
 37367 0000818C 01                      	db	1			; max width
 37368 0000818D 01                      	db	1			; min width
 37369 0000818E 20                      	db	blank ; 20h		; pad char
 37370                                  
 37371                                  ;  "DOS is in ROM"
 37372                                  DosRom_Ptr:
 37373 0000818F 4304                    	dw	1091
 37374 00008191 00                      	db	no_subst ; 0		
 37375                                  
 37376                                  ;  "DOS is in HMA"
 37377                                  DosHma_Ptr:
 37378 00008192 4404                    	dw	1092
 37379 00008194 00                      	db	no_subst ; 0		
 37380                                  
 37381                                  ;  "DOS is in low memory"
 37382                                  DosLow_Ptr:
 37383 00008195 4504                    	dw	1093
 37384 00008197 00                      	db	no_subst ; 0		
 37385                                  
 37386                                  ;  "Cannot Loadhigh batch file" ;M016
 37387                                  NoExecBat_Ptr:
 37388 00008198 4604                    	dw	1094			; M016
 37389 0000819A 00                      	db	no_subst ; 0		; M016
 37390                                  
 37391                                  ;  "LoadHigh: Invalid filename" ; M016
 37392                                  LhInvFil_Ptr:
 37393 0000819B 4704                    	dw	1095			; M016
 37394 0000819D 00                      	db	no_subst ; 0		; M016
 37395                                  
 37396                                  ;  "Could not open specified country information file" ; M045
 37397                                  NoCntry_Ptr:
 37398 0000819E 4804                    	dw	1096			; M045
 37399 000081A0 00                      	db	no_subst ; 0		; M045
 37400                                  
 37401                                  ; 15/04/2023
 37402                                  ; MSDOS 6.0 COMMAND.COM only !
 37403                                  %if 0
 37404                                  
 37405                                  ;* The next four errors emulate those reported by the normal parse
 37406                                  ;  mechanism, with a little more accurate wording; that parser has been
 37407                                  ;  replaced with a custom routine (ParseVar) for LoadHigh and DeviceHigh.
 37408                                  ;  These errors aren't normally generated by LoadHigh except by the normal
 37409                                  ;  parser, so they've been added here.
 37410                                  
 37411                                  ;  "LoadHigh: Invalid argument"
 37412                                  LhInvArg_Ptr:
 37413                                  	dw	1097
 37414                                  	db	no_subst ; 0		
 37415                                  
 37416                                  ;  "Required parameter missing"
 37417                                  ReqParmMiss:
 37418                                  	dw	1098
 37419                                  	db	no_subst ; 0		
 37420                                  
 37421                                  ;  "Unrecognized switch"
 37422                                  LhInvSwt_Ptr:
 37423                                  	dw	1099
 37424                                  	db	no_subst ; 0		
 37425                                  
 37426                                  ;  "A bad UMB number has been specified"
 37427                                  LhBadUMB_Ptr:
 37428                                  	dw	1100
 37429                                  	db	no_subst ; 0
 37430                                  %endif		
 37431                                  
 37432                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37433                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8483h
 37434                                  ; ---------------------------------------------------------------------------
 37435                                  
 37436                                  PATH_TEXT:
 37437 000081A1 504154483D              	db	"PATH="
 37438                                  PROMPT_TEXT:
 37439 000081A6 50524F4D50543D          	db	"PROMPT="
 37440                                  COMSPECSTR:
 37441 000081AD 434F4D535045433D        	db	"COMSPEC="
 37442                                  DirEnvVar:
 37443 000081B5 444952434D443D          	db	"DIRCMD="		; DIR's environment variable
 37444                                  
 37445                                  ; 15/04/2023
 37446                                  %if 0
 37447                                  
 37448                                  ;============================================================================
 37449                                  ; TDATA.ASM, MSDOS 6.0, 1991
 37450                                  ;============================================================================
 37451                                  ; 30/09/2018 - Retro DOS v3.0
 37452                                  
 37453                                  ; TITLE	COMMAND Transient Initialized DATA
 37454                                  
 37455                                  ;The TRANDATA segment contains data that is assumed to have predefined
 37456                                  ;initial values at the beginning of each command cycle. It is
 37457                                  ;included in the transient checksum area. If values in TRANDATA
 37458                                  ;change, the transient will be reloaded for the next command cycle.
 37459                                  
 37460                                  align 16
 37461                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3730h
 37462                                  
 37463                                  PRINTF_TABLE:	db '0123456789ABCDEF'
 37464                                  _3740h:		db '%S',0
 37465                                  ARG_BUF_PTR:	dw _3740h
 37466                                  		dw _3747h
 37467                                  _3747h:		dw ARG_BUF ; _43E8h
 37468                                  _3749h:		db '%S ',0
 37469                                  STRINGBUF1PTR:	dw _3749h
 37470                                  		dw STRING_PTR_1 ; _4468h
 37471                                  _3751h:		db '%9ld',0
 37472                                  FSIZEMESPTR:	dw _3751h
 37473                                  		dw FILESIZE_L ; _446Ah
 37474                                  		dw FILESIZE_H ; _446Ch
 37475                                  _375Ch:		db '%S',0
 37476                                  STRINGBUF2PTR:	dw _375Ch
 37477                                  		dw STRING_PTR_2 ; _446Eh
 37478                                  _3763h:		db 9,0
 37479                                  TABPTR:		dw _3763h
 37480                                  _3767h:		db 0Dh,0Ah
 37481                                  		db 'Batch file missing',0Dh,0Ah,0
 37482                                  BADPATHPTR:	dw _3767h
 37483                                  _3780h:		db 0Dh,0Ah
 37484                                  		db 'Insert disk with batch file',0Dh,0Ah
 37485                                  		db 'and press any key when ready',0Dh,0Ah,0
 37486                                  INSERTDSKPTR:	dw _3780h
 37487                                  _37C0h:		db 'Bad command or file name',0Dh,0Ah,0
 37488                                  BADNAMPTR:	dw _37C0h
 37489                                  _37DDh:		db 'Duplicate file name or File not found',0Dh,0Ah,0
 37490                                  RENERRPTR:	dw _37DDh
 37491                                  _3807h:		db 'File not found',0Dh,0Ah,0
 37492                                  FNOTFOUNDPTR:	dw _3807h
 37493                                  _381Ah:		db 'Path not found',0Dh,0Ah,0
 37494                                  PNOTFOUNDPTR:	dw _381Ah
 37495                                  _382Dh:		db 'Access denied',0Dh,0Ah,0
 37496                                  ACCDENPTR:	dw _382Dh
 37497                                  _383Fh:		db 'Insufficient disk space',0Dh,0Ah,0
 37498                                  NOSPACEPTR:	dw _383Fh
 37499                                  _385Bh:		db 'Out of environment space',0Dh,0Ah,0
 37500                                  ENVERRPTR:	dw _385Bh
 37501                                  _3878h:		db 'File creation error',0Dh,0Ah,0
 37502                                  FULDIRPTR:	dw 3878h
 37503                                  _3890h:		db 'File cannot be copied onto itself',0Dh,0Ah,0
 37504                                  OVERWRPTR:	dw _3890h
 37505                                  _38B6h:		db 'Content of destination lost before copy',0Dh,0Ah,0
 37506                                  LOSTERRPTR:	dw _38B6h
 37507                                  _38E2h:		db 'Invalid filename or file not found',0Dh,0Ah,0
 37508                                  INORNOTPTR:	dw _38E2h
 37509                                  _3909h:		db '%9d File(s) copied',0Dh,0Ah,0
 37510                                  COPIEDPTR:	dw _3909h
 37511                                  		dw COPY_NUM ; _4470h
 37512                                  _3922h:		db '%9d File(s) ',0
 37513                                  DIRMESPTR:	dw _3922h
 37514                                  		dw DIR_NUM  ; _4477h
 37515                                  _3933h:		db '%9ld bytes free',0Dh,0Ah,0
 37516                                  BYTEMESPTR:	dw _3933h
 37517                                  		dw BYTES_FREE   ; _4479h
 37518                                  		dw BYTES_FREE+2 ; _447Bh
 37519                                  _394Bh:		db 'Invalid drive specification',0Dh,0Ah,0
 37520                                  BADDRVPTR:	dw _394Bh
 37521                                  _396Bh:		db 0Dh,0Ah
 37522                                  		db 'Code page %5d not prepared for system',0Dh,0Ah,0
 37523                                  CPNOTSETPTR:	dw _396Bh
 37524                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37525                                  _3999h:		db 0Dh,0Ah
 37526                                  		db 'Code page %5d not prepared for all devices',0Dh,0Ah,0
 37527                                  CPNOTALLPTR:	dw _3999h
 37528                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37529                                  _39CCh:		db 0Dh,0Ah
 37530                                  		db 'Active code page: %5d',0Dh,0Ah,0
 37531                                  CPACTIVEPTR:	dw _39CCh
 37532                                  		dw SYSTEM_CPAGE ; _3F2Fh
 37533                                  _39EAh:		db 'Current drive is no longer valid',0
 37534                                  BADCURDRVPTR:	dw _39EAh
 37535                                  _3A0Dh:		db 'Strike a key when ready . . . ',0
 37536                                  PAUSEMESPTR:	dw _3A0Dh
 37537                                  _3A2Eh:		db 'Invalid parameter',0Dh,0Ah,0
 37538                                  BADPARMPTR:	dw _3A2Eh
 37539                                  WEEKTAB:	db 'SunMonTueWedThuFriSat'
 37540                                  _3A59h:		db 0Dh,0Ah
 37541                                  		db 'Invalid date',0
 37542                                  BADDATPTR:	dw _3A59h
 37543                                  _3A6Ah:		db 'Current date is ',0
 37544                                  CURDATPTR:	dw _3A6Ah
 37545                                  _3A7Dh:		db 0Dh,0Ah
 37546                                  		db 'Enter new date ',0
 37547                                  NEWDATPTR:	dw _3A7Dh
 37548                                  _3A91h:		db '(mm-dd-yy): ',0
 37549                                  USADATPTR:	dw _3A91h
 37550                                  _3AA0h:		db '(dd-mm-yy): ',0
 37551                                  EURDATPTR:	dw _3AA0h
 37552                                  _3AAFh:		db '(yy-mm-dd): ',0
 37553                                  JAPDATPTR:	dw _3AAFh
 37554                                  _3ABEh:		db 0Dh,0Ah
 37555                                  		db 'Invalid time ',0
 37556                                  BADTIMPTR:	dw _3ABEh
 37557                                  _3AD0h:		db 'Current time is ',0
 37558                                  CURTIMPTR:	dw _3AD0h
 37559                                  _3AE3h:		db 0Dh,0Ah
 37560                                  		db 'Enter new time: ',0
 37561                                  NEWTIMPTR:	dw _3AE3h
 37562                                  _3AF8h:		db 'Are you sure (Y/N)?',0
 37563                                  SUREMESPTR:	dw _3AF8h
 37564                                  _3B0Eh:		db ' <DIR>   ',0
 37565                                  DMESPTR:	dw _3B0Eh
 37566                                  _3B1Ah:		db 'MS-DOS Version %1d.%02d                     ',0
 37567                                  VERMESPTR:	dw _3B1Ah
 37568                                  		dw MAJOR_VER_NUM ; _447Dh
 37569                                  		dw MINOR_VER_NUM ; _447Fh
 37570                                  _3B4Dh:		db '%C',0
 37571                                  ONECHRVALPTR:	dw _3B4Dh
 37572                                  		dw ONE_CHAR_VAL	; _4481h
 37573                                  _3B54h:		db ' Volume in drive %c %s',0
 37574                                  VOLMESPTR:	dw _3B54h
 37575                                  		dw VOL_DRV ; _4484h
 37576                                  		dw VOLNAME_ADDR ; _4482h
 37577                                  IS:		db 'is ',0
 37578                                  NOVOL:		db 'has no label',0
 37579                                  _3B82h:		db 'Invalid directory',0Dh,0Ah,0
 37580                                  BADCDPTR:	dw _3B82h
 37581                                  _3B98h:		db 'Unable to create directory',0Dh,0Ah,0
 37582                                  BADMKDPTR:	dw _3B98h
 37583                                  _3BB7h:		db 'Invalid path, not directory,',0Dh,0Ah
 37584                                  		db 'or directory not empty',0Dh,0Ah,0
 37585                                  BADRMDPTR:	dw _3BB7h
 37586                                  _3BF0h:		db 'Must specify ON or OFF',0Dh,0Ah,0
 37587                                  BADONOFFPTR:	dw _3BF0h
 37588                                  _3C0Bh:		db ' Directory of  %S',0Dh,0Ah,0
 37589                                  DIRHEADPTR:	dw _3C0Bh
 37590                                  		dw VOL_DIR ; _4485h
 37591                                  _3C23h:		db 'No Path',0
 37592                                  NULLPATHPTR:	dw _3C23h
 37593                                  PATH_TEXT:	db 'PATH='
 37594                                  PROMPT_TEXT:	db 'PROMPT='
 37595                                  COMSPEC_TEXT:	db 'COMSPEC='
 37596                                  _3C41h:		db 'Invalid drive in search path',0Dh,0Ah,0
 37597                                  BADPMESPTR:	dw _3C41h
 37598                                  _3C62h:		db 'Invalid device',0Dh,0Ah,0
 37599                                  BADDEVPTR:	dw _3C62h
 37600                                  _3C75h:		db 'Label not found',0Dh,0Ah,0
 37601                                  BADLABPTR:	dw _3C75h
 37602                                  _3C89h:		db 'Syntax error',0Dh,0Ah,0
 37603                                  SYNTMESPTR:	dw _3C89h
 37604                                  _3C9Ah:		db 0Dh,'FOR cannot be nested',0Dh,0Ah,0
 37605                                  FORNESTMESTR:	dw _3C9Ah
 37606                                  _3CB4h:		db 'Insufficient memory',0Dh,0Ah,0
 37607                                  INSFMEMMESPTR:	dw _3CB4h
 37608                                  _3CCCh:		db 'Intermediate file error during pipe',0Dh,0Ah,0
 37609                                  PIPEEMESPTR:	dw _3CCCh
 37610                                  _3CF4h:		db 'Cannot do binary reads from a device',0Dh,0Ah,0
 37611                                  INBDEVPTR:	dw _3CF4h
 37612                                  _3D1Dh:		db 'BREAK is ',0
 37613                                  CTRLMESPTR:	dw _3D1Dh
 37614                                  _3D29h:		db 'VERIFY is ',0
 37615                                  VERIMESPTR:	dw _3D29h
 37616                                  _3D36h:		db 'ECHO is ',0
 37617                                  ECHOMESPTR:	dw _3D36h
 37618                                  _3D41h:		db 'off',0Dh,0Ah,0
 37619                                  OFFMESPTR:	dw _3D41h
 37620                                  _3D49h:		db 'on',0Dh,0Ah,0
 37621                                  ONMESPTR:	dw _3D49h
 37622                                  _3D50h:		db 'Invalid path or file name',0Dh,0Ah,0
 37623                                  BADCPMESPTR:	dw _3D50h
 37624                                  _3D6Eh:		db 'Invalid number of parameters',0Dh,0Ah,0
 37625                                  BADARGSPTR:	dw _3D6Eh
 37626                                  _3D8Fh:		db 'Error writing to device',0Dh,0Ah,0
 37627                                  DEVWMESPTR:	dw _3D8Fh
 37628                                  _3DABh:		db 0Dh,0Ah,0
 37629                                  ACRLFPTR:	dw _3DABh
 37630                                  _3DB0h:		db 8
 37631                                  		db 20h
 37632                                  		db 8
 37633                                  		db 0
 37634                                  DBACKPTR:	dw _3DB0h
 37635                                  small_y:	db 'y'
 37636                                  small_n:	db 'n'
 37637                                  CAPITAL_Y:	db 'Y'
 37638                                  CAPITAL_N:	db 'N'
 37639                                  CLSSTRING:	db 4,1Bh,'[2J'	; ANSI Clear screen
 37640                                  PROMPT_TABLE:
 37641                                  		db 'B' ; 42h
 37642                                  		dw PRINT_B
 37643                                  		db 'D' ; 44h
 37644                                  		dw PRINT_DATE
 37645                                  		db 'E' ; 45h
 37646                                  		dw PRINT_ESC
 37647                                  		db 'G' ; 47h
 37648                                  		dw PRINT_G
 37649                                  		db 'H' ; 48h
 37650                                  		dw PRINT_BACK
 37651                                  		db 'L' ; 4Ch
 37652                                  		dw PRINT_L
 37653                                  		db 'N' ; 4Eh
 37654                                  		dw PRINT_DRIVE
 37655                                  		db 'P' ; 50h
 37656                                  		dw BUILD_DIR_FOR_PROMPT
 37657                                  		db 'Q' ; 51h
 37658                                  		dw PRINT_EQ
 37659                                  		db 'T' ; 54h
 37660                                  		dw PRINT_TIME
 37661                                  		db 'V' ; 56h
 37662                                  		dw PRINT_VERSION
 37663                                  		db '_' ; 5Fh
 37664                                  		dw CRLF2
 37665                                  		db '$' ; 24h
 37666                                  		dw PRINT_CHAR
 37667                                  		db 0
 37668                                  
 37669                                  		; Table of IF conditionals
 37670                                  IFTAB:
 37671                                  		db 3	; First byte is count
 37672                                  		db 'NOT'
 37673                                  		dw IFNOT
 37674                                  		db 10
 37675                                  		db 'ERRORLEVEL'
 37676                                  		dw IFERLEV
 37677                                  		db 5
 37678                                  		db 'EXIST'
 37679                                  		dw IFEXISTS
 37680                                  		db 0
 37681                                  
 37682                                  		; Table for internal command names
 37683                                  
 37684                                  COMTAB:		db 3
 37685                                  		db 'DIR'
 37686                                  		db 3
 37687                                  		dw CATALOG
 37688                                  		db 4
 37689                                  		db 'CALL'
 37690                                  		db 2
 37691                                  		dw _$CALL
 37692                                  		db 4
 37693                                  		db 'CHCP'
 37694                                  		db 2
 37695                                  		dw CHCP
 37696                                  		db 6
 37697                                  		db 'RENAME'
 37698                                  		db 1
 37699                                  		dw CRENAME
 37700                                  		db 3
 37701                                  		db 'REN'
 37702                                  		db 1
 37703                                  		dw CRENAME
 37704                                  		db 5
 37705                                  		db 'ERASE'
 37706                                  		db 1
 37707                                  		dw ERASE
 37708                                  		db 3
 37709                                  		db 'DEL'
 37710                                  		db 1
 37711                                  		dw ERASE
 37712                                  		db 4
 37713                                  		db 'TYPE'
 37714                                  		db 1
 37715                                  		dw TYPEFIL
 37716                                  		db 3
 37717                                  		db 'REM'
 37718                                  		db 2
 37719                                  		dw TCOMMAND
 37720                                  		db 4
 37721                                  		db 'COPY'
 37722                                  		db 3
 37723                                  		dw COPY
 37724                                  		db 5
 37725                                  		db 'PAUSE'
 37726                                  		db 2
 37727                                  		dw PAUSE
 37728                                  		db 4
 37729                                  		db 'DATE'
 37730                                  		db 2
 37731                                  		dw DATE
 37732                                  		db 4
 37733                                  		db 'TIME'
 37734                                  		db 0
 37735                                  		dw CTIME
 37736                                  		db 3
 37737                                  		db 'VER'
 37738                                  		db 0
 37739                                  		dw VERSION
 37740                                  		db 3
 37741                                  		db 'VOL'
 37742                                  		db 1
 37743                                  		dw VOLUME
 37744                                  		db 2
 37745                                  		db 'CD'
 37746                                  		db 1
 37747                                  		dw _$CHDIR
 37748                                  		db 5
 37749                                  		db 'CHDIR'
 37750                                  		db 1
 37751                                  		dw _$CHDIR
 37752                                  		db 2
 37753                                  		db 'MD'
 37754                                  		db 1
 37755                                  		dw _$MKDIR
 37756                                  		db 5
 37757                                  		db 'MKDIR'
 37758                                  		db 1
 37759                                  		dw _$MKDIR
 37760                                  		db 2
 37761                                  		db 'RD'
 37762                                  		db 1
 37763                                  		dw _$RMDIR
 37764                                  		db 5
 37765                                  		db 'RMDIR'
 37766                                  		db 1
 37767                                  		dw _$RMDIR
 37768                                  		db 5
 37769                                  		db 'BREAK'
 37770                                  		db 0
 37771                                  		dw CNTRLC
 37772                                  		db 6
 37773                                  		db 'VERIFY'
 37774                                  		db 0
 37775                                  		dw VERIFY
 37776                                  		db 3
 37777                                  		db 'SET'
 37778                                  		db 2
 37779                                  		dw ADD_NAME_TO_ENVIRONMENT
 37780                                  		db 6
 37781                                  		db 'PROMPT'
 37782                                  		db 2
 37783                                  		dw ADD_PROMPT
 37784                                  		db 4
 37785                                  		db 'PATH'
 37786                                  		db 2
 37787                                  		dw PATH
 37788                                  		db 4
 37789                                  		db 'EXIT'
 37790                                  		db 0
 37791                                  		dw _$EXIT
 37792                                  		db 4
 37793                                  		db 'CTTY'
 37794                                  		db 3
 37795                                  		dw CTTY
 37796                                  		db 4
 37797                                  		db 'ECHO'
 37798                                  		db 2
 37799                                  		dw _ECHO
 37800                                  		db 4
 37801                                  		db 'GOTO'
 37802                                  		db 2
 37803                                  		dw _GOTO
 37804                                  		db 5
 37805                                  		db 'SHIFT'
 37806                                  		db 2
 37807                                  		dw _SHIFT
 37808                                  		db 2
 37809                                  		db 'IF'
 37810                                  		db 2
 37811                                  		dw _$IF
 37812                                  		db 3
 37813                                  		db 'FOR'
 37814                                  		db 2
 37815                                  		dw _$FOR
 37816                                  		db 3
 37817                                  		db 'CLS'
 37818                                  		db 0
 37819                                  		dw CLS
 37820                                  		db 0
 37821                                  
 37822                                  CAPITAL_A:	db 'A'
 37823                                  VBAR:		db '|'
 37824                                  LABRACKET:	db '<' ; 3Ch
 37825                                  RABRACKET:	db '>' ; 3Eh
 37826                                  DOLLAR:		db '$'
 37827                                  LPAREN:		db '('
 37828                                  RPAREN:		db ')'
 37829                                  NULLRPAREN:	db ')' ; 29h
 37830                                  		db 0
 37831                                  IN_WORD:	db 'I','N'
 37832                                  DO_WORD	:	db 'D','O'
 37833                                  STAR:		db '*'
 37834                                  CHAR_SUB:	db '-' 
 37835                                  PLUS_CHR:	db '+'
 37836                                  CHAR_L:		db 'L'
 37837                                  char_l:		db 'l'
 37838                                  small_a:	db 'a'
 37839                                  small_z:	db 'z'
 37840                                  CHAR_D:		db 'D'
 37841                                  CHAR_C:		db 'C'
 37842                                  CHAR_S:		db 'S'
 37843                                  CHAR_X:		db 'X'
 37844                                  DOT_CHR:	db '.' 
 37845                                  DOT_QMARK:	dw '?.'  ; dw 2E3Fh
 37846                                  		db ','
 37847                                  TIMECHARS:	dw ':.'  ; dw 2E3Ah 	 
 37848                                  MNCHR:		db 'p'
 37849                                  SYSTEM_CPAGE:	db 0
 37850                                  		db 0
 37851                                  
 37852                                  COMEXT:		db '.COM'
 37853                                  EXEEXT:		db '.EXE'
 37854                                  BATEXT:		db '.BAT'
 37855                                  SWITCH_LIST:	db 'VBAPW'
 37856                                  BATBUFLEN:	dw BATLEN ; 32
 37857                                  
 37858                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F44h
 37859                                  
 37860                                  TRANDATAEND:
 37861                                  
 37862                                  %endif
 37863                                  
 37864                                  ;============================================================================
 37865                                  ; TDATA.ASM, MSDOS 6.0, 1991
 37866                                  ;============================================================================
 37867                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 37868                                  
 37869                                  	; 15/04/2023
 37870 000081BC 00                      	db	0
 37871 000081BD 90                      align 2
 37872                                  
 37873                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:849Eh
 37874                                  ; ---------------------------------------------------------------------------
 37875 000081BE 00                      	db 0
 37876                                  ; Lists of help message numbers for internal commands and /?
 37877                                  
 37878                                  ;;NoHelpMsgs:
 37879 000081BF B0040000                	dw	1200,0		;M014
 37880                                  BreakHelpMsgs:
 37881 000081C3 14050000                	dw	1300,0
 37882                                  ChcpHelpMsgs:
 37883 000081C7 280529050000            	dw	1320,1321,0
 37884                                  CdHelpMsgs:
 37885 000081CD 3C053D053E050000        	dw	1340,1341,1342,0
 37886                                  ClsHelpMsgs:
 37887 000081D5 50050000                	dw	1360,0
 37888                                  CopyHelpMsgs:
 37889 000081D9 780579057A057B057C-     	dw	1400,1401,1402,1403,1404,0
 37889 000081E2 050000             
 37890                                  CttyHelpMsgs:
 37891 000081E5 8C050000                	dw	1420,0
 37892                                  DateHelpMsgs:
 37893 000081E9 A005A1050000            	dw	1440,1441,0
 37894                                  DelHelpMsgs:
 37895 000081EF B405B505B6050000        	dw	1460,1461,1462,0
 37896                                  DirHelpMsgs:
 37897 000081F7 C805C905CA05CB05CC-     	dw	1480,1481,1482,1483,1484,1485,1486,1487,1488
 37897 00008200 05CD05CE05CF05D005 
 37898                                  	; MSDOS 6.0 COMMAND.COM
 37899                                  	;dw	1489,1490,1491,1492
 37900 00008209 0000                    	dw	0
 37901                                  ExitHelpMsgs:
 37902 0000820B DC050000                	dw	1500,0
 37903                                  MdHelpMsgs:
 37904 0000820F F0050000                	dw	1520,0
 37905                                  PathHelpMsgs:
 37906 00008213 0406050606060000        	dw	1540,1541,1542,0
 37907                                  PromptHelpMsgs:
 37908 0000821B 180619061A061B061C-     	dw	1560,1561,1562,1563,1564,1565,1566,1567,1568,0
 37908 00008224 061D061E061F062006-
 37908 0000822D 0000               
 37909                                  RdHelpMsgs:
 37910 0000822F 2C060000                	dw	1580,0
 37911                                  RenHelpMsgs:
 37912 00008233 4006410642060000        	dw	1600,1601,1602,0
 37913                                  SetHelpMsgs:
 37914 0000823B 5406550656060000        	dw	1620,1621,1622,0
 37915                                  TimeHelpMsgs:
 37916 00008243 680669060000            	dw	1640,1641,0
 37917                                  TypeHelpMsgs:
 37918 00008249 7C060000                	dw	1660,0
 37919                                  VerHelpMsgs:
 37920 0000824D 90060000                	dw	1680,0
 37921                                  VerifyHelpMsgs:
 37922 00008251 A4060000                	dw	1700,0
 37923                                  VolHelpMsgs:
 37924 00008255 B8060000                	dw	1720,0
 37925                                  CallHelpMsgs:
 37926 00008259 CC06CD060000            	dw	1740,1741,0	;M014
 37927                                  RemHelpMsgs:
 37928 0000825F E0060000                	dw	1760,0		;M014
 37929                                  PauseHelpMsgs:
 37930 00008263 F4060000                	dw	1780,0		;M014
 37931                                  EchoHelpMsgs:
 37932 00008267 080709070000            	dw	1800,1801,0	;M014
 37933                                  GotoHelpMsgs:
 37934 0000826D 1C071D070000            	dw	1820,1821,0	;M014
 37935                                  ShiftHelpMsgs:
 37936 00008273 30070000                	dw	1840,0		;M014
 37937                                  IfHelpMsgs:
 37938 00008277 440745074607470748-     	dw	1860,1861,1862,1863,1864,1865,1866,0	;M014
 37938 00008280 0749074A070000     
 37939                                  ForHelpMsgs:
 37940 00008287 580759075A075B0700-     	dw	1880,1881,1882,1883,0 ;M014
 37940 00008290 00                 
 37941                                  TruenameHelpMsgs:
 37942 00008291 6C070000                	 dw	1900,0		;M014
 37943                                  LoadhighHelpMsgs:
 37944 00008295 800781078207            	dw	1920,1921,1922
 37945                                  	; MSDOS 6.0 COMMAND.COM
 37946                                  	;dw	1923,1924,1925,1926,1927 ;M014
 37947 0000829B 0000                    	dw	0
 37948                                  
 37949                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8578h
 37950                                  CLSSTRING:
 37951 0000829D 041B5B324A              	db	4,01Bh,"[2J"		; ANSI Clear screen
 37952                                  
 37953                                  PROMPT_TABLE:
 37954 000082A2 42                      	db	"B"
 37955 000082A3 [F41D]                  	dw	Print_B
 37956 000082A5 44                      	db	"D"
 37957 000082A6 [DA36]                  	dw	PRINT_DATE
 37958 000082A8 45                      	db	"E"
 37959 000082A9 [E81D]                  	dw	PRINT_ESC
 37960 000082AB 47                      	db	"G"
 37961 000082AC [EC1D]                  	dw	PRINT_G
 37962 000082AE 48                      	db	"H"
 37963 000082AF [DE1D]                  	dw	PRINT_BACK
 37964 000082B1 4C                      	db	"L"
 37965 000082B2 [F01D]                  	dw	PRINT_L
 37966 000082B4 4E                      	db	"N"
 37967 000082B5 [051E]                  	dw	PRINT_DRIVE
 37968 000082B7 50                      	db	"P"
 37969 000082B8 [0D1E]                  	dw	build_dir_for_prompt
 37970 000082BA 51                      	db	"Q"
 37971 000082BB [E41D]                  	dw	PRINT_EQ
 37972 000082BD 54                      	db	"T"
 37973 000082BE [7B2F]                  	dw	PRINT_TIME
 37974 000082C0 56                      	db	"V"
 37975 000082C1 [741D]                  	dw	PRINT_VERSION
 37976 000082C3 5F                      	db	"_"
 37977 000082C4 [CA25]                  	dw	CRLF2
 37978 000082C6 24                      	db	"$"
 37979 000082C7 [F61D]                  	dw	PRINT_CHAR
 37980 000082C9 00                      	db	0			; NUL TERMINATED
 37981                                  
 37982                                  ; Table of IF conditionals
 37983                                  IFTAB:
 37984 000082CA 034E4F54                	db	3,"NOT"			; First byte is count
 37985 000082CE [E50A]                  	dw	IFNOT
 37986 000082D0 0A4552524F524C4556-     	db	10,"ERRORLEVEL"
 37986 000082D9 454C               
 37987 000082DB [A40B]                  	dw	IFERLEV
 37988 000082DD 054558495354            	db	5,"EXIST"
 37989 000082E3 [390B]                  	dw	IFEXISTS
 37990 000082E5 00                      	db	0
 37991                                  
 37992                                  ; Table for internal command names
 37993                                  COMTAB:
 37994 000082E6 0344495203              	db	3,"DIR",fSwitchAllowed+fCheckDrive ; 3
 37995 000082EB [6C10]                  	dw	CATALOG			; In TCMD1.ASM
 37996 000082ED [F781]                  	dw	DirHelpMsgs
 37997                                  
 37998 000082EF 0443414C4C02            	db	4,"CALL",fSwitchAllowed	; 2
 37999 000082F5 [190C]                  	dw	_$CALL			; In TBATCH2.ASM
 38000 000082F7 [5982]                  	dw	CallHelpMsgs
 38001                                  
 38002 000082F9 044348435002            	db	4,"CHCP",fSwitchAllowed ; 2
 38003 000082FF [5020]                  	dw	CHCP			; In TCMD2B.ASM
 38004 00008301 [C781]                  	dw	ChcpHelpMsgs
 38005                                  
 38006 00008303 0652454E414D4503        	db	6,"RENAME",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38007 0000830B [4D1A]                  	dw	CRENAME			; In TCMD1.ASM
 38008 0000830D [3382]                  	dw	RenHelpMsgs
 38009                                  
 38010 0000830F 0352454E03              	db	3,"REN",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38011 00008314 [4D1A]                  	dw	CRENAME			; In TCMD1.ASM
 38012 00008316 [3382]                  	dw	RenHelpMsgs
 38013                                  	
 38014 00008318 05455241534503          	db	5,"ERASE",fSwitchAllowed+fCheckDrive	; 3
 38015 0000831F [CB19]                  	dw	ERASE			; In TCMD1.ASM
 38016 00008321 [EF81]                  	dw	DelHelpMsgs
 38017                                  	
 38018 00008323 0344454C03              	db	3,"DEL",fSwitchAllowed+fCheckDrive	; 3
 38019 00008328 [CB19]                  	dw	ERASE			; In TCMD1.ASM
 38020 0000832A [EF81]                  	dw	DelHelpMsgs
 38021                                  	
 38022 0000832C 045459504503            	db	4,"TYPE",fSwitchAllowed+fCheckDrive	; 3 ;AC018; P3903
 38023 00008332 [F41A]                  	dw	TYPEFIL			; In TCMD1.ASM
 38024 00008334 [4982]                  	dw	TypeHelpMsgs
 38025                                  	
 38026 00008336 0352454D06              	db	3,"REM",fSwitchAllowed+fLimitHelp	; 6
 38027 0000833B [0401]                  	dw	TCOMMAND		; In TCODE.ASM
 38028 0000833D [5F82]                  	dw	RemHelpMsgs
 38029                                  	
 38030 0000833F 04434F505903            	db	4,"COPY",fSwitchAllowed+fCheckDrive	; 3
 38031 00008345 [2737]                  	dw	COPY			; In COPY.ASM
 38032 00008347 [D981]                  	dw	CopyHelpMsgs
 38033                                  	
 38034 00008349 05504155534506          	db	5,"PAUSE",fSwitchAllowed+fLimitHelp	; 6
 38035 00008350 [BF19]                  	dw	PAUSE			; In TCMD1.ASM
 38036 00008352 [6382]                  	dw	PauseHelpMsgs
 38037                                  	
 38038 00008354 044441544502            	db	4,"DATE",fSwitchAllowed	; 2
 38039 0000835A [8E2E]                  	dw	DATE			; In TPIPE.ASM
 38040 0000835C [E981]                  	dw	DateHelpMsgs
 38041                                  	
 38042 0000835E 0454494D4502            	db	4,"TIME",fSwitchAllowed ; 2		;AC018; P3903
 38043 00008364 [ED2E]                  	dw	CTIME			; In TPIPE.ASM
 38044 00008366 [4382]                  	dw	TimeHelpMsgs
 38045                                  	
 38046 00008368 0356455202              	db	3,"VER",fSwitchAllowed ; 2
 38047 0000836D [131D]                  	dw	VERSION			; In TCMD2.ASM
 38048 0000836F [4D82]                  	dw	VerHelpMsgs
 38049                                  	
 38050 00008371 03564F4C03              	db	3,"VOL",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38051 00008376 [1B1C]                  	dw	VOLUME			; In TCMD1.ASM
 38052 00008378 [5582]                  	dw	VolHelpMsgs
 38053                                  	
 38054 0000837A 02434403                	db	2,"CD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38055 0000837E [9324]                  	dw	_$CHDIR			; In TENV.ASM
 38056 00008380 [CD81]                  	dw	CdHelpMsgs
 38057                                  	
 38058 00008382 05434844495203          	db	5,"CHDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38059 00008389 [9324]                  	dw	_$CHDIR			; In TENV.ASM
 38060 0000838B [CD81]                  	dw	CdHelpMsgs
 38061                                  	
 38062 0000838D 024D4403                	db	2,"MD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38063 00008391 [F824]                  	dw	_$MKDIR			; In TENV.ASM
 38064 00008393 [0F82]                  	dw	MdHelpMsgs
 38065                                  	
 38066 00008395 054D4B44495203          	db	5,"MKDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38067 0000839C [F824]                  	dw	_$MKDIR			; In TENV.ASM
 38068 0000839E [0F82]                  	dw	MdHelpMsgs
 38069                                  	
 38070 000083A0 02524403                	db	2,"RD",fSwitchAllowed+fCheckDrive ; 3	;AC018; P3903
 38071 000083A4 [3A25]                  	dw	_$RMDIR			; In TENV.ASM
 38072 000083A6 [2F82]                  	dw	RdHelpMsgs
 38073                                  	
 38074 000083A8 05524D44495203          	db	5,"RMDIR",fSwitchAllowed+fCheckDrive	;AC018; P3903
 38075 000083AF [3A25]                  	dw	_$RMDIR			; In TENV.ASM
 38076 000083B1 [2F82]                  	dw	RdHelpMsgs
 38077                                  	
 38078 000083B3 05425245414B02          	db	5,"BREAK",fSwitchAllowed ; 2		;AC018; P3903
 38079 000083BA [2436]                  	dw	CNTRLC			; In TUCODE.ASM
 38080 000083BC [C381]                  	dw	BreakHelpMsgs
 38081                                  	
 38082 000083BE 0656455249465902        	db	6,"VERIFY",fSwitchAllowed ; 2		;AC018; P3903
 38083 000083C6 [6636]                  	dw	VERIFY			; In TUCODE.ASM
 38084 000083C8 [5182]                  	dw	VerifyHelpMsgs
 38085                                  	
 38086 000083CA 0353455406              	db	3,"SET",fSwitchAllowed+fLimitHelp ; 6
 38087 000083CF [FD21]                  	dw	ADD_NAME_TO_ENVIRONMENT	; In TENV.ASM
 38088 000083D1 [3B82]                  	dw	SetHelpMsgs
 38089                                  	
 38090 000083D3 0650524F4D505406        	db	6,"PROMPT",fSwitchAllowed+fLimitHelp ; 6
 38091 000083DB [E321]                  	dw	ADD_PROMPT		; In TENV.ASM
 38092 000083DD [1B82]                  	dw	PromptHelpMsgs
 38093                                  	
 38094 000083DF 045041544802            	db	4,"PATH",fSwitchAllowed ; 2
 38095 000083E5 [741E]                  	dw	PATH			; In TCMD2.ASM
 38096 000083E7 [1382]                  	dw	PathHelpMsgs
 38097                                  	
 38098 000083E9 044558495400            	db	4,"EXIT",0
 38099 000083EF [4521]                  	dw	_$EXIT			; In TCMD2.ASM
 38100 000083F1 [0B82]                  	dw	ExitHelpMsgs
 38101                                  	
 38102 000083F3 044354545903            	db	4,"CTTY",fCheckDrive+fSwitchAllowed ; 3
 38103 000083F9 [B21F]                  	dw	CTTY			; In TCMD2.ASM
 38104 000083FB [E581]                  	dw	CttyHelpMsgs
 38105                                  	
 38106 000083FD 044543484F06            	db	4,"ECHO",fSwitchAllowed+fLimitHelp ; 6
 38107 00008403 [EB35]                  	dw	_ECHO			; In TUCODE.ASM
 38108 00008405 [6782]                  	dw	EchoHelpMsgs
 38109                                  	
 38110 00008407 04474F544F06            	db	4,"GOTO",fSwitchAllowed+fLimitHelp
 38111 0000840D [4D0C]                  	dw	_GOTO			; In TBATCH.ASM
 38112 0000840F [6D82]                  	dw	GotoHelpMsgs
 38113                                  	
 38114 00008411 05534849465402          	db	5,"SHIFT",fSwitchAllowed ; 2
 38115 00008418 [D20B]                  	dw	_SHIFT			; In TBATCH.ASM
 38116 0000841A [7382]                  	dw	ShiftHelpMsgs
 38117                                  	
 38118 0000841C 02494606                	db	2,"IF",fSwitchAllowed+fLimitHelp ; 6
 38119 00008420 [7E0A]                  	dw	_$IF			; In TBATCH.ASM
 38120 00008422 [7782]                  	dw	IfHelpMsgs
 38121                                  	
 38122 00008424 03464F5206              	db	3,"FOR",fSwitchAllowed+fLimitHelp ; 6
 38123 00008429 [050F]                  	dw	_$FOR			; In TBATCH.ASM
 38124 0000842B [8782]                  	dw	ForHelpMsgs
 38125                                  	
 38126 0000842D 03434C5300              	db	3,"CLS",0
 38127 00008432 [191F]                  	dw	CLS			; In TCMD2.ASM
 38128 00008434 [D581]                  	dw	ClsHelpMsgs
 38129                                  	
 38130 00008436 08545255454E414D45-     	db	8,"TRUENAME",fSwitchAllowed+fCheckDrive	;AN000; P3903 changed
 38130 0000843F 03                 
 38131 00008440 [CE20]                  	dw	TRUENAME		;AN000;
 38132 00008442 [9182]                  	dw	TruenameHelpMsgs
 38133                                  	
 38134 00008444 084C4F414448494748-     	db	8,"LOADHIGH",fSwitchAllowed ; 2	; M003
 38134 0000844D 02                 
 38135 0000844E [5E56]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38136 00008450 [9582]                  	dw	LoadhighHelpMsgs	; M003
 38137                                  	
 38138 00008452 024C4802                	db	2,"LH",fSwitchAllowed ; 2	; Short form; M003
 38139 00008456 [5E56]                  	dw	LoadHigh		; In loadhi.asm ; M003
 38140 00008458 [9582]                  	dw	LoadhighHelpMsgs	; M003
 38141                                  	
 38142 0000845A 00                      	db	0			; Terminate command table
 38143                                  
 38144                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8736h
 38145                                  
 38146 0000845B 2E434F4D                comext:	db	".COM"
 38147 0000845F 2E455845                exeext:	db	".EXE"
 38148 00008463 2E424154                batext:	db	".BAT"
 38149                                  
 38150                                  switch_list:
 38151 00008467 3F5642415057            	db	"?VBAPW"		; flags we can recognize
 38152                                  
 38153                                  AttrLtrs:
 38154 0000846D 524853764441            	db	"RHSvDA"		; attribute letters for DIR
 38155                                  
 38156                                  ;	Attribute letters in AttrLtrs must appear in the order that
 38157                                  ;	attribute bits occur in the attribute byte returned by
 38158                                  ;	directory searches, starting with bit 0.
 38159                                  ;	The volume label attribute is lowercased to keep it from
 38160                                  ;	being matched (by an uppercase comparison).
 38161                                  
 38162                                  OrderLtrs:
 38163 00008473 4E45445347              	db	"NEDSG"			; sort order letters for DIR
 38164                                  	; MSDOS 6.0 COMMAND.COM
 38165                                  	;db	"NEDSGC"		; sort order letters for DIR
 38166                                  
 38167                                  ;	Sort order letters stand for file name, extension,
 38168                                  ;	date/time, size, grouped (directory files before others),
 38169                                  ;	and compression ratio. DIR routines rely on the specific
 38170                                  ;	order of the letters in this list.
 38171                                  
 38172                                  comspec_flag:
 38173 00008478 00                      	db	0                       ;AN071;
 38174                                  
 38175                                  BATBUFLEN:
 38176 00008479 2000                    	dw	BatLen ; 32
 38177                                  
 38178                                  ; *****************************************************
 38179                                  ; EMG 4.00
 38180                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 38181                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 38182                                  ; *****************************************************
 38183                                  
 38184                                  ; COMMON PARSE BLOCKS
 38185                                  
 38186                                  ; Indicates no value list for PARSE.
 38187                                  
 38188                                  NO_VALUES:
 38189 0000847B 0000                    	dw	0			;AN000;  no values
 38190                                  
 38191                                  NULL_VALUE_LIST:  ; for unvalidated value
 38192 0000847D 00                       	db	0                       ; no value lists
 38193                                  
 38194                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38195                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8759h
 38196                                  
 38197                                  ; PARSE control block for a required file specification (upper cased)
 38198                                  
 38199                                  FILE_REQUIRED:
 38200 0000847E 0002                    	dw	0200h			;AN000;  filespec - required
 38201 00008480 0100                    	dw	1			;AN000;  capitalize - file table
 38202 00008482 [CB95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38203 00008484 [7B84]                  	dw	NO_VALUES		;AN000;
 38204 00008486 00                      	db	0			;AN000;  no keywords
 38205                                  
 38206                                  ; PARSE control block for an optional file specification (upper cased)
 38207                                  ; or drive number
 38208                                  
 38209                                  FILE_OPTIONAL:
 38210 00008487 0103                    	dw	0301h			;AN000;  filespec or drive number
 38211                                  					;	 optional
 38212 00008489 0100                    	dw	1			;AN000;  capitalize - file table
 38213 0000848B [CB95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38214 0000848D [7B84]                  	dw	NO_VALUES		;AN000;
 38215 0000848F 00                      	db	0			;AN000;  no keywords
 38216                                  
 38217                                  ; PARSE control block for an optional file specification (upper cased)
 38218                                  
 38219                                  FILE_OPTIONAL2:
 38220 00008490 0102                    	dw	0201h                   ;AN000;  filespec optional
 38221 00008492 0100                    	dw	1                       ;AN000;  capitalize - file table
 38222 00008494 [CB95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38223 00008496 [7B84]                  	dw	NO_VALUES		;AN000;
 38224 00008498 00                      	db	0			;AN000;  no keywords
 38225                                  
 38226                                  ; PARSE control block for an optional /P switch
 38227                                  
 38228                                  SLASH_P_SWITCH:
 38229 00008499 0000                    	dw	0			;AN000;  no match flags
 38230 0000849B 0200                    	dw	2			;AN000;  capitalize - char table
 38231 0000849D [CB95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38232 0000849F [7B84]                  	dw	NO_VALUES		;AN000;
 38233 000084A1 01                      	db	1			;AN000;  1 keyword
 38234                                  SLASH_P_SYN:
 38235 000084A2 2F5000                  	db	"/P",0                  ;AN000;  /P switch
 38236                                  
 38237                                  ; PARSE BLOCK FOR BREAK, VERIFY, ECHO
 38238                                  
 38239                                  ; The following parse control block can be used for any command which
 38240                                  ; needs only the optional "ON" and "OFF" keywords as operands. Allows
 38241                                  ; the equal sign as an additional delimiter. Returns verified result
 38242                                  ; in PARSE1_OUTPUT. Currently used for the BREAK, VERIFY, and ECHO
 38243                                  ; internal commands.
 38244                                  
 38245                                  PARSE_BREAK:
 38246 000084A5 [A884]                  	dw	BREAK_PARMS		;AN000;
 38247 000084A7 00                      	db	0			;AN032; no extra delimiter
 38248                                  
 38249                                  BREAK_PARMS:
 38250 000084A8 0001                    	db	0,1			;AN000;  1 positional parm
 38251 000084AA [AE84]                  	dw	BREAK_CONTROL1		;AN000;
 38252 000084AC 00                      	db	0			;AN000;  no switches
 38253 000084AD 00                      	db	0			;AN000;  no keywords
 38254                                  
 38255                                  BREAK_CONTROL1:
 38256 000084AE 0120                    	dw	2001h			;AN000;  string value - optional
 38257 000084B0 0200                    	dw	2			;AN000;  capitalize - char table
 38258 000084B2 [CB95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38259 000084B4 [B784]                  	dw	BREAK_VALUES		;AN000;
 38260 000084B6 00                      	db	0			;AN000;  no keywords
 38261                                  
 38262                                  BREAK_VALUES:
 38263 000084B7 03                      	db	3			;AN000;
 38264 000084B8 00                      	db	0			;AN000;  no ranges
 38265 000084B9 00                      	db	0			;AN000;  no numeric values
 38266 000084BA 02                      	db	2			;AN000;  2 string values
 38267 000084BB 00                      	db	0			;AN000;  returned if ON
 38268 000084BC [C184]                  	dw	BREAK_ON		;AN000;  point to ON string
 38269 000084BE 66                      	db	'f'                     ;AN000;  returned if OFF
 38270 000084BF [C484]                  	dw	BREAK_OFF		;AN000;  point to OFF string
 38271                                  
 38272                                  BREAK_ON:
 38273 000084C1 4F4E00                  	db	"ON",0                  ;AN000;
 38274                                  BREAK_OFF:
 38275 000084C4 4F464600                	db	"OFF",0                 ;AN000;
 38276                                  
 38277                                  	; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38278                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:87A3h
 38279                                  
 38280                                  ; PARSE BLOCK FOR CHCP
 38281                                  
 38282                                  ; The following parse control block can be used for any command which
 38283                                  ; needs only one optional three digit decimal parameter for operands.
 38284                                  ; Returns verified result in PARSE1_OUTPUT. Currently used for the
 38285                                  ; CHCP internal command.
 38286                                  
 38287                                  CHCP_MINVAL	EQU	100			;AN000;
 38288                                  CHCP_MAXVAL	EQU	999			;AN000;
 38289                                  
 38290                                  PARSE_CHCP:
 38291 000084C8 [CB84]                  	dw	CHCP_PARMS			;AN000;
 38292 000084CA 00                      	db	0				;AN000;  no extra delimiter
 38293                                  CHCP_PARMS:
 38294 000084CB 0001                    	db	0,1				;AN000;  1 positional parm
 38295 000084CD [D184]                  	dw	CHCP_CONTROL1			;AN000;
 38296 000084CF 00                      	db	0				;AN000;  no switches
 38297 000084D0 00                      	db	0				;AN000;  no keywords
 38298                                  
 38299                                  CHCP_CONTROL1:
 38300 000084D1 0180                    	dw	8001h				;AN000;  numeric value - optional
 38301 000084D3 0000                    	dw	0				;AN000;  no function flags
 38302 000084D5 [CB95]                  	dw	PARSE1_OUTPUT			;AN000;  result buffer
 38303 000084D7 [DA84]                  	dw	CHCP_VALUES			;AN000;
 38304 000084D9 00                      	db	0				;AN000;  no keywords
 38305                                  
 38306                                  CHCP_VALUES:
 38307 000084DA 01                      	db	1				;AN000;
 38308 000084DB 01                      	db	1				;AN000;  1 range
 38309 000084DC 01                      	db	1				;AN000;  returned if result
 38310 000084DD 64000000E7030000        	dd	CHCP_MINVAL,CHCP_MAXVAL		;AN000;  minimum & maximum value
 38311 000084E5 00                      	db	0				;AN000;  no numeric values
 38312 000084E6 00                      	db	0				;AN000;  no string values
 38313                                  
 38314                                  ; PARSE BLOCK FOR DATE
 38315                                  
 38316                                  ; The following parse control block can be used for any command which
 38317                                  ; needs only an optional date string as an operand. Returns unverified
 38318                                  ; result in DATE_OUTPUT. Currently used for the DATE internal command.
 38319                                  
 38320                                  PARSE_DATE:
 38321 000084E7 [EA84]                  	dw	DATE_PARMS			;AN000;
 38322 000084E9 00                      	db	0				;AN000;  no extra delimiter
 38323                                  DATE_PARMS:
 38324 000084EA 0001                    	db	0,1				;AN000;  1 positional parm
 38325 000084EC [F084]                  	dw	DATE_CONTROL1			;AN000;
 38326 000084EE 00                      	db	0				;AN000;  no switches
 38327 000084EF 00                      	db	0				;AN000;  no keywords
 38328                                  
 38329                                  DATE_CONTROL1:
 38330 000084F0 0110                    	dw	1001h				;AN000;  date - optional
 38331 000084F2 0000                    	dw	0				;AN000;  no function flags
 38332 000084F4 [D395]                  	dw	DATE_OUTPUT			;AN000;  result buffer
 38333 000084F6 [7B84]                  	dw	NO_VALUES			;AN000;
 38334 000084F8 00                      	db	0				;AN000;  no keywords
 38335                                  
 38336                                  ; PARSE BLOCK FOR TIME
 38337                                  
 38338                                  ; The following parse control block can be used for any command which
 38339                                  ; needs only an optional time string as an operand. Returns unverified
 38340                                  ; result in TIME_OUTPUT. Currently used for the TIME internal command.
 38341                                  
 38342                                  PARSE_TIME:
 38343 000084F9 [FC84]                  	dw	TIME_PARMS			;AN000;
 38344 000084FB 00                      	db	0				;AN000;  no extra delimiter
 38345                                  TIME_PARMS:
 38346 000084FC 0001                    	db	0,1				;AN000;  1 positional parm
 38347 000084FE [0285]                  	dw	TIME_CONTROL1			;AN000;
 38348 00008500 00                      	db	0				;AN000;  no switches
 38349 00008501 00                      	db	0				;AN000;  no keywords
 38350                                  
 38351                                  TIME_CONTROL1:
 38352 00008502 0108                    	dw	0801h				;AN000;  TIME - optional
 38353 00008504 0000                    	dw	0				;AN000;  no function flags
 38354 00008506 [DB95]                  	dw	TIME_OUTPUT			;AN000;  result buffer
 38355 00008508 [7B84]                  	dw	NO_VALUES			;AN000;
 38356 0000850A 00                      	db	0				;AN000;  no keywords
 38357                                  
 38358                                  ; PARSE BLOCK FOR VOL
 38359                                  
 38360                                  ; The following parse control block can be used for any command which
 38361                                  ; needs only an optional drive letter as an operand.  Returns unverified
 38362                                  ; drive number (one based) in DRIVE_OUTPUT. Currently used for the VOL
 38363                                  ; internal command.
 38364                                  
 38365                                  PARSE_VOL:
 38366 0000850B [0E85]                  	dw	VOL_PARMS			;AN000;
 38367 0000850D 00                      	db	0				;AN000;  no extra delimiter
 38368                                  VOL_PARMS:
 38369 0000850E 0001                    	db	0,1				;AN000;  1 positional parm
 38370 00008510 [1485]                  	dw	DRIVE_CONTROL1			;AN000;
 38371 00008512 00                      	db	0				;AN000;  no switches
 38372 00008513 00                      	db	0				;AN000;  no keywords
 38373                                  
 38374                                  DRIVE_CONTROL1:
 38375 00008514 0101                    	dw	0101h				;AN000;  DRIVE - optional
 38376 00008516 0100                    	dw	1				;AN000;  capitalize - file table
 38377 00008518 [E395]                  	dw	DRIVE_OUTPUT			;AN000;  result buffer
 38378 0000851A [7B84]                  	dw	NO_VALUES			;AN000;
 38379 0000851C 00                      	db	0				;AN000;  no keywords
 38380                                  
 38381                                  ; PARSE BLOCK FOR MKDIR, RMDIR, TYPE
 38382                                  
 38383                                  ; The following parse control block can be used for any command which
 38384                                  ; needs only one required file specification as an operand. Returns a
 38385                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38386                                  ; for the MKDIR, RMDIR, and TYPE internal commands.
 38387                                  
 38388                                  PARSE_MRDIR:
 38389 0000851D [2085]                  	dw	MRDIR_PARMS			;AN000;
 38390 0000851F 00                      	db	0				;AN000;  no extra delimiter
 38391                                  MRDIR_PARMS:
 38392 00008520 0101                    	db	1,1				;AN000;  1 positional parm
 38393 00008522 [7E84]                  	dw	FILE_REQUIRED			;AN000;
 38394 00008524 00                      	db	0				;AN000;  no switches
 38395 00008525 00                      	db	0				;AN000;  no keywords
 38396                                  
 38397                                  ; PARSE BLOCK FOR CHDIR, TRUENAME
 38398                                  
 38399                                  ; The following parse control block can be used for any command which
 38400                                  ; needs only one optional file specification an operand. Returns a
 38401                                  ; pointer to the unverified string in PARSE1_OUTPUT. Currently used
 38402                                  ; for the CHDIR and TRUENAME internal commands.
 38403                                  
 38404                                  PARSE_CHDIR:
 38405 00008526 [2985]                  	dw	CHDIR_PARMS			;AN000;
 38406 00008528 00                      	db	0				;AN000;  no extra delimiter
 38407                                  CHDIR_PARMS:
 38408 00008529 0001                    	db	0,1				;AN000;  1 positional parm
 38409 0000852B [8784]                  	dw	FILE_OPTIONAL			;AN000;
 38410 0000852D 00                      	db	0				;AN000;  no switches
 38411 0000852E 00                      	db	0				;AN000;  no keywords
 38412                                  
 38413                                  ; PARSE BLOCK FOR ERASE
 38414                                  
 38415                                  ; The following parse control block is used for the DEL/ERASE internal
 38416                                  ; commands. This command has one required file specification and an
 38417                                  ; optional switch (/p) as operands. The verified switch or unverified
 38418                                  ; file specification is returned in PARSE1_OUTPUT.
 38419                                  
 38420                                  PARSE_ERASE:
 38421 0000852F [3285]                  	dw	ERASE_PARMS			;AN000;
 38422 00008531 00                      	db	0				;AN000;  no extra delimiter
 38423                                  
 38424                                  ERASE_PARMS:
 38425 00008532 0101                    	db	1,1				;AN000;  1 positional parm
 38426 00008534 [7E84]                  	dw	FILE_REQUIRED			;AN000;
 38427 00008536 01                      	db	1				;AN000;  1 switch
 38428 00008537 [9984]                  	dw	SLASH_P_SWITCH			;AN000;
 38429 00008539 00                      	db	0				;AN000;  no keywords
 38430                                  
 38431                                  ; PARSE BLOCK FOR DIR
 38432                                  
 38433                                  ; The following parse control block is used for the DIR internal command.
 38434                                  ; This command has one optional file specification and several optional
 38435                                  ; switches. Switches, switch values, and the filespec are returned in 
 38436                                  ; PARSE1_OUTPUT.
 38437                                  ;
 38438                                  ; Switches are /a[value], /-a, /o[value], /-o, /s, /-s, /?, /b, /-b,
 38439                                  ; /w, /-w, /p, and /-p. The string values for /a and /o are optional,
 38440                                  ; do not require colons, and are not checked against a value list.
 38441                                  ;
 38442                                  ; Switch /h has been removed from the DIR command	;M008
 38443                                  ; Switch /? is no longer handled internally		;M008
 38444                                  ;
 38445                                  ; A list of pointers to all the switch synonyms is provided here to
 38446                                  ; help identify which switch has been matched.
 38447                                  
 38448                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38449                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8815h
 38450                                  
 38451                                  PARSE_DIR:
 38452 0000853A [3D85]                  	dw	DIR_PARMS
 38453 0000853C 00                      	db	0			; no extra delimiters
 38454                                  DIR_PARMS:
 38455 0000853D 0001                    	db	0,1			; 1 optional positional param
 38456 0000853F [9084]                  	dw	FILE_OPTIONAL2
 38457 00008541 02                      	db	2			; 2 kinds of switches
 38458 00008542 [4785]                  	dw	DIR_SW_VALUED
 38459 00008544 [5685]                  	dw	DIR_SW_UNVALUED
 38460 00008546 00                      	db	0			; no keywords
 38461                                  
 38462                                  DIR_SW_VALUED:
 38463 00008547 0120                    	dw	2001h			; optional string value
 38464 00008549 2100                    	dw	21h			; optional colon; capitalize 
 38465 0000854B [CB95]                  	dw	PARSE1_OUTPUT		; result buffer
 38466 0000854D [7D84]                  	dw	NULL_VALUE_LIST		; don't validate value
 38467                                  
 38468 0000854F 02                      	db	2
 38469                                  
 38470                                  ; MSDOS 6.0 COMMAND.COM
 38471                                  ;ifdef DBLSPACE_HOOKS
 38472                                  ;	db	3		; 3 'synonyms'
 38473                                  ;else
 38474                                  ;	db	2		; 2 'synonyms'
 38475                                  ;endif
 38476                                  
 38477                                  DIR_SW_A:
 38478 00008550 2F4100                  	db	"/A",0
 38479                                  DIR_SW_O:
 38480 00008553 2F4F00                  	db	"/O",0
 38481                                  
 38482                                  ; MSDOS 6.0 COMMAND.COM
 38483                                  ;ifdef DBLSPACE_HOOKS
 38484                                  ;DIR_SW_C	db	"/C",0
 38485                                  ;endif
 38486                                  
 38487                                  DIR_SW_UNVALUED:
 38488 00008556 0000                    	dw	0			; no value
 38489 00008558 0000                    	dw	0			; no format functions
 38490 0000855A [CB95]                  	dw	PARSE1_OUTPUT		; result buffer
 38491 0000855C [7B84]                  	dw	NO_VALUES
 38492                                  
 38493                                  	; 15/04/2023 - Retro DOS v4.0 COMMAND.COM
 38494                                  	;db	12
 38495                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8839h
 38496 0000855E 0E                      	db	14		; 14 'synonyms' !?
 38497                                  
 38498                                  ; MSDOS 6.0 COMMAND.COM
 38499                                  ;ifdef DBLSPACE_HOOKS
 38500                                  ;	db	13		; 13 'synonyms'
 38501                                  ;else
 38502                                  ;	db	12		; 12 'synonyms'
 38503                                  ;endif
 38504                                  
 38505                                  DIR_SW_NEG_A:
 38506 0000855F 2F2D4100                	db	"/-A",0
 38507                                  DIR_SW_NEG_O:
 38508 00008563 2F2D4F00                	db	"/-O",0
 38509                                  DIR_SW_S:
 38510 00008567 2F5300                  	db	"/S",0
 38511                                  DIR_SW_NEG_S:
 38512 0000856A 2F2D5300                	db	"/-S",0
 38513                                  DIR_SW_B:
 38514 0000856E 2F4200                  	db	"/B",0
 38515                                  DIR_SW_NEG_B:
 38516 00008571 2F2D4200                	db	"/-B",0
 38517                                  DIR_SW_W:
 38518 00008575 2F5700                  	db	"/W",0
 38519                                  DIR_SW_NEG_W:
 38520 00008578 2F2D5700                	db	"/-W",0
 38521                                  DIR_SW_P:
 38522 0000857C 2F5000                  	db	"/P",0
 38523                                  DIR_SW_NEG_P:
 38524 0000857F 2F2D5000                	db	"/-P",0
 38525                                  DIR_SW_L:
 38526 00008583 2F4C00                  	db	"/L",0		;M010
 38527                                  DIR_SW_NEG_L:
 38528 00008586 2F2D4C00                	db	"/-L",0 	;M010
 38529                                  ; MSDOS 6.0 COMMAND.COM (DBLSPACE_HOOKS)
 38530                                  ;DIR_SW_NEG_C:
 38531                                  ;	db	"/-C",0
 38532                                  
 38533                                  ; Here's a list of pointers to DIR's switch synonyms, for easier
 38534                                  ; identification. Order is critical - DIR routines rely on the
 38535                                  ; specific order in this list. Negated options appear at odd 
 38536                                  ; positions in the list, and simple on/off options appear first.
 38537                                  
 38538                                  Dir_Sw_Ptrs:
 38539                                  	; MSDOS 5.0 COMMAND.COM
 38540 0000858A [7885]                  	dw	DIR_SW_NEG_W 
 38541                                  Dir_Sw_Ptrs_2:			; list of ptrs to switch synonyms
 38542                                  	; MSDOS 6.0 COMMAND.COM
 38543                                  	;dw	DIR_SW_NEG_C
 38544                                  	;dw	DIR_SW_C
 38545                                  	;dw	DIR_SW_NEG_W
 38546                                  	
 38547 0000858C [7585]                  	dw	DIR_SW_W
 38548 0000858E [7F85]                  	dw	DIR_SW_NEG_P
 38549 00008590 [7C85]                  	dw	DIR_SW_P
 38550 00008592 [6A85]                  	dw	DIR_SW_NEG_S
 38551 00008594 [6785]                  	dw	DIR_SW_S
 38552 00008596 [7185]                  	dw	DIR_SW_NEG_B
 38553 00008598 [6E85]                  	dw	DIR_SW_B
 38554 0000859A [8685]                  	dw	DIR_SW_NEG_L	;M010
 38555 0000859C [8385]                  	dw	DIR_SW_L	;M010
 38556 0000859E [6385]                  	dw	DIR_SW_NEG_O
 38557 000085A0 [5385]                  	dw	DIR_SW_O
 38558 000085A2 [5F85]                  	dw	DIR_SW_NEG_A
 38559 000085A4 [5085]                  	dw	DIR_SW_A
 38560                                  
 38561                                  ; PARSE BLOCK FOR RENAME
 38562                                  
 38563                                  ; The following parse control block can be used for any command which
 38564                                  ; needs only two required file specifications as operands. Returns
 38565                                  ; pointers to the unverified string in PARSE1_OUTPUT.
 38566                                  ; Currently used for the RENAME internal command.
 38567                                  
 38568                                  PARSE_RENAME:
 38569 000085A6 [A985]                  	dw	RENAME_PARMS		;AN000;
 38570 000085A8 00                      	db	0			;AN000;  no extra delimiter
 38571                                  RENAME_PARMS:
 38572 000085A9 0202                    	db	2,2			;AN000;  2 positional parms
 38573 000085AB [7E84]                  	dw	FILE_REQUIRED		;AN000;
 38574 000085AD [7E84]                  	dw	FILE_REQUIRED		;AN000;
 38575 000085AF 00                      	db	0			;AN000;  no switches
 38576 000085B0 00                      	db	0			;AN000;  no keywords
 38577                                  
 38578                                  ; PARSE BLOCK FOR CTTY
 38579                                  
 38580                                  ; The following parse control block can be used for any command which
 38581                                  ; needs one required device name as an operand. Returns a pointer to
 38582                                  ; unverified string in PARSE1_OUTPUT. Currently used for the CTTY
 38583                                  ; internal command.
 38584                                  
 38585                                  PARSE_CTTY:
 38586 000085B1 [B485]                  	dw	CTTY_PARMS		;AN000;
 38587 000085B3 00                      	db	0			;AN000;  no extra delimiter
 38588                                  CTTY_PARMS:
 38589 000085B4 0101                    	db	1,1			;AN000;  1 positional parm
 38590 000085B6 [BA85]                  	dw	CTTY_CONTROL1		;AN000;
 38591 000085B8 00                      	db	0			;AN000;  no switches
 38592 000085B9 00                      	db	0			;AN000;  no keywords
 38593                                  CTTY_CONTROL1:
 38594 000085BA 0020                    	dw	2000h			;AN000;  string value - required
 38595 000085BC 1100                    	dw	11h			;AN000;  capitalize - file table
 38596                                  					;AN000;  remove colon at end
 38597 000085BE [CB95]                  	dw	PARSE1_OUTPUT		;AN000;  result buffer
 38598 000085C0 [7B84]                  	dw	NO_VALUES		;AN000;
 38599 000085C2 00                      	db	0			;AN000;  no keywords
 38600                                  
 38601                                  ; PARSE BLOCK FOR VER
 38602                                  
 38603                                  ; The following parse control block can be used for any command which
 38604                                  ; needs an optional switch "/debug". Currently used for the VER command.
 38605                                  
 38606                                  PARSE_VER:
 38607 000085C3 [C685]                  	dw	VER_PARMS
 38608 000085C5 00                      	db	0			; no extra delimiters
 38609                                  VER_PARMS:
 38610 000085C6 0000                    	db	0,0			; no positional parameters
 38611 000085C8 01                      	db	1			; one switch
 38612 000085C9 [CC85]                  	dw	SLASH_R
 38613 000085CB 00                      	db	0			; no keywords
 38614                                  SLASH_R:
 38615 000085CC 0000                    	dw	0			; no values
 38616 000085CE 0200                    	dw	2			; capitalize by filename table
 38617 000085D0 [CB95]                  	dw	PARSE1_OUTPUT		; result buffer
 38618 000085D2 [7B84]                  	dw	NO_VALUES		; no values
 38619 000085D4 01                      	db	1			; one synonym
 38620                                  SLASH_R_SYN:
 38621 000085D5 2F5200                  	db	"/R",0
 38622                                  
 38623                                  ; M003 ; Start of changes for LoadHigh support
 38624                                  
 38625                                  ;Parse Control Block for LOADHIGH command
 38626                                  
 38627                                  Parse_LoadHi:
 38628 000085D8 [DB85]                  	dw	LoadHi_Parms		;extended parm table
 38629 000085DA 00                      	db	0			;no extra delimiters
 38630                                  
 38631                                  LoadHi_Parms:
 38632 000085DB 0101                    	db	1,1			;min. 1 parm, max. 1 parm
 38633 000085DD [7E84]                  	dw	FILE_REQUIRED		;control struc for filename
 38634 000085DF 00                      	db	0			;no switches
 38635 000085E0 00                      	db	0			;no keywords
 38636                                  
 38637                                  ; M003 ; End of changes for LoadHigh support
 38638                                  
 38639                                  TempVarName:
 38640 000085E1 54454D503D00            	db	"TEMP=",0
 38641                                  
 38642                                  	; 16/04/2023
 38643                                  TRANDATAEND:		; TRANGROUP:88C2h
 38644                                  
 38645                                  ;============================================================================
 38646                                  ; PSDATA.INC, MSDOS 6.0, 1991
 38647                                  ;============================================================================
 38648                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38649                                  
 38650                                  ; 18/04/2023
 38651                                  TRANSPACESTART:
 38652                                  
 38653                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:88C2h
 38654                                  
 38655                                  ;********************** Local Data *************************************
 38656                                  
 38657                                  $P_ORDINAL:
 38658 000085E7 0000                    	dw	0		;AN000; Operand ordinal save area
 38659                                  $P_RC:
 38660 000085E9 0000                    	dw	0		;AN000; Return code from parser
 38661                                  $P_SI_Save:
 38662 000085EB 0000                    	dw	0		;AN000; Pointer of command buffer
 38663                                  $P_DX:
 38664 000085ED 0000                    	dw	0		;AN000; Return result buffer address
 38665                                  $P_Terminator:
 38666 000085EF 00                      	db	0		;AN000; Terminator code (ASCII)
 38667                                  $P_DBCSEV_OFF:
 38668 000085F0 0000                    	dw	0		;AN000; Offset of DBCS EV
 38669                                  $P_DBCSEV_SEG:
 38670 000085F2 0000                    	dw	0		;AN000; Segment of DBCS EV
 38671                                  $P_Flags:			;AN000; Parser internal flags
 38672                                  $P_Flags1:
 38673 000085F4 00                      	db	0		;AN038; to reference first byte flags
 38674                                  $P_Flags2:
 38675 000085F5 00                      	db	0		;AN038; to reference second byte flags only
 38676                                  $P_SaveSI_Cmpx:
 38677 000085F6 0000                    	dw	0		;AN000; save si for later use by complex
 38678                                  $P_KEYorSW_Ptr:
 38679 000085F8 0000                    	dw	0		;AN000; points next to "=" or ":" code
 38680                                  $P_Save_EOB:
 38681 000085FA 0000                    	dw	0		;AN000; save pointer to EOB
 38682                                  $P_Found_SYNONYM:
 38683 000085FC 0000                    	dw	0		;AN000; es:@ points to found synonym
 38684                                  $P_STRING_BUF:
 38685 000085FE 00<rep 80h>             	times  128 db 0		;AN000; Pick a operand from command line
 38686                                  $P_ORIG_ORD:
 38687 0000867E 0000                    	dw	0		;AN039; ORIGINAL ORDINAL FROM CX
 38688                                  $P_ORIG_STACK:
 38689 00008680 0000                    	dw	0		;AN039; ORIGINAL VALUE OF STACK FROM SP
 38690                                  $P_ORIG_SI:
 38691 00008682 0000                    	dw	0		;AN039; ORIGINAL START PARSE POINTER FROM SI
 38692                                  $P_Got_Time:
 38693 00008684 00                      	db	0		;AN023; if 1, use Time delimiters
 38694                                  $P_Country_Info:
 38695 00008685 FFFF                    	dw	-1 ; 0FFFFh
 38696 00008687 00<rep 20h>             	times	32 db 0	
 38697                                  $P_1st_Val:
 38698 000086A7 0000                    	dw	0		;AN000; used when process date or time
 38699                                  $P_2nd_Val:
 38700 000086A9 0000                    	dw	0		;AN000; used when process date or time
 38701                                  $P_3rd_Val:
 38702 000086AB 0000                    	dw	0		;AN000; used when process date or time
 38703                                  $P_4th_Val:
 38704 000086AD 0000                    	dw	0		;AN000; used when process date or time
 38705                                  $P_Char_CAP_Ptr:
 38706 000086AF FF                      	db	0FFh		;AN000; info id
 38707 000086B0 0000                    	dw	0		;AN000; offset	of char case map table
 38708 000086B2 0000                    	dw	0		;AN000; segment of char case map table
 38709                                  $P_File_CAP_Ptr:
 38710 000086B4 FF                      	db	0FFh		;AN000; info id
 38711 000086B5 0000                    	dw	0		;AN000; offset	of file case map table
 38712 000086B7 0000                    	dw	0		;AN000; segment of file case map table
 38713                                  
 38714                                  	; 18/04/2023
 38715                                  ;M029
 38716                                  ;!!!WARNING!!!
 38717                                  ; In routine SYSPARSE (parse.asm), $P_FileSp_Char is reinitialized using 
 38718                                  ;hardcoded strings. If the chars in the string are changed here, corresponding
 38719                                  ;changes need to be made in SYSPARSE
 38720                                  
 38721                                  $P_FileSp_Char:
 38722 000086B9 5B5D7C3C3E2B3D3B22      	db	'[]|<>+=;"'     ;AN000; delimitter of file spec
 38723                                  $P_FileSp_Len equ $-$P_FileSp_Char ;AN000;
 38724                                  
 38725                                  ;filespec error flag
 38726                                  $P_err_flag:
 38727 000086C2 00                      	db	0		;AN033; flag set if filespec parsing error
 38728                                  				;AN033;  was detected.
 38729                                  
 38730                                  ;============================================================================
 38731                                  ; MSGSERV.ASM, MSDOS 6.0, 1991
 38732                                  ;============================================================================
 38733                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38734                                  
 38735                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:899Eh
 38736                                  
 38737                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 38738                                  ;;
 38739                                  ;; STRUCTURE: $M_RES_ADDRS
 38740                                  ;;
 38741                                  ;; Resident data area definition of variables
 38742                                  ;;
 38743                                  ;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;;
 38744                                  
 38745                                  $M_RT:
 38746 000086C3 00<rep 8Dh>             	times $M_RES_ADDRS_SZ db 0   ; times 141 db 0
 38747                                  
 38748                                  ;============================================================================
 38749                                  ; COPYRIGHT.INC, MSDOS 6.0, 1993
 38750                                  ;============================================================================
 38751                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38752                                  
 38753                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:8A2Bh
 38754                                  ; ---------------------------------------------------------------------------
 38755                                  ;;M00 - changed to DOS 5.0 copyright - MD 9 Jul 90
 38756                                  ;;M031 - changed copyright to 1991
 38757                                  ;;9/16 - changed verison to 6.0 and copyright to 1992
 38758                                  ;;9/21 - Added international translations, language passed through COUNTRY macro
 38759                                  ;;B49,50 - changed version to 6 and copyright to 1993
 38760                                  ; ---------------------------------------------------------------------------
 38761                                  
 38762                                  ;;ifdef USA
 38763                                  ;MsDosVer6_CCopy:
 38764                                  ;	db	"MS DOS Version 6 (C)Copyright 1981-1993 Microsoft Corp "
 38765                                  ;	db	"Licensed Material - Property of Microsoft "
 38766                                  ;	db	"All rights reserved "
 38767                                  ;endif
 38768                                  
 38769                                  ; 15/04/2023
 38770                                  MsDosVer5_CCopy:
 38771 00008750 4D5320444F53205665-     	db	"MS DOS Version 5.00 (C)Copyright 1981-1991 Microsoft Corp "
 38771 00008759 7273696F6E20352E30-
 38771 00008762 3020284329436F7079-
 38771 0000876B 726967687420313938-
 38771 00008774 312D31393931204D69-
 38771 0000877D 63726F736F66742043-
 38771 00008786 6F727020           
 38772 0000878A 4C6963656E73656420-     	db	"Licensed Material - Property of Microsoft "
 38772 00008793 4D6174657269616C20-
 38772 0000879C 2D2050726F70657274-
 38772 000087A5 79206F66204D696372-
 38772 000087AE 6F736F667420       
 38773 000087B4 416C6C207269676874-     	db	"All rights reserved "
 38773 000087BD 732072657365727665-
 38773 000087C6 6420               
 38774                                  ; ---------------------------------------------------------------------------
 38775                                  ; 15/04/2023
 38776                                  	; 16/04/2023 - 21/04/2023
 38777                                  	;db 	0
 38778                                  	;db	0Dh,0Ah
 38779                                  	;db	'Retro DOS v4.0 (& v4.1) COMMAND.COM '
 38780                                  	;db	0
 38781                                  	;db	'by Erdogan Tan - 05/05/2023'
 38782                                  	;db	0
 38783                                  
 38784                                  ;============================================================================
 38785                                  ; TPRINTF.ASM, MSDOS 6.0, 1991
 38786                                  ;============================================================================
 38787                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 38788                                  
 38789                                  PRINTF_HANDLE:
 38790 000087C8 0000                    	dw	0		;AC000;
 38791                                  
 38792                                  ; 15/047/2023
 38793                                  %if 0
 38794                                  
 38795                                  ;============================================================================
 38796                                  ; TSPC.ASM, MSDOS 6.0, 1991
 38797                                  ;============================================================================
 38798                                  ; 29/09/2018 - Retro DOS v3.0
 38799                                  
 38800                                  ;TITLE	COMMAND Transient Uninitialized DATA
 38801                                  
 38802                                  ;The TRANSPACE segment contains variable data that is considered
 38803                                  ;volatile between command cycles, and therefore is not included in the
 38804                                  ;transient checksum area. Contents of these variables MUST be
 38805                                  ;initialized before use, and must not be relied upon from command
 38806                                  ;cycle to command cycle.
 38807                                  ;
 38808                                  ;No constant data values should be stored here.
 38809                                  
 38810                                  ; ---------------------------------------------------------------------------
 38811                                  ; START OF UNITIALIZED DATA
 38812                                  ; ---------------------------------------------------------------------------
 38813                                  
 38814                                  ;	times 12 db 0
 38815                                  
 38816                                  align 16
 38817                                  
 38818                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3F50h
 38819                                  
 38820                                  PRINTF_LEFT:	db 0
 38821                                  PRINTF_LONG:	db 0
 38822                                  PRINTF_HEX:	db 0
 38823                                  TABLE_INDEX:	db 0
 38824                                  PRINTF_WIDTH:	dw 0
 38825                                  PRINTF_BASE:	dw 0
 38826                                  PAD_CHAR:	db 0
 38827                                  PRINTF_HANDLE:	dw 0
 38828                                  PRINTF_BUF: times 100 db 0
 38829                                  PRINTF_BUF_END: ; 30/09/2018
 38830                                  
 38831                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 3FBFh
 38832                                  
 38833                                  SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 38834                                  TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 38835                                  UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 38836                                  COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 38837                                  USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 38838                                  EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 38839                                  RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 38840                                  
 38841                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 38842                                  HEADCALL:	dw 0			; TRANVARS  (dw THEADFIX)
 38843                                  RESSEG:		dw 0			; MYSEG     (dw 0) 	 	
 38844                                  TPA:		dw 0			; LTPA	    (dw 0)	
 38845                                  SWITCHAR:	db 0			; RSWITCHAR (db '-')
 38846                                  DIRCHAR:	db 0			; RDIRCHAR  (db '/')
 38847                                  EXEC_ADDR:	dd 0			; 	    (dw EXT_EXEC)	 
 38848                                  					; MYSEG1    (dw 0)	
 38849                                  RCH_ADDR:	dd 0			;	    (dw TREMCHECK) 	
 38850                                  					; MYSEG2    (dw 0)	
 38851                                  		dw 0			; RESTEST   (dw 0)	
 38852                                  TRAN_TPA:	dw 0			; RES_TPA   (dw 0)	
 38853                                  
 38854                                  CHKDRV:		db 0
 38855                                  IFNOTFLAG:
 38856                                  FILTYP:
 38857                                  RDEOF:		db 0			; Misc flags
 38858                                  CURDRV:		db 0
 38859                                  PARM1:
 38860                                  Concat:		db 0
 38861                                  PARM2:
 38862                                  ArgC:		db 0
 38863                                  COMSW:		dw 0			; Switches between command and 1st arg
 38864                                  ARG1S:		dw 0			; Switches between 1st and 2nd arg
 38865                                  ARG2S:					; Switches after 2nd arg		
 38866                                  DestSwitch:	dw 0
 38867                                  ARGTS:
 38868                                  AllSwitch:	dw 0			; ALL switches except for COMSW
 38869                                  CFLAG:		db 0
 38870                                  DestClosed:
 38871                                  SPECDRV:	db 0
 38872                                  BYTCNT:		dw 0			; Size of buffer between RES and TRANS
 38873                                  NXTADD:		dw 0
 38874                                  FRSTSRCH:	db 0
 38875                                  ;LeftOnLine:	db 0			; entries left on line u.b. DIR
 38876                                  ;PerLine:	db 0			; entries/line u.b. DIR
 38877                                  LINCNT:		db 0
 38878                                  LINLEN:		db 0
 38879                                  ;LeftOnPage:	dw 0			; lines left on page u.b. DIR
 38880                                  FILECNT:	dw 0			; file count u.b. DIR
 38881                                  ;FileSiz:	dd 0			; file size u.b. DIR
 38882                                  
 38883                                  ;		Note:  keep FileCntTotal through csecUsedTotal together!
 38884                                  ;
 38885                                  ;FileCntTotal:	dd 0			; total file count u.b. DIR
 38886                                  ;FileSizTotal:	dd 0			; total file size u.b. DIR
 38887                                  
 38888                                  	; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 42BBh
 38889                                  
 38890                                  CHARBUF:  times	80 db 0			;line byte character buffer for xenix write
 38891                                  DESTFCB2:
 38892                                  IDLEN:		db 0
 38893                                  ID:	  times	8  db 0
 38894                                  COM:	  times	3  db 0 
 38895                                  DEST:	  times 37 db 0
 38896                                  DESTNAME: times 11 db 0
 38897                                  DESTDIR:
 38898                                  DestFcb:  times DIRSTRLEN db 0 ; 67	; Directory for PATH searches
 38899                                  GOTOLEN:	; word
 38900                                  BWDBUF: 	; byte
 38901                                  EXEFCB: 	; word
 38902                                  DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 38903                                  
 38904                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 38905                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 38906                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 38907                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 38908                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 38909                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 38910                                  
 38911                                  SDIRBUF:  times 12 db 0	
 38912                                  _BITS:		dw 0
 38913                                  PATHCNT:	dw 0
 38914                                  PATHPOS:	dw 0
 38915                                  PATHSW:		dw 0
 38916                                  ;AttrSpecified:	db 0			; attribute bits u.b. DIR
 38917                                  ;AttrSelect:	db 0			; attribute bits u.b. DIR
 38918                                  LINPERPAG:	db 0
 38919                                  		db 0
 38920                                  COMMA:		db 0			; flag set if +,, occurs
 38921                                  PLUS_COMMA:	db 0			; flag set if +,, occurs
 38922                                  
 38923                                  ;dirflag: 	db 0			;AN015; set when pathcrunch called from DIR
 38924                                  ;parse_last:	dw 0			;AN018; used to hold parsing position
 38925                                  ;system_cpage:	dw 0			;AC001; used for CHCP variable
 38926                                  
 38927                                  ARG_BUF:  times 128 db 0   ; _43E8h	
 38928                                  STRING_PTR_1:	dw 0	   ; _4468h	
 38929                                  FILESIZE_L:	dw 0	   ; _446Ah		
 38930                                  FILESIZE_H:	dw 0	   ; _446Ch	
 38931                                  STRING_PTR_2:	dw 0	   ; _446Eh	
 38932                                  
 38933                                  COPY_NUM:	dw 0
 38934                                  	  times 4 db 0 ; MSDOS 3.3 (unused bytes)
 38935                                  CPYFLAG:	db 0
 38936                                  DIR_NUM:	dw 0
 38937                                  BYTES_FREE:	dw 0
 38938                                  		dw 0
 38939                                  MAJOR_VER_NUM:	dw 0
 38940                                  MINOR_VER_NUM:	dw 0
 38941                                  ONE_CHAR_VAL:	db 0
 38942                                  		;db 0
 38943                                  VOLNAME_ADDR:	dw 0 ; MSDOS 3.3
 38944                                  VOL_DRV:	db 0
 38945                                  VOL_DIR:	dw 0 ; MSDOS 3.3
 38946                                  
 38947                                  ROM_CALL:	db 0			; flag for rom function
 38948                                  ROM_IP:		dw 0
 38949                                  ROM_CS:		dw 0
 38950                                  
 38951                                  DestVars:
 38952                                  DestIsDir:	db 0
 38953                                  DestSiz:	db 0
 38954                                  DestTail:	dw 0
 38955                                  DestInfo:	db 0
 38956                                  DESTBUF:  times	DIRSTRLEN+20 db 0 ; 87
 38957                                  ENDDESTBUF:
 38958                                  
 38959                                  DESTHAND:	dw 0
 38960                                  DESTISDEV:	db 0
 38961                                  FIRSTDEST:	db 0
 38962                                  MELCOPY:	db 0
 38963                                  MELSTART:	dw 0
 38964                                  
 38965                                  SrcVars:
 38966                                  SrcIsDir:	db 0
 38967                                  SrcSiz:		db 0
 38968                                  SrcTail:	dw 0
 38969                                  SrcInfo:	db 0
 38970                                  SrcBuf:   times	DIRSTRLEN+20 db 0 ; 87
 38971                                  
 38972                                  SRCHAND:	dw 0
 38973                                  SRCISDEV:	db 0
 38974                                  
 38975                                  SCANBUF:  times DIRSTRLEN+20 db 0 ; 87
 38976                                  
 38977                                  SRCPT:		dw 0
 38978                                  INEXACT:	db 0
 38979                                  		db 0 ; MSDOS 3.3 
 38980                                  NOWRITE:	db 0
 38981                                  BINARY:		db 0
 38982                                  WRITTEN:	dw 0
 38983                                  TERMREAD:	db 0
 38984                                  ASCII:		db 0
 38985                                  PLUS:		db 0
 38986                                  OBJCNT:		db 0			; Used in copy
 38987                                  CPDATE:		dw 0
 38988                                  CPTIME:		dw 0
 38989                                  
 38990                                  ;OFilePtr_Lo:	dw 0			; original file ptr for COPY when
 38991                                  ;OFilePtr_Hi:	dw 0			; 1st source is also destination
 38992                                  ;OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 38993                                  
 38994                                  BATHAND:	dw 0			; Batch handle
 38995                                  STARTEL:	dw 0
 38996                                  ELCNT:		db 0
 38997                                  ELPOS:		db 0
 38998                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 38999                                  MSDOS 5.0
 39000                                  SKPDEL:
 39001                                  SOURCE:   times	11 db 0
 39002                                  
 39003                                  ext_entered:	db 0			;AN005;
 39004                                  
 39005                                  ;display_ioctl	db 0			;AN000; info level
 39006                                  ;		db 0			;AN000; reserved
 39007                                  ;		dw crt_ioctl_ln		;AN000; length of data
 39008                                  ;		dw 0			;AN000; control flags
 39009                                  ;display_mode:	db 0			;AN000; display mode, colors
 39010                                  ;		db 0			;AN000; reserved
 39011                                  ;		dw 0			;AN023; colors
 39012                                  ;		dw 0			;AN000; display width (PELS)
 39013                                  ;		dw 0			;AN000; display length (PELS)
 39014                                  ;display_width:	dw 0			;AN000; display width
 39015                                  ;linperpag:	dw linesperpage		;AN000; display length (default to linesperpage)
 39016                                  ;
 39017                                  ;vol_ioctl_buf:				;AN000; buffer for ioctl volume label/serial call
 39018                                  ;		dw 0			;AN000; info level
 39019                                  ;vol_serial:	dd 0			;AN000; volume serial number
 39020                                  ;vol_label: times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39021                                  ;	    times 8  db 20h ; " "       ;AN000; file system type
 39022                                  
 39023                                  EXPAND_STAR:	db 0
 39024                                  
 39025                                  ;msg_flag:	db 0			;AN022; flag set if non-utility message issued
 39026                                  ;msg_numb:	dw 0			;AN022; set with extended error message issued
 39027                                  ;append_exec:	db 0			;AN041; set if internal append executed
 39028                                  ;print_err_flag: dw 0			;AN000; flag set if error during sysdispmsg
 39029                                  ;subst_buffer: times parm_block_size*2 db 0 ;AN061;
 39030                                  
 39031                                  COMSPEC_FLAG:	db 0 ; MSDOS 3.3
 39032                                  
 39033                                  ; Data declarations taken out of parse.asm
 39034                                  
 39035                                  ; MSDOS 6.0
 39036                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39037                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39038                                  ;tpbuf		db	128   DUP (?)	; temporary buffer
 39039                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39040                                  ;comptr		dw	?		; ptr into combuf
 39041                                  
 39042                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 45C9h
 39043                                  ARG:
 39044                                  ARG_ARGV:
 39045                                  ARGV0_ARGPOINTER: dw 0	; ARGV[0]
 39046                                  ARGV0_ARG_FLAGS:  db 0
 39047                                  ARGV0_ARGSTARTEL: dw 0
 39048                                  ARGV0_ARGLEN:	  dw 0
 39049                                  ARGV0_ARGSW_WORD: dw 0
 39050                                  ARGV0_OCOMPTR:	  dw 0
 39051                                  
 39052                                  ARGV1_ARGPOINTER: dw 0	; ARGV[1]	
 39053                                  	  times 5 db 0
 39054                                  ARGV1_ARGSW_WORD: dw 0
 39055                                  		  dw 0
 39056                                  
 39057                                  ARGV2_ARGPOINTER: dw 0	; ARGV[2]
 39058                                  	  times 5 db 0
 39059                                  ARGV2_ARGSW_WORD: dw 0
 39060                                  		  dw 0
 39061                                  
 39062                                  	times 671 db 0  ; ARGV[3] to ARGV[63]
 39063                                  	
 39064                                  ARG_ARGVCNT:	dw 0
 39065                                  ARG_ARGSWINFO:	dw 0
 39066                                  
 39067                                  ARG_ARGBUF:    	times 256 dw 0	; times ARGBLEN dw 0 
 39068                                  ARG_ARGFORCOMBUF: times 128 db 0  ; times COMBUFLEN db 0 
 39069                                  
 39070                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B0Dh
 39071                                  
 39072                                  ARGBUFPTR:	dw 0			; index for argv[].argpointer
 39073                                  TPBUF:    times 128 db 0		; temporary buffer
 39074                                  LASTARG:	dw 0			; point at which to accumulate switch info
 39075                                  COMPTR:		dw 0			; ptr into combuf
 39076                                  
 39077                                  ; Data declarations taken out of path.asm
 39078                                  ;fbuf	find_buf	<>			; dma buffer for findfirst/findnext
 39079                                  ;pathinfo	DW	3 DUP (?)		; ES, SI(old), and SI(new) of user path
 39080                                  ;psep_char	DB	?			; '/' or '\'
 39081                                  ;search_best	DB	(?)			; best code, best filename so far
 39082                                  ;fname_max_len	equ	13
 39083                                  ;search_best_buf DB	fname_max_len DUP (?)
 39084                                  ;search_curdir_buf DB	64 DUP (?)		; a place for CurDir info, if successful
 39085                                  ;search_error	DW	(?)			; address of error message to be printed
 39086                                  
 39087                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39088                                  
 39089                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4B93h
 39090                                  
 39091                                  FBUF:	  times	FINDBUFLEN db 0 ; times 43 db 0
 39092                                  FBUF_PNAME equ FBUF+30			; packed name, 13 bytes
 39093                                  PATHINFO:
 39094                                  PATHINFO_0:	dw 0
 39095                                  PATHINFO_2:	dw 0
 39096                                  PATHINFO_4:	dw 0
 39097                                  PSEP_CHAR:	db 0
 39098                                  SEARCH_BEST:	db 0
 39099                                  ;FNAME_MAX_LEN equ 13
 39100                                  SEARCH_BEST_BUF: times FNAME_MAX_LEN db 0 ; times 13 db 0
 39101                                  SEARCH_CURDIR_BUF: times 64 db 0
 39102                                  SEARCH_ERROR:	dw 0
 39103                                  
 39104                                  ; Data declarations taken out of tbatch.asm
 39105                                  
 39106                                  ;if_not_count	DW	?
 39107                                  ;
 39108                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39109                                  ;
 39110                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39111                                  
 39112                                  ; 31/03/2023
 39113                                  STACK:		;LABEL	WORD
 39114                                  
 39115                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4C15h
 39116                                  
 39117                                  IF_NOT_COUNT:	dw 0
 39118                                  ZFLAG:		db 0
 39119                                  	  times 256 db 0 	
 39120                                  STACK:
 39121                                  
 39122                                  ;INTERNATVARS	internat_block <>
 39123                                  ;		DB	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39124                                  ;
 39125                                  ;;		Buffer for DOS function 64h (Get extended country information)
 39126                                  ;;		subfunctions 2, 4, 6, or 7:
 39127                                  ;
 39128                                  ;CountryPtrInfo	label	byte
 39129                                  ;CountryPtrId	db	?
 39130                                  ;CountryPtr	dd	?
 39131                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 39132                                  
 39133                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D18h
 39134                                  
 39135                                  INTERNATVARS:	
 39136                                  DATE_TIME_FORMAT: dw 0			; 0-USA, 1-EUR, 2-JAP
 39137                                  CURRENCY_SYM: 	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 39138                                  THOUS_SEP:	db 0,0			; Thousands separator 2 bytes
 39139                                  DECIMAL_SEP:	db 0,0			; Decimal separator 2 bytes
 39140                                  DATE_SEP:	db 0,0			; Date separator 2 bytes
 39141                                  TIME_SEP:	db 0,0			; Time separator 2 bytes	
 39142                                  BIT_FIELD:	db 0			; Bit values
 39143                                  					;   Bit 0 = 0 if currency symbol first
 39144                                  					;	  = 1 if currency symbol last
 39145                                  					;   Bit 1 = 0 if No space after currency symbol
 39146                                  					;	  = 1 if space after currency symbol
 39147                                  CURRENCY_CENTS:	db 0			; Number of places after currency dec point
 39148                                  TIME_24:	db 0			; 1 if 24 hour time, 0 if 12 hour time
 39149                                  MAP_CALL:	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 39150                                  					; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 39151                                  					;  in pieces.
 39152                                  DATA_SEP:	db 0,0			; Data list separator character		
 39153                                  
 39154                                  		times 8 db 0
 39155                                  ;
 39156                                  ; Max size of the block returned by the INTERNATIONAL call
 39157                                  ;
 39158                                  INTERNAT_BLOCK_SIZE EQU	32
 39159                                  
 39160                                  BATLEN equ 32
 39161                                  		; MSDOS 3.3 COMMAND.COM (1987) Transient portion offset 4D38h		
 39162                                  
 39163                                  BATBUFPOS:	dw 0			; integer position in buffer of next byte
 39164                                  
 39165                                  BATBUF:	  times	BATLEN db 0 ; times 32 db 0
 39166                                  
 39167                                  BATBUFEND:	dw 0
 39168                                  
 39169                                  ;TypeFilSiz:	dd 0			; stores size of file to be typed
 39170                                  
 39171                                  TRANSPACEEND:	; 4D4Ch ; End of MSDOS 3.3 COMMAND.COM (1987) Transient portion
 39172                                  
 39173                                  ; 18/04/2023
 39174                                  ; ----------------------------------------------------------------------------
 39175                                  ; 09/01/2023
 39176                                  ;TRANSPACEEND	equ $ - TRANSIENTSTART ; 18/04/2023
 39177                                  
 39178                                  %endif
 39179                                  
 39180                                  ;============================================================================
 39181                                  ; TSPC.ASM, MSDOS 6.0, 1991
 39182                                  ;============================================================================
 39183                                  ; 15/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39184                                  
 39185                                  ;TITLE	COMMAND Transient Uninitialized DATA
 39186                                  
 39187                                  ;The TRANSPACE segment contains variable data that is considered
 39188                                  ;volatile between command cycles, and therefore is not included in the
 39189                                  ;transient checksum area. Contents of these variables MUST be
 39190                                  ;initialized before use, and must not be relied upon from command
 39191                                  ;cycle to command cycle.
 39192                                  ;
 39193                                  ;No constant data values should be stored here.
 39194                                  
 39195                                  ; ---------------------------------------------------------------------------
 39196                                  ; START OF UNITIALIZED DATA
 39197                                  ; ---------------------------------------------------------------------------
 39198                                  
 39199                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8AA5h
 39200                                  
 39201 000087CA 00<rep 57h>             SRCXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39202 00008821 00<rep 57h>             TRGXNAME: times	DIRSTRLEN+20 db 0 ; 87	; buffer for name translate
 39203 00008878 00<rep 83h>             UCOMBUF:  times COMBUFLEN+3  db 0 ; 131	; Raw console buffer
 39204 000088FB 00<rep 83h>             COMBUF:	  times COMBUFLEN+3  db 0 ; 131	; Cooked console buffer
 39205 0000897E 00<rep 46h>             USERDIR1: times	DIRSTRLEN+3  db 0 ; 70  ; Storage for users current directory
 39206 000089C4 00<rep 83h>             EXECPATH: times COMBUFLEN+3  db 0 ; 131 ; Path for external command
 39207 00008A47 00<rep 53h>             RE_INSTR: times DIRSTRLEN+16 db 0 ; 83  ; path for input to redirection
 39208                                  
 39209                                  ; Variables passed up from resident	; in the Resident portion: (initial values)	
 39210                                  HEADCALL:
 39211 00008A9A 0000                    	dw 0			; TRANVARS  (dw THEADFIX)
 39212 00008A9C 0000                    RESSEG:	dw 0			; MYSEG     (dw 0) 	 	
 39213 00008A9E 0000                    TPA:	dw 0			; LTPA	    (dw 0)	
 39214                                  SWITCHAR:
 39215 00008AA0 00                      	db 0			; RSWITCHAR (db '-')
 39216                                  DIRCHAR:
 39217 00008AA1 00                      	db 0			; RDIRCHAR  (db '/')
 39218                                  EXEC_ADDR:
 39219 00008AA2 00000000                	dd 0			; 	    (dw EXT_EXEC)	 
 39220                                  				; MYSEG1    (dw 0)	
 39221                                  RCH_ADDR:
 39222 00008AA6 00000000                	dd 0			;	    (dw TREMCHECK) 	
 39223                                  				; MYSEG2    (dw 0)	
 39224 00008AAA 0000                    	dw 0			; RESTEST   (dw 0)	
 39225                                  TRAN_TPA:
 39226 00008AAC 0000                    	dw 0			; RES_TPA   (dw 0)	
 39227                                  
 39228 00008AAE 00                      CHKDRV:	db 0
 39229                                  IFNOTFLAG:
 39230                                  FILTYP:
 39231 00008AAF 00                      RDEOF:	db 0			; Misc flags
 39232 00008AB0 00                      CURDRV:	db 0
 39233                                  PARM1:
 39234 00008AB1 00                      Concat:	db 0
 39235                                  PARM2:
 39236 00008AB2 00                      ArgC:	db 0
 39237 00008AB3 0000                    COMSW:	dw 0			; Switches between command and 1st arg
 39238 00008AB5 0000                    ARG1S:	dw 0			; Switches between 1st and 2nd arg
 39239                                  ARG2S:				; Switches after 2nd arg		
 39240                                  DestSwitch:
 39241 00008AB7 0000                    	dw 0
 39242                                  ARGTS:
 39243                                  AllSwitch:
 39244 00008AB9 0000                    	dw 0			; ALL switches except for COMSW
 39245 00008ABB 00                      CFLAG:	db 0
 39246                                  DestClosed:
 39247                                  SPECDRV:
 39248 00008ABC 00                      	db 0
 39249 00008ABD 0000                    BYTCNT:	dw 0			; Size of buffer between RES and TRANS
 39250 00008ABF 0000                    NXTADD:	dw 0
 39251                                  FRSTSRCH:
 39252 00008AC1 00                      	db 0
 39253                                  ; 15/04/2023
 39254                                  LeftOnLine:
 39255 00008AC2 00                      	db 0			; entries left on line u.b. DIR
 39256                                  PerLine:
 39257 00008AC3 00                      	db 0			; entries/line u.b. DIR
 39258 00008AC4 00                      LINCNT:	db 0
 39259 00008AC5 00                      LINLEN:	db 0
 39260                                  LeftOnPage:
 39261 00008AC6 0000                    	dw 0			; lines left on page u.b. DIR
 39262                                  FileCnt:
 39263 00008AC8 0000                    	dw 0			; file count u.b. DIR
 39264                                  FileSiz:
 39265 00008ACA 00000000                	dd 0			; file size u.b. DIR
 39266                                  
 39267                                  ; Note: keep FileCntTotal through csecUsedTotal together!
 39268                                  
 39269                                  FileCntTotal:
 39270 00008ACE 00000000                	dd 0			; total file count u.b. DIR
 39271                                  FileSizTotal:
 39272 00008AD2 00000000                	dd 0			; total file size u.b. DIR
 39273                                  
 39274                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 8DAFh
 39275                                  CHARBUF:
 39276 00008AD6 00<rep 50h>             	times	80 db 0		;line byte character buffer for xenix write
 39277                                  DESTFCB2:
 39278 00008B26 00                      IDLEN:	db 0
 39279 00008B27 00<rep 8h>              ID:	times	8  db 0
 39280 00008B2F 00<rep 3h>              COM:	times	3  db 0 
 39281 00008B32 00<rep 25h>             DEST:	times	37 db 0
 39282                                  DESTNAME:
 39283 00008B57 00<rep Bh>              	times	11 db 0
 39284                                  DESTDIR:
 39285                                  DestFcb:
 39286 00008B62 00<rep 43h>             	times DIRSTRLEN db 0 ; 67 ; Directory for PATH searches
 39287                                  GOTOLEN: ; word
 39288                                  BWDBUF:  ; byte
 39289                                  EXEFCB:  ; word
 39290 00008BA5 00<rep 46h>             DIRBUF:	times DIRSTRLEN+3 db 0 ; 70
 39291                                  
 39292                                  DIRBUF_ATTRIB1 equ DIRBUF+19  ; byte	; INT 21h AH=11h (8+DIR_ENTRY struc)
 39293                                  DIRBUF_ATTRIB2 equ DIRBUF+21  ; byte	; INT 21h AH=4Eh (FIND_BUF struc)
 39294                                  DIRBUF_FTIME   equ DIRBUF+30  ; word
 39295                                  DIRBUF_FDATE   equ DIRBUF+32  ; word	
 39296                                  DIRBUF_FSIZ_L  equ DIRBUF+36  ; word
 39297                                  DIRBUF_FSIZ_H  equ DIRBUF+38  ; word
 39298                                  
 39299                                  	; 16/04/2023 - Retro DOS v4.0 (& v4.1) COMMAND.COM
 39300                                  SDIRBUF:
 39301 00008BEB 00<rep Ch>              	times 12 db 0	
 39302                                  _Bits:
 39303 00008BF7 0000                    	dw 0
 39304                                  PathCnt:
 39305 00008BF9 0000                    	dw 0
 39306                                  PathPos:
 39307 00008BFB 0000                    	dw 0
 39308 00008BFD 0000                    PathSw:	dw 0
 39309                                  AttrSpecified:
 39310 00008BFF 00                      	db 0			; attribute bits u.b. DIR
 39311                                  AttrSelect:
 39312 00008C00 00                      	db 0			; attribute bits u.b. DIR
 39313 00008C01 00                      comma:	db 0			; flag set if +,, occurs
 39314                                  plus_comma:
 39315 00008C02 00                      	db 0			; flag set if +,, occurs
 39316                                  DirFlag:
 39317 00008C03 00                       	db 0			;AN015; set when pathcrunch called from DIR
 39318                                  parse_last:
 39319 00008C04 0000                    	dw 0			;AN018; used to hold parsing position
 39320                                  system_cpage:
 39321 00008C06 0000                    	dw 0			;AC001; used for CHCP variable
 39322                                  Arg_Buf:
 39323 00008C08 00<rep 80h>             	times 128 db 0	
 39324                                  File_Size_Low:
 39325 00008C88 0000                    	dw 0	
 39326                                  File_Size_High:
 39327 00008C8A 0000                    	dw 0		
 39328                                  string_ptr_2:
 39329 00008C8C 0000                    	dw 0	
 39330                                  Copy_num:
 39331 00008C8E 0000                    	dw 0
 39332                                  cpyflag:
 39333 00008C90 00                      	db 0
 39334                                  Dir_Num:
 39335 00008C91 0000                    	dw 0
 39336                                  Bytes_Free:
 39337 00008C93 00000000                	dd 0
 39338                                  
 39339                                  Major_Ver_Num:
 39340 00008C97 0000                    	dw 0
 39341                                  Minor_Ver_Num:
 39342 00008C99 0000                    	dw 0
 39343                                  
 39344                                  One_Char_Val:
 39345 00008C9B 00                      	db 0
 39346 00008C9C 00                      	db 0
 39347                                  vol_drv:
 39348 00008C9D 00                      	db 0
 39349                                  ROM_CALL:
 39350 00008C9E 00                      	db 0			; flag for rom function
 39351 00008C9F 0000                    ROM_IP:	dw 0
 39352 00008CA1 0000                    ROM_CS:	dw 0
 39353                                  
 39354                                  DestVars:
 39355                                  DestIsDir:
 39356 00008CA3 00                      	db 0
 39357                                  DestSiz:
 39358 00008CA4 00                      	db 0
 39359                                  DestTail:
 39360 00008CA5 0000                    	dw 0
 39361                                  DestInfo:
 39362 00008CA7 00                      	db 0
 39363                                  DestBuf:
 39364 00008CA8 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39365                                  EndDestBuf:
 39366                                  DESTHAND:
 39367 00008CFF 0000                    	dw 0
 39368                                  DESTISDEV:
 39369 00008D01 00                      	db 0
 39370                                  FIRSTDEST:
 39371 00008D02 00                      	db 0
 39372                                  MELCOPY:
 39373 00008D03 00                      	db 0
 39374                                  MELSTART:
 39375 00008D04 0000                    	dw 0
 39376                                  SrcVars:
 39377                                  SrcIsDir:
 39378 00008D06 00                      	db 0
 39379 00008D07 00                      SrcSiz:	db 0
 39380                                  SrcTail:
 39381 00008D08 0000                    	dw 0
 39382                                  SrcInfo:
 39383 00008D0A 00                      	db 0
 39384                                  SrcBuf:
 39385 00008D0B 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39386                                  SRCHAND:
 39387 00008D62 0000                    	dw 0
 39388                                  SRCISDEV:
 39389 00008D64 00                      	db 0
 39390                                  ScanBuf:
 39391 00008D65 00<rep 57h>             	times DIRSTRLEN+20 db 0 ; 87
 39392                                  
 39393 00008DBC 0000                    SRCPT:	dw 0
 39394                                  INEXACT:
 39395 00008DBE 00                      	db 0
 39396                                  NOWRITE:
 39397 00008DBF 00                      	db 0
 39398                                  BINARY:
 39399 00008DC0 00                      	db 0
 39400                                  WRITTEN:
 39401 00008DC1 0000                    	dw 0
 39402                                  TERMREAD:
 39403 00008DC3 00                      	db 0
 39404 00008DC4 00                      ASCII:	db 0
 39405 00008DC5 00                      PLUS:	db 0
 39406 00008DC6 00                      objcnt:	db 0			; Used in copy
 39407 00008DC7 0000                    CPDATE:	dw 0
 39408 00008DC9 0000                    CPTIME:	dw 0
 39409                                  
 39410                                  OFilePtr_Lo:
 39411 00008DCB 0000                    	dw 0			; original file ptr for COPY when
 39412                                  OFilePtr_Hi:
 39413 00008DCD 0000                    	dw 0			; 1st source is also destination
 39414 00008DCF 00                      OCtrlZ:	db 0			; original ctrl+Z for COPY when ditto
 39415                                  BATHAND:
 39416 00008DD0 0000                    	dw 0			; Batch handle
 39417                                  STARTEL:
 39418 00008DD2 0000                    	dw 0
 39419 00008DD4 00                      ELCNT:	db 0
 39420 00008DD5 00                      ELPOS:	db 0
 39421                                  
 39422                                  ; 28/03/2023 - Retro DOS v4.0 COMMAND.COM
 39423                                  ; MSDOS 5.0
 39424                                  SKPDEL:
 39425 00008DD6 00<rep Bh>              SOURCE:	times 11 db 0
 39426                                  
 39427                                  ext_entered:
 39428 00008DE1 00                      	db 0			;AN005;
 39429                                  
 39430                                  ; MSDOS 5.0 COMMAND.COM - TRANGROUP:90BCh
 39431                                  
 39432                                  Display_Ioctl:
 39433 00008DE2 00                      	db 0			;AN000; info level
 39434 00008DE3 00                      	db 0			;AN000; reserved
 39435 00008DE4 0E00                    	dw crt_ioctl_ln		;AN000; length of data
 39436 00008DE6 0000                    	dw 0			;AN000; control flags
 39437                                  display_mode:
 39438 00008DE8 00                      	db 0			;AN000; display mode, colors
 39439 00008DE9 00                      	db 0			;AN000; reserved
 39440 00008DEA 0000                    	dw 0			;AN023; colors
 39441 00008DEC 0000                    	dw 0			;AN000; display width (PELS)
 39442 00008DEE 0000                    	dw 0			;AN000; display length (PELS)
 39443                                  display_width:
 39444 00008DF0 0000                    	dw 0			;AN000; display width
 39445                                  LinPerPag:
 39446 00008DF2 1900                    	dw LINESPERPAGE	; 25	;AN000; display length (default to linesperpage)
 39447                                  
 39448                                  vol_ioctl_buf:			;AN000; buffer for ioctl volume label/serial call
 39449 00008DF4 0000                    	dw 0			;AN000; info level
 39450                                  vol_serial:
 39451 00008DF6 00000000                	dd 0			;AN000; volume serial number
 39452                                  vol_label:
 39453 00008DFA 20<rep Bh>              	times 11 db 20h ; " "	;AN000; volume label - init to blanks
 39454 00008E05 20<rep 8h>              	times 8  db 20h ; " "	;AN000; file system type
 39455                                  
 39456                                  expand_star:
 39457 00008E0D 00                      	db 0
 39458                                  
 39459                                  msg_flag:
 39460 00008E0E 00                      	db 0			;AN022; flag set if non-utility message issued
 39461                                  Msg_Numb:
 39462 00008E0F 0000                    	dw 0			;AN022; set with extended error message issued
 39463                                  append_exec:
 39464 00008E11 00                      	db 0			;AN041; set if internal append executed
 39465                                  print_err_flag:
 39466 00008E12 0000                    	dw 0			;AN000; flag set if error during sysdispmsg
 39467                                  subst_buffer:
 39468 00008E14 00<rep 16h>             	times parm_block_size*2 db 0 ; times 22 db 0 
 39469                                  				;AN061;
 39470                                  ; 15/04/2023
 39471 00008E2A 00                      KPARSE:	db 0	; 3/3/KK	
 39472                                  
 39473                                  ; Data declarations taken out of parse.asm
 39474                                  
 39475                                  ; MSDOS 6.0
 39476                                  ;arg	arg_unit	<>		; pointers, arg count, string buffer
 39477                                  ;argbufptr	dw	?		; index for argv[].argpointer
 39478                                  ;tpbuf		db	128 DUP (?)	; temporary buffer
 39479                                  ;LAST_ARG	dw	?		; point at which to accumulate switch info
 39480                                  ;comptr		dw	?		; ptr into combuf
 39481                                  
 39482                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9105h
 39483                                  ARG:
 39484                                  ARG_ARGV:
 39485                                  ARGV0_ARGPOINTER:
 39486 00008E2B 0000                    	dw 0	; ARGV[0]
 39487                                  ARGV0_ARG_FLAGS:
 39488 00008E2D 00                      	db 0
 39489                                  ARGV0_ARGSTARTEL:
 39490 00008E2E 0000                    	dw 0
 39491                                  ARGV0_ARGLEN:
 39492 00008E30 0000                    	dw 0
 39493                                  ARGV0_ARGSW_WORD:
 39494 00008E32 0000                    	dw 0
 39495                                  ARGV0_OCOMPTR:
 39496 00008E34 0000                    	dw 0
 39497                                  ARGV1_ARGPOINTER:
 39498 00008E36 0000                    	dw 0	; ARGV[1]	
 39499 00008E38 00<rep 5h>              	times 5 db 0
 39500                                  ARGV1_ARGSW_WORD:
 39501 00008E3D 0000                    	dw 0
 39502 00008E3F 0000                    	dw 0
 39503                                  ARGV2_ARGPOINTER:
 39504 00008E41 0000                    	dw 0	; ARGV[2]
 39505 00008E43 00<rep 5h>              	times 5 db 0
 39506                                  ARGV2_ARGSW_WORD:
 39507 00008E48 0000                    	dw 0
 39508 00008E4A 0000                    	dw 0
 39509 00008E4C 00<rep 29Fh>            	times 671 db 0  ; ARGV[3] to ARGV[63]
 39510                                  ARG_ARGVCNT:
 39511 000090EB 0000                    	dw 0
 39512                                  ARG_ARGSWINFO:
 39513 000090ED 0000                    	dw 0
 39514                                  ARG_ARGBUF:
 39515 000090EF 0000<rep 100h>          	times 256 dw 0	; times ARGBLEN dw 0 
 39516                                  ARG_ARGFORCOMBUF:
 39517 000092EF 00<rep 80h>             	times 128 db 0  ; times COMBUFLEN db 0 
 39518                                  
 39519                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9649h
 39520                                  ARGBUF_PTR:
 39521 0000936F 0000                    	dw 0			; index for argv[].argpointer
 39522 00009371 00<rep 80h>             TPBUF:	times 128 db 0		; temporary buffer
 39523                                  LASTARG:
 39524 000093F1 0000                    	dw 0			; point at which to accumulate switch info
 39525 000093F3 0000                    COMPTR:	dw 0			; ptr into combuf
 39526                                  
 39527                                  ; Data declarations taken out of path.asm
 39528                                  ;fbuf	find_buf	<>		; dma buffer for findfirst/findnext
 39529                                  ;pathinfo	DW	3 DUP (?)	; ES, SI(old), and SI(new) of user path
 39530                                  ;psep_char	DB	?		; '/' or '\'
 39531                                  ;search_best	DB	(?)		; best code, best filename so far
 39532                                  ;fname_max_len	equ	13
 39533                                  ;search_best_buf DB	fname_max_len DUP (?)
 39534                                  ;search_curdir_buf DB	64 DUP (?)	; a place for CurDir info, if successful
 39535                                  ;search_error	DW	(?)		; address of error message to be printed
 39536                                  
 39537                                  FINDBUFLEN equ FIND_BUF.size ; 43
 39538                                  
 39539                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 96CFh
 39540                                  
 39541 000093F5 00<rep 2Bh>             FBUF:	times FINDBUFLEN db 0	; times 43 db 0
 39542                                  FBUF_PNAME equ FBUF+30		; packed name, 13 bytes
 39543                                  pathinfo:
 39544                                  ;pathinfo_0:
 39545 00009420 0000                    	dw 0
 39546                                  ;pathinfo_2:
 39547 00009422 0000                    	dw 0
 39548                                  ;pathinfo_4:
 39549 00009424 0000                    	dw 0
 39550                                  psep_char:
 39551 00009426 00                      	db 0
 39552                                  search_best:
 39553 00009427 00                      	db 0
 39554                                  FNAME_MAX_LEN equ 13
 39555                                  search_best_buf:
 39556 00009428 00<rep Dh>              	times FNAME_MAX_LEN db 0 ; times 13 db 0
 39557                                  search_curdir_buf:
 39558 00009435 00<rep 40h>             	times 64 db 0
 39559                                  search_error:
 39560 00009475 0000                    	dw 0
 39561                                  
 39562                                  ; Data declarations taken out of tbatch.asm
 39563                                  
 39564                                  ;if_not_count	DW	?
 39565                                  ;
 39566                                  ;zflag		db	?		; Used by typefil to indicate ^Z's
 39567                                  ;
 39568                                  ;		DW	80H DUP(0)	; Init to 0 to make sure the linker is not fooled
 39569                                  
 39570                                  ; 31/03/2023
 39571                                  ;STACK:	;LABEL	WORD
 39572                                  
 39573                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9751h
 39574                                  
 39575                                  IF_NOT_COUNT:
 39576 00009477 0000                    	dw 0
 39577 00009479 00                      zflag:	db 0
 39578 0000947A 00<rep 100h>            	times 256 db 0 
 39579                                  	; 16/04/2023
 39580                                  	; MSDOS 5.0 COMMAND.COM - TRANGROUP:9854h
 39581                                  STACK:
 39582                                  
 39583                                  ;INTERNATVARS	internat_block <>
 39584                                  ;	db	(internat_block_max - ($ - INTERNATVARS)) DUP (?)
 39585                                  
 39586                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9854h
 39587                                  INTERNATVARS:
 39588                                  		; (24+8 = 32 bytes)
 39589                                  DATE_TIME_FORMAT:
 39590 0000957A 0000                    	dw 0			; 0-USA, 1-EUR, 2-JAP
 39591                                  CURRENCY_SYM:
 39592 0000957C 0000000000              	db 0,0,0,0,0 		; times 5 db 0	; Currency Symbol 5 bytes
 39593                                  THOUS_SEP:
 39594 00009581 0000                    	db 0,0			; Thousands separator 2 bytes
 39595                                  DECIMAL_SEP:
 39596 00009583 0000                    	db 0,0			; Decimal separator 2 bytes
 39597                                  DATE_SEP:
 39598 00009585 0000                    	db 0,0			; Date separator 2 bytes
 39599                                  TIME_SEP:
 39600 00009587 0000                    	db 0,0			; Time separator 2 bytes	
 39601                                  BIT_FIELD:
 39602 00009589 00                      	db 0			; Bit values
 39603                                  				;   Bit 0 = 0 if currency symbol first
 39604                                  				;	  = 1 if currency symbol last
 39605                                  				;   Bit 1 = 0 if No space after currency symbol
 39606                                  				;	  = 1 if space after currency symbol
 39607                                  CURRENCY_CENTS:
 39608 0000958A 00                      	db 0			; Number of places after currency dec point
 39609                                  TIME_24:
 39610 0000958B 00                      	db 0			; 1 if 24 hour time, 0 if 12 hour time
 39611                                  MAP_CALL:
 39612 0000958C 00000000                	dw 0,0  ; dd 0 		; Address of case mapping call (DWORD)
 39613                                  				; THIS IS TWO WORDS SO IT CAN BE INITIALIZED
 39614                                  				;  in pieces.
 39615                                  DATA_SEP:
 39616 00009590 0000                    	db 0,0			; Data list separator character		
 39617                                  
 39618 00009592 00<rep 8h>              	times 8 db 0
 39619                                  
 39620                                  ; Max size of the block returned by the INTERNATIONAL call
 39621                                  
 39622                                  INTERNAT_BLOCK_SIZE EQU	32
 39623                                  
 39624                                  ;;	Buffer for DOS function 64h (Get extended country information)
 39625                                  ;;	subfunctions 2, 4, 6, or 7:
 39626                                  ;
 39627                                  ;CountryPtrInfo	label	byte
 39628                                  ;CountryPtrId	db	?
 39629                                  ;CountryPtr	dd	?
 39630                                  ;		.erre	(($ - CountryPtrInfo) GE 5)
 39631                                  	
 39632                                  	; MSDOS 5.0 COMMAND.COM (1991) Transient portion offset 9874h
 39633                                  CountryPtrInfo:
 39634                                  CountryPtrId:	
 39635 0000959A 00                      	db 0
 39636                                  CountryPtr:
 39637 0000959B 00000000                	dd 0
 39638                                  
 39639                                  OldCtrlCHandler:
 39640 0000959F 00000000                	dd 0			; previous int 23 vector		
 39641                                  
 39642                                  BATLEN equ 32
 39643                                  
 39644                                  BATBUFPOS:
 39645 000095A3 0000                    	dw 0			; integer position in buffer of next byte
 39646                                  
 39647 000095A5 00<rep 20h>             BATBUF:	times BATLEN db 0 ; times 32 db 0
 39648                                  BATBUFEND:
 39649 000095C5 0000                    	dw 0
 39650                                  TypeFilSiz:
 39651 000095C7 00000000                	dd 0			; stores size of file to be typed
 39652                                  
 39653                                  ; *****************************************************
 39654                                  ; EMG 4.00
 39655                                  ; DATA STARTING HERE WAS ADDED BY EMG FOR 4.00
 39656                                  ; FOR IMPLEMENTATION OF COMMON PARSE ROUTINE
 39657                                  ; *****************************************************
 39658                                  ;
 39659                                  ; COMMON PARSE OUTPUT BLOCKS
 39660                                  
 39661                                  ; Common output blocks for PARSE number, complex, or string values.
 39662                                  
 39663                                  PARSE1_OUTPUT:
 39664                                  PARSE1_TYPE:
 39665 000095CB 00                      	db 0			;AN000;  type
 39666                                  PARSE1_CODE:
 39667 000095CC 00                      	db 0			;AN000;  return value
 39668                                  PARSE1_SYN:
 39669 000095CD 0000                    	dw 0			;AN000;  es offset of synonym
 39670                                  PARSE1_ADDR:
 39671 000095CF 00000000                	dd 0			;AN000;  numeric value / address
 39672                                  				;	 of string value
 39673                                  
 39674                                  ;  Common output block for PARSE date strings.
 39675                                  
 39676                                  DATE_OUTPUT:
 39677                                  DATE_TYPE:
 39678 000095D3 00                      	db 0			;AN000;  type
 39679 000095D4 00                      	db 0			;AN000;  return value
 39680 000095D5 0000                    	dw 0			;AN000;  es offset of synonym
 39681                                  DATE_YEAR:
 39682 000095D7 0000                    	dw 0			;AN000;  year
 39683                                  DATE_MONTH:
 39684 000095D9 00                      	db 0			;AN000;  month
 39685                                  DATE_DAY:
 39686 000095DA 00                      	db 0			;AN000;  day
 39687                                  
 39688                                  ;  Common output block for PARSE time strings.
 39689                                  
 39690                                  TIME_OUTPUT:
 39691                                  TIME_TYPE:
 39692 000095DB 00                      	db 0			;AN000;  type
 39693 000095DC 00                      	db 0			;AN000;  return value
 39694 000095DD 0000                    	dw 0			;AN000;  es offset of synonym
 39695                                  TIME_HOUR:
 39696 000095DF 00                      	db 0			;AN000;  hour
 39697                                  TIME_MINUTES:
 39698 000095E0 00                      	db 0			;AN000;  minutes
 39699                                  TIME_SECONDS:
 39700 000095E1 00                      	db 0			;AN000;  seconds
 39701                                  TIME_FRACTION:
 39702 000095E2 00                      	db 0			;AN000;  hundredths
 39703                                  
 39704                                  ;  Common output block for PARSE drive specifier (one based drive number).
 39705                                  
 39706                                  DRIVE_OUTPUT:
 39707                                  DRIVE_TYPE:
 39708 000095E3 00                      	db 0			;AN000;  type
 39709                                  DRIVE_VALUE:
 39710 000095E4 00                      	db 0			;AN000;  return value
 39711 000095E5 0000                    	dw 0			;AN000;  es offset of synonym
 39712                                  DRIVE_NUMBER:
 39713 000095E7 00                      	db 0			;AN000;  drive number
 39714 000095E8 000000                  	db 0,0,0		;AN000;  reserved
 39715                                  
 39716                                  	; 18/04/2023
 39717                                  	; 16/04/2023
 39718                                  ;TRANSPACEEND: ; 98C5h ; End of MSDOS 5.0 COMMAND.COM (1991) Transient portion
 39719                                  
 39720                                  ; ----------------------------------------------------------------------------
 39721                                  ; 20/04/2023
 39722                                  TRANSPACEEND equ ($-TRANSIENTSTART)	; Transient portion size
